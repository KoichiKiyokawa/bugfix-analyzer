if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)
|| (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))
if (c < (1.0e-10 * u1u1 * u2u2)) {
double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;
if (c < (1.0e-10 * u1u1 * u3u3)) {
if (c < (1.0e-10 * u2u2 * u3u3)) {
if (normProduct < 1.0e-15) {
if (squaredSine < 1.0e-12) {
double inverse = -1 / Math.sqrt(squaredSine);
return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
return 2 * Math.acos(q0);
double x00 = m[0][0];
double x01 = m[0][1];
double x02 = m[0][2];
double x10 = m[1][0];
double x11 = m[1][1];
double x12 = m[1][2];
double x20 = m[2][0];
double x21 = m[2][1];
double x22 = m[2][2];
double[][] o = new double[3][];
o[0] = new double[3];
o[1] = new double[3];
o[2] = new double[3];
double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;
double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;
double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;
double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;
double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;
double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;
double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;
double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;
double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;
o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);
o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);
o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);
o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);
o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);
o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);
o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);
o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);
o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);
double corr00 = o[0][0] - m[0][0];
double corr01 = o[0][1] - m[0][1];
double corr02 = o[0][2] - m[0][2];
double corr10 = o[1][0] - m[1][0];
double corr11 = o[1][1] - m[1][1];
double corr12 = o[1][2] - m[1][2];
double corr20 = o[2][0] - m[2][0];
double corr21 = o[2][1] - m[2][1];
double corr22 = o[2][2] - m[2][2];
+ corr10 * corr10 + corr11 * corr11 + corr12 * corr12
+ corr20 * corr20 + corr21 * corr21 + corr22 * corr22;
x00 = o[0][0];
x01 = o[0][1];
x02 = o[0][2];
x10 = o[1][0];
x11 = o[1][1];
x12 = o[1][2];
x20 = o[2][0];
x21 = o[2][1];
protected DummyStepInterpolator(DummyStepInterpolator interpolator) {
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
new String[] {
Integer.toString(equations.getDimension()),
new String[] {
new String[] {
new String[] {
Double.toString(Math.abs(t - t0))
double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))
? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));
double h1 = (maxInv2 < 1.0e-15)
? Math.max(1.0e-6, 0.001 * Math.abs(h))
: Math.pow(0.01 / maxInv2, 1.0 / order);
throw new IntegratorException("minimal step size ({0}) reached,"
+ " integration needs {1}",
new String[] {
Double.toString(minStep),
Double.toString(Math.abs(h))
public IntegratorException(String specifier, String[] parts) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
new String[] {
Integer.toString(equations.getDimension()),
new String[] {
Double.toString(Math.abs(t - t0))
Integer.toString(maxCostEval)
new String[] {
new String[] {
ConvergenceChecker checker,
double[] vertexA, double[] vertexB)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[] vertexA, double[] vertexB,
int starts, long seed)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices,
int starts, long seed)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator,
int starts)
return minimizes(f, maxEvaluations, checker);
private PointCostPair minimizes(CostFunction f, int maxEvaluations,
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 });
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);
nm.minimizes(powell, 200, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 },
private ArrayList functions;
if (yMin * yMax >= 0) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");       
return solve(min, yMin, max, yMax, min, yMin);
return new UnivariateRealSolverFactoryImpl();
package org.apache.commons.math.ode;
super(specifier, parts);
super(cause);
throw new FunctionEvaluationException(t, e);
boolean resetDerivatives = false;
resetDerivatives = true;
return resetDerivatives;
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
package org.apache.commons.math.stat.regression;
if (x.length != y.length) {
throw new IllegalArgumentException(
if (covariance == null) {
throw new IllegalArgumentException(
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
private static final long serialVersionUID = -7619974756160279127L;
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
if (Math.abs(yMin) <= functionValueAccuracy) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
return ret;
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
return new UnivariateRealSolverFactoryImpl();
return factory;
protected double imaginary;
protected double real;
public static Complex acos(Complex z) {
public static Complex asin(Complex z) {
public static Complex atan(Complex z) {
public static Complex cos(Complex z) {
public static Complex cosh(Complex z) {
public static Complex exp(Complex z) {
public static Complex log(Complex z) {
public static Complex pow(Complex y, Complex x) {
public static Complex sin(Complex z) {
public static Complex sinh(Complex z) {
public static Complex sqrt(Complex z) {
public static Complex sqrt1z(Complex z) {
public static Complex tan(Complex z) {
public static Complex tanh(Complex z) {
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
parameters   = new ArrayList();
measurements = new ArrayList();
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
public class Fraction extends Number implements Comparable {
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
protected static double TOO_SMALL = 10E-12;
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
steps = new ArrayList();
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private static final long serialVersionUID = 2259286184268533249L;
public boolean reset(double t, double[] y) {
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
functions   = new ArrayList();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
public Object[] nextSample(Collection c, int k) {
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
return new DescriptiveStatisticsImpl();
return factory;
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
public void clear() {
super.clear();
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
return new SummaryStatisticsImpl();
return instance;
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
throw new IllegalArgumentException(
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new BrentSolver(f);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
private Map certifiedValues;
certifiedValues = new HashMap();
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
package org.apache.commons.math.stat.descriptive;
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
super(name);
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
fail();
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
return suite;
return new DescriptiveStatisticsImpl();
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
List externalList = new ArrayList();
List list = new ArrayList();
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
package org.apache.commons.math.stat.descriptive;
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
return suite;
return new SummaryStatisticsImpl();
super(name);
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");       
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
private static final long serialVersionUID = -7179861704951334960L;
t4 = t4 * t4;
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
currentState      = y;
interpolatedState = new double[y.length];
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
currentState      = y;
interpolatedState = new double[y.length];
return (double[]) interpolatedState.clone();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
public void handleStep(double t, double[] y, boolean isLast);
lastTime  = Double.NaN;
lastState = null;
forward   = true;
lastState = (double[]) state.clone();
handler.handleStep(lastTime, lastState, false);
handler.handleStep(lastTime, lastState, true);
extends TestCase {
extends TestCase {
extends TestCase {
extends TestCase {
throws DerivativeException {
extends TestCase {
extends TestCase {
extends TestCase {
extends TestCase {
boolean lastStep  = false;
for (long i = 0; ! lastStep; ++i) {
boolean needUpdate = false;
needUpdate = true;
lastStep = true;
lastStep = (i == (nbStep - 1));
if (needUpdate) {
hNew = filterStep(scaledH, nextIsLast);
false);
return new UnivariateRealSolverFactoryImpl();
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
"\"", parsePosition.getErrorIndex());
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private final double x;
private final double y;
private final double z;
public boolean isNaN() {
public boolean isInfinite() {
public boolean equals(Object other) {
if (this == other) { 
return true;
return false;
if (rhs.isNaN()) {
return false;
public int hashCode() {
if (isNaN()) {
return 8;
public String toString() {
package org.apache.commons.math.geometry;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
return getInstance(Locale.getDefault());
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
ParsePosition parsePosition = new ParsePosition(0);
if (parsePosition.getIndex() == 0) {
"\"", parsePosition.getErrorIndex());
return result;
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
if (nRows == 0) {
if (nCols == 0) {
for (int r = 1; r < nRows; r++) {
lu = null;
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nSum; i++) {
BigDecimal sum = ZERO;
throws MatrixIndexException {
throws MatrixIndexException {
return data[row][column];
if (i > 0) {
package org.apache.commons.math.linear;
for (int row = Math.min(m,n)-1; row >= 0; row--) {
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
for (int i = 0; i < m; ++i) {
return false;
return true;
throw new IllegalArgumentException("Incorrect row dimension");
for (int minor = 0; minor < Math.min(m, n); minor++) {
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < row; i++) {
return x;
throw new IllegalArgumentException("Incorrect row dimension");
for (int k = 0; k < cols; ++k) {
for (int minor = 0; minor < Math.min(m, n); minor++) {
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < row; i++) {
lu = null;
if (nRows == 0) {
if (nCols == 0) {
for (int r = 1; r < nRows; r++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nSum; i++) {
double sum = 0;
throws MatrixIndexException {
throws MatrixIndexException {
return data[row][column];
throw new IllegalArgumentException("vector has wrong length");
for (int row = 0; row < nRows; row++) {
double sum = 0;
for (int i = 0; i < nCols; i++) {
out[row] = sum;
throw new IllegalArgumentException("vector has wrong length");
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nRows; i++) {
out[col] = sum;
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
throw new InvalidMatrixException("Matrix is singular.");
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int col = nCol - 1; col >= 0; col--) {
for (int i = 0; i < col; i++) {
throw new IllegalArgumentException("constant vector has wrong length");
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
throw new InvalidMatrixException("Matrix is singular.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int col = nCol - 1; col >= 0; col--) {
for (int i = 0; i < col; i++) {
if (i > 0) {
for (int col = 0; col < nCols; col++) {
package org.apache.commons.math.linear;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
double getNorm();
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws MatrixIndexException;
throws MatrixIndexException;
throws MatrixIndexException;
throws MatrixIndexException;
package org.apache.commons.math.linear;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
return getInstance(Locale.getDefault());
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
if (i > 0) {
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
ParsePosition parsePosition = new ParsePosition(0);
if (parsePosition.getIndex() == 0) {
"\"", parsePosition.getErrorIndex());
return result;
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
loop = false;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
for (int i = 0; i < data.length; ++i) {
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return data;
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
public double getNorm() {
double sum = 0;
double sum = 0;
return sum;
return max;
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
return sum;
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
return sum;
throws IllegalArgumentException {
for (int i = 0; i < data.length; ++i) {
return max;
throws IllegalArgumentException {
for (int i = 0; i < data.length; ++i) {
return max;
if (norm == 0) {
throw new ArithmeticException("null norm");
if (norm == 0) {
throw new ArithmeticException("null norm");
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return new RealMatrixImpl(out);
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return new RealMatrixImpl(out);
public int getDimension() {
return data.length;
return out;
data[index] = value;
throws MatrixIndexException {
throws IllegalArgumentException {
throws IllegalArgumentException {
public boolean isNaN() {
return true;
return false;
public boolean isInfinite() {
if (isNaN()) {
return false;
return true;
return false;
public boolean equals(Object other) {
if (this == other) { 
return true;
return false;
return false;
if (rhs.isNaN()) {
for (int i = 0; i < data.length; ++i) {
return false;
return true;
return false;
public int hashCode() {
if (isNaN()) {
package org.apache.commons.math.ode;
private final String name;
this.name = name;
public String getName() {
return name;
return true;
return false;
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
public int eventOccurred(double t, double[] y) {
public double g(double t, double[] y) {
public void resetState(double t, double[] y) {
throws DerivativeException {
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode;
double maxCheckInterval,
double convergence,
private boolean initialized;
first       = null;
initialized = false;
public boolean isEmpty() {
throws DerivativeException, IntegratorException {
first = null;
return false;
if (! initialized) {
interpolator.setInterpolatedTime(t0);
initialized = true;
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
throws IntegratorException {
public boolean stop() {
return true;
return false;
throws IntegratorException {
boolean resetDerivatives = false;
resetDerivatives = true;
return resetDerivatives;
super(specifier, parts);
super(cause);
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
return handler;
this.t0 = t0;
g0Positive = (g0 >= 0);
double ta = t0;
double ga = g0;
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
interpolator.setInterpolatedTime(t);
throw new FunctionEvaluationException(t, e);
throw new FunctionEvaluationException(t, e);
solver.setAbsoluteAccuracy(convergence);
ta = tb;
ga = gb;
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
public double getEventTime() {
return pendingEventTime;
t0 = t;
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
g0Positive = (g0 >= 0);
public boolean stop() {
if (! pendingEvent) {
return false;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
for (int i = 0; i < order; ++i) {
this.step = step;
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
handler.reset();
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
handler.handleStep(interpolator, lastStep);
System.arraycopy(interpolator.getInterpolatedState(), 0,
private static final long serialVersionUID = -7179861704951334960L;
super(interpolator);
super.storeTime(t);
throws DerivativeException {
interpolatedTime = time;
double sum = 0;
for (int i = 0; i < order; ++i) {
for (int i = 0; i < order; ++i) {
double f = 0;
throws IOException {
super.writeExternal(out);
throws IOException {
for (int i = 0; i < order; ++i) {
this.step = step;
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
handler.reset();
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
handler.handleStep(interpolator, lastStep);
System.arraycopy(interpolator.getInterpolatedState(), 0,
super(interpolator);
super.storeTime(t);
throws DerivativeException {
interpolatedTime = time;
double sum = 0;
double f = 0;
throws IOException {
super.writeExternal(out);
throws IOException {
super(name);
super(name);
throws IntegratorException {
throws DerivativeException {
if (Math.abs(h) < minStep) {
if (acceptSmall) {
new Object[] {
double t0, double[] y0,
double t, double[] y)
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
private static final long serialVersionUID = -6576285612589783992L;
public ClassicalRungeKuttaStepInterpolator() {
super(interpolator);
return new ClassicalRungeKuttaStepInterpolator(this);
throws DerivativeException {
for (int i = 0; i < interpolatedState.length; ++i) {
error += ratio * ratio;
for (int k = 0; k < d.length; ++k) {
handler.reset();
handler.handleStep(interpolator, lastStep);
Math.max(minReduction,
safety * Math.pow(error, exp)));
private static final long serialVersionUID = -7179861704951334960L;
scalAbsoluteTolerance, scalRelativeTolerance);
vecAbsoluteTolerance, vecRelativeTolerance);
handler.reset();
handler.handleStep(interpolator, lastStep);
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
super(name);
this.prototype = prototype;
throws DerivativeException, IntegratorException {
do {
this.handler = handler;
this.handler = handler;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
public boolean requiresDenseOutput() {
public void reset() {
handler.reset();
private int count;
this.n = n;
count = 0;
extends AbstractStepInterpolator {
super(interpolator);
if (interpolator.currentState != null) {
reinitialize(y, forward);
throws IOException {
writeBaseExternal(out);
for (int i = 0; i < currentState.length; ++i) {
throws IOException {
for (int k = 0; k < kMax; ++k) {
for (int i = 0; i < currentState.length; ++i) {
setInterpolatedTime(t);
throw new IOException(e.getMessage());
super(name);
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
AbstractStepInterpolator interpolator;
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
handler.reset();
interpolator.shift();
for (boolean loop = true; loop;) {
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
loop = false;
System.arraycopy(yTmp, 0, y, 0, y0.length);
handler.handleStep(interpolator, lastStep);
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
throws DerivativeException {
for (int i = 0; i < interpolatedState.length; ++i) {
throws DerivativeException {
interpolatedTime = time;
throws DerivativeException;
private double h;
private double lastTime;
private double[] lastState;
private boolean forward;
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
throws DerivativeException {
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
package org.apache.commons.math.stat.regression;
if (x.length != y.length) {
throw new IllegalArgumentException(
if (covariance == null) {
throw new IllegalArgumentException(
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
throw new IllegalArgumentException(
throw new IllegalArgumentException(
for (int i = 0; i < length; i++) {
double sum = 0;
int nCols = m.getColumnDimension();
return false;
return true;
if (n > 0) {
double dx = x - xbar;
double dy = y - ybar;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
package org.apache.commons.math.util;
protected static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
nf.setMaximumFractionDigits(2);
return nf;
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
int index = pos.getIndex();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
pos.setIndex(endIndex);
return ret;
Number number = format.parse(source, pos);
if (startIndex == endIndex) {
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
pos.setErrorIndex(startIndex);
return false;
pos.setIndex(endIndex);
return true;
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
format.format(value, toAppendTo, pos);
return toAppendTo;
package org.apache.commons.math.geometry;
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
package org.apache.commons.math.geometry;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
nf.setMaximumFractionDigits(2);
public void testSimpleNoDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
assertEquals(expected, actual);
public void testPositiveInfinity() {
assertEquals(expected, actual);
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNan() {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
fail(ex.getMessage());
fail(ex.getMessage());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
assertNotNull(cf);
public void testFormatObject() {
Object object = new Object();
cf.format(object);
fail();
package org.apache.commons.math.geometry;
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
public void testRank() {
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testSolve() {
RealMatrix m = new RealMatrixImpl(subTestData);
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
RealMatrix m = new RealMatrixImpl(subTestData);
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
for (int i = 0; i < data.length; ++i) {
package org.apache.commons.math.linear;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
nf.setMaximumFractionDigits(2);
public void testSimpleNoDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
assertEquals(expected, actual);
public void testPositiveInfinity() {
assertEquals(expected, actual);
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNan() {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
fail(ex.getMessage());
fail(ex.getMessage());
fail("wrong exception caught");
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
assertNotNull(cf);
public void testFormatObject() {
Object object = new Object();
cf.format(object);
fail();
package org.apache.commons.math.linear;
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
public double getNorm() {
public int getDimension() {
return data.length;
public boolean isNaN() {
public boolean isInfinite() {
public static Test suite() {
return suite;
public void testConstructors() {
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("Expecting ArithmeticException");
fail("wrong exception caught");
fail("Expecting ArithmeticException");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
for (int i = 0; i < m.length; i++) {
throws DerivativeException {
public int getDimension() {
return 2;
extends TestCase {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public static Test suite() {
extends TestCase {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
public static Test suite() {
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
public void handleStep(StepInterpolator interpolator, boolean isLast)
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new EulerIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException {
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
EulerIntegrator integ = new EulerIntegrator(step);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new GillIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
GillIntegrator integ = new GillIntegrator(step);
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep   = 0;
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-8;
double relTolerance = 1.0e-8;
GraggBulirschStoerIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new MidpointIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
MidpointIntegrator integ = new MidpointIntegrator(step);
super(name);
throws DerivativeException, IntegratorException {
public boolean requiresDenseOutput() {
return true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
return;
interpolator.setInterpolatedTime(t);
public void reset() {
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
private boolean firstCall = true;
public void handleStep(double t,
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
value = new Float(f);
value = new Integer(i);
value = new Long(l);
dynaBean.set(propertyName, new Double(v));
VitalStats vs1 = new VitalStats( new Double(120.0), 
new Double(96.4) );
Patient p1 = new Patient( vs1, new Integer( 35 ) );
VitalStats vs2 = new VitalStats( new Double(70.0), 
new Double(97.4) );
Patient p2 = new Patient( vs2, new Integer( 23 ) );
VitalStats vs3 = new VitalStats( new Double(90.0), 
new Double(98.6) );
Patient p3 = new Patient( vs3, new Integer( 42 ) );
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
new Integer(dimension1), new Integer(dimension2)
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
private static final long serialVersionUID = -7619974756160279127L;
new Object[] { new Double(argument) });
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
new Object[] { new Integer(maxIterations) });
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
return new UnivariateRealSolverFactoryImpl();
return factory;
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
new Double(initial), new Double(lowerBound), new Double(upperBound),
new Double(a), new Double(b), new Double(fa), new Double(fb) });
protected double imaginary;
protected double real;
public class ComplexFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
public ComplexFormat(NumberFormat realFormat,
NumberFormat imaginaryFormat) {
public static String formatComplex( Complex c ) {
return getInstance().format( c );
throw new IllegalArgumentException(
"Cannot format given Object as a Date");
private StringBuffer formatDouble(double value, NumberFormat format,
StringBuffer toAppendTo, FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
format.format(value, toAppendTo, pos);
return toAppendTo;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
private static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
"\"", parsePosition.getErrorIndex());
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
getImaginaryCharacter()) != 0) {
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
pos.setIndex(endIndex);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(String source, double value, ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
int n = sb.length();
int startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = new Double(value);
pos.setIndex(endIndex);
return ret;
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
int endIndex = pos.getIndex();
if (startIndex == endIndex) {
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
public static Complex acos(Complex z) {
public static Complex asin(Complex z) {
public static Complex atan(Complex z) {
public static Complex cos(Complex z) {
public static Complex cosh(Complex z) {
public static Complex exp(Complex z) {
public static Complex log(Complex z) {
public static Complex pow(Complex y, Complex x) {
public static Complex sin(Complex z) {
public static Complex sinh(Complex z) {
public static Complex sqrt(Complex z) {
public static Complex sqrt1z(Complex z) {
public static Complex tan(Complex z) {
public static Complex tanh(Complex z) {
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
parameters   = new ArrayList();
measurements = new ArrayList();
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
public class Fraction extends Number implements Comparable {
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
new Object[] { new Double(value), new Integer(maxIterations) });
public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
private BigDecimal data[][] = null;
private BigDecimal lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
int nRows = d.length;
int nCols = d[0].length;
int nRows = d.length;
int nCols = d[0].length;
int nRows = v.length;
return new BigMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(d);
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].multiply(d);
return new BigMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
BigDecimal sum = ZERO;
sum = ZERO;
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
outData[row][col] = sum;
return new BigMatrixImpl(outData);
int nRows = getRowDimension();
int nCols = getColumnDimension();
double d[][] = new double[nRows][nCols];
for (int j=0; j<nCols;j++) {
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
selectedColumns.length);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out);
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out);
int ncols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[ncols];
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
BigDecimal[] out = new BigDecimal[nRows];
int nrows = this.getRowDimension();
double[] out = new double[nrows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
BigDecimal[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createBigIdentityMatrix
(this.getRowDimension()));
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[v.length];
BigDecimal bd[] = new BigDecimal[v.length];
for (int i=0;i<bd.length;i++) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[nCols];
int nRows = this.getRowDimension();
BigMatrix bMatrix = new BigMatrixImpl(b);
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
BigDecimal[] out = new BigDecimal[nRows];
BigDecimal bd[] = new BigDecimal[b.length];
for (int i=0;i<bd.length;i++) {
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
BigMatrixImpl outMat = new BigMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
if (i > 0)
if (j > 0)
BigMatrix m = (BigMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (!data[row][col].equals(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
data[row][col].hashCode();
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
double[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? 1d : 0d;
return out;
int nCols = rowData.length;
double[][] data = new double[1][nCols];
return new RealMatrixImpl(data);
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nCols = rowData.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data);
int nCols = rowData.length;
String[][] data = new String[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
return new RealMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
int nRows = columnData.length;
BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data);
String[][] data = new String[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
BigDecimal[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return out;
public interface QRDecomposition {
public abstract RealMatrix getR();
public abstract RealMatrix getQ();
private double[][] qr;
private double[] rDiag;
private int m;
private int n;
xNormSqr += qr[row][minor]*qr[row][minor];
double a = Math.sqrt(xNormSqr);
if (qr[minor][minor] > 0) a = -a;
for (int col = minor+1; col < n; col++) {
alpha -= qr[row][col]*qr[row][minor];
alpha /= a*qr[minor][minor];
qr[row][col] -= alpha*qr[row][minor];
public RealMatrix getR()
RealMatrixImpl ret = new RealMatrixImpl(m,n);
double[][] r = ret.getDataRef();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
r[row][row] = rDiag[row];
for (int col = row+1; col < n; col++) {
r[row][col] = qr[row][col];
return ret;
public RealMatrix getQ()
RealMatrixImpl ret = new RealMatrixImpl(m,m);
double[][] Q = ret.getDataRef();
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
return ret;
private static final long serialVersionUID = 4237564493130426188L;
private double data[][] = null;
private double lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static double TOO_SMALL = 10E-12;
this.copyIn(d);
int nRows = v.length;
return new RealMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + m.getEntry(row, col);
return new RealMatrixImpl(outData);
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] - m.getEntry(row, col);
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + d;
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] * d;
return new RealMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
double[][] outData = new double[nRows][nCols];
double sum = 0;
sum = 0;
sum += data[row][i] * m.getEntry(i, col);
outData[row][col] = sum;
return new RealMatrixImpl(outData);
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
endColumn > data[0].length ) {
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
double[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
selectedColumns.length);
double[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out);
int nRows = this.getRowDimension();
double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out);
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
double[] out = new double[nRows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
double[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createRealIdentityMatrix
(this.getRowDimension()));
if (v.length != this.getColumnDimension()) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[v.length];
sum += data[row][i] * v[i];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[nCols];
int nRows = this.getRowDimension();
RealMatrix bMatrix = new RealMatrixImpl(b);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
double[] out = new double[nRows];
out[row] = solution[row][0];
return out;
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
double[][] bp = new double[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] -= bp[col][j] * lu[i][col];
bp[col][j] /= lu[col][col];
bp[i][j] -= bp[col][j] * lu[i][col];
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
lu = this.getData();
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
lu[row][col] /= lu[col][col];
if (i > 0)
if (j > 0)
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (Double.doubleToLongBits(data[row][col]) != 
int nRows = getRowDimension();
int nCols = getColumnDimension();
for (int col = 0; col < nCols; col++) {
MathUtils.hash(data[row][col]);
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
double[][] out = new double[nRows][this.getColumnDimension()];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
package org.apache.commons.math.ode;
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
protected AbstractStepInterpolator(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
protected void reinitialize(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
public void storeTime(double t) {
public void setInterpolatedTime(double time)
throws DerivativeException {
interpolatedTime = time;
double oneMinusThetaH = currentTime - interpolatedTime;
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
return (double[]) interpolatedState.clone();
protected void writeBaseExternal(ObjectOutput out)
protected double readBaseExternal(ObjectInput in)
int dimension = in.readInt();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
package org.apache.commons.math.ode;
implements FirstOrderIntegrator {
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public void setInitialStepSize(double initialStepSize) {
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
public double initializeStep(FirstOrderDifferentialEquations equations,
boolean forward, int order, double[] scale,
double t0, double[] y0, double[] yDot0,
double[] y1, double[] yDot1)
throws DerivativeException {
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
protected double filterStep(double h, boolean acceptSmall)
if (Math.abs(h) < minStep) {
if (acceptSmall) {
h = (h < 0) ? -minStep : minStep;
new Object[] {
if (h > maxStep) {
h = maxStep;
h = -maxStep;
return h;
public abstract void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
protected StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
private static final String methodName = "classical Runge-Kutta";
public ClassicalRungeKuttaIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
double coeff23   = s * (( fourTheta - 2) * theta - 2);
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
private static final long serialVersionUID = -6576285612589783992L;
steps = new ArrayList();
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
double current  = lastInterpolator.getCurrentTime();
double previous = lastInterpolator.getPreviousTime();
double step = current - previous;
double gap = model.getInitialTime() - current;
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
public void handleStep(StepInterpolator interpolator, boolean isLast)
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public void setInterpolatedTime(double time) {
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
int location = locatePoint(time, si);
int iMed = (iMin + iMax) / 2;
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
double d12 = tMax - tMed;
double d23 = tMed - tMin;
double d13 = tMax - tMin;
double dt1 = time - tMax;
double dt2 = time - tMed;
double dt3 = time - tMin;
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private int locatePoint(double time, StepInterpolator interval) {
private static final long serialVersionUID = 2259286184268533249L;
public DerivativeException(String specifier, String[] parts) {
public DerivativeException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public DormandPrince54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode;
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
double eta = oneMinusThetaH / h;
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public DormandPrince853Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio1  = errSum1 / tol;
double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode;
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
int dimension = interpolator.currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
int dimension = currentState.length;
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
double eta = oneMinusThetaH / h;
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
int dimension = in.readInt();
package org.apache.commons.math.ode;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
package org.apache.commons.math.ode;
protected DummyStepInterpolator(double[] y, boolean forward) {
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
package org.apache.commons.math.ode;
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double   minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public abstract String getName();
public void setSafety(double safety) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
boolean forward = (t > t0);
int stages = c.length + 1;
double[][] yDotK = new double[stages][];
double[] yTmp = new double[y0.length];
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
boolean lastStep;
handler.reset();
do {
double[] scale;
if (switchesHandler.evaluateStep(interpolator)) {
double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
if (switchesHandler.stop()) {
lastStep = true;
handler.handleStep(interpolator, lastStep);
double  factor     = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, nextIsLast);
public void setMinReduction(double minReduction) {
public void setMaxGrowth(double maxGrowth) {
package org.apache.commons.math.ode;
private static final String methodName = "Euler";
public EulerIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
private static final long serialVersionUID = -7179861704951334960L;
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations {
public interface FirstOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
public void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode;
public interface FixedStepHandler {
public void handleStep(double t, double[] y, boolean isLast);
package org.apache.commons.math.ode;
private static final String methodName = "Gill";
public GillIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public GillStepInterpolator(GillStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double soMt      = s * (1 - theta);
double c23       = soMt * (1 + 2 * theta);
double coeff1    = soMt * (1 - fourTheta);
double coeff2    = c23  * tMq;
double coeff3    = c23  * tPq;
double coeff4    = s * (1 + theta * (1 + fourTheta));
package org.apache.commons.math.ode;
private static final String methodName = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public void setStabilityCheck(boolean performTest,
int maxIter, int maxChecks,
double stabilityReduction) {
public void setStepsizeControl(double stepControl1, double stepControl2,
double stepControl3, double stepControl4) {
public void setOrderControl(int maxOrder,
double orderControl1, double orderControl2) {
public void setStepHandler (StepHandler handler) {
super.setStepHandler(handler);
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int size = maxOrder / 2;
double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(boolean useInterpolationError,
int mudif) {
public String getName() {
return methodName;
private void rescale(double[] y1, double[] y2, double[] scale) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double step, int k,
double[] scale, double[][] f,
double[] yMiddle, double[] yEnd,
double[] yTmp)
int    n        = sequence[k];
double subStep  = step / n;
double subStep2 = 2 * subStep;
double middle = yEnd[i];
double ratio = f[0][l] / scale[l];
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
boolean forward = (t > t0);
double[] yDot0   = new double[y0.length];
double[] y1      = new double[y0.length];
double[] yTmp    = new double[y0.length];
double[] yTmpDot = new double[y0.length];
double[][] diagonal = new double[sequence.length-1][];
double[][] y1Diag = new double[sequence.length-1][];
double[][][] fk  = new double[sequence.length][][];
double[] scale = new double[y0.length];
if (denseOutput || (! switchesHandler.isEmpty())) {
handler.reset();
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
double exp = 1.0 / (2 * k + 1);
double pow = Math.pow(stepControl3, exp);
double ratio = ((double) sequence[k+1]) / sequence[0];
int mu = 2 * k - mudif + 3;
int l2 = l / 2;
GraggBulirschStoerStepInterpolator gbsInterpolator
double interpError = gbsInterpolator.estimateError(scale);
if (switchesHandler.evaluateStep(interpolator)) {
if (switchesHandler.stop()) {
handler.handleStep(interpolator, lastStep);
false);
false);
package org.apache.commons.math.ode;
private void resetTables(int maxDegree) {
double[][] newPols = new double[maxDegree + 1][];
int ip5 = i + 5;
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double[] y1, double[] y1Dot,
double[][] yMidDots,
boolean forward) {
(GraggBulirschStoerStepInterpolator interpolator) {
int dimension = currentState.length;
public void computeCoefficients(int mu, double h) {
double yp0   = h * y0Dot[i];
double yp1   = h * y1Dot[i];
double ydiff = y1[i] - currentState[i];
double aspl  = ydiff - yp1;
double bspl  = yp0 - ydiff;
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
double ph1 = ydiff + 0.25 * (aspl - bspl);
double ph2 = yp1 - yp0;
double ph3 = 6 * (bspl - aspl);
double fac1 = 0.5 * j * (j - 1);
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(double[] scale) {
double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
int dimension = currentState.length;
double oneMinusTheta = 1.0 - theta;
double theta05       = theta - 0.5;
double t4            = theta * oneMinusTheta;
t4 = t4 * t4;
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
public void writeExternal(ObjectOutput out)
int dimension = currentState.length;
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int dimension = currentState.length;
int degree = in.readInt();
package org.apache.commons.math.ode;
private static final String methodName = "Higham-Hall 5(4)";
public HighamHall54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public HighamHall54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio  = h * errSum / tol;
package org.apache.commons.math.ode;
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double theta2 = theta * theta;
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
package org.apache.commons.math.ode;
private static final String methodName = "midpoint";
public MidpointIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double coeff1 = oneMinusThetaH * theta;
double coeff2 = oneMinusThetaH * (1.0 + theta);
package org.apache.commons.math.ode;
public abstract class RungeKuttaIntegrator
implements FirstOrderIntegrator {
RungeKuttaStepInterpolator prototype,
double step) {
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
handler         = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public abstract String getName();
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
boolean lastStep  = false;
handler.reset();
for (long i = 0; ! lastStep; ++i) {
interpolator.shift();
boolean needUpdate = false;
for (boolean loop = true; loop;) {
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
if (switchesHandler.evaluateStep(interpolator)) {
needUpdate = true;
loop = false;
System.arraycopy(yTmp, 0, y, 0, y0.length);
if (switchesHandler.stop()) {
lastStep = true;
lastStep = (i == (nbStep - 1));
handler.handleStep(interpolator, lastStep);
if (needUpdate) {
i = -1;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
private StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
int dimension = currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int kMax = in.readInt();
public interface SecondOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
package org.apache.commons.math.ode;
public interface StepHandler {
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
public class StepNormalizer
implements StepHandler {
public StepNormalizer(double h, FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime  = Double.NaN;
lastState = null;
forward   = true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
double nextTime;
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, true);
private double h;
private FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private boolean forward;
package org.apache.commons.math.ode;
class SwitchState implements Serializable {
private SwitchingFunction function;
private double maxCheckInterval;
private double convergence;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = SwitchingFunction.CONTINUE;
this.t0 = t0;
g0 = function.g(t0, y0);
g0Positive = (g0 >= 0);
double t1 = interpolator.getCurrentTime();
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
double gb = function.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return function.g(t, interpolator.getInterpolatedState());
throw new FunctionEvaluationException(t, e);
solver.setAbsoluteAccuracy(convergence);
double root = solver.solve(ta, tb);
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
public double getEventTime() {
return pendingEventTime;
t0 = t;
g0 = function.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = function.eventOccurred(t, y);
g0Positive = (g0 >= 0);
nextAction = SwitchingFunction.CONTINUE;
public boolean stop() {
return nextAction == SwitchingFunction.STOP;
public boolean reset(double t, double[] y) {
if (! pendingEvent) {
return false;
if (nextAction == SwitchingFunction.RESET_STATE) {
function.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
package org.apache.commons.math.ode;
public interface SwitchingFunction extends Serializable {
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
package org.apache.commons.math.ode;
public class SwitchingFunctionsHandler {
public SwitchingFunctionsHandler() {
functions   = new ArrayList();
first       = null;
initialized = false;
public boolean isEmpty() {
return functions.isEmpty();
throws DerivativeException, IntegratorException {
first = null;
if (functions.isEmpty()) {
return false;
if (! initialized) {
double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
double [] y = interpolator.getInterpolatedState();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
initialized = true;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
throws IntegratorException {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
public boolean stop() {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
return true;
return false;
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private SwitchState first;
private boolean initialized;
package org.apache.commons.math.ode;
private static final String methodName = "3/8";
public ThreeEighthesIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta2 = 4 * theta * theta;
double s          = oneMinusThetaH / 8.0;
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
double coeff2     = 3 * s * (1 + theta - fourTheta2);
double coeff3     = 3 * s * (1 + theta);
double coeff4     = s * (1 + theta + fourTheta2);
for (int i = 0; i < interpolatedState.length; ++i) {
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
val = new Double(str).doubleValue();
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
double delta = (max - min)/(new Double(binCount)).doubleValue();
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
Integer c = new Integer(randomBytes[i]);
Integer c = new Integer(hash[i]);
public Object[] nextSample(Collection c, int k) {
obj = new Long(((Integer) v).longValue());
freqTable.put(obj, new Long(1));
freqTable.put(obj, new Long(count.longValue() + 1));
addValue(new Long(v));
addValue(new Long(v.longValue()));
addValue(new Long(v));
addValue(new Character(v));
return getCount(new Long(v));
return getCount(new Long(v));
return getCount(new Character(v));
return getPct(new Long(v));       
return getPct(new Long(v));         
return getPct(new Character(v));         
return getCumFreq(new Long(v));       
return getCumFreq(new Long(v));         
return getCumFreq(new Character(v));         
return getCumPct(new Long(v));       
return getCumPct(new Long(v));         
return getCumPct(new Character(v));         
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
return new DescriptiveStatisticsImpl();
return factory;
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
public void clear() {
super.clear();
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
return new SummaryStatisticsImpl();
return instance;
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
throw new IllegalArgumentException(
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
new Object[] { new Double(x) });
new Object[] { new Double(x) });
return new Double(o.toString()).doubleValue();
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(new double[] { 0.0 });
return new Double(newA);
return new Double();
return new Double(newA);
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
ComplexFormat complexFormat = null;
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = new Double(Math.PI);
ComplexFormat cf = new ComplexFormat();
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
assertFalse(zero.equals(new Double(0)));
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
assertEquals(m2,m);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData4x3);
matrix = new RealMatrixImpl(testData3x4);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
assertEquals(m2,m);
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
assertClose("inverse-operate",mInv.operate(testVector),
m.solve(testVector),normTolerance);
double[] x = m.operate(testVector);
assertClose("identity operate",testVector,x,entryTolerance);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
package org.apache.commons.math.ode;
double step = (pb.getFinalTime() - pb.getInitialTime())
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
integ.setStepHandler(cm);
throws DerivativeException {
public int getDimension() {
return 2;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 2900);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(DummyStepHandler.getInstance());
integ.setStepHandler(new InterpolatingStepHandler());
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
throws DerivativeException {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerStepHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerStepHandler(pb));
integ.setStepHandler(new VariableStepHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(new StepNormalizer(range / 10.0,
private boolean firstCall = true;
integ.setStepHandler(new StepNormalizer(range / 10.5,
public void handleStep(double t,
package org.apache.commons.math.ode;
implements FirstOrderDifferentialEquations, SwitchingFunction {
package org.apache.commons.math.ode;
class TestProblem1
package org.apache.commons.math.ode;
class TestProblem2
package org.apache.commons.math.ode;
class TestProblem3
package org.apache.commons.math.ode;
class TestProblem4
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[] { new Bounce(), new Stop() };
private static class Bounce implements SwitchingFunction {
return SwitchingFunction.RESET_STATE;
private static class Stop implements SwitchingFunction {
return SwitchingFunction.STOP;
package org.apache.commons.math.ode;
class TestProblem5
package org.apache.commons.math.ode;
abstract class TestProblemAbstract
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[0];
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
f.addValue(new Integer(1));
f.addValue(new Long(1));
f.addValue(new Integer(-1));
assertEquals("1 count", 3, f.getCount(new Integer(1)));
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
obj1 = new Integer(1);
Integer int1 = new Integer(1);
f.addValue(new Long(2));
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
private Map certifiedValues;
certifiedValues = new HashMap();
Double value = new Double(valueString);
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
package org.apache.commons.math.stat.descriptive;
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
super(name);
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
fail();
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
return suite;
return new DescriptiveStatisticsImpl();
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
list.add(new Double(v));
List externalList = new ArrayList();
List list = new ArrayList();
list.add( new Double(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
u.addObject(new Integer(12));
u.addObject(new Long(21));
u.addObject(new Float(14.1));
u.addObject(new Double(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
assertFalse("wrong type", u.equals(new Double(0)));
package org.apache.commons.math.stat.descriptive;
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
return suite;
return new SummaryStatisticsImpl();
super(name);
Double input = new Double(expected);
Integer input = new Integer(1);
return new UnivariateRealSolverFactoryImpl();
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
"\"", parsePosition.getErrorIndex());
package org.apache.commons.math.distribution;
void setAlpha(double alpha);
double getAlpha();
void setBeta(double beta);
double getBeta();
package org.apache.commons.math.distribution;
private double alpha;
private double beta;
this.alpha = alpha;
this.beta = beta;
public void setAlpha(double alpha) {
this.alpha = alpha;
public double getAlpha() {
return alpha;
public void setBeta(double beta) {
this.beta = beta;
public double getBeta() {
return beta;
return 0;
return 0;
return 0;
public double inverseCumulativeProbability(double p) throws MathException {
if (p == 0) {
return 0;
return 1;
return super.inverseCumulativeProbability(p);
protected double getInitialDomain(double p) {
return p;
protected double getDomainLowerBound(double p) {
return 0;
protected double getDomainUpperBound(double p) {
return 1;
public double cumulativeProbability(double x) throws MathException {
return 0;
return 1;
return cumulativeProbability(x1) - cumulativeProbability(x0);
if (x < 0) {
return 0;
public class FDistributionImpl
extends AbstractContinuousDistribution
implements FDistribution, Serializable  {
private static final long serialVersionUID = -8516354193418641566L;
private double numeratorDegreesOfFreedom;
private double denominatorDegreesOfFreedom;
public FDistributionImpl(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
super();
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();
ret = Beta.regularizedBeta((n * x) / (m + n * x),
0.5 * n,
0.5 * m);
return ret;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return getDenominatorDegreesOfFreedom() /
(getDenominatorDegreesOfFreedom() - 2.0);
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.denominatorDegreesOfFreedom = degreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
package org.apache.commons.math.distribution;
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private final double x;
private final double y;
private final double z;
public boolean isNaN() {
public boolean isInfinite() {
public boolean equals(Object other) {
if (this == other) { 
return true;
return false;
if (rhs.isNaN()) {
return false;
public int hashCode() {
if (isNaN()) {
return 8;
public String toString() {
package org.apache.commons.math.geometry;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
return getInstance(Locale.getDefault());
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
ParsePosition parsePosition = new ParsePosition(0);
if (parsePosition.getIndex() == 0) {
"\"", parsePosition.getErrorIndex());
return result;
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
double alpha = 0;
double xNormSqr = 0;
if (a != 0.0) {
double alpha = 0;
double xNormSqr = 0;
if (a != 0.0) {
double alpha = 0;
if (nRows == 0) {
if (nCols == 0) {
for (int r = 1; r < nRows; r++) {
lu = null;
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nSum; i++) {
BigDecimal sum = ZERO;
throws MatrixIndexException {
throws MatrixIndexException {
return data[row][column];
if (i > 0) {
package org.apache.commons.math.linear;
package org.apache.commons.math.linear;
package org.apache.commons.math.linear;
throw new InvalidMatrixException("LU decomposition requires that the matrix be square.");
parity = 1;
double sum = 0;
for (int row = 0; row < col; row++) {
for (int i = 0; i < row; i++) {
int max = col; // permutation row
for (int i = 0; i < col; i++) {
if (Math.abs(sum) > largest) {
largest = Math.abs(sum);
max = row;
return;
if (max != col) {
double tmp = 0;
tmp = lu[max][i];
lu[max][i] = lu[col][i];
lu[col][i] = tmp;
parity = -parity;
for (int i = 0; i < m; ++i) {
for (int i = 0; i < m; ++i) {
for (int i = 0; i < m; ++i) {
return 0;
return determinant;
throw new IllegalArgumentException("constant vector has wrong length");
throw new InvalidMatrixException("Matrix is singular.");
for (int i = 0; i < col; i++) {
throw new IllegalArgumentException("constant vector has wrong length");
throw new InvalidMatrixException("Matrix is singular.");
for (int i = 0; i < col; i++) {
throw new IllegalArgumentException("Incorrect row dimension");
throw new InvalidMatrixException("Matrix is singular.");
for (int col = 0; col < nColB; col++) {
for (int j = 0; j < nColB; j++) {
for (int j = 0; j < nColB; j++) {
for (int i = 0; i < col; i++) {
for (int j = 0; j < nColB; j++) {
if (lu == null) {
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < m; ++i) {
return false;
return true;
throw new IllegalArgumentException("Incorrect row dimension");
for (int minor = 0; minor < Math.min(m, n); minor++) {
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < row; i++) {
return x;
throw new IllegalArgumentException("Incorrect row dimension");
for (int k = 0; k < cols; ++k) {
for (int minor = 0; minor < Math.min(m, n); minor++) {
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < row; i++) {
lu = null;
if (nRows == 0) {
if (nCols == 0) {
for (int r = 1; r < nRows; r++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
throw new IllegalArgumentException("matrix dimension mismatch");
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nSum; i++) {
double sum = 0;
throws MatrixIndexException {
throws MatrixIndexException {
return data[row][column];
throw new IllegalArgumentException("vector has wrong length");
for (int row = 0; row < nRows; row++) {
double sum = 0;
for (int i = 0; i < nCols; i++) {
out[row] = sum;
throw new IllegalArgumentException("vector has wrong length");
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nRows; i++) {
out[col] = sum;
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
throw new InvalidMatrixException("Matrix is singular.");
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int col = nCol - 1; col >= 0; col--) {
for (int i = 0; i < col; i++) {
throw new IllegalArgumentException("constant vector has wrong length");
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
throw new InvalidMatrixException("Matrix is singular.");
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int col = nCol - 1; col >= 0; col--) {
for (int i = 0; i < col; i++) {
if (i > 0) {
for (int col = 0; col < nCols; col++) {
package org.apache.commons.math.linear;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
double getNorm();
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws IllegalArgumentException;
throws MatrixIndexException;
throws MatrixIndexException;
throws MatrixIndexException;
throws MatrixIndexException;
package org.apache.commons.math.linear;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
return getInstance(Locale.getDefault());
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
if (i > 0) {
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
ParsePosition parsePosition = new ParsePosition(0);
if (parsePosition.getIndex() == 0) {
"\"", parsePosition.getErrorIndex());
return result;
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
return null;
parseAndIgnoreWhitespace(source, pos);
loop = false;
parseAndIgnoreWhitespace(source, pos);
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
return null;
for (int i = 0; i < data.length; ++i) {
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
return this;
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return data;
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
public double getNorm() {
double sum = 0;
double sum = 0;
return sum;
return max;
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
return sum;
throws IllegalArgumentException {
double sum = 0;
for (int i = 0; i < data.length; ++i) {
return sum;
throws IllegalArgumentException {
for (int i = 0; i < data.length; ++i) {
return max;
throws IllegalArgumentException {
for (int i = 0; i < data.length; ++i) {
return max;
if (norm == 0) {
throw new ArithmeticException("null norm");
if (norm == 0) {
throw new ArithmeticException("null norm");
for (int i = 0; i < data.length; i++) {
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return new RealMatrixImpl(out);
throws IllegalArgumentException {
for (int i = 0; i < data.length; i++) {
return new RealMatrixImpl(out);
public int getDimension() {
return data.length;
return out;
data[index] = value;
throws MatrixIndexException {
throws IllegalArgumentException {
throws IllegalArgumentException {
public boolean isNaN() {
return true;
return false;
public boolean isInfinite() {
if (isNaN()) {
return false;
return true;
return false;
public boolean equals(Object other) {
if (this == other) { 
return true;
return false;
return false;
if (rhs.isNaN()) {
for (int i = 0; i < data.length; ++i) {
return false;
return true;
return false;
public int hashCode() {
if (isNaN()) {
package org.apache.commons.math.ode;
private final String name;
this.name = name;
public String getName() {
return name;
return true;
return false;
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
public int eventOccurred(double t, double[] y) {
public double g(double t, double[] y) {
public void resetState(double t, double[] y) {
throws DerivativeException {
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode;
double maxCheckInterval,
double convergence,
private boolean initialized;
first       = null;
initialized = false;
public boolean isEmpty() {
throws DerivativeException, IntegratorException {
first = null;
return false;
if (! initialized) {
interpolator.setInterpolatedTime(t0);
initialized = true;
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
throws IntegratorException {
public boolean stop() {
return true;
return false;
throws IntegratorException {
boolean resetDerivatives = false;
resetDerivatives = true;
return resetDerivatives;
super(specifier, parts);
super(cause);
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
return handler;
this.t0 = t0;
g0Positive = (g0 >= 0);
double ta = t0;
double ga = g0;
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
interpolator.setInterpolatedTime(t);
throw new FunctionEvaluationException(t, e);
throw new FunctionEvaluationException(t, e);
solver.setAbsoluteAccuracy(convergence);
ta = tb;
ga = gb;
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
public double getEventTime() {
return pendingEventTime;
t0 = t;
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
g0Positive = (g0 >= 0);
public boolean stop() {
if (! pendingEvent) {
return false;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
for (int i = 0; i < order; ++i) {
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
handler.reset();
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
handler.handleStep(interpolator, lastStep);
System.arraycopy(interpolator.getInterpolatedState(), 0,
private static final long serialVersionUID = -7179861704951334960L;
super(interpolator);
super.storeTime(t);
throws DerivativeException {
interpolatedTime = time;
double sum = 0;
for (int i = 0; i < order; ++i) {
for (int i = 0; i < order; ++i) {
double f = 0;
throws IOException {
super.writeExternal(out);
throws IOException {
for (int i = 0; i < order; ++i) {
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
handler.reset();
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
handler.handleStep(interpolator, lastStep);
System.arraycopy(interpolator.getInterpolatedState(), 0,
super(interpolator);
super.storeTime(t);
throws DerivativeException {
interpolatedTime = time;
double sum = 0;
double f = 0;
throws IOException {
super.writeExternal(out);
throws IOException {
super(name);
super(name);
throws IntegratorException {
throws DerivativeException {
if (Math.abs(h) < minStep) {
if (acceptSmall) {
new Object[] {
double t0, double[] y0,
double t, double[] y)
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
private static final long serialVersionUID = -6576285612589783992L;
public ClassicalRungeKuttaStepInterpolator() {
super(interpolator);
return new ClassicalRungeKuttaStepInterpolator(this);
throws DerivativeException {
for (int i = 0; i < interpolatedState.length; ++i) {
error += ratio * ratio;
for (int k = 0; k < d.length; ++k) {
handler.reset();
handler.handleStep(interpolator, lastStep);
Math.max(minReduction,
safety * Math.pow(error, exp)));
private static final long serialVersionUID = -7179861704951334960L;
scalAbsoluteTolerance, scalRelativeTolerance);
vecAbsoluteTolerance, vecRelativeTolerance);
handler.reset();
handler.handleStep(interpolator, lastStep);
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
super(name);
this.prototype = prototype;
throws DerivativeException, IntegratorException {
do {
this.handler = handler;
this.handler = handler;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
public boolean requiresDenseOutput() {
public void reset() {
handler.reset();
private int count;
this.n = n;
count = 0;
extends AbstractStepInterpolator {
super(interpolator);
if (interpolator.currentState != null) {
reinitialize(y, forward);
throws IOException {
writeBaseExternal(out);
for (int i = 0; i < currentState.length; ++i) {
throws IOException {
for (int k = 0; k < kMax; ++k) {
for (int i = 0; i < currentState.length; ++i) {
setInterpolatedTime(t);
throw new IOException(e.getMessage());
super(name);
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
throws DerivativeException, IntegratorException {
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
AbstractStepInterpolator interpolator;
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
handler.reset();
interpolator.shift();
for (boolean loop = true; loop;) {
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
loop = false;
System.arraycopy(yTmp, 0, y, 0, y0.length);
handler.handleStep(interpolator, lastStep);
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
throws DerivativeException {
for (int i = 0; i < interpolatedState.length; ++i) {
throws DerivativeException {
interpolatedTime = time;
throws DerivativeException;
private double h;
private double lastTime;
private double[] lastState;
private boolean forward;
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
throws DerivativeException {
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
package org.apache.commons.math.stat.regression;
if (x.length != y.length) {
throw new IllegalArgumentException(
if (covariance == null) {
throw new IllegalArgumentException(
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
throw new IllegalArgumentException(
throw new IllegalArgumentException(
for (int i = 0; i < length; i++) {
double sum = 0;
int nCols = m.getColumnDimension();
return false;
return true;
if (n > 0) {
double dx = x - xbar;
double dy = y - ybar;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
package org.apache.commons.math.util;
protected static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
nf.setMaximumFractionDigits(2);
return nf;
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
int index = pos.getIndex();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
pos.setIndex(endIndex);
return ret;
Number number = format.parse(source, pos);
if (startIndex == endIndex) {
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
pos.setErrorIndex(startIndex);
return false;
pos.setIndex(endIndex);
return true;
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
format.format(value, toAppendTo, pos);
return toAppendTo;
package org.apache.commons.math.distribution;
for (int i = 0; i < x.length; i++) {
for (int i = 0; i < x.length; i++) {
for (int i = 0; i < x.length; i++) {
0.990d, 0.975d, 0.950d, 0.900d};
for (int i = 0; i < x.length; i++) {
for (int i = 0; i < x.length; i++) {
package org.apache.commons.math.geometry;
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
package org.apache.commons.math.geometry;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
nf.setMaximumFractionDigits(2);
public void testSimpleNoDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
assertEquals(expected, actual);
public void testPositiveInfinity() {
assertEquals(expected, actual);
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNan() {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
fail(ex.getMessage());
fail(ex.getMessage());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
assertNotNull(cf);
public void testFormatObject() {
Object object = new Object();
cf.format(object);
fail();
package org.apache.commons.math.geometry;
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
super(name);
public void testDimensions() {
for (int i = 0; i < rows; ++i) {
for (int j = 0; j < cols; ++j) {
public static Test suite() {
package org.apache.commons.math.linear;
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
package org.apache.commons.math.linear;
private static final double entryTolerance = 10e-16;
private static final double normTolerance = 10e-14;
super(name);
public static Test suite() {
return suite;
public void testDimensions() {
fail("wrong exception caught");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testSolve() {
public void testDeterminant() {
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
public void testRank() {
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testSolve() {
fail("wrong exception caught");
RealMatrix m = new RealMatrixImpl(subTestData);
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
RealMatrix m = new RealMatrixImpl(subTestData);
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
for (int i = 0; i < data.length; ++i) {
package org.apache.commons.math.linear;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
nf.setMaximumFractionDigits(2);
public void testSimpleNoDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
assertEquals(expected, actual);
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
assertEquals(expected, actual);
public void testPositiveInfinity() {
assertEquals(expected, actual);
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimals() {
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNan() {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
fail(ex.getMessage());
fail(ex.getMessage());
fail("wrong exception caught");
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
assertNotNull(cf);
public void testFormatObject() {
Object object = new Object();
cf.format(object);
fail();
package org.apache.commons.math.linear;
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
for (int i = 0; i < data.length; i++) {
for (int i = 0; i < data.length; i++) {
public double getNorm() {
public int getDimension() {
return data.length;
public boolean isNaN() {
public boolean isInfinite() {
public static Test suite() {
return suite;
public void testConstructors() {
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
fail("Expecting ArithmeticException");
fail("wrong exception caught");
fail("Expecting ArithmeticException");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
fail("IllegalArgumentException expected");
fail("wrong exception caught");
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
for (int i = 0; i < m.length; i++) {
throws DerivativeException {
public int getDimension() {
return 2;
extends TestCase {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public static Test suite() {
extends TestCase {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
throws DerivativeException, IntegratorException {
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public static Test suite() {
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-7);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new EulerIntegrator(step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new EulerIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException {
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
EulerIntegrator integ = new EulerIntegrator(step);
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new GillIntegrator(step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new GillIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
GillIntegrator integ = new GillIntegrator(step);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep   = 0;
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-8;
double relTolerance = 1.0e-8;
GraggBulirschStoerIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new MidpointIntegrator(step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new MidpointIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
MidpointIntegrator integ = new MidpointIntegrator(step);
super(name);
throws DerivativeException, IntegratorException {
public boolean requiresDenseOutput() {
return true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
return;
interpolator.setInterpolatedTime(t);
public void reset() {
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
public void handleStep(StepInterpolator interpolator, boolean isLast) {
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
public int getDimension() {
return 1;
throws DerivativeException, IntegratorException {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
private boolean firstCall = true;
public void handleStep(double t,
for (int i = 0; i < 10; i++) {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.regression;
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
package org.apache.commons.math.stat.regression;
private double[] y;
super.setUp();
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
SimpleRegression regression = new SimpleRegression();
value = new Float(f);
value = new Integer(i);
value = new Long(l);
dynaBean.set(propertyName, new Double(v));
VitalStats vs1 = new VitalStats( new Double(120.0), 
new Double(96.4) );
Patient p1 = new Patient( vs1, new Integer( 35 ) );
VitalStats vs2 = new VitalStats( new Double(70.0), 
new Double(97.4) );
Patient p2 = new Patient( vs2, new Integer( 23 ) );
VitalStats vs3 = new VitalStats( new Double(90.0), 
new Double(98.6) );
Patient p3 = new Patient( vs3, new Integer( 42 ) );
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
new Integer(dimension1), new Integer(dimension2)
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
private static final long serialVersionUID = -7619974756160279127L;
new Object[] { new Double(argument) });
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
new Object[] { new Integer(maxIterations) });
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
return new UnivariateRealSolverFactoryImpl();
return factory;
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
new Double(initial), new Double(lowerBound), new Double(upperBound),
new Double(a), new Double(b), new Double(fa), new Double(fb) });
protected double imaginary;
protected double real;
ret = (Double.doubleToRawLongBits(real) ==
Double.doubleToRawLongBits(rhs.getReal())) &&
(Double.doubleToRawLongBits(imaginary) ==
Double.doubleToRawLongBits(rhs.getImaginary())); 
public class ComplexFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
public ComplexFormat(NumberFormat realFormat,
NumberFormat imaginaryFormat) {
public static String formatComplex( Complex c ) {
return getInstance().format( c );
throw new IllegalArgumentException(
"Cannot format given Object as a Date");
private StringBuffer formatDouble(double value, NumberFormat format,
StringBuffer toAppendTo, FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
format.format(value, toAppendTo, pos);
return toAppendTo;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
private static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
"\"", parsePosition.getErrorIndex());
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
getImaginaryCharacter()) != 0) {
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
pos.setIndex(endIndex);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(String source, double value, ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
int n = sb.length();
int startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = new Double(value);
pos.setIndex(endIndex);
return ret;
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
int endIndex = pos.getIndex();
if (startIndex == endIndex) {
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
public static Complex acos(Complex z) {
public static Complex asin(Complex z) {
public static Complex atan(Complex z) {
public static Complex cos(Complex z) {
public static Complex cosh(Complex z) {
public static Complex exp(Complex z) {
public static Complex log(Complex z) {
public static Complex pow(Complex y, Complex x) {
public static Complex sin(Complex z) {
public static Complex sinh(Complex z) {
public static Complex sqrt(Complex z) {
public static Complex sqrt1z(Complex z) {
public static Complex tan(Complex z) {
public static Complex tanh(Complex z) {
public interface ChiSquaredDistribution extends ContinuousDistribution {
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
public interface ExponentialDistribution extends ContinuousDistribution {
private static final long serialVersionUID = -8516354193418641566L;
private double numeratorDegreesOfFreedom;
private double denominatorDegreesOfFreedom;
public FDistributionImpl(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
super();
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();
return ret;
public double inverseCumulativeProbability(final double p)
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return ret;
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.denominatorDegreesOfFreedom = degreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
public interface GammaDistribution extends ContinuousDistribution {
public interface NormalDistribution extends ContinuousDistribution {
parameters   = new ArrayList();
measurements = new ArrayList();
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
public class Fraction extends Number implements Comparable {
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
new Object[] { new Double(value), new Integer(maxIterations) });
public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
private BigDecimal data[][] = null;
private BigDecimal lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
int nRows = d.length;
int nCols = d[0].length;
int nRows = d.length;
int nCols = d[0].length;
int nRows = v.length;
return new BigMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(d);
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].multiply(d);
return new BigMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
BigDecimal sum = ZERO;
sum = ZERO;
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
outData[row][col] = sum;
return new BigMatrixImpl(outData);
int nRows = getRowDimension();
int nCols = getColumnDimension();
double d[][] = new double[nRows][nCols];
for (int j=0; j<nCols;j++) {
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
selectedColumns.length);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out);
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out);
int ncols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[ncols];
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
BigDecimal[] out = new BigDecimal[nRows];
int nrows = this.getRowDimension();
double[] out = new double[nrows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
BigDecimal[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createBigIdentityMatrix
(this.getRowDimension()));
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[v.length];
BigDecimal bd[] = new BigDecimal[v.length];
for (int i=0;i<bd.length;i++) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[nCols];
int nRows = this.getRowDimension();
BigMatrix bMatrix = new BigMatrixImpl(b);
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
BigDecimal[] out = new BigDecimal[nRows];
BigDecimal bd[] = new BigDecimal[b.length];
for (int i=0;i<bd.length;i++) {
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
BigMatrixImpl outMat = new BigMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
if (i > 0)
if (j > 0)
BigMatrix m = (BigMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (!data[row][col].equals(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
data[row][col].hashCode();
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
double[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? 1d : 0d;
return out;
int nCols = rowData.length;
double[][] data = new double[1][nCols];
return new RealMatrixImpl(data);
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nCols = rowData.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data);
int nCols = rowData.length;
String[][] data = new String[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
return new RealMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
int nRows = columnData.length;
BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data);
String[][] data = new String[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
BigDecimal[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return out;
public interface QRDecomposition {
public abstract RealMatrix getR();
public abstract RealMatrix getQ();
private double[][] qr;
private int m;
private int n;
m = matrix.getRowDimension();
n = matrix.getColumnDimension();
qr = matrix.getData();
xNormSqr += qr[row][minor]*qr[row][minor];
double a = Math.sqrt(xNormSqr);
if (qr[minor][minor] > 0) a = -a;
qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])
alpha -= qr[row][col]*qr[row][minor];
alpha /= a*qr[minor][minor];
qr[row][col] -= alpha*qr[row][minor];
RealMatrixImpl ret = new RealMatrixImpl(m,n);
double[][] r = ret.getDataRef();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
r[row][row] = rDiag[row];
for (int col = row+1; col < n; col++) {
r[row][col] = qr[row][col];
return ret;
public RealMatrix getQ()
RealMatrixImpl ret = new RealMatrixImpl(m,m);
double[][] Q = ret.getDataRef();
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
return ret;
private static final long serialVersionUID = 4237564493130426188L;
private double data[][] = null;
private double lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static double TOO_SMALL = 10E-12;
this.copyIn(d);
int nRows = v.length;
return new RealMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + m.getEntry(row, col);
return new RealMatrixImpl(outData);
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] - m.getEntry(row, col);
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + d;
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] * d;
return new RealMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
double[][] outData = new double[nRows][nCols];
double sum = 0;
sum = 0;
sum += data[row][i] * m.getEntry(i, col);
outData[row][col] = sum;
return new RealMatrixImpl(outData);
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
endColumn > data[0].length ) {
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
double[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
selectedColumns.length);
double[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out);
int nRows = this.getRowDimension();
double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out);
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
double[] out = new double[nRows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
double[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createRealIdentityMatrix
(this.getRowDimension()));
if (v.length != this.getColumnDimension()) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[v.length];
sum += data[row][i] * v[i];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[nCols];
int nRows = this.getRowDimension();
RealMatrix bMatrix = new RealMatrixImpl(b);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
double[] out = new double[nRows];
out[row] = solution[row][0];
return out;
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
double[][] bp = new double[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] -= bp[col][j] * lu[i][col];
bp[col][j] /= lu[col][col];
bp[i][j] -= bp[col][j] * lu[i][col];
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
lu = this.getData();
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
lu[row][col] /= lu[col][col];
if (i > 0)
if (j > 0)
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (Double.doubleToLongBits(data[row][col]) != 
Double.doubleToLongBits(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
for (int col = 0; col < nCols; col++) {
MathUtils.hash(data[row][col]);
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
double[][] out = new double[nRows][this.getColumnDimension()];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
package org.apache.commons.math.ode;
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
protected AbstractStepInterpolator(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
protected void reinitialize(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
public void storeTime(double t) {
public void setInterpolatedTime(double time)
throws DerivativeException {
interpolatedTime = time;
double oneMinusThetaH = currentTime - interpolatedTime;
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
return (double[]) interpolatedState.clone();
protected void writeBaseExternal(ObjectOutput out)
protected double readBaseExternal(ObjectInput in)
int dimension = in.readInt();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
package org.apache.commons.math.ode;
implements FirstOrderIntegrator {
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
this.minStep     = minStep;
this.maxStep     = maxStep;
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public void setInitialStepSize(double initialStepSize) {
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
public double initializeStep(FirstOrderDifferentialEquations equations,
boolean forward, int order, double[] scale,
double t0, double[] y0, double[] yDot0,
double[] y1, double[] yDot1)
throws DerivativeException {
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
protected double filterStep(double h, boolean acceptSmall)
if (Math.abs(h) < minStep) {
if (acceptSmall) {
h = (h < 0) ? -minStep : minStep;
new Object[] {
if (h > maxStep) {
h = maxStep;
h = -maxStep;
return h;
public abstract void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
protected StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
private static final String methodName = "classical Runge-Kutta";
public ClassicalRungeKuttaIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
double coeff23   = s * (( fourTheta - 2) * theta - 2);
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
private static final long serialVersionUID = -6576285612589783992L;
steps = new ArrayList();
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
double current  = lastInterpolator.getCurrentTime();
double previous = lastInterpolator.getPreviousTime();
double step = current - previous;
double gap = model.getInitialTime() - current;
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
public void handleStep(StepInterpolator interpolator, boolean isLast)
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public void setInterpolatedTime(double time) {
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
int location = locatePoint(time, si);
int iMed = (iMin + iMax) / 2;
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
double d12 = tMax - tMed;
double d23 = tMed - tMin;
double d13 = tMax - tMin;
double dt1 = time - tMax;
double dt2 = time - tMed;
double dt3 = time - tMin;
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private int locatePoint(double time, StepInterpolator interval) {
private static final long serialVersionUID = 2259286184268533249L;
public DerivativeException(String specifier, String[] parts) {
public DerivativeException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public DormandPrince54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode;
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
double eta = oneMinusThetaH / h;
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public DormandPrince853Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio1  = errSum1 / tol;
double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode;
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
int dimension = interpolator.currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
int dimension = currentState.length;
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
double eta = oneMinusThetaH / h;
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
int dimension = in.readInt();
package org.apache.commons.math.ode;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
package org.apache.commons.math.ode;
protected DummyStepInterpolator(double[] y, boolean forward) {
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
package org.apache.commons.math.ode;
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double   minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public abstract String getName();
public void setSafety(double safety) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
boolean forward = (t > t0);
int stages = c.length + 1;
double[][] yDotK = new double[stages][];
double[] yTmp = new double[y0.length];
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
boolean lastStep;
handler.reset();
do {
double[] scale;
if (switchesHandler.evaluateStep(interpolator)) {
double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
if (switchesHandler.stop()) {
lastStep = true;
handler.handleStep(interpolator, lastStep);
double  factor     = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, nextIsLast);
public void setMinReduction(double minReduction) {
public void setMaxGrowth(double maxGrowth) {
package org.apache.commons.math.ode;
private static final String methodName = "Euler";
public EulerIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
private static final long serialVersionUID = -7179861704951334960L;
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations {
public interface FirstOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
public void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode;
public interface FixedStepHandler {
public void handleStep(double t, double[] y, boolean isLast);
package org.apache.commons.math.ode;
private static final String methodName = "Gill";
public GillIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public GillStepInterpolator(GillStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double soMt      = s * (1 - theta);
double c23       = soMt * (1 + 2 * theta);
double coeff1    = soMt * (1 - fourTheta);
double coeff2    = c23  * tMq;
double coeff3    = c23  * tPq;
double coeff4    = s * (1 + theta * (1 + fourTheta));
package org.apache.commons.math.ode;
private static final String methodName = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public void setStabilityCheck(boolean performTest,
int maxIter, int maxChecks,
double stabilityReduction) {
public void setStepsizeControl(double stepControl1, double stepControl2,
double stepControl3, double stepControl4) {
public void setOrderControl(int maxOrder,
double orderControl1, double orderControl2) {
public void setStepHandler (StepHandler handler) {
super.setStepHandler(handler);
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int size = maxOrder / 2;
double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(boolean useInterpolationError,
int mudif) {
public String getName() {
return methodName;
private void rescale(double[] y1, double[] y2, double[] scale) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double step, int k,
double[] scale, double[][] f,
double[] yMiddle, double[] yEnd,
double[] yTmp)
int    n        = sequence[k];
double subStep  = step / n;
double subStep2 = 2 * subStep;
double middle = yEnd[i];
double ratio = f[0][l] / scale[l];
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
boolean forward = (t > t0);
double[] yDot0   = new double[y0.length];
double[] y1      = new double[y0.length];
double[] yTmp    = new double[y0.length];
double[] yTmpDot = new double[y0.length];
double[][] diagonal = new double[sequence.length-1][];
double[][] y1Diag = new double[sequence.length-1][];
double[][][] fk  = new double[sequence.length][][];
double[] scale = new double[y0.length];
if (denseOutput || (! switchesHandler.isEmpty())) {
handler.reset();
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
double exp = 1.0 / (2 * k + 1);
double pow = Math.pow(stepControl3, exp);
double ratio = ((double) sequence[k+1]) / sequence[0];
int mu = 2 * k - mudif + 3;
int l2 = l / 2;
GraggBulirschStoerStepInterpolator gbsInterpolator
double interpError = gbsInterpolator.estimateError(scale);
if (switchesHandler.evaluateStep(interpolator)) {
if (switchesHandler.stop()) {
handler.handleStep(interpolator, lastStep);
false);
false);
package org.apache.commons.math.ode;
private void resetTables(int maxDegree) {
double[][] newPols = new double[maxDegree + 1][];
int ip5 = i + 5;
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double[] y1, double[] y1Dot,
double[][] yMidDots,
boolean forward) {
(GraggBulirschStoerStepInterpolator interpolator) {
int dimension = currentState.length;
public void computeCoefficients(int mu, double h) {
double yp0   = h * y0Dot[i];
double yp1   = h * y1Dot[i];
double ydiff = y1[i] - currentState[i];
double aspl  = ydiff - yp1;
double bspl  = yp0 - ydiff;
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
double ph1 = ydiff + 0.25 * (aspl - bspl);
double ph2 = yp1 - yp0;
double ph3 = 6 * (bspl - aspl);
double fac1 = 0.5 * j * (j - 1);
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(double[] scale) {
double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
int dimension = currentState.length;
double oneMinusTheta = 1.0 - theta;
double theta05       = theta - 0.5;
double t4            = theta * oneMinusTheta;
t4 = t4 * t4;
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
public void writeExternal(ObjectOutput out)
int dimension = currentState.length;
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int dimension = currentState.length;
int degree = in.readInt();
package org.apache.commons.math.ode;
private static final String methodName = "Higham-Hall 5(4)";
public HighamHall54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
public HighamHall54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double ratio  = h * errSum / tol;
package org.apache.commons.math.ode;
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double theta2 = theta * theta;
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
package org.apache.commons.math.ode;
private static final String methodName = "midpoint";
public MidpointIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double coeff1 = oneMinusThetaH * theta;
double coeff2 = oneMinusThetaH * (1.0 + theta);
package org.apache.commons.math.ode;
public abstract class RungeKuttaIntegrator
implements FirstOrderIntegrator {
RungeKuttaStepInterpolator prototype,
double step) {
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
handler         = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public abstract String getName();
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
new Object[] {
new Object[] {
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
boolean lastStep  = false;
handler.reset();
for (long i = 0; ! lastStep; ++i) {
interpolator.shift();
boolean needUpdate = false;
for (boolean loop = true; loop;) {
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
if (switchesHandler.evaluateStep(interpolator)) {
needUpdate = true;
loop = false;
System.arraycopy(yTmp, 0, y, 0, y0.length);
if (switchesHandler.stop()) {
lastStep = true;
lastStep = (i == (nbStep - 1));
handler.handleStep(interpolator, lastStep);
if (needUpdate) {
i = -1;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
private StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
int dimension = currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int kMax = in.readInt();
public interface SecondOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
package org.apache.commons.math.ode;
public interface StepHandler {
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
public class StepNormalizer
implements StepHandler {
public StepNormalizer(double h, FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime  = Double.NaN;
lastState = null;
forward   = true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
double nextTime;
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, true);
private double h;
private FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private boolean forward;
package org.apache.commons.math.ode;
class SwitchState implements Serializable {
private SwitchingFunction function;
private double maxCheckInterval;
private double convergence;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = SwitchingFunction.CONTINUE;
this.t0 = t0;
g0 = function.g(t0, y0);
g0Positive = (g0 >= 0);
double t1 = interpolator.getCurrentTime();
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
double gb = function.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return function.g(t, interpolator.getInterpolatedState());
throw new FunctionEvaluationException(t, e);
solver.setAbsoluteAccuracy(convergence);
double root = solver.solve(ta, tb);
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
public double getEventTime() {
return pendingEventTime;
t0 = t;
g0 = function.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = function.eventOccurred(t, y);
g0Positive = (g0 >= 0);
nextAction = SwitchingFunction.CONTINUE;
public boolean stop() {
return nextAction == SwitchingFunction.STOP;
public boolean reset(double t, double[] y) {
if (! pendingEvent) {
return false;
if (nextAction == SwitchingFunction.RESET_STATE) {
function.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
package org.apache.commons.math.ode;
public interface SwitchingFunction extends Serializable {
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
package org.apache.commons.math.ode;
public class SwitchingFunctionsHandler {
public SwitchingFunctionsHandler() {
functions   = new ArrayList();
first       = null;
initialized = false;
public boolean isEmpty() {
return functions.isEmpty();
throws DerivativeException, IntegratorException {
first = null;
if (functions.isEmpty()) {
return false;
if (! initialized) {
double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
double [] y = interpolator.getInterpolatedState();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
initialized = true;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
throws IntegratorException {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
public boolean stop() {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
return true;
return false;
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private SwitchState first;
private boolean initialized;
package org.apache.commons.math.ode;
private static final String methodName = "3/8";
public ThreeEighthesIntegrator(double step) {
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta2 = 4 * theta * theta;
double s          = oneMinusThetaH / 8.0;
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
double coeff2     = 3 * s * (1 + theta - fourTheta2);
double coeff3     = 3 * s * (1 + theta);
double coeff4     = s * (1 + theta + fourTheta2);
for (int i = 0; i < interpolatedState.length; ++i) {
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
val = new Double(str).doubleValue();
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
double delta = (max - min)/(new Double(binCount)).doubleValue();
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
Integer c = new Integer(randomBytes[i]);
Integer c = new Integer(hash[i]);
public Object[] nextSample(Collection c, int k) {
obj = new Long(((Integer) v).longValue());
freqTable.put(obj, new Long(1));
freqTable.put(obj, new Long(count.longValue() + 1));
addValue(new Long(v));
addValue(new Long(v.longValue()));
addValue(new Long(v));
addValue(new Character(v));
return getCount(new Long(v));
return getCount(new Long(v));
return getCount(new Character(v));
return getPct(new Long(v));       
return getPct(new Long(v));         
return getPct(new Character(v));         
return getCumFreq(new Long(v));       
return getCumFreq(new Long(v));         
return getCumFreq(new Character(v));         
return getCumPct(new Long(v));       
return getCumPct(new Long(v));         
return getCumPct(new Character(v));         
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
return new DescriptiveStatisticsImpl();
return factory;
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
public void clear() {
super.clear();
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
return new SummaryStatisticsImpl();
return instance;
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
throw new IllegalArgumentException(
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
new Object[] { new Double(x) });
new Object[] { new Double(x) });
return new Double(o.toString()).doubleValue();
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(new double[] { 0.0 });
return new Double(newA);
return new Double();
return new Double(newA);
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
ComplexFormat complexFormat = null;
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = new Double(Math.PI);
ComplexFormat cf = new ComplexFormat();
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
0.990d, 0.975d, 0.950d, 0.900d}; 
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
assertFalse(zero.equals(new Double(0)));
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
assertEquals(m2,m);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData4x3);
matrix = new RealMatrixImpl(testData3x4);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
assertEquals(m2,m);
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
assertClose("inverse-operate",mInv.operate(testVector),
m.solve(testVector),normTolerance);
double[] x = m.operate(testVector);
assertClose("identity operate",testVector,x,entryTolerance);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
package org.apache.commons.math.ode;
double step = (pb.getFinalTime() - pb.getInitialTime())
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
integ.setStepHandler(cm);
throws DerivativeException {
public int getDimension() {
return 2;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 2900);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(DummyStepHandler.getInstance());
integ.setStepHandler(new InterpolatingStepHandler());
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
throws DerivativeException {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerStepHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerStepHandler(pb));
integ.setStepHandler(new VariableStepHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(new StepNormalizer(range / 10.0,
private boolean firstCall = true;
integ.setStepHandler(new StepNormalizer(range / 10.5,
public void handleStep(double t,
package org.apache.commons.math.ode;
implements FirstOrderDifferentialEquations, SwitchingFunction {
package org.apache.commons.math.ode;
class TestProblem1
package org.apache.commons.math.ode;
class TestProblem2
package org.apache.commons.math.ode;
class TestProblem3
package org.apache.commons.math.ode;
class TestProblem4
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[] { new Bounce(), new Stop() };
private static class Bounce implements SwitchingFunction {
return SwitchingFunction.RESET_STATE;
private static class Stop implements SwitchingFunction {
return SwitchingFunction.STOP;
package org.apache.commons.math.ode;
class TestProblem5
package org.apache.commons.math.ode;
abstract class TestProblemAbstract
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[0];
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
f.addValue(new Integer(1));
f.addValue(new Long(1));
f.addValue(new Integer(-1));
assertEquals("1 count", 3, f.getCount(new Integer(1)));
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
obj1 = new Integer(1);
Integer int1 = new Integer(1);
f.addValue(new Long(2));
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
private Map certifiedValues;
certifiedValues = new HashMap();
Double value = new Double(valueString);
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
package org.apache.commons.math.stat.descriptive;
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
super(name);
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
fail();
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
return suite;
return new DescriptiveStatisticsImpl();
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
list.add(new Double(v));
List externalList = new ArrayList();
List list = new ArrayList();
list.add( new Double(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
u.addObject(new Integer(12));
u.addObject(new Long(21));
u.addObject(new Float(14.1));
u.addObject(new Double(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
assertFalse("wrong type", u.equals(new Double(0)));
package org.apache.commons.math.stat.descriptive;
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
super(name);
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
StatisticalSummary summary = u.getSummary();
u.addValue(1d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
u.addValue(2d);
summary = u.getSummary();
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
return suite;
return new SummaryStatisticsImpl();
super(name);
Double input = new Double(expected);
Integer input = new Integer(1);
public interface RealMatrix {
public interface RandomData {
return false;
RealMatrix m = new RealMatrixImpl(subTestData);
public RealMatrix getQ()
throw new IllegalArgumentException("Incorrect row dimension");
throw new IllegalArgumentException("Incorrect row dimension");
for (int k = 0; k < cols; ++k) {
for (int row = minor; row < m; row++) {
for (int row = minor; row < m; row++) {
for (int i = 0; i < row; i++) {
throws ConvergenceException, FunctionEvaluationException;
throws ConvergenceException, FunctionEvaluationException;
public interface SecondOrderDifferentialEquations {
target = new double[]{y[1], 1d, 0d, 0d};
double target[] = {y[0], 1d, 0d, 0d};
target = new double[]{y[1], 1d, 0d, 0d};
while (iter.hasNext()) {
while (iter.hasNext()) {
return res;
for (int i = 0; i < v.length; i++) {
return res;
while (iter.hasNext()) {
return res;
return res;
for (int i = 0; i < a.length; i++) {
return res;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return null;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return res;
public int getDimension() {
while (iter.hasNext()) {
double delta;
while (iter.hasNext()) {
for (int i = 0; i < v.length; i++) {
while (iter.hasNext()) {
while (iter.hasNext()) {
return max;
for (int i = 0; i < v.length; i++) {
return max;
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
while (iter.hasNext()) {
return max;
for (int i = 0; i < v.length; i++) {
return max;
while (iter.hasNext()) {
return max;
public double getNorm() {
while (iter.hasNext()) {
public boolean isInfinite() {
while (iter.hasNext()) {
return true;
return false;
public boolean isNaN() {
while (iter.hasNext()) {
return true;
return false;
while (iter.hasNext()) {
return this;
return this;
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
while (iter.hasNext()) {
return this;
return res;
throws IllegalArgumentException {
return res;
while (iter.hasNext()) {
return res;
for (int i = 0; i < v.length; i++) {
while (iter.hasNext()) {
return res;
for (int i = 0; i < v.length; i++) {
return res;
return res;
null);
while (iter.hasNext()) {
throw new MatrixIndexException(
while (iter.hasNext()) {
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("Incorrect row dimension");
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("Incorrect row dimension");
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
"Argument {0} outside domain [{1} ; {2}]",
private static final long serialVersionUID = 4380655778005469702L;
public ConvergenceException(String pattern, Object[] arguments) {
public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
super("dimension mismatch {0} != {1}",
new Object[] {
super("Evaluation failed for argument = {0}",
String pattern, Object[] arguments) {
public FunctionEvaluationException(double argument, Throwable cause) {
public FunctionEvaluationException(double argument,
String pattern, Object[] arguments,
Throwable cause) {
super(pattern, arguments, cause);
public MathConfigurationException(String pattern, Object[] arguments) {
public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
private static String buildMessage(String pattern, Object[] arguments, Locale locale) {
public MathException(String pattern, Object[] arguments) {
super(buildMessage(pattern, arguments, Locale.US));
public MathException(String pattern, Object[] arguments, Throwable rootCause) {
super(buildMessage(pattern, arguments, Locale.US));
private static final long serialVersionUID = -2154780004193976271L;
private int maxIterations;
public MaxIterationsExceededException(int maxIterations) {
super("Maximal number of iterations ({0}) exceeded",
public MaxIterationsExceededException(int maxIterations,
String pattern, Object[] arguments) {
throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);
new Object[] {
null);
null);
throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);
null);
null);
new Object[] {
Integer.toString(m.length),
Integer.toString(m[0].length)
new Object[] {
Double.toString(det)
new Object[] {
Integer.toString(i - 1)
null);
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
throw new IllegalArgumentException("matrix is not square");
if (v.length != this.getColumnDimension()) {
throw new IllegalArgumentException("vector has wrong length");
throw new IllegalArgumentException("vector has wrong length");
throw new IllegalArgumentException("constant vector has wrong length");
if (b.getRowDimension() != this.getRowDimension()) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!this.isSquare()) {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
new Object[] {
null);
null);
null);
new Object[] {
new Object[] {
new Object[] {
new Object[] {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
private static final long serialVersionUID = -4100440615830558122L;
throw new FunctionEvaluationException(t, e);
throw new FunctionEvaluationException(t, e);
new Object[] {
new Object[] {
new Object[] {
public CostException(String pattern, Object[] arguments) {
new Object[] {
Integer.toString(starts)
null);
new Object[] {
null);
null);
new Object[] {
new Object[] {
null);
null);
null);
null);
throw new MathException("Conversion Exception in Transformation: {0}",
new Object[] { e.getMessage() }, e);
null);
null);
null);
String msg =
"Contraction criteria can never be smaller than " +
"the expansion factor.  This would lead to a never " +
"ending loop of expansion and contraction as a newly " +
"expanded internal storage array would immediately " +
"satisfy the criteria for contraction";
throw new IllegalArgumentException(msg);
String msg =
"The contraction criteria must be a number larger " +
"than one.  If the contractionCriteria is less than or " +
"equal to one an endless loop of contraction and " +
"expansion would ensue as an internalArray.length " +
"== numElements would satisfy the contraction criteria";
throw new IllegalArgumentException(msg);
String msg =
"The expansion factor must be a number greater than 1.0";
throw new IllegalArgumentException(msg);
String msg = "Cannot discard more elements than are" +
"contained in this array.";
throw new IllegalArgumentException(msg);
String msg = "Cannot discard a negative number of elements.";
throw new IllegalArgumentException(msg);
throw new IllegalArgumentException("Illegal expansionMode setting.");  
String msg =
"The initial capacity supplied: " + initialCapacity +
"must be a positive integer";
throw new IllegalArgumentException(msg);
String msg =
"Number of elements must be zero or a positive " + "integer";
throw new IllegalArgumentException(msg);
ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);
MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);
MathException ex = new MathException(pattern, arguments, cause);
private int n;
throw new CostException("{0}", new Object[] { "oops"});
throw new CostException("{0}", new Object[] { "oops"});
implements RandomVectorGenerator {
public interface NormalizedRandomGenerator {
public interface RandomVectorGenerator {
return true;
return false;
throws IllegalArgumentException {
for (int i = 0; i < currentState.length; ++i) {
yDotKLast[0] = new double[dimension];
yDotKLast[1] = new double[dimension];
yDotKLast[2] = new double[dimension];
out.writeInt(yDotK.length);
for (int k = 0; k < yDotK.length; ++k) {
for (int i = 0; i < currentState.length; ++i) {
yDotK = new double[kMax][];
yDotK[k] = new double[currentState.length];
for (int i = 0; i < currentState.length; ++i) {
setInterpolatedTime(t);
out.writeInt(currentState.length);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(currentState[i]);
currentState  = new double[dimension];
for (int i = 0; i < currentState.length; ++i) {
currentState[i] = in.readDouble();
throw new NotPositiveDefiniteMatrixException();
super(name);
public static Test suite() {
return suite;
fail("wrong exception caught");
fail("wrong exception caught");
fail("wrong exception caught");
for (int j = 0; j < y0.length; ++j) {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
previousError = error;
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
IOException, ClassNotFoundException {
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
for (int l = 0; l < functions.length; ++l) {
pb.getFinalTime(), new double[pb.getDimension()]);
previousError = error;
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
throws DerivativeException, IntegratorException {
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (++iterations > maxIterations) {
if (++iterations > maxIterations) {
if (++iterations > maxIterations) {
throws IOException {
float contractionCritera,
if (contractionCritera < expansionFactor) {
this.contractionCriteria = contractionCriteria;
this.expansionFactor = expansionFactor;
this.expansionMode = expansionMode;
public int hashCode() {
public double getA() {
public double getB() {
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
fail("Expecting MatrixIndexException");
public Object clone() {
public Object clone() {
public Object clone() {
public Object clone() {
public Object clone() {
implements FirstOrderDifferentialEquations, Cloneable {
public abstract Object clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblem1 pb2 = (TestProblem1) pb1.clone();
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
super();
super(y, forward);
protected void doFinalize()
throws DerivativeException {
optimum =
public int getN() {
return points.size();
private class PointModel extends WeightedMeasurement {
public PointModel(double px, double py) {
if (parameter == cx) {
return getPartialDiX() - getPartialRadiusX();
return getPartialDiY() - getPartialRadiusY();
double dx = px - cx.getEstimate();
double dy = py - cy.getEstimate();
return (cx.getEstimate() - px) / getCenterDistance();
return (cy.getEstimate() - py) / getCenterDistance();
return getCenterDistance() - getRadius();
points.add(new PointModel(px, py));
private class PointModel extends WeightedMeasurement {
public PointModel(double px, double py) {
if (parameter == cx) {
return getPartialDiX() - getPartialRadiusX();
return getPartialDiY() - getPartialRadiusY();
double dx = px - cx.getEstimate();
double dy = py - cy.getEstimate();
return (cx.getEstimate() - px) / getCenterDistance();
return (cy.getEstimate() - py) / getCenterDistance();
return getCenterDistance() - getRadius();
measurements[i] = new MinpackMeasurement(i);
private class MinpackMeasurement extends WeightedMeasurement {
public MinpackMeasurement(int index) {
return getResiduals()[index];
for (int j = 0; j < n; ++j) {
if (parameter == parameters[j]) {
fail("Expecting InvalidMatrixException");
m.getTrace().doubleValue();
public void testBracketCornerSolution() throws MathException {
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); 
fail("Expecting ConvergenceException");
package org.apache.commons.math.util;
private int size;
return 1;
return true;
return false;
return true;
return false;
while (true) {
break;
while (true) {
public int size() {
++count;
if (index < 0) {
++count;
private int next;
public boolean hasNext() {
throws IOException, ClassNotFoundException {
count = 0;
package org.apache.commons.math.linear;
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
fail("IllegalArgumentException expected");
fail("wrong exception caught");
if (m.length != n.length) {
for (int i = 0; i < m.length; i++) {
if (m.length != n.length) {
for (int i = 0; i < m.length; i++) {
for (int i = 0; i < coefficients.length; i++) {
"pas minimal ({0}) atteint, l''int\u00e9gration n\u00e9cessite {1}" },
return true;
throws IllegalArgumentException {
throws IllegalArgumentException {
throws IllegalArgumentException {
throws IllegalArgumentException {
while (iter.hasNext()) {
return res;
while (iter.hasNext()) {
return max;
public double getNorm() {
while (iter.hasNext()) {
for (int j = 0; j < n; ++j) {
for (int j = 0; j < n; ++j) {
throw new SingularMatrixException();
throw new SingularMatrixException();
throw new SingularMatrixException();
for (int j = 0; j < b.getColumnDimension(); ++j) {
throw new SingularMatrixException();
super(name);
public static Test suite() {
return suite;
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
private double sigma;
break;
break;
break;
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
--j;
return list;
return;
break;
for (boolean loop = true; loop;) {
loop = false;
return false;
return true;
return false;
return true;
for (int i = 0; i < n; ++i) {
break;
break;
++count;
return;
return;
return;
return;
return;
break;
return;
break;
return;
break;
break;
return;
return;
break;
break;
return;
return;
break;
break;
for (int i = 0; i < m; ++i) {
for (int i = 0; i < m; ++i) {
throws IllegalArgumentException {
throws IllegalArgumentException {
throws IllegalArgumentException {
for (int j = 0; j < n; j++) {
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
for (int i = 0; i < n; ++i) {
y = new double[n];
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
for (int i = 0; i < n; ++i) {
throws MathException {
public void testEquals() {
assertTrue(MathUtils.equals(testArray[i], testArray[j]));
assertTrue(MathUtils.equals(testArray[j], testArray[i]));
assertTrue(!MathUtils.equals(testArray[i], testArray[j]));
assertTrue(!MathUtils.equals(testArray[j], testArray[i]));
private double min;
private double max;
return min;
return max;
this.min = min;
this.max = max;
this.function = function;
double criterion = 0;
for (int i = 0; i < rows; ++i) {
if (x < 0) {
return Double.NaN;
return Double.NEGATIVE_INFINITY;
return 0.0;
if (x < 0) {
return d;
return -Double.MAX_VALUE;
return Double.MAX_VALUE;
return d;
long bits     = Double.doubleToLongBits(d);
long sign     = bits & 0x8000000000000000L;
long exponent = bits & 0x7ff0000000000000L;
long mantissa = bits & 0x000fffffffffffffL;
if (d * (direction - d) >= 0) {
if (mantissa == 0x000fffffffffffffL) {
return Double.longBitsToDouble(sign |
(exponent + 0x0010000000000000L));
return Double.longBitsToDouble(sign |
exponent | (mantissa + 1));
if (mantissa == 0L) {
return Double.longBitsToDouble(sign |
(exponent - 0x0010000000000000L) |
0x000fffffffffffffL);
return Double.longBitsToDouble(sign |
exponent | (mantissa - 1));
return f;
return f;
public void testNextAfter() {
return pendingEventTime;
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals("sum entry entry",
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
fail("expecting NullPointerException");
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
fail("expecting NullPointerException");
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals("sum entry entry",
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
fail("expecting NullPointerException");
fail("vectors not same length");
super(name);
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
public void setUp() {
public void tearDown() {
super(name);
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
super(name);
super(name);
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
super(name);
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
super(name);
assertEquals("sum entry entry",
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals("Rows02Cols13", mRows02Cols13,
assertEquals("Rows03Cols12", mRows03Cols12,
assertEquals("Rows03Cols123", mRows03Cols123,
assertEquals("Rows20Cols123", mRows20Cols123,
assertEquals("Rows31Cols31", mRows31Cols31,
assertEquals("Rows31Cols31", mRows31Cols31,
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
fail("vectors not same length");
super(name);
assertEquals("sum entry entry",
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals("Rows02Cols13", mRows02Cols13,
assertEquals("Rows03Cols12", mRows03Cols12,
assertEquals("Rows03Cols123", mRows03Cols123,
assertEquals("Rows20Cols123", mRows20Cols123,
assertEquals("Rows31Cols31", mRows31Cols31,
assertEquals("Rows31Cols31", mRows31Cols31,
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
public void testSetSubMatrix() throws Exception {
fail("expecting NullPointerException");
fail("vectors not same length");
super(name);
fail("an exception should have been thrown");
this.iterationCount = iterationCount;
.doubleValue();
while (unif == 0.0d) {
public void testNextExponential() {
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (rhs.isNaN()) {
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
protected TestRandomGenerator testGenerator = new TestRandomGenerator();
randomData = new RandomDataImpl(testGenerator);
public void testNextInt() {
testGenerator.nextInt(-1);
Frequency freq = new Frequency();
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
value = testGenerator.nextInt(4);
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
public void testNextLong() {
long q1 = Long.MAX_VALUE/4;
long q2 = 2 *  q1;
long q3 = 3 * q1;
Frequency freq = new Frequency();
long val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextLong();
if (val < q1) {
value = 0;
value = 1;
value = 2;
value = 3;
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
public void testNextBoolean() {
double[] expected = {halfSampleSize, halfSampleSize};
long[] observed = new long[2];
for (int i=0; i<smallSampleSize; i++) {
if (testGenerator.nextBoolean()) {
observed[0]++;
observed[1]++;
public void testNextFloat() {
Frequency freq = new Frequency();
float val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextFloat();
if (val < 0.25) {
value = 0;
value = 1;
value = 2;
value = 3;
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
for (int i = 0; i < 1000; ++i) {
for (int i = 0; i < 1000; ++i) {
for (int i = 0; i < 1000; ++i) {
for (int i = 0; i < n; ++i) {
public void testNextInt() {
public void testNextLong() {
randomData.reSeed(1000);
for (int i = 0; i < 10000; ++i) {
for (int i = 0; i < 10000; ++i) {
for (int i = 0; i < 10000; ++i) {
for (int i = 0; i < n; ++i) {
public void testNextInt() {
public void testNextLong() {
return (long) (nextDouble() * Long.MAX_VALUE);
throws IllegalArgumentException {
clearResult();
verifyInterval(min, max);
verifyIterationCount();
setResult(t, i);
clearResult();
verifyInterval(min, max);
verifyIterationCount();
setResult(s, i);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 32) {
clearResult();
verifyInterval(min, max);
verifyIterationCount();
setResult(s, 1);
if (i >= minimalIterationCount) {
setResult(s, i);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
s = 0.5 * (max - min) * (f.value(min) + f.value(max));
sum += f.value(x);
clearResult();
verifyInterval(min, max);
verifyIterationCount();
setResult(t, i);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
void setMaximalIterationCount(int count);
int getMaximalIterationCount();
void setAbsoluteAccuracy(double accuracy);
void setRelativeAccuracy(double accuracy);
double getRelativeAccuracy();
void setMinimalIterationCount(int count);
void resetMinimalIterationCount();
protected int maximalIterationCount;
protected int defaultMinimalIterationCount;
protected int iterationCount;
verifyIterationCount();
maximalIterationCount = count;
public int getMaximalIterationCount() {
return maximalIterationCount;
public void setAbsoluteAccuracy(double accuracy) {
absoluteAccuracy = accuracy;
relativeAccuracy = accuracy;
public double getRelativeAccuracy() {
return relativeAccuracy;
this.resultComputed = true;
protected final void clearResult() {
this.resultComputed = false;
minimalIterationCount = count;
public int getMinimalIterationCount() {
return minimalIterationCount;
public void resetMinimalIterationCount() {
minimalIterationCount = defaultMinimalIterationCount;
throws IllegalArgumentException {
if (lower >= upper) {
protected void verifyIterationCount() throws IllegalArgumentException {
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(50);
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
return result;
return result;
return result;
return result;
return result;
double getResult() throws IllegalStateException;
protected boolean resultComputed = false;
protected double result;
public double getResult() throws IllegalStateException {
if (resultComputed) {
return result;
if (resultComputed) {
if (resultComputed) {
resultComputed = true;
rand = new JDKRandomGenerator();
rand = new JDKRandomGenerator();
package org.apache.commons.math.linear;
this.m = m;
return x;
for (int i = 0; i < n; i++) {
return x;
if (hexString.length() != 1) {
public void testNextSecureHex() {
if (hexString.length() != 1) {
numberOfSuccesses, sampleSize);
private double probability(int n, int m, int k, int x) {
if (x < domain[0]) {
numberOfSuccesses, sampleSize);
double ret = probability(n, m, k, x0);
while (it.hasNext()) {
double d = 0;
return d;
while (it.hasNext()) {
return result;
public double evaluate(final double[] values, final int begin, final int length) {
final int begin, final int length) {
public double evaluate(final double[] values, final int begin, final int length) {
final int begin, final int length) {
public double evaluate(final double[] values, final int begin, final int length) {
break;
break;
break;
return true;
return false;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
private double nan = Double.NaN;
double[] values = new double[] { one, two, two, three };
values = new double[] { one };
StatUtils.mean(values) == one);
x = new double[] {two};
TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.product(x), tolerance);
TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(12, StatUtils.product(x), tolerance);
TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);
x = new double[] {two};
x = new double[] {one, two, two, three};
TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);
x = new double[] {two};
x = new double[] {one, two, two, three};
x = new double[] {one, two, two, three};
TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(two, StatUtils.max(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(two, StatUtils.min(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);
private long twoL = 2;
private long threeL = 3;
private int oneI = 1;
private int twoI = 2;
private int threeI=3;
private double tolerance = 10E-15;
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(threeL);
f.addValue(threeL);
f.addValue(threeI);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(oneL);
f.addValue(oneL);
f.addValue(twoI);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(oneL);
int[] result = new int[k];
for (int i = 0; i < k; i++) {
result[i] = index[n - i - 1];
return true;
return ignored;
return true;
return ignored;
return Double.NaN;
return y;
return Double.NaN;
return 0.0;
double expected;
double expected;
double expected;
int j = 0;
int k = 0;
for (int i = 0; i < n; i++) {
for (int i = 0; i < n; i++) {
private final double z;
while (true) {
return value;
if (index < 0) {
return out;
return out;
do {
++i;
while (true) {
while (true) {
this.mu = mu;
long n = 0;
double r = 1.0d;
double rnd = 1.0d;
if (r >= p) {
n++;
return n;
return n;
double y = 0;
double v = 0;
while (true) {
break;
break;
break;
break;
while (true) {
if (!loaded) {
public void nextBytes(byte[] bytes) {
public int nextInt() {
public int nextInt(int n) {
public long nextLong() {
public boolean nextBoolean() {
public float nextFloat() {
public double nextDouble() {
void nextBytes(byte[] bytes);
int nextInt();
int nextInt(int n);
long nextLong();
boolean nextBoolean();
float nextFloat();
double nextDouble();
if (n > 0) {
do {
if (n > 0) {
do {
public String toString() {
Serializable {
private int count;
public int nextInt() {
public boolean nextBoolean() {
public double nextDouble() {
public float nextFloat() {
public long nextLong() {
public void nextBytes(byte[] bytes) {
while (true) {
break;
int i = 1;
int j = 0;
j = 0;
i++;
return y;
public long nextLong() {
public int nextInt() {
public double nextDouble() {
public boolean nextBoolean() {
public float nextFloat() {
public void nextBytes(byte[] bytes) {
while (true) {
break;
int i = 1;
int j = 0;
i++;
j = 0;
i++;
return x;
this.x = x;
this.y = y;
public String toString() {
public String toString() {
return s;
private int index;
public String toString() {
return out;
public String toString() {
return out;
public String toString() {
public String toString() {
public String toString() {
return out;
public String toString() {
return out;
public String toString() {
return out;
public String toString() {
public String toString() {
return out;
public String toString() {
public String toString() {
return b;
return v;
return b;
return b;
return v;
return b;
public String toString() {
for (int i = 0; i < n; i++) {
return array;
return array;
for (int i = 0; i < n; i++) {
return array;
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.polar2Complex(1, 0), 10e-12);
ComplexUtils.polar2Complex(0, 1), 10e-12);
ComplexUtils.polar2Complex(0, -1), 10e-12);
ComplexUtils.polar2Complex(1, pi/2), 10e-12);
ComplexUtils.polar2Complex(1, -pi/2), 10e-12);
r += i;
double theta = 0;
for (int j =0; j < 20; j++) {
theta += pi / 6;
ComplexUtils.polar2Complex(r, theta), 10e-12);
theta = -2 * pi;
for (int j =0; j < 20; j++) {
theta -= pi / 6;
ComplexUtils.polar2Complex(r, theta), 10e-12);
TestUtils.assertSame(Complex.NaN,
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(1, negInf));
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(inf, negInf));
TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));
TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));
TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));
TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));
ByteArrayOutputStream bos = new ByteArrayOutputStream();
for (int i = 0; i < n; i++) {
return list;
break;
public String toString() {
for (int i = 0; i < n; i++) {
0,
for (int i = 0; i < n; i++) {
if (count == null) {
count = 0;
if (count == null) {
count = 0;
if (count == null) {
count = 0;
throws IOException {
while (true) {
throws IOException {
throws IOException {
do {
for (int i = 0; i < x.length; i++) {
return true;
return true;
return false;
private final double z;
this.alpha = alpha;
this.beta = beta;
public double getAlpha() {
return alpha;
public double getBeta() {
return beta;
return Double.NEGATIVE_INFINITY;
return Double.NEGATIVE_INFINITY;
return Double.NEGATIVE_INFINITY;
return 0;
return 1;
return 0;
return 1;
return true;
private static final long serialVersionUID = 6751309484392813623L;
if (trials < 0) {
probabilityOfSuccess = p;
numberOfTrials = trials;
public int getNumberOfTrials() {
return numberOfTrials;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
double ret;
ret = Double.NEGATIVE_INFINITY;
return ret;
public double cumulativeProbability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
ret = 1.0;
return ret;
return true;
this.scale = scale;
this.median = median;
public double cumulativeProbability(double x) {
public double getMedian() {
return median;
public double getScale() {
return scale;
double ret;
ret = Double.NEGATIVE_INFINITY;
ret = Double.POSITIVE_INFINITY;
return ret;
return Double.NaN;
return Double.NaN;
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
public double getDegreesOfFreedom() {
return 0;
return Double.POSITIVE_INFINITY;
return true;
this.value = value;
public double inverseCumulativeProbability(final double p)
if (p < 0.0 || p > 1.0) {
return value;
return value;
return 0;
return value;
return value;
return true;
return value;
if (index < 0) {
private final double mean;
if (mean <= 0) {
this.mean = mean;
public double getMean() {
return mean;
if (x < 0) {
return Double.NEGATIVE_INFINITY;
double ret;
if (x <= 0.0) {
ret = 0.0;
return ret;
double ret;
if (p < 0.0 || p > 1.0) {
ret = Double.POSITIVE_INFINITY;
return ret;
return getMean();
return 0;
return Double.POSITIVE_INFINITY;
return true;
private static final long serialVersionUID = -8516354193418641566L;
denominatorDegreesOfFreedom);
denominatorDegreesOfFreedom);
double ret;
0.5 * n,
0.5 * m);
return ret;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
return Double.NaN;
return Double.NaN;
return 0;
return Double.POSITIVE_INFINITY;
return true;
this.scale = scale;
public double getShape() {
public double getScale() {
return scale;
if (x < 0) {
return 0;
if (x < 0) {
return Double.NEGATIVE_INFINITY;
public double cumulativeProbability(double x) {
double ret;
return ret;
return 0;
return Double.POSITIVE_INFINITY;
return true;
probabilityOfSuccess = p;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
if (x < 0) {
return 0.0;
if (x < 0) {
return Double.NEGATIVE_INFINITY;
public double cumulativeProbability(int x) {
if (x < 0) {
return 0.0;
return 0;
return Integer.MAX_VALUE;
return true;
if (p == 1) {
return Integer.MAX_VALUE;
if (p == 0) {
return 0;
this.beta = beta;
this.mu = mu;
return mu;
public double getScale() {
return beta;
public double cumulativeProbability(double x) {
if (p < 0.0 || p > 1.0) {
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
if (numberOfSuccesses > populationSize) {
if (sampleSize > populationSize) {
public double cumulativeProbability(int x) {
double ret;
if (x < domain[0]) {
ret = 0.0;
ret = 1.0;
return ret;
private int getLowerDomain(int n, int m, int k) {
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public int getPopulationSize() {
return populationSize;
public int getSampleSize() {
return sampleSize;
public double probability(int x) {
double ret;
ret = Double.NEGATIVE_INFINITY;
return ret;
public double upperCumulativeProbability(int x) {
double ret;
ret = 1.0;
ret = 0.0;
return ret;
while (x0 != x1) {
x0 += dx;
return ret;
return true;
double probability(int x);
if (beta <= 0.0) {
this.mu = mu;
this.beta = beta;
return mu;
public double getScale() {
return beta;
public double cumulativeProbability(double x) {
if (p < 0.0 || p > 1.0) {
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return mu;
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
this.mu = mu;
return Double.NaN;
return Double.NaN;
return Double.NaN;
if (p < 0.0 || p > 1.0) {
public double getScale() {
return c;
return mu;
return Double.POSITIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return mu;
return Double.POSITIVE_INFINITY;
return true;
this.scale = scale;
public double getScale() {
return scale;
public double getShape() {
return 0;
return Double.NEGATIVE_INFINITY;
return 0;
if (x0 > x1) {
return 0;
return Double.POSITIVE_INFINITY;
return true;
if (s <= 0.0) {
this.mu = mu;
return mu;
public double getScale() {
return s;
public double cumulativeProbability(double x) {
if (p < 0.0 || p > 1.0) {
return 0.0;
return Double.POSITIVE_INFINITY;
return mu;
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
this.mu = mu;
this.omega = omega;
public double getShape() {
return mu;
public double getScale() {
return omega;
return 0.0;
public double cumulativeProbability(double x) {
return 0;
return Double.POSITIVE_INFINITY;
return true;
private static final long serialVersionUID = 8589540077390120676L;
private final double mean;
this.mean = mean;
standardDeviation = sd;
public double getMean() {
return mean;
public double getStandardDeviation() {
return standardDeviation;
if (p < 0.0 || p > 1.0) {
if (x0 > x1) {
return getMean();
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
this.scale = scale;
public double getScale() {
return scale;
public double getShape() {
return 0;
return Double.NEGATIVE_INFINITY;
return 0;
return Double.POSITIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return scale;
return Double.POSITIVE_INFINITY;
return true;
private static final long serialVersionUID = 6751309484392813623L;
probabilityOfSuccess = p;
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
return ret;
double ret;
if (x < 0) {
ret = Double.NEGATIVE_INFINITY;
return ret;
public double cumulativeProbability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
return ret;
return 0;
return Integer.MAX_VALUE;
return true;
private static final long serialVersionUID = -3349935121172596109L;
private final double mean;
if (p <= 0) {
this.maxIterations = maxIterations;
public double getMean() {
return mean;
public double probability(int x) {
double ret;
if (x < 0 || x == Integer.MAX_VALUE) {
ret = Double.NEGATIVE_INFINITY;
return ret;
public double cumulativeProbability(int x) {
if (x < 0) {
return 0;
if (x == Integer.MAX_VALUE) {
return 1;
return normal.cumulativeProbability(x + 0.5);
return getMean();
return getMean();
return 0;
return Integer.MAX_VALUE;
return true;
double probability(double x);
super();
double ret;
return ret;
double ret;
++j;
return mu;
return ret;
double ret;
if (n == 0) {
return 0;
return ret;
this.degreesOfFreedom = degreesOfFreedom;
public double getDegreesOfFreedom() {
return degreesOfFreedom;
public double cumulativeProbability(double x) {
double ret;
ret = 0.5;
double t =
0.5);
if (x < 0.0) {
ret = 0.5 * t;
ret = 1.0 - 0.5 * t;
return ret;
return 0;
return Double.NaN;
return Double.POSITIVE_INFINITY;
return Double.NaN;
return Double.NEGATIVE_INFINITY;
return Double.POSITIVE_INFINITY;
return true;
double b)
this.a = a;
this.b = b;
return c;
return 0;
return 0;
return 0;
return 1;
return a;
return b;
return true;
if (p == 0) {
return a;
if (p == 1) {
return b;
public double probability(int x) {
return 0;
public double cumulativeProbability(int x) {
return 0;
return 1;
return true;
if (lower >= upper) {
return 0.0;
return 0;
return 1;
public double inverseCumulativeProbability(final double p)
if (p < 0.0 || p > 1.0) {
return true;
public double getShape() {
public double getScale() {
return scale;
if (x < 0) {
return 0;
if (x < 0) {
return Double.NEGATIVE_INFINITY;
public double cumulativeProbability(double x) {
double ret;
if (x <= 0.0) {
ret = 0.0;
return ret;
public double inverseCumulativeProbability(double p) {
double ret;
if (p < 0.0 || p > 1.0) {
ret = 0.0;
ret = Double.POSITIVE_INFINITY;
return ret;
return 0;
return Double.POSITIVE_INFINITY;
return true;
return 0.0;
return Double.NEGATIVE_INFINITY;
return 0.0;
return 1.0;
return value;
return 1;
return true;
for (int i = 0; i < x.length; i++) {
for (int i = 0; i < x.length; i++) {
do {
public class BinomialDistributionTest extends IntegerDistributionAbstractTest {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
public double[] makeDensityTestValues() {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public int[] makeInverseCumulativeTestValues() {
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void setUp() {
super.setUp();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testMedian() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
public void testScale() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
public double[] makeInverseCumulativeTestValues() {
Double.POSITIVE_INFINITY};
public double[] makeDensityTestValues() {
public void setUp() {
super.setUp();
setTolerance(1E-4);
0.5318646, 0.1526342});
setInverseCumulativeTestValues(getCumulativeTestPoints());
setInverseCumulativeTestPoints(getCumulativeTestValues());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();
for (int i = 0; i < x.length; i++) {
public void setUp() {
super.setUp();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
for (int i = 0; i < 10; i++) {
public void setUp() {
super.setUp();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testMeanAccessors() {
ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public void setUp() {
super.setUp();
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
double p = fd.cumulativeProbability(.999);
double x = fd.inverseCumulativeProbability(p);
double x = fd.inverseCumulativeProbability(p);
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public void setUp() {
super.setUp();
public void testParameterAccessors() {
GammaDistribution distribution = (GammaDistribution) getDistribution();
testProbability(-1.000, 4.0, 2.0, .0000);
testProbability(15.501, 4.0, 2.0, .9499);
testProbability(0.504, 4.0, 1.0, .0018);
testProbability(10.011, 1.0, 2.0, .9933);
testProbability(5.000, 2.0, 2.0, .7127);
testValue(15.501, 4.0, 2.0, .9499);
testValue(0.504, 4.0, 1.0, .0018);
testValue(10.011, 1.0, 2.0, .9933);
testValue(5.000, 2.0, 2.0, .7127);
double actual = distribution.cumulativeProbability(x);
double actual = distribution.inverseCumulativeProbability(p);
for (int i = 0; i < x.length; i++) {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public static double logGamma(double x) {
double ret;
if (Double.isNaN(x) || (x <= 0.0)) {
ret = Double.NaN;
return ret;
if (x < 0) {
return 0;
in.close();
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
public double[] makeDensityTestValues() {
return new double[] {
return new double[] {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
for (int i = 1; i < n; i++) {
return ret;
public double[] makeInverseCumulativeTestPoints() {
return new double[] {
public int[] makeInverseCumulativeTestValues() {
public double[] makeCumulativeTestPoints() {
return new double[] {
public double[] makeDensityTestValues() {
return new double[] {
public double[] makeCumulativeTestValues() {
return new double[] {
public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};
public double[] makeDensityTestValues() {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
public int[] makeInverseCumulativeTestValues() {
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testLargeValues() {
int populationSize = 3456;
int sampleSize = 789;
int numberOfSucceses = 101;
double[][] data = {
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
for (int i = 0; i < data.length; ++i) {
int x = (int)data[i][0];
double cdf = data[i][2];
double actualCdf = dist.cumulativeProbability(x);
double cdf1 = data[i][3];
double actualCdf1 = dist.upperCumulativeProbability(x);
public void testMoreLargeValues() {
int populationSize = 26896;
int sampleSize = 895;
int numberOfSucceses = 55;
double[][] data = {
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
int k = 0;
public double[] makeCumulativeTestPoints() {
return new double[] {
public double[] makeDensityTestValues() {
return new double[] {
public double[] makeCumulativeTestValues() {
return new double[] {
public double[] makeCumulativeTestPoints() {
return new double[] {
public double[] makeCumulativeTestValues() {
return new double[] {
public double[] makeDensityTestValues() {
return new double[] {
return new double[] {
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public double[] makeInverseCumulativeTestValues() {
public void setUp() {
super.setUp();
verifyCumulativeProbabilities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
verifyInverseCumulativeProbabilities();
for (int i = 0; i < x.length; i++) {
else { // make sure top coding not reversed
public double[] makeCumulativeTestPoints() {
return new double[] {
public double[] makeDensityTestValues() {
return new double[] {
public double[] makeCumulativeTestValues() {
return new double[] {
public double[] makeCumulativeTestPoints() {
return new double[] {
public double[] makeDensityTestValues() {
return new double[] {
public double[] makeCumulativeTestValues() {
return new double[] {
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d};
public double[] makeDensityTestValues() {
public void setUp() {
super.setUp();
NormalDistribution distribution = (NormalDistribution) getDistribution();
double mu = distribution.getMean();
double sigma = distribution.getStandardDeviation();
mu + 5 * sigma});
verifyCumulativeProbabilities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testGetMean() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
public void testGetStandardDeviation() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
for (int i = 0; i < x.length; i++) {
else { // make sure top coding not reversed
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public double[] makeInverseCumulativeTestValues() {
public void setUp() {
super.setUp();
verifyCumulativeProbabilities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
verifyQuantiles();
verifyDensities();
setInverseCumulativeTestPoints(new double[] {0, 1});
verifyInverseCumulativeProbabilities();
for (int i = 0; i < x.length; i++) {
else { // make sure top coding not reversed
public class PascalDistributionTest extends IntegerDistributionAbstractTest {
public void setUp() {
super.setUp();
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public int[] makeInverseCumulativeTestValues() {
setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public class PoissonDistributionTest extends IntegerDistributionAbstractTest {
private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
public double[] makeDensityTestValues() {
return new double[] { 0d, 0.0183156388887d,  0.073262555555d,
0.156293451851d, 0.00529247667642d, 8.27746364655e-09};
public int[] makeCumulativeTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };
public double[] makeCumulativeTestValues() {
0.238103305554d, 0.433470120367d, 0.62883693518,
0.78513038703d,  0.99716023388d, 0.999999998077 };
public double[] makeInverseCumulativeTestPoints() {
public int[] makeInverseCumulativeTestValues() {
double result = dist.normalApproximateProbability(110)
- dist.normalApproximateProbability(89);
result = dist.normalApproximateProbability(10200)
- dist.normalApproximateProbability(9899);
public void testMean() {
public void testLargeMeanCumulativeProbability() {
double mean = 1.0;
while (mean <= 10000000.0) {
double x = mean * 2.0;
double dx = x / 10.0;
while (x >= 0) {
x -= dx;
mean *= 10.0;
public void testLargeMeanInverseCumulativeProbability() {
double mean = 1.0;
double p = 0.1;
double dp = p;
p += dp;
mean *= 10.0;
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public void setUp() {
super.setUp();
td.cumulativeProbability(.1);
td.cumulativeProbability(.01);
setInverseCumulativeTestValues(getCumulativeTestPoints());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
verifyDensities();
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
return;
return res;
public void setUp() {
super.setUp();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
0.0,
1.0,
1.0
public double[] makeInverseCumulativeTestPoints() {
public double[] makeInverseCumulativeTestValues() {
public double[] makeDensityTestValues() {
0,
0,
public void setUp() {
super.setUp();
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
public double[] makeDensityTestValues() {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public int[] makeInverseCumulativeTestValues() {
public void setUp() {
super.setUp();
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
public double[] makeCumulativeTestPoints() {
public double[] makeCumulativeTestValues() {
public double[] makeDensityTestValues() {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {0.0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testAlpha() {
public void testBeta() {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
public double[] makeInverseCumulativeTestPoints() {
public int[] makeInverseCumulativeTestValues() {
1.0e-10);
1.0e-10);
double tolerance) {
return false;
