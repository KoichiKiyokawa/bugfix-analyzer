package org.apache.commons.math.analysis.derivative;
public abstract class AbstractDifferenceDerivative extends UnivariateRealFunctionProxy implements UnivariateRealFunction {
private double delta;
public AbstractDifferenceDerivative(UnivariateRealFunction function, double h) {
super(function);
setDelta(h);
private void setDelta(double h) {
this.delta = h;
protected double getDelta() {
return delta;
package org.apache.commons.math.analysis.derivative;
public class BackwardDifferenceDerivative extends AbstractDifferenceDerivative {
public BackwardDifferenceDerivative(UnivariateRealFunction function, double h) {
super(function, h);
public double value(double x) throws MathException {
UnivariateRealFunction f = getFunction();
double h = getDelta();
return (f.value(x) - f.value(x - h)) / h;
public static UnivariateRealFunction decorate(UnivariateRealFunction function, double h) {
return new BackwardDifferenceDerivative(function, h);
package org.apache.commons.math.analysis.derivative;
public class CenterDifferenceDerivative extends AbstractDifferenceDerivative {
public CenterDifferenceDerivative(UnivariateRealFunction function, double h) {
super(function, h);
public double value(double x) throws MathException {
UnivariateRealFunction f = getFunction();
double h2 = getDelta();
double h = h2 * .5;
return (f.value(x + h) - f.value(x - h)) / h2;
public static UnivariateRealFunction decorate(UnivariateRealFunction function, double h) {
return new CenterDifferenceDerivative(function, h);
package org.apache.commons.math.analysis.derivative;
public class ForwardDifferenceDerivative extends AbstractDifferenceDerivative {
public ForwardDifferenceDerivative(UnivariateRealFunction function, double h) {
super(function, h);
public double value(double x) throws MathException {
UnivariateRealFunction f = getFunction();
double h = getDelta();
return (f.value(x + h) - f.value(x)) / h;
public static UnivariateRealFunction decorate(UnivariateRealFunction function, double h) {
return new ForwardDifferenceDerivative(function, h);
package org.apache.commons.math.analysis;
public abstract class UnivariateRealFunctionProxy
implements UnivariateRealFunction {
private UnivariateRealFunction function;
public UnivariateRealFunctionProxy(UnivariateRealFunction function) {
super();
setFunction(function);
protected UnivariateRealFunction getFunction() {
return function;
private void setFunction(UnivariateRealFunction function) {
this.function = function;
package org.apache.commons.math.analysis;
public interface FunctionOperator {
public UnivariateRealFunction evaluate(UnivariateRealFunction f) throws MathException;
package org.apache.commons.math.analysis;
public class UnivariateRealFunctionUtilsTest extends TestCase {
public void testLocalMaximumCentered() {
UnivariateRealFunction function = new SinFunction();
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.centerDifferenceDerivative(function, 1.0e-5);
testLocalMaximum(derivative);
public void testLocalMaximumForward() {
UnivariateRealFunction function = new SinFunction();
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.forwardDifferenceDerivative(function, 1.0e-5);
testLocalMaximum(derivative);
public void testLocalMaximumBackward() {
UnivariateRealFunction function = new SinFunction();
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.backwardDifferenceDerivative(function, 1.0e-5);
testLocalMaximum(derivative);
private void testLocalMaximum(UnivariateRealFunction derivative) {
double maximum = UnivariateRealSolverUtils.solve(derivative, Math.PI / 3.0, Math.PI * 2.0 / 3.0);
assertEquals(maximum, Math.PI / 2.0, 1.0e-5);
fail(ex.getMessage());
package org.apache.commons.math.analysis;
public class UnivariateRealFunctionUtils {
private UnivariateRealFunctionUtils() {
super();
public static UnivariateRealFunction backwardDifferenceDerivative(UnivariateRealFunction function, double delta) {
return BackwardDifferenceDerivative.decorate(function, delta);
public static UnivariateRealFunction centerDifferenceDerivative(UnivariateRealFunction function, double delta) {
return CenterDifferenceDerivative.decorate(function, delta);
public static UnivariateRealFunction forwardDifferenceDerivative(UnivariateRealFunction function, double delta) {
return ForwardDifferenceDerivative.decorate(function, delta);
package org.apache.commons.math.analysis;
public class DerivativeOperatorFactory {
public static DerivativeOperatorFactory newInstance() {
return null;
public FunctionOperator getDefaultDerivativeOperator() {
return null;
public FunctionOperator getCenteredDifferenceDerivativeOperator(){
return null;
package org.apache.commons.math.analysis;
public class DerivativeOperatorFactoryTest extends TestCase {
public DerivativeOperatorFactoryTest(String arg0) {
super(arg0);
package org.apache.commons.math.util;
public class BeanTransformer implements NumberTransformer {
private String propertyName = null;
private String propertyGetter = null;
public BeanTransformer() {
super();
public BeanTransformer(final String property) {
super();
setPropertyName(property);
public String getPropertyName() {
return propertyName;
public void setPropertyName(final String string) {
this.propertyName = string;
this.propertyGetter = "get" + string.substring(0,1).toUpperCase() + string.substring(1);
public double transform(final Object o) throws MathException {
Expression expr = new Expression(o, propertyGetter, new Object[0]);
Object result;
expr.execute();
result = expr.getValue();
throw new MathException("IllegalAccessException in Transformation: " + e.getMessage(), e);
throw new MathException("InvocationTargetException in Transformation: " + e.getMessage(), e);
throw new MathException("NoSuchMethodException in Transformation: " + e.getMessage(), e);
throw new MathException("ClassCastException in Transformation: " + e.getMessage(), e);
throw new MathException("Exception in Transformation: " + e.getMessage(), e);
return ((Number) result).doubleValue();
package org.apache.commons.math.util;
public class BeanTransformerTest extends TestCase {
public void testConstructor(){
BeanTransformer b = new BeanTransformer();
assertNull(b.getPropertyName());
public void testConstructorString(){
String name = "property";
BeanTransformer b = new BeanTransformer(name);
assertEquals(name, b.getPropertyName());
public void testSetPropertyName(){
String name = "property";
BeanTransformer b = new BeanTransformer();
b.setPropertyName(name);
assertEquals(name, b.getPropertyName());
public void testTransformNoSuchMethod(){
BeanTransformer b = new BeanTransformer("z");
TestBean target = new TestBean();
b.transform(target);
fail("Expecting MathException");
public void testTransform() throws Exception {
BeanTransformer b = new BeanTransformer("x");
TestBean target = new TestBean();
double value = Double.NaN;
value = b.transform(target);
TestUtils.assertEquals(1.0, value, 1.0e-2);
public void testTransformInvalidType() throws Exception {
BeanTransformer b = new BeanTransformer("y");
TestBean target = new TestBean();
b.transform(target);
fail("Expecting ClassCastException");
package org.apache.commons.math.linear;
public class CholeskySolverTest 
extends TestCase {
private double[][] m1 = {{1}};
private double m1Det = 1.0d;
private double[][] m2 = {{1, 0} , 
private double m2Det = 2.0d;                                 
private double[][] m3 = {{1, 0, 0}, 
private double m3Det = 6.0d;
private double[][] m4 = {{1, 0, 0}, 
private double m4Det = 18.0d;
private double[][] m5 = {{ 1,  0,  0,  0,  0}, 
private double m5Det = 2700.0d;
private double[][] m6 = {{1, 0,  0}, 
private double[][] m7 = {{1, 2, 3}, 
public CholeskySolverTest(String nameOfTest) {
super(nameOfTest);
public void setUp() 
throws java.lang.Exception { 
super.setUp();
public void tearDown() 
throws java.lang.Exception {
super.tearDown();
public static Test suite() {
TestSuite suite = new TestSuite(CholeskySolverTest.class);
suite.setName("CholeskySolver Tests");
return suite;
public void testNumericalZero() {
CholeskySolver solver = new CholeskySolver();
double numericalZero = 77.77d;
solver.setNumericalZero(numericalZero);
assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);
solver.decompose(
new RealMatrixImpl(new double[][]{{numericalZero/2, 0},
fail("testing numericalZero");
public void testDecompose() {
testDecompose(m1, "Decomposing matrix m1");
testDecompose(m2, "Decomposing matrix m2");
testDecompose(m3, "Decomposing matrix m3");
testDecompose(m4, "Decomposing matrix m4");
testDecompose(m5, "Decomposing matrix m5");
testDecompose(m6, "Decomposing matrix m6");
fail("Decomposing matrix m6"); 
CholeskySolver solver = new CholeskySolver();
solver.decompose(new RealMatrixImpl(m7));
fail("Decomposing matrix m7"); 
public void testSolve() {
CholeskySolver solver = new CholeskySolver();
solver.solve(new double[] {1,2,3});
fail("solving a liniar equitation with a missing matrix should fail"); 
testSolve(m1, "Solving matrix m1");  
testSolve(m2, "Solving matrix m2");
testSolve(m3, "Solving matrix m3");
testSolve(m4, "Solving matrix m4");
testSolve(m5, "Solving matrix m5");
testSolve(m6, "Solving matrix m6");
fail("Solving matrix m6"); 
CholeskySolver solver = new CholeskySolver();
solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});
fail("Solving matrix m3[3x3], v[4]"); 
public void testGetDeterminant() {
CholeskySolver solver = new CholeskySolver();
solver.getDeterminant();
fail("Calculating determinant of missing matrix should fail"); 
testGetDeterminant(m1, m1Det, "Calculating determinant of m1");
testGetDeterminant(m2, m2Det, "Calculating determinant of m2");
testGetDeterminant(m3, m3Det, "Calculating determinant of m3");
testGetDeterminant(m4, m4Det, "Calculating determinant of m4");
testGetDeterminant(m5, m5Det, "Calculating determinant of m5");
private void testDecompose(double[][] lowerTriangularMatrix, String message) 
throws IllegalArgumentException {
RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);
RealMatrix pdMatrix = 
triangularMatrix.multiply(triangularMatrix.transpose());
CholeskySolver solver = new CholeskySolver();
solver.decompose(pdMatrix);
assertTrue(message, 
areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));
private void testSolve(double[][] lowerTriangularMatrix, String message)  {
RealMatrix triangularMatrix = 
new RealMatrixImpl(lowerTriangularMatrix);
RealMatrixImpl pdMatrix = 
(RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());
CholeskySolver solver = 
new CholeskySolver();
double[] c = new double[lowerTriangularMatrix.length];
for (int i=0; i<c.length; i++) 
for (int j=0; j<lowerTriangularMatrix[0].length; j++) 
c[i] += lowerTriangularMatrix[i][j];
solver.decompose(pdMatrix);
RealMatrix x = new RealMatrixImpl(solver.solve(c));
assertTrue(message, 
areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));
private void testGetDeterminant(double[][] lowerTriangularMatrix, 
double determinant,
String message) 
throws IllegalArgumentException {
RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);
RealMatrix pdMatrix = 
triangularMatrix.multiply(triangularMatrix.transpose());
double pdDeterminant = determinant * determinant;
CholeskySolver solver = new CholeskySolver();
solver.decompose(pdMatrix);
assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);
private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {
double[][] mv1 = m1.getData();
double[][] mv2 = m2.getData();
if (mv1.length != mv1.length  ||
mv1[0].length != mv2[0].length) 
return false;
for (int i=0; i<mv1.length; i++) 
for (int j=0; j<mv1[0].length; j++) 
if (Math.abs(mv1[i][j] -mv2[i][j]) > delta) 
return false;
return true;
public static void main(String[] args) {
System.out.println("Start");
TestRunner runner = new TestRunner();
runner.doRun(CholeskySolverTest.suite());
System.out.println("End");
package org.apache.commons.math.linear;
public abstract  class DecompositionFactory {
public static DecompositionFactory newInstance(){
return null;
public abstract Decomposer newDecomposer();
public abstract Decomposer newQRDecopmposer();
package org.apache.commons.math.linear;
public class CholeskySolver {
private double numericalZero = 10E-12;
private RealMatrixImpl decompMatrix;
public CholeskySolver() {
public void setNumericalZero(double numericalZero) {
this.numericalZero = numericalZero;
public double getNumericalZero() {
return numericalZero;
public void decompose(RealMatrix m) 
throws IllegalArgumentException {
decompMatrix = null;
double[][] mval = m.getData();
int numRows = m.getRowDimension();
int numCols = m.getColumnDimension();
if (numRows != numCols) 
throw new IllegalArgumentException("matrix is not square"); 
double[][] decomp = new double[numRows][numCols];       
double sum;
for (int col=0; col<numCols; col++) {
sum = mval[col][col];
for (int k=0; k<col; k++) 
sum = sum - decomp[col][k]*decomp[col][k];
if (sum <= numericalZero) {
throw new IllegalArgumentException(
"Matrix is not positiv definit");
decomp[col][col] += Math.sqrt(sum);
for (int row=col+1; row<numRows; row++) {
sum = mval[row][col];
for (int k=0; k<col; k++) 
sum = sum - decomp[col][k]*decomp[row][k];
decomp[row][col] = sum/decomp[col][col]; 
decompMatrix = new RealMatrixImpl(decomp);
public RealMatrixImpl getDecomposition() {
return decompMatrix;
public double[] solve(double[] c) 
throws IllegalStateException, IllegalArgumentException {
if (decompMatrix == null) {
throw new IllegalStateException("no decomposed matrix available");
if (decompMatrix.getColumnDimension() != c.length) 
throw new IllegalArgumentException("matrix dimension mismatch"); 
double[][] decomp = decompMatrix.getData();
double[] x = new double[decomp.length];
double sum;
for (int i=0; i<x.length; i++) {
sum = c[i];
for (int k=0; k<i; k++) 
sum = sum - decomp[i][k]*x[k];
x[i] = sum / decomp[i][i];
for (int i=x.length-1; i>=0; i--) {
sum = x[i];
for (int k=i+1; k<x.length; k++) 
sum = sum - decomp[k][i]*x[k];        
x[i] = sum / decomp[i][i];
return x;
public double[] solve(RealMatrix m, double[] c) 
throws IllegalArgumentException {
decompose(m);
return solve(c);
public double getDeterminant() {
if (decompMatrix == null) {
throw new IllegalStateException("no decomposed matrix available");
double[][] data = decompMatrix.getData();
double res = 1.0d; 
for (int i=0; i<data.length; i++) {
res *= data[i][i];
res = res*res;
return res;
package org.apache.commons.math.linear;
public interface Decomposition {
RealVector solve(RealVector b);
RealMatrix solve(RealMatrix b);
RealMatrix invert();
package org.apache.commons.math.linear;
public interface Decomposer {
Decomposition decompose(RealMatrix matrix);
package org.apache.commons.math.linear;
public class RealVector {
package org.apache.commons.math.function;
public interface Evaluation {
public abstract Evaluation evaluate(EvaluationContext context)
throws EvaluationException;
package org.apache.commons.math.function;
public interface EvaluationContext {
public abstract double doubleValue(Evaluation argument) throws EvaluationException ;
public abstract float floatValue(Evaluation argument) throws EvaluationException ;
public abstract int intValue(Evaluation argument) throws EvaluationException ;
public abstract long longValue(Evaluation argument) throws EvaluationException ;
public abstract short shortValue(Evaluation argument) throws EvaluationException ;
public abstract byte byteValue(Evaluation argument) throws EvaluationException ;
public abstract Evaluation evaluate(double d);
public abstract Evaluation evaluate(float f);
public abstract Evaluation evaluate(int i);
public abstract Evaluation evaluate(long l);
public abstract Evaluation evaluate(short s);
public abstract Evaluation evaluate(byte b);
package org.apache.commons.math.function;
public class EvaluationException extends MathException {
public EvaluationException() {
super();
public EvaluationException(String message) {
super(message);
public EvaluationException(String message, Throwable cause) {
super(message, cause);
public EvaluationException(Throwable cause) {
super(cause);
package org.apache.commons.math.function;
public class DefaultContext implements EvaluationContext {
public DefaultContext() {
super();
public double doubleValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).doubleValue();
public float floatValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).floatValue();
public int intValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).intValue();
public long longValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).longValue();
public short shortValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).shortValue();
public byte byteValue(Evaluation argument) throws EvaluationException {
return ((DefaultValue)argument.evaluate(this)).byteValue();
public Evaluation evaluate(double d) {
return new DefaultValue(d);
public Evaluation evaluate(float f) {
return new DefaultValue(f);
public Evaluation evaluate(int i) {
return new DefaultValue(i);
public Evaluation evaluate(long l) {
return new DefaultValue(l);
public Evaluation evaluate(short s) {
return new DefaultValue(s);
public Evaluation evaluate(byte b) {
return new DefaultValue(b);
public class DefaultValue extends Number implements Evaluation {
Number value;
DefaultValue() {
super();
DefaultValue(Number n) {
value = n;
DefaultValue(double d) {
value = new Double(d);
DefaultValue(float f) {
value = new Float(f);
DefaultValue(int i) {
value = new Integer(i);
DefaultValue(long l) {
value = new Long(l);
public Evaluation evaluate(EvaluationContext context)
throws EvaluationException {
return this;
public int intValue() {
return value.intValue();
public long longValue() {
return value.longValue();
public float floatValue() {
return value.floatValue();
public double doubleValue() {
return value.doubleValue();
public byte byteValue() {
return value.byteValue();
public short shortValue() {
return value.shortValue();
package org.apache.commons.math.function.simple;
public class Multiply implements Evaluation, Serializable {
private Evaluation left;
private Evaluation right;
public void setLeftOperand(Evaluation left) {
this.left = left;
public void setRightOperand(Evaluation right) {
this.right = right;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
context.doubleValue(left) * context.doubleValue(right)
);
public String toString() {
return "Multiply";
package org.apache.commons.math.function.simple;
public class Add implements Evaluation, Serializable {
private Evaluation left;
private Evaluation right;
public void setLeftOperand(Evaluation left) {
this.left = left;
public void setRightOperand(Evaluation right) {
this.right = right;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
context.doubleValue(left) + context.doubleValue(right)
);
public String toString() {
return "Add";
package org.apache.commons.math.function.simple;
public class Sqrt implements Evaluation, Serializable {
private Evaluation argument;
public void setOperand(Evaluation argument) {
this.argument = argument;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
Math.sqrt(context.doubleValue(argument)));
public String toString() {
return "Square Root";
package org.apache.commons.math.function.simple;
public class Subtract implements Evaluation, Serializable {
private Evaluation left;
private Evaluation right;
public void setLeftOperand(Evaluation left) {
this.left = left;
public void setRightOperand(Evaluation right) {
this.right = right;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
context.doubleValue(left) - context.doubleValue(right)
);
public String toString() {
return "Subtract";
package org.apache.commons.math.function.simple;
public class Divide implements Evaluation, Serializable {
private Evaluation left;
private Evaluation right;
public void setLeftOperand(Evaluation left) {
this.left = left;
public void setRightOperand(Evaluation right) {
this.right = right;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
context.doubleValue(left) / context.doubleValue(right)
);
public String toString() {
return "Divide";
package org.apache.commons.math.function.simple;
public class Equals implements Evaluation, Serializable {
private Evaluation left;
private Evaluation right;
public void setLeftOperand(Evaluation left) {
this.left = left;
public void setRightOperand(Evaluation right) {
this.right = right;
public Evaluation evaluate(EvaluationContext context) {
return null;
public String toString() {
return "Equals";
package org.apache.commons.math.function.simple;
public class Power implements Evaluation, Serializable {
private Evaluation argument;
private Evaluation power;
public void setOperand(Evaluation argument) {
this.argument = argument;
public void setPower(Evaluation power) {
this.power = power;
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
return context.evaluate(
Math.pow(
context.doubleValue(argument),
context.doubleValue(power)
)
);
public String toString() {
return "Power";
package org.apache.commons.math.function;
public class Variable implements Evaluation, Serializable {
public Evaluation evaluate(EvaluationContext context)
throws EvaluationException {
return null;
public String toString() {
return "Variable";
package org.apache.commons.math.function;
public interface Compilable {
public abstract Evaluation compile(EvaluationContext context)
throws EvaluationException;
package org.apache.commons.math.stat.univariate;
public final class BeanListUnivariateImplTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double skewness = 0;
private double kurtosis = 0.5;
private double tolerance = 10E-15;
private List patientList = null;
public BeanListUnivariateImplTest(String name) {
super(name);
public void setUp() {  
patientList = new ArrayList();
VitalStats vs1 = new VitalStats( new Double(120.0), 
new Double(96.4) );
Patient p1 = new Patient( vs1, new Integer( 35 ) );
patientList.add( p1 );
VitalStats vs2 = new VitalStats( new Double(70.0), 
new Double(97.4) );
Patient p2 = new Patient( vs2, new Integer( 23 ) );
patientList.add( p2 );
VitalStats vs3 = new VitalStats( new Double(90.0), 
new Double(98.6) );
Patient p3 = new Patient( vs3, new Integer( 42 ) );
patientList.add( p3 );
public static Test suite() {
TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);
suite.setName("Frequency Tests");
return suite;
public void testStats() {	
DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" ); 
double[] values = {35d, 23d, 42d};
assertEquals("total count",3,u.getN(),tolerance);
assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);
assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);
assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);
assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);       
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testPropStats() {
DescriptiveStatistics heartU = new BeanListUnivariateImpl( patientList,
"vitalStats.heartRate" );       
assertEquals( "Mean heart rate unexpected", 93.333, 
heartU.getMean(), 0.001 );
assertEquals( "Max heart rate unexpected", 120.0, 
heartU.getMax(), 0.001 );
DescriptiveStatistics ageU = new BeanListUnivariateImpl( patientList,
"age" );
assertEquals( "Mean age unexpected", 33.333,
ageU.getMean(), 0.001 );
assertEquals( "Max age unexpected", 42.0,
ageU.getMax(), 0.001 );
public void testSetPropertyName(){
BeanListUnivariateImpl u = new BeanListUnivariateImpl(null);
String expected = "property";
u.setPropertyName(expected);
assertEquals(expected, u.getPropertyName());
public void testAddValue() {
DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" ); 
u.addValue(10);
double[] values = {35d, 23d, 42d, 10d};
assertEquals("total count",4,u.getN(),tolerance);
assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);
assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);
assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);
assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);       
u.clear();
assertEquals("total count",0,u.getN(),tolerance);      
public void testSerialization() {
double[] values = {35d, 23d, 42d};
DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" ); 
assertEquals("total count",3,u.getN(),tolerance);
assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);
assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);
assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);
assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);   
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
assertEquals("total count",3,u2.getN(),tolerance);
assertEquals("mean", StatUtils.mean(values), u2.getMean(), tolerance);
assertEquals("min", StatUtils.min(values), u2.getMin(), tolerance);
assertEquals("max", StatUtils.max(values), u2.getMax(), tolerance);
assertEquals("var", StatUtils.variance(values), u2.getVariance(), tolerance);   
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);
public class VitalStats {
private Double heartrate;
private Double temperature;
public VitalStats() {
public VitalStats(Double heartrate, Double temperature) {
setHeartRate( heartrate );
setTemperature( temperature );
public Double getHeartRate() {
return heartrate;
public void setHeartRate(Double heartrate) {
this.heartrate = heartrate;
public Double getTemperature() {
return temperature;
public void setTemperature(Double temperature) {
this.temperature = temperature;
public class Patient {
private VitalStats vitalStats;
private Integer age;
public Patient() {
public Patient(VitalStats vitalStats, Integer age) {
setVitalStats( vitalStats );
setAge( age );
public VitalStats getVitalStats() {
return( vitalStats );
public void setVitalStats(VitalStats vitalStats) {
this.vitalStats = vitalStats;
public Integer getAge() {
return age;
public void setAge(Integer age) {
this.age = age;
package org.apache.commons.math.stat.univariate;
public class BeanListUnivariateImpl extends ListUnivariateImpl implements Serializable {
private String propertyName;
public BeanListUnivariateImpl(){
this(new ArrayList());
public BeanListUnivariateImpl(List list) {
this(list, null);
public BeanListUnivariateImpl(List list, String propertyName) {
super(list);
setPropertyName(propertyName);
public String getPropertyName() {
return propertyName;
public void setPropertyName(String propertyName) {
this.propertyName = propertyName;
this.transformer = new NumberTransformer() {
public double transform(final Object o) throws MathException {
return (
(Number) PropertyUtils.getProperty(
o,
getPropertyName()))
.doubleValue();
throw new MathException(
"IllegalAccessException in Transformation: "
+ e.getMessage(),
e);
throw new MathException(
"InvocationTargetException in Transformation: "
+ e.getMessage(),
e);
throw new MathException(
"oSuchMethodException in Transformation: "
+ e.getMessage(),
e);
public void addValue(double v)  {
DynaProperty[] props = new DynaProperty[] {
new DynaProperty(propertyName, Double.class)
BasicDynaClass dynaClass = new BasicDynaClass(null, null, props);
DynaBean dynaBean = null;
dynaBean = dynaClass.newInstance();
throw new RuntimeException(ex);   // should never happen
dynaBean.set(propertyName, new Double(v));
addObject(dynaBean);
public void addObject(Object bean) {
list.add(bean);
package org.apache.commons.math;
public class FunctionEvaluationExceptionTest extends TestCase {
public void testConstructor(){
FunctionEvaluationException ex = new FunctionEvaluationException(0.0);
assertNull(ex.getCause());
assertNotNull(ex.getMessage());
assertTrue(ex.getMessage().indexOf("0") > 0);
assertEquals(0.0, ex.getArgument(), 0);
public void testConstructorPatternArguments(){
String pattern = "Evaluation failed for argument = {0}";
Object[] arguments = { new Double(0.0) };
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);
assertNull(ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testConstructorPatternArgumentsCause(){
String pattern = "Evaluation failed for argument = {0}";
Object[] arguments = { new Double(0.0) };
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);
assertEquals(cause, ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math;
public class MaxIterationsExceededExceptionTest extends TestCase {
public void testConstructor(){
MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);
assertNull(ex.getCause());
assertNotNull(ex.getMessage());
assertTrue(ex.getMessage().indexOf("1,000,000") > 0);
assertEquals(1000000, ex.getMaxIterations());
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math;
public class MathExceptionTest extends TestCase {
public void testConstructor(){
MathException ex = new MathException();
assertNull(ex.getCause());
assertNull(ex.getMessage());
assertNull(ex.getMessage(Locale.FRENCH));
public void testConstructorPatternArguments(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
MathException ex = new MathException(pattern, arguments);
assertNull(ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testConstructorCause(){
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
MathException ex = new MathException(cause);
assertEquals(cause, ex.getCause());
public void testConstructorPatternArgumentsCause(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
MathException ex = new MathException(pattern, arguments, cause);
assertEquals(cause, ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testPrintStackTrace() {
String outMsg = "outer message";
String inMsg = "inner message";
MathException cause = new MathConfigurationException(inMsg, new Object[0]);
MathException ex = new MathException(outMsg, new Object[0], cause);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
PrintStream ps = new PrintStream(baos);
ex.printStackTrace(ps);
String stack = baos.toString();
String outerMsg = "org.apache.commons.math.MathException: outer message";
String innerMsg = "Caused by: " + 
"org.apache.commons.math.MathConfigurationException: inner message";
assertTrue(stack.startsWith(outerMsg));
assertTrue(stack.indexOf(innerMsg) > 0);
PrintWriter pw = new PrintWriter(ps, true);
ex.printStackTrace(pw);
stack = baos.toString();
assertTrue(stack.startsWith(outerMsg));
assertTrue(stack.indexOf(innerMsg) > 0);
public void testSerialization() {
String outMsg = "outer message";
String inMsg = "inner message";
MathException cause = new MathConfigurationException(inMsg, new Object[0]);
MathException ex = new MathException(outMsg, new Object[0], cause);
MathException image = (MathException) TestUtils.serializeAndRecover(ex);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
PrintStream ps = new PrintStream(baos);
ex.printStackTrace(ps);
String stack = baos.toString();
ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
PrintStream ps2 = new PrintStream(baos2);
image.printStackTrace(ps2);
String stack2 = baos2.toString();
boolean jdkSupportsNesting = false;
Throwable.class.getDeclaredMethod("getCause", new Class[0]);
jdkSupportsNesting = true;
jdkSupportsNesting = false;
if (jdkSupportsNesting) {
assertEquals(stack, stack2);
assertTrue(stack2.indexOf(inMsg) != -1);
assertTrue(stack2.indexOf("MathConfigurationException") != -1);
package org.apache.commons.math;
public class TestUtils {
private TestUtils() {
super();
public static void assertEquals(double expected, double actual, double delta) {
assertEquals(null, expected, actual, delta);
public static void assertEquals(String msg, double expected, double actual, double delta) {
if(Double.isNaN(expected)){
Assert.assertTrue("" + actual + " is not NaN.",
Double.isNaN(actual));
Assert.assertEquals(msg, expected, actual, delta);
public static void assertSame(double expected, double actual) {
assertEquals(expected, actual, 0);
public static void assertSame(Complex expected, Complex actual) {
assertSame(expected.getReal(), actual.getReal());
assertSame(expected.getImaginary(), actual.getImaginary());
public static void assertEquals(Complex expected, Complex actual, double delta) {
assertEquals(expected.getReal(), actual.getReal(), delta);
assertEquals(expected.getImaginary(), actual.getImaginary(), delta);
public static void assertEquals(double a[], double b[], double tolerance) {
Assert.assertEquals(a.length, b.length);
for (int i = 0; i < a.length; i++) {
Assert.assertEquals(a[i], b[i], tolerance);
public static Object serializeAndRecover(Object o){
Object result = null;
File tmp = null;
FileOutputStream fo = null;
FileInputStream fi = null;
tmp = File.createTempFile("test",".ser");
fo = new FileOutputStream(tmp);
ObjectOutputStream so = new ObjectOutputStream(fo);
so.writeObject(o);
so.flush();
fo.close();
fi = new FileInputStream(tmp);
ObjectInputStream si = new ObjectInputStream(fi);  
result = si.readObject();
if (fo != null) {
fo.close();
if (fi != null) {
fi.close();
if (tmp != null) {
tmp.delete();
return result;
public static void checkSerializedEquality(Object object) {
Object object2 = serializeAndRecover(object);
Assert.assertEquals("Equals check", object, object2);
Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());
public static void assertRelativelyEquals(double expected, double actual,
double relativeError) {
assertRelativelyEquals(null, expected, actual, relativeError);
public static void assertRelativelyEquals(String msg, double expected,
double actual, double relativeError) {
if (Double.isNaN(expected)) {
Assert.assertTrue(msg, Double.isNaN(actual));
Assert.assertTrue(msg, Double.isNaN(expected));
Assert.assertEquals(expected, actual, relativeError);
Assert.assertEquals(msg, actual, expected, relativeError);
double x = Math.abs((expected - actual) / expected);
Assert.assertEquals(msg, 0.0, x, relativeError);
public static void assertContains(String msg, Complex[] values,
Complex z, double epsilon) {
int i = 0;
boolean found = false;
while (!found && i < values.length) {
assertEquals(values[i], z, epsilon);
found = true; 
i++;
if (!found) {
Assert.fail(msg + 
" Unable to find " + ComplexFormat.formatComplex(z));
public static void assertContains(Complex[] values,
Complex z, double epsilon) {
assertContains(null, values, z, epsilon);      
public static void assertContains(String msg, double[] values,
double x, double epsilon) {
int i = 0;
boolean found = false;
while (!found && i < values.length) {
assertEquals(values[i], x, epsilon);
found = true; 
i++;
if (!found) {
Assert.fail(msg + " Unable to find" + x);
public static void assertContains(double[] values, double x,
double epsilon) {
assertContains(null, values, x, epsilon);
package org.apache.commons.math.analysis;
public final class PolynomialFunctionLagrangeFormTest extends TestCase {
public void testLinearFunction() throws MathException {
PolynomialFunctionLagrangeForm p;
double c[], z, expected, result, tolerance = 1E-12;
double x[] = { 0.0, 3.0 };
double y[] = { -4.0, 0.5 };
p = new PolynomialFunctionLagrangeForm(x, y);
z = 2.0; expected = -1.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 4.5; expected = 2.75; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 6.0; expected = 5.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(1, p.degree());
c = p.getCoefficients();
assertEquals(2, c.length);
assertEquals(-4.0, c[0], tolerance);
assertEquals(1.5, c[1], tolerance);
public void testQuadraticFunction() throws MathException {
PolynomialFunctionLagrangeForm p;
double c[], z, expected, result, tolerance = 1E-12;
double x[] = { 0.0, -1.0, 0.5 };
double y[] = { -3.0, -6.0, 0.0 };
p = new PolynomialFunctionLagrangeForm(x, y);
z = 1.0; expected = 4.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 2.5; expected = 22.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = -2.0; expected = -5.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(2, p.degree());
c = p.getCoefficients();
assertEquals(3, c.length);
assertEquals(-3.0, c[0], tolerance);
assertEquals(5.0, c[1], tolerance);
assertEquals(2.0, c[2], tolerance);
public void testQuinticFunction() throws MathException {
PolynomialFunctionLagrangeForm p;
double c[], z, expected, result, tolerance = 1E-12;
double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };
double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };
p = new PolynomialFunctionLagrangeForm(x, y);
z = 0.0; expected = 0.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = -2.0; expected = 0.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 4.0; expected = 360.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(5, p.degree());
c = p.getCoefficients();
assertEquals(6, c.length);
assertEquals(0.0, c[0], tolerance);
assertEquals(6.0, c[1], tolerance);
assertEquals(1.0, c[2], tolerance);
assertEquals(-7.0, c[3], tolerance);
assertEquals(-1.0, c[4], tolerance);
assertEquals(1.0, c[5], tolerance);
public void testParameters() throws Exception {
double x[] = { 1.0 };
double y[] = { 2.0 };
new PolynomialFunctionLagrangeForm(x, y);
fail("Expecting IllegalArgumentException - bad input array length");
double x[] = { 1.0, 2.0, 3.0, 4.0 };
double y[] = { 0.0, -4.0, -24.0 };
new PolynomialFunctionLagrangeForm(x, y);
fail("Expecting IllegalArgumentException - mismatch input arrays");
package org.apache.commons.math.analysis;
public class PolynomialSplineFunctionTest extends TestCase {
protected double tolerance = 1.0e-12;
protected PolynomialFunction[] polynomials = {
new PolynomialFunction(new double[] {0d, 1d, 1d}), 
new PolynomialFunction(new double[] {2d, 1d, 1d}),
new PolynomialFunction(new double[] {4d, 1d, 1d})
protected double[] knots = {-1, 0, 1, 2};
protected PolynomialFunction dp = 
new PolynomialFunction(new double[] {1d, 2d});
public void testConstructor() {
PolynomialSplineFunction spline = 
new PolynomialSplineFunction(knots, polynomials);
assertTrue(Arrays.equals(knots, spline.getKnots()));
assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);
assertEquals(3, spline.getN());
new PolynomialSplineFunction(new double[] {0}, polynomials);
fail("Expecting IllegalArgumentException");
new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);
fail("Expecting IllegalArgumentException");
new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);
fail("Expecting IllegalArgumentException");
public void testValues() throws Exception {
PolynomialSplineFunction spline = 
new PolynomialSplineFunction(knots, polynomials);
UnivariateRealFunction dSpline = spline.derivative();
double x = -1;
int index = 0;
for (int i = 0; i < 10; i++) {
x+=0.25;
index = findKnot(knots, x);
assertEquals("spline function evaluation failed for x=" + x, 
polynomials[index].value(x - knots[index]), spline.value(x), tolerance);
assertEquals("spline derivative evaluation failed for x=" + x,
dp.value(x - knots[index]), dSpline.value(x), tolerance);
for (int i = 0; i < 3; i++) {
assertEquals("spline function evaluation failed for knot=" + knots[i],
polynomials[i].value(0), spline.value(knots[i]), tolerance);
assertEquals("spline function evaluation failed for knot=" + knots[i],
dp.value(0), dSpline.value(knots[i]), tolerance);
x = spline.value(-1.5);
fail("Expecting IllegalArgumentException");
x = spline.value(2.5);
fail("Expecting IllegalArgumentException");
protected int findKnot(double[] knots, double x) {
if (x < knots[0] || x >= knots[knots.length -1]) {
throw new IllegalArgumentException("x is out of range");
for (int i = 0; i < knots.length; i++) {
if (knots[i] > x) {
return i -1;
throw new IllegalArgumentException("x is out of range");
package org.apache.commons.math.analysis;
public class SplineInterpolatorTest extends TestCase {
protected double knotTolerance = 1E-12;
protected double coefficientTolerance = 1E-6;
protected double interpolationTolerance = 1E-2;
public SplineInterpolatorTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SplineInterpolatorTest.class);
suite.setName("UnivariateRealInterpolator Tests");
return suite;
public void testInterpolateLinearDegenerateTwoSegment()
throws Exception {
double x[] = { 0.0, 0.5, 1.0 };
double y[] = { 0.0, 0.5, 1.0 };
UnivariateRealInterpolator i = new SplineInterpolator();
UnivariateRealFunction f = i.interpolate(x, y);
verifyInterpolation(f, x, y);
verifyConsistency((PolynomialSplineFunction) f, x);
PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();
double target[] = {y[0], 1d, 0d, 0d};
TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[1], 1d, 0d, 0d};
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);
assertEquals(0.0,f.value(0.0), interpolationTolerance);
assertEquals(0.4,f.value(0.4), interpolationTolerance);
assertEquals(1.0,f.value(1.0), interpolationTolerance);
public void testInterpolateLinearDegenerateThreeSegment()
throws Exception {
double x[] = { 0.0, 0.5, 1.0, 1.5 };
double y[] = { 0.0, 0.5, 1.0, 1.5 };
UnivariateRealInterpolator i = new SplineInterpolator();
UnivariateRealFunction f = i.interpolate(x, y);
verifyInterpolation(f, x, y);
PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();
double target[] = {y[0], 1d, 0d, 0d};
TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[1], 1d, 0d, 0d};
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[2], 1d, 0d, 0d};
TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);
assertEquals(0,f.value(0), interpolationTolerance);
assertEquals(1.4,f.value(1.4), interpolationTolerance);
assertEquals(1.5,f.value(1.5), interpolationTolerance);
public void testInterpolateLinear() throws Exception {
double x[] = { 0.0, 0.5, 1.0 };
double y[] = { 0.0, 0.5, 0.0 };
UnivariateRealInterpolator i = new SplineInterpolator();
UnivariateRealFunction f = i.interpolate(x, y);
verifyInterpolation(f, x, y);
verifyConsistency((PolynomialSplineFunction) f, x);
PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();
double target[] = {y[0], 1.5d, 0d, -2d};
TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[1], 0d, -3d, 2d};
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    
public void testInterpolateSin() throws Exception {
double x[] =
0.0,
Math.PI / 6d,
Math.PI / 2d,
5d * Math.PI / 6d,
Math.PI,
7d * Math.PI / 6d,
3d * Math.PI / 2d,
11d * Math.PI / 6d,
2.d * Math.PI };
double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };
UnivariateRealInterpolator i = new SplineInterpolator();
UnivariateRealFunction f = i.interpolate(x, y);
verifyInterpolation(f, x, y);
verifyConsistency((PolynomialSplineFunction) f, x);
PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();
double target[] = {y[0], 1.002676d, 0d, -0.17415829d};
TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};
TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};
TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};
TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};
TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};
TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);
target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};
TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); 
assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);
assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);     
public void testIllegalArguments() throws MathException {
UnivariateRealInterpolator i = new SplineInterpolator();
double xval[] = { 0.0, 1.0 };
double yval[] = { 0.0, 1.0, 2.0 };
i.interpolate(xval, yval);
fail("Failed to detect data set array with different sizes.");
double xval[] = { 0.0, 1.0, 0.5 };
double yval[] = { 0.0, 1.0, 2.0 };
i.interpolate(xval, yval);
fail("Failed to detect unsorted arguments.");
protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])  
throws Exception{
for (int i = 0; i < x.length; i++) {
assertEquals(f.value(x[i]), y[i], knotTolerance);
protected void verifyConsistency(PolynomialSplineFunction f, double x[]) 
throws Exception {
PolynomialFunction polynomials[] = f.getPolynomials();
for (int i = 1; i < x.length - 2; i++) {
assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); 
assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), 
polynomials[i + 1].derivative().value(0), 0.5); 
assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), 
polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); 
package org.apache.commons.math.analysis;
public final class DividedDifferenceInterpolatorTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();
double x[], y[], z, expected, result, tolerance;
int n = 6;
double min = 0.0, max = 2 * Math.PI;
x = new double[n];
y = new double[n];
for (int i = 0; i < n; i++) {
x[i] = min + i * (max - min) / n;
y[i] = f.value(x[i]);
double derivativebound = 1.0;
UnivariateRealFunction p = interpolator.interpolate(x, y);
z = Math.PI / 4; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
public void testExpm1Function() throws MathException {
UnivariateRealFunction f = new Expm1Function();
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();
double x[], y[], z, expected, result, tolerance;
int n = 5;
double min = -1.0, max = 1.0;
x = new double[n];
y = new double[n];
for (int i = 0; i < n; i++) {
x[i] = min + i * (max - min) / n;
y[i] = f.value(x[i]);
double derivativebound = Math.E;
UnivariateRealFunction p = interpolator.interpolate(x, y);
z = 0.0; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = 0.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = -0.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();
double x[] = { 1.0, 2.0, 2.0, 4.0 };
double y[] = { 0.0, 4.0, 4.0, 2.5 };
UnivariateRealFunction p = interpolator.interpolate(x, y);
p.value(0.0);
fail("Expecting MathException - bad abscissas array");
protected double partialerror(double x[], double z) throws
IllegalArgumentException {
if (x.length < 1) {
throw new IllegalArgumentException
("Interpolation array cannot be empty.");
double out = 1;
for (int i = 0; i < x.length; i++) {
out *= (z - x[i]) / (i + 1);
return out;
package org.apache.commons.math.analysis;
public class UnivariateRealSolverUtilsTest extends TestCase {
protected UnivariateRealFunction sin = new SinFunction();
public void testSolveNull() throws MathException {
UnivariateRealSolverUtils.solve(null, 0.0, 4.0);
fail();
public void testSolveBadParameters() throws MathException {
UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); 
UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); 
public void testSolveSin() throws MathException {     
double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);
assertEquals(Math.PI, x, 1.0e-4);
public void testSolveAccuracyNull()  throws MathException {
double accuracy = 1.0e-6;
UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);
fail();
public void testSolveAccuracySin() throws MathException {
double accuracy = 1.0e-6;
double x = UnivariateRealSolverUtils.solve(sin, 1.0,
4.0, accuracy);
assertEquals(Math.PI, x, accuracy);
public void testSolveNoRoot() throws MathException {
UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);  
fail("Expecting IllegalArgumentException ");  
public void testBracketSin() throws MathException {
double[] result = UnivariateRealSolverUtils.bracket(sin, 
0.0, -2.0, 2.0);
assertTrue(sin.value(result[0]) < 0);
assertTrue(sin.value(result[1]) > 0);
public void testBracketCornerSolution() throws MathException {
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); 
fail("Expecting ConvergenceException");
public void testBadParameters() throws MathException {
UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);
fail("Expecting IllegalArgumentException");
UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);
fail("Expecting IllegalArgumentException");
UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);
fail("Expecting IllegalArgumentException");
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);
fail("Expecting IllegalArgumentException");
package org.apache.commons.math.analysis;
public final class NevilleInterpolatorTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealInterpolator interpolator = new NevilleInterpolator();
double x[], y[], z, expected, result, tolerance;
int n = 6;
double min = 0.0, max = 2 * Math.PI;
x = new double[n];
y = new double[n];
for (int i = 0; i < n; i++) {
x[i] = min + i * (max - min) / n;
y[i] = f.value(x[i]);
double derivativebound = 1.0;
UnivariateRealFunction p = interpolator.interpolate(x, y);
z = Math.PI / 4; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
public void testExpm1Function() throws MathException {
UnivariateRealFunction f = new Expm1Function();
UnivariateRealInterpolator interpolator = new NevilleInterpolator();
double x[], y[], z, expected, result, tolerance;
int n = 5;
double min = -1.0, max = 1.0;
x = new double[n];
y = new double[n];
for (int i = 0; i < n; i++) {
x[i] = min + i * (max - min) / n;
y[i] = f.value(x[i]);
double derivativebound = Math.E;
UnivariateRealFunction p = interpolator.interpolate(x, y);
z = 0.0; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = 0.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
z = -0.5; expected = f.value(z); result = p.value(z);
tolerance = Math.abs(derivativebound * partialerror(x, z));
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealInterpolator interpolator = new NevilleInterpolator();
double x[] = { 1.0, 2.0, 2.0, 4.0 };
double y[] = { 0.0, 4.0, 4.0, 2.5 };
UnivariateRealFunction p = interpolator.interpolate(x, y);
p.value(0.0);
fail("Expecting MathException - bad abscissas array");
protected double partialerror(double x[], double z) throws
IllegalArgumentException {
if (x.length < 1) {
throw new IllegalArgumentException
("Interpolation array cannot be empty.");
double out = 1;
for (int i = 0; i < x.length; i++) {
out *= (z - x[i]) / (i + 1);
return out;
package org.apache.commons.math.analysis;
public class MonitoredFunction implements UnivariateRealFunction {
public MonitoredFunction(UnivariateRealFunction f) {
callsCount = 0;
this.f = f;
public void setCallsCount(int callsCount) {
this.callsCount = callsCount;
public int getCallsCount() {
return callsCount;
public double value(double x) throws FunctionEvaluationException {
++callsCount;
return f.value(x);
private int callsCount;
private UnivariateRealFunction f;
package org.apache.commons.math.analysis;
public final class TrapezoidIntegratorTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = Math.PI; expected = 2;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -Math.PI/3; max = 0; expected = -0.5;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = 1; expected = -1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = 0; max = 0.5; expected = 11.0/768;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);
integrator.integrate(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
package org.apache.commons.math.analysis;
public final class BrentSolverTest extends TestCase {
public BrentSolverTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(BrentSolverTest.class);
suite.setName("UnivariateRealSolver Tests");
return suite;
public void testSinZero() throws MathException {
UnivariateRealFunction f = new SinFunction();
double result;
UnivariateRealSolver solver = new BrentSolver(f);
result = solver.solve(3, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 5);
result = solver.solve(1, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 6);
solver = new SecantSolver(f);
result = solver.solve(3, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 5);
result = solver.solve(1, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 6);
assertEquals(result, solver.getResult(), 0);
public void testQuinticZero() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
double result;
UnivariateRealSolver solver = new BrentSolver(f);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 2);
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 6);
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 7);
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 7);
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 7);
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 9);
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 9);
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 9);
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 11);
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 8);
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 13);
solver = new SecantSolver(f);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 2);
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 6);
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 7);
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 8);
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 7);
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 9);
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 11);
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 9);
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 15);
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 8);
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(solver.getIterationCount() <= 15);
result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);
assertEquals(result, 0, 1E-8);
result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);
assertEquals(result, 0, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);
assertEquals(result, 0.5, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);
assertEquals(result, 0.5, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);
assertEquals(result, 0.5, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);
assertEquals(result, 1.0, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);
assertEquals(result, 1.0, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);
assertEquals(result, 1.0, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);
assertEquals(result, 1.0, 1E-6);
result = UnivariateRealSolverUtils.solve(f, 0.85, 5);
assertEquals(result, 1.0, 1E-6);
public void testBadEndpoints() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new BrentSolver(f);
solver.solve(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
solver.solve(1, 1.5);
fail("Expecting IllegalArgumentException - non-bracketing");
public void testInitialGuess() throws MathException {
MonitoredFunction f = new MonitoredFunction(new QuinticFunction());
UnivariateRealSolver solver = new BrentSolver(f);
double result;
result = solver.solve(0.6, 7.0);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
int referenceCallsCount = f.getCallsCount();
assertTrue(referenceCallsCount >= 13);
result = solver.solve(0.6, 7.0, 0.0);
fail("an IllegalArgumentException was expected");
fail("wrong exception caught: " + e.getMessage());
f.setCallsCount(0);
result = solver.solve(0.6, 7.0, 0.61);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(f.getCallsCount() > referenceCallsCount);
f.setCallsCount(0);
result = solver.solve(0.6, 7.0, 0.999999);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertTrue(f.getCallsCount() < referenceCallsCount);
f.setCallsCount(0);
result = solver.solve(0.6, 7.0, 1.0);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(0, solver.getIterationCount());
assertEquals(1, f.getCallsCount());
package org.apache.commons.math.analysis;
public class QuinticFunction implements DifferentiableUnivariateRealFunction, Serializable {
private static final long serialVersionUID = -8866263034920607152L;
public double value(double x) throws FunctionEvaluationException {
return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);
public UnivariateRealFunction derivative() {
return new UnivariateRealFunction() {
public double value(double x) throws FunctionEvaluationException {
return (5*x*x-3.75)*x*x+0.25;
package org.apache.commons.math.analysis;
public final class PolynomialFunctionTest extends TestCase {
protected double tolerance = 1.0e-12;
public void testConstants() throws MathException {
double[] c = { 2.5 };
PolynomialFunction f = new PolynomialFunction( c );
assertEquals( f.value( 0.0), c[0], tolerance );
assertEquals( f.value( -1.0), c[0], tolerance );
assertEquals( f.value( -123.5), c[0], tolerance );
assertEquals( f.value( 3.0), c[0], tolerance );
assertEquals( f.value( 456.89), c[0], tolerance );
assertEquals(f.degree(), 0);
assertEquals(f.derivative().value(0), 0, tolerance);
assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);
public void testLinear() throws MathException {
double[] c = { -1.5, 3.0 };
PolynomialFunction f = new PolynomialFunction( c );
assertEquals( f.value( 0.0), c[0], tolerance );
assertEquals( -4.5, f.value( -1.0), tolerance );
assertEquals( -9.0, f.value( -2.5), tolerance );
assertEquals( 0.0, f.value( 0.5), tolerance );
assertEquals( 3.0, f.value( 1.5), tolerance );
assertEquals( 7.5, f.value( 3.0), tolerance );
assertEquals(f.degree(), 1);
assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);
public void testQuadratic() throws MathException {
double[] c = { -2.0, -3.0, 2.0 };
PolynomialFunction f = new PolynomialFunction( c );
assertEquals( f.value( 0.0), c[0], tolerance );
assertEquals( 0.0, f.value( -0.5), tolerance );
assertEquals( 0.0, f.value( 2.0), tolerance );
assertEquals( -2.0, f.value( 1.5), tolerance );
assertEquals( 7.0, f.value( -1.5), tolerance );
assertEquals( 265.5312, f.value( 12.34), tolerance );
public void testQuintic() throws MathException {
double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };
PolynomialFunction f = new PolynomialFunction( c );
assertEquals( f.value( 0.0), c[0], tolerance );
assertEquals( 0.0, f.value( 5.0), tolerance );
assertEquals( 0.0, f.value( 1.0), tolerance );
assertEquals( 0.0, f.value( -3.0), tolerance );
assertEquals( 54.84375, f.value( -1.5), tolerance );
assertEquals( -8.06637, f.value( 1.3), tolerance );
assertEquals(f.degree(), 5);
public void testfirstDerivativeComparison() throws MathException {
double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };
double[] g_coeff = { 6.0, -4.0, 3.0 };
double[] h_coeff = { -4.0, 6.0 };
PolynomialFunction f = new PolynomialFunction( f_coeff );
PolynomialFunction g = new PolynomialFunction( g_coeff );
PolynomialFunction h = new PolynomialFunction( h_coeff );
assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );
assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );
assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );
assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );
assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );
assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );
assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );
package org.apache.commons.math.analysis;
public final class LaguerreSolverTest extends TestCase {
public void testLinearFunction() throws MathException {
double min, max, expected, result, tolerance;
double coefficients[] = { -1.0, 4.0 };
PolynomialFunction f = new PolynomialFunction(coefficients);
UnivariateRealSolver solver = new LaguerreSolver(f);
min = 0.0; max = 1.0; expected = 0.25;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testQuadraticFunction() throws MathException {
double min, max, expected, result, tolerance;
double coefficients[] = { -3.0, 5.0, 2.0 };
PolynomialFunction f = new PolynomialFunction(coefficients);
UnivariateRealSolver solver = new LaguerreSolver(f);
min = 0.0; max = 2.0; expected = 0.5;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -4.0; max = -1.0; expected = -3.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
double min, max, expected, result, tolerance;
double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };
PolynomialFunction f = new PolynomialFunction(coefficients);
UnivariateRealSolver solver = new LaguerreSolver(f);
min = -2.0; max = 2.0; expected = -1.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -5.0; max = -2.5; expected = -3.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = 3.0; max = 6.0; expected = 4.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction2() throws MathException {
double initial = 0.0, tolerance;
Complex expected, result[];
double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };
PolynomialFunction f = new PolynomialFunction(coefficients);
LaguerreSolver solver = new LaguerreSolver(f);
result = solver.solveAll(coefficients, initial);
expected = new Complex(0.0, -2.0);
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
TestUtils.assertContains(result, expected, tolerance);
expected = new Complex(0.0, 2.0);
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
TestUtils.assertContains(result, expected, tolerance);
expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
TestUtils.assertContains(result, expected, tolerance);
expected = new Complex(-1.0, 0.0);
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
TestUtils.assertContains(result, expected, tolerance);
expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
TestUtils.assertContains(result, expected, tolerance);
public void testParameters() throws Exception {
double coefficients[] = { -3.0, 5.0, 2.0 };
PolynomialFunction f = new PolynomialFunction(coefficients);
UnivariateRealSolver solver = new LaguerreSolver(f);
solver.solve(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
solver.solve(2, 3);
fail("Expecting IllegalArgumentException - no bracketing");
UnivariateRealFunction f2 = new SinFunction();
new LaguerreSolver(f2);
fail("Expecting IllegalArgumentException - bad function");
package org.apache.commons.math.analysis;
public class Expm1Function implements DifferentiableUnivariateRealFunction {
public double value(double x) throws FunctionEvaluationException {
return Math.exp(x) - 1.0;
public UnivariateRealFunction derivative() {
return new UnivariateRealFunction() {
public double value(double x) throws FunctionEvaluationException {
return Math.exp(x);
package org.apache.commons.math.analysis;
public final class RiddersSolverTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new RiddersSolver(f);
double min, max, expected, result, tolerance;
min = 3.0; max = 4.0; expected = Math.PI;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -1.0; max = 1.5; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new RiddersSolver(f);
double min, max, expected, result, tolerance;
min = -0.4; max = 0.2; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = 0.75; max = 1.5; expected = 1.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -0.9; max = -0.2; expected = -0.5;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testExpm1Function() throws MathException {
UnivariateRealFunction f = new Expm1Function();
UnivariateRealSolver solver = new RiddersSolver(f);
double min, max, expected, result, tolerance;
min = -1.0; max = 2.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -20.0; max = 10.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -50.0; max = 100.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new RiddersSolver(f);
solver.solve(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
solver.solve(2, 3);
fail("Expecting IllegalArgumentException - no bracketing");
package org.apache.commons.math.analysis;
public final class BisectionSolverTest extends TestCase {
public void testSinZero() throws MathException {
UnivariateRealFunction f = new SinFunction();
double result;
UnivariateRealSolver solver = new BisectionSolver(f);
result = solver.solve(3, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
result = solver.solve(1, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
public void testQuinticZero() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
double result;
UnivariateRealSolver solver = new BisectionSolver(f);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(result, solver.getResult(), 0);
assertTrue(solver.getIterationCount() > 0);
public void testSetFunctionValueAccuracy(){
double expected = 1.0e-2;    
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
solver.setFunctionValueAccuracy(expected);
assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);
public void testResetFunctionValueAccuracy(){
double newValue = 1.0e-2;    
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
double oldValue = solver.getFunctionValueAccuracy();
solver.setFunctionValueAccuracy(newValue);
solver.resetFunctionValueAccuracy();
assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);
public void testSetAbsoluteAccuracy(){
double expected = 1.0e-2; 
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
solver.setAbsoluteAccuracy(expected);
assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); 
public void testResetAbsoluteAccuracy(){
double newValue = 1.0e-2;       
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
double oldValue = solver.getAbsoluteAccuracy();
solver.setAbsoluteAccuracy(newValue);
solver.resetAbsoluteAccuracy();
assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);
public void testSetMaximalIterationCount(){
int expected = 100;
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
solver.setMaximalIterationCount(expected);
assertEquals(expected, solver.getMaximalIterationCount());
public void testResetMaximalIterationCount(){
int newValue = 10000;
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
int oldValue = solver.getMaximalIterationCount();
solver.setMaximalIterationCount(newValue);
solver.resetMaximalIterationCount();
assertEquals(oldValue, solver.getMaximalIterationCount());
public void testSetRelativeAccuracy(){
double expected = 1.0e-2;
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
solver.setRelativeAccuracy(expected);
assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);
public void testResetRelativeAccuracy(){
double newValue = 1.0e-2;        
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new BisectionSolver(f);
double oldValue = solver.getRelativeAccuracy();
solver.setRelativeAccuracy(newValue);
solver.resetRelativeAccuracy();
assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);
public void testSerialization() throws MathException {
UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());
double result;
BisectionSolver solver = new BisectionSolver(f);
UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());
double newValue = 1.0e-2;
f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());
solver = new BisectionSolver(f);
double oldValue = solver.getRelativeAccuracy();
solver.setRelativeAccuracy(newValue);
solver.resetRelativeAccuracy();
assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);
solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); 
assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
solver2.setRelativeAccuracy(newValue);
solver2.resetRelativeAccuracy();
assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
package org.apache.commons.math.analysis;
public final class RombergIntegratorTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new RombergIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = Math.PI; expected = 2;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -Math.PI/3; max = 0; expected = -0.5;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealIntegrator integrator = new RombergIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = 1; expected = -1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = 0; max = 0.5; expected = 11.0/768;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new RombergIntegrator(f);
integrator.integrate(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(50);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
package org.apache.commons.math.analysis;
public final class NewtonSolverTest extends TestCase {
public void testSinZero() throws MathException {
DifferentiableUnivariateRealFunction f = new SinFunction();
double result;
UnivariateRealSolver solver = new NewtonSolver(f);
result = solver.solve(3, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
result = solver.solve(1, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertEquals(result, solver.getResult(), 0);
assertTrue(solver.getIterationCount() > 0);
public void testQuinticZero() throws MathException {
DifferentiableUnivariateRealFunction f = new QuinticFunction();
double result;
UnivariateRealSolver solver = new BisectionSolver(f);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
public void testSerialization() throws MathException {
DifferentiableUnivariateRealFunction f = new QuinticFunction();
double result;
NewtonSolver solver = new NewtonSolver(f);
NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);
result = solver.solve(-0.2, 0.2);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());
result = solver.solve(-0.1, 0.3);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());
result = solver.solve(-0.3, 0.45);
assertEquals(result, 0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.3, 0.7);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.2, 0.6);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.05, 0.95);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.25);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.8, 1.2);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 1.75);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.55, 1.45);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());
result = solver.solve(0.85, 5);
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());
double newValue = 1.0e-2;
f = new QuinticFunction();
solver = new NewtonSolver(f);
double oldValue = solver.getRelativeAccuracy();
solver.setRelativeAccuracy(newValue);
solver.resetRelativeAccuracy();
assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);
solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); 
assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
solver2.setRelativeAccuracy(newValue);
solver2.resetRelativeAccuracy();
assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
package org.apache.commons.math.analysis;
public final class MullerSolverTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = 3.0; max = 4.0; expected = Math.PI;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -1.0; max = 1.5; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testSinFunction2() throws MathException {
UnivariateRealFunction f = new SinFunction();
MullerSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = 3.0; max = 4.0; expected = Math.PI;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
min = -1.0; max = 1.5; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = -0.4; max = 0.2; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = 0.75; max = 1.5; expected = 1.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -0.9; max = -0.2; expected = -0.5;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction2() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
MullerSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = -0.4; max = 0.2; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
min = 0.75; max = 1.5; expected = 1.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
min = -0.9; max = -0.2; expected = -0.5;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
public void testExpm1Function() throws MathException {
UnivariateRealFunction f = new Expm1Function();
UnivariateRealSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = -1.0; max = 2.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -20.0; max = 10.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
min = -50.0; max = 100.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve(min, max);
assertEquals(expected, result, tolerance);
public void testExpm1Function2() throws MathException {
UnivariateRealFunction f = new Expm1Function();
MullerSolver solver = new MullerSolver(f);
double min, max, expected, result, tolerance;
min = -1.0; max = 2.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
min = -20.0; max = 10.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
min = -50.0; max = 100.0; expected = 0.0;
tolerance = Math.max(solver.getAbsoluteAccuracy(),
Math.abs(expected * solver.getRelativeAccuracy()));
result = solver.solve2(min, max);
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new MullerSolver(f);
solver.solve(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
solver.solve(2, 3);
fail("Expecting IllegalArgumentException - no bracketing");
package org.apache.commons.math.analysis;
public class UnivariateRealSolverFactoryImplTest extends TestCase {
private UnivariateRealSolverFactory factory;
private DifferentiableUnivariateRealFunction function;
protected void setUp() throws Exception {
super.setUp();
factory = new UnivariateRealSolverFactoryImpl();
function = new SinFunction();
protected void tearDown() throws Exception {
factory = null;
function = null;
super.tearDown();
public void testNewBisectionSolverNull() {
factory.newBisectionSolver(null);
fail();
public void testNewBisectionSolverValid() {
UnivariateRealSolver solver = factory.newBisectionSolver(function);
assertNotNull(solver);
assertTrue(solver instanceof BisectionSolver);
public void testNewNewtonSolverNull() {
factory.newNewtonSolver(null);
fail();
public void testNewNewtonSolverValid() {
UnivariateRealSolver solver = factory.newNewtonSolver(function);
assertNotNull(solver);
assertTrue(solver instanceof NewtonSolver);
public void testNewBrentSolverNull() {
factory.newBrentSolver(null);
fail();
public void testNewBrentSolverValid() {
UnivariateRealSolver solver = factory.newBrentSolver(function);
assertNotNull(solver);
assertTrue(solver instanceof BrentSolver);
public void testNewSecantSolverNull() {
factory.newSecantSolver(null);
fail();
public void testNewSecantSolverValid() {
UnivariateRealSolver solver = factory.newSecantSolver(function);
assertNotNull(solver);
assertTrue(solver instanceof SecantSolver);
package org.apache.commons.math.analysis;
public final class PolynomialFunctionNewtonFormTest extends TestCase {
public void testLinearFunction() throws MathException {
PolynomialFunctionNewtonForm p;
double coefficients[], z, expected, result, tolerance = 1E-12;
double a[] = { 2.0, 1.5 };
double c[] = { 4.0 };
p = new PolynomialFunctionNewtonForm(a, c);
z = 2.0; expected = -1.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 4.5; expected = 2.75; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 6.0; expected = 5.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(1, p.degree());
coefficients = p.getCoefficients();
assertEquals(2, coefficients.length);
assertEquals(-4.0, coefficients[0], tolerance);
assertEquals(1.5, coefficients[1], tolerance);
public void testQuadraticFunction() throws MathException {
PolynomialFunctionNewtonForm p;
double coefficients[], z, expected, result, tolerance = 1E-12;
double a[] = { 4.0, 3.0, 2.0 };
double c[] = { 1.0, -2.0 };
p = new PolynomialFunctionNewtonForm(a, c);
z = 1.0; expected = 4.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 2.5; expected = 22.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = -2.0; expected = -5.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(2, p.degree());
coefficients = p.getCoefficients();
assertEquals(3, coefficients.length);
assertEquals(-3.0, coefficients[0], tolerance);
assertEquals(5.0, coefficients[1], tolerance);
assertEquals(2.0, coefficients[2], tolerance);
public void testQuinticFunction() throws MathException {
PolynomialFunctionNewtonForm p;
double coefficients[], z, expected, result, tolerance = 1E-12;
double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };
double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };
p = new PolynomialFunctionNewtonForm(a, c);
z = 0.0; expected = 0.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = -2.0; expected = 0.0; result = p.value(z);
assertEquals(expected, result, tolerance);
z = 4.0; expected = 360.0; result = p.value(z);
assertEquals(expected, result, tolerance);
assertEquals(5, p.degree());
coefficients = p.getCoefficients();
assertEquals(6, coefficients.length);
assertEquals(0.0, coefficients[0], tolerance);
assertEquals(6.0, coefficients[1], tolerance);
assertEquals(1.0, coefficients[2], tolerance);
assertEquals(-7.0, coefficients[3], tolerance);
assertEquals(-1.0, coefficients[4], tolerance);
assertEquals(1.0, coefficients[5], tolerance);
public void testParameters() throws Exception {
double a[] = { 1.0 };
double c[] = { 2.0 };
new PolynomialFunctionNewtonForm(a, c);
fail("Expecting IllegalArgumentException - bad input array length");
double a[] = { 1.0, 2.0, 3.0, 4.0 };
double c[] = { 4.0, 3.0, 2.0, 1.0 };
new PolynomialFunctionNewtonForm(a, c);
fail("Expecting IllegalArgumentException - mismatch input arrays");
package org.apache.commons.math.analysis;
public final class SimpsonIntegratorTest extends TestCase {
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = Math.PI; expected = 2;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -Math.PI/3; max = 0; expected = -0.5;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testQuinticFunction() throws MathException {
UnivariateRealFunction f = new QuinticFunction();
UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);
double min, max, expected, result, tolerance;
min = 0; max = 1; expected = -1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = 0; max = 0.5; expected = 11.0/768;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
result = integrator.integrate(min, max);
assertEquals(expected, result, tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);
integrator.integrate(1, -1);
fail("Expecting IllegalArgumentException - bad interval");
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
integrator.integrate(-1, 1);
fail("Expecting IllegalArgumentException - bad iteration limits");
package org.apache.commons.math.analysis;
public class SinFunction implements DifferentiableUnivariateRealFunction {
public double value(double x) throws FunctionEvaluationException {
return Math.sin(x);
public UnivariateRealFunction derivative() {
return new UnivariateRealFunction() {
public double value(double x) throws FunctionEvaluationException {
return Math.cos(x);
package org.apache.commons.math.util;
public abstract class DoubleArrayAbstractTest extends TestCase {
protected DoubleArray da = null;
protected DoubleArray ra = null;
public DoubleArrayAbstractTest(String name) {
super(name);
public void testAdd1000() {
for (int i = 0; i < 1000; i++) {
da.addElement(i);
assertEquals(
"Number of elements should be equal to 1000 after adding 1000 values",
1000,
da.getNumElements());
assertEquals(
"The element at the 56th index should be 56",
56.0,
da.getElement(56),
Double.MIN_VALUE);
public void testGetValues() {
double[] controlArray = { 2.0, 4.0, 6.0 };
da.addElement(2.0);
da.addElement(4.0);
da.addElement(6.0);
double[] testArray = da.getElements();
for (int i = 0; i < da.getNumElements(); i++) {
assertEquals(
"The testArray values should equal the controlArray values, index i: "
+ i
+ " does not match",
testArray[i],
controlArray[i],
Double.MIN_VALUE);
public void testAddElementRolling() {
ra.addElement(0.5);
ra.addElement(1.0);
ra.addElement(1.0);
ra.addElement(1.0);
ra.addElement(1.0);
ra.addElement(1.0);
ra.addElementRolling(2.0);
assertEquals(
"There should be 6 elements in the eda",
6,
ra.getNumElements());
assertEquals(
"The max element should be 2.0",
2.0,
StatUtils.max(ra.getElements()),
Double.MIN_VALUE);
assertEquals(
"The min element should be 1.0",
1.0,
StatUtils.min(ra.getElements()),
Double.MIN_VALUE);
for (int i = 0; i < 1024; i++) {
ra.addElementRolling(i);
assertEquals(
"We just inserted 1024 rolling elements, num elements should still be 6",
6,
ra.getNumElements());
public void testMinMax() {
da.addElement(2.0);
da.addElement(22.0);
da.addElement(-2.0);
da.addElement(21.0);
da.addElement(22.0);
da.addElement(42.0);
da.addElement(62.0);
da.addElement(22.0);
da.addElement(122.0);
da.addElement(1212.0);
assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);
assertEquals(
"Max should be 1212.0",
1212.0,
StatUtils.max(da.getElements()),
Double.MIN_VALUE);
package org.apache.commons.math.util;
public class TestBean {
private Double x = new Double(1.0);
private String y = "1.0";
public Double getX() {
return x;
public String getY() {
return y;
public void setX(Double double1) {
x = double1;
public void setY(String string) {
y = string;
public Double getZ() {
throw new RuntimeException();
public void setZ(Double double1) {
package org.apache.commons.math.util;
public class DefaultTransformerTest extends TestCase {
public void testTransformDouble() throws Exception {
double expected = 1.0;
Double input = new Double(expected);
DefaultTransformer t = new DefaultTransformer();
assertEquals(expected, t.transform(input), 1.0e-4);
public void testTransformNull(){
DefaultTransformer t = new DefaultTransformer();
t.transform(null);
fail("Expection MathException");
public void testTransformInteger() throws Exception {
double expected = 1.0;
Integer input = new Integer(1);
DefaultTransformer t = new DefaultTransformer();
assertEquals(expected, t.transform(input), 1.0e-4);
public void testTransformBigDecimal() throws Exception {
double expected = 1.0;
BigDecimal input = new BigDecimal("1.0");
DefaultTransformer t = new DefaultTransformer();
assertEquals(expected, t.transform(input), 1.0e-4);
public void testTransformString() throws Exception {
double expected = 1.0;
String input = "1.0";
DefaultTransformer t = new DefaultTransformer();
assertEquals(expected, t.transform(input), 1.0e-4);
public void testTransformObject(){
Boolean input = Boolean.TRUE;
DefaultTransformer t = new DefaultTransformer();
t.transform(input);
fail("Expecting MathException");
package org.apache.commons.math.util;
public class TransformerMapTest extends TestCase {
public void testPutTransformer(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertEquals(expected, map.getTransformer(TransformerMapTest.class));
public void testContainsClass(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.containsClass(TransformerMapTest.class));
public void testContainsTransformer(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.containsTransformer(expected));
public void testRemoveTransformer(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.containsClass(TransformerMapTest.class));
assertTrue(map.containsTransformer(expected));
map.removeTransformer(TransformerMapTest.class);
assertFalse(map.containsClass(TransformerMapTest.class));
assertFalse(map.containsTransformer(expected));
public void testClear(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.containsClass(TransformerMapTest.class));
map.clear();
assertFalse(map.containsClass(TransformerMapTest.class));
public void testClasses(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.classes().contains(TransformerMapTest.class));
public void testTransformers(){
NumberTransformer expected = new DefaultTransformer();
TransformerMap map = new TransformerMap();
map.putTransformer(TransformerMapTest.class, expected);
assertTrue(map.transformers().contains(expected));
package org.apache.commons.math.util;
public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {
public ResizableDoubleArrayTest(String name) {
super( name );
protected void tearDown() throws Exception {
da = null;
ra = null;
protected void setUp() throws Exception {
da = new ResizableDoubleArray();
ra = new ResizableDoubleArray();
public void testConstructors() {
float defaultExpansionFactor = 2.0f;
float defaultContractionCriteria = 2.5f;
int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;
ResizableDoubleArray testDa = new ResizableDoubleArray(2);
assertEquals(0, testDa.getNumElements());
assertEquals(2, testDa.getInternalLength());
assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);
assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);
assertEquals(defaultMode, testDa.getExpansionMode());
da = new ResizableDoubleArray(-1);
fail("Expecting IllegalArgumentException");
testDa = new ResizableDoubleArray(2, 2.0f);
assertEquals(0, testDa.getNumElements());
assertEquals(2, testDa.getInternalLength());
assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);
assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);
assertEquals(defaultMode, testDa.getExpansionMode());
da = new ResizableDoubleArray(2, 0.5f);
fail("Expecting IllegalArgumentException");
testDa = new ResizableDoubleArray(2, 3.0f);
assertEquals(3.0f, testDa.getExpansionFactor(), 0);
assertEquals(3.5f, testDa.getContractionCriteria(), 0);
testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);
assertEquals(0, testDa.getNumElements());
assertEquals(2, testDa.getInternalLength());
assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);
assertEquals(3.0f, testDa.getContractionCriteria(), 0);
assertEquals(defaultMode, testDa.getExpansionMode());
da = new ResizableDoubleArray(2, 2.0f, 1.5f);
fail("Expecting IllegalArgumentException");
testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, 
ResizableDoubleArray.ADDITIVE_MODE);
assertEquals(0, testDa.getNumElements());
assertEquals(2, testDa.getInternalLength());
assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);
assertEquals(3.0f, testDa.getContractionCriteria(), 0);
assertEquals(ResizableDoubleArray.ADDITIVE_MODE, 
testDa.getExpansionMode());
da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);
fail("Expecting IllegalArgumentException");
public void testSetElementArbitraryExpansion() {
da.addElement(2.0);
da.addElement(4.0);
da.addElement(6.0);
da.setElement(1, 3.0);
da.setElement(1000, 3.4);
assertEquals( "The number of elements should now be 1001, it isn't", 
da.getNumElements(), 1001);
assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,
da.getElement( 760 ), Double.MIN_VALUE );
assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), 
Double.MIN_VALUE );
assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), 
Double.MIN_VALUE); 
da.clear();
da.addElement(2.0);
da.addElement(4.0);
da.addElement(6.0);
assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());
assertEquals(3, da.getNumElements());
da.setElement(3, 7.0);
assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());
assertEquals(4, da.getNumElements());
da.setElement(10, 10.0);
assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());
assertEquals(11, da.getNumElements());
da.setElement(9, 10.0);
assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());
assertEquals(11, da.getNumElements());
da.setElement(-2, 3);
fail("Expecting ArrayIndexOutOfBoundsException for negative index");
ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, 
ResizableDoubleArray.ADDITIVE_MODE);
assertEquals(2, testDa.getInternalLength());
testDa.addElement(1d);
testDa.addElement(1d);
assertEquals(2, testDa.getInternalLength());
testDa.addElement(1d);
assertEquals(4, testDa.getInternalLength());         
public void testAdd1000() {
super.testAdd1000();
assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +
"16 and an expansion factor of 2.0",
1024, ((ResizableDoubleArray) da).getInternalLength());
public void testAddElementRolling() {
super.testAddElementRolling();
da.clear();
da.addElement(1);
da.addElement(2);
da.addElementRolling(3);
assertEquals(3, da.getElement(1), 0);
da.addElementRolling(4);
assertEquals(3, da.getElement(0), 0);
assertEquals(4, da.getElement(1), 0);
da.addElement(5);
assertEquals(5, da.getElement(2), 0);
da.addElementRolling(6);
assertEquals(4, da.getElement(0), 0);
assertEquals(5, da.getElement(1), 0);
assertEquals(6, da.getElement(2), 0);   
ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, 
ResizableDoubleArray.ADDITIVE_MODE);
assertEquals(2, testDa.getInternalLength());
testDa.addElement(1d); // x,0
testDa.addElement(2d); // x,x
testDa.addElement(3d); // x,x,x,0 -- expanded
assertEquals(1d, testDa.getElement(0), 0);
assertEquals(2d, testDa.getElement(1), 0);
assertEquals(3d, testDa.getElement(2), 0);   
assertEquals(4, testDa.getInternalLength());  // x,x,x,0 
assertEquals(3, testDa.getNumElements());
testDa.addElementRolling(4d);
assertEquals(2d, testDa.getElement(0), 0);
assertEquals(3d, testDa.getElement(1), 0);
assertEquals(4d, testDa.getElement(2), 0);   
assertEquals(4, testDa.getInternalLength());  // 0,x,x,x
assertEquals(3, testDa.getNumElements());
testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract
assertEquals(3d, testDa.getElement(0), 0);
assertEquals(4d, testDa.getElement(1), 0);
assertEquals(5d, testDa.getElement(2), 0);   
assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0     
assertEquals(3, testDa.getNumElements());
testDa.getElement(4);
fail("Expecting ArrayIndexOutOfBoundsException");
testDa.getElement(-1);
fail("Expecting ArrayIndexOutOfBoundsException");
public void testSetNumberOfElements() {
da.addElement( 1.0 );
da.addElement( 1.0 );
da.addElement( 1.0 );
da.addElement( 1.0 );
da.addElement( 1.0 );
da.addElement( 1.0 );
assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);
((ResizableDoubleArray) da).setNumElements( 3 );
assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);
((ResizableDoubleArray) da).setNumElements( -3 );
fail( "Setting number of elements to negative should've thrown an exception");
((ResizableDoubleArray) da).setNumElements(1024);
assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);
assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);
public void testWithInitialCapacity() {
ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);
assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());
RandomData randomData = new RandomDataImpl();
int iterations = randomData.nextInt(100, 1000);
for( int i = 0; i < iterations; i++) {
eDA2.addElement( i );
assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());
eDA2.addElement( 2.0 );
assertEquals("Number of elements should be equals to " + (iterations +1),
iterations + 1 , eDA2.getNumElements() );
public void testWithInitialCapacityAndExpansionFactor() {
ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);
assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );
RandomData randomData = new RandomDataImpl();
int iterations = randomData.nextInt(100, 3000);
for( int i = 0; i < iterations; i++) {
eDA3.addElement( i );
assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());
eDA3.addElement( 2.0 );
assertEquals("Number of elements should be equals to " + (iterations +1),
iterations +1, eDA3.getNumElements() );
assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);
public void testDiscard() {
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
da.addElement(2.0);
assertEquals( "Number of elements should be 11", 11, da.getNumElements());
((ResizableDoubleArray)da).discardFrontElements(5);
assertEquals( "Number of elements should be 6", 6, da.getNumElements());
((ResizableDoubleArray)da).discardFrontElements(-1);
fail( "Trying to discard a negative number of element is not allowed");
((ResizableDoubleArray)da).discardFrontElements( 10000 );
fail( "You can't discard more elements than the array contains");
public void testMutators() {
((ResizableDoubleArray)da).setContractionCriteria(10f);
assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);
((ResizableDoubleArray)da).setExpansionFactor(8f);  
assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);
((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria
fail("Expecting IllegalArgumentException");
((ResizableDoubleArray)da).setExpansionMode(
ResizableDoubleArray.ADDITIVE_MODE);
assertEquals(ResizableDoubleArray.ADDITIVE_MODE, 
((ResizableDoubleArray)da).getExpansionMode());
((ResizableDoubleArray)da).setExpansionMode(-1);
fail ("Expecting IllegalArgumentException");
package org.apache.commons.math.util;
public class ContinuedFractionTest extends TestCase {
public ContinuedFractionTest(String name) {
super(name);
public void testGoldenRatio(){
ContinuedFraction cf = new ContinuedFraction() {
private static final long serialVersionUID = 4696264881688589546L;
public double getA(int n, double x) {
return 1.0;
public double getB(int n, double x) {
return 1.0;
double gr = cf.evaluate(0.0, 10e-9);
assertEquals(1.61803399, gr, 10e-9);
fail(e.getMessage());
package org.apache.commons.math.util;
public final class MathUtilsTest extends TestCase {
public MathUtilsTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(MathUtilsTest.class);
suite.setName("MathUtils Tests");
return suite;
public void testAddAndCheck() {
int big = Integer.MAX_VALUE;
int bigNeg = Integer.MIN_VALUE;
assertEquals(big, MathUtils.addAndCheck(big, 0));
MathUtils.addAndCheck(big, 1);
fail("Expecting ArithmeticException");
MathUtils.addAndCheck(bigNeg, -1);
fail("Expecting ArithmeticException");
public void testMulAndCheck() {
int big = Integer.MAX_VALUE;
int bigNeg = Integer.MIN_VALUE;
assertEquals(big, MathUtils.mulAndCheck(big, 1));
MathUtils.mulAndCheck(big, 2);
fail("Expecting ArithmeticException");
MathUtils.mulAndCheck(bigNeg, 2);
fail("Expecting ArithmeticException");
public void testSubAndCheck() {
int big = Integer.MAX_VALUE;
int bigNeg = Integer.MIN_VALUE;
assertEquals(big, MathUtils.subAndCheck(big, 0));
MathUtils.subAndCheck(big, -1);
fail("Expecting ArithmeticException");
MathUtils.subAndCheck(bigNeg, 1);
fail("Expecting ArithmeticException");
public void testSubAndCheckErrorMessage() {
int big = Integer.MAX_VALUE;
MathUtils.subAndCheck(big, -1);
fail("Expecting ArithmeticException");
assertEquals("overflow: subtract", ex.getMessage());
public void testBinomialCoefficient() {
long[] bcoef5 = {1,5,10,10,5,1};
long[] bcoef6 = {1,6,15,20,15,6,1};
for (int i = 0; i < 6; i++) {
assertEquals("5 choose " + i, bcoef5[i], 
MathUtils.binomialCoefficient(5,i));
for (int i = 0; i < 7; i++) {
assertEquals("6 choose " + i, bcoef6[i], 
MathUtils.binomialCoefficient(6,i));
for (int n = 1; n < 10; n++) {
for (int k = 0; k <= n; k++) {
assertEquals(n + " choose " + k, binomialCoefficient(n, k), 
MathUtils.binomialCoefficient(n, k));
assertEquals(n + " choose " + k,(double) binomialCoefficient(n, k), 
MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);
assertEquals(n + " choose " + k,
Math.log((double) binomialCoefficient(n, k)), 
MathUtils.binomialCoefficientLog(n, k),10E-12);
assertEquals(MathUtils.binomialCoefficient(34,17),
binomialCoefficient(34,17));
public void test0Choose0() {
assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);
assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);
assertEquals(MathUtils.binomialCoefficient(0, 0), 1);
public void testBinomialCoefficientFail() {
MathUtils.binomialCoefficient(4,5);
fail ("expecting IllegalArgumentException");
MathUtils.binomialCoefficientDouble(4,5);
fail ("expecting IllegalArgumentException");
MathUtils.binomialCoefficientLog(4,5);
fail ("expecting IllegalArgumentException");
MathUtils.binomialCoefficient(67,34);
fail ("expecting ArithmeticException");
double x = MathUtils.binomialCoefficientDouble(1030,515);
assertTrue("expecting infinite binomial coefficient",
Double.isInfinite(x));
public void testFactorial() {
for (int i = 1; i < 10; i++) {
assertEquals(i + "! ",factorial(i),MathUtils.factorial(i));
assertEquals(i + "! ",(double)factorial(i),
MathUtils.factorialDouble(i),Double.MIN_VALUE);
assertEquals(i + "! ",Math.log((double)factorial(i)),
MathUtils.factorialLog(i),10E-12);
assertEquals("0", 1, MathUtils.factorial(0));
assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);
assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);
public void testFactorialFail() {
MathUtils.factorial(-1);
fail ("expecting IllegalArgumentException");
MathUtils.factorialDouble(-1);
fail ("expecting IllegalArgumentException");
MathUtils.factorialLog(-1);
fail ("expecting IllegalArgumentException");
MathUtils.factorial(21);
fail ("expecting ArithmeticException");
assertTrue("expecting infinite factorial value",
Double.isInfinite(MathUtils.factorialDouble(171)));
private long binomialCoefficient(int n, int k) {
if ((n == k) || (k == 0)) {
return 1;
if ((k == 1) || (k == n - 1)) {
return n;
return binomialCoefficient(n - 1, k - 1) +
binomialCoefficient(n - 1, k);
public void testLimits() {
findBinomialLimits();
private void findBinomialLimits() {
boolean foundLimit = false;
int test = 10;
while (!foundLimit) {
MathUtils.binomialCoefficient(test, test / 2);
foundLimit = true;
System.out.println
("largest n for binomialCoefficient = " + (test - 1) );
test++;
foundLimit = false;
test = 10;
while (!foundLimit) {
double x = MathUtils.binomialCoefficientDouble(test, test / 2);
if (Double.isInfinite(x)) {
foundLimit = true;
System.out.println
("largest n for binomialCoefficientD = " + (test - 1) );
test++;
public void testFactiorialLimits() {
findFactorialLimits();
private void findFactorialLimits() {
boolean foundLimit = false;
int test = 10;
while (!foundLimit) {
MathUtils.factorial(test);
foundLimit = true;
System.out.println
("largest n for factorial = " + (test - 1) );
test++;
foundLimit = false;
test = 10;
while (!foundLimit) {
double x = MathUtils.factorialDouble(test);
if (Double.isInfinite(x)) {
foundLimit = true;
System.out.println
("largest n for factorialDouble = " + (test - 1) );
test++;
private long factorial(int n) {
long result = 1;
for (int i = 2; i <= n; i++) {
result *= i;
return result;
public void testSignDouble() {
double delta = 0.0 ;
assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;
assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;
public void testSignFloat() {
float delta = 0.0F ;
assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;
assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;
public void testSignByte() {
assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;
assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;
public void testSignShort() {
assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;
assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;
public void testSignInt() {
assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;
assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;
public void testSignLong() {
assertEquals( 1L, MathUtils.indicator( 2L ) ) ;
assertEquals( -1L, MathUtils.indicator( -2L ) ) ;
public void testIndicatorDouble() {
double delta = 0.0 ;
assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;
assertEquals( 1.0, MathUtils.indicator( 0.0 ), delta ) ;
assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;
public void testIndicatorFloat() {
float delta = 0.0F ;
assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;
assertEquals( 1.0F, MathUtils.indicator( 0.0F ), delta ) ;
assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;
public void testIndicatorByte() {
assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;
assertEquals( (byte)1, MathUtils.indicator( (byte)0 ) ) ;
assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;
public void testIndicatorShort() {
assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;
assertEquals( (short)1, MathUtils.indicator( (short)0 ) ) ;
assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;
public void testIndicatorInt() {
assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;
assertEquals( (int)1, MathUtils.indicator( (int)(0) ) ) ;
assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;
public void testIndicatorLong() {
assertEquals( 1L, MathUtils.indicator( 2L ) ) ;
assertEquals( 1L, MathUtils.indicator( 0L ) ) ;
assertEquals( -1L, MathUtils.indicator( -2L ) ) ;
public void testCosh() {
double x = 3.0;
double expected = 10.06766;
assertEquals(expected, MathUtils.cosh(x), 1.0e-5);
public void testSinh() {
double x = 3.0;
double expected = 10.01787;
assertEquals(expected, MathUtils.sinh(x), 1.0e-5);
public void testCoshNaN() {
assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));
public void testSinhNaN() {
assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));
public void testEquals() {
double[] testArray = {Double.NaN, Double.POSITIVE_INFINITY, 
Double.NEGATIVE_INFINITY, 1d, 0d};
for (int i = 0; i < testArray.length; i++) {
for (int j = 0; j < testArray.length; j ++) {
if (i == j) {
assertTrue(MathUtils.equals(testArray[i], testArray[j]));
assertTrue(MathUtils.equals(testArray[j], testArray[i]));
assertTrue(!MathUtils.equals(testArray[i], testArray[j]));
assertTrue(!MathUtils.equals(testArray[j], testArray[i]));
public void testHash() {
double[] testArray = {Double.NaN, Double.POSITIVE_INFINITY, 
Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14), 
Double.MIN_VALUE, Double.MAX_VALUE};
for (int i = 0; i < testArray.length; i++) {
for (int j = 0; j < testArray.length; j ++) {
if (i == j) {
assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));
assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));
assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));
assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));
public void testLog() {
assertEquals(2.0, MathUtils.log(2,4), 0);
assertEquals(3.0, MathUtils.log(2,8), 0);
assertTrue(Double.isNaN(MathUtils.log(-1, 1)));
assertTrue(Double.isNaN(MathUtils.log(1, -1)));
assertTrue(Double.isNaN(MathUtils.log(0, 0)));
assertEquals(0, MathUtils.log(0, 10), 0);
assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);
public void testGcd() {
int a = 30;
int b = 50;
int c = 77;
assertEquals(0, MathUtils.gcd(0, 0));
assertEquals(b, MathUtils.gcd( 0,  b));
assertEquals(a, MathUtils.gcd( a,  0));
assertEquals(b, MathUtils.gcd( 0, -b));
assertEquals(a, MathUtils.gcd(-a,  0));
assertEquals(10, MathUtils.gcd( a,  b));
assertEquals(10, MathUtils.gcd(-a,  b));
assertEquals(10, MathUtils.gcd( a, -b));
assertEquals(10, MathUtils.gcd(-a, -b));
assertEquals(1, MathUtils.gcd( a,  c));
assertEquals(1, MathUtils.gcd(-a,  c));
assertEquals(1, MathUtils.gcd( a, -c));
assertEquals(1, MathUtils.gcd(-a, -c));
public void testLcm() {
int a = 30;
int b = 50;
int c = 77;
assertEquals(0, MathUtils.lcm(0, b));
assertEquals(0, MathUtils.lcm(a, 0));
assertEquals(b, MathUtils.lcm(1, b));
assertEquals(a, MathUtils.lcm(a, 1));
assertEquals(150, MathUtils.lcm(a, b));
assertEquals(150, MathUtils.lcm(-a, b));
assertEquals(150, MathUtils.lcm(a, -b));
assertEquals(2310, MathUtils.lcm(a, c));
MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);
fail("Expecting ArithmeticException");
public void testRoundFloat() {
float x = 1.234567890f;
assertEquals(1.23f, MathUtils.round(x, 2), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);
assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);
assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);
assertEquals(50.09f,  MathUtils.round(50.085f, 2), 0.0f);
assertEquals(50.19f,  MathUtils.round(50.185f, 2), 0.0f);
assertEquals(50.01f,  MathUtils.round(50.005f, 2), 0.0f);
assertEquals(30.01f,  MathUtils.round(30.005f, 2), 0.0f);
assertEquals(30.65f,  MathUtils.round(30.645f, 2), 0.0f);
assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);
fail();
assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);
MathUtils.round(1.234f, 2, 1923);
fail();
TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);
assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);
assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);
assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);
public void testNextAfterSpecialCases() {
assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));
assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));
assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));
assertTrue(Double.isInfinite(MathUtils.nextAfter( Double.MAX_VALUE, Double.POSITIVE_INFINITY)));
assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));
assertEquals( Double.MIN_VALUE, MathUtils.nextAfter(0,  1), 0);
assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);
assertEquals(0, MathUtils.nextAfter( Double.MIN_VALUE, -1), 0);
assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE,  1), 0);
public void testNextAfter() {
assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);
assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);
assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);
assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);
assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);
assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);
assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);
assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);
assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
public void testRoundDouble() {
double x = 1.234567890;
assertEquals(1.23, MathUtils.round(x, 2), 0.0);
assertEquals(1.235, MathUtils.round(x, 3), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4), 0.0);
assertEquals(39.25,MathUtils.round(39.245, 2), 0.0);
assertEquals(39.24,MathUtils.round(39.245, 2, 
BigDecimal.ROUND_DOWN), 0.0);
double xx = 39.0;
xx = xx + 245d/1000d;
assertEquals(39.25,MathUtils.round(xx, 2), 0.0);
assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);
assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);
assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);
assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);
assertEquals(50.09d,  MathUtils.round(50.085d, 2), 0.0d);
assertEquals(50.19d,  MathUtils.round(50.185d, 2), 0.0d);
assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);
assertEquals(30.01d,  MathUtils.round(30.005d, 2), 0.0d);
assertEquals(30.65d,  MathUtils.round(30.645d, 2), 0.0d);
assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);
assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);
fail();
assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);
MathUtils.round(1.234, 2, 1923);
fail();
assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);
TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);
assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);
assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);
assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);
package org.apache.commons.math.complex;
public class ComplexUtilsTest extends TestCase {
private double inf = Double.POSITIVE_INFINITY;
private double negInf = Double.NEGATIVE_INFINITY;
private double nan = Double.NaN;
private double pi = Math.PI;
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfInf = new Complex(negInf, inf);
private Complex infNegInf = new Complex(inf, negInf);
private Complex infInf = new Complex(inf, inf);
private Complex negInfNegInf = new Complex(negInf, negInf);
private Complex infNaN = new Complex(inf, nan);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
public void testPolar2Complex() {
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.polar2Complex(1, 0), 10e-12);
TestUtils.assertEquals(Complex.ZERO, 
ComplexUtils.polar2Complex(0, 1), 10e-12);
TestUtils.assertEquals(Complex.ZERO, 
ComplexUtils.polar2Complex(0, -1), 10e-12);
TestUtils.assertEquals(Complex.I, 
ComplexUtils.polar2Complex(1, pi/2), 10e-12);
TestUtils.assertEquals(Complex.I.negate(), 
ComplexUtils.polar2Complex(1, -pi/2), 10e-12);
double r = 0;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 20; j++) {
theta += pi / 6;
TestUtils.assertEquals(altPolar(r, theta), 
ComplexUtils.polar2Complex(r, theta), 10e-12);
theta = -2 * pi;
for (int j =0; j < 20; j++) {
theta -= pi / 6;
TestUtils.assertEquals(altPolar(r, theta), 
ComplexUtils.polar2Complex(r, theta), 10e-12);
protected Complex altPolar(double r, double theta) {
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPolar2ComplexIllegalModulus() {
ComplexUtils.polar2Complex(-1, 0);
fail("Expecting IllegalArgumentException");
public void testPolar2ComplexNaN() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.polar2Complex(nan, nan));     
public void testPolar2ComplexInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(1, negInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(inf, negInf));
TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));
TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));
TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));
TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));
TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
package org.apache.commons.math.complex;
public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
package org.apache.commons.math.complex;
public class ComplexTest extends TestCase {
private double inf = Double.POSITIVE_INFINITY;
private double neginf = Double.NEGATIVE_INFINITY;
private double nan = Double.NaN;
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, neginf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfInf = new Complex(neginf, inf);
private Complex negInfNegInf = new Complex(neginf, neginf);
private Complex oneNaN = new Complex(1, nan);
public void testConstructor() {
Complex z = new Complex(3.0, 4.0);
assertEquals(3.0, z.getReal(), 1.0e-5);
assertEquals(4.0, z.getImaginary(), 1.0e-5);
public void testConstructorNaN() {
Complex z = new Complex(3.0, Double.NaN);
assertTrue(z.isNaN());
z = new Complex(nan, 4.0);
assertTrue(z.isNaN());
z = new Complex(3.0, 4.0);
assertFalse(z.isNaN());
public void testAbs() {
Complex z = new Complex(3.0, 4.0);
assertEquals(5.0, z.abs(), 1.0e-5);
public void testAbsNaN() {
assertTrue(Double.isNaN(Complex.NaN.abs()));
Complex z = new Complex(inf, nan);
assertTrue(Double.isNaN(z.abs()));
public void testAbsInfinite() {
Complex z = new Complex(inf, 0);
assertEquals(inf, z.abs(), 0);
z = new Complex(0, neginf);
assertEquals(inf, z.abs(), 0);
z = new Complex(inf, neginf);
assertEquals(inf, z.abs(), 0);     
public void testAdd() {
Complex x = new Complex(3.0, 4.0);
Complex y = new Complex(5.0, 6.0);
Complex z = x.add(y);
assertEquals(8.0, z.getReal(), 1.0e-5);
assertEquals(10.0, z.getImaginary(), 1.0e-5);
public void testAddNaN() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.add(Complex.NaN);
assertTrue(z.isNaN());
z = new Complex(1, nan);
Complex w = x.add(z);
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
public void testAddInfinite() {
Complex x = new Complex(1, 1);
Complex z = new Complex(inf, 0);
Complex w = x.add(z);
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
x = new Complex(neginf, 0);
assertTrue(Double.isNaN(x.add(z).real));
public void testConjugate() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.conjugate();
assertEquals(3.0, z.getReal(), 1.0e-5);
assertEquals(-4.0, z.getImaginary(), 1.0e-5);
public void testConjugateNaN() {
Complex z = Complex.NaN.conjugate();
assertTrue(z.isNaN());
public void testConjugateInfiinite() {
Complex z = new Complex(0, inf);
assertEquals(neginf, z.conjugate().imaginary, 0);
z = new Complex(0, neginf);
assertEquals(inf, z.conjugate().imaginary, 0);
public void testDivide() {
Complex x = new Complex(3.0, 4.0);
Complex y = new Complex(5.0, 6.0);
Complex z = x.divide(y);
assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);
assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);
public void testDivideInfinite() {
Complex x = new Complex(3, 4);
Complex w = new Complex(neginf, inf);
assertTrue(x.divide(w).equals(Complex.ZERO));
Complex z = w.divide(x);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
w = new Complex(inf, inf);
z = w.divide(x);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
w = new Complex(1, inf);
z = w.divide(w);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
public void testDivideNaN() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.divide(Complex.NaN);
assertTrue(z.isNaN());
public void testDivideNaNInf() {  
Complex z = oneInf.divide(Complex.ONE);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
z = negInfNegInf.divide(oneNaN);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
z = negInfInf.divide(Complex.ONE);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
public void testMultiply() {
Complex x = new Complex(3.0, 4.0);
Complex y = new Complex(5.0, 6.0);
Complex z = x.multiply(y);
assertEquals(-9.0, z.getReal(), 1.0e-5);
assertEquals(38.0, z.getImaginary(), 1.0e-5);
public void testMultiplyNaN() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.multiply(Complex.NaN);
assertTrue(z.isNaN());
public void testMultiplyNaNInf() {
Complex z = new Complex(1,1);
Complex w = z.multiply(infOne);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
w = oneInf.multiply(oneNegInf);
assertEquals(w.real, inf, 0);
assertTrue(Double.isNaN(w.imaginary));
w = negInfNegInf.multiply(oneNaN);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
public void testNegate() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.negate();
assertEquals(-3.0, z.getReal(), 1.0e-5);
assertEquals(-4.0, z.getImaginary(), 1.0e-5);
public void testNegateNaN() {
Complex z = Complex.NaN.negate();
assertTrue(z.isNaN());
public void testSubtract() {
Complex x = new Complex(3.0, 4.0);
Complex y = new Complex(5.0, 6.0);
Complex z = x.subtract(y);
assertEquals(-2.0, z.getReal(), 1.0e-5);
assertEquals(-2.0, z.getImaginary(), 1.0e-5);
public void testSubtractNaN() {
Complex x = new Complex(3.0, 4.0);
Complex z = x.subtract(Complex.NaN);
assertTrue(z.isNaN());
public void testEqualsNull() {
Complex x = new Complex(3.0, 4.0);
assertFalse(x.equals(null));
public void testEqualsClass() {
Complex x = new Complex(3.0, 4.0);
assertFalse(x.equals(this));
public void testEqualsSame() {
Complex x = new Complex(3.0, 4.0);
assertTrue(x.equals(x));
public void testEqualsTrue() {
Complex x = new Complex(3.0, 4.0);
Complex y = new Complex(3.0, 4.0);
assertTrue(x.equals(y));
public void testEqualsRealDifference() {
Complex x = new Complex(0.0, 0.0);
Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);
assertFalse(x.equals(y));
public void testEqualsImaginaryDifference() {
Complex x = new Complex(0.0, 0.0);
Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);
assertFalse(x.equals(y));
public void testEqualsNaN() {
Complex realNaN = new Complex(Double.NaN, 0.0);
Complex imaginaryNaN = new Complex(0.0, Double.NaN);
Complex complexNaN = Complex.NaN;
assertTrue(realNaN.equals(imaginaryNaN));
assertTrue(imaginaryNaN.equals(complexNaN));
assertTrue(realNaN.equals(complexNaN));
public void testHashCode() {
Complex x = new Complex(0.0, 0.0);
Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);
assertFalse(x.hashCode()==y.hashCode());
y = new Complex(0.0 + Double.MIN_VALUE, 0.0);
assertFalse(x.hashCode()==y.hashCode());
Complex realNaN = new Complex(Double.NaN, 0.0);
Complex imaginaryNaN = new Complex(0.0, Double.NaN);
assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());
assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());
package org.apache.commons.math.complex;
public abstract class ComplexFormatAbstractTest extends TestCase {
ComplexFormat complexFormat = null;
ComplexFormat complexFormatJ = null;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
complexFormat = ComplexFormat.getInstance(getLocale());
complexFormatJ = ComplexFormat.getInstance(getLocale());
complexFormatJ.setImaginaryCharacter("j");
public void testSimpleNoDecimals() {
Complex c = new Complex(1, 1);
String expected = "1 + 1i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
Complex c = new Complex(1.23, 1.43);
String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
Complex c = new Complex(1.2323, 1.4343);
String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeReal() {
Complex c = new Complex(-1.2323, 1.4343);
String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeImaginary() {
Complex c = new Complex(1.2323, -1.4343);
String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeBoth() {
Complex c = new Complex(-1.2323, -1.4343);
String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testZeroReal() {
Complex c = new Complex(0.0, -1.4343);
String expected = "0 - 1" + getDecimalCharacter() + "43i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testZeroImaginary() {
Complex c = new Complex(30.233, 0);
String expected = "30" + getDecimalCharacter() + "23";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testDifferentImaginaryChar() {
Complex c = new Complex(1, 1);
String expected = "1 + 1j";
String actual = complexFormatJ.format(c); 
assertEquals(expected, actual);
public void testStaticFormatComplex() {
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
Complex c = new Complex(232.222, -342.33);
String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";
String actual = ComplexFormat.formatComplex(c); 
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
Complex c = new Complex(Double.NaN, Double.NaN);
String expected = "(NaN) + (NaN)i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testPositiveInfinity() {
Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
String expected = "(Infinity) + (Infinity)i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeInfinity() {
Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
String expected = "(-Infinity) - (Infinity)i";
String actual = complexFormat.format(c); 
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
String source = "1 + 1i";
Complex expected = new Complex(1, 1);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimals() {
String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
Complex expected = new Complex(1.23, 1.43);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";
Complex expected = new Complex(1.2323, 1.4343);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNegativeReal() {
String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";
Complex expected = new Complex(-1.2323, 1.4343);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNegativeImaginary() {
String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";
Complex expected = new Complex(1.2323, -1.4343);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNegativeBoth() {
String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";
Complex expected = new Complex(-1.2323, -1.4343);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseZeroReal() {
String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";
Complex expected = new Complex(0.0, -1.4343);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseZeroImaginary() {
String source = "-1" + getDecimalCharacter() + "2323";
Complex expected = new Complex(-1.2323, 0);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseDifferentImaginaryChar() {
String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";
Complex expected = new Complex(-1.2323, -1.4343);
Complex actual = (Complex)complexFormatJ.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParseNan() {
String source = "(NaN) + (NaN)i";
Complex expected = new Complex(Double.NaN, Double.NaN);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testParsePositiveInfinity() {
String source = "(Infinity) + (Infinity)i";
Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testPaseNegativeInfinity() {
String source = "(-Infinity) - (Infinity)i";
Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
Complex actual = (Complex)complexFormat.parseObject(source); 
assertEquals(expected, actual);
fail(ex.getMessage());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
ComplexFormat cf = new ComplexFormat(nf);
assertNotNull(cf);
assertEquals(nf, cf.getRealFormat());
public void testGetImaginaryFormat() {
NumberFormat nf = NumberFormat.getInstance();
ComplexFormat cf = new ComplexFormat();
assertNotSame(nf, cf.getImaginaryFormat());
cf.setImaginaryFormat(nf);
assertSame(nf, cf.getImaginaryFormat());
public void testSetImaginaryFormatNull() {
ComplexFormat cf = new ComplexFormat();
cf.setImaginaryFormat(null);
fail();
public void testSetRealFormatNull() {
ComplexFormat cf = new ComplexFormat();
cf.setRealFormat(null);
fail();
public void testGetRealFormat() {
NumberFormat nf = NumberFormat.getInstance();
ComplexFormat cf = new ComplexFormat();
assertNotSame(nf, cf.getRealFormat());
cf.setRealFormat(nf);
assertSame(nf, cf.getRealFormat());
public void testSetImaginaryCharacterNull() {
ComplexFormat cf = new ComplexFormat();
cf.setImaginaryCharacter(null);
fail();
public void testSetImaginaryCharacterEmpty() {
ComplexFormat cf = new ComplexFormat();
cf.setImaginaryCharacter("");
fail();
public void testFormatNumber() {
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = new Double(Math.PI);
String text = cf.format(pi);
assertEquals("3" + getDecimalCharacter() + "14", text);
public void testFormatObject() {
ComplexFormat cf = new ComplexFormat();
Object object = new Object();
cf.format(object);
fail();
package org.apache.commons.math.complex;
public class ComplexFormatTest extends ComplexFormatAbstractTest {
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.optimization;
public class NelderMeadTest
extends TestCase {
public NelderMeadTest(String name) {
super(name);
public void testCostExceptions() throws ConvergenceException {
CostFunction wrong =
new CostFunction() {
public double cost(double[] x) throws CostException {
if (x[0] < 0) {
throw new CostException("{0}", new Object[] { "oops"});
throw new CostException(new RuntimeException("oops"));
return x[0] * (1 - x[0]);
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
fail("an exception should have been thrown");
assertNull(ce.getCause());
fail("wrong exception caught: " + e.getMessage());
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
fail("an exception should have been thrown");
assertNotNull(ce.getCause());
fail("wrong exception caught: " + e.getMessage());
public void testRosenbrock()
throws CostException, ConvergenceException, NotPositiveDefiniteMatrixException {
CostFunction rosenbrock =
new CostFunction() {
public double cost(double[] x) {
++count;
double a = x[1] - x[0] * x[0];
double b = 1.0 - x[0];
return 100 * a * a + b * b;
count = 0;
NelderMead nm = new NelderMead();
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
fail("an exception should have been thrown");
fail("wrong exception caught: " + e.getMessage());
count = 0;
PointCostPair optimum =
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
assertTrue(count > 700);
assertTrue(count < 800);
assertEquals(0.0, optimum.cost, 5.0e-5);
assertEquals(1.0, optimum.point[0], 0.01);
assertEquals(1.0, optimum.point[1], 0.01);
PointCostPair[] minima = nm.getMinima();
assertEquals(10, minima.length);
assertNotNull(minima[0]);
assertNull(minima[minima.length - 1]);
for (int i = 0; i < minima.length; ++i) {
if (minima[i] == null) {
if ((i + 1) < minima.length) {
assertTrue(minima[i+1] == null);
if (i > 0) {
assertTrue(minima[i-1].cost <= minima[i].cost);
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(64453353l);
RandomVectorGenerator rvg =
new UncorrelatedRandomVectorGenerator(new double[] { 0.9, 1.1 },
new double[] { 0.2, 0.2 },
new UniformRandomGenerator(rg));
optimum =
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);
assertEquals(0.0, optimum.cost, 2.0e-4);
optimum =
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);
assertEquals(0.0, optimum.cost, 3.0e-5);
public void testPowell()
throws CostException, ConvergenceException {
CostFunction powell =
new CostFunction() {
public double cost(double[] x) {
++count;
double a = x[0] + 10 * x[1];
double b = x[2] - x[3];
double c = x[1] - 2 * x[2];
double d = x[0] - x[3];
return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;
count = 0;
NelderMead nm = new NelderMead();
PointCostPair optimum =
nm.minimizes(powell, 200, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 },
1, 1642738l);
assertTrue(count < 150);
assertEquals(0.0, optimum.cost, 6.0e-4);
assertEquals(0.0, optimum.point[0], 0.07);
assertEquals(0.0, optimum.point[1], 0.07);
assertEquals(0.0, optimum.point[2], 0.07);
assertEquals(0.0, optimum.point[3], 0.07);
private static class ValueChecker implements ConvergenceChecker {
public ValueChecker(double threshold) {
this.threshold = threshold;
public boolean converged(PointCostPair[] simplex) {
PointCostPair smallest = simplex[0];
PointCostPair largest  = simplex[simplex.length - 1];
return (largest.cost - smallest.cost) < threshold;
private double threshold;
public static Test suite() {
return new TestSuite(NelderMeadTest.class);
private int count;
package org.apache.commons.math.optimization;
public class MultiDirectionalTest
extends TestCase {
public MultiDirectionalTest(String name) {
super(name);
public void testCostExceptions() throws ConvergenceException {
CostFunction wrong =
new CostFunction() {
public double cost(double[] x) throws CostException {
if (x[0] < 0) {
throw new CostException("{0}", new Object[] { "oops"});
throw new CostException(new RuntimeException("oops"));
return x[0] * (1 - x[0]);
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
fail("an exception should have been thrown");
assertNull(ce.getCause());
fail("wrong exception caught: " + e.getMessage());
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
fail("an exception should have been thrown");
assertNotNull(ce.getCause());
fail("wrong exception caught: " + e.getMessage());
public void testRosenbrock()
throws CostException, ConvergenceException {
CostFunction rosenbrock =
new CostFunction() {
public double cost(double[] x) {
++count;
double a = x[1] - x[0] * x[0];
double b = 1.0 - x[0];
return 100 * a * a + b * b;
count = 0;
PointCostPair optimum =
new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
assertTrue(count > 60);
assertTrue(optimum.cost > 0.01);
public void testPowell()
throws CostException, ConvergenceException {
CostFunction powell =
new CostFunction() {
public double cost(double[] x) {
++count;
double a = x[0] + 10 * x[1];
double b = x[2] - x[3];
double c = x[1] - 2 * x[2];
double d = x[0] - x[3];
return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;
count = 0;
PointCostPair optimum =
new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 });
assertTrue(count > 850);
assertTrue(optimum.cost > 0.015);
private static class ValueChecker implements ConvergenceChecker {
public ValueChecker(double threshold) {
this.threshold = threshold;
public boolean converged(PointCostPair[] simplex) {
PointCostPair smallest = simplex[0];
PointCostPair largest  = simplex[simplex.length - 1];
return (largest.cost - smallest.cost) < threshold;
private double threshold;
public static Test suite() {
return new TestSuite(MultiDirectionalTest.class);
private int count;
package org.apache.commons.math.linear;
public final class MatrixUtilsTest extends TestCase {
protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
protected double[][] nullMatrix = null;
protected double[] row = {1,2,3};
protected BigDecimal[] bigRow = 
protected String[] stringRow = {"1", "2", "3"};
protected double[][] rowMatrix = {{1,2,3}};
protected BigDecimal[][] bigRowMatrix = 
protected String[][] stringRowMatrix = {{"1", "2", "3"}};
protected double[] col = {0,4,6};
protected BigDecimal[] bigCol = 
protected String[] stringCol = {"0","4","6"};
protected double[] nullDoubleArray = null;
protected double[][] colMatrix = {{0},{4},{6}};
protected BigDecimal[][] bigColMatrix = 
protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};
public MatrixUtilsTest(String name) {
super(name);
public void setUp() {     
public static Test suite() {
TestSuite suite = new TestSuite(MatrixUtilsTest.class);
suite.setName("MatrixUtils Tests");
return suite;
public void testCreateRealMatrix() {
assertEquals(new RealMatrixImpl(testData), 
MatrixUtils.createRealMatrix(testData));
MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged
fail("Expecting IllegalArgumentException");
MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns
fail("Expecting IllegalArgumentException");
MatrixUtils.createRealMatrix(null);  // null
fail("Expecting NullPointerException");
public void testCreateBigMatrix() {
assertEquals(new BigMatrixImpl(testData), 
MatrixUtils.createBigMatrix(testData));
assertEquals(new BigMatrixImpl(bigColMatrix), 
MatrixUtils.createBigMatrix(bigColMatrix));
assertEquals(new BigMatrixImpl(stringColMatrix), 
MatrixUtils.createBigMatrix(stringColMatrix));
MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged
fail("Expecting IllegalArgumentException");
MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns
fail("Expecting IllegalArgumentException");
MatrixUtils.createBigMatrix(nullMatrix);  // null
fail("Expecting NullPointerException");
public void testCreateRowRealMatrix() {
assertEquals((RealMatrixImpl) MatrixUtils.createRowRealMatrix(row),
new RealMatrixImpl(rowMatrix));
MatrixUtils.createRowRealMatrix(new double[] {});  // empty
fail("Expecting IllegalArgumentException");
MatrixUtils.createRowRealMatrix(null);  // null
fail("Expecting NullPointerException");
public void testCreateRowBigMatrix() {
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(row),
new BigMatrixImpl(rowMatrix));
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(bigRow),
new BigMatrixImpl(bigRowMatrix));
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(stringRow),
new BigMatrixImpl(stringRowMatrix));
MatrixUtils.createRowBigMatrix(new double[] {});  // empty
fail("Expecting IllegalArgumentException");
MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null
fail("Expecting NullPointerException");
public void testCreateColumnRealMatrix() {
assertEquals((RealMatrixImpl) MatrixUtils.createColumnRealMatrix(col),
new RealMatrixImpl(colMatrix));
MatrixUtils.createColumnRealMatrix(new double[] {});  // empty
fail("Expecting IllegalArgumentException");
MatrixUtils.createColumnRealMatrix(null);  // null
fail("Expecting NullPointerException");
public void testCreateColumnBigMatrix() {
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(col),
new BigMatrixImpl(colMatrix));
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(bigCol),
new BigMatrixImpl(bigColMatrix));
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(stringCol),
new BigMatrixImpl(stringColMatrix));   
MatrixUtils.createColumnBigMatrix(new double[] {});  // empty
fail("Expecting IllegalArgumentException");
MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null
fail("Expecting NullPointerException");
protected void checkIdentityMatrix(RealMatrix m) {
for (int i = 0; i < m.getRowDimension(); i++) {
for (int j =0; j < m.getColumnDimension(); j++) {
if (i == j) {
assertEquals(m.getEntry(i, j), 1d, 0);
assertEquals(m.getEntry(i, j), 0d, 0);
public void testCreateIdentityMatrix() {
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));
MatrixUtils.createRealIdentityMatrix(0);
protected void checkIdentityBigMatrix(BigMatrix m) {
for (int i = 0; i < m.getRowDimension(); i++) {
for (int j =0; j < m.getColumnDimension(); j++) {
if (i == j) {
assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);
assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);
public void testCreateBigIdentityMatrix() {
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));
MatrixUtils.createRealIdentityMatrix(0);
package org.apache.commons.math.linear;
public class QRDecompositionImplTest extends TestCase {
double[][] testData3x3NonSingular = { 
double[][] testData3x3Singular = { 
double[][] testData3x4 = { 
double[][] testData4x3 = { 
private static final double entryTolerance = 10e-16;
private static final double normTolerance = 10e-14;
public QRDecompositionImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(QRDecompositionImplTest.class);
suite.setName("QRDecompositionImpl Tests");
return suite;
public void testDimensions() {
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
QRDecomposition qr = new QRDecompositionImpl(matrix);
assertEquals("3x3 Q size", qr.getQ().getRowDimension(), 3);
assertEquals("3x3 Q size", qr.getQ().getColumnDimension(), 3);
assertEquals("3x3 R size", qr.getR().getRowDimension(), 3);
assertEquals("3x3 R size", qr.getR().getColumnDimension(), 3);
matrix = new RealMatrixImpl(testData4x3);
qr = new QRDecompositionImpl(matrix);
assertEquals("4x3 Q size", qr.getQ().getRowDimension(), 4);
assertEquals("4x3 Q size", qr.getQ().getColumnDimension(), 4);
assertEquals("4x3 R size", qr.getR().getRowDimension(), 4);
assertEquals("4x3 R size", qr.getR().getColumnDimension(), 3);
matrix = new RealMatrixImpl(testData3x4);
qr = new QRDecompositionImpl(matrix);
assertEquals("3x4 Q size", qr.getQ().getRowDimension(), 3);
assertEquals("3x4 Q size", qr.getQ().getColumnDimension(), 3);
assertEquals("3x4 R size", qr.getR().getRowDimension(), 3);
assertEquals("3x4 R size", qr.getR().getColumnDimension(), 4);
public void testAEqualQR() {
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
QRDecomposition qr = new QRDecompositionImpl(A);
RealMatrix Q = qr.getQ();
RealMatrix R = qr.getR();
double norm = Q.multiply(R).subtract(A).getNorm();
assertEquals("3x3 nonsingular A = QR", 0, norm, normTolerance);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
qr = new QRDecompositionImpl(matrix);
norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();
assertEquals("3x3 singular A = QR", 0, norm, normTolerance);
matrix = new RealMatrixImpl(testData3x4);
qr = new QRDecompositionImpl(matrix);
norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();
assertEquals("3x4 A = QR", 0, norm, normTolerance);
matrix = new RealMatrixImpl(testData4x3);
qr = new QRDecompositionImpl(matrix);
norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();
assertEquals("4x3 A = QR", 0, norm, normTolerance);
public void testQOrthogonal() {
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new QRDecompositionImpl(matrix).getQ();
RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);
double norm = matrix.transpose().multiply(matrix).subtract(eye)
.getNorm();
assertEquals("3x3 nonsingular Q'Q = I", 0, norm, normTolerance);
matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new QRDecompositionImpl(matrix).getQ();
eye = MatrixUtils.createRealIdentityMatrix(3);
norm = matrix.transpose().multiply(matrix).subtract(eye)
.getNorm();
assertEquals("3x3 singular Q'Q = I", 0, norm, normTolerance);
matrix = new RealMatrixImpl(testData3x4);
matrix = new QRDecompositionImpl(matrix).getQ();
eye = MatrixUtils.createRealIdentityMatrix(3);
norm = matrix.transpose().multiply(matrix).subtract(eye)
.getNorm();
assertEquals("3x4 Q'Q = I", 0, norm, normTolerance);
matrix = new RealMatrixImpl(testData4x3);
matrix = new QRDecompositionImpl(matrix).getQ();
eye = MatrixUtils.createRealIdentityMatrix(4);
norm = matrix.transpose().multiply(matrix).subtract(eye)
.getNorm();
assertEquals("4x3 Q'Q = I", 0, norm, normTolerance);
public void testRUpperTriangular() {
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
RealMatrix R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
matrix = new RealMatrixImpl(testData3x4);
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
matrix = new RealMatrixImpl(testData4x3);
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
package org.apache.commons.math.linear;
public final class RealMatrixImplTest extends TestCase {
protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };
protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};
protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };
protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, 
protected double[] testDataRow1 = {1d,2d,3d};
protected double[] testDataCol3 = {3d,3d,8d};
protected double[][] testDataInv = 
protected double[] preMultTest = {8,12,33};
protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};
protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};
protected double[][] testDataPlusInv = 
protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };
protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},
protected double[][] singular = { {2d,3d}, {2d,3d} };
protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},
protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };
protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};
protected double[] testVector = {1,2,3};
protected double[] testVector2 = {1,2,3,4};
protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},
protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};
protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};
protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};
protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};
protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};
protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};
protected double[][] subRows23Cols00 = {{2} , {4}};
protected double[][] subRows00Cols33 = {{4}};
protected double[][] subRow0 = {{1,2,3,4}};
protected double[][] subRow3 = {{4,5,6,7}};
protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};
protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
public RealMatrixImplTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(RealMatrixImplTest.class);
suite.setName("RealMatrixImpl Tests");
return suite;
public void testDimensions() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(testData2);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
public void testCopyFunctions() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
assertEquals(m2,m);
public void testAdd() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
double[][] sumEntries = mPlusMInv.getData();
for (int row = 0; row < m.getRowDimension(); row++) {
for (int col = 0; col < m.getColumnDimension(); col++) {
assertEquals("sum entry entry",
testDataPlusInv[row][col],sumEntries[row][col],
entryTolerance);
public void testAddFail() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(testData2);
m.add(m2);
fail("IllegalArgumentException expected");
public void testNorm() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(testData2);
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
public void testPlusMinus() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);
assertClose("m-n = m + -n",m.subtract(m2),
m2.scalarMultiply(-1d).add(m),entryTolerance);        
m.subtract(new RealMatrixImpl(testData2));
fail("Expecting illegalArgumentException");
public void testMultiply() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
RealMatrixImpl identity = new RealMatrixImpl(id);
RealMatrixImpl m2 = new RealMatrixImpl(testData2);
assertClose("inverse multiply",m.multiply(mInv),
identity,entryTolerance);
assertClose("inverse multiply",mInv.multiply(m),
identity,entryTolerance);
assertClose("identity multiply",m.multiply(identity),
m,entryTolerance);
assertClose("identity multiply",identity.multiply(mInv),
mInv,entryTolerance);
assertClose("identity multiply",m2.multiply(identity),
m2,entryTolerance); 
m.multiply(new RealMatrixImpl(bigSingular));
fail("Expecting illegalArgumentException");
private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};
private double[][] d4 = new double[][] {{1},{2},{3},{4}};
private double[][] d5 = new double[][] {{30},{70}};
public void testMultiply2() { 
RealMatrix m3 = new RealMatrixImpl(d3);   
RealMatrix m4 = new RealMatrixImpl(d4);
RealMatrix m5 = new RealMatrixImpl(d5);
assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);
public void testIsSingular() {
RealMatrixImpl m = new RealMatrixImpl(singular);
assertTrue("singular",m.isSingular());
m = new RealMatrixImpl(bigSingular);
assertTrue("big singular",m.isSingular());
m = new RealMatrixImpl(id);
assertTrue("identity nonsingular",!m.isSingular());
m = new RealMatrixImpl(testData);
assertTrue("testData nonsingular",!m.isSingular());
public void testInverse() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrix mInv = new RealMatrixImpl(testDataInv);
assertClose("inverse",mInv,m.inverse(),normTolerance);
assertClose("inverse^2",m,m.inverse().inverse(),10E-12);
m = new RealMatrixImpl(testData2);
m.inverse();
fail("Expecting InvalidMatrixException");
m = new RealMatrixImpl(singular);
m.inverse();
fail("Expecting InvalidMatrixException");
public void testSolve() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrix mInv = new RealMatrixImpl(testDataInv);
assertClose("inverse-operate",mInv.operate(testVector),
m.solve(testVector),normTolerance);
m.solve(testVector2);
fail("expecting IllegalArgumentException");
RealMatrix bs = new RealMatrixImpl(bigSingular);
bs.solve(bs);
fail("Expecting InvalidMatrixException");
m.solve(bs);
fail("Expecting IllegalArgumentException");
new RealMatrixImpl(testData2).solve(bs);
fail("Expecting illegalArgumentException");
(new RealMatrixImpl(testData2)).luDecompose();
fail("Expecting InvalidMatrixException");
public void testDeterminant() {       
RealMatrix m = new RealMatrixImpl(bigSingular);
assertEquals("singular determinant",0,m.getDeterminant(),0);
m = new RealMatrixImpl(detData);
assertEquals("nonsingular test",-3d,m.getDeterminant(),normTolerance);
m = new RealMatrixImpl(detData2);
assertEquals("nonsingular R test 1",-2d,m.getDeterminant(),normTolerance);
m = new RealMatrixImpl(testData);
assertEquals("nonsingular  R test 2",-1d,m.getDeterminant(),normTolerance);
new RealMatrixImpl(testData2).getDeterminant();
fail("Expecting InvalidMatrixException");
public void testTrace() {
RealMatrix m = new RealMatrixImpl(id);
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
m = new RealMatrixImpl(testData2);
m.getTrace();
fail("Expecting illegalArgumentException");
public void testScalarAdd() {
RealMatrix m = new RealMatrixImpl(testData);
assertClose("scalar add",new RealMatrixImpl(testDataPlus2),
m.scalarAdd(2d),entryTolerance);
public void testOperate() {
RealMatrix m = new RealMatrixImpl(id);
double[] x = m.operate(testVector);
assertClose("identity operate",testVector,x,entryTolerance);
m = new RealMatrixImpl(bigSingular);
m.operate(testVector);
fail("Expecting illegalArgumentException");
public void testTranspose() {
RealMatrix m = new RealMatrixImpl(testData); 
assertClose("inverse-transpose",m.inverse().transpose(),
m.transpose().inverse(),normTolerance);
m = new RealMatrixImpl(testData2);
RealMatrix mt = new RealMatrixImpl(testData2T);
assertClose("transpose",mt,m.transpose(),normTolerance);
public void testPremultiplyVector() {
RealMatrix m = new RealMatrixImpl(testData);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
m = new RealMatrixImpl(bigSingular);
m.preMultiply(testVector);
fail("expecting IllegalArgumentException");
public void testPremultiply() {
RealMatrix m3 = new RealMatrixImpl(d3);   
RealMatrix m4 = new RealMatrixImpl(d4);
RealMatrix m5 = new RealMatrixImpl(d5);
assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
RealMatrixImpl identity = new RealMatrixImpl(id);
assertClose("inverse multiply",m.preMultiply(mInv),
identity,entryTolerance);
assertClose("inverse multiply",mInv.preMultiply(m),
identity,entryTolerance);
assertClose("identity multiply",m.preMultiply(identity),
m,entryTolerance);
assertClose("identity multiply",identity.preMultiply(mInv),
mInv,entryTolerance);
m.preMultiply(new RealMatrixImpl(bigSingular));
fail("Expecting illegalArgumentException");
public void testGetVectors() {
RealMatrix m = new RealMatrixImpl(testData);
assertClose("get row",m.getRow(0),testDataRow1,entryTolerance);
assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance);
m.getRow(10);
fail("expecting MatrixIndexException");
m.getColumn(-1);
fail("expecting MatrixIndexException");
public void testGetEntry() {
RealMatrix m = new RealMatrixImpl(testData);
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
m.getEntry(10, 4);
fail ("Expecting MatrixIndexException");
public void testLUDecomposition() throws Exception {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrix lu = m.getLUMatrix();
assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);
verifyDecomposition(m, lu);
lu = m.getLUMatrix();
assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);
verifyDecomposition(m, lu);
m = new RealMatrixImpl(luData);
lu = m.getLUMatrix();
assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);
verifyDecomposition(m, lu);
m = new RealMatrixImpl(testDataMinus);
lu = m.getLUMatrix();
verifyDecomposition(m, lu);
m = new RealMatrixImpl(id);
lu = m.getLUMatrix();
verifyDecomposition(m, lu);
m = new RealMatrixImpl(bigSingular); // singular
lu = m.getLUMatrix();
fail("Expecting InvalidMatrixException");
m = new RealMatrixImpl(testData2);  // not square
lu = m.getLUMatrix();
fail("Expecting InvalidMatrixException");
public void testExamples() {
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new RealMatrixImpl(matrixData);
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new RealMatrixImpl(matrixData2);
RealMatrix p = m.multiply(n);
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
RealMatrix pInverse = p.inverse(); 
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};
RealMatrix coefficients = new RealMatrixImpl(coefficientsData);
double[] constants = {1, -2, 1};
double[] solution = coefficients.solve(constants);
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   
public void testSubMatrix() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealMatrix mRows23Cols00 = new RealMatrixImpl(subRows23Cols00);
RealMatrix mRows00Cols33 = new RealMatrixImpl(subRows00Cols33);
RealMatrix mRows01Cols23 = new RealMatrixImpl(subRows01Cols23);
RealMatrix mRows02Cols13 = new RealMatrixImpl(subRows02Cols13);
RealMatrix mRows03Cols12 = new RealMatrixImpl(subRows03Cols12);
RealMatrix mRows03Cols123 = new RealMatrixImpl(subRows03Cols123);
RealMatrix mRows20Cols123 = new RealMatrixImpl(subRows20Cols123);
RealMatrix mRows31Cols31 = new RealMatrixImpl(subRows31Cols31);
assertEquals("Rows23Cols00", mRows23Cols00, 
m.getSubMatrix(2 , 3 , 0, 0));
assertEquals("Rows00Cols33", mRows00Cols33, 
m.getSubMatrix(0 , 0 , 3, 3));
assertEquals("Rows01Cols23", mRows01Cols23,
m.getSubMatrix(0 , 1 , 2, 3));   
assertEquals("Rows02Cols13", mRows02Cols13,
m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  
assertEquals("Rows03Cols12", mRows03Cols12,
m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  
assertEquals("Rows03Cols123", mRows03Cols123,
m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); 
assertEquals("Rows20Cols123", mRows20Cols123,
m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); 
assertEquals("Rows31Cols31", mRows31Cols31,
m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); 
assertEquals("Rows31Cols31", mRows31Cols31,
m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); 
m.getSubMatrix(1,0,2,4);
fail("Expecting MatrixIndexException");
m.getSubMatrix(-1,1,2,2);
fail("Expecting MatrixIndexException");
m.getSubMatrix(1,0,2,2);
fail("Expecting MatrixIndexException");
m.getSubMatrix(1,0,2,4);
fail("Expecting MatrixIndexException");
m.getSubMatrix(new int[] {}, new int[] {0});
fail("Expecting MatrixIndexException");
m.getSubMatrix(new int[] {0}, new int[] {4});
fail("Expecting MatrixIndexException");
public void testGetRowMatrix() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealMatrix mRow0 = new RealMatrixImpl(subRow0);
RealMatrix mRow3 = new RealMatrixImpl(subRow3);
assertEquals("Row0", mRow0, 
m.getRowMatrix(0));
assertEquals("Row3", mRow3, 
m.getRowMatrix(3));
m.getRowMatrix(-1);
fail("Expecting MatrixIndexException");
m.getRowMatrix(4);
fail("Expecting MatrixIndexException");
public void testGetColumnMatrix() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);
RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);
assertEquals("Column1", mColumn1, 
m.getColumnMatrix(1));
assertEquals("Column3", mColumn3, 
m.getColumnMatrix(3));
m.getColumnMatrix(-1);
fail("Expecting MatrixIndexException");
m.getColumnMatrix(4);
fail("Expecting MatrixIndexException");
public void testEqualsAndHashCode() {
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m1 = (RealMatrixImpl) m.copy();
RealMatrixImpl mt = (RealMatrixImpl) m.transpose();
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new RealMatrixImpl(bigSingular))); 
public void testToString() {
RealMatrixImpl m = new RealMatrixImpl(testData);
assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
m.toString());
m = new RealMatrixImpl();
assertEquals("RealMatrixImpl{}",
m.toString());
public void testSetSubMatrix() throws Exception {
RealMatrixImpl m = new RealMatrixImpl(testData);
m.setSubMatrix(detData2,1,1);
RealMatrix expected = MatrixUtils.createRealMatrix
(new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});
assertEquals(expected, m);  
m.setSubMatrix(detData2,0,0);
expected = MatrixUtils.createRealMatrix
(new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});
assertEquals(expected, m);  
m.setSubMatrix(testDataPlus2,0,0);      
expected = MatrixUtils.createRealMatrix
(new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});
assertEquals(expected, m);   
RealMatrixImpl matrix = (RealMatrixImpl) MatrixUtils.createRealMatrix
(new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});
matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);
expected = MatrixUtils.createRealMatrix
(new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});
assertEquals(expected, matrix);   
m.setSubMatrix(testData,1,1);
fail("expecting MatrixIndexException");
m.setSubMatrix(testData,-1,1);
fail("expecting MatrixIndexException");
m.setSubMatrix(testData,1,-1);
fail("expecting MatrixIndexException");
m.setSubMatrix(null,1,1);
fail("expecting NullPointerException");
RealMatrixImpl m2 = new RealMatrixImpl();
m2.setSubMatrix(testData,0,1);
fail("expecting MatrixIndexException");
m2.setSubMatrix(testData,1,0);
fail("expecting MatrixIndexException");
m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);
fail("expecting IllegalArgumentException");
m.setSubMatrix(new double[][] {{}}, 0, 0);
fail("expecting IllegalArgumentException");
protected void assertClose(String msg, RealMatrix m, RealMatrix n,
double tolerance) {
assertTrue(msg,m.subtract(n).getNorm() < tolerance);
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
fail("vectors not same length");
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", 
m[i],n[i],tolerance);
protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   
if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||
lowerData.length != upperData.length
|| lowerData.length != lu.getRowDimension()) {
throw new InvalidMatrixException("incorrect dimensions");
int n = lu.getRowDimension();
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (j < i) {
lowerData[i][j] = lu.getEntry(i, j);
upperData[i][j] = 0d;
lowerData[i][j] = 1d;
upperData[i][j] = lu.getEntry(i, j);
lowerData[i][j] = 0d;
upperData[i][j] = lu.getEntry(i, j);
protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {
if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {
throw new IllegalArgumentException("dimension mismatch");
int n = matrix.getRowDimension();
int m = matrix.getColumnDimension();
double out[][] = new double[m][n];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
out[i][j] = matrix.getEntry(permutation[i], j);
return new RealMatrixImpl(out);
protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{
int n = matrix.getRowDimension();
double[][] lowerData = new double[n][n];
double[][] upperData = new double[n][n];
splitLU(lu, lowerData, upperData);
RealMatrix lower =new RealMatrixImpl(lowerData);
RealMatrix upper = new RealMatrixImpl(upperData);
int[] permutation = ((RealMatrixImpl) matrix).getPermutation();
RealMatrix permuted = permuteRows(matrix, permutation);
assertClose("lu decomposition does not work", permuted, lower.multiply(upper), normTolerance);
private void dumpMatrix(RealMatrix m) {
for (int i = 0; i < m.getRowDimension(); i++) {
String os = "";
for (int j = 0; j < m.getColumnDimension(); j++) {
os += m.getEntry(i, j) + " ";
System.out.println(os);
package org.apache.commons.math.linear;
public final class BigMatrixImplTest extends TestCase {
protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };
protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };
protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};
protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };
protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, 
protected double[] testDataRow1 = {1d,2d,3d};
protected double[] testDataCol3 = {3d,3d,8d};
protected double[][] testDataInv = 
protected double[] preMultTest = {8,12,33};
protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};
protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};
protected double[][] testDataPlusInv = 
protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };
protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},
protected double[][] singular = { {2d,3d}, {2d,3d} };
protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},
protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };
protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};
protected double[] testVector = {1,2,3};
protected double[] testVector2 = {1,2,3,4};
protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},
protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};
protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};
protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};
protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};
protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};
protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};
protected double[][] subRows23Cols00 = {{2} , {4}};
protected double[][] subRows00Cols33 = {{4}};
protected double[][] subRow0 = {{1,2,3,4}};
protected double[][] subRow3 = {{4,5,6,7}};
protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};
protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
public BigMatrixImplTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(BigMatrixImplTest.class);
suite.setName("BigMatrixImpl Tests");
return suite;
public static final double[] asDouble(BigDecimal[] data) {
double d[] = new double[data.length];
for (int i=0;i<d.length;i++) {
d[i] = data[i].doubleValue();
return d;
public static final double[][] asDouble(BigDecimal[][] data) {
double d[][] = new double[data.length][data[0].length];
for (int i=0;i<d.length;i++) {
for (int j=0;j<d[i].length;j++)
d[i][j] = data[i][j].doubleValue();
return d;
public static final BigDecimal[] asBigDecimal(double [] data) {
BigDecimal d[] = new BigDecimal[data.length];
for (int i=0;i<d.length;i++) {
d[i] = new BigDecimal(data[i]);
return d;
public static final BigDecimal[][] asBigDecimal(double [][] data) {
BigDecimal d[][] = new BigDecimal[data.length][data[0].length];
for (int i=0;i<d.length;i++) {
for (int j=0;j<data[i].length;j++) {
d[i][j] = new BigDecimal(data[i][j]);
return d;
public void testDimensions() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(testData2);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
public void testCopyFunctions() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
assertEquals(m2,m);
public void testConstructors() {
BigMatrix m1 = new BigMatrixImpl(testData);
BigMatrix m2 = new BigMatrixImpl(testDataString);
BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));
assertClose("double, string", m1, m2, Double.MIN_VALUE);
assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);
assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);
new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});
fail("Expecting NumberFormatException");
new BigMatrixImpl(new String[][] {});
fail("Expecting IllegalArgumentException");
new BigMatrixImpl(new String[][] {{},{}});
fail("Expecting IllegalArgumentException");
new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});
fail("Expecting IllegalArgumentException");
new BigMatrixImpl(0, 1);
fail("Expecting IllegalArgumentException");
new BigMatrixImpl(1, 0);
fail("Expecting IllegalArgumentException");
public void testAdd() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
double[][] sumEntries = asDouble(mPlusMInv.getData());
for (int row = 0; row < m.getRowDimension(); row++) {
for (int col = 0; col < m.getColumnDimension(); col++) {
assertEquals("sum entry entry",
testDataPlusInv[row][col],sumEntries[row][col],
entryTolerance);
public void testAddFail() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(testData2);
m.add(m2);
fail("IllegalArgumentException expected");
public void testNorm() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(testData2);
assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);
public void testPlusMinus() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);
assertClose("m-n = m + -n",m.subtract(m2),
m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);
m.subtract(new BigMatrixImpl(testData2));
fail("Expecting illegalArgumentException");
public void testMultiply() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
BigMatrixImpl identity = new BigMatrixImpl(id);
BigMatrixImpl m2 = new BigMatrixImpl(testData2);
assertClose("inverse multiply",m.multiply(mInv),
identity,entryTolerance);
assertClose("inverse multiply",mInv.multiply(m),
identity,entryTolerance);
assertClose("identity multiply",m.multiply(identity),
m,entryTolerance);
assertClose("identity multiply",identity.multiply(mInv),
mInv,entryTolerance);
assertClose("identity multiply",m2.multiply(identity),
m2,entryTolerance); 
m.multiply(new BigMatrixImpl(bigSingular));
fail("Expecting illegalArgumentException");
private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};
private double[][] d4 = new double[][] {{1},{2},{3},{4}};
private double[][] d5 = new double[][] {{30},{70}};
public void testMultiply2() { 
BigMatrix m3 = new BigMatrixImpl(d3);
BigMatrix m4 = new BigMatrixImpl(d4);
BigMatrix m5 = new BigMatrixImpl(d5);
assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);
public void testIsSingular() {
BigMatrixImpl m = new BigMatrixImpl(singular);
assertTrue("singular",m.isSingular());
m = new BigMatrixImpl(bigSingular);
assertTrue("big singular",m.isSingular());
m = new BigMatrixImpl(id);
assertTrue("identity nonsingular",!m.isSingular());
m = new BigMatrixImpl(testData);
assertTrue("testData nonsingular",!m.isSingular());
public void testInverse() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrix mInv = new BigMatrixImpl(testDataInv);
assertClose("inverse",mInv,m.inverse(),normTolerance);
assertClose("inverse^2",m,m.inverse().inverse(),10E-12);
m = new BigMatrixImpl(testData2);
m.inverse();
fail("Expecting InvalidMatrixException");
m = new BigMatrixImpl(singular);
m.inverse();
fail("Expecting InvalidMatrixException");
public void testSolve() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrix mInv = new BigMatrixImpl(testDataInv);
assertClose("inverse-operate",
asDouble(mInv.operate(asBigDecimal(testVector))),
asDouble(m.solve(asBigDecimal(testVector))),
normTolerance);
asDouble(m.solve(asBigDecimal(testVector2)));
fail("expecting IllegalArgumentException");
BigMatrix bs = new BigMatrixImpl(bigSingular);
bs.solve(bs);
fail("Expecting InvalidMatrixException");
m.solve(bs);
fail("Expecting IllegalArgumentException");
new BigMatrixImpl(testData2).solve(bs);
fail("Expecting illegalArgumentException");
(new BigMatrixImpl(testData2)).luDecompose();
fail("Expecting InvalidMatrixException");
public void testDeterminant() {       
BigMatrix m = new BigMatrixImpl(bigSingular);
assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);
m = new BigMatrixImpl(detData);
assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);
m = new BigMatrixImpl(detData2);
assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);
m = new BigMatrixImpl(testData);
assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);
new BigMatrixImpl(testData2).getDeterminant().doubleValue();
fail("Expecting InvalidMatrixException");
public void testTrace() {
BigMatrix m = new BigMatrixImpl(id);
assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);
m = new BigMatrixImpl(testData2);
m.getTrace().doubleValue();
fail("Expecting illegalArgumentException");
public void testScalarAdd() {
BigMatrix m = new BigMatrixImpl(testData);
assertClose("scalar add",new BigMatrixImpl(testDataPlus2),
m.scalarAdd(new BigDecimal(2d)),entryTolerance);
public void testOperate() {
BigMatrix m = new BigMatrixImpl(id);
double[] x = asDouble(m.operate(asBigDecimal(testVector)));
assertClose("identity operate",testVector,x,entryTolerance);
m = new BigMatrixImpl(bigSingular);
asDouble(m.operate(asBigDecimal(testVector)));
fail("Expecting illegalArgumentException");
public void testTranspose() {
BigMatrix m = new BigMatrixImpl(testData);
assertClose("inverse-transpose",m.inverse().transpose(),
m.transpose().inverse(),normTolerance);
m = new BigMatrixImpl(testData2);
BigMatrix mt = new BigMatrixImpl(testData2T);
assertClose("transpose",mt,m.transpose(),normTolerance);
public void testPremultiplyVector() {
BigMatrix m = new BigMatrixImpl(testData);
assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);
m = new BigMatrixImpl(bigSingular);
m.preMultiply(asBigDecimal(testVector));
fail("expecting IllegalArgumentException");
public void testPremultiply() {
BigMatrix m3 = new BigMatrixImpl(d3);
BigMatrix m4 = new BigMatrixImpl(d4);
BigMatrix m5 = new BigMatrixImpl(d5);
assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
BigMatrixImpl identity = new BigMatrixImpl(id);
new BigMatrixImpl(testData2);
assertClose("inverse multiply",m.preMultiply(mInv),
identity,entryTolerance);
assertClose("inverse multiply",mInv.preMultiply(m),
identity,entryTolerance);
assertClose("identity multiply",m.preMultiply(identity),
m,entryTolerance);
assertClose("identity multiply",identity.preMultiply(mInv),
mInv,entryTolerance);
m.preMultiply(new BigMatrixImpl(bigSingular));
fail("Expecting illegalArgumentException");
public void testGetVectors() {
BigMatrix m = new BigMatrixImpl(testData);
assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);
assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);
m.getRowAsDoubleArray(10);
fail("expecting MatrixIndexException");
m.getColumnAsDoubleArray(-1);
fail("expecting MatrixIndexException");
public void testLUDecomposition() throws Exception {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrix lu = m.getLUMatrix();
assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(testDataLU), normTolerance);
verifyDecomposition(m, lu);
m = new BigMatrixImpl(luData);
lu = m.getLUMatrix();
assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(luDataLUDecomposition), normTolerance);
verifyDecomposition(m, lu);
m = new BigMatrixImpl(testDataMinus);
lu = m.getLUMatrix();
verifyDecomposition(m, lu);
m = new BigMatrixImpl(id);
lu = m.getLUMatrix();
verifyDecomposition(m, lu);
m = new BigMatrixImpl(bigSingular); // singular
lu = m.getLUMatrix();
fail("Expecting InvalidMatrixException");
m = new BigMatrixImpl(testData2);  // not square
lu = m.getLUMatrix();
fail("Expecting InvalidMatrixException");
public void testSubMatrix() {
BigMatrix m = new BigMatrixImpl(subTestData);
BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);
BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);
BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);
BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);
BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);
BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);
BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);
BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);
assertEquals("Rows23Cols00", mRows23Cols00, 
m.getSubMatrix(2 , 3 , 0, 0));
assertEquals("Rows00Cols33", mRows00Cols33, 
m.getSubMatrix(0 , 0 , 3, 3));
assertEquals("Rows01Cols23", mRows01Cols23,
m.getSubMatrix(0 , 1 , 2, 3));   
assertEquals("Rows02Cols13", mRows02Cols13,
m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  
assertEquals("Rows03Cols12", mRows03Cols12,
m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  
assertEquals("Rows03Cols123", mRows03Cols123,
m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); 
assertEquals("Rows20Cols123", mRows20Cols123,
m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); 
assertEquals("Rows31Cols31", mRows31Cols31,
m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); 
assertEquals("Rows31Cols31", mRows31Cols31,
m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); 
m.getSubMatrix(1,0,2,4);
fail("Expecting MatrixIndexException");
m.getSubMatrix(-1,1,2,2);
fail("Expecting MatrixIndexException");
m.getSubMatrix(1,0,2,2);
fail("Expecting MatrixIndexException");
m.getSubMatrix(1,0,2,4);
fail("Expecting MatrixIndexException");
m.getSubMatrix(new int[] {}, new int[] {0});
fail("Expecting MatrixIndexException");
m.getSubMatrix(new int[] {0}, new int[] {4});
fail("Expecting MatrixIndexException");
public void testGetColumnMatrix() {
BigMatrix m = new BigMatrixImpl(subTestData);
BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);
BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);
assertEquals("Column1", mColumn1, 
m.getColumnMatrix(1));
assertEquals("Column3", mColumn3, 
m.getColumnMatrix(3));
m.getColumnMatrix(-1);
fail("Expecting MatrixIndexException");
m.getColumnMatrix(4);
fail("Expecting MatrixIndexException");
public void testGetRowMatrix() {
BigMatrix m = new BigMatrixImpl(subTestData);
BigMatrix mRow0 = new BigMatrixImpl(subRow0);
BigMatrix mRow3 = new BigMatrixImpl(subRow3);
assertEquals("Row0", mRow0, 
m.getRowMatrix(0));
assertEquals("Row3", mRow3, 
m.getRowMatrix(3));
m.getRowMatrix(-1);
fail("Expecting MatrixIndexException");
m.getRowMatrix(4);
fail("Expecting MatrixIndexException");
public void testEqualsAndHashCode() {
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m1 = (BigMatrixImpl) m.copy();
BigMatrixImpl mt = (BigMatrixImpl) m.transpose();
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new BigMatrixImpl(bigSingular)));
m = new BigMatrixImpl(new String[][] {{"2.0"}});
m1 = new BigMatrixImpl(new String[][] {{"2.00"}});
assertTrue(m.hashCode() != m1.hashCode());
assertFalse(m.equals(m1));
public void testToString() {
BigMatrixImpl m = new BigMatrixImpl(testData);
assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",
m.toString());
m = new BigMatrixImpl();
assertEquals("BigMatrixImpl{}",
m.toString());
public void testSetSubMatrix() throws Exception {
BigDecimal[][] detData3 = 
MatrixUtils.createBigMatrix(detData2).getData();
BigMatrixImpl m = new BigMatrixImpl(testData);
m.setSubMatrix(detData3,1,1);
BigMatrix expected = MatrixUtils.createBigMatrix
(new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});
assertEquals(expected, m);  
m.setSubMatrix(detData3,0,0);
expected = MatrixUtils.createBigMatrix
(new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});
assertEquals(expected, m);  
BigDecimal[][] testDataPlus3 = 
MatrixUtils.createBigMatrix(testDataPlus2).getData();
m.setSubMatrix(testDataPlus3,0,0);      
expected = MatrixUtils.createBigMatrix
(new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});
assertEquals(expected, m);   
BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix
(new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});
matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),
new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);
expected = MatrixUtils.createBigMatrix
(new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),
new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),
new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},
new BigDecimal(2)}});
assertEquals(expected, matrix);   
m.setSubMatrix(matrix.getData(),1,1);
fail("expecting MatrixIndexException");
m.setSubMatrix(null,1,1);
fail("expecting NullPointerException");
m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},
fail("expecting IllegalArgumentException");
m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);
fail("expecting IllegalArgumentException");
protected void assertClose(String msg, BigMatrix m, BigMatrix n,
double tolerance) {
assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
fail("vectors not same length");
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", 
m[i],n[i],tolerance);
protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {
if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||
lowerData.length != upperData.length
|| lowerData.length != lu.getRowDimension()) {
throw new InvalidMatrixException("incorrect dimensions");
int n = lu.getRowDimension();
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (j < i) {
lowerData[i][j] = lu.getEntry(i, j);
upperData[i][j] = new BigDecimal(0);
lowerData[i][j] = new BigDecimal(1);
upperData[i][j] = lu.getEntry(i, j);
lowerData[i][j] = new BigDecimal(0);
upperData[i][j] = lu.getEntry(i, j);
protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {
if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {
throw new IllegalArgumentException("dimension mismatch");
int n = matrix.getRowDimension();
int m = matrix.getColumnDimension();
BigDecimal out[][] = new BigDecimal[m][n];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
out[i][j] = matrix.getEntry(permutation[i], j);
return new BigMatrixImpl(out);
protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{
int n = matrix.getRowDimension();
BigDecimal[][] lowerData = new BigDecimal[n][n];
BigDecimal[][] upperData = new BigDecimal[n][n];
splitLU(lu, lowerData, upperData);
BigMatrix lower =new BigMatrixImpl(lowerData);
BigMatrix upper = new BigMatrixImpl(upperData);
int[] permutation = ((BigMatrixImpl) matrix).getPermutation();
BigMatrix permuted = permuteRows(matrix, permutation);
assertClose("lu decomposition does not work", permuted,
lower.multiply(upper), normTolerance);
private void dumpMatrix(BigMatrix m) {
for (int i = 0; i < m.getRowDimension(); i++) {
String os = "";
for (int j = 0; j < m.getColumnDimension(); j++) {
os += m.getEntry(i, j) + " ";
System.out.println(os);
package org.apache.commons.math.linear;
public class InvalidMatrixExceptionTest extends TestCase {
public void testConstructor(){
InvalidMatrixException ex = new InvalidMatrixException();
assertNull(ex.getMessage());
public void testConstructorMessage(){
String msg = "message";
InvalidMatrixException ex = new InvalidMatrixException(msg);
assertEquals(msg, ex.getMessage());
package org.apache.commons.math.linear;
public class MatrixIndexExceptionTest extends TestCase {
public void testConstructorMessage(){
String msg = "message";
MatrixIndexException ex = new MatrixIndexException(msg);
assertEquals(msg, ex.getMessage());
package org.apache.commons.math.distribution;
public class TDistributionTest extends ContinuousDistributionAbstractTest {
public TDistributionTest(String name) {
super(name);
public ContinuousDistribution makeDistribution() {
return new TDistributionImpl(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,
-1.475884, 0.0, 5.89343, 3.36493, 2.570582,
2.015048, 1.475884};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d};
protected void setUp() throws Exception {
super.setUp();
setTolerance(1E-6);
public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {
TDistributionImpl td = new TDistributionImpl(5.);
td.cumulativeProbability(.1);
td.cumulativeProbability(.01);
public void testSmallDf() throws Exception {
setDistribution(new TDistributionImpl(1d));
setTolerance(1E-4);
setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,
-3.077684, 0.0, 318.3088, 31.82052, 12.70620,
6.313752, 3.077684});
setInverseCumulativeTestValues(getCumulativeTestPoints());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
TDistribution distribution = (TDistribution) getDistribution();
assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setDegreesOfFreedom(4d);
assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setDegreesOfFreedom(0d);
fail("Expecting IllegalArgumentException for df = 0");
package org.apache.commons.math.distribution;
public class GammaDistributionTest extends ContinuousDistributionAbstractTest {
public GammaDistributionTest(String name) {
super(name);
public ContinuousDistribution makeDistribution() {
return new GammaDistributionImpl(4d, 2d);
public double[] makeCumulativeTestPoints() {
return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,
3.489539, 26.12448, 20.09024, 17.53455,
15.50731, 13.36157};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d}; 
protected void setUp() throws Exception {
super.setUp();
setTolerance(6e-6);
public void testParameterAccessors() {
GammaDistribution distribution = (GammaDistribution) getDistribution();
assertEquals(4d, distribution.getAlpha(), 0);
distribution.setAlpha(3d);
assertEquals(3d, distribution.getAlpha(), 0);
assertEquals(2d, distribution.getBeta(), 0);
distribution.setBeta(4d);
assertEquals(4d, distribution.getBeta(), 0);
distribution.setAlpha(0d);
fail("Expecting IllegalArgumentException for alpha = 0");
distribution.setBeta(0d);
fail("Expecting IllegalArgumentException for beta = 0");
public void testProbabilities() throws Exception {
testProbability(-1.000, 4.0, 2.0, .0000);
testProbability(15.501, 4.0, 2.0, .9499);
testProbability(0.504, 4.0, 1.0, .0018);
testProbability(10.011, 1.0, 2.0, .9933);
testProbability(5.000, 2.0, 2.0, .7127);
public void testValues() throws Exception {
testValue(15.501, 4.0, 2.0, .9499);
testValue(0.504, 4.0, 1.0, .0018);
testValue(10.011, 1.0, 2.0, .9933);
testValue(5.000, 2.0, 2.0, .7127);
private void testProbability(double x, double a, double b, double expected) throws Exception {
GammaDistribution distribution = new GammaDistributionImpl( a, b );
double actual = distribution.cumulativeProbability(x);
assertEquals("probability for " + x, expected, actual, 10e-4);
private void testValue(double expected, double a, double b, double p) throws Exception {
GammaDistribution distribution = new GammaDistributionImpl( a, b );
double actual = distribution.inverseCumulativeProbability(p);
assertEquals("critical value for " + p, expected, actual, 10e-4);
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
package org.apache.commons.math.distribution;
public class PoissonDistributionTest extends IntegerDistributionAbstractTest {
private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;
public PoissonDistributionTest(String name) {
super(name);
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);  
public int[] makeDensityTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
public double[] makeDensityTestValues() {
return new double[] { 0d, 0.0183156388887d,  0.073262555555d,
0.14652511111d, 0.195366814813d, 0.195366814813, 
0.156293451851d, 0.00529247667642d, 8.27746364655e-09};
public int[] makeCumulativeTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };
public double[] makeCumulativeTestValues() {
return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, 
0.238103305554d, 0.433470120367d, 0.62883693518,
0.78513038703d,  0.99716023388d, 0.999999998077 };
public double[] makeInverseCumulativeTestPoints() {
return new double[] { 0d,  0.018315638889d, 0.0915781944437d, 
0.238103305554d, 0.433470120367d, 0.62883693518,
0.78513038704d,  0.99716023388d, 0.999999998077 };
public int[] makeInverseCumulativeTestValues() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
public void testNormalApproximateProbability() throws Exception {
PoissonDistribution dist = new PoissonDistributionImpl(100);
double result = dist.normalApproximateProbability(110)
- dist.normalApproximateProbability(89);
assertEquals(0.706281887248, result, 1E-10);
dist.setMean(10000);
result = dist.normalApproximateProbability(10200)
- dist.normalApproximateProbability(9899);
assertEquals(0.820070051552, result, 1E-10);
public void testDegenerateInverseCumulativeProbability() throws Exception {
PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);
assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));
assertEquals(-1, dist.inverseCumulativeProbability(0d));
public void testMean() {
PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);
dist.setMean(-1);
fail("negative mean.  IllegalArgumentException expected");
dist.setMean(10.0);
assertEquals(10.0, dist.getMean(), 0.0);
public void testLargeMeanCumulativeProbability() {
PoissonDistribution dist = new PoissonDistributionImpl(1.0);
double mean = 1.0;
while (mean <= 10000000.0) {
dist.setMean(mean);
double x = mean * 2.0;
double dx = x / 10.0;
while (x >= 0) {
dist.cumulativeProbability(x);
fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());
x -= dx;
mean *= 10.0;
public void testLargeMeanInverseCumulativeProbability() {
PoissonDistribution dist = new PoissonDistributionImpl(1.0);
double mean = 1.0;
while (mean <= 10000000.0) {
dist.setMean(mean);
double p = 0.1;
double dp = p;
while (p < 1.0) {
dist.inverseCumulativeProbability(p);
fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
p += dp;
mean *= 10.0;
package org.apache.commons.math.distribution;
public class PascalDistributionTest extends IntegerDistributionAbstractTest {
public PascalDistributionTest(String name) {
super(name);
public IntegerDistribution makeDistribution() {
return new PascalDistributionImpl(10,0.70);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, 
0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,
0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1}; 
public int[] makeInverseCumulativeTestValues() {
return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};
public void testDegenerate0() throws Exception {
setDistribution(new PascalDistributionImpl(5,0.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
public void testDegenerate1() throws Exception {
setDistribution(new PascalDistributionImpl(5,1.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {-1, -1});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
package org.apache.commons.math.distribution;
public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {
public CauchyDistributionTest(String arg0) {
super(arg0);
public ContinuousDistribution makeDistribution() {
return new CauchyDistributionImpl(1.2, 2.1);
public double[] makeCumulativeTestPoints() {
return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,
-12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,
27.88302995d, 68.0230835d, 669.6485619d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,
0.975d, 0.990d, 0.999d};
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testMedian() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
double expected = Math.random();
distribution.setMedian(expected);
assertEquals(expected, distribution.getMedian(), 0.0);
public void testScale() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
double expected = Math.random();
distribution.setScale(expected);
assertEquals(expected, distribution.getScale(), 0.0);
public void testSetScale() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
distribution.setScale(0.0);
fail("Can not have 0.0 scale.");
distribution.setScale(-1.0);
fail("Can not have negative scale.");
package org.apache.commons.math.distribution;
public abstract class ContinuousDistributionAbstractTest extends TestCase {
private ContinuousDistribution distribution;
private double tolerance = 1E-4;
private double[] cumulativeTestPoints;
private double[] cumulativeTestValues;
private double[] inverseCumulativeTestPoints;
private double[] inverseCumulativeTestValues;
public ContinuousDistributionAbstractTest(String name) {
super(name);
public abstract ContinuousDistribution makeDistribution();
public abstract double[] makeCumulativeTestPoints();
public abstract double[] makeCumulativeTestValues();
public double[] makeInverseCumulativeTestPoints() {
return makeCumulativeTestValues();
public double[] makeInverseCumulativeTestValues() {
return makeCumulativeTestPoints();
protected void setUp() throws Exception {
super.setUp();
distribution = makeDistribution();
cumulativeTestPoints = makeCumulativeTestPoints();
cumulativeTestValues = makeCumulativeTestValues();
inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();
inverseCumulativeTestValues = makeInverseCumulativeTestValues();   
protected void tearDown() throws Exception {      
super.tearDown();
distribution = null;
cumulativeTestPoints = null;
cumulativeTestValues = null;
inverseCumulativeTestPoints = null;
inverseCumulativeTestValues = null;   
protected void verifyCumulativeProbabilities() throws Exception {
for (int i = 0; i < cumulativeTestPoints.length; i++) {
TestUtils.assertEquals("Incorrect cumulative probability value returned for " 
+ cumulativeTestPoints[i], cumulativeTestValues[i], 
distribution.cumulativeProbability(cumulativeTestPoints[i]), 
getTolerance());
protected void verifyInverseCumulativeProbabilities() throws Exception {
for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {
TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for " 
+ inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], 
distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]), 
getTolerance());
public void testCumulativeProbabilities() throws Exception {
verifyCumulativeProbabilities();      
public void testInverseCumulativeProbabilities() throws Exception {
verifyInverseCumulativeProbabilities();       
public void testConsistency() throws Exception {
for (int i=1; i < cumulativeTestPoints.length; i++) {
TestUtils.assertEquals(0d, 
distribution.cumulativeProbability
(cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);
double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);
double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);
double diff = distribution.cumulativeProbability(upper) - 
distribution.cumulativeProbability(lower);
double direct = distribution.cumulativeProbability(lower, upper);
TestUtils.assertEquals("Inconsistent cumulative probabilities for (" 
+ lower + "," + upper + ")", diff, direct, tolerance);
public void testIllegalArguments() throws Exception {
distribution.cumulativeProbability(1, 0);
fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");
distribution.inverseCumulativeProbability(-1);
fail("Expecting IllegalArgumentException for p = -1");
distribution.inverseCumulativeProbability(2);
fail("Expecting IllegalArgumentException for p = 2");
protected double[] getCumulativeTestPoints() {
return cumulativeTestPoints;
protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {
this.cumulativeTestPoints = cumulativeTestPoints;
protected double[] getCumulativeTestValues() {
return cumulativeTestValues;
protected void setCumulativeTestValues(double[] cumulativeTestValues) {
this.cumulativeTestValues = cumulativeTestValues;
protected ContinuousDistribution getDistribution() {
return distribution;
protected void setDistribution(ContinuousDistribution distribution) {
this.distribution = distribution;
protected double[] getInverseCumulativeTestPoints() {
return inverseCumulativeTestPoints;
protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {
this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;
protected double[] getInverseCumulativeTestValues() {
return inverseCumulativeTestValues;
protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {
this.inverseCumulativeTestValues = inverseCumulativeTestValues;
protected double getTolerance() {
return tolerance;
protected void setTolerance(double tolerance) {
this.tolerance = tolerance;
package org.apache.commons.math.distribution;
public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {
public WeibullDistributionTest(String arg0) {
super(arg0);
public ContinuousDistribution makeDistribution() {
return new WeibullDistributionImpl(1.2, 2.1);
public double[] makeCumulativeTestPoints() {
return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,
0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,
6.232056007d, 7.497630467d, 10.51154969d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,
0.975d, 0.990d, 0.999d};
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {0.0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testAlpha() {
WeibullDistribution distribution = (WeibullDistribution) getDistribution();
double expected = Math.random();
distribution.setShape(expected);
assertEquals(expected, distribution.getShape(), 0.0);
public void testBeta() {
WeibullDistribution distribution = (WeibullDistribution) getDistribution();
double expected = Math.random();
distribution.setScale(expected);
assertEquals(expected, distribution.getScale(), 0.0);
public void testSetAlpha() {
WeibullDistribution distribution = (WeibullDistribution) getDistribution();
distribution.setShape(0.0);
fail("Can not have 0.0 alpha.");
distribution.setShape(-1.0);
fail("Can not have negative alpha.");
public void testSetBeta() {
WeibullDistribution distribution = (WeibullDistribution) getDistribution();
distribution.setScale(0.0);
fail("Can not have 0.0 beta.");
distribution.setScale(-1.0);
fail("Can not have negative beta.");
package org.apache.commons.math.distribution;
public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {
public ChiSquareDistributionTest(String name) {
super(name);
public ContinuousDistribution makeDistribution() {
return new ChiSquaredDistributionImpl(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 
20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d}; 
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1};     
public double[] makeInverseCumulativeTestValues() {
return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 
20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, 
Double.POSITIVE_INFINITY};
protected void setUp() throws Exception {
super.setUp();
setTolerance(5e-6);
public void testSmallDf() throws Exception {
setDistribution(new ChiSquaredDistributionImpl(0.1d));
setTolerance(1E-4);
setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, 
1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, 
0.5318646, 0.1526342});
setInverseCumulativeTestValues(getCumulativeTestPoints());
setInverseCumulativeTestPoints(getCumulativeTestValues());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();
assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setDegreesOfFreedom(4d);
assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setDegreesOfFreedom(0d);
fail("Expecting IllegalArgumentException for df = 0");
package org.apache.commons.math.distribution;
public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {
public NormalDistributionTest(String arg0) {
super(arg0);
public ContinuousDistribution makeDistribution() {
return new NormalDistributionImpl(2.1, 1.4);
public double[] makeCumulativeTestPoints() {
return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, 
6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d}; 
protected void setUp() throws Exception {
super.setUp();
setTolerance(1E-6);
private void verifyQuantiles() throws Exception {
NormalDistribution distribution = (NormalDistribution) getDistribution();
double mu = distribution.getMean();
double sigma = distribution.getStandardDeviation();
setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, 
mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,
mu + 5 * sigma});
setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447, 
0.9772499, 0.9986501, 0.9999683,  0.9999997});
verifyCumulativeProbabilities();       
public void testQuantiles() throws Exception {
verifyQuantiles();
setDistribution(new NormalDistributionImpl(0, 1));
verifyQuantiles();
setDistribution(new NormalDistributionImpl(0, 0.1));
verifyQuantiles();
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testGetMean() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
assertEquals(2.1, distribution.getMean(), 0);
public void testSetMean() throws Exception {
double mu = Math.random();
NormalDistribution distribution = (NormalDistribution) getDistribution();
distribution.setMean(mu);
verifyQuantiles();
public void testGetStandardDeviation() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
assertEquals(1.4, distribution.getStandardDeviation(), 0);  
public void testSetStandardDeviation() throws Exception {
double sigma = 0.1d + Math.random();
NormalDistribution distribution = (NormalDistribution) getDistribution();
distribution.setStandardDeviation(sigma);
assertEquals(sigma, distribution.getStandardDeviation(), 0);
verifyQuantiles();
distribution.setStandardDeviation(0);
fail("Expecting IllegalArgumentException for sd = 0");
public void testExtremeValues() throws Exception {
NormalDistribution distribution = (NormalDistribution) getDistribution();
distribution.setMean(0);
distribution.setStandardDeviation(1);
for (int i = 0; i < 100; i+=5) { // make sure no convergence exception
double lowerTail = distribution.cumulativeProbability((double)-i);
double upperTail = distribution.cumulativeProbability((double) i);
if (i < 10) { // make sure not top-coded
assertTrue(lowerTail > 0.0d);
assertTrue(upperTail < 1.0d);
else { // make sure top coding not reversed
assertTrue(lowerTail < 0.00001);
assertTrue(upperTail > 0.99999);
package org.apache.commons.math.distribution;
public class FDistributionTest extends ContinuousDistributionAbstractTest {
public FDistributionTest(String name) {
super(name);
public ContinuousDistribution makeDistribution() {
return new FDistributionImpl(5.0, 6.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.03468084d ,0.09370091d, 0.1433137d,
0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d, 
4.387374d, 3.107512d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d}; 
protected void setUp() throws Exception {
super.setUp();
setTolerance(4e-6);
public void testCumulativeProbabilityExtremes() throws Exception {
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
FDistribution distribution = (FDistribution) getDistribution();
assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setNumeratorDegreesOfFreedom(4d);
assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setDenominatorDegreesOfFreedom(4d);
assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
distribution.setNumeratorDegreesOfFreedom(0d);
fail("Expecting IllegalArgumentException for df = 0");
distribution.setDenominatorDegreesOfFreedom(0d);
fail("Expecting IllegalArgumentException for df = 0");
public void testLargeDegreesOfFreedom() throws Exception {
org.apache.commons.math.distribution.FDistributionImpl fd =
new org.apache.commons.math.distribution.FDistributionImpl(
100000., 100000.);
double p = fd.cumulativeProbability(.999);
double x = fd.inverseCumulativeProbability(p);
assertEquals(.999, x, 1.0e-5);
package org.apache.commons.math.distribution;
public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {
public HypergeometricDistributionTest(String name) {
super(name);
public IntegerDistribution makeDistribution() {
return new HypergeometricDistributionImpl(10,5, 5);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};
public double[] makeDensityTestValues() {
return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, 
0.099206d, 0.003968d, 0d};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,
1.00000d, 1d};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1d}; 
public int[] makeInverseCumulativeTestValues() {
return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};
public void testDegenerateNoFailures() throws Exception {
setDistribution(new HypergeometricDistributionImpl(5,5,3));
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {2, 2});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
public void testDegenerateNoSuccesses() throws Exception {
setDistribution(new HypergeometricDistributionImpl(5,0,3));
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {-1, -1});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
public void testDegenerateFullSample() throws Exception {
setDistribution(new HypergeometricDistributionImpl(5,3,5));
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {2, 2});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
public void testPopulationSize() {
HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);
dist.setPopulationSize(-1);
fail("negative population size.  IllegalArgumentException expected");
dist.setPopulationSize(10);
assertEquals(10, dist.getPopulationSize());
public void testLargeValues() {
int populationSize = 3456;
int sampleSize = 789;
int numberOfSucceses = 101;
double[][] data = {
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);
for (int i = 0; i < data.length; ++i) {
int x = (int)data[i][0];
double pdf = data[i][1];
double actualPdf = dist.probability(x);
TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);
double cdf = data[i][2];
double actualCdf = dist.cumulativeProbability(x);
TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);
double cdf1 = data[i][3];
double actualCdf1 = dist.upperCumulativeProbability(x);
TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);
public void testMoreLargeValues() {
int populationSize = 26896;
int sampleSize = 895;
int numberOfSucceses = 55;
double[][] data = {
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
package org.apache.commons.math.distribution;
public abstract class IntegerDistributionAbstractTest extends TestCase {
private IntegerDistribution distribution;
private double tolerance = 1E-4;
private int[] densityTestPoints;
private double[] densityTestValues;
private int[] cumulativeTestPoints;
private double[] cumulativeTestValues;
private double[] inverseCumulativeTestPoints;
private int[] inverseCumulativeTestValues;
public IntegerDistributionAbstractTest(String name) {
super(name);
public abstract IntegerDistribution makeDistribution();
public abstract int[] makeDensityTestPoints();
public abstract double[] makeDensityTestValues();
public abstract int[] makeCumulativeTestPoints();
public abstract double[] makeCumulativeTestValues();
public abstract double[] makeInverseCumulativeTestPoints();
public abstract int[] makeInverseCumulativeTestValues();
protected void setUp() throws Exception {
super.setUp();
distribution = makeDistribution();
densityTestPoints = makeDensityTestPoints();
densityTestValues = makeDensityTestValues();
cumulativeTestPoints = makeCumulativeTestPoints();
cumulativeTestValues = makeCumulativeTestValues();
inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();
inverseCumulativeTestValues = makeInverseCumulativeTestValues();   
protected void tearDown() throws Exception {      
super.tearDown();
distribution = null;
densityTestPoints = null;
densityTestValues = null;
cumulativeTestPoints = null;
cumulativeTestValues = null;
inverseCumulativeTestPoints = null;
inverseCumulativeTestValues = null;   
protected void verifyDensities() throws Exception {
for (int i = 0; i < densityTestPoints.length; i++) {
assertEquals("Incorrect density value returned for " + densityTestPoints[i],
densityTestValues[i], 
distribution.probability(densityTestPoints[i]), tolerance);
protected void verifyCumulativeProbabilities() throws Exception {
for (int i = 0; i < cumulativeTestPoints.length; i++) {
assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],
cumulativeTestValues[i], 
distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);
protected void verifyInverseCumulativeProbabilities() throws Exception {
for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {
assertEquals("Incorrect inverse cumulative probability value returned for " 
+ inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], 
distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));
public void testDensities() throws Exception {
verifyDensities();     
public void testCumulativeProbabilities() throws Exception {
verifyCumulativeProbabilities();      
public void testInverseCumulativeProbabilities() throws Exception {
verifyInverseCumulativeProbabilities();       
public void testIllegalArguments() throws Exception {
distribution.cumulativeProbability(1, 0);
fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");
distribution.inverseCumulativeProbability(-1);
fail("Expecting IllegalArgumentException for p = -1");
distribution.inverseCumulativeProbability(2);
fail("Expecting IllegalArgumentException for p = 2");
protected int[] getCumulativeTestPoints() {
return cumulativeTestPoints;
protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {
this.cumulativeTestPoints = cumulativeTestPoints;
protected double[] getCumulativeTestValues() {
return cumulativeTestValues;
protected void setCumulativeTestValues(double[] cumulativeTestValues) {
this.cumulativeTestValues = cumulativeTestValues;
protected int[] getDensityTestPoints() {
return densityTestPoints;
protected void setDensityTestPoints(int[] densityTestPoints) {
this.densityTestPoints = densityTestPoints;
protected double[] getDensityTestValues() {
return densityTestValues;
protected void setDensityTestValues(double[] densityTestValues) {
this.densityTestValues = densityTestValues;
protected IntegerDistribution getDistribution() {
return distribution;
protected void setDistribution(IntegerDistribution distribution) {
this.distribution = distribution;
protected double[] getInverseCumulativeTestPoints() {
return inverseCumulativeTestPoints;
protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {
this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;
protected int[] getInverseCumulativeTestValues() {
return inverseCumulativeTestValues;
protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {
this.inverseCumulativeTestValues = inverseCumulativeTestValues;
protected double getTolerance() {
return tolerance;
protected void setTolerance(double tolerance) {
this.tolerance = tolerance;
package org.apache.commons.math.distribution;
public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {
public ExponentialDistributionTest(String name) {
super(name);
public ContinuousDistribution makeDistribution() {
return new ExponentialDistributionImpl(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, 
34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d}; 
public void testCumulativeProbabilityExtremes() throws Exception {
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
public void testInverseCumulativeProbabilityExtremes() throws Exception {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testCumulativeProbability2() throws Exception {
double actual = getDistribution().cumulativeProbability(0.25, 0.75);
assertEquals(0.0905214, actual, 10e-4);
public void testMeanAccessors() {
ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();
assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);
distribution.setMean(2d);
assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);
distribution.setMean(0);
fail("Expecting IllegalArgumentException for 0 mean");
package org.apache.commons.math.distribution;
public class BinomialDistributionTest extends IntegerDistributionAbstractTest {
public BinomialDistributionTest(String name) {
super(name);
public IntegerDistribution makeDistribution() {
return new BinomialDistributionImpl(10,0.70);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, 
0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,
0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d,1}; 
public int[] makeInverseCumulativeTestValues() {
return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};
public void testDegenerate0() throws Exception {
setDistribution(new BinomialDistributionImpl(5,0.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {-1, -1});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
public void testDegenerate1() throws Exception {
setDistribution(new BinomialDistributionImpl(5,1.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {4, 4});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();     
package org.apache.commons.math.special;
public class BetaTest extends TestCase {
public BetaTest(String name) {
super(name);
private void testRegularizedBeta(double expected, double x, double a,
double b)
double actual = Beta.regularizedBeta(x, a, b);
TestUtils.assertEquals(expected, actual, 10e-15);
fail(ex.getMessage());
private void testLogBeta(double expected, double a, double b) {
double actual = Beta.logBeta(a, b);
TestUtils.assertEquals(expected, actual, 10e-15);
public void testRegularizedBetaNanPositivePositive() {
testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);
public void testRegularizedBetaPositiveNanPositive() {
testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);
public void testRegularizedBetaPositivePositiveNan() {
testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);
public void testRegularizedBetaNegativePositivePositive() {
testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);
public void testRegularizedBetaPositiveNegativePositive() {
testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);
public void testRegularizedBetaPositivePositiveNegative() {
testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);
public void testRegularizedBetaZeroPositivePositive() {
testRegularizedBeta(0.0, 0.0, 1.0, 2.0);
public void testRegularizedBetaPositiveZeroPositive() {
testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);
public void testRegularizedBetaPositivePositiveZero() {
testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);
public void testRegularizedBetaPositivePositivePositive() {
testRegularizedBeta(0.75, 0.5, 1.0, 2.0);
public void testLogBetaNanPositive() {
testLogBeta(Double.NaN, Double.NaN, 2.0);
public void testLogBetaPositiveNan() {
testLogBeta(Double.NaN, 1.0, Double.NaN);
public void testLogBetaNegativePositive() {
testLogBeta(Double.NaN, -1.0, 2.0);
public void testLogBetaPositiveNegative() {
testLogBeta(Double.NaN, 1.0, -2.0);
public void testLogBetaZeroPositive() {
testLogBeta(Double.NaN, 0.0, 2.0);
public void testLogBetaPositiveZero() {
testLogBeta(Double.NaN, 1.0, 0.0);
public void testLogBetaPositivePositive() {
testLogBeta(-0.693147180559945, 1.0, 2.0);
package org.apache.commons.math.special;
public class ErfTest extends TestCase {
public void testErf0() throws MathException {
double actual = Erf.erf(0.0);
double expected = 0.0;
assertEquals(expected, actual, 1.0e-5);
public void testErf1960() throws MathException {
double x = 1.960 / Math.sqrt(2.0);
double actual = Erf.erf(x);
double expected = 0.95;
assertEquals(expected, actual, 1.0e-5);
actual = Erf.erf(-x);
expected = -expected;
assertEquals(expected, actual, 1.0e-5);
public void testErf2576() throws MathException {
double x = 2.576 / Math.sqrt(2.0);
double actual = Erf.erf(x);
double expected = 0.99;
assertEquals(expected, actual, 1.0e-5);
actual = Erf.erf(-x);
expected = -expected;
assertEquals(expected, actual, 1.0e-5);
public void testErf2807() throws MathException {
double x = 2.807 / Math.sqrt(2.0);
double actual = Erf.erf(x);
double expected = 0.995;
assertEquals(expected, actual, 1.0e-5);
actual = Erf.erf(-x);
expected = -expected;
assertEquals(expected, actual, 1.0e-5);
public void testErf3291() throws MathException {
double x = 3.291 / Math.sqrt(2.0);
double actual = Erf.erf(x);
double expected = 0.999;
assertEquals(expected, actual, 1.0e-5);
actual = Erf.erf(-x);
expected = -expected;
assertEquals(expected, actual, 1.0e-5);
package org.apache.commons.math.special;
public class GammaTest extends TestCase {
public GammaTest(String name) {
super(name);
private void testRegularizedGamma(double expected, double a, double x) {
double actualP = Gamma.regularizedGammaP(a, x);
double actualQ = Gamma.regularizedGammaQ(a, x);
TestUtils.assertEquals(expected, actualP, 10e-15);
TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);
fail(ex.getMessage());
private void testLogGamma(double expected, double x) {
double actual = Gamma.logGamma(x);
TestUtils.assertEquals(expected, actual, 10e-15);
public void testRegularizedGammaNanPositive() {
testRegularizedGamma(Double.NaN, Double.NaN, 1.0);
public void testRegularizedGammaPositiveNan() {
testRegularizedGamma(Double.NaN, 1.0, Double.NaN);
public void testRegularizedGammaNegativePositive() {
testRegularizedGamma(Double.NaN, -1.5, 1.0);
public void testRegularizedGammaPositiveNegative() {
testRegularizedGamma(Double.NaN, 1.0, -1.0);
public void testRegularizedGammaZeroPositive() {
testRegularizedGamma(Double.NaN, 0.0, 1.0);
public void testRegularizedGammaPositiveZero() {
testRegularizedGamma(0.0, 1.0, 0.0);
public void testRegularizedGammaPositivePositive() {
testRegularizedGamma(0.632120558828558, 1.0, 1.0);
public void testLogGammaNan() {
testLogGamma(Double.NaN, Double.NaN);
public void testLogGammaNegative() {
testLogGamma(Double.NaN, -1.0);
public void testLogGammaZero() {
testLogGamma(Double.NaN, 0.0);
public void testLogGammaPositive() {
testLogGamma(0.6931471805599457, 3.0);
package org.apache.commons.math.ode;
public class ThreeEighthesIntegratorTest
extends TestCase {
public ThreeEighthesIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new ThreeEighthesIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException  {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 4; i < 10; ++i) {
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime())
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double error = handler.getMaximalError();
if (i > 4) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-13);
assertTrue(handler.getMaximalError() < 4.0e-12);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.0004);
assertTrue(handler.getMaximalError() > 0.005);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
integ.setStepHandler(new KeplerHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
private static class KeplerHandler implements StepHandler {
public KeplerHandler(TestProblem3 pb) {
this.pb = pb;
maxError = 0;
public boolean requiresDenseOutput() {
return false;
public void reset() {
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError > 0.005);
private TestProblem3 pb;
private double maxError = 0;
public static Test suite() {
return new TestSuite(ThreeEighthesIntegratorTest.class);
package org.apache.commons.math.ode;
public class EulerStepInterpolatorTest
extends TestCase {
public EulerStepInterpolatorTest(String name) {
super(name);
public void testNoReset() {
double[]   y    =   { 0.0, 1.0, -2.0 };
double[][] yDot = { { 1.0, 2.0, -2.0 } };
EulerStepInterpolator interpolator = new EulerStepInterpolator();
interpolator.reinitialize(new DummyEquations(), y, yDot, true);
interpolator.storeTime(0);
interpolator.shift();
interpolator.storeTime(1);
double[] result = interpolator.getInterpolatedState();
for (int i = 0; i < result.length; ++i) {
assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);
public void testInterpolationAtBounds()
throws DerivativeException {
double   t0 = 0;
double[] y0 = {0.0, 1.0, -2.0};
double[] y = (double[]) y0.clone();
double[][] yDot = { new double[y0.length] };
EulerStepInterpolator interpolator = new EulerStepInterpolator();
interpolator.reinitialize(new DummyEquations(), y, yDot, true);
interpolator.storeTime(t0);
double dt = 1.0;
y[0] =  1.0;
y[1] =  3.0;
y[2] = -4.0;
yDot[0][0] = (y[0] - y0[0]) / dt;
yDot[0][1] = (y[1] - y0[1]) / dt;
yDot[0][2] = (y[2] - y0[2]) / dt;
interpolator.shift();
interpolator.storeTime(t0 + dt);
interpolator.setInterpolatedTime(interpolator.getPreviousTime());
double[] result = interpolator.getInterpolatedState();
for (int i = 0; i < result.length; ++i) {
assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);
interpolator.setInterpolatedTime(interpolator.getCurrentTime());
result = interpolator.getInterpolatedState();
for (int i = 0; i < result.length; ++i) {
assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);
public void testInterpolationInside()
throws DerivativeException {
double[]   y    =   { 1.0, 3.0, -4.0 };
double[][] yDot = { { 1.0, 2.0, -2.0 } };
EulerStepInterpolator interpolator = new EulerStepInterpolator();
interpolator.reinitialize(new DummyEquations(), y, yDot, true);
interpolator.storeTime(0);
interpolator.shift();
interpolator.storeTime(1);
interpolator.setInterpolatedTime(0.1);
double[] result = interpolator.getInterpolatedState();
assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);
assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);
assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);
interpolator.setInterpolatedTime(0.5);
result = interpolator.getInterpolatedState();
assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);
assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);
assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
EulerIntegrator integ = new EulerIntegrator(step);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 82000);
assertTrue(bos.size () < 83000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 0.001);
private static class DummyEquations
implements FirstOrderDifferentialEquations {
public int getDimension() {
return 0;
public void computeDerivatives(double t, double[] y, double[] yDot) {
public static Test suite() {
return new TestSuite(EulerStepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class ClassicalRungeKuttaIntegratorTest
extends TestCase {
public ClassicalRungeKuttaIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testNullIntervalCheck() {
TestProblem1 pb = new TestProblem1();
new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()],
0.0, new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException  {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 4; i < 10; ++i) {
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime())
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double error = handler.getMaximalError();
if (i > 4) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-13);
assertTrue(handler.getMaximalError() < 4.0e-12);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.0004);
assertTrue(handler.getMaximalError() > 0.005);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
integ.setStepHandler(new KeplerHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
private static class KeplerHandler implements StepHandler {
public KeplerHandler(TestProblem3 pb) {
this.pb = pb;
reset();
public boolean requiresDenseOutput() {
return false;
public void reset() {
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError > 0.005);
private double maxError = 0;
private TestProblem3 pb;
public static Test suite() {
return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);
package org.apache.commons.math.ode;
public class ClassicalRungeKuttaStepInterpolatorTest
extends TestCase {
public ClassicalRungeKuttaStepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 700000);
assertTrue(bos.size () < 701000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError > 0.005);
public static Test suite() {
return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class DormandPrince54StepInterpolatorTest
extends TestCase {
public DormandPrince54StepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 119500);
assertTrue(bos.size () < 120500);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 7.0e-10);
public static Test suite() {
return new TestSuite(DormandPrince54StepInterpolatorTest.class);
package org.apache.commons.math.ode;
abstract class TestProblemAbstract
implements FirstOrderDifferentialEquations, Cloneable {
protected int n;
protected int calls;
protected double t0;
protected double[] y0;
protected double t1;
protected double[] errorScale;
protected TestProblemAbstract() {
n          = 0;
calls      = 0;
t0         = 0;
y0         = null;
t1         = 0;
errorScale = null;
protected TestProblemAbstract(TestProblemAbstract problem) {
n     = problem.n;
calls = problem.calls;
t0    = problem.t0;
if (problem.y0 == null) {
y0 = null;
y0 = (double[]) problem.y0.clone();
if (problem.errorScale == null) {
errorScale = null;
errorScale = (double[]) problem.errorScale.clone();
t1 = problem.t1;
public abstract Object clone();
protected void setInitialConditions(double t0, double[] y0) {
calls     = 0;
n         = y0.length;
this.t0   = t0;
this.y0   = (double[]) y0.clone(); 
protected void setFinalConditions(double t1) {
this.t1 = t1;
protected void setErrorScale(double[] errorScale) {
this.errorScale = (double[]) errorScale.clone(); 
public int getDimension() {
return n;
public double getInitialTime() {
return t0;
public double[] getInitialState() {
return y0;
public double getFinalTime() {
return t1;
public double[] getErrorScale() {
return errorScale;
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[0];
public int getCalls() {
return calls;
public void computeDerivatives(double t, double[] y, double[] yDot) {
++calls;
doComputeDerivatives(t, y, yDot);
abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);
abstract public double[] computeTheoreticalState(double t);
package org.apache.commons.math.ode;
public class GraggBulirschStoerStepInterpolatorTest
extends TestCase {
public GraggBulirschStoerStepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb  = new TestProblem3(0.9);
double minStep   = 0;
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-8;
double relTolerance = 1.0e-8;
GraggBulirschStoerIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 34000);
assertTrue(bos.size () < 35000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 5.0e-11);
public static Test suite() {
return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class DormandPrince853IntegratorTest
extends TestCase {
public DormandPrince853IntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,
1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testNullIntervalCheck() {
TestProblem1 pb = new TestProblem1();
DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,
1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()],
0.0, new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testMinStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-15;
double scalRelativeTolerance = 1.0e-15;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testIncreasingTolerance()
throws DerivativeException, IntegratorException {
int previousCalls = Integer.MAX_VALUE;
for (int i = -12; i < -2; ++i) {
TestProblem1 pb = new TestProblem1();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = Math.pow(10.0, i);
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));
int calls = pb.getCalls();
assertTrue(calls <= previousCalls);
previousCalls = calls;
public void testSwitchingFunctions()
throws DerivativeException, IntegratorException {
TestProblem4 pb = new TestProblem4();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-9;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < 5.0e-8);
assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new KeplerHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(pb.getCalls() < 2900);
public void testVariableSteps()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testNoDenseOutput()
throws DerivativeException, IntegratorException {
TestProblem1 pb1 = new TestProblem1();
TestProblem1 pb2 = (TestProblem1) pb1.clone();
double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());
double maxStep = pb1.getFinalTime() - pb1.getInitialTime();
double scalAbsoluteTolerance = 1.0e-4;
double scalRelativeTolerance = 1.0e-4;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(DummyStepHandler.getInstance());
integ.integrate(pb1,
pb1.getInitialTime(), pb1.getInitialState(),
pb1.getFinalTime(), new double[pb1.getDimension()]);
int callsWithoutDenseOutput = pb1.getCalls();
integ.setStepHandler(new InterpolatingStepHandler());
integ.integrate(pb2,
pb2.getInitialTime(), pb2.getInitialState(),
pb2.getFinalTime(), new double[pb2.getDimension()]);
int callsWithDenseOutput = pb2.getCalls();
assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);
public void testUnstableDerivative()
throws DerivativeException, IntegratorException {
final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);
FirstOrderIntegrator integ =
new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);
double[] y = { Double.NaN };
integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);
assertEquals(8.0, y[0], 1.0e-12);
private static class KeplerHandler implements StepHandler {
public KeplerHandler(TestProblem3 pb) {
this.pb = pb;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
nbSteps = 0;
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast)
throws DerivativeException {
++nbSteps;
for (int a = 1; a < 10; ++a) {
double prev   = interpolator.getPreviousTime();
double curr   = interpolator.getCurrentTime();
double interp = ((10 - a) * prev + a * curr) / 10;
interpolator.setInterpolatedTime(interp);
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError < 2.4e-10);
assertTrue(nbSteps < 150);
private int nbSteps;
private double maxError;
private TestProblem3 pb;
private static class VariableHandler implements StepHandler {
public VariableHandler() {
reset();
public boolean requiresDenseOutput() {
return false;
public void reset() {
firstTime = true;
minStep = 0;
maxStep = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double step = Math.abs(interpolator.getCurrentTime()
- interpolator.getPreviousTime());
if (firstTime) {
minStep   = Math.abs(step);
maxStep   = minStep;
firstTime = false;
if (step < minStep) {
minStep = step;
if (step > maxStep) {
maxStep = step;
if (isLast) {
assertTrue(minStep < (1.0 / 100.0));
assertTrue(maxStep > (1.0 / 2.0));
private boolean firstTime = true;
private double  minStep = 0;
private double  maxStep = 0;
private static class InterpolatingStepHandler implements StepHandler {
public boolean requiresDenseOutput() {
return true;
public void reset() {
public void handleStep(StepInterpolator interpolator,
boolean isLast)
throws DerivativeException {
double prev = interpolator.getPreviousTime();
double curr = interpolator.getCurrentTime();
interpolator.setInterpolatedTime(0.5*(prev + curr));
public static Test suite() {
return new TestSuite(DormandPrince853IntegratorTest.class);
package org.apache.commons.math.ode;
public class EulerIntegratorTest
extends TestCase {
public EulerIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new EulerIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 4; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime())
FirstOrderIntegrator integ = new EulerIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double error = handler.getMaximalError();
if (i > 4) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new EulerIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-4);
assertTrue(handler.getMaximalError() < 1.0e-3);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new EulerIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
assertTrue(handler.getMaximalError() > 0.2);
public static Test suite() {
return new TestSuite(EulerIntegratorTest.class);
package org.apache.commons.math.ode;
public class DormandPrince54IntegratorTest
extends TestCase {
public DormandPrince54IntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,
1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testMinStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-15;
double scalRelativeTolerance = 1.0e-15;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testSmallLastStep()
throws DerivativeException, IntegratorException {
TestProblemAbstract pb = new TestProblem5();
double minStep = 1.25;
double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());
double scalAbsoluteTolerance = 6.0e-4;
double scalRelativeTolerance = 6.0e-4;
AdaptiveStepsizeIntegrator integ =
new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);
integ.setStepHandler(handler);
integ.setInitialStepSize(1.7);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.wasLastSeen());
private static class DP54SmallLastHandler implements StepHandler {
public DP54SmallLastHandler(double minStep) {
lastSeen = false;
this.minStep = minStep;
public boolean requiresDenseOutput() {
return false;
public void reset() {
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (isLast) {
lastSeen = true;
double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();
assertTrue(Math.abs(h) < minStep);
public boolean wasLastSeen() {
return lastSeen;
private boolean lastSeen;
private double  minStep;
public void testIncreasingTolerance()
throws DerivativeException, IntegratorException {
int previousCalls = Integer.MAX_VALUE;
for (int i = -12; i < -2; ++i) {
TestProblem1 pb = new TestProblem1();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = Math.pow(10.0, i);
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));
int calls = pb.getCalls();
assertTrue(calls <= previousCalls);
previousCalls = calls;
public void testSwitchingFunctions()
throws DerivativeException, IntegratorException {
TestProblem4 pb = new TestProblem4();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < 5.0e-6);
assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new KeplerHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(pb.getCalls() < 2800);
public void testVariableSteps()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
private static class KeplerHandler implements StepHandler {
public KeplerHandler(TestProblem3 pb) {
this.pb = pb;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
nbSteps = 0;
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast)
throws DerivativeException {
++nbSteps;
for (int a = 1; a < 10; ++a) {
double prev   = interpolator.getPreviousTime();
double curr   = interpolator.getCurrentTime();
double interp = ((10 - a) * prev + a * curr) / 10;
interpolator.setInterpolatedTime(interp);
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError < 7.0e-10);
assertTrue(nbSteps < 400);
private int nbSteps;
private double maxError;
private TestProblem3 pb;
private static class VariableHandler implements StepHandler {
public VariableHandler() {
firstTime = true;
minStep = 0;
maxStep = 0;
public boolean requiresDenseOutput() {
return false;
public void reset() {
firstTime = true;
minStep = 0;
maxStep = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double step = Math.abs(interpolator.getCurrentTime()
- interpolator.getPreviousTime());
if (firstTime) {
minStep   = Math.abs(step);
maxStep   = minStep;
firstTime = false;
if (step < minStep) {
minStep = step;
if (step > maxStep) {
maxStep = step;
if (isLast) {
assertTrue(minStep < (1.0 / 450.0));
assertTrue(maxStep > (1.0 / 4.2));
private boolean firstTime;
private double  minStep;
private double  maxStep;
public static Test suite() {
return new TestSuite(DormandPrince54IntegratorTest.class);
package org.apache.commons.math.ode;
public class StepNormalizerTest
extends TestCase {
public StepNormalizerTest(String name) {
super(name);
pb    = null;
integ = null;
public void testBoundaries()
throws DerivativeException, IntegratorException {
double range = pb.getFinalTime() - pb.getInitialTime();
setLastSeen(false);
integ.setStepHandler(new StepNormalizer(range / 10.0,
new FixedStepHandler() {
private boolean firstCall = true;
public void handleStep(double t,
double[] y,
boolean isLast) {
if (firstCall) {
checkValue(t, pb.getInitialTime());
firstCall = false;
if (isLast) {
setLastSeen(true);
checkValue(t, pb.getFinalTime());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(lastSeen);
public void testBeforeEnd()
throws DerivativeException, IntegratorException {
final double range = pb.getFinalTime() - pb.getInitialTime();
setLastSeen(false);
integ.setStepHandler(new StepNormalizer(range / 10.5,
new FixedStepHandler() {
public void handleStep(double t,
double[] y,
boolean isLast) {
if (isLast) {
setLastSeen(true);
checkValue(t,
pb.getFinalTime() - range / 21.0);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(lastSeen);
public void checkValue(double value, double reference) {
assertTrue(Math.abs(value - reference) < 1.0e-10);
public void setLastSeen(boolean lastSeen) {
this.lastSeen = lastSeen;
public static Test suite() {
return new TestSuite(StepNormalizerTest.class);
public void setUp() {
pb = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);
lastSeen = false;
public void tearDown() {
pb    = null;
integ = null;
TestProblem3 pb;
FirstOrderIntegrator integ;
boolean lastSeen;
package org.apache.commons.math.ode;
public class GillStepInterpolatorTest
extends TestCase {
public GillStepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
GillIntegrator integ = new GillIntegrator(step);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 700000);
assertTrue(bos.size () < 701000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 0.003);
public static Test suite() {
return new TestSuite(GillStepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class DormandPrince853StepInterpolatorTest
extends TestCase {
public DormandPrince853StepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 86000);
assertTrue(bos.size () < 87000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 2.4e-10);
public static Test suite() {
return new TestSuite(DormandPrince853StepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class StepProblem
implements FirstOrderDifferentialEquations, SwitchingFunction {
public StepProblem(double rateBefore, double rateAfter,
double switchTime) {
this.rateAfter  = rateAfter;
this.switchTime = switchTime;
setRate(rateBefore);
public void computeDerivatives(double t, double[] y, double[] yDot) {
yDot[0] = rate;
public int getDimension() {
return 1;
public void setRate(double rate) {
this.rate = rate;
public int eventOccurred(double t, double[] y) {
setRate(rateAfter);
return RESET_DERIVATIVES;
public double g(double t, double[] y) {
return t - switchTime;
public void resetState(double t, double[] y) {
private double rate;
private double rateAfter;
private double switchTime;
private static final long serialVersionUID = 7590601995477504318L;
package org.apache.commons.math.ode;
class TestProblem1
extends TestProblemAbstract {
private double[] y;
public TestProblem1() {
super();
double[] y0 = { 1.0, 0.1 };
setInitialConditions(0.0, y0);
setFinalConditions(4.0);
double[] errorScale = { 1.0, 1.0 };
setErrorScale(errorScale);
y = new double[y0.length];
public TestProblem1(TestProblem1 problem) {
super(problem);
y = (double[]) problem.y.clone();
public Object clone() {
return new TestProblem1(this);
public void doComputeDerivatives(double t, double[] y, double[] yDot) {
for (int i = 0; i < n; ++i)
yDot[i] = -y[i];
public double[] computeTheoreticalState(double t) {
double c = Math.exp (t0 - t);
for (int i = 0; i < n; ++i) {
y[i] = c * y0[i];
return y;
package org.apache.commons.math.ode;
class TestProblem2
extends TestProblemAbstract {
private double[] y;
public TestProblem2() {
super();
double[] y0 = { 0.0 };
setInitialConditions(0.0, y0);
setFinalConditions(1.0);
double[] errorScale = { 1.0 };
setErrorScale(errorScale);
y = new double[y0.length];
public TestProblem2(TestProblem2 problem) {
super(problem);
y = (double[]) problem.y.clone();
public Object clone() {
return new TestProblem2(this);
public void doComputeDerivatives(double t, double[] y, double[] yDot) {
for (int i = 0; i < n; ++i)
yDot[i] = t * (t * t - y[i]);
public double[] computeTheoreticalState(double t) {
double t2 = t * t;
double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);
for (int i = 0; i < n; ++i) {
y[i] = c;
return y;
package org.apache.commons.math.ode;
public class ContinuousOutputModelTest
extends TestCase {
public ContinuousOutputModelTest(String name) {
super(name);
pb    = null;
integ = null;
public void testBoundaries()
throws DerivativeException, IntegratorException {
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());
cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());
cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));
public void testRandomAccess()
throws DerivativeException, IntegratorException {
ContinuousOutputModel cm = new ContinuousOutputModel();
integ.setStepHandler(cm);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 1.0e-9);
public void checkValue(double value, double reference) {
assertTrue(Math.abs(value - reference) < 1.0e-10);
public static Test suite() {
return new TestSuite(ContinuousOutputModelTest.class);
public void setUp() {
pb = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);
public void tearDown() {
pb    = null;
integ = null;
TestProblem3 pb;
FirstOrderIntegrator integ;
package org.apache.commons.math.ode;
class TestProblemHandler
implements StepHandler {
private TestProblemAbstract problem;
private double maxError;
private double lastError;
private double lastTime;
public TestProblemHandler(TestProblemAbstract problem) {
this.problem = problem;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
maxError  = 0;
lastError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast)
throws DerivativeException {
double pT = interpolator.getPreviousTime();
double cT = interpolator.getCurrentTime();
double[] errorScale = problem.getErrorScale();
if (isLast) {
double[] interpolatedY = interpolator.getInterpolatedState();
double[] theoreticalY  = problem.computeTheoreticalState(cT);
for (int i = 0; i < interpolatedY.length; ++i) {
double error = Math.abs(interpolatedY[i] - theoreticalY[i]);
if (error > lastError) {
lastError = error;
lastTime = cT;
for (int k = 0; k <= 20; ++k) {
double time = pT + (k * (cT - pT)) / 20;
interpolator.setInterpolatedTime(time);
double[] interpolatedY = interpolator.getInterpolatedState();
double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());
for (int i = 0; i < interpolatedY.length; ++i) {
double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);
if (error > maxError) {
maxError = error;
public double getMaximalError() {
return maxError;
public double getLastError() {
return lastError;
public double getLastTime() {
return lastTime;
package org.apache.commons.math.ode;
public class HighamHall54StepInterpolatorTest
extends TestCase {
public HighamHall54StepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 158000);
assertTrue(bos.size () < 159000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 1.6e-10);
public static Test suite() {
return new TestSuite(HighamHall54StepInterpolatorTest.class);
package org.apache.commons.math.ode;
public class HighamHall54IntegratorTest
extends TestCase {
public HighamHall54IntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0,
1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testMinStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-15;
double scalRelativeTolerance = 1.0e-15;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testIncreasingTolerance()
throws DerivativeException, IntegratorException {
int previousCalls = Integer.MAX_VALUE;
for (int i = -12; i < -2; ++i) {
TestProblem1 pb = new TestProblem1();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = Math.pow(10.0, i);
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));
int calls = pb.getCalls();
assertTrue(calls <= previousCalls);
previousCalls = calls;
public void testSwitchingFunctions()
throws DerivativeException, IntegratorException {
TestProblem4 pb = new TestProblem4();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < 1.0e-7);
assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
integ.setStepHandler(new KeplerHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
private static class KeplerHandler implements StepHandler {
public KeplerHandler(TestProblem3 pb) {
this.pb = pb;
nbSteps = 0;
maxError = 0;
public boolean requiresDenseOutput() {
return false;
public void reset() {
nbSteps = 0;
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
++nbSteps;
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError < 1.54e-10);
assertTrue(nbSteps < 520);
private TestProblem3 pb;
private int nbSteps;
private double maxError;
public static Test suite() {
return new TestSuite(HighamHall54IntegratorTest.class);
package org.apache.commons.math.ode;
public class MidpointStepInterpolatorTest
extends TestCase {
public MidpointStepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
MidpointIntegrator integ = new MidpointIntegrator(step);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 98000);
assertTrue(bos.size () < 99000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError < 1.0e-6);
public static Test suite() {
return new TestSuite(MidpointStepInterpolatorTest.class);
package org.apache.commons.math.ode;
class TestProblem3
extends TestProblemAbstract {
double e;
private double[] y;
public TestProblem3(double e) {
super();
this.e = e;
double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };
setInitialConditions(0.0, y0);
setFinalConditions(20.0);
double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };
setErrorScale(errorScale);
y = new double[y0.length];
public TestProblem3() {
this(0.1);
public TestProblem3(TestProblem3 problem) {
super(problem);
e = problem.e;
y = (double[]) problem.y.clone();
public Object clone() {
return new TestProblem3(this);
public void doComputeDerivatives(double t, double[] y, double[] yDot) {
double r2 = y[0] * y[0] + y[1] * y[1];
double invR3 = 1 / (r2 * Math.sqrt(r2));
yDot[0] = y[2];
yDot[1] = y[3];
yDot[2] = -invR3  * y[0];
yDot[3] = -invR3  * y[1];
public double[] computeTheoreticalState(double t) {
double E = t;
double d = 0;
double corr = 0;
do {
double f2  = e * Math.sin(E);
double f0  = d - f2;
double f1  = 1 - e * Math.cos(E);
double f12 = f1 + f1;
corr  = f0 * f12 / (f1 * f12 - f0 * f2);
d -= corr;
E = t + d;
double cosE = Math.cos(E);
double sinE = Math.sin(E);
y[0] = cosE - e;
y[1] = Math.sqrt(1 - e * e) * sinE;
y[2] = -sinE / (1 - e * cosE);
y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);
return y;
package org.apache.commons.math.ode;
class TestProblemFactory {
private static TestProblemAbstract[] pool = {
new TestProblem1(),
new TestProblem2(),
new TestProblem3(),
new TestProblem4(),
new TestProblem5()
private TestProblemFactory() {
public static TestProblemAbstract[] getProblems() {
return pool;
package org.apache.commons.math.ode;
public class GillIntegratorTest
extends TestCase {
public GillIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new GillIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException  {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 5; i < 10; ++i) {
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime())
FirstOrderIntegrator integ = new GillIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double error = handler.getMaximalError();
if (i > 5) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new GillIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-13);
assertTrue(handler.getMaximalError() < 4.0e-12);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new GillIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.0004);
assertTrue(handler.getMaximalError() > 0.005);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb  = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
FirstOrderIntegrator integ = new GillIntegrator(step);
integ.setStepHandler(new KeplerStepHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testUnstableDerivative()
throws DerivativeException, IntegratorException {
final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);
FirstOrderIntegrator integ = new GillIntegrator(0.3);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);
double[] y = { Double.NaN };
integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);
assertEquals(8.0, y[0], 1.0e-12);
private static class KeplerStepHandler implements StepHandler {
public KeplerStepHandler(TestProblem3 pb) {
this.pb = pb;
reset();
public boolean requiresDenseOutput() {
return false;
public void reset() {
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError > 0.001);
private double maxError;
private TestProblem3 pb;
public static Test suite() {
return new TestSuite(GillIntegratorTest.class);
package org.apache.commons.math.ode;
class TestProblem4
extends TestProblemAbstract {
private double a;
private double[] y;
public TestProblem4() {
super();
a = 1.2;
double[] y0 = { Math.sin(a), Math.cos(a) };
setInitialConditions(0.0, y0);
setFinalConditions(15);
double[] errorScale = { 1.0, 0.0 };
setErrorScale(errorScale);
y = new double[y0.length];
public TestProblem4(TestProblem4 problem) {
super(problem);
a = problem.a;
y = (double[]) problem.y.clone();
public Object clone() {
return new TestProblem4(this);
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[] { new Bounce(), new Stop() };
public void doComputeDerivatives(double t, double[] y, double[] yDot) {
yDot[0] =  y[1];
yDot[1] = -y[0];
public double[] computeTheoreticalState(double t) {
double sin = Math.sin(t + a);
double cos = Math.cos(t + a);
y[0] = Math.abs(sin);
y[1] = (sin >= 0) ? cos : -cos;
return y;
private static class Bounce implements SwitchingFunction {
private static final long serialVersionUID = 1356097180027801200L;
private int sign;
public Bounce() {
sign = +1;
public double g(double t, double[] y) {
return sign * y[0];
public int eventOccurred(double t, double[] y) {
sign = -sign;
return SwitchingFunction.RESET_STATE;
public void resetState(double t, double[] y) {
y[1] = -y[1];
private static class Stop implements SwitchingFunction {
private static final long serialVersionUID = 6975050568227951931L;
public Stop() {
public double g(double t, double[] y) {
return t - 12.0;
public int eventOccurred(double t, double[] y) {
return SwitchingFunction.STOP;
public void resetState(double t, double[] y) {
package org.apache.commons.math.ode;
public class MidpointIntegratorTest
extends TestCase {
public MidpointIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new MidpointIntegrator(0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testDecreasingSteps()
throws DerivativeException, IntegratorException  {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 4; i < 10; ++i) {
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime())
FirstOrderIntegrator integ = new MidpointIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double error = handler.getMaximalError();
if (i > 4) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new MidpointIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-7);
assertTrue(handler.getMaximalError() < 1.0e-6);
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new MidpointIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
assertTrue(handler.getMaximalError() > 0.05);
public static Test suite() {
return new TestSuite(MidpointIntegratorTest.class);
package org.apache.commons.math.ode;
public class GraggBulirschStoerIntegratorTest
extends TestCase {
public GraggBulirschStoerIntegratorTest(String name) {
super(name);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
FirstOrderIntegratorFactory factory =
FirstOrderIntegratorFactory.newInstance();
AdaptiveStepsizeIntegrator integrator =
factory.newGraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testNullIntervalCheck() {
TestProblem1 pb = new TestProblem1();
GraggBulirschStoerIntegrator integrator =
new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);
integrator.integrate(pb,
0.0, new double[pb.getDimension()],
0.0, new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testMinStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double minStep   = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-20;
double relTolerance = 1.0e-20;
FirstOrderIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testIncreasingTolerance()
throws DerivativeException, IntegratorException {
int previousCalls = Integer.MAX_VALUE;
for (int i = -12; i < -4; ++i) {
TestProblem1 pb     = new TestProblem1();
double minStep      = 0;
double maxStep      = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = Math.pow(10.0, i);
double relTolerance = absTolerance;
FirstOrderIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
double ratio =  handler.getMaximalError() / absTolerance;
assertTrue(ratio < 2.4);
assertTrue(ratio > 0.02);
int calls = pb.getCalls();
assertTrue(calls <= previousCalls);
previousCalls = calls;
public void testSwitchingFunctions()
throws DerivativeException, IntegratorException {
TestProblem4 pb = new TestProblem4();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-10;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb);
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
for (int l = 0; l < functions.length; ++l) {
integ.addSwitchingFunction(functions[l],
Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalError() < 5.0e-8);
assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);
public void testKepler()
throws DerivativeException, IntegratorException {
final TestProblem3 pb = new TestProblem3(0.9);
double minStep        = 0;
double maxStep        = pb.getFinalTime() - pb.getInitialTime();
double absTolerance   = 1.0e-6;
double relTolerance   = 1.0e-6;
FirstOrderIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
integ.setStepHandler(new KeplerStepHandler(pb));
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(pb.getCalls() < 2150);
public void testVariableSteps()
throws DerivativeException, IntegratorException {
final TestProblem3 pb = new TestProblem3(0.9);
double minStep        = 0;
double maxStep        = pb.getFinalTime() - pb.getInitialTime();
double absTolerance   = 1.0e-8;
double relTolerance   = 1.0e-8;
FirstOrderIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
integ.setStepHandler(new VariableStepHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
public void testUnstableDerivative()
throws DerivativeException, IntegratorException {
final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);
FirstOrderIntegrator integ =
new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);
double[] y = { Double.NaN };
integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);
assertEquals(8.0, y[0], 1.0e-12);
private static class KeplerStepHandler implements StepHandler {
public KeplerStepHandler(TestProblem3 pb) {
this.pb = pb;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
nbSteps = 0;
maxError = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast)
throws DerivativeException {
++nbSteps;
for (int a = 1; a < 100; ++a) {
double prev   = interpolator.getPreviousTime();
double curr   = interpolator.getCurrentTime();
double interp = ((100 - a) * prev + a * curr) / 100;
interpolator.setInterpolatedTime(interp);
double[] interpolatedY = interpolator.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
if (isLast) {
assertTrue(maxError < 2.7e-6);
assertTrue(nbSteps < 80);
private int nbSteps;
private double maxError;
private TestProblem3 pb;
public static class VariableStepHandler implements StepHandler {
public VariableStepHandler() {
reset();
public boolean requiresDenseOutput() {
return false;
public void reset() {
firstTime = true;
minStep = 0;
maxStep = 0;
public void handleStep(StepInterpolator interpolator,
boolean isLast) {
double step = Math.abs(interpolator.getCurrentTime()
- interpolator.getPreviousTime());
if (firstTime) {
minStep   = Math.abs(step);
maxStep   = minStep;
firstTime = false;
if (step < minStep) {
minStep = step;
if (step > maxStep) {
maxStep = step;
if (isLast) {
assertTrue(minStep < 8.2e-3);
assertTrue(maxStep > 1.7);
private boolean firstTime;
private double  minStep;
private double  maxStep;
public static Test suite() {
return new TestSuite(GraggBulirschStoerIntegratorTest.class);
package org.apache.commons.math.ode;
public class ThreeEighthesStepInterpolatorTest
extends TestCase {
public ThreeEighthesStepInterpolatorTest(String name) {
super(name);
public void testSerialization()
throws DerivativeException, IntegratorException,
IOException, ClassNotFoundException {
TestProblem3 pb = new TestProblem3(0.9);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
integ.setStepHandler(new ContinuousOutputModel());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(integ.getStepHandler());
assertTrue(bos.size () > 700000);
assertTrue(bos.size () < 701000);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
Random random = new Random(347588535632l);
double maxError = 0.0;
for (int i = 0; i < 1000; ++i) {
double r = random.nextDouble();
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
cm.setInterpolatedTime(time);
double[] interpolatedY = cm.getInterpolatedState ();
double[] theoreticalY  = pb.computeTheoreticalState(time);
double dx = interpolatedY[0] - theoreticalY[0];
double dy = interpolatedY[1] - theoreticalY[1];
double error = dx * dx + dy * dy;
if (error > maxError) {
maxError = error;
assertTrue(maxError > 0.005);
public static Test suite() {
return new TestSuite(ThreeEighthesStepInterpolatorTest.class);
package org.apache.commons.math.ode;
class TestProblem5
extends TestProblem1 {
public TestProblem5() {
super();
setFinalConditions(2 * t0 - t1);
package org.apache.commons.math.ode;
public class FirstOrderConverterTest
extends TestCase {
public FirstOrderConverterTest(String name) {
super(name);
public void testDoubleDimension() {
for (int i = 1; i < 10; ++i) {
SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);
FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);
assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
double previousError = Double.NaN;
for (int i = 0; i < 10; ++i) {
double step  = Math.pow(2.0, -(i + 1));
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)
- Math.sin(4.0);
if (i > 0) {
assertTrue(Math.abs(error) < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)
- Math.sin(4.0);
assertTrue(Math.abs(error) < 1.0e-10);
public void testBigStep()
throws DerivativeException, IntegratorException {
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)
- Math.sin(4.0);
assertTrue(Math.abs(error) > 0.1);
public static Test suite() {
return new TestSuite(FirstOrderConverterTest.class);
private static class Equations
implements SecondOrderDifferentialEquations {
private int n;
private double omega2;
public Equations(int n, double omega) {
this.n = n;
omega2 = omega * omega;
public int getDimension() {
return n;
public void computeSecondDerivatives(double t, double[] y, double[] yDot,
double[] yDDot) {
for (int i = 0; i < n; ++i) {
yDDot[i] = -omega2 * y[i];
private double integrateWithSpecifiedStep(double omega,
double t0, double t,
double step)
throws DerivativeException, IntegratorException {
double[] y0 = new double[2];
y0[0] = Math.sin(omega * t0);
y0[1] = omega * Math.cos(omega * t0);
ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);
double[] y = new double[2];
i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);
return y[0];
package org.apache.commons.math.stat;
public class CertifiedDataTest extends TestCase  {
protected double mean = Double.NaN;
protected double std = Double.NaN;
public CertifiedDataTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(CertifiedDataTest.class);
suite.setName("Certified Tests");
return suite;
public void testUnivariateImpl() throws Exception {
SummaryStatistics u = SummaryStatistics.newInstance(SummaryStatisticsImpl.class);
loadStats("data/PiDigits.txt", u);
assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);
assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);  
loadStats("data/Mavro.txt", u);
assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);
assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);
loadStats("data/NumAcc1.txt", u);
assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);
assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);
public void testStoredUnivariateImpl() throws Exception {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
loadStats("data/PiDigits.txt", u);
assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);
assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);
loadStats("data/Mavro.txt", u);
assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);
assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);        
loadStats("data/NumAcc1.txt", u);
assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);
assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);
private void loadStats(String resource, Object u) throws Exception {
DescriptiveStatistics d = null;
SummaryStatistics s = null;
if (u instanceof DescriptiveStatistics) {
d = (DescriptiveStatistics) u;
s = (SummaryStatistics) u;
u.getClass().getDeclaredMethod(
"clear", new Class[]{}).invoke(u, new Object[]{});
mean = Double.NaN;
std = Double.NaN;
BufferedReader in =
new BufferedReader(
new InputStreamReader(
getClass().getResourceAsStream(resource)));
String line = null;
for (int j = 0; j < 60; j++) {
line = in.readLine();
if (j == 40) {
mean =
Double.parseDouble(
line.substring(line.lastIndexOf(":") + 1).trim());
if (j == 41) {
std =
Double.parseDouble(
line.substring(line.lastIndexOf(":") + 1).trim());
line = in.readLine();
while (line != null) {
if (d != null) {
d.addValue(Double.parseDouble(line.trim()));
s.addValue(Double.parseDouble(line.trim()));
line = in.readLine();
in.close();
package org.apache.commons.math.stat;
public final class StatUtilsTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
private double nan = Double.NaN;
public StatUtilsTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(StatUtilsTest.class);
suite.setName("StatUtil Tests");
return suite;
public void testStats() {
double[] values = new double[] { one, two, two, three };
assertEquals("sum", sum, StatUtils.sum(values), tolerance);
assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);
assertEquals("var", var, StatUtils.variance(values), tolerance);
assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);
assertEquals("mean", mean, StatUtils.mean(values), tolerance);
assertEquals("min", min, StatUtils.min(values), tolerance);
assertEquals("max", max, StatUtils.max(values), tolerance);
public void testN0andN1Conditions() throws Exception {
double[] values = new double[0];
assertTrue(
"Mean of n = 0 set should be NaN",
Double.isNaN(StatUtils.mean(values)));
assertTrue(
"Variance of n = 0 set should be NaN",
Double.isNaN(StatUtils.variance(values)));
values = new double[] { one };
assertTrue(
"Mean of n = 1 set should be value of single item n1",
StatUtils.mean(values) == one);
assertTrue(
"Variance of n = 1 set should be zero",
StatUtils.variance(values) == 0);
public void testArrayIndexConditions() throws Exception {
double[] values = { 1.0, 2.0, 3.0, 4.0 };
assertEquals(
"Sum not expected",
5.0,
StatUtils.sum(values, 1, 2),
Double.MIN_VALUE);
assertEquals(
"Sum not expected",
3.0,
StatUtils.sum(values, 0, 2),
Double.MIN_VALUE);
assertEquals(
"Sum not expected",
7.0,
StatUtils.sum(values, 2, 2),
Double.MIN_VALUE);
StatUtils.sum(values, 2, 3);
assertTrue("Didn't throw exception", false);
assertTrue(true);
StatUtils.sum(values, -1, 2);
assertTrue("Didn't throw exception", false);
assertTrue(true);
public void testSumSq() {
double[] x = null;
StatUtils.sumSq(x);
fail("null is not a valid data array.");
StatUtils.sumSq(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);
public void testProduct() {
double[] x = null;
StatUtils.product(x);
fail("null is not a valid data array.");
StatUtils.product(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.product(x), tolerance);
TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(12, StatUtils.product(x), tolerance);
TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);
public void testSumLog() {
double[] x = null;
StatUtils.sumLog(x);
fail("null is not a valid data array.");
StatUtils.sumLog(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);
public void testMean() {
double[] x = null;
StatUtils.mean(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);
public void testVariance() {
double[] x = null;
StatUtils.variance(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);
public void testMax() {
double[] x = null;
StatUtils.max(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(two, StatUtils.max(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);
public void testMin() {
double[] x = null;
StatUtils.min(x, 0, 4);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(two, StatUtils.min(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);
public void testPercentile() {
double[] x = null;
StatUtils.percentile(x, .25);
fail("null is not a valid data array.");
StatUtils.percentile(x, 0, 4, 0.25);
fail("null is not a valid data array.");
x = new double[] {};
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);
public void testDifferenceStats() throws Exception {
double sample1[] = {1d, 2d, 3d, 4d};
double sample2[] = {1d, 3d, 4d, 2d};
double diff[] = {0d, -1d, -1d, 2d};
double small[] = {1d, 4d};
double meanDifference = StatUtils.meanDifference(sample1, sample2);
assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);
assertEquals(meanDifference, StatUtils.mean(diff), tolerance);
assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), 
StatUtils.variance(diff), tolerance);
StatUtils.meanDifference(sample1, small);
fail("Expecting IllegalArgumentException");
StatUtils.varianceDifference(sample1, small, meanDifference);
fail("Expecting IllegalArgumentException");
double[] single = {1.0};
StatUtils.varianceDifference(single, single, meanDifference);
fail("Expecting IllegalArgumentException");
public void testGeometricMean() throws Exception {
double[] test = null;
StatUtils.geometricMean(test);
fail("Expecting IllegalArgumentException");
test = new double[] {2, 4, 6, 8};
assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), 
StatUtils.geometricMean(test), Double.MIN_VALUE);
assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), 
StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);
package org.apache.commons.math.stat.inference;
public class ChiSquareTestTest extends TestCase {
protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();
public ChiSquareTestTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(ChiSquareTestTest.class);
suite.setName("TestStatistic Tests");
return suite;
public void testChiSquare() throws Exception {
long[] observed = {10, 9, 11};
double[] expected = {10, 10, 10};
assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);
assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);
long[] observed1 = { 500, 623, 72, 70, 31 };
double[] expected1 = { 485, 541, 82, 61, 37 };
assertEquals( "chi-square test statistic", 16.4131070362, testStatistic.chiSquare(expected1, observed1), 1E-10);
assertEquals("chi-square p-value", 0.002512096, testStatistic.chiSquareTest(expected1, observed1), 1E-9);
assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.003));
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.002));
testStatistic.chiSquareTest(expected1, observed1, 95);
fail("alpha out of range, IllegalArgumentException expected");
long[] tooShortObs = { 0 };
double[] tooShortEx = { 1 };
testStatistic.chiSquare(tooShortEx, tooShortObs);
fail("arguments too short, IllegalArgumentException expected");
long[] unMatchedObs = { 0, 1, 2, 3 };
double[] unMatchedEx = { 1, 1, 2 };
testStatistic.chiSquare(unMatchedEx, unMatchedObs);
fail("arrays have different lengths, IllegalArgumentException expected");
expected[0] = 0;
testStatistic.chiSquareTest(expected, observed, .01);
fail("bad expected count, IllegalArgumentException expected");
expected[0] = 1;
observed[0] = -1;
testStatistic.chiSquareTest(expected, observed, .01);
fail("bad expected count, IllegalArgumentException expected");
public void testChiSquareIndependence() throws Exception {
long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};
assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);
assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);
assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));    
long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };
assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);
assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1)); 
long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};
testStatistic.chiSquare(counts3);
fail("Expecting IllegalArgumentException");
long[][] counts4 = {{40, 22, 43}};
testStatistic.chiSquare(counts4);
fail("Expecting IllegalArgumentException");
long[][] counts5 = {{40}, {40}, {30}, {10}};
testStatistic.chiSquare(counts5);
fail("Expecting IllegalArgumentException");
long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };
testStatistic.chiSquare(counts6);
fail("Expecting IllegalArgumentException");
testStatistic.chiSquareTest(counts, 0);
fail("Expecting IllegalArgumentException");
public void testChiSquareLargeTestStatistic() throws Exception {
double[] exp = new double[] {
3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 
232921.0, 437665.75
long[] obs = new long[] {
2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =
new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); 
double cst = csti.chiSquareTest(exp, obs); 
assertEquals("chi-square p-value", 0.0, cst, 1E-3);
assertEquals( "chi-square test statistic", 
3624883.342907764, testStatistic.chiSquare(exp, obs), 1E-9);
public void testChiSquareZeroCount() throws Exception {
long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};
assertEquals( "chi-square test statistic", 9.67444662263,
testStatistic.chiSquare(counts), 1E-9);
assertEquals("chi-square p-value", 0.0462835770603,
testStatistic.chiSquareTest(counts), 1E-9);       
public void testChiSquareDataSetsComparisonEqualCounts()
throws Exception {
long[] observed1 = {10, 12, 12, 10};
long[] observed2 = {5, 15, 14, 10};    
assertEquals("chi-square p value", 0.541096, 
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2), 1E-6);
assertEquals("chi-square test statistic", 2.153846,
testStatistic.chiSquareDataSetsComparison(
observed1, observed2), 1E-6);
assertFalse("chi-square test result", 
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2, 0.4));
public void testChiSquareDataSetsComparisonUnEqualCounts()
throws Exception {
long[] observed1 = {10, 12, 12, 10, 15};
long[] observed2 = {15, 10, 10, 15, 5};    
assertEquals("chi-square p value", 0.124115, 
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2), 1E-6);
assertEquals("chi-square test statistic", 7.232189,
testStatistic.chiSquareDataSetsComparison(
observed1, observed2), 1E-6);
assertTrue("chi-square test result", 
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2, 0.13));
assertFalse("chi-square test result", 
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2, 0.12));
public void testChiSquareDataSetsComparisonBadCounts()
throws Exception {
long[] observed1 = {10, -1, 12, 10, 15};
long[] observed2 = {15, 10, 10, 15, 5};
testStatistic.chiSquareTestDataSetsComparison(
observed1, observed2);
fail("Expecting IllegalArgumentException - negative count");
long[] observed3 = {10, 0, 12, 10, 15};
long[] observed4 = {15, 0, 10, 15, 5};
testStatistic.chiSquareTestDataSetsComparison(
observed3, observed4);
fail("Expecting IllegalArgumentException - double 0's");
long[] observed5 = {10, 10, 12, 10, 15};
long[] observed6 = {0, 0, 0, 0, 0};
testStatistic.chiSquareTestDataSetsComparison(
observed5, observed6);
fail("Expecting IllegalArgumentException - vanishing counts");
package org.apache.commons.math.stat.inference;
public class TTestFactoryTest extends TTestTest {
public TTestFactoryTest(String name) {
super(name);
public void setUp() {
super.setUp();
testStatistic = TestUtils.getTTest();
public static Test suite() {
TestSuite suite = new TestSuite(TTestFactoryTest.class);
suite.setName("TTestFactory Tests");
return suite;
package org.apache.commons.math.stat.inference;
public class TestUtilsTest extends TestCase {
public TestUtilsTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(TestUtilsTest.class);
suite.setName("TestUtils Tests");
return suite;
public void testChiSquare() throws Exception {
long[] observed = {10, 9, 11};
double[] expected = {10, 10, 10};
assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);
assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);
long[] observed1 = { 500, 623, 72, 70, 31 };
double[] expected1 = { 485, 541, 82, 61, 37 };
assertEquals( "chi-square test statistic", 16.4131070362, TestUtils.chiSquare(expected1, observed1), 1E-10);
assertEquals("chi-square p-value", 0.002512096, TestUtils.chiSquareTest(expected1, observed1), 1E-9);
assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.003));
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.002));
TestUtils.chiSquareTest(expected1, observed1, 95);
fail("alpha out of range, IllegalArgumentException expected");
long[] tooShortObs = { 0 };
double[] tooShortEx = { 1 };
TestUtils.chiSquare(tooShortEx, tooShortObs);
fail("arguments too short, IllegalArgumentException expected");
long[] unMatchedObs = { 0, 1, 2, 3 };
double[] unMatchedEx = { 1, 1, 2 };
TestUtils.chiSquare(unMatchedEx, unMatchedObs);
fail("arrays have different lengths, IllegalArgumentException expected");
expected[0] = 0;
TestUtils.chiSquareTest(expected, observed, .01);
fail("bad expected count, IllegalArgumentException expected");
expected[0] = 1;
observed[0] = -1;
TestUtils.chiSquareTest(expected, observed, .01);
fail("bad expected count, IllegalArgumentException expected");
public void testChiSquareIndependence() throws Exception {
long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};
assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);
assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);
assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));    
long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };
assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);
assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1)); 
long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};
TestUtils.chiSquare(counts3);
fail("Expecting IllegalArgumentException");
long[][] counts4 = {{40, 22, 43}};
TestUtils.chiSquare(counts4);
fail("Expecting IllegalArgumentException");
long[][] counts5 = {{40}, {40}, {30}, {10}};
TestUtils.chiSquare(counts5);
fail("Expecting IllegalArgumentException");
long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };
TestUtils.chiSquare(counts6);
fail("Expecting IllegalArgumentException");
TestUtils.chiSquareTest(counts, 0);
fail("Expecting IllegalArgumentException");
public void testChiSquareLargeTestStatistic() throws Exception {
double[] exp = new double[] {
3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 
232921.0, 437665.75
long[] obs = new long[] {
2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =
new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); 
double cst = csti.chiSquareTest(exp, obs); 
assertEquals("chi-square p-value", 0.0, cst, 1E-3);
assertEquals( "chi-square test statistic", 
3624883.342907764, TestUtils.chiSquare(exp, obs), 1E-9);
public void testChiSquareZeroCount() throws Exception {
long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};
assertEquals( "chi-square test statistic", 9.67444662263,
TestUtils.chiSquare(counts), 1E-9);
assertEquals("chi-square p-value", 0.0462835770603,
TestUtils.chiSquareTest(counts), 1E-9);       
private double[] tooShortObs = { 1.0 };
private double[] emptyObs = {};
private SummaryStatistics emptyStats = SummaryStatistics.newInstance();  
public void testOneSampleT() throws Exception {
double[] observed =
double mu = 100.0;
SummaryStatistics sampleStats = null;
sampleStats = SummaryStatistics.newInstance();
for (int i = 0; i < observed.length; i++) {
sampleStats.addValue(observed[i]);
assertEquals("t statistic",  -2.81976445346,
TestUtils.t(mu, observed), 10E-10);
assertEquals("t statistic",  -2.81976445346,
TestUtils.t(mu, sampleStats), 10E-10);
assertEquals("p value", 0.0136390585873,
TestUtils.tTest(mu, observed), 10E-10);
assertEquals("p value", 0.0136390585873,
TestUtils.tTest(mu, sampleStats), 10E-10);
TestUtils.t(mu, (double[]) null);
fail("arguments too short, IllegalArgumentException expected");
TestUtils.t(mu, (SummaryStatistics) null);
fail("arguments too short, IllegalArgumentException expected");
TestUtils.t(mu, emptyObs);
fail("arguments too short, IllegalArgumentException expected");
TestUtils.t(mu, emptyStats);
fail("arguments too short, IllegalArgumentException expected");
TestUtils.t(mu, tooShortObs);
fail("insufficient data to compute t statistic, IllegalArgumentException expected");
TestUtils.tTest(mu, tooShortObs);
fail("insufficient data to perform t test, IllegalArgumentException expected");
TestUtils.t(mu, (SummaryStatistics) null);
fail("insufficient data to compute t statistic, IllegalArgumentException expected");
TestUtils.tTest(mu, (SummaryStatistics) null);
fail("insufficient data to perform t test, IllegalArgumentException expected");
public void testOneSampleTTest() throws Exception {
double[] oneSidedP =
SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();    
for (int i = 0; i < oneSidedP.length; i++) {
oneSidedPStats.addValue(oneSidedP[i]);
assertEquals("one sample t stat", 3.86485535541, 
TestUtils.t(0d, oneSidedP), 10E-10);
assertEquals("one sample t stat", 3.86485535541, 
TestUtils.t(0d, oneSidedPStats),1E-10);
assertEquals("one sample p value", 0.000521637019637,
TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);
assertEquals("one sample p value", 0.000521637019637,
TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);
assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));
assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));
assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));
assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));
TestUtils.tTest(0d, oneSidedP, 95);
fail("alpha out of range, IllegalArgumentException expected");
TestUtils.tTest(0d, oneSidedPStats, 95);
fail("alpha out of range, IllegalArgumentException expected");
public void testTwoSampleTHeterscedastic() throws Exception {
double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };
double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };
SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();  
for (int i = 0; i < sample1.length; i++) {
sampleStats1.addValue(sample1[i]);
SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();    
for (int i = 0; i < sample2.length; i++) {
sampleStats2.addValue(sample2[i]);
assertEquals("two sample heteroscedastic t stat", 1.60371728768, 
TestUtils.t(sample1, sample2), 1E-10);
assertEquals("two sample heteroscedastic t stat", 1.60371728768, 
TestUtils.t(sampleStats1, sampleStats2), 1E-10);
assertEquals("two sample heteroscedastic p value", 0.128839369622, 
TestUtils.tTest(sample1, sample2), 1E-10);
assertEquals("two sample heteroscedastic p value", 0.128839369622, 
TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);     
assertTrue("two sample heteroscedastic t-test reject", 
TestUtils.tTest(sample1, sample2, 0.2));
assertTrue("two sample heteroscedastic t-test reject", 
TestUtils.tTest(sampleStats1, sampleStats2, 0.2));
assertTrue("two sample heteroscedastic t-test accept", 
!TestUtils.tTest(sample1, sample2, 0.1));
assertTrue("two sample heteroscedastic t-test accept", 
!TestUtils.tTest(sampleStats1, sampleStats2, 0.1));
TestUtils.tTest(sample1, sample2, .95);
fail("alpha out of range, IllegalArgumentException expected");
TestUtils.tTest(sampleStats1, sampleStats2, .95);
fail("alpha out of range, IllegalArgumentException expected");
TestUtils.tTest(sample1, tooShortObs, .01);
fail("insufficient data, IllegalArgumentException expected");
TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);
fail("insufficient data, IllegalArgumentException expected");
TestUtils.tTest(sample1, tooShortObs);
fail("insufficient data, IllegalArgumentException expected");
TestUtils.tTest(sampleStats1, (SummaryStatistics) null);
fail("insufficient data, IllegalArgumentException expected");
TestUtils.t(sample1, tooShortObs);
fail("insufficient data, IllegalArgumentException expected");
TestUtils.t(sampleStats1, (SummaryStatistics) null);
fail("insufficient data, IllegalArgumentException expected");
public void testTwoSampleTHomoscedastic() throws Exception {
double[] sample1 ={2, 4, 6, 8, 10, 97};
double[] sample2 = {4, 6, 8, 10, 16};
SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();  
for (int i = 0; i < sample1.length; i++) {
sampleStats1.addValue(sample1[i]);
SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();    
for (int i = 0; i < sample2.length; i++) {
sampleStats2.addValue(sample2[i]);
assertEquals("two sample homoscedastic t stat", 0.73096310086, 
TestUtils.homoscedasticT(sample1, sample2), 10E-11);
assertEquals("two sample homoscedastic p value", 0.4833963785, 
TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     
assertTrue("two sample homoscedastic t-test reject", 
TestUtils.homoscedasticTTest(sample1, sample2, 0.49));
assertTrue("two sample homoscedastic t-test accept", 
!TestUtils.homoscedasticTTest(sample1, sample2, 0.48));
public void testSmallSamples() throws Exception {
double[] sample1 = {1d, 3d};
double[] sample2 = {4d, 5d};        
assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),
1E-10);
assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),
1E-10);
public void testPaired() throws Exception {
double[] sample1 = {1d, 3d, 5d, 7d};
double[] sample2 = {0d, 6d, 11d, 2d};
double[] sample3 = {5d, 7d, 8d, 10d};
assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);
assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);
assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);
assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));
assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    
package org.apache.commons.math.stat.inference;
public class TTestTest extends TestCase {
protected TTest testStatistic = new TTestImpl();
private double[] tooShortObs = { 1.0 };
private double[] emptyObs = {};
private SummaryStatistics emptyStats = SummaryStatistics.newInstance();  
SummaryStatistics tooShortStats = null;  
public TTestTest(String name) {
super(name);
public void setUp() {
tooShortStats = SummaryStatistics.newInstance();
tooShortStats.addValue(0d);
public static Test suite() {
TestSuite suite = new TestSuite(TTestTest.class);
suite.setName("TestStatistic Tests");
return suite;
public void testOneSampleT() throws Exception {
double[] observed =
double mu = 100.0;
SummaryStatistics sampleStats = null;
sampleStats = SummaryStatistics.newInstance();
for (int i = 0; i < observed.length; i++) {
sampleStats.addValue(observed[i]);
assertEquals("t statistic",  -2.81976445346,
testStatistic.t(mu, observed), 10E-10);
assertEquals("t statistic",  -2.81976445346,
testStatistic.t(mu, sampleStats), 10E-10);
assertEquals("p value", 0.0136390585873,
testStatistic.tTest(mu, observed), 10E-10);
assertEquals("p value", 0.0136390585873,
testStatistic.tTest(mu, sampleStats), 10E-10);
testStatistic.t(mu, (double[]) null);
fail("arguments too short, IllegalArgumentException expected");
testStatistic.t(mu, (SummaryStatistics) null);
fail("arguments too short, IllegalArgumentException expected");
testStatistic.t(mu, emptyObs);
fail("arguments too short, IllegalArgumentException expected");
testStatistic.t(mu, emptyStats);
fail("arguments too short, IllegalArgumentException expected");
testStatistic.t(mu, tooShortObs);
fail("insufficient data to compute t statistic, IllegalArgumentException expected");
testStatistic.tTest(mu, tooShortObs);
fail("insufficient data to perform t test, IllegalArgumentException expected");
testStatistic.t(mu, tooShortStats);
fail("insufficient data to compute t statistic, IllegalArgumentException expected");
testStatistic.tTest(mu, tooShortStats);
fail("insufficient data to perform t test, IllegalArgumentException expected");
public void testOneSampleTTest() throws Exception {
double[] oneSidedP =
SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();    
for (int i = 0; i < oneSidedP.length; i++) {
oneSidedPStats.addValue(oneSidedP[i]);
assertEquals("one sample t stat", 3.86485535541, 
testStatistic.t(0d, oneSidedP), 10E-10);
assertEquals("one sample t stat", 3.86485535541, 
testStatistic.t(0d, oneSidedPStats),1E-10);
assertEquals("one sample p value", 0.000521637019637,
testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);
assertEquals("one sample p value", 0.000521637019637,
testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);
assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));
assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));
assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));
assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));
testStatistic.tTest(0d, oneSidedP, 95);
fail("alpha out of range, IllegalArgumentException expected");
testStatistic.tTest(0d, oneSidedPStats, 95);
fail("alpha out of range, IllegalArgumentException expected");
public void testTwoSampleTHeterscedastic() throws Exception {
double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };
double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };
SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();  
for (int i = 0; i < sample1.length; i++) {
sampleStats1.addValue(sample1[i]);
SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();    
for (int i = 0; i < sample2.length; i++) {
sampleStats2.addValue(sample2[i]);
assertEquals("two sample heteroscedastic t stat", 1.60371728768, 
testStatistic.t(sample1, sample2), 1E-10);
assertEquals("two sample heteroscedastic t stat", 1.60371728768, 
testStatistic.t(sampleStats1, sampleStats2), 1E-10);
assertEquals("two sample heteroscedastic p value", 0.128839369622, 
testStatistic.tTest(sample1, sample2), 1E-10);
assertEquals("two sample heteroscedastic p value", 0.128839369622, 
testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);     
assertTrue("two sample heteroscedastic t-test reject", 
testStatistic.tTest(sample1, sample2, 0.2));
assertTrue("two sample heteroscedastic t-test reject", 
testStatistic.tTest(sampleStats1, sampleStats2, 0.2));
assertTrue("two sample heteroscedastic t-test accept", 
!testStatistic.tTest(sample1, sample2, 0.1));
assertTrue("two sample heteroscedastic t-test accept", 
!testStatistic.tTest(sampleStats1, sampleStats2, 0.1));
testStatistic.tTest(sample1, sample2, .95);
fail("alpha out of range, IllegalArgumentException expected");
testStatistic.tTest(sampleStats1, sampleStats2, .95);
fail("alpha out of range, IllegalArgumentException expected");
testStatistic.tTest(sample1, tooShortObs, .01);
fail("insufficient data, IllegalArgumentException expected");
testStatistic.tTest(sampleStats1, tooShortStats, .01);
fail("insufficient data, IllegalArgumentException expected");
testStatistic.tTest(sample1, tooShortObs);
fail("insufficient data, IllegalArgumentException expected");
testStatistic.tTest(sampleStats1, tooShortStats);
fail("insufficient data, IllegalArgumentException expected");
testStatistic.t(sample1, tooShortObs);
fail("insufficient data, IllegalArgumentException expected");
testStatistic.t(sampleStats1, tooShortStats);
fail("insufficient data, IllegalArgumentException expected");
public void testTwoSampleTHomoscedastic() throws Exception {
double[] sample1 ={2, 4, 6, 8, 10, 97};
double[] sample2 = {4, 6, 8, 10, 16};
SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();  
for (int i = 0; i < sample1.length; i++) {
sampleStats1.addValue(sample1[i]);
SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();    
for (int i = 0; i < sample2.length; i++) {
sampleStats2.addValue(sample2[i]);
assertEquals("two sample homoscedastic t stat", 0.73096310086, 
testStatistic.homoscedasticT(sample1, sample2), 10E-11);
assertEquals("two sample homoscedastic p value", 0.4833963785, 
testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     
assertTrue("two sample homoscedastic t-test reject", 
testStatistic.homoscedasticTTest(sample1, sample2, 0.49));
assertTrue("two sample homoscedastic t-test accept", 
!testStatistic.homoscedasticTTest(sample1, sample2, 0.48));
public void testSmallSamples() throws Exception {
double[] sample1 = {1d, 3d};
double[] sample2 = {4d, 5d};        
assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),
1E-10);
assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),
1E-10);
public void testPaired() throws Exception {
double[] sample1 = {1d, 3d, 5d, 7d};
double[] sample2 = {0d, 6d, 11d, 2d};
double[] sample3 = {5d, 7d, 8d, 10d};
assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);
assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);
assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);
assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));
assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    
package org.apache.commons.math.stat.inference;
public class ChiSquareFactoryTest extends ChiSquareTestTest {
public ChiSquareFactoryTest(String name) {
super(name);
public void setUp() {
super.setUp();
testStatistic = TestUtils.getUnknownDistributionChiSquareTest();
public static Test suite() {
TestSuite suite = new TestSuite(ChiSquareFactoryTest.class);
suite.setName("ChiSquareTestFactory Tests");
return suite;
package org.apache.commons.math.stat.descriptive;
public final class SummaryStatisticsImplTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
protected SummaryStatistics u = null;
public SummaryStatisticsImplTest(String name) {
super(name);
public void setUp() {  
u = SummaryStatistics.newInstance();
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
suite.setName("Frequency Tests");
return suite;
public void testStats() {
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {            
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {  
StatisticalSummary summary = u.getSummary();
verifySummary(summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(summary);     
public void testSerialization() {
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(summary);
public void testEqualsAndHashCode() {
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = SummaryStatistics.newInstance();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(4d);
t.addValue(2d);
t.addValue(3d);
t.addValue(1d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public abstract class UnivariateStatisticAbstractTest extends TestCase {
protected double mean = 12.404545454545455d;
protected double geoMean = 12.070589161633011d;
protected double var = 10.00235930735931d;
protected double std = Math.sqrt(var);
protected double skew = 1.437423729196190d;
protected double kurt = 2.377191264804700d;
protected double min = 8.2d;
protected double max = 21d;
protected double median = 12d;
protected double percentile5 = 8.29d;
protected double percentile95 = 20.82d;
protected double product = 628096400563833396009676.9200400128d;
protected double sumLog = 54.7969806116451507d;
protected double sumSq = 3595.250d;
protected double sum = 272.90d;
protected double secondMoment = 210.04954545454547d;
protected double thirdMoment = 868.0906859504136;
protected double fourthMoment = 9244.080993773481;
protected double tolerance = 10E-12;
protected double[] testArray =
14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,
9, 12.3 };
public UnivariateStatisticAbstractTest(String name) {
super(name);
public abstract UnivariateStatistic getUnivariateStatistic();
public abstract double expectedValue();
public double getTolerance() {
return tolerance;
public void testEvaluation() throws Exception {   
assertEquals(
expectedValue(),
getUnivariateStatistic().evaluate(testArray),
getTolerance());
package org.apache.commons.math.stat.descriptive;
public final class MixedListUnivariateImplTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
private TransformerMap transformers = new TransformerMap();
public MixedListUnivariateImplTest(String name) {
super(name);
transformers = new TransformerMap();
transformers.putTransformer(Foo.class, new NumberTransformer() {
public double transform(Object o) {
return Double.parseDouble(((Foo) o).heresFoo());
transformers.putTransformer(Bar.class, new NumberTransformer() {
public double transform(Object o) {
return Double.parseDouble(((Bar) o).heresBar());
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);
suite.setName("Mixed List Tests");
return suite;
public void testStats() {
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);
assertEquals("total count", 0, u.getN(), tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N", n, u.getN(), tolerance);
assertEquals("sum", sum, u.getSum(), tolerance);
assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);
assertEquals("var", var, u.getVariance(), tolerance);
assertEquals("std", std, u.getStandardDeviation(), tolerance);
assertEquals("mean", mean, u.getMean(), tolerance);
assertEquals("min", min, u.getMin(), tolerance);
assertEquals("max", max, u.getMax(), tolerance);
u.clear();
assertEquals("total count", 0, u.getN(), tolerance);
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
assertTrue(
"Mean of n = 0 set should be NaN",
Double.isNaN(u.getMean()));
assertTrue(
"Standard Deviation of n = 0 set should be NaN",
Double.isNaN(u.getStandardDeviation()));
assertTrue(
"Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance()));
u.addValue(one);
assertTrue(
"Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,
u.getMean() == one);
assertTrue(
"StdDev of n = 1 set should be zero, instead it is: "
+ u.getStandardDeviation(),
u.getStandardDeviation() == 0);
assertTrue(
"Variance of n = 1 set should be zero",
u.getVariance() == 0);
public void testSkewAndKurtosis() {
ListUnivariateImpl u =
new ListUnivariateImpl(new ArrayList(), transformers);
u.addObject("12.5");
u.addObject(new Integer(12));
u.addObject("11.8");
u.addObject("14.2");
u.addObject(new Foo());
u.addObject("14.5");
u.addObject(new Long(21));
u.addObject("8.2");
u.addObject("10.3");
u.addObject("11.3");
u.addObject(new Float(14.1));
u.addObject("9.9");
u.addObject("12.2");
u.addObject(new Bar());
u.addObject("12.1");
u.addObject("11");
u.addObject(new Double(19.8));
u.addObject("11");
u.addObject("10");
u.addObject("8.8");
u.addObject("9");
u.addObject("12.3");
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testProductAndGeometricMean() throws Exception {
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
u.setWindowSize(10);
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
assertEquals(
"Geometric mean not expected",
2.213364,
u.getGeometricMean(),
0.00001);
for (int i = 0; i < 10; i++) {
u.addValue(i + 2);
assertEquals(
"Geometric mean not expected",
5.755931,
u.getGeometricMean(),
0.00001);
public static final class Foo {
public String heresFoo() {
return "14.9";
public static final class Bar {
public String heresBar() {
return "12.0";
package org.apache.commons.math.stat.descriptive.moment;
public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {
protected SecondMoment stat;
public SecondMomentTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new SecondMoment();
public double expectedValue() {
return this.secondMoment;
package org.apache.commons.math.stat.descriptive.moment;
public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{
protected StandardDeviation stat;
public StandardDeviationTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new StandardDeviation();
public static Test suite() {
TestSuite suite = new TestSuite(StandardDeviationTest.class);
suite.setName("StandardDeviation Tests");
return suite;
public double expectedValue() {
return this.std;
public void testNaN() {
StandardDeviation std = new StandardDeviation();
assertTrue(Double.isNaN(std.getResult()));
std.increment(1d);
assertEquals(0d, std.getResult(), 0);
public void testPopulation() {
double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};
double sigma = populationStandardDeviation(values);
SecondMoment m = new SecondMoment();
m.evaluate(values);  // side effect is to add values
StandardDeviation s1 = new StandardDeviation();
s1.setBiasCorrected(false);
assertEquals(sigma, s1.evaluate(values), 1E-14);
s1.incrementAll(values);
assertEquals(sigma, s1.getResult(), 1E-14);
s1 = new StandardDeviation(false, m);
assertEquals(sigma, s1.getResult(), 1E-14);     
s1 = new StandardDeviation(false);
assertEquals(sigma, s1.evaluate(values), 1E-14);
s1.incrementAll(values);
assertEquals(sigma, s1.getResult(), 1E-14);     
protected double populationStandardDeviation(double[] v) {
double mean = new Mean().evaluate(v);
double sum = 0;
for (int i = 0; i < v.length; i++) {
sum += (v[i] - mean) * (v[i] - mean); 
return Math.sqrt(sum / (double) v.length);
package org.apache.commons.math.stat.descriptive.moment;
public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{
protected Skewness stat;
public SkewnessTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new Skewness();
public static Test suite() {
TestSuite suite = new TestSuite(SkewnessTest.class);
suite.setName("Skewness Tests");
return suite;
public double expectedValue() {
return this.skew;
public void testNaN() {
Skewness skew = new Skewness();
assertTrue(Double.isNaN(skew.getResult()));
skew.increment(1d);
assertTrue(Double.isNaN(skew.getResult()));
skew.increment(1d);
assertTrue(Double.isNaN(skew.getResult()));
skew.increment(1d);
assertFalse(Double.isNaN(skew.getResult()));      
package org.apache.commons.math.stat.descriptive.moment;
public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{
protected GeometricMean stat;
public GeometricMeanTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(GeometricMeanTest.class);
suite.setName("Mean  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new GeometricMean();
public double expectedValue() {
return this.geoMean;
public void testSpecialValues() {
GeometricMean mean = new GeometricMean();
assertTrue(Double.isNaN(mean.getResult()));
mean.increment(1d);
assertFalse(Double.isNaN(mean.getResult()));
mean.increment(0d);
assertEquals(0d, mean.getResult(), 0);
mean.increment(Double.POSITIVE_INFINITY);
assertTrue(Double.isNaN(mean.getResult()));
mean.clear();
assertTrue(Double.isNaN(mean.getResult()));
mean.increment(Double.POSITIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);
mean.increment(-2d);
assertTrue(Double.isNaN(mean.getResult()));
package org.apache.commons.math.stat.descriptive.moment;
public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{
protected FirstMoment stat;
public FirstMomentTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new FirstMoment();
public double expectedValue() {
return this.mean;
package org.apache.commons.math.stat.descriptive.moment;
public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{
protected Kurtosis stat;
public KurtosisTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(KurtosisTest.class);
suite.setName("Kurtosis  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Kurtosis();
public double expectedValue() {
return this.kurt;
public void testNaN() {
Kurtosis kurt = new Kurtosis();
assertTrue(Double.isNaN(kurt.getResult()));
kurt.increment(1d);
assertTrue(Double.isNaN(kurt.getResult()));
kurt.increment(1d);
assertTrue(Double.isNaN(kurt.getResult()));
kurt.increment(1d);
assertTrue(Double.isNaN(kurt.getResult()));
kurt.increment(1d);
assertFalse(Double.isNaN(kurt.getResult()));      
package org.apache.commons.math.stat.descriptive.moment;
public class VectorialMeanTest
extends TestCase {
public VectorialMeanTest(String name) {
super(name);
points = null;
public void testMismatch() {
new VectorialMean(8).increment(new double[5]);
fail("an exception should have been thrown");
assertEquals(5, dme.getDimension1());
assertEquals(8, dme.getDimension2());
fail("wrong exception type caught: " + e.getClass().getName());
public void testSimplistic() throws DimensionMismatchException {
VectorialMean stat = new VectorialMean(2);
stat.increment(new double[] {-1.0,  1.0});
stat.increment(new double[] { 1.0, -1.0});
double[] mean = stat.getResult();
assertEquals(0.0, mean[0], 1.0e-12);
assertEquals(0.0, mean[1], 1.0e-12);
public void testBasicStats() throws DimensionMismatchException {
VectorialMean stat = new VectorialMean(points[0].length);
for (int i = 0; i < points.length; ++i) {
stat.increment(points[i]);
assertEquals(points.length, stat.getN());
double[] mean = stat.getResult();
double[]   refMean = new double[] { 1.78, 1.62,  3.12};
for (int i = 0; i < mean.length; ++i) {
assertEquals(refMean[i], mean[i], 1.0e-12);
public void setUp() {
points = new double[][] {
public void tearDown() {
points = null;
public static Test suite() {
return new TestSuite(VectorialMeanTest.class);
private double [][] points;
package org.apache.commons.math.stat.descriptive.moment;
public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{
protected Variance stat;
public VarianceTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new Variance();
public static Test suite() {
TestSuite suite = new TestSuite(VarianceTest.class);
suite.setName("Variance Tests");
return suite;
public double expectedValue() {
return this.var;
public void testNaN() {
StandardDeviation std = new StandardDeviation();
assertTrue(Double.isNaN(std.getResult()));
std.increment(1d);
assertEquals(0d, std.getResult(), 0);
public void testPopulation() {
double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};
SecondMoment m = new SecondMoment();
m.evaluate(values);  // side effect is to add values
Variance v1 = new Variance();
v1.setBiasCorrected(false);
assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);
v1.incrementAll(values);
assertEquals(populationVariance(values), v1.getResult(), 1E-14);
v1 = new Variance(false, m);
assertEquals(populationVariance(values), v1.getResult(), 1E-14);     
v1 = new Variance(false);
assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);
v1.incrementAll(values);
assertEquals(populationVariance(values), v1.getResult(), 1E-14);     
protected double populationVariance(double[] v) {
double mean = new Mean().evaluate(v);
double sum = 0;
for (int i = 0; i < v.length; i++) {
sum += (v[i] - mean) * (v[i] - mean); 
return sum / (double) v.length;
package org.apache.commons.math.stat.descriptive.moment;
public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{
protected FourthMoment stat;
public FourthMomentTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new FourthMoment();
public double expectedValue() {
return this.fourthMoment;
package org.apache.commons.math.stat.descriptive.moment;
public class MeanTest extends StorelessUnivariateStatisticAbstractTest{
protected Mean stat;
public MeanTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(MeanTest.class);
suite.setName("Mean  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Mean();
public double expectedValue() {
return this.mean;
public void testSmallSamples() {
Mean mean = new Mean();
assertTrue(Double.isNaN(mean.getResult()));
mean.increment(1d);
assertEquals(1d, mean.getResult(), 0);
package org.apache.commons.math.stat.descriptive.moment;
public class VectorialCovarianceTest
extends TestCase {
public VectorialCovarianceTest(String name) {
super(name);
points = null;
public void testMismatch() {
new VectorialCovariance(8).increment(new double[5]);
fail("an exception should have been thrown");
assertEquals(5, dme.getDimension1());
assertEquals(8, dme.getDimension2());
fail("wrong exception type caught: " + e.getClass().getName());
public void testSimplistic() throws DimensionMismatchException {
VectorialCovariance stat = new VectorialCovariance(2);
stat.increment(new double[] {-1.0,  1.0});
stat.increment(new double[] { 1.0, -1.0});
RealMatrix c = stat.getResult();
assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);
assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);
assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);
public void testBasicStats() throws DimensionMismatchException {
VectorialCovariance stat = new VectorialCovariance(points[0].length);
for (int i = 0; i < points.length; ++i) {
stat.increment(points[i]);
assertEquals(points.length, stat.getN());
RealMatrix c = stat.getResult();
double[][] refC    = new double[][] {
for (int i = 0; i < c.getRowDimension(); ++i) {
for (int j = 0; j <= i; ++j) {
assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);
public void setUp() {
points = new double[][] {
public void tearDown() {
points = null;
public static Test suite() {
return new TestSuite(VectorialCovarianceTest.class);
private double [][] points;
package org.apache.commons.math.stat.descriptive.moment;
public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{
protected ThirdMoment stat;
public ThirdMomentTest(String name) {
super(name);
public UnivariateStatistic getUnivariateStatistic() {
return new ThirdMoment();
public double expectedValue() {
return this.thirdMoment;
package org.apache.commons.math.stat.descriptive;
public class AbstractUnivariateStatisticTest extends TestCase {
public AbstractUnivariateStatisticTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);
suite.setName("AbstractUnivariateStatistic Tests");
return suite;
protected double[] testArray = {0, 1, 2, 3, 4, 5};
protected double[] nullArray = null;
protected double[] singletonArray = {0};
protected Mean testStatistic = new Mean();
public void testTestPositive() {
for (int j = 0; j < 6; j++) {
for (int i = 1; i < (7 - j); i++) {
assertTrue(testStatistic.test(testArray, 0, i));
assertTrue(testStatistic.test(singletonArray, 0, 1));
public void testTestNegative() {
assertFalse(testStatistic.test(singletonArray, 0, 0));
assertFalse(testStatistic.test(testArray, 0, 0));
testStatistic.test(singletonArray, 2, 1);  // start past end
fail("Expecting IllegalArgumentException");
testStatistic.test(testArray, 0, 7);  // end past end
fail("Expecting IllegalArgumentException");
testStatistic.test(testArray, -1, 1);  // start negative
fail("Expecting IllegalArgumentException");
testStatistic.test(testArray, 0, -1);  // length negative
fail("Expecting IllegalArgumentException");
testStatistic.test(nullArray, 0, 1);  // null array
fail("Expecting IllegalArgumentException");
package org.apache.commons.math.stat.descriptive;
public abstract class StorelessUnivariateStatisticAbstractTest
extends UnivariateStatisticAbstractTest {
public StorelessUnivariateStatisticAbstractTest(String name) {
super(name);
protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};
public abstract UnivariateStatistic getUnivariateStatistic();
public abstract double expectedValue();
public void testIncrementation() throws Exception {
StorelessUnivariateStatistic statistic =
(StorelessUnivariateStatistic) getUnivariateStatistic();
statistic.clear();
for (int i = 0; i < testArray.length; i++) {
statistic.increment(testArray[i]);
assertEquals(expectedValue(), statistic.getResult(), getTolerance());
assertEquals(testArray.length, statistic.getN());
statistic.clear();
assertTrue(Double.isNaN(statistic.getResult()));
assertEquals(0, statistic.getN());
public void testSerialization() throws Exception {
StorelessUnivariateStatistic statistic =
(StorelessUnivariateStatistic) getUnivariateStatistic();
TestUtils.checkSerializedEquality(statistic);
statistic.clear();
for (int i = 0; i < testArray.length; i++) {
statistic.increment(testArray[i]);
if(i % 5 == 0)
statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); 
TestUtils.checkSerializedEquality(statistic);
assertEquals(expectedValue(), statistic.getResult(), getTolerance());
statistic.clear();
assertTrue(Double.isNaN(statistic.getResult()));
public void testEqualsAndHashCode() {
StorelessUnivariateStatistic statistic =
(StorelessUnivariateStatistic) getUnivariateStatistic();
StorelessUnivariateStatistic statistic2 = null;
assertTrue("non-null, compared to null", !statistic.equals(statistic2));
assertTrue("reflexive, non-null", statistic.equals(statistic));
int emptyHash = statistic.hashCode();
statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();
assertTrue("empty stats should be equal", statistic.equals(statistic2));
assertEquals("empty stats should have the same hashcode", 
emptyHash, statistic2.hashCode());
statistic.increment(1d);
assertTrue("reflexive, non-empty", statistic.equals(statistic));
assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));
assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));
assertTrue("non-empty stat should have different hashcode from empty stat",
statistic.hashCode() != emptyHash);
statistic2.increment(1d);
assertTrue("stats with same data should be equal", statistic.equals(statistic2));
assertEquals("stats with same data should have the same hashcode", 
statistic.hashCode(), statistic2.hashCode());
statistic.increment(Double.POSITIVE_INFINITY);
assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));
assertTrue("stats with different n's should have different hashcodes",
statistic.hashCode() != statistic2.hashCode());
statistic2.increment(Double.POSITIVE_INFINITY);
assertTrue("stats with same data should be equal", statistic.equals(statistic2));
assertEquals("stats with same data should have the same hashcode", 
statistic.hashCode(), statistic2.hashCode()); 
statistic.clear();
statistic2.clear();
assertTrue("cleared stats should be equal", statistic.equals(statistic2));
assertEquals("cleared stats should have thashcode of empty stat", 
emptyHash, statistic2.hashCode());
assertEquals("cleared stats should have thashcode of empty stat", 
emptyHash, statistic.hashCode());
public void testMomentSmallSamples() {
UnivariateStatistic stat = getUnivariateStatistic();
if (stat instanceof SecondMoment) {
SecondMoment moment = (SecondMoment) getUnivariateStatistic();
assertTrue(Double.isNaN(moment.getResult()));
moment.increment(1d);
assertEquals(0d, moment.getResult(), 0);
public void testConsistency() {
StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();
stat.incrementAll(testArray);
assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());
for (int i = 0; i < smallSamples.length; i++) {
stat.clear();
for (int j =0; j < smallSamples[i].length; j++) {
stat.increment(smallSamples[i][j]);
TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());
package org.apache.commons.math.stat.descriptive;
public class InteractionTest extends TestCase {
protected double mean = 12.40454545454550;
protected double var = 10.00235930735930;
protected double skew = 1.437423729196190;
protected double kurt = 2.377191264804700;
protected double tolerance = 10E-12;
protected double[] testArray =
12.5,
12,
11.8,
14.2,
14.9,
14.5,
21,
8.2,
10.3,
11.3,
14.1,
9.9,
12.2,
12,
12.1,
11,
19.8,
11,
10,
8.8,
9,
12.3 };
public InteractionTest(String name) {
super(name);
public void testInteraction() {
FourthMoment m4 = new FourthMoment();
Mean m = new Mean(m4);
Variance v = new Variance(m4);
Skewness s= new Skewness(m4);
Kurtosis k = new Kurtosis(m4);
for (int i = 0; i < testArray.length; i++){
m4.increment(testArray[i]);
assertEquals(mean,m.getResult(),tolerance);
assertEquals(var,v.getResult(),tolerance);
assertEquals(skew ,s.getResult(),tolerance);
assertEquals(kurt,k.getResult(),tolerance);
package org.apache.commons.math.stat.descriptive;
public final class StatisticalSummaryValuesTest extends TestCase {
public StatisticalSummaryValuesTest(String name) {
super(name);
public void setUp() {  
public static Test suite() {
TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);
suite.setName("StatisticalSummaryValues Tests");
return suite;
public void testSerialization() {
StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
TestUtils.checkSerializedEquality(u); 
StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);
verifyEquality(u, t);
public void testEqualsAndHashCode() {
StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
StatisticalSummaryValues t = null;
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
assertTrue("instances with same data should be equal", t.equals(u));
assertEquals("hash code", u.hashCode(), t.hashCode());
u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);
t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);
assertFalse("instances based on different data should be different", 
(u.equals(t) ||t.equals(u)));
private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);
TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);
TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);   
package org.apache.commons.math.stat.descriptive;
public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {
private static final long serialVersionUID = -8837442489133392138L;
protected List list;
protected NumberTransformer transformer;
protected int windowSize = DescriptiveStatistics.INFINITE_WINDOW;
public ListUnivariateImpl(){
this(new ArrayList());
public ListUnivariateImpl(List list) {
this(list, new DefaultTransformer());
public ListUnivariateImpl(List list, NumberTransformer transformer) {
super();
this.list = list;
this.transformer = transformer;
public double[] getValues() {
int length = list.size();
if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&
windowSize < list.size())
length = list.size() - Math.max(0, list.size() - windowSize);
double[] copiedArray = new double[length];
for (int i = 0; i < copiedArray.length; i++) {
copiedArray[i] = getElement(i);
return copiedArray;
public double getElement(int index) {
double value = Double.NaN;
int calcIndex = index;
if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&
windowSize < list.size())
calcIndex = (list.size() - windowSize) + index;
value = transformer.transform(list.get(calcIndex));
e.printStackTrace();
return value;
public long getN() {
int n = 0;
if (windowSize != DescriptiveStatistics.INFINITE_WINDOW) {
if (list.size() > windowSize) {
n = windowSize;
n = list.size();
n = list.size();
return n;
public void addValue(double v) {
list.add(new Double(v));
public void addObject(Object o) {
list.add(o);
public void clear() {
list.clear();
public double apply(UnivariateStatistic stat) {
double[] v = this.getValues();
if (v != null) {
return stat.evaluate(v, 0, v.length);
return Double.NaN;
public NumberTransformer getTransformer() {
return transformer;
public void setTransformer(NumberTransformer transformer) {
this.transformer = transformer;
public synchronized void setWindowSize(int windowSize) {
this.windowSize = windowSize;
int extra = list.size() - windowSize;
for (int i = 0; i < extra; i++) {
list.remove(0);
public synchronized int getWindowSize() {
return windowSize;
package org.apache.commons.math.stat.descriptive;
public final class ListUnivariateImplTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public ListUnivariateImplTest(String name) {
super(name);
public void setUp() {  
public static Test suite() {
TestSuite suite = new TestSuite(ListUnivariateImplTest.class);
suite.setName("Frequency Tests");
return suite;
public void testStats() {
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl( externalList ); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
List list = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl( list );
assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );
list.add( new Double(one));
assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);  
public void testSkewAndKurtosis() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testProductAndGeometricMean() throws Exception {
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );
public void testSerialization() {
DescriptiveStatistics u = null;
u = DescriptiveStatistics.newInstance(ListUnivariateImpl.class);
fail(e.getMessage());
fail(e.getMessage());
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
package org.apache.commons.math.stat.descriptive;
public final class DescriptiveStatisticsTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public DescriptiveStatisticsTest(String name) {
super(name);
public void setUp() {  
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);
suite.setName("Descriptive Statistics Tests");
return suite;
public void testStats() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testSkewAndKurtosis() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testProductAndGeometricMean() throws Exception {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
DescriptiveStatistics stats = DescriptiveStatistics.newInstance();
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
private void tstGetSortedValues(double[] test) {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
public void testPercentiles() {
double[] test = {5,4,3,2,1};
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testSerialization() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
fail();
fail();
public void testWindowSize() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
public void testWindowing() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testToString() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
package org.apache.commons.math.stat.descriptive.rank;
public class MinTest extends StorelessUnivariateStatisticAbstractTest{
protected Min stat;
public MinTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(MinTest.class);
suite.setName("Min  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Min();
public double expectedValue() {
return this.min;
public void testSpecialValues() {
double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, 
Double.NEGATIVE_INFINITY};
Min min = new Min();
assertTrue(Double.isNaN(min.getResult()));
min.increment(testArray[0]);
assertEquals(0d, min.getResult(), 0);
min.increment(testArray[1]);
assertEquals(0d, min.getResult(), 0);
min.increment(testArray[2]);
assertEquals(0d, min.getResult(), 0);
min.increment(testArray[3]);
assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);
assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     
public void testNaNs() {
Min min = new Min();
double nan = Double.NaN;
assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);     
assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);     
assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);     
assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     
package org.apache.commons.math.stat.descriptive.rank;
public class MaxTest extends StorelessUnivariateStatisticAbstractTest{
protected Max stat;
public MaxTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(MaxTest.class);
suite.setName("Max  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Max();
public double expectedValue() {
return this.max;
public void testSpecialValues() {
double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, 
Double.POSITIVE_INFINITY};
Max max = new Max();
assertTrue(Double.isNaN(max.getResult()));
max.increment(testArray[0]);
assertEquals(0d, max.getResult(), 0);
max.increment(testArray[1]);
assertEquals(0d, max.getResult(), 0);
max.increment(testArray[2]);
assertEquals(0d, max.getResult(), 0);
max.increment(testArray[3]);
assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);
assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     
public void testNaNs() {
Max max = new Max();
double nan = Double.NaN;
assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);     
assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);     
assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);     
assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     
package org.apache.commons.math.stat.descriptive.rank;
public class MedianTest extends UnivariateStatisticAbstractTest{
protected Median stat;
public MedianTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(MedianTest.class);
suite.setName("Median  Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {  
return new Median();
public double expectedValue() {
return this.median;
package org.apache.commons.math.stat.descriptive.rank;
public class PercentileTest extends UnivariateStatisticAbstractTest{
protected Percentile stat;
public PercentileTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(PercentileTest.class);
suite.setName("Percentile Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {   
return new Percentile(95.0);
public double expectedValue() {
return this.percentile95;
public void testHighPercentile(){
double[] d = new double[]{1, 2, 3};
Percentile p = new Percentile(75);
assertEquals(3.0, p.evaluate(d), 1.0e-5);
public void testPercentile() {
double[] d = new double[] {1, 3, 2, 4};
Percentile p = new Percentile(30);
assertEquals(1.5, p.evaluate(d), 1.0e-5);
p.setQuantile(25);
assertEquals(1.25, p.evaluate(d), 1.0e-5);
p.setQuantile(75);
assertEquals(3.75, p.evaluate(d), 1.0e-5);
p.setQuantile(50);
assertEquals(2.5, p.evaluate(d), 1.0e-5);
p.evaluate(d, 0, d.length, -1.0);
fail();
p.evaluate(d, 0, d.length, 101.0);
fail();
public void testNISTExample() {
double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, 
95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682
Percentile p = new Percentile(90); 
assertEquals(95.1981, p.evaluate(d), 1.0e-4);
assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);
public void test5() {
Percentile percentile = new Percentile(5);
assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());
public void testNullEmpty() {
Percentile percentile = new Percentile(50);
double[] nullArray = null;
double[] emptyArray = new double[] {};
percentile.evaluate(nullArray);
fail("Expecting IllegalArgumentException for null array");
assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));        
public void testSingleton() {
Percentile percentile = new Percentile(50);
double[] singletonArray = new double[] {1d};
assertEquals(1d, percentile.evaluate(singletonArray), 0);
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); 
assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     
public void testSpecialValues() {
Percentile percentile = new Percentile(50);
double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};
assertEquals(2.5d, percentile.evaluate(specialValues), 0);
specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,
Double.NaN, Double.POSITIVE_INFINITY};
assertEquals(2.5d, percentile.evaluate(specialValues), 0);
specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, 
Double.POSITIVE_INFINITY};
assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));
specialValues = new double[] {1d, 1d, Double.NaN, 
Double.NaN};
assertTrue(Double.isNaN(percentile.evaluate(specialValues)));
specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, 
Double.NEGATIVE_INFINITY};
assertTrue(Double.isNaN(percentile.evaluate(specialValues)));   
public void testSetQuantile() {
Percentile percentile = new Percentile(10);
percentile.setQuantile(100); // OK
assertEquals(100, percentile.getQuantile(), 0);      
percentile.setQuantile(0);
fail("Expecting IllegalArgumentException");
new Percentile(0);
fail("Expecting IllegalArgumentException");
package org.apache.commons.math.stat.descriptive;
public final class DescriptiveStatisticsImplTest extends TestCase {
private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public DescriptiveStatisticsImplTest(String name) {
super(name);
public void setUp() {  
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
suite.setName("DescriptiveStatistics Tests");
return suite;
public void testStats() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testSkewAndKurtosis() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
double[] testArray = 
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
public void testProductAndGeometricMean() throws Exception {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
private void tstGetSortedValues(double[] test) {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
public void testPercentiles() {
double[] test = {5,4,3,2,1};
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
package org.apache.commons.math.stat.descriptive.summary;
public class SumTest extends StorelessUnivariateStatisticAbstractTest{
protected Sum stat;
public SumTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SumTest.class);
suite.setName("Sum Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Sum();      
public double expectedValue() {
return this.sum;
public void testSpecialValues() {
Sum sum = new Sum();
assertTrue(Double.isNaN(sum.getResult()));
sum.increment(1);
assertEquals(1, sum.getResult(), 0);
sum.increment(Double.POSITIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);
sum.increment(Double.NEGATIVE_INFINITY);
assertTrue(Double.isNaN(sum.getResult()));
sum.increment(1);
assertTrue(Double.isNaN(sum.getResult())); 
package org.apache.commons.math.stat.descriptive.summary;
public class ProductTest extends StorelessUnivariateStatisticAbstractTest{
protected Product stat;
public ProductTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(ProductTest.class);
suite.setName("Product Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new Product();
public double getTolerance() {
return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double
public double expectedValue() {
return this.product;
public void testSpecialValues() {
Product product = new Product();
assertTrue(Double.isNaN(product.getResult()));
product.increment(1);
assertEquals(1, product.getResult(), 0);
product.increment(Double.POSITIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);
product.increment(Double.NEGATIVE_INFINITY);
assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);
product.increment(Double.NaN);
assertTrue(Double.isNaN(product.getResult())); 
product.increment(1);
assertTrue(Double.isNaN(product.getResult())); 
package org.apache.commons.math.stat.descriptive.summary;
public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{
protected SumOfSquares stat;
public SumSqTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SumSqTest.class);
suite.setName("SumSq Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {
return new SumOfSquares();
public double expectedValue() {
return this.sumSq;
public void testSpecialValues() {
SumOfSquares sumSq = new SumOfSquares();
assertTrue(Double.isNaN(sumSq.getResult()));
sumSq.increment(2d);
assertEquals(4d, sumSq.getResult(), 0);
sumSq.increment(Double.POSITIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);
sumSq.increment(Double.NEGATIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);
sumSq.increment(Double.NaN);
assertTrue(Double.isNaN(sumSq.getResult())); 
sumSq.increment(1);
assertTrue(Double.isNaN(sumSq.getResult())); 
package org.apache.commons.math.stat.descriptive.summary;
public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{
protected SumOfLogs stat;
public SumLogTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SumLogTest.class);
suite.setName("SumLog Tests");
return suite;
public UnivariateStatistic getUnivariateStatistic() {        
return new SumOfLogs();
public double expectedValue() {
return this.sumLog;
public void testSpecialValues() {
SumOfLogs sum = new SumOfLogs();
assertTrue(Double.isNaN(sum.getResult()));
sum.increment(1d);
assertFalse(Double.isNaN(sum.getResult()));
sum.increment(0d);
assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);
sum.increment(Double.POSITIVE_INFINITY);
assertTrue(Double.isNaN(sum.getResult()));
sum.clear();
assertTrue(Double.isNaN(sum.getResult()));
sum.increment(Double.POSITIVE_INFINITY);
assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);
sum.increment(-2d);
assertTrue(Double.isNaN(sum.getResult()));
package org.apache.commons.math.stat;
public final class FrequencyTest extends TestCase {
private long oneL = 1;
private long twoL = 2;
private long threeL = 3;
private int oneI = 1;
private int twoI = 2;
private int threeI=3;
private double tolerance = 10E-15;
private Frequency f = null;
public FrequencyTest(String name) {
super(name);
public void setUp() {  
f = new Frequency();
public static Test suite() {
TestSuite suite = new TestSuite(FrequencyTest.class);
suite.setName("Frequency Tests");
return suite;
public void testCounts() {
assertEquals("total count",0,f.getSumFreq());
f.addValue(oneL);
f.addValue(twoL);
f.addValue(1);
f.addValue(oneI);
assertEquals("one frequency count",3,f.getCount(1));
assertEquals("two frequency count",1,f.getCount(2));
assertEquals("three frequency count",0,f.getCount(3));
assertEquals("total count",4,f.getSumFreq());
assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));
assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));
assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));
assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));
f.clear();
assertEquals("total count",0,f.getSumFreq());
f.addValue("one");
f.addValue("One");
f.addValue("oNe");
f.addValue("Z");
assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));
assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);
assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);
assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);
f.clear();
f = null;
Frequency f = new Frequency();
f.addValue(1);
f.addValue(new Integer(1));
f.addValue(new Long(1));
f.addValue(2);
f.addValue(new Integer(-1));
assertEquals("1 count", 3, f.getCount(1));
assertEquals("1 count", 3, f.getCount(new Integer(1)));
assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);
assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);   
f = null;
f = new Frequency(String.CASE_INSENSITIVE_ORDER);
f.addValue("one");
f.addValue("One");
f.addValue("oNe");
f.addValue("Z");
assertEquals("one count", 3 ,  f.getCount("one"));
assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);
assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);
f = null;
f = new Frequency();
assertEquals(0L, f.getCount('a'));
assertEquals(0L, f.getCumFreq('b'));
TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);
TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);
f.addValue('a');
f.addValue('b');
f.addValue('c');
f.addValue('d');
assertEquals(1L, f.getCount('a'));
assertEquals(2L, f.getCumFreq('b'));
assertEquals(0.25, f.getPct('a'), 0.0);
assertEquals(0.5, f.getCumPct('b'), 0.0);
assertEquals(1.0, f.getCumPct('e'), 0.0);
public void testPcts() {
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(threeL);
f.addValue(threeL);
f.addValue(3);
f.addValue(threeI);
assertEquals("one pct",0.25,f.getPct(1),tolerance);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
assertEquals("three pct",0.5,f.getPct(threeL),tolerance);
assertEquals("five pct",0,f.getPct(5),tolerance);
assertEquals("foo pct",0,f.getPct("foo"),tolerance);
assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);
assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);
assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);
assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);
public void testAdd() {
char aChar = 'a';
char bChar = 'b';
String aString = "a";
f.addValue(aChar);
f.addValue(bChar);
f.addValue(aString);    
fail("Expecting IllegalArgumentException");
assertEquals("a pct",0.5,f.getPct(aChar),tolerance);
assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);
assertEquals("a string pct",0.0,f.getPct(aString),tolerance);
assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);
public void testEmptyTable() {
assertEquals("freq sum, empty table", 0, f.getSumFreq());
assertEquals("count, empty table", 0, f.getCount(0));
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
assertEquals("cum freq, empty table", 0, f.getCumFreq(0));
assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));
assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
public void testToString(){
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
String s = f.toString();
assertNotNull(s);
BufferedReader reader = new BufferedReader(new StringReader(s));
String line = reader.readLine(); // header line
assertNotNull(line);
line = reader.readLine(); // one's or two's line
assertNotNull(line);
line = reader.readLine(); // one's or two's line
assertNotNull(line);
line = reader.readLine(); // no more elements
assertNull(line);
fail(ex.getMessage());
public void testIntegerValues() {
Object obj1 = null;
obj1 = new Integer(1);
Integer int1 = new Integer(1);
f.addValue(obj1);
f.addValue(int1);
f.addValue(2);
f.addValue(new Long(2));
assertEquals("Integer 1 count", 2, f.getCount(1));
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
Iterator it = f.valuesIterator();
while (it.hasNext()) {
assertTrue(it.next() instanceof Long);
package org.apache.commons.math.stat.regression;
public final class SimpleRegressionTest extends TestCase {
private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, 
private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, 
private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },
private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },
public SimpleRegressionTest(String name) {
super(name);
public void setUp() {
public static Test suite() {
TestSuite suite = new TestSuite(SimpleRegressionTest.class);
suite.setName("BivariateRegression Tests");
return suite;
public void testNorris() {
SimpleRegression regression = new SimpleRegression();
for (int i = 0; i < data.length; i++) {
regression.addData(data[i][1], data[i][0]);
assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);
assertEquals("slope std err", 0.429796848199937E-03,
regression.getSlopeStdErr(),10E-12);
assertEquals("number of observations", 36, regression.getN());
assertEquals( "intercept", -0.262323073774029,
regression.getIntercept(),10E-12);
assertEquals("std err intercept", 0.232818234301152,
regression.getInterceptStdErr(),10E-12);
assertEquals("r-square", 0.999993745883712,
regression.getRSquare(), 10E-12);
assertEquals("SSR", 4255954.13232369,
regression.getRegressionSumSquares(), 10E-9);
assertEquals("MSE", 0.782864662630069,
regression.getMeanSquareError(), 10E-10);
assertEquals("SSE", 26.6173985294224,
regression.getSumSquaredErrors(),10E-9);
assertEquals( "predict(0)",  -0.262323073774029,
regression.predict(0), 10E-12);
assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,
regression.predict(1), 10E-12);
public void testCorr() {
SimpleRegression regression = new SimpleRegression();
regression.addData(corrData);
assertEquals("number of observations", 17, regression.getN());
assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);
assertEquals("r", -0.94663767742, regression.getR(), 1E-10);
public void testNaNs() {
SimpleRegression regression = new SimpleRegression();
assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));
assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));
assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));
assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));
assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));
assertTrue("e not NaN", Double.isNaN(regression.getR()));
assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));
assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));
assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));
assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));
assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));
regression.addData(1, 2);
regression.addData(1, 3);
assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));
assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));
assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));
assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));
assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));
assertTrue("e not NaN", Double.isNaN(regression.getR()));
assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));
assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));
assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));
assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));
assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));
regression = new SimpleRegression();
regression.addData(1, 2);
regression.addData(3, 3);
assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));
assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));
assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));
assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));
assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));
assertTrue("r NaN", !Double.isNaN(regression.getR()));
assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));
assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));
assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));
assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));
assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));
regression.addData(1, 4);
assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));
assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));
assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));
public void testClear() {
SimpleRegression regression = new SimpleRegression();
regression.addData(corrData);
assertEquals("number of observations", 17, regression.getN());
regression.clear();
assertEquals("number of observations", 0, regression.getN());
regression.addData(corrData);
assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);
regression.addData(data);
assertEquals("number of observations", 53, regression.getN());
public void testInference() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
regression = new SimpleRegression();
regression.addData(infData2);
assertEquals("slope std err", 1.07260253,
regression.getSlopeStdErr(), 1E-8);
assertEquals("std err intercept",4.17718672,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 0.261829133982,
regression.getSignificance(),1E-11);    
assertEquals("slope conf interval half-width", 2.97802204827, 
regression.getSlopeConfidenceInterval(),1E-8);
assertTrue("tighter means wider",
regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
regression.getSlopeConfidenceInterval(1);
fail("expecting IllegalArgumentException for alpha = 1");
public void testPerfect() throws Exception {
SimpleRegression regression = new SimpleRegression();
int n = 100;
for (int i = 0; i < n; i++) {
regression.addData(((double) i) / (n - 1), i);
assertEquals(0.0, regression.getSignificance(), 1.0e-5);
assertTrue(regression.getSlope() > 0.0);
assertTrue(regression.getSumSquaredErrors() >= 0.0);
public void testPerfectNegative() throws Exception {
SimpleRegression regression = new SimpleRegression();
int n = 100;
for (int i = 0; i < n; i++) {
regression.addData(- ((double) i) / (n - 1), i);
assertEquals(0.0, regression.getSignificance(), 1.0e-5);
assertTrue(regression.getSlope() < 0.0);   
public void testRandom() throws Exception {
SimpleRegression regression = new SimpleRegression();
Random random = new Random(1);
int n = 100;
for (int i = 0; i < n; i++) {
regression.addData(((double) i) / (n - 1), random.nextDouble());
assertTrue( 0.0 < regression.getSignificance()
&& regression.getSignificance() < 1.0);       
public void testSSENonNegative() {
double[] y = { 8915.102, 8919.302, 8923.502 };
double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };
SimpleRegression reg = new SimpleRegression();
for (int i = 0; i < x.length; i++) {
reg.addData(x[i], y[i]);
assertTrue(reg.getSumSquaredErrors() >= 0.0);
package org.apache.commons.math.stat.data;
public class LewTest extends CertifiedDataAbstractTest {
protected String getResourceName() {
return "org/apache/commons/math/stat/data/Lew.txt";
package org.apache.commons.math.stat.data;
public class LotteryTest extends CertifiedDataAbstractTest {
protected String getResourceName() {
return "org/apache/commons/math/stat/data/Lottery.txt";
package org.apache.commons.math.stat.data;
public abstract class CertifiedDataAbstractTest extends TestCase {
private DescriptiveStatistics descriptives;
private SummaryStatistics summaries;
private Map certifiedValues;
protected void setUp() throws Exception {
descriptives = DescriptiveStatistics.newInstance();
summaries = SummaryStatistics.newInstance();
certifiedValues = new HashMap();
loadData();
private void loadData() throws IOException {
BufferedReader in = null;
URL resourceURL = getClass().getClassLoader().getResource(getResourceName());
in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));
String line = in.readLine();
while (line != null) {
line = line.trim();
if (!("".equals(line) || line.startsWith("#"))) {
int n = line.indexOf('=');
if (n == -1) {
double value = Double.parseDouble(line);
descriptives.addValue(value);
summaries.addValue(value);
String name = line.substring(0, n).trim();
String valueString = line.substring(n + 1).trim();
Double value = new Double(valueString);
certifiedValues.put(name, value);
line = in.readLine();
if (in != null) {
in.close();
protected abstract String getResourceName();
protected double getMaximumAbsoluteError() {
return 1.0e-5;
protected void tearDown() throws Exception {
descriptives.clear();
descriptives = null;
summaries.clear();
summaries = null;
certifiedValues.clear();
certifiedValues = null;
public void testCertifiedValues() {
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
Double expectedValue = (Double)certifiedValues.get(name);
Double summariesValue = (Double)this.getProperty(summaries, name);
TestUtils.assertEquals("summary value for " + name + " is incorrect.",
summariesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());
Double descriptivesValue = (Double)this.getProperty(descriptives, name);
TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",
descriptivesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());
protected Object getProperty(Object bean, String name) throws Exception{
String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1); 
Method meth = bean.getClass().getMethod(prop, new Class[0]);
return meth.invoke(bean, new Object[0]);
package org.apache.commons.math.estimation;
public class MinpackTest
extends TestCase {
public MinpackTest(String name) {
super(name);
public void testMinpackLinearFullRank()
throws EstimationException {
minpackTest(new LinearFullRankFunction(10, 5, 1.0,
5.0, 2.23606797749979), false);
minpackTest(new LinearFullRankFunction(50, 5, 1.0,
8.06225774829855, 6.70820393249937), false);
public void testMinpackLinearRank1()
throws EstimationException {
minpackTest(new LinearRank1Function(10, 5, 1.0,
291.521868819476, 1.4638501094228), false);
minpackTest(new LinearRank1Function(50, 5, 1.0,
3101.60039334535, 3.48263016573496), false);
public void testMinpackLinearRank1ZeroColsAndRows()
throws EstimationException {
minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);
minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);
public void testMinpackRosenbrok()
throws EstimationException {
minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },
Math.sqrt(24.2)), false);
minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },
Math.sqrt(1795769.0)), false);
minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },
11.0 * Math.sqrt(169000121.0)), false);
public void testMinpackHelicalValley()
throws EstimationException {
minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },
50.0), false);
minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },
102.95630140987), false);
minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},
991.261822123701), false);
public void testMinpackPowellSingular()
throws EstimationException {
minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },
14.6628782986152), false);
minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },
1270.9838708654), false);
minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },
126887.903284750), false);
public void testMinpackFreudensteinRoth()
throws EstimationException {
minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },
20.0124960961895, 6.99887517584575,
new double[] {
11.4124844654993,
-0.896827913731509
minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },
12432.833948863, 6.9988751744895,
new double[] {
11.4130046614746,
-0.896796038685958
minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },
11426454.595762, 6.99887517242903,
new double[] {
11.4127817857886,
-0.89680510749204
public void testMinpackBard()
throws EstimationException {
minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,
new double[] {
0.0824105765758334,
1.1330366534715,
2.34369463894115
minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,
new double[] {
0.840666673818329,
-158848033.259565,
-164378671.653535
minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,
new double[] {
0.840666673867645,
-158946167.205518,
-164464906.857771
public void testMinpackKowalikOsborne()
throws EstimationException {
minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },
0.0728915102882945,
0.017535837721129,
new double[] {
0.192807810476249,
0.191262653354071,
0.123052801046931,
0.136053221150517
minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },
2.97937007555202,
0.032052192917937,
new double[] {
728675.473768287,
-14.0758803129393,
-32977797.7841797,
-20571594.1977912
minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },
29.9590617016037,
0.0175364017658228,
new double[] {
0.192948328597594,
0.188053165007911,
0.122430604321144,
0.134575665392506
public void testMinpackMeyer()
throws EstimationException {
minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },
41153.4665543031, 9.37794514651874,
new double[] {
0.00560963647102661,
6181.34634628659,
345.223634624144
minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },
4168216.89130846, 792.917871779501,
new double[] {
1.42367074157994e-11,
33695.7133432541,
901.268527953801
public void testMinpackWatson()
throws EstimationException {
minpackTest(new WatsonFunction(6, 0.0,
5.47722557505166, 0.0478295939097601,
new double[] {
-0.0157249615083782, 1.01243488232965,
-0.232991722387673,  1.26043101102818,
-1.51373031394421,   0.99299727291842
minpackTest(new WatsonFunction(6, 10.0,
6433.12578950026, 0.0478295939096951,
new double[] {
-0.0157251901386677, 1.01243485860105,
-0.232991545843829,  1.26042932089163,
-1.51372776706575,   0.99299573426328
minpackTest(new WatsonFunction(6, 100.0,
674256.040605213, 0.047829593911544,
new double[] {
-0.0157247019712586, 1.01243490925658,
-0.232991922761641,  1.26043292929555,
-1.51373320452707,   0.99299901922322
minpackTest(new WatsonFunction(9, 0.0,
5.47722557505166, 0.00118311459212420,
new double[] {
-0.153070644166722e-4, 0.999789703934597,
0.0147639634910978,   0.146342330145992,
1.00082109454817,    -2.61773112070507,
4.10440313943354,    -3.14361226236241,
1.05262640378759
minpackTest(new WatsonFunction(9, 10.0,
12088.127069307, 0.00118311459212513,
new double[] {
-0.153071334849279e-4, 0.999789703941234,
0.0147639629786217,   0.146342334818836,
1.00082107321386,    -2.61773107084722,
4.10440307655564,    -3.14361222178686,
1.05262639322589
minpackTest(new WatsonFunction(9, 100.0,
1269109.29043834, 0.00118311459212384,
new double[] {
-0.153069523352176e-4, 0.999789703958371,
0.0147639625185392,   0.146342341096326,
1.00082104729164,    -2.61773101573645,
4.10440301427286,    -3.14361218602503,
1.05262638516774
minpackTest(new WatsonFunction(12, 0.0,
5.47722557505166, 0.217310402535861e-4,
new double[] {
-0.660266001396382e-8, 1.00000164411833,
-0.000563932146980154, 0.347820540050756,
-0.156731500244233,    1.05281515825593,
-3.24727109519451,     7.2884347837505,
-10.271848098614,       9.07411353715783,
-4.54137541918194,     1.01201187975044
minpackTest(new WatsonFunction(12, 10.0,
19220.7589790951, 0.217310402518509e-4,
new double[] {
-0.663710223017410e-8, 1.00000164411787,
-0.000563932208347327, 0.347820540486998,
-0.156731503955652,    1.05281517654573,
-3.2472711515214,      7.28843489430665,
-10.2718482369638,      9.07411364383733,
-4.54137546533666,     1.01201188830857
minpackTest(new WatsonFunction(12, 100.0,
2018918.04462367, 0.217310402539845e-4,
new double[] {
-0.663806046485249e-8, 1.00000164411786,
-0.000563932210324959, 0.347820540503588,
-0.156731504091375,    1.05281517718031,
-3.24727115337025,     7.28843489775302,
-10.2718482410813,      9.07411364688464,
-4.54137546660822,     1.0120118885369
public void testMinpackBox3Dimensional()
throws EstimationException {
minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },
32.1115837449572), false);
public void testMinpackJennrichSampson()
throws EstimationException {
minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },
64.5856498144943, 11.1517793413499,
new double[] {
0.257819926636811, 0.257829976764542
public void testMinpackBrownDennis()
throws EstimationException {
minpackTest(new BrownDennisFunction(20,
new double[] { 25.0, 5.0, -5.0, -1.0 },
2815.43839161816, 292.954288244866,
new double[] {
-11.59125141003, 13.2024883984741,
-0.403574643314272, 0.236736269844604
minpackTest(new BrownDennisFunction(20,
new double[] { 250.0, 50.0, -50.0, -10.0 },
555073.354173069, 292.954270581415,
new double[] {
-11.5959274272203, 13.2041866926242,
-0.403417362841545, 0.236771143410386
minpackTest(new BrownDennisFunction(20,
new double[] { 2500.0, 500.0, -500.0, -100.0 },
61211252.2338581, 292.954306151134,
new double[] {
-11.5902596937374, 13.2020628854665,
-0.403688070279258, 0.236665033746463
public void testMinpackChebyquad()
throws EstimationException {
minpackTest(new ChebyquadFunction(1, 8, 1.0,
1.88623796907732, 1.88623796907732,
new double[] { 0.5 }), false);
minpackTest(new ChebyquadFunction(1, 8, 10.0,
5383344372.34005, 1.88424820499951,
new double[] { 0.9817314924684 }), false);
minpackTest(new ChebyquadFunction(1, 8, 100.0,
0.118088726698392e19, 1.88424820499347,
new double[] { 0.9817314852934 }), false);
minpackTest(new ChebyquadFunction(8, 8, 1.0,
0.196513862833975, 0.0593032355046727,
new double[] {
0.0431536648587336, 0.193091637843267,
0.266328593812698,  0.499999334628884,
0.500000665371116,  0.733671406187302,
0.806908362156733,  0.956846335141266
minpackTest(new ChebyquadFunction(9, 9, 1.0,
0.16994993465202, 0.0,
new double[] {
0.0442053461357828, 0.199490672309881,
0.23561910847106,   0.416046907892598,
0.5,                0.583953092107402,
0.764380891528940,  0.800509327690119,
0.955794653864217
minpackTest(new ChebyquadFunction(10, 10, 1.0,
0.183747831178711, 0.0806471004038253,
new double[] {
0.0596202671753563, 0.166708783805937,
0.239171018813509,  0.398885290346268,
0.398883667870681,  0.601116332129320,
0.60111470965373,   0.760828981186491,
0.833291216194063,  0.940379732824644
public void testMinpackBrownAlmostLinear()
throws EstimationException {
minpackTest(new BrownAlmostLinearFunction(10, 0.5,
16.5302162063499, 0.0,
new double[] {
0.979430303349862, 0.979430303349862,
0.979430303349862, 0.979430303349862,
0.979430303349862, 0.979430303349862,
0.979430303349862, 0.979430303349862,
0.979430303349862, 1.20569696650138
minpackTest(new BrownAlmostLinearFunction(10, 5.0,
9765624.00089211, 0.0,
new double[] {
0.979430303349865, 0.979430303349865,
0.979430303349865, 0.979430303349865,
0.979430303349865, 0.979430303349865,
0.979430303349865, 0.979430303349865,
0.979430303349865, 1.20569696650135
minpackTest(new BrownAlmostLinearFunction(10, 50.0,
0.9765625e17, 0.0,
new double[] {
1.0, 1.0, 1.0, 1.0, 1.0,
1.0, 1.0, 1.0, 1.0, 1.0
minpackTest(new BrownAlmostLinearFunction(30, 0.5,
83.476044467848, 0.0,
new double[] {
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 0.997754216442807,
0.997754216442807, 1.06737350671578
minpackTest(new BrownAlmostLinearFunction(40, 0.5,
128.026364472323, 0.0,
new double[] {
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
1.00000000000002, 1.00000000000002,
0.999999999999121
public void testMinpackOsborne1()
throws EstimationException {
minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },
0.937564021037838, 0.00739249260904843,
new double[] {
0.375410049244025, 1.93584654543108,
-1.46468676748716, 0.0128675339110439,
0.0221227011813076
public void testMinpackOsborne2()
throws EstimationException {
minpackTest(new Osborne2Function(new double[] {
1.3, 0.65, 0.65, 0.7, 0.6,
3.0, 5.0, 7.0, 2.0, 4.5, 5.5
1.44686540984712, 0.20034404483314,
new double[] {
1.30997663810096,  0.43155248076,
0.633661261602859, 0.599428560991695,
0.754179768272449, 0.904300082378518,
1.36579949521007, 4.82373199748107,
2.39868475104871, 4.56887554791452,
5.67534206273052
private void minpackTest(MinpackFunction function, boolean exceptionExpected) {
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.setMaxCostEval(100 * (function.getN() + 1));
estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));
estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));
estimator.setOrthoTolerance(2.22044604926e-16);
assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));
estimator.estimate(function);
assertFalse(exceptionExpected);
assertTrue(exceptionExpected);
assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));
assertTrue(function.checkTheoreticalMinParams());
private static abstract class MinpackFunction implements EstimationProblem {
protected MinpackFunction(int m,
double[] startParams,
double   theoreticalStartCost,
double   theoreticalMinCost,
double[] theoreticalMinParams) {
this.m = m;
this.n = startParams.length;
parameters = new EstimatedParameter[n];
for (int i = 0; i < n; ++i) {
parameters[i] = new EstimatedParameter("p" + i, startParams[i]);
this.theoreticalStartCost = theoreticalStartCost;
this.theoreticalMinCost   = theoreticalMinCost;
this.theoreticalMinParams = theoreticalMinParams;
this.costAccuracy         = 1.0e-8;
this.paramsAccuracy       = 1.0e-5;
protected static double[] buildArray(int n, double x) {
double[] array = new double[n];
Arrays.fill(array, x);
return array;
protected void setCostAccuracy(double costAccuracy) {
this.costAccuracy = costAccuracy;
protected void setParamsAccuracy(double paramsAccuracy) {
this.paramsAccuracy = paramsAccuracy;
public int getN() {
return parameters.length;
public boolean checkTheoreticalStartCost(double rms) {
double threshold = costAccuracy * (1.0 + theoreticalStartCost);
return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;
public boolean checkTheoreticalMinCost(double rms) {
double threshold = costAccuracy * (1.0 + theoreticalMinCost);
return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;
public boolean checkTheoreticalMinParams() {
if (theoreticalMinParams != null) {
for (int i = 0; i < theoreticalMinParams.length; ++i) {
double mi = theoreticalMinParams[i];
double vi = parameters[i].getEstimate();
if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {
return false;
return true;
public WeightedMeasurement[] getMeasurements() {
WeightedMeasurement[] measurements = new WeightedMeasurement[m];
for (int i = 0; i < m; ++i) {
measurements[i] = new MinpackMeasurement(i);
return measurements;
public EstimatedParameter[] getUnboundParameters() {
return parameters;
public EstimatedParameter[] getAllParameters() {
return parameters;
protected abstract double[][] getJacobian();
protected abstract double[] getResiduals();
private class MinpackMeasurement extends WeightedMeasurement {
public MinpackMeasurement(int index) {
super(1.0, 0.0);
this.index = index;
public double getTheoreticalValue() {
return getResiduals()[index];
public double getPartial(EstimatedParameter parameter) {
for (int j = 0; j < n; ++j) {
if (parameter == parameters[j]) {
return getJacobian()[index][j];
return 0;
private int index;
private static final long serialVersionUID = 1L;
protected int                  n;
protected int                  m;
protected EstimatedParameter[] parameters;
protected double               theoreticalStartCost;
protected double               theoreticalMinCost;
protected double[]             theoreticalMinParams;
protected double               costAccuracy;
protected double               paramsAccuracy;
private static class LinearFullRankFunction extends MinpackFunction {
public LinearFullRankFunction(int m, int n, double x0,
double theoreticalStartCost,
double theoreticalMinCost) {
super(m, buildArray(n, x0), theoreticalStartCost,
theoreticalMinCost, buildArray(n, -1.0));
protected double[][] getJacobian() {
double t = 2.0 / m;
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
jacobian[i] = new double[n];
for (int j = 0; j < n; ++j) {
jacobian[i][j] = (i == j) ? (1 - t) : -t;
return jacobian;
protected double[] getResiduals() {
double sum = 0;
for (int i = 0; i < n; ++i) {
sum += parameters[i].getEstimate();
double t  = 1 + 2 * sum / m;
double[] f = new double[m];
for (int i = 0; i < n; ++i) {
f[i] = parameters[i].getEstimate() - t;
Arrays.fill(f, n, m, -t);
return f;
private static class LinearRank1Function extends MinpackFunction {
public LinearRank1Function(int m, int n, double x0,
double theoreticalStartCost,
double theoreticalMinCost) {
super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);
protected double[][] getJacobian() {
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
jacobian[i] = new double[n];
for (int j = 0; j < n; ++j) {
jacobian[i][j] = (i + 1) * (j + 1);
return jacobian;
protected double[] getResiduals() {
double[] f = new double[m];
double sum = 0;
for (int i = 0; i < n; ++i) {
sum += (i + 1) * parameters[i].getEstimate();
for (int i = 0; i < m; ++i) {
f[i] = (i + 1) * sum - 1;
return f;
private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {
public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {
super(m, buildArray(n, x0),
Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),
Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),
null);
protected double[][] getJacobian() {
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
jacobian[i] = new double[n];
jacobian[i][0] = 0;
for (int j = 1; j < (n - 1); ++j) {
if (i == 0) {
jacobian[i][j] = 0;
jacobian[i][j] = i * (j + 1);
jacobian[i][j] = 0;
jacobian[i][n - 1] = 0;
return jacobian;
protected double[] getResiduals() {
double[] f = new double[m];
double sum = 0;
for (int i = 1; i < (n - 1); ++i) {
sum += (i + 1) * parameters[i].getEstimate();
for (int i = 0; i < (m - 1); ++i) {
f[i] = i * sum - 1;
f[m - 1] = -1;
return f;
private static class RosenbrockFunction extends MinpackFunction {
public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {
super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));
protected double[][] getJacobian() {
double x1 = parameters[0].getEstimate();
return new double[][] { { -20 * x1, 10 }, { -1, 0 } };
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };
private static class HelicalValleyFunction extends MinpackFunction {
public HelicalValleyFunction(double[] startParams,
double theoreticalStartCost) {
super(3, startParams, theoreticalStartCost, 0.0,
new double[] { 1.0, 0.0, 0.0 });
protected double[][] getJacobian() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double tmpSquare = x1 * x1 + x2 * x2;
double tmp1 = twoPi * tmpSquare;
double tmp2 = Math.sqrt(tmpSquare);
return new double[][] {
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double tmp1;
if (x1 == 0) {
tmp1 = (x2 >= 0) ? 0.25 : -0.25;
tmp1 = Math.atan(x2 / x1) / twoPi;
if (x1 < 0) {
tmp1 += 0.5;
double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);
return new double[] {
10.0 * (x3 - 10 * tmp1),
10.0 * (tmp2 - 1),
x3
private static final double twoPi = 2.0 * Math.PI;
private static class PowellSingularFunction extends MinpackFunction {
public PowellSingularFunction(double[] startParams,
double theoreticalStartCost) {
super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));
protected double[][] getJacobian() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double x4 = parameters[3].getEstimate();
return new double[][] {
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double x4 = parameters[3].getEstimate();
return new double[] {
x1 + 10 * x2,
sqrt5 * (x3 - x4),
(x2 - 2 * x3) * (x2 - 2 * x3),
sqrt10 * (x1 - x4) * (x1 - x4)
private static final double sqrt5  = Math.sqrt( 5.0);
private static final double sqrt10 = Math.sqrt(10.0);
private static class FreudensteinRothFunction extends MinpackFunction {
public FreudensteinRothFunction(double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(2, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double x2 = parameters[1].getEstimate();
return new double[][] {
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
return new double[] {
-13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,
-29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2
private static class BardFunction extends MinpackFunction {
public BardFunction(double x0,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(15, buildArray(3, x0), theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double tmp1 = i  + 1;
double tmp2 = 15 - i;
double tmp3 = (i <= 7) ? tmp1 : tmp2;
double tmp4 = x2 * tmp2 + x3 * tmp3;
tmp4 *= tmp4;
jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };
return jacobian;
protected double[] getResiduals() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double tmp1 = i + 1;
double tmp2 = 15 - i;
double tmp3 = (i <= 7) ? tmp1 : tmp2;
f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));
return f;
private static final double[] y = {
0.14, 0.18, 0.22, 0.25, 0.29,
0.32, 0.35, 0.39, 0.37, 0.58,
0.73, 0.96, 1.34, 2.10, 4.39
private static class KowalikOsborneFunction extends MinpackFunction {
public KowalikOsborneFunction(double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(11, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
if (theoreticalStartCost > 20.0) {
setCostAccuracy(2.0e-4);
setParamsAccuracy(5.0e-3);
protected double[][] getJacobian() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double   x4 = parameters[3].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double tmp = v[i] * (v[i] + x3) + x4;
double j1  = -v[i] * (v[i] + x2) / tmp;
double j2  = -v[i] * x1 / tmp;
double j3  = j1 * j2;
double j4  = j3 / v[i];
jacobian[i] = new double[] { j1, j2, j3, j4 };
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double x4 = parameters[3].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);
return f;
private static final double[] v = {
4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625
private static final double[] y = {
0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,
0.0456, 0.0342, 0.0323, 0.0235, 0.0246
private static class MeyerFunction extends MinpackFunction {
public MeyerFunction(double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(16, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
if (theoreticalStartCost > 1.0e6) {
setCostAccuracy(7.0e-3);
setParamsAccuracy(2.0e-2);
protected double[][] getJacobian() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double temp = 5.0 * (i + 1) + 45.0 + x3;
double tmp1 = x2 / temp;
double tmp2 = Math.exp(tmp1);
double tmp3 = x1 * tmp2 / temp;
jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];
return f;
private static final double[] y = {
34780.0, 28610.0, 23650.0, 19630.0,
16370.0, 13720.0, 11540.0,  9744.0,
8261.0,  7030.0,  6005.0,  5147.0,
4427.0,  3820.0,  3307.0,  2872.0                  
private static class WatsonFunction extends MinpackFunction {
public WatsonFunction(int n, double x0,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(31, buildArray(n, x0), theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double[][] jacobian = new double[m][];
for (int i = 0; i < (m - 2); ++i) {
double div = (i + 1) / 29.0;
double s2  = 0.0;
double dx  = 1.0;
for (int j = 0; j < n; ++j) {
s2 += dx * parameters[j].getEstimate();
dx *= div;
double temp= 2 * div * s2;
dx = 1.0 / div;
jacobian[i] = new double[n];
for (int j = 0; j < n; ++j) {
jacobian[i][j] = dx * (j - temp);
dx *= div;
jacobian[m - 2]    = new double[n];
jacobian[m - 2][0] = 1;
jacobian[m - 1]   = new double[n];
jacobian[m - 1][0]= -2 * parameters[0].getEstimate();
jacobian[m - 1][1]= 1;
return jacobian;
protected double[] getResiduals() {
double[] f = new double[m];
for (int i = 0; i < (m - 2); ++i) {
double div = (i + 1) / 29.0;
double s1 = 0;
double dx = 1;
for (int j = 1; j < n; ++j) {
s1 += j * dx * parameters[j].getEstimate();
dx *= div;
double s2 =0;
dx =1;
for (int j = 0; j < n; ++j) {
s2 += dx * parameters[j].getEstimate();
dx *= div;
f[i] = s1 - s2 * s2 - 1;
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
f[m - 2] = x1;
f[m - 1] = x2 - x1 * x1 - 1;
return f;
private static class Box3DimensionalFunction extends MinpackFunction {
public Box3DimensionalFunction(int m, double[] startParams,
double theoreticalStartCost) {
super(m, startParams, theoreticalStartCost,
0.0, new double[] { 1.0, 10.0, 1.0 });
protected double[][] getJacobian() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double tmp = (i + 1) / 10.0;
jacobian[i] = new double[] {
-tmp * Math.exp(-tmp * x1),
tmp * Math.exp(-tmp * x2),
Math.exp(-i - 1) - Math.exp(-tmp)
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double tmp = (i + 1) / 10.0;
f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)
+ (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;
return f;
private static class JennrichSampsonFunction extends MinpackFunction {
public JennrichSampsonFunction(int m, double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(m, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double t = i + 1;
jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double temp = i + 1;
f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);
return f;
private static class BrownDennisFunction extends MinpackFunction {
public BrownDennisFunction(int m, double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(m, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double   x1 = parameters[0].getEstimate();
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double   x4 = parameters[3].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double temp = (i + 1) / 5.0;
double ti   = Math.sin(temp);
double tmp1 = x1 + temp * x2 - Math.exp(temp);
double tmp2 = x3 + ti   * x4 - Math.cos(temp);
jacobian[i] = new double[] {
2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double x4 = parameters[3].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double temp = (i + 1) / 5.0;
double tmp1 = x1 + temp * x2 - Math.exp(temp);
double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);
f[i] = tmp1 * tmp1 + tmp2 * tmp2;
return f;
private static class ChebyquadFunction extends MinpackFunction {
private static double[] buildChebyquadArray(int n, double factor) {
double[] array = new double[n];
double inv = factor / (n + 1);
for (int i = 0; i < n; ++i) {
array[i] = (i + 1) * inv;
return array;
public ChebyquadFunction(int n, int m, double factor,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(m, buildChebyquadArray(n, factor), theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
jacobian[i] = new double[n];
double dx = 1.0 / n;
for (int j = 0; j < n; ++j) {
double tmp1 = 1;
double tmp2 = 2 * parameters[j].getEstimate() - 1;
double temp = 2 * tmp2;
double tmp3 = 0;
double tmp4 = 2;
for (int i = 0; i < m; ++i) {
jacobian[i][j] = dx * tmp4;
double ti = 4 * tmp2 + temp * tmp4 - tmp3;
tmp3 = tmp4;
tmp4 = ti;
ti   = temp * tmp2 - tmp1;
tmp1 = tmp2;
tmp2 = ti;
return jacobian;
protected double[] getResiduals() {
double[] f = new double[m];
for (int j = 0; j < n; ++j) {
double tmp1 = 1;
double tmp2 = 2 * parameters[j].getEstimate() - 1;
double temp = 2 * tmp2;
for (int i = 0; i < m; ++i) {
f[i] += tmp2;
double ti = temp * tmp2 - tmp1;
tmp1 = tmp2;
tmp2 = ti;
double dx = 1.0 / n;
boolean iev = false;
for (int i = 0; i < m; ++i) {
f[i] *= dx;
if (iev) {
f[i] += 1.0 / (i * (i + 2));
iev = ! iev;
return f;
private static class BrownAlmostLinearFunction extends MinpackFunction {
public BrownAlmostLinearFunction(int m, double factor,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(m, buildArray(m, factor), theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
jacobian[i] = new double[n];
double prod = 1;
for (int j = 0; j < n; ++j) {
prod *= parameters[j].getEstimate();
for (int i = 0; i < n; ++i) {
jacobian[i][j] = 1;
jacobian[j][j] = 2;
for (int j = 0; j < n; ++j) {
EstimatedParameter vj = parameters[j];
double temp = vj.getEstimate();
if (temp == 0) {
temp = 1;
prod = 1;
for (int k = 0; k < n; ++k) {
if (k != j) {
prod *= parameters[k].getEstimate();
jacobian[n - 1][j] = prod / temp;
return jacobian;
protected double[] getResiduals() {
double[] f = new double[m];
double sum  = -(n + 1);
double prod = 1;
for (int j = 0; j < n; ++j) {
sum  += parameters[j].getEstimate();
prod *= parameters[j].getEstimate();
for (int i = 0; i < n; ++i) {
f[i] = parameters[i].getEstimate() + sum;
f[n - 1] = prod - 1;
return f;
private static class Osborne1Function extends MinpackFunction {
public Osborne1Function(double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(33, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double   x2 = parameters[1].getEstimate();
double   x3 = parameters[2].getEstimate();
double   x4 = parameters[3].getEstimate();
double   x5 = parameters[4].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double temp = 10.0 * i;
double tmp1 = Math.exp(-temp * x4);
double tmp2 = Math.exp(-temp * x5);
jacobian[i] = new double[] {
-1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2
return jacobian;
protected double[] getResiduals() {
double x1 = parameters[0].getEstimate();
double x2 = parameters[1].getEstimate();
double x3 = parameters[2].getEstimate();
double x4 = parameters[3].getEstimate();
double x5 = parameters[4].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double temp = 10.0 * i;
double tmp1 = Math.exp(-temp * x4);
double tmp2 = Math.exp(-temp * x5);
f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);
return f;
private static final double[] y = {
0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,
0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,
0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406
private static class Osborne2Function extends MinpackFunction {
public Osborne2Function(double[] startParams,
double theoreticalStartCost,
double theoreticalMinCost,
double[] theoreticalMinParams) {
super(65, startParams, theoreticalStartCost,
theoreticalMinCost, theoreticalMinParams);
protected double[][] getJacobian() {
double   x01 = parameters[0].getEstimate();
double   x02 = parameters[1].getEstimate();
double   x03 = parameters[2].getEstimate();
double   x04 = parameters[3].getEstimate();
double   x05 = parameters[4].getEstimate();
double   x06 = parameters[5].getEstimate();
double   x07 = parameters[6].getEstimate();
double   x08 = parameters[7].getEstimate();
double   x09 = parameters[8].getEstimate();
double   x10 = parameters[9].getEstimate();
double   x11 = parameters[10].getEstimate();
double[][] jacobian = new double[m][];
for (int i = 0; i < m; ++i) {
double temp = i / 10.0;
double tmp1 = Math.exp(-x05 * temp);
double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));
double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));
double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));
jacobian[i] = new double[] {
-tmp1,
-tmp2,
-tmp3,
-tmp4,
temp * x01 * tmp1,
x02 * (temp - x09) * (temp - x09) * tmp2,
x03 * (temp - x10) * (temp - x10) * tmp3,
x04 * (temp - x11) * (temp - x11) * tmp4,
-2 * x02 * x06 * (temp - x09) * tmp2,
-2 * x03 * x07 * (temp - x10) * tmp3,
-2 * x04 * x08 * (temp - x11) * tmp4
return jacobian;
protected double[] getResiduals() {
double x01 = parameters[0].getEstimate();
double x02 = parameters[1].getEstimate();
double x03 = parameters[2].getEstimate();
double x04 = parameters[3].getEstimate();
double x05 = parameters[4].getEstimate();
double x06 = parameters[5].getEstimate();
double x07 = parameters[6].getEstimate();
double x08 = parameters[7].getEstimate();
double x09 = parameters[8].getEstimate();
double x10 = parameters[9].getEstimate();
double x11 = parameters[10].getEstimate();
double[] f = new double[m];
for (int i = 0; i < m; ++i) {
double temp = i / 10.0;
double tmp1 = Math.exp(-x05 * temp);
double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));
double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));
double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));
f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);
return f;
private static final double[] y = {
1.366, 1.191, 1.112, 1.013, 0.991,
0.885, 0.831, 0.847, 0.786, 0.725,
0.746, 0.679, 0.608, 0.655, 0.616,
0.606, 0.602, 0.626, 0.651, 0.724,
0.649, 0.649, 0.694, 0.644, 0.624,
0.661, 0.612, 0.558, 0.533, 0.495,
0.500, 0.423, 0.395, 0.375, 0.372,
0.391, 0.396, 0.405, 0.428, 0.429,
0.523, 0.562, 0.607, 0.653, 0.672,
0.708, 0.633, 0.668, 0.645, 0.632,
0.591, 0.559, 0.597, 0.625, 0.739,
0.710, 0.729, 0.720, 0.636, 0.581,
0.428, 0.292, 0.162, 0.098, 0.054
public static Test suite() {
return new TestSuite(MinpackTest.class);
package org.apache.commons.math.estimation;
public class LevenbergMarquardtEstimatorTest
extends TestCase {
public LevenbergMarquardtEstimatorTest(String name) {
super(name);
public void testTrivial() throws EstimationException {
LinearProblem problem =
new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] {2},
new EstimatedParameter[] {
new EstimatedParameter("p0", 0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals(1.5,
problem.getUnboundParameters()[0].getEstimate(),
1.0e-10);
public void testQRColumnsPermutation() throws EstimationException {
EstimatedParameter[] x = {
new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 1.0, -1.0 },
new EstimatedParameter[] { x[0], x[1] },
4.0),
new LinearMeasurement(new double[] { 2.0 },
new EstimatedParameter[] { x[1] },
6.0),
new LinearMeasurement(new double[] { 1.0, -2.0 },
new EstimatedParameter[] { x[0], x[1] },
1.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals(7.0, x[0].getEstimate(), 1.0e-10);
assertEquals(3.0, x[1].getEstimate(), 1.0e-10);
public void testNoDependency() throws EstimationException {
EstimatedParameter[] p = new EstimatedParameter[] {
new EstimatedParameter("p0", 0),
new EstimatedParameter("p1", 0),
new EstimatedParameter("p2", 0),
new EstimatedParameter("p3", 0),
new EstimatedParameter("p4", 0),
new EstimatedParameter("p5", 0)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
for (int i = 0; i < p.length; ++i) {
assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);
public void testOneSet() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 0),
new EstimatedParameter("p1", 0),
new EstimatedParameter("p2", 0)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 1.0 },
new EstimatedParameter[] { p[0] },
1.0),
new LinearMeasurement(new double[] { -1.0, 1.0 },
new EstimatedParameter[] { p[0], p[1] },
1.0),
new LinearMeasurement(new double[] { -1.0, 1.0 },
new EstimatedParameter[] { p[1], p[2] },
1.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals(1.0, p[0].getEstimate(), 1.0e-10);
assertEquals(2.0, p[1].getEstimate(), 1.0e-10);
assertEquals(3.0, p[2].getEstimate(), 1.0e-10);
public void testTwoSets() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 0),
new EstimatedParameter("p1", 1),
new EstimatedParameter("p2", 2),
new EstimatedParameter("p3", 3),
new EstimatedParameter("p4", 4),
new EstimatedParameter("p5", 5)
double epsilon = 1.0e-7;
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },
new EstimatedParameter[] { p[0], p[1], p[3] },
2.0),
new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
-9.0),
new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
2.0),
new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },
new EstimatedParameter[] { p[1], p[2], p[3] },
2.0),
new LinearMeasurement(new double[] { epsilon, 1.0 },
new EstimatedParameter[] { p[4], p[5] },
1.0 + epsilon * epsilon),
new LinearMeasurement(new double[] {  1.0, 1.0 },
new EstimatedParameter[] { p[4], p[5] },
2.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);
assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);
assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);
assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);
assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);
assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);
public void testNonInversible() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 0),
new EstimatedParameter("p1", 0),
new EstimatedParameter("p2", 0)
LinearMeasurement[] m = new LinearMeasurement[] {
new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },
new EstimatedParameter[] { p[0], p[1], p[2] },
1.0),
new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },
new EstimatedParameter[] { p[0], p[1], p[2] },
1.0),
new LinearMeasurement(new double[] { -3.0, -9.0 },
new EstimatedParameter[] { p[0], p[2] },
1.0)
LinearProblem problem = new LinearProblem(m);
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
double initialCost = estimator.getRMS(problem);
estimator.estimate(problem);
assertTrue(estimator.getRMS(problem) < initialCost);
assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);
double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])
+ m[1].getResidual() * m[1].getPartial(p[0])
+ m[2].getResidual() * m[2].getPartial(p[0]));
double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])
+ m[1].getResidual() * m[1].getPartial(p[1]));
double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])
+ m[1].getResidual() * m[1].getPartial(p[2])
+ m[2].getResidual() * m[2].getPartial(p[2]));
assertEquals(0, dJ0, 1.0e-10);
assertEquals(0, dJ1, 1.0e-10);
assertEquals(0, dJ2, 1.0e-10);
public void testIllConditioned() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 0),
new EstimatedParameter("p1", 1),
new EstimatedParameter("p2", 2),
new EstimatedParameter("p3", 3)
LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
32.0),
new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
23.0),
new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
33.0),
new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
31.0)
LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();
estimator1.estimate(problem1);
assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);
assertEquals(1.0, p[0].getEstimate(), 1.0e-10);
assertEquals(1.0, p[1].getEstimate(), 1.0e-10);
assertEquals(1.0, p[2].getEstimate(), 1.0e-10);
assertEquals(1.0, p[3].getEstimate(), 1.0e-10);
LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
32.0),
new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
23.0),
new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
33.0),
new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
31.0)
LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();
estimator2.estimate(problem2);
assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);
assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);
assertEquals(137.0, p[1].getEstimate(), 1.0e-8);
assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);
assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);
public void testMoreEstimatedParametersSimple() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 7),
new EstimatedParameter("p1", 6),
new EstimatedParameter("p2", 5),
new EstimatedParameter("p3", 4)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 3.0, 2.0 },
new EstimatedParameter[] { p[0], p[1] },
7.0),
new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },
new EstimatedParameter[] { p[1], p[2], p[3] },
3.0),
new LinearMeasurement(new double[] { 2.0, 1.0 },
new EstimatedParameter[] { p[0], p[2] },
5.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
public void testMoreEstimatedParametersUnsorted() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 2),
new EstimatedParameter("p1", 2),
new EstimatedParameter("p2", 2),
new EstimatedParameter("p3", 2),
new EstimatedParameter("p4", 2),
new EstimatedParameter("p5", 2)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 1.0, 1.0 },
new EstimatedParameter[] { p[0], p[1] },
3.0),
new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },
new EstimatedParameter[] { p[2], p[3], p[4] },
12.0),
new LinearMeasurement(new double[] { 1.0, -1.0 },
new EstimatedParameter[] { p[4], p[5] },
-1.0),
new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },
new EstimatedParameter[] { p[3], p[2], p[5] },
7.0),
new LinearMeasurement(new double[] { 1.0, -1.0 },
new EstimatedParameter[] { p[4], p[3] },
1.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals(3.0, p[2].getEstimate(), 1.0e-10);
assertEquals(4.0, p[3].getEstimate(), 1.0e-10);
assertEquals(5.0, p[4].getEstimate(), 1.0e-10);
assertEquals(6.0, p[5].getEstimate(), 1.0e-10);
public void testRedundantEquations() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 1),
new EstimatedParameter("p1", 1)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 1.0, 1.0 },
new EstimatedParameter[] { p[0], p[1] },
3.0),
new LinearMeasurement(new double[] { 1.0, -1.0 },
new EstimatedParameter[] { p[0], p[1] },
1.0),
new LinearMeasurement(new double[] { 1.0, 3.0 },
new EstimatedParameter[] { p[0], p[1] },
5.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
assertEquals(2.0, p[0].getEstimate(), 1.0e-10);
assertEquals(1.0, p[1].getEstimate(), 1.0e-10);
public void testInconsistentEquations() throws EstimationException {
EstimatedParameter[] p = {
new EstimatedParameter("p0", 1),
new EstimatedParameter("p1", 1)
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
new LinearMeasurement(new double[] { 1.0, 1.0 },
new EstimatedParameter[] { p[0], p[1] },
3.0),
new LinearMeasurement(new double[] { 1.0, -1.0 },
new EstimatedParameter[] { p[0], p[1] },
1.0),
new LinearMeasurement(new double[] { 1.0, 3.0 },
new EstimatedParameter[] { p[0], p[1] },
4.0)
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(problem);
assertTrue(estimator.getRMS(problem) > 0.1);
public void testCircleFitting() throws EstimationException {
Circle circle = new Circle(98.680, 47.345);
circle.addPoint( 30.0,  68.0);
circle.addPoint( 50.0,  -6.0);
circle.addPoint(110.0, -20.0);
circle.addPoint( 35.0,  15.0);
circle.addPoint( 45.0,  97.0);
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(circle);
assertTrue(estimator.getCostEvaluations() < 10);
assertTrue(estimator.getJacobianEvaluations() < 10);
double rms = estimator.getRMS(circle);
assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);
assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);
assertEquals(96.07590211815305, circle.getX(),      1.0e-10);
assertEquals(48.13516790438953, circle.getY(),      1.0e-10);
public void testCircleFittingBadInit() throws EstimationException {
Circle circle = new Circle(-12, -12);
double[][] points = new double[][] {
for (int i = 0; i < points.length; ++i) {
circle.addPoint(points[i][0], points[i][1]);
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
estimator.estimate(circle);
assertTrue(estimator.getCostEvaluations() < 15);
assertTrue(estimator.getJacobianEvaluations() < 10);
assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);
assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);
assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);
assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);
private static class LinearProblem implements EstimationProblem {
public LinearProblem(LinearMeasurement[] measurements) {
this.measurements = measurements;
public WeightedMeasurement[] getMeasurements() {
return measurements;
public EstimatedParameter[] getUnboundParameters() {
return getAllParameters();
public EstimatedParameter[] getAllParameters() {
HashMap map = new HashMap();
for (int i = 0; i < measurements.length; ++i) {
EstimatedParameter[] parameters = measurements[i].getParameters();
for (int j = 0; j < parameters.length; ++j) {
map.put(parameters[j], null);
Set set = map.keySet();
return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);
private LinearMeasurement[] measurements;
private static class LinearMeasurement extends WeightedMeasurement {
public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,
double setPoint) {
super(1.0, setPoint);
this.factors = factors;
this.parameters = parameters;
public double getTheoreticalValue() {
double v = 0;
for (int i = 0; i < factors.length; ++i) {
v += factors[i] * parameters[i].getEstimate();
return v;
public double getPartial(EstimatedParameter parameter) {
for (int i = 0; i < parameters.length; ++i) {
if (parameters[i] == parameter) {
return factors[i];
return 0;
public EstimatedParameter[] getParameters() {
return parameters;
private double[] factors;
private EstimatedParameter[] parameters;
private static final long serialVersionUID = -3922448707008868580L;
private static class Circle implements EstimationProblem {
public Circle(double cx, double cy) {
this.cx = new EstimatedParameter("cx", cx);
this.cy = new EstimatedParameter("cy", cy);
points  = new ArrayList();
public void addPoint(double px, double py) {
points.add(new PointModel(px, py));
public int getM() {
return points.size();
public WeightedMeasurement[] getMeasurements() {
return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]);
public EstimatedParameter[] getAllParameters() {
return new EstimatedParameter[] { cx, cy };
public EstimatedParameter[] getUnboundParameters() {
return new EstimatedParameter[] { cx, cy };
public double getPartialRadiusX() {
double dRdX = 0;
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
return dRdX / points.size();
public double getPartialRadiusY() {
double dRdY = 0;
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
return dRdY / points.size();
public double getRadius() {
double r = 0;
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
return r / points.size();
public double getX() {
return cx.getEstimate();
public double getY() {
return cy.getEstimate();
private class PointModel extends WeightedMeasurement {
public PointModel(double px, double py) {
super(1.0, 0.0);
this.px = px;
this.py = py;
public double getPartial(EstimatedParameter parameter) {
if (parameter == cx) {
return getPartialDiX() - getPartialRadiusX();
return getPartialDiY() - getPartialRadiusY();
return 0;
public double getCenterDistance() {
double dx = px - cx.getEstimate();
double dy = py - cy.getEstimate();
return Math.sqrt(dx * dx + dy * dy);
public double getPartialDiX() {
return (cx.getEstimate() - px) / getCenterDistance();
public double getPartialDiY() {
return (cy.getEstimate() - py) / getCenterDistance();
public double getTheoreticalValue() {
return getCenterDistance() - getRadius();
private double px;
private double py;
private static final long serialVersionUID = 1L;
private EstimatedParameter cx;
private EstimatedParameter cy;
private ArrayList points;
public static Test suite() {
return new TestSuite(LevenbergMarquardtEstimatorTest.class);
package org.apache.commons.math.estimation;
public class EstimatedParameterTest
extends TestCase {
public EstimatedParameterTest(String name) {
super(name);
public void testConstruction() {
EstimatedParameter p1 = new EstimatedParameter("p1", 1.0);
assertTrue(p1.getName().equals("p1"));
checkValue(p1.getEstimate(), 1.0);
assertTrue(! p1.isBound());
EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true);
assertTrue(p2.getName().equals("p2"));
checkValue(p2.getEstimate(), 2.0);
assertTrue(p2.isBound());
public void testBound() {
EstimatedParameter p = new EstimatedParameter("p", 0.0);
assertTrue(! p.isBound());
p.setBound(true);
assertTrue(p.isBound());
p.setBound(false);
assertTrue(! p.isBound());
public void testEstimate() {
EstimatedParameter p = new EstimatedParameter("p", 0.0);
checkValue(p.getEstimate(), 0.0);
for (double e = 0.0; e < 10.0; e += 0.5) {
p.setEstimate(e);
checkValue(p.getEstimate(), e);
public static Test suite() {
return new TestSuite(EstimatedParameterTest.class);
private void checkValue(double value, double expected) {
assertTrue(Math.abs(value - expected) < 1.0e-10);
package org.apache.commons.math.estimation;
public class WeightedMeasurementTest
extends TestCase {
public WeightedMeasurementTest(String name) {
super(name);
p1 = null;
p2 = null;
public void testConstruction() {
WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);
checkValue(m.getWeight(), 3.0);
checkValue(m.getMeasuredValue(), theoretical() + 0.1);
public void testIgnored() {
WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);
assertTrue(!m.isIgnored());
m.setIgnored(true);
assertTrue(m.isIgnored());
m.setIgnored(false);
assertTrue(!m.isIgnored());
public void testTheory() {
WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);
checkValue(m.getTheoreticalValue(), theoretical());
checkValue(m.getResidual(), 0.1);
double oldP1 = p1.getEstimate();
p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));
checkValue(m.getResidual(), 0.0);
p1.setEstimate(oldP1);
checkValue(m.getResidual(), 0.1);
double oldP2 = p2.getEstimate();
p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));
checkValue(m.getResidual(), 0.0);
p2.setEstimate(oldP2);
checkValue(m.getResidual(), 0.1);
public static Test suite() {
return new TestSuite(WeightedMeasurementTest.class);
public void setUp() {
p1 = new EstimatedParameter("p1", 1.0);
p2 = new EstimatedParameter("p2", 2.0);
public void tearDown() {
p1 = null;
p2 = null;
private void checkValue(double value, double expected) {
assertTrue(Math.abs(value - expected) < 1.0e-10);
private double theoretical() {
return 3 * p1.getEstimate() - p2.getEstimate();
private double partial(EstimatedParameter p) {
if (p == p1) {
return 3.0;
return -1.0;
return 0.0;
private static class MyMeasurement
extends WeightedMeasurement {
public MyMeasurement(double weight, double measuredValue,
WeightedMeasurementTest testInstance) {
super(weight, measuredValue);
this.testInstance = testInstance;
public double getTheoreticalValue() {
return testInstance.theoretical();
public double getPartial(EstimatedParameter p) {
return testInstance.partial(p);
private transient WeightedMeasurementTest testInstance;
private static final long serialVersionUID = -246712922500792332L;
private EstimatedParameter p1;
private EstimatedParameter p2;
package org.apache.commons.math;
public class MathConfigurationExceptionTest extends TestCase {
public void testConstructor(){
MathConfigurationException ex = new MathConfigurationException();
assertNull(ex.getCause());
assertNull(ex.getMessage());
assertNull(ex.getMessage(Locale.FRENCH));
public void testConstructorPatternArguments(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
MathConfigurationException ex = new MathConfigurationException(pattern, arguments);
assertNull(ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testConstructorCause(){
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
MathConfigurationException ex = new MathConfigurationException(cause);
assertEquals(cause, ex.getCause());
public void testConstructorPatternArgumentsCause(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);
assertEquals(cause, ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math;
public class ConvergenceExceptionTest extends TestCase {
public void testConstructor(){
ConvergenceException ex = new ConvergenceException();
assertNull(ex.getCause());
assertNotNull(ex.getMessage());
assertNotNull(ex.getMessage(Locale.FRENCH));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testConstructorPatternArguments(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
ConvergenceException ex = new ConvergenceException(pattern, arguments);
assertNull(ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
public void testConstructorCause(){
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
ConvergenceException ex = new ConvergenceException(cause);
assertEquals(cause, ex.getCause());
public void testConstructorPatternArgumentsCause(){
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
Object[] arguments = { new Integer(6), new Integer(4) };
String inMsg = "inner message";
Exception cause = new Exception(inMsg);
ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);
assertEquals(cause, ex.getCause());
assertEquals(pattern, ex.getPattern());
assertEquals(arguments.length, ex.getArguments().length);
for (int i = 0; i < arguments.length; ++i) {
assertEquals(arguments[i], ex.getArguments()[i]);
assertFalse(pattern.equals(ex.getMessage()));
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math;
public class ArgumentOutsideDomainExceptionTest extends TestCase {
public void testConstructor(){
ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);
assertNull(ex.getCause());
assertNotNull(ex.getMessage());
assertTrue(ex.getMessage().indexOf("3.14") > 0);
assertEquals(Math.PI, ex.getArgument(), 0);
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math.geometry;
public class RotationTest
extends TestCase {
public RotationTest(String name) {
super(name);
public void testIdentity() {
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkAngle(r.getAngle(), 0);
r = new Rotation(-1, 0, 0, 0, false);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkAngle(r.getAngle(), 0);
r = new Rotation(42, 0, 0, 0, true);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkAngle(r.getAngle(), 0);
public void testAxisAngle() {
Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
double s = 1 / Math.sqrt(3);
checkVector(r.getAxis(), new Vector3D(s, s, s));
checkAngle(r.getAngle(), 2 * Math.PI / 3);
new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);
fail("an exception should have been thrown");
fail("unexpected exception");
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
checkVector(r.getAxis(), new Vector3D(0, 0, -1));
checkAngle(r.getAngle(), 0.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkAngle(r.getAngle(), Math.PI);
public void testVectorOnePair() {
Vector3D u = new Vector3D(3, 2, 1);
Vector3D v = new Vector3D(-4, 2, 2);
Rotation r = new Rotation(u, v);
checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));
checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);
public void testVectorTwoPairs() {
Vector3D u1 = new Vector3D(3, 0, 0);
Vector3D u2 = new Vector3D(0, 5, 0);
Vector3D v1 = new Vector3D(0, 0, 2);
Vector3D v2 = new Vector3D(-2, 0, 2);
Rotation r = new Rotation(u1, u2, v1, v2);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
r = new Rotation(u1, u2, u1.negate(), u2.negate());
Vector3D axis = r.getAxis();
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
checkAngle(r.getAngle(), Math.PI);
public void testMatrix()
throws NotARotationMatrixException {
double[][] m1 = { { 0.0, 1.0, 0.0 },
Rotation r = new Rotation(m1, 1.0e-7);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
double[][] m2 = { { 0.83203, -0.55012, -0.07139 },
r = new Rotation(m2, 1.0e-12);
double[][] m3 = r.getMatrix();
double d00 = m2[0][0] - m3[0][0];
double d01 = m2[0][1] - m3[0][1];
double d02 = m2[0][2] - m3[0][2];
double d10 = m2[1][0] - m3[1][0];
double d11 = m2[1][1] - m3[1][1];
double d12 = m2[1][2] - m3[1][2];
double d20 = m2[2][0] - m3[2][0];
double d21 = m2[2][1] - m3[2][1];
double d22 = m2[2][2] - m3[2][2];
assertTrue(Math.abs(d00) < 6.0e-6);
assertTrue(Math.abs(d01) < 6.0e-6);
assertTrue(Math.abs(d02) < 6.0e-6);
assertTrue(Math.abs(d10) < 6.0e-6);
assertTrue(Math.abs(d11) < 6.0e-6);
assertTrue(Math.abs(d12) < 6.0e-6);
assertTrue(Math.abs(d20) < 6.0e-6);
assertTrue(Math.abs(d21) < 6.0e-6);
assertTrue(Math.abs(d22) < 6.0e-6);
assertTrue(Math.abs(d00) > 4.0e-7);
assertTrue(Math.abs(d01) > 4.0e-7);
assertTrue(Math.abs(d02) > 4.0e-7);
assertTrue(Math.abs(d10) > 4.0e-7);
assertTrue(Math.abs(d11) > 4.0e-7);
assertTrue(Math.abs(d12) > 4.0e-7);
assertTrue(Math.abs(d20) > 4.0e-7);
assertTrue(Math.abs(d21) > 4.0e-7);
assertTrue(Math.abs(d22) > 4.0e-7);
for (int i = 0; i < 3; ++i) {
for (int j = 0; j < 3; ++j) {
double m3tm3 = m3[i][0] * m3[j][0]
+ m3[i][1] * m3[j][1]
+ m3[i][2] * m3[j][2];
if (i == j) {
assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);
assertTrue(Math.abs(m3tm3) < 1.0e-10);
checkVector(r.applyTo(Vector3D.plusI),
new Vector3D(m3[0][0], m3[1][0], m3[2][0]));
checkVector(r.applyTo(Vector3D.plusJ),
new Vector3D(m3[0][1], m3[1][1], m3[2][1]));
checkVector(r.applyTo(Vector3D.plusK),
new Vector3D(m3[0][2], m3[1][2], m3[2][2]));
double[][] m4 = { { 1.0,  0.0,  0.0 },
r = new Rotation(m4, 1.0e-7);
checkAngle(r.getAngle(), Math.PI);
double[][] m5 = { { 0.0, 0.0, 1.0 },
r = new Rotation(m5, 1.0e-7);
fail("got " + r + ", should have caught an exception");
fail("wrong exception caught");
public void testAngles()
throws CardanEulerSingularityException {
RotationOrder[] CardanOrders = {
RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
RotationOrder[] EulerOrders = {
RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
for (int i = 0; i < CardanOrders.length; ++i) {
for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {
for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {
for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {
Rotation r = new Rotation(CardanOrders[i],
alpha1, alpha2, alpha3);
double[] angles = r.getAngles(CardanOrders[i]);
checkAngle(angles[0], alpha1);
checkAngle(angles[1], alpha2);
checkAngle(angles[2], alpha3);
for (int i = 0; i < EulerOrders.length; ++i) {
for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {
for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {
for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {
Rotation r = new Rotation(EulerOrders[i],
alpha1, alpha2, alpha3);
double[] angles = r.getAngles(EulerOrders[i]);
checkAngle(angles[0], alpha1);
checkAngle(angles[1], alpha2);
checkAngle(angles[2], alpha3);
public void testQuaternion() {
Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);
double n = 23.5;
Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),
n * r1.getQ2(), n * r1.getQ3(),
true);
for (double x = -0.9; x < 0.9; x += 0.2) {
for (double y = -0.9; y < 0.9; y += 0.2) {
for (double z = -0.9; z < 0.9; z += 0.2) {
Vector3D u = new Vector3D(x, y, z);
checkVector(r2.applyTo(u), r1.applyTo(u));
public void testCompose() {
Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);
Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);
Rotation r3 = r2.applyTo(r1);
for (double x = -0.9; x < 0.9; x += 0.2) {
for (double y = -0.9; y < 0.9; y += 0.2) {
for (double z = -0.9; z < 0.9; z += 0.2) {
Vector3D u = new Vector3D(x, y, z);
checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));
public void testComposeInverse() {
Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);
Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);
Rotation r3 = r2.applyInverseTo(r1);
for (double x = -0.9; x < 0.9; x += 0.2) {
for (double y = -0.9; y < 0.9; y += 0.2) {
for (double z = -0.9; z < 0.9; z += 0.2) {
Vector3D u = new Vector3D(x, y, z);
checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));
public void testApplyInverseTo() {
Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);
for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
for (double phi = -1.55; phi < 1.55; phi += 0.2) {
Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),
Math.sin(lambda) * Math.cos(phi),
Math.sin(phi));
r.applyInverseTo(r.applyTo(u));
checkVector(u, r.applyInverseTo(r.applyTo(u)));
checkVector(u, r.applyTo(r.applyInverseTo(u)));
r = new Rotation();
for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
for (double phi = -1.55; phi < 1.55; phi += 0.2) {
Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),
Math.sin(lambda) * Math.cos(phi),
Math.sin(phi));
checkVector(u, r.applyInverseTo(r.applyTo(u)));
checkVector(u, r.applyTo(r.applyInverseTo(u)));
r = new Rotation(Vector3D.plusK, Math.PI);
for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
for (double phi = -1.55; phi < 1.55; phi += 0.2) {
Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),
Math.sin(lambda) * Math.cos(phi),
Math.sin(phi));
checkVector(u, r.applyInverseTo(r.applyTo(u)));
checkVector(u, r.applyTo(r.applyInverseTo(u)));
private void checkVector(Vector3D v1, Vector3D v2) {
assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);
private void checkAngle(double a1, double a2) {
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
public static Test suite() {
return new TestSuite(RotationTest.class);
package org.apache.commons.math.geometry;
public class Vector3DTest
extends TestCase {
public Vector3DTest(String name) {
super(name);
public void testCoordinates() {
Vector3D v = new Vector3D(1, 2, 3);
assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);
assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);
assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);
public void testNorm() {
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))
< 1.0e-12);
public void testSubtract() {
Vector3D v1 = new Vector3D(1, 2, 3);
Vector3D v2 = new Vector3D(-3, -2, -1);
v1 = v1.subtract(v2);
checkVector(v1, new Vector3D(4, 4, 4));
checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));
public void testAdd() {
Vector3D v1 = new Vector3D(1, 2, 3);
Vector3D v2 = new Vector3D(-3, -2, -1);
v1 = v1.add(v2);
checkVector(v1, new Vector3D(-2, 0, 2));
checkVector(v2.add(v1), new Vector3D(-5, -2, 1));
public void testScalarProduct() {
Vector3D v = new Vector3D(1, 2, 3);
v = v.multiply(3);
checkVector(v, new Vector3D(3, 6, 9));
checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));
public void testVectorialProducts() {
Vector3D v1 = new Vector3D(2, 1, -4);
Vector3D v2 = new Vector3D(3, 1, -1);
assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);
Vector3D v3 = Vector3D.crossProduct(v1, v2);
checkVector(v3, new Vector3D(3, -10, -1));
assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);
assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);
public void testAngular() {
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
Vector3D u = new Vector3D(-1, 1, -1);
assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);
assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);
public void testAngularSeparation() {
Vector3D v1 = new Vector3D(2, -1, 4);
Vector3D  k = v1.normalize();
Vector3D  i = k.orthogonal();
Vector3D v2 = k.multiply(Math.cos(1.2)).add(i.multiply(Math.sin(1.2)));
assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);
private void checkVector(Vector3D v1, Vector3D v2) {
assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);
public static Test suite() {
return new TestSuite(Vector3DTest.class);
package org.apache.commons.math;
public class DuplicateSampleAbscissaExceptionTest extends TestCase {
public void testConstructor(){
DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);
assertNull(ex.getCause());
assertNotNull(ex.getMessage());
assertTrue(ex.getMessage().indexOf("1.2") > 0);
assertEquals(1.2, ex.getDuplicateAbscissa(), 0);
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
package org.apache.commons.math.random;
public class RandomAdaptorTest extends RandomDataTest {
public RandomAdaptorTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(RandomAdaptorTest.class);
suite.setName("RandomAdaptor Tests");
return suite;
public void testAdaptor() {
ConstantGenerator generator = new ConstantGenerator();
Random random = RandomAdaptor.createAdaptor(generator);
checkConstant(random);
RandomAdaptor randomAdaptor = new RandomAdaptor(generator);
checkConstant(randomAdaptor); 
private void checkConstant(Random random) {
byte[] bytes = new byte[] {0};
random.nextBytes(bytes);
assertEquals(0, bytes[0]);  
assertEquals(false, random.nextBoolean());
assertEquals(0, random.nextDouble(), 0);
assertEquals(0, random.nextFloat(), 0);
assertEquals(0, random.nextGaussian(), 0);
assertEquals(0, random.nextInt());
assertEquals(0, random.nextInt(1));
assertEquals(0, random.nextLong());
random.setSeed(100);
assertEquals(0, random.nextDouble(), 0);
private static class ConstantGenerator implements RandomGenerator {
public boolean nextBoolean() {
return false;
public void nextBytes(byte[] bytes) {
public double nextDouble() {
return 0;
public float nextFloat() {
return 0;
public double nextGaussian() {
return 0;
public int nextInt() {
return 0;
public int nextInt(int n) {
return 0;
public long nextLong() {
return 0;
public void setSeed(long seed) {
package org.apache.commons.math.random;
public class AbstractRandomGeneratorTest extends RandomDataTest {
protected TestRandomGenerator testGenerator = new TestRandomGenerator();
public AbstractRandomGeneratorTest(String name) {
super(name);
randomData = new RandomDataImpl(testGenerator);
public static Test suite() {
TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);
suite.setName("AbstractRandomGenerator Tests");
return suite;
public void testNextInt() {
testGenerator.nextInt(-1);
fail("IllegalArgumentException expected");
Frequency freq = new Frequency();
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
value = testGenerator.nextInt(4);
assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextLong() {
long q1 = Long.MAX_VALUE/4;
long q2 = 2 *  q1;
long q3 = 3 * q1;
Frequency freq = new Frequency();
long val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextLong();
if (val < q1) {
value = 0;
value = 1;
value = 2;
value = 3;
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextBoolean() {
long halfSampleSize = smallSampleSize / 2; 
double[] expected = {halfSampleSize, halfSampleSize};
long[] observed = new long[2];
for (int i=0; i<smallSampleSize; i++) {
if (testGenerator.nextBoolean()) {
observed[0]++;
observed[1]++;
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 10.828);    
public void testNextFloat() {
Frequency freq = new Frequency();
float val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextFloat();
if (val < 0.25) {
value = 0;
value = 1;
value = 2;
value = 3;
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
package org.apache.commons.math.random;
public final class ValueServerTest extends RetryTestCase {
private ValueServer vs = new ValueServer();
public ValueServerTest(String name) {
super(name);
public void setUp() {
vs.setMode(ValueServer.DIGEST_MODE);
URL url = getClass().getResource("testData.txt");
vs.setValuesFileURL(url); 
fail("malformed test URL");
public static Test suite() {
TestSuite suite = new TestSuite(ValueServerTest.class);
suite.setName("ValueServer Tests");
return suite;
public void testNextDigest() throws Exception{
double next = 0.0;
double tolerance = 0.1;
vs.computeDistribution();
assertTrue("empirical distribution property", 
vs.getEmpiricalDistribution() != null);
SummaryStatistics stats = SummaryStatistics.newInstance();
for (int i = 1; i < 1000; i++) {
next = vs.getNext();
stats.addValue(next);
assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);
assertEquals
("std dev", 1.0173699343977738, stats.getStandardDeviation(), 
tolerance);
vs.computeDistribution(500);
stats = SummaryStatistics.newInstance();
for (int i = 1; i < 1000; i++) {
next = vs.getNext();
stats.addValue(next);
assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);
assertEquals
("std dev", 1.0173699343977738, stats.getStandardDeviation(), 
tolerance);
public void testNextDigestFail() throws Exception {
vs.getNext();
fail("Expecting IllegalStateException");
public void testReplay() throws Exception {
double firstDataValue = 4.038625496201205;
double secondDataValue = 3.6485326248346936;
double tolerance = 10E-15;
double compareValue = 0.0d;
vs.setMode(ValueServer.REPLAY_MODE);
vs.resetReplayFile();
compareValue = vs.getNext();
assertEquals(compareValue,firstDataValue,tolerance);
compareValue = vs.getNext();
assertEquals(compareValue,secondDataValue,tolerance);
for (int i = 3; i < 1001; i++) {
compareValue = vs.getNext();
compareValue = vs.getNext();
assertEquals(compareValue,firstDataValue,tolerance);
compareValue = vs.getNext();
assertEquals(compareValue,secondDataValue,tolerance);
vs.closeReplayFile();
vs.closeReplayFile();
public void testModes() throws Exception {
vs.setMode(ValueServer.CONSTANT_MODE);
vs.setMu(0);
assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);
vs.setMode(ValueServer.UNIFORM_MODE);
vs.setMu(2);
double val = vs.getNext();
assertTrue(val > 0 && val < 4);
vs.setSigma(1);
vs.setMode(ValueServer.GAUSSIAN_MODE);
val = vs.getNext();
assertTrue("gaussian value close enough to mean",
val < vs.getMu() + 100*vs.getSigma());
vs.setMode(ValueServer.EXPONENTIAL_MODE);
val = vs.getNext();
assertTrue(val > 0);
vs.setMode(1000);
vs.getNext();
fail("bad mode, expecting IllegalStateException");
public void testFill() throws Exception {
vs.setMode(ValueServer.CONSTANT_MODE);
vs.setMu(2);
double[] val = new double[5];
vs.fill(val);
for (int i = 0; i < 5; i++) {
assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);
double v2[] = vs.fill(3);
for (int i = 0; i < 3; i++) {
assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);
public void testProperties() throws Exception {
vs.setMode(ValueServer.CONSTANT_MODE);
assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());
vs.setValuesFileURL("http://www.apache.org");
URL url = vs.getValuesFileURL();
assertEquals("valuesFileURL test","http://www.apache.org",url.toString());
package org.apache.commons.math.random;
public class UniformRandomGeneratorTest
extends TestCase {
public UniformRandomGeneratorTest(String name) {
super(name);
public void testMeanAndStandardDeviation() {
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(17399225432l);
UniformRandomGenerator generator = new UniformRandomGenerator(rg);
double[] sample = new double[10000];
for (int i = 0; i < sample.length; ++i) {
sample[i] = generator.nextNormalizedDouble();
assertEquals(0.0, StatUtils.mean(sample), 0.07);
assertEquals(1.0, StatUtils.variance(sample), 0.02);
public static Test suite() {
return new TestSuite(UniformRandomGeneratorTest.class);
package org.apache.commons.math.random;
public class GaussianRandomGeneratorTest
extends TestCase {
public GaussianRandomGeneratorTest(String name) {
super(name);
public void testMeanAndStandardDeviation() {
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(17399225432l);
GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);
double[] sample = new double[10000];
for (int i = 0; i < sample.length; ++i) {
sample[i] = generator.nextNormalizedDouble();
assertEquals(0.0, StatUtils.mean(sample), 0.012);
assertEquals(1.0, StatUtils.variance(sample), 0.01);
public static Test suite() {
return new TestSuite(GaussianRandomGeneratorTest.class);
package org.apache.commons.math.random;
public class UncorrelatedRandomVectorGeneratorTest
extends TestCase {
public UncorrelatedRandomVectorGeneratorTest(String name) {
super(name);
mean = null;
standardDeviation = null;
generator = null;
public void testMeanAndCorrelation() throws DimensionMismatchException {
VectorialMean meanStat = new VectorialMean(mean.length);
VectorialCovariance covStat = new VectorialCovariance(mean.length);
for (int i = 0; i < 10000; ++i) {
double[] v = generator.nextVector();
meanStat.increment(v);
covStat.increment(v);
double[] estimatedMean = meanStat.getResult();
double scale;
RealMatrix estimatedCorrelation = covStat.getResult();
for (int i = 0; i < estimatedMean.length; ++i) {
assertEquals(mean[i], estimatedMean[i], 0.07);
for (int j = 0; j < i; ++j) {
scale = standardDeviation[i] * standardDeviation[j];
assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);
scale = standardDeviation[i] * standardDeviation[i];
assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);
public void setUp() {
mean              = new double[] {0.0, 1.0, -3.0, 2.3};
standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(17399225432l);
generator =
new UncorrelatedRandomVectorGenerator(mean, standardDeviation,
new GaussianRandomGenerator(rg));
public void tearDown() {
mean = null;
standardDeviation = null;
generator = null;
public static Test suite() {
return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);
private double[] mean;
private double[] standardDeviation;
private UncorrelatedRandomVectorGenerator generator;
package org.apache.commons.math.random;
public class TestRandomGenerator extends AbstractRandomGenerator {
private Random random = new Random();
public void setSeed(long seed) {
clear();
random.setSeed(seed);
public double nextDouble() {
return random.nextDouble();
package org.apache.commons.math.random;
public class CorrelatedRandomVectorGeneratorTest
extends TestCase {
public CorrelatedRandomVectorGeneratorTest(String name) {
super(name);
mean       = null;
covariance = null;
generator  = null;
public void testRank() {
assertEquals(3, generator.getRank());
public void testRootMatrix() {
RealMatrix b = generator.getRootMatrix();
RealMatrix bbt = b.multiply(b.transpose());
for (int i = 0; i < covariance.getRowDimension(); ++i) {
for (int j = 0; j < covariance.getColumnDimension(); ++j) {
assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);
public void testMeanAndCovariance() throws DimensionMismatchException {
VectorialMean meanStat = new VectorialMean(mean.length);
VectorialCovariance covStat = new VectorialCovariance(mean.length);
for (int i = 0; i < 5000; ++i) {
double[] v = generator.nextVector();
meanStat.increment(v);
covStat.increment(v);
double[] estimatedMean = meanStat.getResult();
RealMatrix estimatedCovariance = covStat.getResult();
for (int i = 0; i < estimatedMean.length; ++i) {
assertEquals(mean[i], estimatedMean[i], 0.07);
for (int j = 0; j <= i; ++j) {
assertEquals(covariance.getEntry(i, j),
estimatedCovariance.getEntry(i, j),
0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));
public void setUp() {
mean = new double[] { 0.0, 1.0, -3.0, 2.3};
RealMatrixImpl b = new RealMatrixImpl(4, 3);
double[][] bData = b.getDataRef();
int counter = 0;
for (int i = 0; i < bData.length; ++i) {
double[] bi = bData[i];
for (int j = 0; j < b.getColumnDimension(); ++j) {
bi[j] = 1.0 + 0.1 * ++counter;
RealMatrix bbt = b.multiply(b.transpose());
covariance = new RealMatrixImpl(mean.length, mean.length);
double[][] covData = covariance.getDataRef();
for (int i = 0; i < covariance.getRowDimension(); ++i) {
covData[i][i] = bbt.getEntry(i, i);
for (int j = 0; j < covariance.getColumnDimension(); ++j) {
double s = bbt.getEntry(i, j);
covData[i][j] = s;
covData[j][i] = s;
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(17399225432l);
GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);
generator = new CorrelatedRandomVectorGenerator(mean,
covariance,
1.0e-12 * covariance.getNorm(),
rawGenerator);
fail(e.getMessage());
fail("not positive definite matrix");
public void tearDown() {
mean       = null;
covariance = null;
generator  = null;
public static Test suite() {
return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);
private double[] mean;
private RealMatrixImpl covariance;
private CorrelatedRandomVectorGenerator generator;
package org.apache.commons.math.random;
public final class EmpiricalDistributionTest extends RetryTestCase {
protected EmpiricalDistribution empiricalDistribution = null;
protected EmpiricalDistribution empiricalDistribution2 = null;
protected File file = null;
protected URL url = null; 
protected double[] dataArray = null;
public EmpiricalDistributionTest(String name) {
super(name);
public void setUp() throws IOException {
empiricalDistribution = new EmpiricalDistributionImpl(100);
url = getClass().getResource("testData.txt");
empiricalDistribution2 = new EmpiricalDistributionImpl(100);
BufferedReader in = 
new BufferedReader(new InputStreamReader(
url.openStream()));
String str = null;
ArrayList list = new ArrayList();
while ((str = in.readLine()) != null) {
list.add(Double.valueOf(str));
in.close();
in = null;
dataArray = new double[list.size()];
int i = 0;
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
i++;
public static Test suite() {
TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);
suite.setName("EmpiricalDistribution Tests");
return suite;
public void testLoad() throws Exception {
empiricalDistribution.load(url);   
assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);
assertEquals
(empiricalDistribution.getSampleStats().getMean(),
5.069831575018909,10E-7);
assertEquals
(empiricalDistribution.getSampleStats().getStandardDeviation(),
1.0173699343977738,10E-7);
public void testDoubleLoad() throws Exception {
empiricalDistribution2.load(dataArray);   
assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);
assertEquals
(empiricalDistribution2.getSampleStats().getMean(),
5.069831575018909,10E-7);
assertEquals
(empiricalDistribution2.getSampleStats().getStandardDeviation(),
1.0173699343977738,10E-7);
double[] bounds = empiricalDistribution2.getUpperBounds();
assertEquals(bounds.length, 100);
assertEquals(bounds[99], 1.0, 10e-12);
public void testNext() throws Exception {
tstGen(0.1);
tstDoubleGen(0.1);
public void testNexFail() {
empiricalDistribution.getNextValue();
empiricalDistribution2.getNextValue();
fail("Expecting IllegalStateException");
public void testGridTooFine() throws Exception {
empiricalDistribution = new EmpiricalDistributionImpl(1001);
tstGen(0.1);    
empiricalDistribution2 = new EmpiricalDistributionImpl(1001);           
tstDoubleGen(0.1);
public void testGridTooFat() throws Exception {
empiricalDistribution = new EmpiricalDistributionImpl(1);
tstGen(5); // ridiculous tolerance; but ridiculous grid size
empiricalDistribution2 = new EmpiricalDistributionImpl(1);           
tstDoubleGen(5);           
public void testBinIndexOverflow() throws Exception {
double[] x = new double[] {9474.94326071674, 2080107.8865462579};
new EmpiricalDistributionImpl().load(x);
public void testSerialization() {
EmpiricalDistribution dist = new EmpiricalDistributionImpl();
EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);
verifySame(dist, dist2);
empiricalDistribution2.load(dataArray);   
dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);
verifySame(empiricalDistribution2, dist2);
private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {
assertEquals(d1.isLoaded(), d2.isLoaded());
assertEquals(d1.getBinCount(), d2.getBinCount());
assertEquals(d1.getSampleStats(), d2.getSampleStats());
if (d1.isLoaded()) {
for (int i = 0;  i < d1.getUpperBounds().length; i++) {
assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);
assertEquals(d1.getBinStats(), d2.getBinStats());
private void tstGen(double tolerance)throws Exception {
empiricalDistribution.load(url);   
SummaryStatistics stats = SummaryStatistics.newInstance();
for (int i = 1; i < 1000; i++) {
stats.addValue(empiricalDistribution.getNextValue());
assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);
assertEquals
("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);
private void tstDoubleGen(double tolerance)throws Exception {
empiricalDistribution2.load(dataArray);   
SummaryStatistics stats = SummaryStatistics.newInstance();
for (int i = 1; i < 1000; i++) {
stats.addValue(empiricalDistribution2.getNextValue());
assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);
assertEquals
("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);
package org.apache.commons.math.random;
public class RandomDataTest extends RetryTestCase {
public RandomDataTest(String name) {
super(name);
randomData = new RandomDataImpl();
protected long smallSampleSize = 1000;
protected double[] expected = {250,250,250,250};
protected int largeSampleSize = 10000;
private String[] hex = 
protected RandomDataImpl randomData = null; 
protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();
public void setUp() { 
public static Test suite() {
TestSuite suite = new TestSuite(RandomDataTest.class);
suite.setName("RandomData Tests");
return suite;
public void testNextIntExtremeValues() {
int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);
int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);
assertFalse(x == y);
public void testNextLongExtremeValues() {
long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);
long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);
assertFalse(x == y);
public void testNextInt() {
randomData.nextInt(4,3);
fail("IllegalArgumentException expected");
Frequency freq = new Frequency();
int value = 0;
for (int i=0;i<smallSampleSize;i++) {
value = randomData.nextInt(0,3);
assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextLong() {
randomData.nextLong(4,3);
fail("IllegalArgumentException expected");
Frequency freq = new Frequency();
long value = 0;
for (int i=0;i<smallSampleSize;i++) {
value = randomData.nextLong(0,3);
assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextSecureLong() {
randomData.nextSecureLong(4,3);
fail("IllegalArgumentException expected");
Frequency freq = new Frequency();
long value = 0;
for (int i=0;i<smallSampleSize;i++) {
value = randomData.nextSecureLong(0,3);
assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextSecureInt() {
randomData.nextSecureInt(4,3);
fail("IllegalArgumentException expected");
Frequency freq = new Frequency();
int value = 0;
for (int i=0;i<smallSampleSize;i++) {
value = randomData.nextSecureInt(0,3);
assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);  
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);    
public void testNextPoisson() {
randomData.nextPoisson(0);
fail("zero mean -- expecting IllegalArgumentException");
Frequency f = new Frequency();
for (int i = 0; i<largeSampleSize; i++) {
f.addValue(randomData.nextPoisson(4.0d));
fail(ex.getMessage());
long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) + 
f.getCount(3) + f.getCount(4) + f.getCount(5);
long sumFreq = f.getSumFreq();
double cumPct = 
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);
randomData.nextPoisson(-1);
fail("negative mean supplied -- IllegalArgumentException expected");
randomData.nextPoisson(0);
fail("0 mean supplied -- IllegalArgumentException expected");
public void testNextHex() {
randomData.nextHexString(-1);
fail("negative length supplied -- IllegalArgumentException expected");
randomData.nextHexString(0);
fail("zero length supplied -- IllegalArgumentException expected");
String hexString = randomData.nextHexString(3);
if (hexString.length() != 3) {
fail("incorrect length for generated string");
hexString = randomData.nextHexString(1);
if (hexString.length() != 1) {
fail("incorrect length for generated string");
hexString = randomData.nextHexString(0);
fail("zero length requested -- expecting IllegalArgumentException");
if (hexString.length() != 1) {
fail("incorrect length for generated string");
Frequency f = new Frequency();
for (int i = 0; i < smallSampleSize; i++) {
hexString = randomData.nextHexString(100);
if (hexString.length() != 100) {
fail("incorrect length for generated string");
for (int j = 0; j < hexString.length(); j++) {
f.addValue(hexString.substring(j,j+1));
double[] expected = new double[16];
long[] observed = new long[16];
for (int i = 0; i < 16; i++) {
expected[i] = (double)smallSampleSize*100/(double)16;
observed[i] = f.getCount(hex[i]);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 37.70);    
public void testNextSecureHex() {
randomData.nextSecureHexString(-1);
fail("negative length -- IllegalArgumentException expected");
randomData.nextSecureHexString(0);
fail("zero length -- IllegalArgumentException expected");
String hexString = randomData.nextSecureHexString(3);
if (hexString.length() != 3) {
fail("incorrect length for generated string");
hexString = randomData.nextSecureHexString(1);
if (hexString.length() != 1) {
fail("incorrect length for generated string");
hexString = randomData.nextSecureHexString(0);
fail("zero length requested -- expecting IllegalArgumentException");
if (hexString.length() != 1) {
fail("incorrect length for generated string");
Frequency f = new Frequency();
for (int i = 0; i < smallSampleSize; i++) {
hexString = randomData.nextSecureHexString(100);
if (hexString.length() != 100) {
fail("incorrect length for generated string");
for (int j = 0; j < hexString.length(); j++) {
f.addValue(hexString.substring(j,j+1));
double[] expected = new double[16];
long[] observed = new long[16];
for (int i = 0; i < 16; i++) {
expected[i] = (double)smallSampleSize*100/(double)16;
observed[i] = f.getCount(hex[i]);
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 37.70);    
public void testNextUniform() {    
randomData.nextUniform(4,3);
fail("IllegalArgumentException expected");
randomData.nextUniform(3,3);
fail("IllegalArgumentException expected");
double[] expected = {500,500};
long[] observed = {0,0};
double lower = -1d;
double upper = 20d;
double midpoint = (lower + upper)/2d;
double result = 0;
for (int i = 0; i < 1000; i++) {
result = randomData.nextUniform(lower,upper);
if ((result == lower) || (result == upper)) {
fail("generated value equal to an endpoint: " + result);
if (result < midpoint) {
observed[0]++;
observed[1]++;
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 10.83);  
public void testNextUniformExclusiveEndpoints() {
for (int i = 0; i < 1000; i++) {
double u = randomData.nextUniform(0.99, 1);
assertTrue(u > 0.99 && u < 1);
public void testNextGaussian() { 
randomData.nextGaussian(0,0);
fail("zero sigma -- IllegalArgumentException expected");
SummaryStatistics u = SummaryStatistics.newInstance();
for (int i = 0; i<largeSampleSize; i++) {
u.addValue(randomData.nextGaussian(0,1));
double xbar = u.getMean();
double s = u.getStandardDeviation();
double n = (double) u.getN(); 
assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);
public void testNextExponential() {
randomData.nextExponential(-1);
fail("negative mean -- expecting IllegalArgumentException");
assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8); 
long cumFreq = 0;
double v = 0;
for (int i = 0; i < largeSampleSize; i++) {
v = randomData.nextExponential(1);
assertTrue("exponential deviate postive", v > 0);
if (v < 2) cumFreq++;
assertEquals("exponential cumulative distribution",
(double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);
public void testConfig() throws NoSuchProviderException, 
NoSuchAlgorithmException {
randomData.reSeed(1000);
double v = randomData.nextUniform(0,1);
randomData.reSeed();
assertTrue("different seeds", 
Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);
randomData.reSeed(1000);
assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);
randomData.reSeedSecure(1000);
String hex = randomData.nextSecureHexString(40);
randomData.reSeedSecure();
assertTrue("different seeds",
!hex.equals(randomData.nextSecureHexString(40)));
randomData.reSeedSecure(1000);
assertTrue("same seeds",
!hex.equals(randomData.nextSecureHexString(40))); 
randomData.setSecureAlgorithm("SHA1PRNG","SUN");
assertTrue("different seeds",
!hex.equals(randomData.nextSecureHexString(40)));
randomData.setSecureAlgorithm("NOSUCHTHING","SUN");
fail("expecting NoSuchAlgorithmException");
randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");
fail("expecting NoSuchProviderException");
RandomDataImpl rd = new RandomDataImpl();
rd.reSeed(100);
rd.nextLong(1,2);
RandomDataImpl rd2 = new RandomDataImpl();
rd2.reSeedSecure(2000);
rd2.nextSecureLong(1,2);
rd = new RandomDataImpl();
rd.reSeed();
rd.nextLong(1,2);
rd2 = new RandomDataImpl();
rd2.reSeedSecure();
rd2.nextSecureLong(1,2);
public void testNextSample() {
Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},
long[] observed = {0,0,0,0,0,0,0,0,0,0};
double[] expected = {100,100,100,100,100,100,100,100,100,100};
HashSet cPop = new HashSet();  //{0,1,2,3,4}
for (int i = 0; i < 5; i++) {
cPop.add(Integer.toString(i));
Object[] sets = new Object[10]; // 2-sets from 5
for (int i = 0; i < 10; i ++) {
HashSet hs = new HashSet();
hs.add(c[i][0]);
hs.add(c[i][1]);
sets[i] = hs;
for (int i = 0; i < 1000; i ++) {
Object[] cSamp = randomData.nextSample(cPop,2);
observed[findSample(sets,cSamp)]++;
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 27.88);  
HashSet hs = new HashSet();
hs.add("one");
Object[] one = randomData.nextSample(hs,1);
String oneString = (String) one[0];
if ((one.length != 1) || !oneString.equals("one")){
fail("bad sample for set size = 1, sample size = 1");
one = randomData.nextSample(hs,2);
fail("sample size > set size, expecting IllegalArgumentException");
hs = new HashSet();
one = randomData.nextSample(hs,0);
fail("n = k = 0, expecting IllegalArgumentException");
private int findSample(Object[] u, Object[] samp) {
for (int i = 0; i < u.length; i++) {
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
for (int j = 0; j < samp.length; j++) {
sampSet.add(samp[j]);
if (set.equals(sampSet)) {                 
return i;
fail("sample not found:{" + samp[0] + "," + samp[1] + "}");
return -1;
public void testNextPermutation() {
int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
long[] observed = {0,0,0,0,0,0};
double[] expected = {100,100,100,100,100,100};
for (int i = 0; i < 600; i++) {
int[] perm = randomData.nextPermutation(3,3);
observed[findPerm(p,perm)]++;
assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 20.52); 
int[] perm = randomData.nextPermutation(1,1);
if ((perm.length != 1) || (perm[0] != 0)){
fail("bad permutation for n = 1, sample k = 1");
perm = randomData.nextPermutation(2,3);
fail("permutation k > n, expecting IllegalArgumentException");
perm = randomData.nextPermutation(0,0);
fail("permutation k = n = 0, expecting IllegalArgumentException");
private int findPerm(int[][] p, int[] samp) {
for (int i = 0; i < p.length; i++) {
boolean good = true;
for (int j = 0; j < samp.length; j++) {
if (samp[j] != p[i][j]) {
good = false;
if (good)  {
return i;
fail("permutation not found");
return -1;
package org.apache.commons.math;
public abstract class RetryTestCase extends TestCase {
public RetryTestCase() {
super();
public RetryTestCase(String arg0) {
super(arg0);
protected void runTest() throws Throwable {
super.runTest();
super.runTest();
package org.apache.commons.math.fraction;
public class FractionTest extends TestCase {
private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {
assertEquals(expectedNumerator, actual.getNumerator());
assertEquals(expectedDenominator, actual.getDenominator());
public void testConstructor() {
assertFraction(0, 1, new Fraction(0, 1));
assertFraction(0, 1, new Fraction(0, 2));
assertFraction(0, 1, new Fraction(0, -1));
assertFraction(1, 2, new Fraction(1, 2));
assertFraction(1, 2, new Fraction(2, 4));
assertFraction(-1, 2, new Fraction(-1, 2));
assertFraction(-1, 2, new Fraction(1, -2));
assertFraction(-1, 2, new Fraction(-2, 4));
assertFraction(-1, 2, new Fraction(2, -4));
new Fraction(Integer.MIN_VALUE, -1);
fail();
new Fraction(1, Integer.MIN_VALUE);
fail();
assertFraction(0, 1, new Fraction(0.00000000000001));
assertFraction(2, 5, new Fraction(0.40000000000001));
assertFraction(15, 1, new Fraction(15.0000000000001));
fail(ex.getMessage());
public void testCompareTo() {
Fraction first = new Fraction(1, 2);
Fraction second = new Fraction(1, 3);
Fraction third = new Fraction(1, 2);
assertEquals(0, first.compareTo(first));
assertEquals(0, first.compareTo(third));
assertEquals(1, first.compareTo(second));
assertEquals(-1, second.compareTo(first));
public void testDoubleValue() {
Fraction first = new Fraction(1, 2);
Fraction second = new Fraction(1, 3);
assertEquals(0.5, first.doubleValue(), 0.0);
assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);
public void testFloatValue() {
Fraction first = new Fraction(1, 2);
Fraction second = new Fraction(1, 3);
assertEquals(0.5f, first.floatValue(), 0.0f);
assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);
public void testIntValue() {
Fraction first = new Fraction(1, 2);
Fraction second = new Fraction(3, 2);
assertEquals(0, first.intValue());
assertEquals(1, second.intValue());
public void testLongValue() {
Fraction first = new Fraction(1, 2);
Fraction second = new Fraction(3, 2);
assertEquals(0L, first.longValue());
assertEquals(1L, second.longValue());
public void testConstructorDouble() {
assertFraction(1, 2, new Fraction(0.5));
assertFraction(1, 3, new Fraction(1.0 / 3.0));
assertFraction(17, 100, new Fraction(17.0 / 100.0));
assertFraction(317, 100, new Fraction(317.0 / 100.0));
assertFraction(-1, 2, new Fraction(-0.5));
assertFraction(-1, 3, new Fraction(-1.0 / 3.0));
assertFraction(-17, 100, new Fraction(17.0 / -100.0));
assertFraction(-317, 100, new Fraction(-317.0 / 100.0));
fail(ex.getMessage());
public void testAbs() {
Fraction a = new Fraction(10, 21);
Fraction b = new Fraction(-10, 21);
Fraction c = new Fraction(10, -21);
assertFraction(10, 21, a.abs());
assertFraction(10, 21, b.abs());
assertFraction(10, 21, c.abs());
public void testReciprocal() {
Fraction f = null;
f = new Fraction(50, 75);
f = f.reciprocal();
assertEquals(3, f.getNumerator());
assertEquals(2, f.getDenominator());
f = new Fraction(4, 3);
f = f.reciprocal();
assertEquals(3, f.getNumerator());
assertEquals(4, f.getDenominator());
f = new Fraction(-15, 47);
f = f.reciprocal();
assertEquals(-47, f.getNumerator());
assertEquals(15, f.getDenominator());
f = new Fraction(0, 3);
f = f.reciprocal();
fail("expecting ArithmeticException");
f = new Fraction(Integer.MAX_VALUE, 1);
f = f.reciprocal();
assertEquals(1, f.getNumerator());
assertEquals(Integer.MAX_VALUE, f.getDenominator());
public void testNegate() {
Fraction f = null;
f = new Fraction(50, 75);
f = f.negate();
assertEquals(-2, f.getNumerator());
assertEquals(3, f.getDenominator());
f = new Fraction(-50, 75);
f = f.negate();
assertEquals(2, f.getNumerator());
assertEquals(3, f.getDenominator());
f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);
f = f.negate();
assertEquals(Integer.MIN_VALUE+2, f.getNumerator());
assertEquals(Integer.MAX_VALUE, f.getDenominator());
f = new Fraction(Integer.MIN_VALUE, 1);
f = f.negate();
fail("expecting ArithmeticException");
public void testAdd() {
Fraction a = new Fraction(1, 2);
Fraction b = new Fraction(2, 3);
assertFraction(1, 1, a.add(a));
assertFraction(7, 6, a.add(b));
assertFraction(7, 6, b.add(a));
assertFraction(4, 3, b.add(b));
Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);
Fraction f2 = Fraction.ONE;
Fraction f = f1.add(f2);
assertEquals(Integer.MAX_VALUE, f.getNumerator());
assertEquals(1, f.getDenominator());
f1 = new Fraction(-1, 13*13*2*2);
f2 = new Fraction(-2, 13*17*2);
f = f1.add(f2);
assertEquals(13*13*17*2*2, f.getDenominator());
assertEquals(-17 - 2*13*2, f.getNumerator());
f.add(null);
fail("expecting IllegalArgumentException");
f1 = new Fraction(1,32768*3);
f2 = new Fraction(1,59049);
f = f1.add(f2);
assertEquals(52451, f.getNumerator());
assertEquals(1934917632, f.getDenominator());
f1 = new Fraction(Integer.MIN_VALUE, 3);
f2 = new Fraction(1,3);
f = f1.add(f2);
assertEquals(Integer.MIN_VALUE+1, f.getNumerator());
assertEquals(3, f.getDenominator());
f1 = new Fraction(Integer.MAX_VALUE - 1, 1);
f2 = Fraction.ONE;
f = f1.add(f2);
assertEquals(Integer.MAX_VALUE, f.getNumerator());
assertEquals(1, f.getDenominator());
f = f.add(Fraction.ONE); // should overflow
fail("expecting ArithmeticException but got: " + f.toString());
f1 = new Fraction(Integer.MIN_VALUE, 5);
f2 = new Fraction(-1,5);
f = f1.add(f2); // should overflow
fail("expecting ArithmeticException but got: " + f.toString());
f= new Fraction(-Integer.MAX_VALUE, 1);
f = f.add(f);
fail("expecting ArithmeticException");
f= new Fraction(-Integer.MAX_VALUE, 1);
f = f.add(f);
fail("expecting ArithmeticException");
f1 = new Fraction(3,327680);
f2 = new Fraction(2,59049);
f = f1.add(f2); // should overflow
fail("expecting ArithmeticException but got: " + f.toString());
public void testDivide() {
Fraction a = new Fraction(1, 2);
Fraction b = new Fraction(2, 3);
assertFraction(1, 1, a.divide(a));
assertFraction(3, 4, a.divide(b));
assertFraction(4, 3, b.divide(a));
assertFraction(1, 1, b.divide(b));
Fraction f1 = new Fraction(3, 5);
Fraction f2 = Fraction.ZERO;
f1.divide(f2);
fail("expecting ArithmeticException");
f1 = new Fraction(0, 5);
f2 = new Fraction(2, 7);
Fraction f = f1.divide(f2);
assertSame(Fraction.ZERO, f);
f1 = new Fraction(2, 7);
f2 = Fraction.ONE;
f = f1.divide(f2);
assertEquals(2, f.getNumerator());
assertEquals(7, f.getDenominator());
f1 = new Fraction(1, Integer.MAX_VALUE);
f = f1.divide(f1);  
assertEquals(1, f.getNumerator());
assertEquals(1, f.getDenominator());
f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);
f2 = new Fraction(1, Integer.MAX_VALUE);
f = f1.divide(f2);
assertEquals(Integer.MIN_VALUE, f.getNumerator());
assertEquals(1, f.getDenominator());
f.divide(null);
fail("IllegalArgumentException");
f1 = new Fraction(1, Integer.MAX_VALUE);
f = f1.divide(f1.reciprocal());  // should overflow
fail("expecting ArithmeticException");
f1 = new Fraction(1, -Integer.MAX_VALUE);
f = f1.divide(f1.reciprocal());  // should overflow
fail("expecting ArithmeticException");
public void testMultiply() {
Fraction a = new Fraction(1, 2);
Fraction b = new Fraction(2, 3);
assertFraction(1, 4, a.multiply(a));
assertFraction(1, 3, a.multiply(b));
assertFraction(1, 3, b.multiply(a));
assertFraction(4, 9, b.multiply(b));
Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);
Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);
Fraction f = f1.multiply(f2);
assertEquals(Integer.MIN_VALUE, f.getNumerator());
assertEquals(1, f.getDenominator());
f.multiply(null);
fail("expecting IllegalArgumentException");
public void testSubtract() {
Fraction a = new Fraction(1, 2);
Fraction b = new Fraction(2, 3);
assertFraction(0, 1, a.subtract(a));
assertFraction(-1, 6, a.subtract(b));
assertFraction(1, 6, b.subtract(a));
assertFraction(0, 1, b.subtract(b));
Fraction f = new Fraction(1,1);
f.subtract(null);
fail("expecting IllegalArgumentException");
Fraction f1 = new Fraction(1,32768*3);
Fraction f2 = new Fraction(1,59049);
f = f1.subtract(f2);
assertEquals(-13085, f.getNumerator());
assertEquals(1934917632, f.getDenominator());
f1 = new Fraction(Integer.MIN_VALUE, 3);
f2 = new Fraction(1,3).negate();
f = f1.subtract(f2);
assertEquals(Integer.MIN_VALUE+1, f.getNumerator());
assertEquals(3, f.getDenominator());
f1 = new Fraction(Integer.MAX_VALUE, 1);
f2 = Fraction.ONE;
f = f1.subtract(f2);
assertEquals(Integer.MAX_VALUE-1, f.getNumerator());
assertEquals(1, f.getDenominator());
f1 = new Fraction(1, Integer.MAX_VALUE);
f2 = new Fraction(1, Integer.MAX_VALUE - 1);
f = f1.subtract(f2);
fail("expecting ArithmeticException");  //should overflow
f1 = new Fraction(Integer.MIN_VALUE, 5);
f2 = new Fraction(1,5);
f = f1.subtract(f2); // should overflow
fail("expecting ArithmeticException but got: " + f.toString());
f= new Fraction(Integer.MIN_VALUE, 1);
f = f.subtract(Fraction.ONE);
fail("expecting ArithmeticException");
f= new Fraction(Integer.MAX_VALUE, 1);
f = f.subtract(Fraction.ONE.negate());
fail("expecting ArithmeticException");
f1 = new Fraction(3,327680);
f2 = new Fraction(2,59049);
f = f1.subtract(f2); // should overflow
fail("expecting ArithmeticException but got: " + f.toString());
public void testEqualsAndHashCode() {
Fraction zero  = new Fraction(0,1);
Fraction nullFraction = null;
assertTrue( zero.equals(zero));
assertFalse(zero.equals(nullFraction));
assertFalse(zero.equals(new Double(0)));
Fraction zero2 = new Fraction(0,2);
assertTrue(zero.equals(zero2));
assertEquals(zero.hashCode(), zero2.hashCode());
Fraction one = new Fraction(1,1);
assertFalse((one.equals(zero) ||zero.equals(one)));
public void testGetReducedFraction() {
Fraction threeFourths = new Fraction(3, 4);
assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));
assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));
Fraction.getReducedFraction(1, 0);
fail("expecting ArithmeticException");
assertEquals(Fraction.getReducedFraction
(2, Integer.MIN_VALUE).getNumerator(),-1);
assertEquals(Fraction.getReducedFraction
(1, -1).getNumerator(), -1);
package org.apache.commons.math.fraction;
public class FractionFormatTest extends TestCase {
FractionFormat properFormat = null;
FractionFormat improperFormat = null;
protected Locale getLocale() {
return Locale.getDefault();
protected void setUp() throws Exception {
properFormat = FractionFormat.getProperInstance(getLocale());
improperFormat = FractionFormat.getImproperInstance(getLocale());
public void testFormat() {
Fraction c = new Fraction(1, 2);
String expected = "1 / 2";
String actual = properFormat.format(c); 
assertEquals(expected, actual);
actual = improperFormat.format(c);
assertEquals(expected, actual);
public void testFormatNegative() {
Fraction c = new Fraction(-1, 2);
String expected = "-1 / 2";
String actual = properFormat.format(c); 
assertEquals(expected, actual);
actual = improperFormat.format(c); 
assertEquals(expected, actual);
public void testFormatZero() {
Fraction c = new Fraction(0, 1);
String expected = "0 / 1";
String actual = properFormat.format(c); 
assertEquals(expected, actual);
actual = improperFormat.format(c); 
assertEquals(expected, actual);
public void testFormatImproper() {
Fraction c = new Fraction(5, 3);
String actual = properFormat.format(c); 
assertEquals("1 2 / 3", actual);
actual = improperFormat.format(c); 
assertEquals("5 / 3", actual);
public void testFormatImproperNegative() {
Fraction c = new Fraction(-5, 3);
String actual = properFormat.format(c); 
assertEquals("-1 2 / 3", actual);
actual = improperFormat.format(c); 
assertEquals("-5 / 3", actual);
public void testParse() {
String source = "1 / 2";
Fraction c = properFormat.parse(source);
assertNotNull(c);
assertEquals(1, c.getNumerator());
assertEquals(2, c.getDenominator());
c = improperFormat.parse(source);
assertNotNull(c);
assertEquals(1, c.getNumerator());
assertEquals(2, c.getDenominator());
fail(ex.getMessage());
public void testParseInteger() {
String source = "10";
Fraction c = properFormat.parse(source);
assertNotNull(c);
assertEquals(10, c.getNumerator());
assertEquals(1, c.getDenominator());
fail(ex.getMessage());
Fraction c = improperFormat.parse(source);
assertNotNull(c);
assertEquals(10, c.getNumerator());
assertEquals(1, c.getDenominator());
fail(ex.getMessage());
public void testParseInvalid() {
String source = "a";
String msg = "should not be able to parse '10 / a'.";
properFormat.parse(source);
fail(msg);
improperFormat.parse(source);
fail(msg);
public void testParseInvalidDenominator() {
String source = "10 / a";
String msg = "should not be able to parse '10 / a'.";
properFormat.parse(source);
fail(msg);
improperFormat.parse(source);
fail(msg);
public void testParseNegative() {
String source = "-1 / 2";
Fraction c = properFormat.parse(source);
assertNotNull(c);
assertEquals(-1, c.getNumerator());
assertEquals(2, c.getDenominator());
c = improperFormat.parse(source);
assertNotNull(c);
assertEquals(-1, c.getNumerator());
assertEquals(2, c.getDenominator());
source = "1 / -2";
c = properFormat.parse(source);
assertNotNull(c);
assertEquals(-1, c.getNumerator());
assertEquals(2, c.getDenominator());
c = improperFormat.parse(source);
assertNotNull(c);
assertEquals(-1, c.getNumerator());
assertEquals(2, c.getDenominator());
fail(ex.getMessage());
public void testParseProper() {
String source = "1 2 / 3";
Fraction c = properFormat.parse(source);
assertNotNull(c);
assertEquals(5, c.getNumerator());
assertEquals(3, c.getDenominator());
fail(ex.getMessage());
improperFormat.parse(source);
fail("invalid improper fraction.");
public void testParseProperNegative() {
String source = "-1 2 / 3";
Fraction c = properFormat.parse(source);
assertNotNull(c);
assertEquals(-5, c.getNumerator());
assertEquals(3, c.getDenominator());
fail(ex.getMessage());
improperFormat.parse(source);
fail("invalid improper fraction.");
public void testParseProperInvalidMinus() {
String source = "2 -2 / 3";
properFormat.parse(source);
fail("invalid minus in improper fraction.");
source = "2 2 / -3";
properFormat.parse(source);
fail("invalid minus in improper fraction.");
public void testNumeratorFormat() {
NumberFormat old = properFormat.getNumeratorFormat();
NumberFormat nf = NumberFormat.getInstance();
nf.setParseIntegerOnly(true);
properFormat.setNumeratorFormat(nf);
assertEquals(nf, properFormat.getNumeratorFormat());
properFormat.setNumeratorFormat(old);
old = improperFormat.getNumeratorFormat();
nf = NumberFormat.getInstance();
nf.setParseIntegerOnly(true);
improperFormat.setNumeratorFormat(nf);
assertEquals(nf, improperFormat.getNumeratorFormat());
improperFormat.setNumeratorFormat(old);
public void testDenominatorFormat() {
NumberFormat old = properFormat.getDenominatorFormat();
NumberFormat nf = NumberFormat.getInstance();
nf.setParseIntegerOnly(true);
properFormat.setDenominatorFormat(nf);
assertEquals(nf, properFormat.getDenominatorFormat());
properFormat.setDenominatorFormat(old);
old = improperFormat.getDenominatorFormat();
nf = NumberFormat.getInstance();
nf.setParseIntegerOnly(true);
improperFormat.setDenominatorFormat(nf);
assertEquals(nf, improperFormat.getDenominatorFormat());
improperFormat.setDenominatorFormat(old);
public void testWholeFormat() {
ProperFractionFormat format = (ProperFractionFormat)properFormat;
NumberFormat old = format.getWholeFormat();
NumberFormat nf = NumberFormat.getInstance();
nf.setParseIntegerOnly(true);
format.setWholeFormat(nf);
assertEquals(nf, format.getWholeFormat());
format.setWholeFormat(old);
package org.apache.commons.math.transform;
public final class FastFourierTransformerTest extends TestCase {
public void testAdHocData() throws MathException {
FastFourierTransformer transformer = new FastFourierTransformer();
Complex result[]; double tolerance = 1E-12;
double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};
Complex y[] = {
new Complex(21.9, 0.0),
new Complex(-2.09497474683058, 1.91507575950825),
new Complex(-2.6, 2.7),
new Complex(-1.10502525316942, -4.88492424049175),
new Complex(0.1, 0.0),
new Complex(-1.10502525316942, 4.88492424049175),
new Complex(-2.6, -2.7),
new Complex(-2.09497474683058, -1.91507575950825)};
result = transformer.transform(x);
for (int i = 0; i < result.length; i++) {
assertEquals(y[i].getReal(), result[i].getReal(), tolerance);
assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);
result = transformer.inversetransform(y);
for (int i = 0; i < result.length; i++) {
assertEquals(x[i], result[i].getReal(), tolerance);
assertEquals(0.0, result[i].getImaginary(), tolerance);
double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};
FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));
Complex y2[] = y;
result = transformer.transform2(y2);
for (int i = 0; i < result.length; i++) {
assertEquals(x2[i], result[i].getReal(), tolerance);
assertEquals(0.0, result[i].getImaginary(), tolerance);
result = transformer.inversetransform2(x2);
for (int i = 0; i < result.length; i++) {
assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);
assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
FastFourierTransformer transformer = new FastFourierTransformer();
Complex result[]; int N = 1 << 8;
double min, max, tolerance = 1E-12;
min = 0.0; max = 2.0 * Math.PI;
result = transformer.transform(f, min, max, N);
assertEquals(0.0, result[1].getReal(), tolerance);
assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);
assertEquals(0.0, result[N-1].getReal(), tolerance);
assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);
for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {
assertEquals(0.0, result[i].getReal(), tolerance);
assertEquals(0.0, result[i].getImaginary(), tolerance);
min = -Math.PI; max = Math.PI;
result = transformer.inversetransform(f, min, max, N);
assertEquals(0.0, result[1].getReal(), tolerance);
assertEquals(-0.5, result[1].getImaginary(), tolerance);
assertEquals(0.0, result[N-1].getReal(), tolerance);
assertEquals(0.5, result[N-1].getImaginary(), tolerance);
for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {
assertEquals(0.0, result[i].getReal(), tolerance);
assertEquals(0.0, result[i].getImaginary(), tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
FastFourierTransformer transformer = new FastFourierTransformer();
transformer.transform(f, 1, -1, 64);
fail("Expecting IllegalArgumentException - bad interval");
transformer.transform(f, -1, 1, 0);
fail("Expecting IllegalArgumentException - bad samples number");
transformer.transform(f, -1, 1, 100);
fail("Expecting IllegalArgumentException - bad samples number");
package org.apache.commons.math.transform;
public final class FastCosineTransformerTest extends TestCase {
public void testAdHocData() throws MathException {
FastCosineTransformer transformer = new FastCosineTransformer();
double result[], tolerance = 1E-12;
double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };
double y[] = { 172.0, -105.096569476353, 27.3137084989848,
-12.9593152353742, 8.0, -5.78585076868676,
4.68629150101524, -4.15826451958632, 4.0 };
result = transformer.transform(x);
for (int i = 0; i < result.length; i++) {
assertEquals(y[i], result[i], tolerance);
result = transformer.inversetransform(y);
for (int i = 0; i < result.length; i++) {
assertEquals(x[i], result[i], tolerance);
FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));
result = transformer.transform2(y);
for (int i = 0; i < result.length; i++) {
assertEquals(x[i], result[i], tolerance);
result = transformer.inversetransform2(x);
for (int i = 0; i < result.length; i++) {
assertEquals(y[i], result[i], tolerance);
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
FastCosineTransformer transformer = new FastCosineTransformer();
double min, max, result[], tolerance = 1E-12; int N = 9;
double expected[] = { 0.0, 3.26197262739567, 0.0,
-2.17958042710327, 0.0, -0.648846697642915,
0.0, -0.433545502649478, 0.0 };
min = 0.0; max = 2.0 * Math.PI * N / (N-1);
result = transformer.transform(f, min, max, N);
for (int i = 0; i < N; i++) {
assertEquals(expected[i], result[i], tolerance);
min = -Math.PI; max = Math.PI * (N+1) / (N-1);
result = transformer.transform(f, min, max, N);
for (int i = 0; i < N; i++) {
assertEquals(-expected[i], result[i], tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
FastCosineTransformer transformer = new FastCosineTransformer();
transformer.transform(f, 1, -1, 65);
fail("Expecting IllegalArgumentException - bad interval");
transformer.transform(f, -1, 1, 1);
fail("Expecting IllegalArgumentException - bad samples number");
transformer.transform(f, -1, 1, 64);
fail("Expecting IllegalArgumentException - bad samples number");
package org.apache.commons.math.transform;
public final class FastSineTransformerTest extends TestCase {
public void testAdHocData() throws MathException {
FastSineTransformer transformer = new FastSineTransformer();
double result[], tolerance = 1E-12;
double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };
double y[] = { 0.0, 20.1093579685034, -9.65685424949238,
5.98642305066196, -4.0, 2.67271455167720,
-1.65685424949238, 0.795649469518633 };
result = transformer.transform(x);
for (int i = 0; i < result.length; i++) {
assertEquals(y[i], result[i], tolerance);
result = transformer.inversetransform(y);
for (int i = 0; i < result.length; i++) {
assertEquals(x[i], result[i], tolerance);
FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));
result = transformer.transform2(y);
for (int i = 0; i < result.length; i++) {
assertEquals(x[i], result[i], tolerance);
result = transformer.inversetransform2(x);
for (int i = 0; i < result.length; i++) {
assertEquals(y[i], result[i], tolerance);
public void testSinFunction() throws MathException {
UnivariateRealFunction f = new SinFunction();
FastSineTransformer transformer = new FastSineTransformer();
double min, max, result[], tolerance = 1E-12; int N = 1 << 8;
min = 0.0; max = 2.0 * Math.PI;
result = transformer.transform(f, min, max, N);
assertEquals(N >> 1, result[2], tolerance);
for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {
assertEquals(0.0, result[i], tolerance);
min = -Math.PI; max = Math.PI;
result = transformer.transform(f, min, max, N);
assertEquals(-(N >> 1), result[2], tolerance);
for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {
assertEquals(0.0, result[i], tolerance);
public void testParameters() throws Exception {
UnivariateRealFunction f = new SinFunction();
FastSineTransformer transformer = new FastSineTransformer();
transformer.transform(f, 1, -1, 64);
fail("Expecting IllegalArgumentException - bad interval");
transformer.transform(f, -1, 1, 0);
fail("Expecting IllegalArgumentException - bad samples number");
transformer.transform(f, -1, 1, 100);
fail("Expecting IllegalArgumentException - bad samples number");
package org.apache.commons.math;
public class DuplicateSampleAbscissaException extends MathException  {
private static final long serialVersionUID = -2271007547170169872L;
public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {
super("Abscissa {0} is duplicated at both indices {1} and {2}",
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
public double getDuplicateAbscissa() {
return ((Double) getArguments()[0]).doubleValue();
package org.apache.commons.math.analysis;
public abstract class UnivariateRealSolverFactory {
protected UnivariateRealSolverFactory() {
public static UnivariateRealSolverFactory newInstance() {
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
return new UnivariateRealSolverFactoryImpl();
return factory;
public abstract UnivariateRealSolver newDefaultSolver(
UnivariateRealFunction f);
public abstract UnivariateRealSolver newBisectionSolver(
UnivariateRealFunction f);
public abstract UnivariateRealSolver newBrentSolver(
UnivariateRealFunction f);
public abstract UnivariateRealSolver newNewtonSolver(
DifferentiableUnivariateRealFunction f);
public abstract UnivariateRealSolver newSecantSolver(
UnivariateRealFunction f);
package org.apache.commons.math.analysis;
public class UnivariateRealSolverUtils {
private UnivariateRealSolverUtils() {
super();
private static UnivariateRealSolverFactory factory = null;
public static double solve(UnivariateRealFunction f, double x0, double x1)
throws ConvergenceException, FunctionEvaluationException {
setup(f);
return factory.newDefaultSolver(f).solve(x0, x1);
public static double solve(UnivariateRealFunction f, double x0, double x1,
double absoluteAccuracy) throws ConvergenceException, 
FunctionEvaluationException {    
setup(f);
UnivariateRealSolver solver = factory.newDefaultSolver(f);
solver.setAbsoluteAccuracy(absoluteAccuracy);
return solver.solve(x0, x1);
public static double[] bracket(UnivariateRealFunction function, 
double initial, double lowerBound, double upperBound) 
throws ConvergenceException, FunctionEvaluationException {
return bracket( function, initial, lowerBound, upperBound,
Integer.MAX_VALUE ) ;
public static double[] bracket(UnivariateRealFunction function,
double initial, double lowerBound, double upperBound, 
int maximumIterations) throws ConvergenceException, 
FunctionEvaluationException {
if (function == null) {
throw new IllegalArgumentException ("function is null.");
if (maximumIterations <= 0)  {
throw new IllegalArgumentException
("bad value for maximumIterations: " + maximumIterations);
if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
throw new IllegalArgumentException
("Invalid endpoint parameters:  lowerBound=" + lowerBound + 
" initial=" + initial + " upperBound=" + upperBound);
double a = initial;
double b = initial;
double fa;
double fb;
int numIterations = 0 ;
do {
a = Math.max(a - 1.0, lowerBound);
b = Math.min(b + 1.0, upperBound);
fa = function.value(a);
fb = function.value(b);
numIterations++ ;
((a > lowerBound) || (b < upperBound)));
if (fa * fb >= 0.0 ) {
throw new ConvergenceException
("Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}",
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
new Double(initial), new Double(lowerBound), new Double(upperBound),
new Double(a), new Double(b), new Double(fa), new Double(fb) });
return new double[]{a, b};
public static double midpoint(double a, double b) {
return (a + b) * .5;
private static void setup(UnivariateRealFunction f) {
if (f == null) {
throw new IllegalArgumentException("function can not be null.");    
if (factory == null) {
factory = UnivariateRealSolverFactory.newInstance();
package org.apache.commons.math.analysis;
public abstract class UnivariateRealIntegratorImpl implements
UnivariateRealIntegrator, Serializable {
protected double relativeAccuracy;
protected int maximalIterationCount;
protected int minimalIterationCount;
protected double defaultRelativeAccuracy;
protected int defaultMaximalIterationCount;
protected int defaultMinimalIterationCount;
protected boolean resultComputed = false;
protected double result;
protected int iterationCount;
protected UnivariateRealFunction f;
protected UnivariateRealIntegratorImpl(
UnivariateRealFunction f,
int defaultMaximalIterationCount) throws IllegalArgumentException {
if (f == null) {
throw new IllegalArgumentException("Function can not be null.");
this.f = f;
this.defaultMaximalIterationCount = defaultMaximalIterationCount;
this.maximalIterationCount = defaultMaximalIterationCount;
this.defaultRelativeAccuracy = 1E-6;
this.relativeAccuracy = defaultRelativeAccuracy;
this.defaultMinimalIterationCount = 3;
this.minimalIterationCount = defaultMinimalIterationCount;
verifyIterationCount();
public double getResult() throws IllegalStateException {
if (resultComputed) {
return result;
throw new IllegalStateException("No result available.");
public int getIterationCount() throws IllegalStateException {
if (resultComputed) {
return iterationCount;
throw new IllegalStateException("No result available.");
protected final void setResult(double result, int iterationCount) {
this.result = result;
this.iterationCount = iterationCount;
this.resultComputed = true;
protected final void clearResult() {
this.resultComputed = false;
public void setMaximalIterationCount(int count) {
maximalIterationCount = count;
public int getMaximalIterationCount() {
return maximalIterationCount;
public void resetMaximalIterationCount() {
maximalIterationCount = defaultMaximalIterationCount;
public void setMinimalIterationCount(int count) {
minimalIterationCount = count;
public int getMinimalIterationCount() {
return minimalIterationCount;
public void resetMinimalIterationCount() {
minimalIterationCount = defaultMinimalIterationCount;
public void setRelativeAccuracy(double accuracy) {
relativeAccuracy = accuracy;
public double getRelativeAccuracy() {
return relativeAccuracy;
public void resetRelativeAccuracy() {
relativeAccuracy = defaultRelativeAccuracy;
protected boolean isSequence(double start, double mid, double end) {
return (start < mid) && (mid < end);
protected void verifyInterval(double lower, double upper) throws
IllegalArgumentException {
if (lower >= upper) {
throw new IllegalArgumentException
("Endpoints do not specify an interval: [" + lower +
", " + upper + "]");
protected void verifyIterationCount() throws IllegalArgumentException {
if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {
throw new IllegalArgumentException
("Invalid iteration limits: min=" + minimalIterationCount +
" max=" + maximalIterationCount);
package org.apache.commons.math.analysis;
public interface UnivariateRealInterpolator {
public UnivariateRealFunction interpolate(double xval[], double yval[])
throws MathException;
package org.apache.commons.math.analysis;
public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,
Serializable {
private static final long serialVersionUID = 107049519551235069L;
public UnivariateRealFunction interpolate(double x[], double y[]) throws
DuplicateSampleAbscissaException {
double a[], c[];
PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);
c = new double[x.length-1];
for (int i = 0; i < c.length; i++) {
c[i] = x[i];
a = computeDividedDifference(x, y);
PolynomialFunctionNewtonForm p;
p = new PolynomialFunctionNewtonForm(a, c);
return p;
protected static double[] computeDividedDifference(double x[], double y[])
throws DuplicateSampleAbscissaException {
int i, j, n;
double divdiff[], a[], denominator;
PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);
n = x.length;
divdiff = new double[n];
for (i = 0; i < n; i++) {
divdiff[i] = y[i];      // initialization
a = new double [n];
a[0] = divdiff[0];
for (i = 1; i < n; i++) {
for (j = 0; j < n-i; j++) {
denominator = x[j+i] - x[j];
if (denominator == 0.0) {
throw new DuplicateSampleAbscissaException(x[j], j, j+i);
divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;
a[i] = divdiff[0];
return a;
package org.apache.commons.math.analysis;
public class UnivariateRealSolverFactoryImpl extends UnivariateRealSolverFactory {
public UnivariateRealSolverFactoryImpl() {
public UnivariateRealSolver newDefaultSolver(UnivariateRealFunction f) {
return newBrentSolver(f);
public UnivariateRealSolver newBisectionSolver(UnivariateRealFunction f) {
return new BisectionSolver(f);
public UnivariateRealSolver newBrentSolver(UnivariateRealFunction f) {
return new BrentSolver(f);
public UnivariateRealSolver newNewtonSolver(
DifferentiableUnivariateRealFunction f) {
return new NewtonSolver(f);
public UnivariateRealSolver newSecantSolver(UnivariateRealFunction f) {
return new SecantSolver(f);
package org.apache.commons.math.analysis;
public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {
private static final long serialVersionUID = 1984971194738974867L;
public SecantSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
public double solve(double min, double max, double initial)
throws MaxIterationsExceededException, FunctionEvaluationException {
return solve(min, max);
public double solve(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException {
clearResult();
verifyInterval(min, max);
double x0 = min;
double x1 = max;
double y0 = f.value(x0);
double y1 = f.value(x1);
if (y0 * y1 >= 0) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + y0 + "," + y1 + "]");       
double x2 = x0;
double y2 = y0;
double oldDelta = x2 - x1;
int i = 0;
while (i < maximalIterationCount) {
if (Math.abs(y2) < Math.abs(y1)) {
x0 = x1;
x1 = x2;
x2 = x0;
y0 = y1;
y1 = y2;
y2 = y0;
if (Math.abs(y1) <= functionValueAccuracy) {
setResult(x1, i);
return result;
if (Math.abs(oldDelta) <
Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {
setResult(x1, i);
return result;
double delta;
if (Math.abs(y1) > Math.abs(y0)) {
delta = 0.5 * oldDelta;
delta = (x0 - x1) / (1 - y0 / y1);
if (delta / oldDelta > 1) {
delta = 0.5 * oldDelta;
x0 = x1;
y0 = y1;
x1 = x1 + delta;
y1 = f.value(x1);
if ((y1 > 0) == (y2 > 0)) {
x2 = x0;
y2 = y0;
oldDelta = x2 - x1;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public interface UnivariateRealIntegrator {
void setMaximalIterationCount(int count);
int getMaximalIterationCount();
void resetMaximalIterationCount();
void setMinimalIterationCount(int count);
int getMinimalIterationCount();
void resetMinimalIterationCount();
void setRelativeAccuracy(double accuracy);
double getRelativeAccuracy();
void resetRelativeAccuracy();
double integrate(double min, double max) throws ConvergenceException, 
FunctionEvaluationException, IllegalArgumentException;
double getResult() throws IllegalStateException;
int getIterationCount() throws IllegalStateException;
package org.apache.commons.math.analysis;
public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver,
Serializable {
private static final long serialVersionUID = 1112491292565386596L;
protected double absoluteAccuracy;
protected double relativeAccuracy;
protected double functionValueAccuracy;
protected int maximalIterationCount;
protected double defaultAbsoluteAccuracy;
protected double defaultRelativeAccuracy;
protected double defaultFunctionValueAccuracy;
protected int defaultMaximalIterationCount;
protected boolean resultComputed = false;
protected double result;
protected int iterationCount;
protected UnivariateRealFunction f;
protected UnivariateRealSolverImpl(
UnivariateRealFunction f,
int defaultMaximalIterationCount,
double defaultAbsoluteAccuracy) {
super();
if (f == null) {
throw new IllegalArgumentException("function can not be null.");
this.f = f;
this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;
this.defaultRelativeAccuracy = 1E-14;
this.defaultFunctionValueAccuracy = 1E-15;
this.absoluteAccuracy = defaultAbsoluteAccuracy;
this.relativeAccuracy = defaultRelativeAccuracy;
this.functionValueAccuracy = defaultFunctionValueAccuracy;
this.defaultMaximalIterationCount = defaultMaximalIterationCount;
this.maximalIterationCount = defaultMaximalIterationCount;
public double getResult() {
if (resultComputed) {
return result;
throw new IllegalStateException("No result available");
public int getIterationCount() {
if (resultComputed) {
return iterationCount;
throw new IllegalStateException("No result available");
protected final void setResult(double result, int iterationCount) {
this.result = result;
this.iterationCount = iterationCount;
this.resultComputed = true;
protected final void clearResult() {
this.resultComputed = false;
public void setAbsoluteAccuracy(double accuracy) {
absoluteAccuracy = accuracy;
public double getAbsoluteAccuracy() {
return absoluteAccuracy;
public void resetAbsoluteAccuracy() {
absoluteAccuracy = defaultAbsoluteAccuracy;
public void setMaximalIterationCount(int count) {
maximalIterationCount = count;
public int getMaximalIterationCount() {
return maximalIterationCount;
public void resetMaximalIterationCount() {
maximalIterationCount = defaultMaximalIterationCount;
public void setRelativeAccuracy(double accuracy) {
relativeAccuracy = accuracy;
public double getRelativeAccuracy() {
return relativeAccuracy;
public void resetRelativeAccuracy() {
relativeAccuracy = defaultRelativeAccuracy;
public void setFunctionValueAccuracy(double accuracy) {
functionValueAccuracy = accuracy;
public double getFunctionValueAccuracy() {
return functionValueAccuracy;
public void resetFunctionValueAccuracy() {
functionValueAccuracy = defaultFunctionValueAccuracy;
protected boolean isBracketing(double lower, double upper, 
UnivariateRealFunction f) throws FunctionEvaluationException {
double f1 = f.value(lower);
double f2 = f.value(upper);
return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));
protected boolean isSequence(double start, double mid, double end) {
return (start < mid) && (mid < end);
protected void verifyInterval(double lower, double upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("Endpoints do not specify an interval: [" + lower + 
"," + upper + "]");
protected void verifySequence(double lower, double initial, double upper) {
if (!isSequence(lower, initial, upper)) {
throw new IllegalArgumentException
("Invalid interval, initial value parameters:  lower=" + 
lower + " initial=" + initial + " upper=" + upper);
protected void verifyBracketing(double lower, double upper, 
UnivariateRealFunction f) throws FunctionEvaluationException {
verifyInterval(lower, upper);
if (!isBracketing(lower, upper, f)) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + lower + "," + upper + "]" + 
"  Values: [" + f.value(lower) + "," + f.value(upper) + "]");       
package org.apache.commons.math.analysis;
public class NevilleInterpolator implements UnivariateRealInterpolator,
Serializable {
public UnivariateRealFunction interpolate(double x[], double y[]) throws
MathException {
PolynomialFunctionLagrangeForm p;
p = new PolynomialFunctionLagrangeForm(x, y);
return p;
package org.apache.commons.math.analysis;
public interface UnivariateRealFunction {
public double value(double x) throws FunctionEvaluationException;
package org.apache.commons.math.analysis;
public class RombergIntegrator extends UnivariateRealIntegratorImpl {
private static final long serialVersionUID = -1058849527738180243L;
public RombergIntegrator(UnivariateRealFunction f) {
super(f, 32);
public double integrate(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException, IllegalArgumentException {
int i = 1, j, m = maximalIterationCount + 1;
double r, t[][] = new double[m][m], s, olds;
clearResult();
verifyInterval(min, max);
verifyIterationCount();
TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);
t[0][0] = qtrap.stage(min, max, 0);
olds = t[0][0];
while (i <= maximalIterationCount) {
t[i][0] = qtrap.stage(min, max, i);
for (j = 1; j <= i; j++) {
r = (1L << (2 * j)) -1;
t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;
s = t[i][i];
if (i >= minimalIterationCount) {
if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {
setResult(s, i);
return result;
olds = s;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 32) {
throw new IllegalArgumentException
("Iteration upper limit out of [0, 32] range: " +
maximalIterationCount);
package org.apache.commons.math.analysis;
public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {
private static final long serialVersionUID = 3405465123320678216L;
public SimpsonIntegrator(UnivariateRealFunction f) {
super(f, 64);
public double integrate(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException, IllegalArgumentException {
int i = 1;
double s, olds, t, oldt;
clearResult();
verifyInterval(min, max);
verifyIterationCount();
TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);
if (minimalIterationCount == 1) {
s = (4 * qtrap.stage(min, max, 1) - qtrap.stage(min, max, 0)) / 3.0;
setResult(s, 1);
return result;
olds = 0;
oldt = qtrap.stage(min, max, 0);
while (i <= maximalIterationCount) {
t = qtrap.stage(min, max, i);
s = (4 * t - oldt) / 3.0;
if (i >= minimalIterationCount) {
if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {
setResult(s, i);
return result;
olds = s;
oldt = t;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
throw new IllegalArgumentException
("Iteration upper limit out of [0, 64] range: " +
maximalIterationCount);
package org.apache.commons.math.analysis;
public class MullerSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = 6552227503458976920L;
public MullerSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
public double solve(double min, double max, double initial) throws
MaxIterationsExceededException, FunctionEvaluationException {
if (f.value(min) == 0.0) { return min; }
if (f.value(max) == 0.0) { return max; }
if (f.value(initial) == 0.0) { return initial; }
verifyBracketing(min, max, f);
verifySequence(min, initial, max);
if (isBracketing(min, initial, f)) {
return solve(min, initial);
return solve(initial, max);
public double solve(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException {
double x0, x1, x2, x, oldx, y0, y1, y2, y;
double d01, d12, d012, c1, delta, xplus, xminus, tolerance;
x0 = min; y0 = f.value(x0);
x2 = max; y2 = f.value(x2);
x1 = 0.5 * (x0 + x2); y1 = f.value(x1);
if (y0 == 0.0) { return min; }
if (y2 == 0.0) { return max; }
verifyBracketing(min, max, f);
int i = 1;
oldx = Double.POSITIVE_INFINITY;
while (i <= maximalIterationCount) {
d01 = (y1 - y0) / (x1 - x0);
d12 = (y2 - y1) / (x2 - x1);
d012 = (d12 - d01) / (x2 - x0);
c1 = d01 + (x1 - x0) * d012;
delta = c1 * c1 - 4 * y1 * d012;
xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));
xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));
x = isSequence(x0, xplus, x2) ? xplus : xminus;
y = f.value(x);
tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
if (Math.abs(x - oldx) <= tolerance) {
setResult(x, i);
return result;
if (Math.abs(y) <= functionValueAccuracy) {
setResult(x, i);
return result;
boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||
(x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||
(x == x1);
if (!bisect) {
x0 = x < x1 ? x0 : x1;
y0 = x < x1 ? y0 : y1;
x2 = x > x1 ? x2 : x1;
y2 = x > x1 ? y2 : y1;
x1 = x; y1 = y;
oldx = x;
double xm = 0.5 * (x0 + x2);
double ym = f.value(xm);
if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {
x2 = xm; y2 = ym;
x0 = xm; y0 = ym;
x1 = 0.5 * (x0 + x2);
y1 = f.value(x1);
oldx = Double.POSITIVE_INFINITY;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
public double solve2(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException {
double x0, x1, x2, x, oldx, y0, y1, y2, y;
double q, A, B, C, delta, denominator, tolerance;
x0 = min; y0 = f.value(x0);
x1 = max; y1 = f.value(x1);
x2 = 0.5 * (x0 + x1); y2 = f.value(x2);
if (y0 == 0.0) { return min; }
if (y1 == 0.0) { return max; }
verifyBracketing(min, max, f);
int i = 1;
oldx = Double.POSITIVE_INFINITY;
while (i <= maximalIterationCount) {
q = (x2 - x1) / (x1 - x0);
A = q * (y2 - (1 + q) * y1 + q * y0);
B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;
C = (1 + q) * y2;
delta = B * B - 4 * A * C;
if (delta >= 0.0) {
double dplus = B + Math.sqrt(delta);
double dminus = B - Math.sqrt(delta);
denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;
denominator = Math.sqrt(B * B - delta);
if (denominator != 0) {
x = x2 - 2.0 * C * (x2 - x1) / denominator;
while (x == x1 || x == x2) {
x += absoluteAccuracy;
x = min + Math.random() * (max - min);
oldx = Double.POSITIVE_INFINITY;
y = f.value(x);
tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
if (Math.abs(x - oldx) <= tolerance) {
setResult(x, i);
return result;
if (Math.abs(y) <= functionValueAccuracy) {
setResult(x, i);
return result;
x0 = x1; y0 = y1;
x1 = x2; y1 = y2;
x2 = x; y2 = y;
oldx = x;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public class BrentSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = -2136672307739067002L;
public BrentSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
public double solve(double min, double max, double initial)
throws MaxIterationsExceededException, FunctionEvaluationException {
if (((initial - min) * (max -initial)) < 0) {
throw new IllegalArgumentException("Initial guess is not in search"
+ " interval." + "  Initial: " + initial
+  "  Endpoints: [" + min + "," + max + "]");
double yInitial = f.value(initial);
if (Math.abs(yInitial) <= functionValueAccuracy) {
setResult(initial, 0);
return result;
double yMin = f.value(min);
if (Math.abs(yMin) <= functionValueAccuracy) {
setResult(yMin, 0);
return result;
if (yInitial * yMin < 0) {
return solve(min, yMin, initial, yInitial, min, yMin);
double yMax = f.value(max);
if (Math.abs(yMax) <= functionValueAccuracy) {
setResult(yMax, 0);
return result;
if (yInitial * yMax < 0) {
return solve(initial, yInitial, max, yMax, initial, yInitial);
return solve(min, yMin, max, yMax, initial, yInitial);
public double solve(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException {
clearResult();
verifyInterval(min, max);
double yMin = f.value(min);
double yMax = f.value(max);
if (yMin * yMax >= 0) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");       
return solve(min, yMin, max, yMax, min, yMin);
private double solve(double x0, double y0,
double x1, double y1,
double x2, double y2)
throws MaxIterationsExceededException, FunctionEvaluationException {
double delta = x1 - x0;
double oldDelta = delta;
int i = 0;
while (i < maximalIterationCount) {
if (Math.abs(y2) < Math.abs(y1)) {
x0 = x1;
x1 = x2;
x2 = x0;
y0 = y1;
y1 = y2;
y2 = y0;
if (Math.abs(y1) <= functionValueAccuracy) {
setResult(x1, i);
return result;
double dx = (x2 - x1);
double tolerance =
Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);
if (Math.abs(dx) <= tolerance) {
setResult(x1, i);
return result;
if ((Math.abs(oldDelta) < tolerance) ||
(Math.abs(y0) <= Math.abs(y1))) {
delta = 0.5 * dx;
oldDelta = delta;
double r3 = y1 / y0;
double p;
double p1;
if (x0 == x2) {
p = dx * r3;
p1 = 1.0 - r3;
double r1 = y0 / y2;
double r2 = y1 / y2;
p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));
p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);
if (p > 0.0) {
p1 = -p1;
p = -p;
if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||
p >= Math.abs(0.5 * oldDelta * p1)) {
delta = 0.5 * dx;
oldDelta = delta;
oldDelta = delta;
delta = p / p1;
x0 = x1;
y0 = y1;
if (Math.abs(delta) > tolerance) {
x1 = x1 + delta;
x1 = x1 + 0.5 * tolerance;
x1 = x1 - 0.5 * tolerance;
y1 = f.value(x1);
if ((y1 > 0) == (y2 > 0)) {
x2 = x0;
y2 = y0;
delta = x1 - x0;
oldDelta = delta;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,
Serializable {
private double coefficients[];
private double a[], c[];
private boolean coefficientsComputed;
PolynomialFunctionNewtonForm(double a[], double c[]) throws
IllegalArgumentException {
verifyInputArray(a, c);
this.a = new double[a.length];
this.c = new double[c.length];
System.arraycopy(a, 0, this.a, 0, a.length);
System.arraycopy(c, 0, this.c, 0, c.length);
coefficientsComputed = false;
public double value(double z) throws FunctionEvaluationException {
return evaluate(a, c, z);
public int degree() {
return c.length;
public double[] getNewtonCoefficients() {
double[] out = new double[a.length];
System.arraycopy(a, 0, out, 0, a.length);
return out;
public double[] getCenters() {
double[] out = new double[c.length];
System.arraycopy(c, 0, out, 0, c.length);
return out;
public double[] getCoefficients() {
if (!coefficientsComputed) {
computeCoefficients();
double[] out = new double[coefficients.length];
System.arraycopy(coefficients, 0, out, 0, coefficients.length);
return out;
public static double evaluate(double a[], double c[], double z) throws
FunctionEvaluationException, IllegalArgumentException {
verifyInputArray(a, c);
int n = c.length;
double value = a[n];
for (int i = n-1; i >= 0; i--) {
value = a[i] + (z - c[i]) * value;
return value;
protected void computeCoefficients() {
int i, j, n = degree();
coefficients = new double[n+1];
for (i = 0; i <= n; i++) {
coefficients[i] = 0.0;
coefficients[0] = a[n];
for (i = n-1; i >= 0; i--) {
for (j = n-i; j > 0; j--) {
coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];
coefficients[0] = a[i] - c[i] * coefficients[0];
coefficientsComputed = true;
protected static void verifyInputArray(double a[], double c[]) throws
IllegalArgumentException {
if (a.length < 1 || c.length < 1) {
throw new IllegalArgumentException
("Input arrays must not be empty.");
if (a.length != c.length + 1) {
throw new IllegalArgumentException
("Bad input array sizes, should have difference 1.");
package org.apache.commons.math.analysis;
public class LaguerreSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = -3775334783473775723L;
private PolynomialFunction p;
public LaguerreSolver(UnivariateRealFunction f) throws
IllegalArgumentException {
super(f, 100, 1E-6);
if (f instanceof PolynomialFunction) {
p = (PolynomialFunction)f;
throw new IllegalArgumentException("Function is not polynomial.");
public PolynomialFunction getPolynomialFunction() {
return new PolynomialFunction(p.getCoefficients());
public double solve(double min, double max, double initial) throws
ConvergenceException, FunctionEvaluationException {
if (p.value(min) == 0.0) { return min; }
if (p.value(max) == 0.0) { return max; }
if (p.value(initial) == 0.0) { return initial; }
verifyBracketing(min, max, p);
verifySequence(min, initial, max);
if (isBracketing(min, initial, p)) {
return solve(min, initial);
return solve(initial, max);
public double solve(double min, double max) throws ConvergenceException, 
FunctionEvaluationException {
if (p.value(min) == 0.0) { return min; }
if (p.value(max) == 0.0) { return max; }
verifyBracketing(min, max, p);
double coefficients[] = p.getCoefficients();
Complex c[] = new Complex[coefficients.length];
for (int i = 0; i < coefficients.length; i++) {
c[i] = new Complex(coefficients[i], 0.0);
Complex initial = new Complex(0.5 * (min + max), 0.0);
Complex z = solve(c, initial);
if (isRootOK(min, max, z)) {
setResult(z.getReal(), iterationCount);
return result;
Complex[] root = solveAll(c, initial);
for (int i = 0; i < root.length; i++) {
if (isRootOK(min, max, root[i])) {
setResult(root[i].getReal(), iterationCount);
return result;
throw new ConvergenceException();
protected boolean isRootOK(double min, double max, Complex z) {
double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);
return (isSequence(min, z.getReal(), max)) &&
(Math.abs(z.getImaginary()) <= tolerance ||
z.abs() <= functionValueAccuracy);
public Complex[] solveAll(double coefficients[], double initial) throws
ConvergenceException, FunctionEvaluationException {
Complex c[] = new Complex[coefficients.length];
Complex z = new Complex(initial, 0.0);
for (int i = 0; i < c.length; i++) {
c[i] = new Complex(coefficients[i], 0.0);
return solveAll(c, z);
public Complex[] solveAll(Complex coefficients[], Complex initial) throws
MaxIterationsExceededException, FunctionEvaluationException {
int n = coefficients.length - 1;
int iterationCount = 0;
if (n < 1) {
throw new IllegalArgumentException
("Polynomial degree must be positive: degree=" + n);
Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial
for (int i = 0; i <= n; i++) {
c[i] = coefficients[i];
Complex root[] = new Complex[n];
for (int i = 0; i < n; i++) {
Complex subarray[] = new Complex[n-i+1];
System.arraycopy(c, 0, subarray, 0, subarray.length);
root[i] = solve(subarray, initial);
Complex newc = c[n-i];
Complex oldc = null;
for (int j = n-i-1; j >= 0; j--) {
oldc = c[j];
c[j] = newc;
newc = oldc.add(newc.multiply(root[i]));
iterationCount += this.iterationCount;
resultComputed = true;
this.iterationCount = iterationCount;
return root;
public Complex solve(Complex coefficients[], Complex initial) throws
MaxIterationsExceededException, FunctionEvaluationException {
int n = coefficients.length - 1;
if (n < 1) {
throw new IllegalArgumentException
("Polynomial degree must be positive: degree=" + n);
Complex N = new Complex((double)n, 0.0);
Complex N1 = new Complex((double)(n-1), 0.0);
int i = 1;
Complex pv = null;
Complex dv = null;
Complex d2v = null;
Complex G = null;
Complex G2 = null;
Complex H = null;
Complex delta = null;
Complex denominator = null;
Complex z = initial;
Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
while (i <= maximalIterationCount) {
pv = coefficients[n];
dv = Complex.ZERO;
d2v = Complex.ZERO;
for (int j = n-1; j >= 0; j--) {
d2v = dv.add(z.multiply(d2v));
dv = pv.add(z.multiply(dv));
pv = coefficients[j].add(z.multiply(pv));
d2v = d2v.multiply(new Complex(2.0, 0.0));
double tolerance = Math.max(relativeAccuracy * z.abs(),
absoluteAccuracy);
if ((z.subtract(oldz)).abs() <= tolerance) {
resultComputed = true;
iterationCount = i;
return z;
if (pv.abs() <= functionValueAccuracy) {
resultComputed = true;
iterationCount = i;
return z;
G = dv.divide(pv);
G2 = G.multiply(G);
H = G2.subtract(d2v.divide(pv));
delta = N1.multiply((N.multiply(H)).subtract(G2));
Complex dplus = G.add(ComplexUtils.sqrt(delta));
Complex dminus = G.subtract(ComplexUtils.sqrt(delta));
denominator = dplus.abs() > dminus.abs() ? dplus : dminus;
if (denominator.equals(new Complex(0.0, 0.0))) {
z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));
oldz = new Complex(Double.POSITIVE_INFINITY,
Double.POSITIVE_INFINITY);
oldz = z;
z = z.subtract(N.divide(denominator));
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,
Serializable {
private double coefficients[];
private double x[], y[];
private boolean coefficientsComputed;
PolynomialFunctionLagrangeForm(double x[], double y[]) throws
IllegalArgumentException {
verifyInterpolationArray(x, y);
this.x = new double[x.length];
this.y = new double[y.length];
System.arraycopy(x, 0, this.x, 0, x.length);
System.arraycopy(y, 0, this.y, 0, y.length);
coefficientsComputed = false;
public double value(double z) throws FunctionEvaluationException {
return evaluate(x, y, z);
throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);
public int degree() {
return x.length - 1;
public double[] getInterpolatingPoints() {
double[] out = new double[x.length];
System.arraycopy(x, 0, out, 0, x.length);
return out;
public double[] getInterpolatingValues() {
double[] out = new double[y.length];
System.arraycopy(y, 0, out, 0, y.length);
return out;
public double[] getCoefficients() {
if (!coefficientsComputed) {
computeCoefficients();
double[] out = new double[coefficients.length];
System.arraycopy(coefficients, 0, out, 0, coefficients.length);
return out;
public static double evaluate(double x[], double y[], double z) throws
DuplicateSampleAbscissaException, IllegalArgumentException {
int i, j, n, nearest = 0;
double value, c[], d[], tc, td, divider, w, dist, min_dist;
verifyInterpolationArray(x, y);
n = x.length;
c = new double[n];
d = new double[n];
min_dist = Double.POSITIVE_INFINITY;
for (i = 0; i < n; i++) {
c[i] = y[i];
d[i] = y[i];
dist = Math.abs(z - x[i]);
if (dist < min_dist) {
nearest = i;
min_dist = dist;
value = y[nearest];
for (i = 1; i < n; i++) {
for (j = 0; j < n-i; j++) {
tc = x[j] - z;
td = x[i+j] - z;
divider = x[j] - x[i+j];
if (divider == 0.0) {
throw new DuplicateSampleAbscissaException(x[i], i, i+j);
w = (c[j+1] - d[j]) / divider;
c[j] = tc * w;
d[j] = td * w;
if (nearest < 0.5*(n-i+1)) {
value += c[nearest];    // fork down
nearest--;
value += d[nearest];    // fork up
return value;
protected void computeCoefficients() throws ArithmeticException {
int i, j, n;
double c[], tc[], d, t;
n = degree() + 1;
coefficients = new double[n];
for (i = 0; i < n; i++) {
coefficients[i] = 0.0;
c = new double[n+1];
c[0] = 1.0;
for (i = 0; i < n; i++) {
for (j = i; j > 0; j--) {
c[j] = c[j-1] - c[j] * x[i];
c[0] *= (-x[i]);
c[i+1] = 1;
tc = new double[n];
for (i = 0; i < n; i++) {
d = 1;
for (j = 0; j < n; j++) {
if (i != j) {
d *= (x[i] - x[j]);
if (d == 0.0) {
throw new ArithmeticException
("Identical abscissas cause division by zero.");
t = y[i] / d;
tc[n-1] = c[n];     // actually c[n] = 1
coefficients[n-1] += t * tc[n-1];
for (j = n-2; j >= 0; j--) {
tc[j] = c[j+1] + tc[j+1] * x[i];
coefficients[j] += t * tc[j];
coefficientsComputed = true;
protected static void verifyInterpolationArray(double x[], double y[]) throws
IllegalArgumentException {
if (x.length < 2 || y.length < 2) {
throw new IllegalArgumentException
("Interpolation requires at least two points.");
if (x.length != y.length) {
throw new IllegalArgumentException
("Abscissa and value arrays must have the same length.");
package org.apache.commons.math.analysis;
public class NewtonSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = 2067325783137941016L;
private transient UnivariateRealFunction derivative;
public NewtonSolver(DifferentiableUnivariateRealFunction f) {
super(f, 100, 1E-6);
derivative = f.derivative();
public double solve(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException  {
return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));
public double solve(double min, double max, double startValue)
throws MaxIterationsExceededException, FunctionEvaluationException {
clearResult();
verifySequence(min, startValue, max);
double x0 = startValue;
double x1;
int i = 0;
while (i < maximalIterationCount) {
x1 = x0 - (f.value(x0) / derivative.value(x0));
if (Math.abs(x1 - x0) <= absoluteAccuracy) {
setResult(x1, i);
return x1;
x0 = x1;
++i;
throw new MaxIterationsExceededException(maximalIterationCount);
private void readObject(java.io.ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
derivative = ((DifferentiableUnivariateRealFunction) f).derivative();
package org.apache.commons.math.analysis;
public class PolynomialSplineFunction 
implements DifferentiableUnivariateRealFunction, Serializable {
private static final long serialVersionUID = 1619940313389547244L;
private double knots[];
private PolynomialFunction polynomials[] = null;
private int n = 0;
public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {
if (knots.length < 2) {
throw new IllegalArgumentException
("Not enough knot values -- spline partition must have at least 2 points.");
if (knots.length - 1 != polynomials.length) {
throw new IllegalArgumentException 
("Number of polynomial interpolants must match the number of segments.");
if (!isStrictlyIncreasing(knots)) {
throw new IllegalArgumentException 
("Knot values must be strictly increasing.");
this.n = knots.length -1;
this.knots = new double[n + 1];
System.arraycopy(knots, 0, this.knots, 0, n + 1);
this.polynomials = new PolynomialFunction[n];
System.arraycopy(polynomials, 0, this.polynomials, 0, n);
public double value(double v) throws ArgumentOutsideDomainException {
if (v < knots[0] || v > knots[n]) {
throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);
int i = Arrays.binarySearch(knots, v);
if (i < 0) {
i = -i - 2;
if ( i >= polynomials.length ) {
i--;
return polynomials[i].value(v - knots[i]);
public UnivariateRealFunction derivative() {
return polynomialSplineDerivative();
public PolynomialSplineFunction polynomialSplineDerivative() {
PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];
for (int i = 0; i < n; i++) {
derivativePolynomials[i] = polynomials[i].polynomialDerivative();
return new PolynomialSplineFunction(knots, derivativePolynomials);
public int getN() {
return n;
public PolynomialFunction[] getPolynomials() {
PolynomialFunction p[] = new PolynomialFunction[n];
System.arraycopy(polynomials, 0, p, 0, n);
return p;
public double[] getKnots() {
double out[] = new double[n + 1];
System.arraycopy(knots, 0, out, 0, n + 1);
return out;  
private static boolean isStrictlyIncreasing(double[] x) {
for (int i = 1; i < x.length; ++i) {
if (x[i - 1] >= x[i]) {
return false;
return true;
package org.apache.commons.math.analysis;
public class RiddersSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = -4703139035737911735L;
public RiddersSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
public double solve(double min, double max, double initial) throws
MaxIterationsExceededException, FunctionEvaluationException {
if (f.value(min) == 0.0) { return min; }
if (f.value(max) == 0.0) { return max; }
if (f.value(initial) == 0.0) { return initial; }
verifyBracketing(min, max, f);
verifySequence(min, initial, max);
if (isBracketing(min, initial, f)) {
return solve(min, initial);
return solve(initial, max);
public double solve(double min, double max) throws MaxIterationsExceededException, 
FunctionEvaluationException {
double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;
x1 = min; y1 = f.value(x1);
x2 = max; y2 = f.value(x2);
if (y1 == 0.0) { return min; }
if (y2 == 0.0) { return max; }
verifyBracketing(min, max, f);
int i = 1;
oldx = Double.POSITIVE_INFINITY;
while (i <= maximalIterationCount) {
x3 = 0.5 * (x1 + x2);
y3 = f.value(x3);
if (Math.abs(y3) <= functionValueAccuracy) {
setResult(x3, i);
return result;
delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing
correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *
(x3 - x1) / Math.sqrt(delta);
x = x3 - correction;                // correction != 0
y = f.value(x);
tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
if (Math.abs(x - oldx) <= tolerance) {
setResult(x, i);
return result;
if (Math.abs(y) <= functionValueAccuracy) {
setResult(x, i);
return result;
if (correction > 0.0) {             // x1 < x < x3
if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {
x2 = x; y2 = y;
x1 = x; x2 = x3;
y1 = y; y2 = y3;
if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {
x1 = x; y1 = y;
x1 = x3; x2 = x;
y1 = y3; y2 = y;
oldx = x;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public class BisectionSolver extends UnivariateRealSolverImpl {
private static final long serialVersionUID = 4963578633786538912L;
public BisectionSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
public double solve(double min, double max, double initial)
throws MaxIterationsExceededException, FunctionEvaluationException {
return solve(min, max);
public double solve(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException {
clearResult();
verifyInterval(min,max);
double m;
double fm;
double fmin;
int i = 0;
while (i < maximalIterationCount) {
m = UnivariateRealSolverUtils.midpoint(min, max);
fmin = f.value(min);
fm = f.value(m);
if (fm * fmin > 0.0) {
min = m;
max = m;
if (Math.abs(max - min) <= absoluteAccuracy) {
m = UnivariateRealSolverUtils.midpoint(min, max);
setResult(m, i);
return m;
++i;
throw new MaxIterationsExceededException(maximalIterationCount);
package org.apache.commons.math.analysis;
public interface DifferentiableUnivariateRealFunction
extends UnivariateRealFunction {
public UnivariateRealFunction derivative();
package org.apache.commons.math.analysis;
public class SplineInterpolator implements UnivariateRealInterpolator {
public UnivariateRealFunction interpolate(double x[], double y[]) {
if (x.length != y.length) {
throw new IllegalArgumentException("Dataset arrays must have same length.");
if (x.length < 3) {
throw new IllegalArgumentException
("At least 3 datapoints are required to compute a spline interpolant");
int n = x.length - 1;   
for (int i = 0; i < n; i++) {
if (x[i]  >= x[i + 1]) {
throw new IllegalArgumentException("Dataset x values must be strictly increasing.");
double h[] = new double[n];
for (int i = 0; i < n; i++) {
h[i] = x[i + 1] - x[i];
double mu[] = new double[n];
double z[] = new double[n + 1];
mu[0] = 0d;
z[0] = 0d;
double g = 0;
for (int i = 1; i < n; i++) {
g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];
mu[i] = h[i] / g;
z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /
(h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;
double b[] = new double[n];
double c[] = new double[n + 1];
double d[] = new double[n];
z[n] = 0d;
c[n] = 0d;
for (int j = n -1; j >=0; j--) {
c[j] = z[j] - mu[j] * c[j + 1];
b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;
d[j] = (c[j + 1] - c[j]) / (3d * h[j]);
PolynomialFunction polynomials[] = new PolynomialFunction[n];
double coefficients[] = new double[4];
for (int i = 0; i < n; i++) {
coefficients[0] = y[i];
coefficients[1] = b[i];
coefficients[2] = c[i];
coefficients[3] = d[i];
polynomials[i] = new PolynomialFunction(coefficients);
return new PolynomialSplineFunction(x, polynomials);
package org.apache.commons.math.analysis;
public interface UnivariateRealSolver {
void setMaximalIterationCount(int count);
int getMaximalIterationCount();
void resetMaximalIterationCount();
void setAbsoluteAccuracy(double accuracy);
double getAbsoluteAccuracy();
void resetAbsoluteAccuracy();
void setRelativeAccuracy(double accuracy);
double getRelativeAccuracy();
void resetRelativeAccuracy();
void setFunctionValueAccuracy(double accuracy);
double getFunctionValueAccuracy();
void resetFunctionValueAccuracy();
double solve(double min, double max) throws ConvergenceException, 
FunctionEvaluationException;
double solve(double min, double max, double startValue)
throws ConvergenceException, FunctionEvaluationException;
double getResult();
int getIterationCount();
package org.apache.commons.math.analysis;
public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {
private static final long serialVersionUID = 3322454535052136809L;
private double coefficients[];
public PolynomialFunction(double c[]) {
super();
if (c.length < 1) {
throw new IllegalArgumentException("Polynomial coefficient array must have postive length.");
this.coefficients = new double[c.length];
System.arraycopy(c, 0, this.coefficients, 0, c.length);
public double value(double x) {
return evaluate(coefficients, x);
public int degree() {
return coefficients.length - 1;
public double[] getCoefficients() {
double[] out = new double[coefficients.length];
System.arraycopy(coefficients,0, out, 0, coefficients.length);
return out;
protected static double evaluate(double[] coefficients, double argument) {
int n = coefficients.length;
if (n < 1) {
throw new IllegalArgumentException("Coefficient array must have positive length for evaluation");
double result = coefficients[n - 1];
for (int j = n -2; j >=0; j--) {
result = argument * result + coefficients[j];
return result;
protected static double[] differentiate(double[] coefficients) {
int n = coefficients.length;
if (n < 1) {
throw new IllegalArgumentException("Coefficient array must have positive length for differentiation");
if (n == 1) {
return new double[]{0};
double[] result = new double[n - 1];
for (int i = n - 1; i  > 0; i--) {
result[i - 1] = (double) i * coefficients[i];
return result;
public PolynomialFunction polynomialDerivative() {
return new PolynomialFunction(differentiate(coefficients));
public UnivariateRealFunction derivative() {
return polynomialDerivative();
package org.apache.commons.math.analysis;
public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {
private static final long serialVersionUID = 4978222553983172543L;
private double s;
public TrapezoidIntegrator(UnivariateRealFunction f) {
super(f, 64);
double stage(double min, double max, int n) throws
FunctionEvaluationException {
long i, np;
double x, spacing, sum = 0;
if (n == 0) {
s = 0.5 * (max - min) * (f.value(min) + f.value(max));
return s;
np = 1L << (n-1);           // number of new points in this stage
spacing = (max - min) / np; // spacing between adjacent new points
x = min + 0.5 * spacing;    // the first new point
for (i = 0; i < np; i++) {
sum += f.value(x);
x += spacing;
s = 0.5 * (s + sum * spacing);
return s;
public double integrate(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException, IllegalArgumentException {
int i = 1;
double t, oldt;
clearResult();
verifyInterval(min, max);
verifyIterationCount();
oldt = stage(min, max, 0);
while (i <= maximalIterationCount) {
t = stage(min, max, i);
if (i >= minimalIterationCount) {
if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {
setResult(t, i);
return result;
oldt = t;
i++;
throw new MaxIterationsExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
throw new IllegalArgumentException
("Iteration upper limit out of [0, 64] range: " +
maximalIterationCount);
package org.apache.commons.math;
public class MessagesResources_fr
extends ListResourceBundle {
public MessagesResources_fr() {
public Object[][] getContents() {
return (Object[][]) contents.clone();
"Erreur d''\u00e9valuation pour l''argument {0}" },
"Abscisse {0} dupliqu\u00e9e aux indices {1} et {2}" },
"\u00c9chec de convergence" },
"Argument {0} hors du domaine [{1} ; {2}]" },
"Nombre maximal d''it\u00e9rations ({0}) d\u00e9pass\u00e9" },
"dimensions incompatibles {0} != {1}" },
"matrice non d\u00e9finie positive" },
"Impossible de convertir {0} en fraction apr\u00e8s {1} it\u00e9rations" },
" final a value={5}, final b value={6}, f(a)={7}, f(b)={8}",
"Nombre d''it\u00e9rations = {0}, it\u00e9rations maximum = {1}, valeur initiale = {2}," +
" borne inf\u00e9rieure = {3}, borne sup\u00e9rieure = {4}," +
" valeur a finale = {5}, valeur b finale = {6}, f(a) = {7}, f(b) = {8}" },
"Divergence de fraction continue \u00e0 l''infini pour la valeur {0}" },
"\u00c9chec de convergence de fraction continue pour la valeur {0}" },
"Exception de conversion dans une transformation, l''objet est nul" },
"Exception de conversion dans une transformation : {0}" },
"pas de convergence apr\u00e8s {0} it\u00e9rations" },
"trop petite tol\u00e9rance relative sur le co\u00fbt ({0}), aucune r\u00e9duction de la somme des carr\u00e9s n''est possible" },
"trop petite tol\u00e9rance relative sur les param\u00e8tres ({0}), aucune am\u00e9lioration de la solution approximative n''est possible" },
"trop petite tol\u00e9rance sur l''orthogonalit\u00e9 ({0}), la solution est orthogonale \u00e0 la jacobienne" },
"nombre maximal d''\u00e9valuations d\u00e9pass\u00e9 ({0})" },
"singularit\u00e9 d''angles de Cardan" },
"singularit\u00e9 d''angles d''Euler" },
"une matrice {0}x{1} ne peut pas \u00eatre une matrice de rotation" },
"la matrice orthogonale la plus proche a un d\u00e9terminant n\u00e9gatif {0}" },
"impossible de rendre la matrice orthogonale en {0} it\u00e9rations" },
"pas minimal ({0}) atteint, l''int\u00e9gration n\u00e9cessite {1}" },
+ " state vector has dimension {1}",
"incompatibilit\u00e9 de dimensions entre le probl\u00e8me ODE ({0}),"
+ " et le vecteur d''\u00e9tat ({1})" },
"intervalle d''int\u00e9gration trop petit : {0}" },
"aucun des {0} points de d\u00e9part n''aboutit \u00e0 une convergence"  }
package org.apache.commons.math.util;
public interface DoubleArray {
int getNumElements();
double getElement(int index);
void setElement(int index, double value);
void addElement(double value);
double addElementRolling(double value);
double[] getElements();
void clear();
package org.apache.commons.math.util;
public class ResizableDoubleArray implements DoubleArray, Serializable {
private static final long serialVersionUID = -3485529955529426875L; 
public static final int ADDITIVE_MODE = 1;
public static final int MULTIPLICATIVE_MODE = 0;
protected float contractionCriteria = 2.5f;
protected float expansionFactor = 2.0f;
protected int expansionMode = MULTIPLICATIVE_MODE;
protected int initialCapacity = 16;
protected double[] internalArray;
protected int numElements = 0;
protected int startIndex = 0;
public ResizableDoubleArray() {
internalArray = new double[initialCapacity];
public ResizableDoubleArray(int initialCapacity) {
setInitialCapacity(initialCapacity);
internalArray = new double[this.initialCapacity];
public ResizableDoubleArray(int initialCapacity, float expansionFactor) {
this.expansionFactor = expansionFactor;
setInitialCapacity(initialCapacity);
internalArray = new double[initialCapacity];
setContractionCriteria(expansionFactor +0.5f);
public ResizableDoubleArray(int initialCapacity, float expansionFactor,
float contractionCriteria) {
this.expansionFactor = expansionFactor;
setContractionCriteria(contractionCriteria);
setInitialCapacity(initialCapacity);
internalArray = new double[initialCapacity];
public ResizableDoubleArray(int initialCapacity, float expansionFactor,
float contractionCriteria, int expansionMode) {
this.expansionFactor = expansionFactor;
setContractionCriteria(contractionCriteria);
setInitialCapacity(initialCapacity);
setExpansionMode(expansionMode);
internalArray = new double[initialCapacity];
public synchronized void addElement(double value) {
numElements++;
if ((startIndex + numElements) > internalArray.length) {
expand();
internalArray[startIndex + (numElements - 1)] = value;
if (shouldContract()) {
contract();
public synchronized double addElementRolling(double value) {
double discarded = internalArray[startIndex];
if ((startIndex + (numElements + 1)) > internalArray.length) {
expand();
startIndex += 1;
internalArray[startIndex + (numElements - 1)] = value;
if (shouldContract()) {
contract();
return discarded;
protected void checkContractExpand(
float contractionCritera,
float expansionFactor) {
if (contractionCritera < expansionFactor) {
String msg =
"Contraction criteria can never be smaller than " +
"the expansion factor.  This would lead to a never " +
"ending loop of expansion and contraction as a newly " +
"expanded internal storage array would immediately " +
"satisfy the criteria for contraction";
throw new IllegalArgumentException(msg);
if (contractionCriteria <= 1.0) {
String msg =
"The contraction criteria must be a number larger " +
"than one.  If the contractionCriteria is less than or " +
"equal to one an endless loop of contraction and " +
"expansion would ensue as an internalArray.length " +
"== numElements would satisfy the contraction criteria";
throw new IllegalArgumentException(msg);
if (expansionFactor <= 1.0) {
String msg =
"The expansion factor must be a number greater than 1.0";
throw new IllegalArgumentException(msg);
public synchronized void clear() {
numElements = 0;
internalArray = new double[initialCapacity];
public synchronized void contract() {
double[] tempArray = new double[numElements + 1];
System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);
internalArray = tempArray;
startIndex = 0;
public synchronized void discardFrontElements(int i) {
if (i > numElements) {
String msg = "Cannot discard more elements than are" +
"contained in this array.";
throw new IllegalArgumentException(msg);
String msg = "Cannot discard a negative number of elements.";
throw new IllegalArgumentException(msg);
numElements -= i;
startIndex += i;
if (shouldContract()) {
contract();
protected synchronized void expand() {
int newSize = 0;
if (expansionMode == MULTIPLICATIVE_MODE) {
newSize = (int) Math.ceil(internalArray.length * expansionFactor);
newSize = internalArray.length + Math.round(expansionFactor);
double[] tempArray = new double[newSize];
System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);
internalArray = tempArray;
private synchronized void expandTo(int size) {
double[] tempArray = new double[size];
System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);
internalArray = tempArray;
public float getContractionCriteria() {
return contractionCriteria;
public synchronized double getElement(int index) {
if (index >= numElements) {
String msg =
"The index specified: " + index +
" is larger than the current number of elements";
throw new ArrayIndexOutOfBoundsException(msg);
return internalArray[startIndex + index];
String msg =
"Elements cannot be retrieved from a negative array index";
throw new ArrayIndexOutOfBoundsException(msg);
public synchronized double[] getElements() {
double[] elementArray = new double[numElements];
System.arraycopy( internalArray, startIndex, elementArray, 0,
numElements);
return elementArray;
public float getExpansionFactor() {
return expansionFactor;
public int getExpansionMode() {
return expansionMode;
synchronized int getInternalLength() {
return (internalArray.length);
public synchronized int getNumElements() {
return (numElements);
public synchronized double[] getValues() {
return (internalArray);
public void setContractionCriteria(float contractionCriteria) {
checkContractExpand(contractionCriteria, getExpansionFactor());
this.contractionCriteria = contractionCriteria;
public synchronized void setElement(int index, double value) {
if (index < 0) {
String msg = "Cannot set an element at a negative index";
throw new ArrayIndexOutOfBoundsException(msg);
if (index + 1 > numElements) {
numElements = index + 1;
if ((startIndex + index) >= internalArray.length) {
expandTo(startIndex + (index + 1));
internalArray[startIndex + index] = value;
public void setExpansionFactor(float expansionFactor) {
checkContractExpand(getContractionCriteria(), expansionFactor);
this.expansionFactor = expansionFactor;
public void setExpansionMode(int expansionMode) {
if (expansionMode != MULTIPLICATIVE_MODE && 
expansionMode != ADDITIVE_MODE) {
throw new IllegalArgumentException("Illegal expansionMode setting.");  
this.expansionMode = expansionMode;
protected void setInitialCapacity(int initialCapacity) {
if (initialCapacity > 0) {
this.initialCapacity = initialCapacity;
String msg =
"The initial capacity supplied: " + initialCapacity +
"must be a positive integer";
throw new IllegalArgumentException(msg);
public synchronized void setNumElements(int i) {
if (i < 0) {
String msg =
"Number of elements must be zero or a positive " + "integer";
throw new IllegalArgumentException(msg);
if ((startIndex + i) > internalArray.length) {
expandTo(startIndex + i);
numElements = i;
private synchronized boolean shouldContract() {
if (expansionMode == MULTIPLICATIVE_MODE) { 
return (internalArray.length / ((float) numElements)) > contractionCriteria;
return (internalArray.length - numElements) > contractionCriteria;
public synchronized int start() {
return startIndex;
package org.apache.commons.math.util;
public final class MathUtils {
private static final byte  NB = (byte)-1;
private static final short NS = (short)-1;
private static final byte  PB = (byte)1;
private static final short PS = (short)1;
private static final byte  ZB = (byte)0;
private static final short ZS = (short)0;
private MathUtils() {
super();
public static int addAndCheck(int x, int y) {
long s = (long)x + (long)y;
if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
throw new ArithmeticException("overflow: add");
return (int)s;
public static long binomialCoefficient(final int n, final int k) {
if (n < k) {
throw new IllegalArgumentException(
"must have n >= k for binomial coefficient (n,k)");
if (n < 0) {
throw new IllegalArgumentException(
"must have n >= 0 for binomial coefficient (n,k)");
if ((n == k) || (k == 0)) {
return 1;
if ((k == 1) || (k == n - 1)) {
return n;
long result = Math.round(binomialCoefficientDouble(n, k));
if (result == Long.MAX_VALUE) {
throw new ArithmeticException(
"result too large to represent in a long integer");
return result;
public static double log(double base, double x) {
return Math.log(x)/Math.log(base);
public static double binomialCoefficientDouble(final int n, final int k) {
return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
public static double binomialCoefficientLog(final int n, final int k) {
if (n < k) {
throw new IllegalArgumentException(
"must have n >= k for binomial coefficient (n,k)");
if (n < 0) {
throw new IllegalArgumentException(
"must have n >= 0 for binomial coefficient (n,k)");
if ((n == k) || (k == 0)) {
return 0;
if ((k == 1) || (k == n - 1)) {
return Math.log((double)n);
double logSum = 0;
for (int i = k + 1; i <= n; i++) {
logSum += Math.log((double)i);
for (int i = 2; i <= n - k; i++) {
logSum -= Math.log((double)i);
return logSum;
public static double cosh(double x) {
return (Math.exp(x) + Math.exp(-x)) / 2.0;
public static boolean equals(double x, double y) {
return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);
public static long factorial(final int n) {
long result = Math.round(factorialDouble(n));
if (result == Long.MAX_VALUE) {
throw new ArithmeticException(
"result too large to represent in a long integer");
return result;
public static double factorialDouble(final int n) {
if (n < 0) {
throw new IllegalArgumentException("must have n >= 0 for n!");
return Math.floor(Math.exp(factorialLog(n)) + 0.5);
public static double factorialLog(final int n) {
if (n < 0) {
throw new IllegalArgumentException("must have n > 0 for n!");
double logSum = 0;
for (int i = 2; i <= n; i++) {
logSum += Math.log((double)i);
return logSum;
public static int gcd(int u, int v) {
if (u * v == 0) {
return (Math.abs(u) + Math.abs(v));
if (u > 0) {
u = -u;
if (v > 0) {
v = -v;
int k = 0;
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
u /= 2;
v /= 2;
k++; // cast out twos.
if (k == 31) {
throw new ArithmeticException("overflow: gcd is 2^31");
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
do {
while ((t & 1) == 0) { // while t is even..
t /= 2; // cast out twos
if (t > 0) {
u = -t;
v = t;
t = (v - u) / 2;
return -u * (1 << k); // gcd is u*2^k
public static int hash(double value) {
long bits = Double.doubleToLongBits(value);
return (int)(bits ^ (bits >>> 32));
public static byte indicator(final byte x) {
return (x >= ZB) ? PB : NB;
public static double indicator(final double x) {
if (Double.isNaN(x)) {
return Double.NaN;
return (x >= 0.0) ? 1.0 : -1.0;
public static float indicator(final float x) {
if (Float.isNaN(x)) {
return Float.NaN;
return (x >= 0.0F) ? 1.0F : -1.0F;
public static int indicator(final int x) {
return (x >= 0) ? 1 : -1;
public static long indicator(final long x) {
return (x >= 0L) ? 1L : -1L;
public static short indicator(final short x) {
return (x >= ZS) ? PS : NS;
public static int lcm(int a, int b) {
return Math.abs(mulAndCheck(a / gcd(a, b), b));
public static int mulAndCheck(int x, int y) {
long m = ((long)x) * ((long)y);
if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
throw new ArithmeticException("overflow: mul");
return (int)m;
public static double nextAfter(double d, double direction) {
if (Double.isNaN(d) || Double.isInfinite(d)) {
return d;
return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
long bits     = Double.doubleToLongBits(d);
long sign     = bits & 0x8000000000000000L;
long exponent = bits & 0x7ff0000000000000L;
long mantissa = bits & 0x000fffffffffffffL;
if (d * (direction - d) >= 0) {
if (mantissa == 0x000fffffffffffffL) {
return Double.longBitsToDouble(sign |
(exponent + 0x0010000000000000L));
return Double.longBitsToDouble(sign |
exponent | (mantissa + 1));
if (mantissa == 0L) {
return Double.longBitsToDouble(sign |
(exponent - 0x0010000000000000L) |
0x000fffffffffffffL);
return Double.longBitsToDouble(sign |
exponent | (mantissa - 1));
public static double round(double x, int scale) {
return round(x, scale, BigDecimal.ROUND_HALF_UP);
public static double round(double x, int scale, int roundingMethod) {
return (new BigDecimal
(Double.toString(x))
.setScale(scale, roundingMethod))
.doubleValue();
if (Double.isInfinite(x)) {
return x;          
return Double.NaN;
public static float round(float x, int scale) {
return round(x, scale, BigDecimal.ROUND_HALF_UP);
public static float round(float x, int scale, int roundingMethod) {
float sign = indicator(x);
float factor = (float)Math.pow(10.0f, scale) * sign;
return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;
private static double roundUnscaled(double unscaled, double sign,
int roundingMethod) {
switch (roundingMethod) {
case BigDecimal.ROUND_CEILING :
if (sign == -1) {
unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
break;
case BigDecimal.ROUND_DOWN :
unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
break;
case BigDecimal.ROUND_FLOOR :
if (sign == -1) {
unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
break;
case BigDecimal.ROUND_HALF_DOWN : {
unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);
double fraction = unscaled - Math.floor(unscaled);
if (fraction > 0.5) {
unscaled = Math.ceil(unscaled);
unscaled = Math.floor(unscaled);
break;
case BigDecimal.ROUND_HALF_EVEN : {
double fraction = unscaled - Math.floor(unscaled);
if (fraction > 0.5) {
unscaled = Math.ceil(unscaled);
unscaled = Math.floor(unscaled);
if (Math.floor(unscaled) / 2.0 == Math.floor(Math
.floor(unscaled) / 2.0)) { // even
unscaled = Math.floor(unscaled);
unscaled = Math.ceil(unscaled);
break;
case BigDecimal.ROUND_HALF_UP : {
unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);
double fraction = unscaled - Math.floor(unscaled);
if (fraction >= 0.5) {
unscaled = Math.ceil(unscaled);
unscaled = Math.floor(unscaled);
break;
case BigDecimal.ROUND_UNNECESSARY :
if (unscaled != Math.floor(unscaled)) {
throw new ArithmeticException("Inexact result from rounding");
break;
case BigDecimal.ROUND_UP :
unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));
break;
default :
throw new IllegalArgumentException("Invalid rounding method.");
return unscaled;
public static byte sign(final byte x) {
return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
public static double sign(final double x) {
if (Double.isNaN(x)) {
return Double.NaN;
return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
public static float sign(final float x) {
if (Float.isNaN(x)) {
return Float.NaN;
return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
public static int sign(final int x) {
return (x == 0) ? 0 : (x > 0) ? 1 : -1;
public static long sign(final long x) {
return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
public static short sign(final short x) {
return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
public static double sinh(double x) {
return (Math.exp(x) - Math.exp(-x)) / 2.0;
public static int subAndCheck(int x, int y) {
long s = (long)x - (long)y;
if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
throw new ArithmeticException("overflow: subtract");
return (int)s;
package org.apache.commons.math.util;
public interface NumberTransformer {
double transform(Object o) throws MathException;
package org.apache.commons.math.util;
public abstract class ContinuedFraction implements Serializable {
private static final long serialVersionUID = 1768555336266158242L;
private static final double DEFAULT_EPSILON = 10e-9;
protected ContinuedFraction() {
super();
protected abstract double getA(int n, double x);
protected abstract double getB(int n, double x);
public double evaluate(double x) throws MathException {
return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);
public double evaluate(double x, double epsilon) throws MathException {
return evaluate(x, epsilon, Integer.MAX_VALUE);
public double evaluate(double x, int maxIterations) throws MathException {
return evaluate(x, DEFAULT_EPSILON, maxIterations);
public double evaluate(double x, double epsilon, int maxIterations)
throws MathException
double p0 = 1.0;
double p1 = getA(0, x);
double q0 = 0.0;
double q1 = 1.0;
double c = p1 / q1;
int n = 0;
double relativeError = Double.MAX_VALUE;
while (n < maxIterations && relativeError > epsilon) {
++n;
double a = getA(n, x);
double b = getB(n, x);
double p2 = a * p1 + b * p0;
double q2 = a * q1 + b * q0;
if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
if (a != 0.0) {
p2 = p1 + (b / a * p0);
q2 = q1 + (b / a * q0);
p2 = (a / b * p1) + p0;
q2 = (a / b * q1) + q0;
throw new ConvergenceException(
"Continued fraction convergents diverged to +/- infinity for value {0}",
new Object[] { new Double(x) });
double r = p2 / q2;
relativeError = Math.abs(r / c - 1.0);
c = p2 / q2;
p0 = p1;
p1 = p2;
q0 = q1;
q1 = q2;
if (n >= maxIterations) {
throw new MaxIterationsExceededException(maxIterations,
"Continued fraction convergents failed to converge for value {0}",
new Object[] { new Double(x) });
return c;
package org.apache.commons.math.util;
public class TransformerMap implements NumberTransformer, Serializable {
private static final long serialVersionUID = -942772950698439883L;
private NumberTransformer defaultTransformer = null;
private Map map = null;
public TransformerMap() {
map = new HashMap();
defaultTransformer = new DefaultTransformer();
public boolean containsClass(Class key) {
return map.containsKey(key);
public boolean containsTransformer(NumberTransformer value) {
return map.containsValue(value);
public NumberTransformer getTransformer(Class key) {
return (NumberTransformer) map.get(key);
public Object putTransformer(Class key, NumberTransformer transformer) {
return map.put(key, transformer);
public Object removeTransformer(Class key) {
return map.remove(key);
public void clear() {
map.clear();
public Set classes() {
return map.keySet();
public Collection transformers() {
return map.values();
public double transform(Object o) throws MathException {
double value = Double.NaN;
if (o instanceof Number || o instanceof String) {
value = defaultTransformer.transform(o);
NumberTransformer trans = getTransformer(o.getClass());
if (trans != null) {
value = trans.transform(o);
return value;
package org.apache.commons.math.util;
public class DefaultTransformer implements NumberTransformer, Serializable {
private static final long serialVersionUID = 4019938025047800455L;
public double transform(Object o) throws MathException{
if (o == null) {
throw new MathException("Conversion Exception in Transformation, Object is null", new Object[0]);
if (o instanceof Number) {
return ((Number)o).doubleValue();
return new Double(o.toString()).doubleValue();
throw new MathException("Conversion Exception in Transformation: {0}",
new Object[] { e.getMessage() }, e);
package org.apache.commons.math.complex;
public class ComplexFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
private static final String DEFAULT_IMAGINARY_CHARACTER = "i";
private String imaginaryCharacter;
private NumberFormat imaginaryFormat;
private NumberFormat realFormat;
public ComplexFormat() {
this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());
public ComplexFormat(NumberFormat format) {
this(DEFAULT_IMAGINARY_CHARACTER, format);
public ComplexFormat(NumberFormat realFormat,
NumberFormat imaginaryFormat) {
this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);
public ComplexFormat(String imaginaryCharacter) {
this(imaginaryCharacter, getDefaultNumberFormat());
public ComplexFormat(String imaginaryCharacter, NumberFormat format) {
this(imaginaryCharacter, format, (NumberFormat)format.clone());
public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,
NumberFormat imaginaryFormat) {
super();
setImaginaryCharacter(imaginaryCharacter);
setImaginaryFormat(imaginaryFormat);
setRealFormat(realFormat);
public static String formatComplex( Complex c ) {
return getInstance().format( c );
public StringBuffer format(Complex complex, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
double re = complex.getReal();
formatDouble(re, getRealFormat(), toAppendTo, pos);
double im = complex.getImaginary();
if (im < 0.0) {
toAppendTo.append(" - ");
formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);
toAppendTo.append(getImaginaryCharacter());
toAppendTo.append(" + ");
formatDouble(im, getImaginaryFormat(), toAppendTo, pos);
toAppendTo.append(getImaginaryCharacter());
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
StringBuffer ret = null;
if (obj instanceof Complex) {
ret = format( (Complex)obj, toAppendTo, pos);
ret = format( new Complex(((Number)obj).doubleValue(), 0.0),
toAppendTo, pos);
throw new IllegalArgumentException(
"Cannot format given Object as a Date");
return ret;
private StringBuffer formatDouble(double value, NumberFormat format,
StringBuffer toAppendTo, FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
format.format(value, toAppendTo, pos);
return toAppendTo;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
private static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
public String getImaginaryCharacter() {
return imaginaryCharacter;
public NumberFormat getImaginaryFormat() {
return imaginaryFormat;
public static ComplexFormat getInstance() {
return getInstance(Locale.getDefault());
public static ComplexFormat getInstance(Locale locale) {
NumberFormat f = getDefaultNumberFormat(locale);
return new ComplexFormat(f);
public NumberFormat getRealFormat() {
return realFormat;
public Complex parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
Complex result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable complex number: \"" + source +
"\"", parsePosition.getErrorIndex());
return result;
public Complex parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
Number re = parseNumber(source, getRealFormat(), pos);
if (re == null) {
pos.setIndex(initialIndex);
return null;
int startIndex = pos.getIndex();
char c = parseNextCharacter(source, pos);
int sign = 0;
switch (c) {
case 0 :
return new Complex(re.doubleValue(), 0.0);
case '-' :
sign = -1;
break;
case '+' :
sign = 1;
break;
default :
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
Number im = parseNumber(source, getRealFormat(), pos);
if (im == null) {
pos.setIndex(initialIndex);
return null;
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (source.substring(startIndex, endIndex).compareTo(
getImaginaryCharacter()) != 0) {
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
pos.setIndex(endIndex);
return new Complex(re.doubleValue(), im.doubleValue() * sign);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(String source, double value, ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
int n = sb.length();
int startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = new Double(value);
pos.setIndex(endIndex);
return ret;
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
int endIndex = pos.getIndex();
if (startIndex == endIndex) {
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
public void setImaginaryCharacter(String imaginaryCharacter) {
if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {
throw new IllegalArgumentException(
"imaginaryCharacter must be a non-empty string.");
this.imaginaryCharacter = imaginaryCharacter;
public void setImaginaryFormat(NumberFormat imaginaryFormat) {
if (imaginaryFormat == null) {
throw new IllegalArgumentException(
"imaginaryFormat can not be null.");
this.imaginaryFormat = imaginaryFormat;
public void setRealFormat(NumberFormat realFormat) {
if (realFormat == null) {
throw new IllegalArgumentException(
"realFormat can not be null.");
this.realFormat = realFormat;
package org.apache.commons.math.complex;
public class Complex implements Serializable  {
private static final long serialVersionUID = -6530173849413811929L;
public static final Complex I = new Complex(0.0, 1.0);
public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
public static final Complex ONE = new Complex(1.0, 0.0);
public static final Complex ZERO = new Complex(0.0, 0.0);
protected double imaginary;
protected double real;
public Complex(double real, double imaginary) {
super();
this.real = real;
this.imaginary = imaginary;
public double abs() {
if (isNaN()) {
return Double.NaN;
if (isInfinite()) {
return Double.POSITIVE_INFINITY;
if (Math.abs(real) < Math.abs(imaginary)) {
if (imaginary == 0.0) {
return Math.abs(real);
double q = real / imaginary;
return (Math.abs(imaginary) * Math.sqrt(1 + q*q));
if (real == 0.0) {
return Math.abs(imaginary);
double q = imaginary / real;
return (Math.abs(real) * Math.sqrt(1 + q*q));
public Complex add(Complex rhs) {   
return new Complex(real + rhs.getReal(),
imaginary + rhs.getImaginary());
public Complex conjugate() {
if (isNaN()) {
return NaN;
return new Complex(real, -imaginary);
public Complex divide(Complex rhs) {
if (isNaN() || rhs.isNaN()) {
return NaN;
double c = rhs.getReal();
double d = rhs.getImaginary();
if (c == 0.0 && d == 0.0) {
return NaN;
if (rhs.isInfinite() && !isInfinite()) {
return ZERO;
if (Math.abs(c) < Math.abs(d)) {
if (d == 0.0) {
return new Complex(real/c, imaginary/c);
double q = c / d;
double denominator = c * q + d;
return new Complex((real * q + imaginary) / denominator,
(imaginary * q - real) / denominator);
if (c == 0.0) {
return new Complex(imaginary/d, -real/c);
double q = d / c;
double denominator = d * q + c;
return new Complex((imaginary * q + real) / denominator,
(imaginary - real * q) / denominator);
public boolean equals(Object other) {
boolean ret;
if (this == other) { 
ret = true;
ret = false;
Complex rhs = (Complex)other;
if (rhs.isNaN()) {
ret = this.isNaN();
ret = (Double.doubleToRawLongBits(real) ==
Double.doubleToRawLongBits(rhs.getReal())) &&
(Double.doubleToRawLongBits(imaginary) ==
Double.doubleToRawLongBits(rhs.getImaginary())); 
ret = false;
return ret;
public int hashCode() {
if (isNaN()) {
return 7;
return 37 * (17 * MathUtils.hash(imaginary) + 
MathUtils.hash(real));
public double getImaginary() {
return imaginary;
public double getReal() {
return real;
public boolean isNaN() {
return Double.isNaN(real) || Double.isNaN(imaginary);        
public boolean isInfinite() {
return !isNaN() && 
(Double.isInfinite(real) || Double.isInfinite(imaginary));        
public Complex multiply(Complex rhs) {
if (isNaN() || rhs.isNaN()) {
return NaN;
return new Complex(real * rhs.real - imaginary * rhs.imaginary,
real * rhs.imaginary + imaginary * rhs.real);
public Complex negate() {
if (isNaN()) {
return NaN;
return new Complex(-real, -imaginary);
public Complex subtract(Complex rhs) {
if (isNaN() || rhs.isNaN()) {
return NaN;
return new Complex(real - rhs.getReal(),
imaginary - rhs.getImaginary());
package org.apache.commons.math.complex;
public class ComplexUtils {
private ComplexUtils() {
super();
public static Complex acos(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
return Complex.I.negate().multiply(log(z.add(
Complex.I.multiply(sqrt1z(z)))));       
public static Complex asin(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
return Complex.I.negate().multiply(log(sqrt1z(z).add(
Complex.I.multiply(z))));       
public static Complex atan(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
return Complex.I.multiply(
log(Complex.I.add(z).divide(Complex.I.subtract(z))))
.divide(new Complex(2.0, 0.0));
public static Complex cos(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a = z.getReal();
double b = z.getImaginary();
return new Complex(Math.cos(a) * MathUtils.cosh(b),
-Math.sin(a) * MathUtils.sinh(b));
public static Complex cosh(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a = z.getReal();
double b = z.getImaginary();
return new Complex(MathUtils.cosh(a) * Math.cos(b),
MathUtils.sinh(a) * Math.sin(b));
public static Complex exp(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double b = z.getImaginary();
double expA = Math.exp(z.getReal());
return new Complex(expA *  Math.cos(b), expA * Math.sin(b));
public static Complex log(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
return new Complex(Math.log(z.abs()),
Math.atan2(z.getImaginary(), z.getReal()));        
public static Complex polar2Complex(double r, double theta) {
if (r < 0) {
throw new IllegalArgumentException
("Complex modulus must not be negative");
return new Complex(r * Math.cos(theta), r * Math.sin(theta));
public static Complex pow(Complex y, Complex x) {
return exp(x.multiply(log(y)));
public static Complex sin(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a = z.getReal();
double b = z.getImaginary();
return new Complex(Math.sin(a) * MathUtils.cosh(b),
Math.cos(a) * MathUtils.sinh(b));
public static Complex sinh(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a = z.getReal();
double b = z.getImaginary();
return new Complex(MathUtils.sinh(a) * Math.cos(b),
MathUtils.cosh(a) * Math.sin(b));
public static Complex sqrt(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a = z.getReal();
double b = z.getImaginary();
if (a == 0.0 && b == 0.0) {
return new Complex(0.0, 0.0);
double t = Math.sqrt((Math.abs(a) + z.abs()) / 2.0);
if (a >= 0.0) {
return new Complex(t, b / (2.0 * t));
return new Complex(Math.abs(b) / (2.0 * t),
MathUtils.indicator(b) * t);
public static Complex sqrt1z(Complex z) {
return sqrt(Complex.ONE.subtract(z.multiply(z)));
public static Complex tan(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a2 = 2.0 * z.getReal();
double b2 = 2.0 * z.getImaginary();
double d = Math.cos(a2) + MathUtils.cosh(b2);
return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / d);
public static Complex tanh(Complex z) {
if (z.isNaN()) {
return Complex.NaN;
double a2 = 2.0 * z.getReal();
double b2 = 2.0 * z.getImaginary();
double d = MathUtils.cosh(a2) + Math.cos(b2);
return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / d);
package org.apache.commons.math;
public class MaxIterationsExceededException extends ConvergenceException {
private static final long serialVersionUID = -2154780004193976271L;
private int maxIterations;
public MaxIterationsExceededException(int maxIterations) {
super("Maximal number of iterations ({0}) exceeded",
new Object[] { new Integer(maxIterations) });
this.maxIterations = maxIterations;
public MaxIterationsExceededException(int maxIterations,
String pattern, Object[] arguments) {
super(pattern, arguments);
this.maxIterations = maxIterations;
public int getMaxIterations() {
return maxIterations;
package org.apache.commons.math.optimization;
public class MultiDirectional
extends DirectSearchOptimizer {
public MultiDirectional() {
super();
this.khi   = 2.0;
this.gamma = 0.5;
public MultiDirectional(double khi, double gamma) {
super();
this.khi   = khi;
this.gamma = gamma;
protected void iterateSimplex()
throws CostException {
while (true) {
PointCostPair[] original = simplex;
double originalCost = original[0].cost;
double reflectedCost = evaluateNewSimplex(original, 1.0);
if (reflectedCost < originalCost) {
PointCostPair[] reflected = simplex;
double expandedCost = evaluateNewSimplex(original, khi);
if (reflectedCost <= expandedCost) {
simplex = reflected;
return;
double contractedCost = evaluateNewSimplex(original, gamma);
if (contractedCost < originalCost) {
return;
private double evaluateNewSimplex(PointCostPair[] original, double coeff)
throws CostException {
double[] xSmallest = original[0].point;
int n = xSmallest.length;
simplex = new PointCostPair[n + 1];
simplex[0] = original[0];
for (int i = 1; i <= n; ++i) {
double[] xOriginal    = original[i].point;
double[] xTransformed = new double[n];
for (int j = 0; j < n; ++j) {
xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
simplex[i] = new PointCostPair(xTransformed, Double.NaN);
evaluateSimplex();
return simplex[0].cost;
private double khi;
private double gamma;
package org.apache.commons.math.optimization;
public abstract class DirectSearchOptimizer {
protected DirectSearchOptimizer() {
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[] vertexA, double[] vertexB)
throws CostException, ConvergenceException {
buildSimplex(vertexA, vertexB);
setSingleStart();
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[] vertexA, double[] vertexB,
int starts, long seed)
throws CostException, ConvergenceException {
buildSimplex(vertexA, vertexB);
double[] mean              = new double[vertexA.length];
double[] standardDeviation = new double[vertexA.length];
for (int i = 0; i < vertexA.length; ++i) {
mean[i]              = 0.5 * (vertexA[i] + vertexB[i]);
standardDeviation[i] = 0.5 * Math.abs(vertexA[i] - vertexB[i]);
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(seed);
UniformRandomGenerator urg = new UniformRandomGenerator(rg);
RandomVectorGenerator rvg =
new UncorrelatedRandomVectorGenerator(mean, standardDeviation, urg);
setMultiStart(starts, rvg);
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices)
throws CostException, ConvergenceException {
buildSimplex(vertices);
setSingleStart();
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices,
int starts, long seed)
throws NotPositiveDefiniteMatrixException,
CostException, ConvergenceException {
buildSimplex(vertices);
VectorialMean meanStat = new VectorialMean(vertices[0].length);
VectorialCovariance covStat = new VectorialCovariance(vertices[0].length);
for (int i = 0; i < vertices.length; ++i) {
meanStat.increment(vertices[i]);
covStat.increment(vertices[i]);
double[] mean = meanStat.getResult();
RealMatrix covariance = covStat.getResult();
RandomGenerator rg = new JDKRandomGenerator();
rg.setSeed(seed);
RandomVectorGenerator rvg =
new CorrelatedRandomVectorGenerator(mean,
covariance, 1.0e-12 * covariance.getNorm(),
new UniformRandomGenerator(rg));
setMultiStart(starts, rvg);
return minimizes(f, maxEvaluations, checker);
throw new RuntimeException("internal error");
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator)
throws CostException, ConvergenceException {
buildSimplex(generator);
setSingleStart();
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator,
int starts)
throws CostException, ConvergenceException {
buildSimplex(generator);
setMultiStart(starts, generator);
return minimizes(f, maxEvaluations, checker);
private void buildSimplex(double[] vertexA, double[] vertexB) {
int n = vertexA.length;
simplex = new PointCostPair[n + 1];
for (int i = 0; i <= n; ++i) {
double[] vertex = new double[n];
if (i > 0) {
System.arraycopy(vertexB, 0, vertex, 0, i);
if (i < n) {
System.arraycopy(vertexA, i, vertex, i, n - i);
simplex[i] = new PointCostPair(vertex, Double.NaN);
private void buildSimplex(double[][] vertices) {
int n = vertices.length - 1;
simplex = new PointCostPair[n + 1];
for (int i = 0; i <= n; ++i) {
simplex[i] = new PointCostPair(vertices[i], Double.NaN);
private void buildSimplex(RandomVectorGenerator generator) {
double[] vertex = generator.nextVector();
int n = vertex.length;
simplex = new PointCostPair[n + 1];
simplex[0] = new PointCostPair(vertex, Double.NaN);
for (int i = 1; i <= n; ++i) {
simplex[i] = new PointCostPair(generator.nextVector(), Double.NaN);
private void setSingleStart() {
starts    = 1;
generator = null;
minima    = null;
private void setMultiStart(int starts, RandomVectorGenerator generator) {
if (starts < 2) {
this.starts    = 1;
this.generator = null;
minima         = null;
this.starts    = starts;
this.generator = generator;
minima         = null;
public PointCostPair[] getMinima() {
return (PointCostPair[]) minima.clone();
private PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker)
throws CostException, ConvergenceException {
this.f = f;
minima = new PointCostPair[starts];
for (int i = 0; i < starts; ++i) {
evaluations = 0;
evaluateSimplex();
for (boolean loop = true; loop;) {
if (checker.converged(simplex)) {
minima[i] = simplex[0];
loop = false;
minima[i] = null;
loop = false;
iterateSimplex();
if (i < (starts - 1)) {
buildSimplex(generator);
Arrays.sort(minima, pointCostPairComparator);
if (minima[0] == null) {
throw new ConvergenceException("none of the {0} start points"
+ " lead to convergence",
new String[] {
Integer.toString(starts)
return minima[0];
protected abstract void iterateSimplex()
throws CostException;
protected double evaluateCost(double[] x)
throws CostException {
evaluations++;
return f.cost(x);
protected void evaluateSimplex()
throws CostException {
for (int i = 0; i < simplex.length; ++i) {
PointCostPair pair = simplex[i];
if (Double.isNaN(pair.cost)) {
simplex[i] = new PointCostPair(pair.point, evaluateCost(pair.point));
Arrays.sort(simplex, pointCostPairComparator);
protected void replaceWorstPoint(PointCostPair pointCostPair) {
int n = simplex.length - 1;
for (int i = 0; i < n; ++i) {
if (simplex[i].cost > pointCostPair.cost) {
PointCostPair tmp = simplex[i];
simplex[i]        = pointCostPair;
pointCostPair     = tmp;
simplex[n] = pointCostPair;
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
if (o1 == null) {
return (o2 == null) ? 0 : +1;
return -1;
double cost1 = ((PointCostPair) o1).cost;
double cost2 = ((PointCostPair) o2).cost;
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
protected PointCostPair[] simplex;
private CostFunction f;
private int evaluations;
private int starts;
private RandomVectorGenerator generator;
private PointCostPair[] minima;
package org.apache.commons.math.optimization;
public class NelderMead
extends DirectSearchOptimizer {
public NelderMead() {
super();
this.rho   = 1.0;
this.khi   = 2.0;
this.gamma = 0.5;
this.sigma = 0.5;
public NelderMead(double rho, double khi, double gamma, double sigma) {
super();
this.rho   = rho;
this.khi   = khi;
this.gamma = gamma;
this.sigma = sigma;
protected void iterateSimplex()
throws CostException {
int n = simplex.length - 1;
double   smallest      = simplex[0].cost;
double   secondLargest = simplex[n-1].cost;
double   largest       = simplex[n].cost;
double[] xLargest      = simplex[n].point;
double[] centroid = new double[n];
for (int i = 0; i < n; ++i) {
double[] x = simplex[i].point;
for (int j = 0; j < n; ++j) {
centroid[j] += x[j];
double scaling = 1.0 / n;
for (int j = 0; j < n; ++j) {
centroid[j] *= scaling;
double[] xR       = new double[n];
for (int j = 0; j < n; ++j) {
xR[j] = centroid[j] + rho * (centroid[j] - xLargest[j]);
double costR = evaluateCost(xR);
if ((smallest <= costR) && (costR < secondLargest)) {
replaceWorstPoint(new PointCostPair(xR, costR));
double[] xE = new double[n];
for (int j = 0; j < n; ++j) {
xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
double costE = evaluateCost(xE);
if (costE < costR) {
replaceWorstPoint(new PointCostPair(xE, costE));
replaceWorstPoint(new PointCostPair(xR, costR));
if (costR < largest) {
double[] xC = new double[n];
for (int j = 0; j < n; ++j) {
xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
double costC = evaluateCost(xC);
if (costC <= costR) {
replaceWorstPoint(new PointCostPair(xC, costC));
return;
double[] xC = new double[n];
for (int j = 0; j < n; ++j) {
xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);
double costC = evaluateCost(xC);
if (costC < largest) {
replaceWorstPoint(new PointCostPair(xC, costC));
return;
double[] xSmallest = simplex[0].point;
for (int i = 1; i < simplex.length; ++i) {
double[] x = simplex[i].point;
for (int j = 0; j < n; ++j) {
x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
simplex[i] = new PointCostPair(x, Double.NaN);
evaluateSimplex();
private double rho;
private double khi;
private double gamma;
private double sigma;
package org.apache.commons.math.optimization;
public interface CostFunction {
public double cost(double[] x) throws CostException;
package org.apache.commons.math.optimization;
public class CostException
extends MathException {
private static final long serialVersionUID = 467695563268795689L;
public CostException(String pattern, Object[] arguments) {
super(pattern, arguments);
public CostException(Throwable rootCause) {
super(rootCause);
package org.apache.commons.math.optimization;
public class PointCostPair {
public PointCostPair(double[] point, double cost) {
this.point = (double[]) point.clone();
this.cost = cost;
public final double[] point;
public final double cost;
package org.apache.commons.math.optimization;
public interface ConvergenceChecker {
public boolean converged (PointCostPair[] simplex);
package org.apache.commons.math.linear;
public class BigMatrixImpl implements BigMatrix, Serializable {
private static final long serialVersionUID = -1011428905656140431L;
private BigDecimal data[][] = null;
private BigDecimal lu[][] = null;
private int[] permutation = null;
private int parity = 1;
private int roundingMode = BigDecimal.ROUND_HALF_UP;
private int scale = 64;
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
public BigMatrixImpl() {
public BigMatrixImpl(int rowDimension, int columnDimension) {
if (rowDimension <=0 || columnDimension <=0) {
throw new IllegalArgumentException
("row and column dimensions must be positive");
data = new BigDecimal[rowDimension][columnDimension];
lu = null;
public BigMatrixImpl(BigDecimal[][] d) {
this.copyIn(d);
lu = null;
public BigMatrixImpl(double[][] d) {
int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one row."); 
int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one column."); 
for (int row = 1; row < nRows; row++) {
if (d[row].length != nCols) {
throw new IllegalArgumentException(
"All input rows must have the same length.");
this.copyIn(d);
lu = null;
public BigMatrixImpl(String[][] d) {
int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one row."); 
int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one column."); 
for (int row = 1; row < nRows; row++) {
if (d[row].length != nCols) {
throw new IllegalArgumentException(
"All input rows must have the same length.");
this.copyIn(d);
lu = null;
public BigMatrixImpl(BigDecimal[] v) {
int nRows = v.length;
data = new BigDecimal[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = v[row];
public BigMatrix copy() {
return new BigMatrixImpl(this.copyOut());
public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col].add(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix scalarAdd(BigDecimal d) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col].add(d);
return new BigMatrixImpl(outData);
public BigMatrix scalarMultiply(BigDecimal d) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col].multiply(d);
return new BigMatrixImpl(outData);
public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
BigDecimal sum = ZERO;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
sum = ZERO;
for (int i = 0; i < nSum; i++) {
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
outData[row][col] = sum;
return new BigMatrixImpl(outData);
public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {
return m.multiply(this);
public BigDecimal[][] getData() {
return copyOut();
public double[][] getDataAsDoubleArray() {
int nRows = getRowDimension();
int nCols = getColumnDimension();
double d[][] = new double[nRows][nCols];
for (int i = 0; i < nRows; i++) {
for (int j=0; j<nCols;j++) {
d[i][j] = data[i][j].doubleValue();
return d;
public BigDecimal[][] getDataRef() {
return data;
public int getRoundingMode() {
return roundingMode;
public void setRoundingMode(int roundingMode) {
this.roundingMode = roundingMode;
public int getScale() {
return scale;
public void setScale(int scale) {
this.scale = scale;
public BigDecimal getNorm() {
BigDecimal maxColSum = ZERO;
for (int col = 0; col < this.getColumnDimension(); col++) {
BigDecimal sum = ZERO;
for (int row = 0; row < this.getRowDimension(); row++) {
sum = sum.add(data[row][col].abs());
maxColSum = maxColSum.max(sum);
return maxColSum;
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
if (startRow < 0 || startRow > endRow || endRow > data.length ||
startColumn < 0 || startColumn > endColumn ||
endColumn > data[0].length ) {
throw new MatrixIndexException(
"invalid row or column index selection");
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int i = startRow; i <= endRow; i++) {
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
throws MatrixIndexException {
if (selectedRows.length * selectedColumns.length == 0) {
throw new MatrixIndexException(
"selected row and column index arrays must be non-empty");
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
selectedColumns.length);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int i = 0; i < selectedRows.length; i++) {
for (int j = 0; j < selectedColumns.length; j++) {
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
throw new MatrixIndexException("matrix dimension mismatch");
return subMatrix;
public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) 
throws MatrixIndexException {
if ((row < 0) || (column < 0)){
throw new MatrixIndexException
("invalid row or column index selection");          
int nRows = subMatrix.length;
if (nRows == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one row."); 
int nCols = subMatrix[0].length;
if (nCols == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (subMatrix[r].length != nCols) {
throw new IllegalArgumentException(
"All input rows must have the same length.");
if (data == null) {
if ((row > 0)||(column > 0)) throw new MatrixIndexException
("matrix must be initialized to perfom this method");
data = new BigDecimal[nRows][nCols];
System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          
if (((nRows + row) > this.getRowDimension()) ||
(nCols + column > this.getColumnDimension()))
throw new MatrixIndexException(
"invalid row or column index selection");                   
for (int i = 0; i < nRows; i++) {
System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
lu = null;
public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
if ( !isValidCoordinate( row, 0)) {
throw new MatrixIndexException("illegal row argument");
int ncols = this.getColumnDimension();
BigDecimal[][] out = new BigDecimal[1][ncols]; 
System.arraycopy(data[row], 0, out[0], 0, ncols);
return new BigMatrixImpl(out);
public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
if ( !isValidCoordinate( 0, column)) {
throw new MatrixIndexException("illegal column argument");
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][1]; 
for (int row = 0; row < nRows; row++) {
out[row][0] = data[row][column];
return new BigMatrixImpl(out);
public BigDecimal[] getRow(int row) throws MatrixIndexException {
if ( !isValidCoordinate( row, 0 ) ) {
throw new MatrixIndexException("illegal row argument");
int ncols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[ncols];
System.arraycopy(data[row], 0, out, 0, ncols);
return out;
public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
if ( !isValidCoordinate( row, 0 ) ) {
throw new MatrixIndexException("illegal row argument");
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
for (int i=0;i<ncols;i++) {
out[i] = data[row][i].doubleValue();
return out;
public BigDecimal[] getColumn(int col) throws MatrixIndexException {
if ( !isValidCoordinate(0, col) ) {
throw new MatrixIndexException("illegal column argument");
int nRows = this.getRowDimension();
BigDecimal[] out = new BigDecimal[nRows];
for (int i = 0; i < nRows; i++) {
out[i] = data[i][col];
return out;
public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
if ( !isValidCoordinate( 0, col ) ) {
throw new MatrixIndexException("illegal column argument");
int nrows = this.getRowDimension();
double[] out = new double[nrows];
for (int i=0;i<nrows;i++) {
out[i] = data[i][col].doubleValue();
return out;
public BigDecimal getEntry(int row, int column)
throws MatrixIndexException {
if (!isValidCoordinate(row,column)) {
throw new MatrixIndexException("matrix entry does not exist");
return data[row][column];
public double getEntryAsDouble(int row, int column) throws MatrixIndexException {
return getEntry(row,column).doubleValue();
public BigMatrix transpose() {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
BigDecimal[][] outData = out.getDataRef();
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
outData[col][row] = data[row][col];
return out;
public BigMatrix inverse() throws InvalidMatrixException {
return solve(MatrixUtils.createBigIdentityMatrix
(this.getRowDimension()));
public BigDecimal getDeterminant() throws InvalidMatrixException {
if (!isSquare()) {
throw new InvalidMatrixException("matrix is not square");
if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null
return ZERO;
BigDecimal det = (parity == 1) ? ONE : ONE.negate();
for (int i = 0; i < this.getRowDimension(); i++) {
det = det.multiply(lu[i][i]);
return det;
public boolean isSquare() {
return (this.getColumnDimension() == this.getRowDimension());
public boolean isSingular() {
if (lu == null) {
luDecompose();
return false;
return true;
return false; // so the matrix is not singular
public int getRowDimension() {
return data.length;
public int getColumnDimension() {
return data[0].length;
public BigDecimal getTrace() throws IllegalArgumentException {
if (!isSquare()) {
throw new IllegalArgumentException("matrix is not square");
BigDecimal trace = data[0][0];
for (int i = 1; i < this.getRowDimension(); i++) {
trace = trace.add(data[i][i]);
return trace;
public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
if (v.length != this.getColumnDimension()) {
throw new IllegalArgumentException("vector has wrong length");
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[v.length];
for (int row = 0; row < nRows; row++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nCols; i++) {
sum = sum.add(data[row][i].multiply(v[i]));
out[row] = sum;
return out;
public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
BigDecimal bd[] = new BigDecimal[v.length];
for (int i=0;i<bd.length;i++) {
bd[i] = new BigDecimal(v[i]);
return operate(bd);
public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
int nRows = this.getRowDimension();
if (v.length != nRows) {
throw new IllegalArgumentException("vector has wrong length");
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[nCols];
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nRows; i++) {
sum = sum.add(data[i][col].multiply(v[i]));
out[col] = sum;
return out;
public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
int nRows = this.getRowDimension();
if (b.length != nRows) {
throw new IllegalArgumentException("constant vector has wrong length");
BigMatrix bMatrix = new BigMatrixImpl(b);
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
BigDecimal[] out = new BigDecimal[nRows];
for (int row = 0; row < nRows; row++) {
out[row] = solution[row][0];
return out;
public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
BigDecimal bd[] = new BigDecimal[b.length];
for (int i=0;i<bd.length;i++) {
bd[i] = new BigDecimal(b[i]);
return solve(bd);
public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {
if (b.getRowDimension() != this.getRowDimension()) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!this.isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (this.isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
for (int row = 0; row < nRowB; row++) {
for (int col = 0; col < nColB; col++) {
bp[row][col] = b.getEntry(permutation[row], col);
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int j = 0; j < nColB; j++) {
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
for (int col = nCol - 1; col >= 0; col--) {
for (int j = 0; j < nColB; j++) {
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
for (int i = 0; i < col; i++) {
for (int j = 0; j < nColB; j++) {
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
BigMatrixImpl outMat = new BigMatrixImpl(bp);
return outMat;
public void luDecompose() throws InvalidMatrixException {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
if (nRows != nCols) {
throw new InvalidMatrixException("LU decomposition requires that the matrix be square.");
lu = this.getData();
permutation = new int[nRows];
for (int row = 0; row < nRows; row++) {
permutation[row] = row;
parity = 1;
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int row = 0; row < col; row++) {
sum = lu[row][col];
for (int i = 0; i < row; i++) {
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
int max = col; // permutation row
BigDecimal largest = ZERO;
for (int row = col; row < nRows; row++) {
sum = lu[row][col];
for (int i = 0; i < col; i++) {
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
if (sum.abs().compareTo(largest) == 1) {
largest = sum.abs();
max = row;
if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {
lu = null;
throw new InvalidMatrixException("matrix is singular");
if (max != col) {
BigDecimal tmp = ZERO;
for (int i = 0; i < nCols; i++) {
tmp = lu[max][i];
lu[max][i] = lu[col][i];
lu[col][i] = tmp;
int temp = permutation[max];
permutation[max] = permutation[col];
permutation[col] = temp;
parity = -parity;
for (int row = col + 1; row < nRows; row++) {
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
public String toString() {
StringBuffer res = new StringBuffer();
res.append("BigMatrixImpl{");
if (data != null) {
for (int i = 0; i < data.length; i++) {
if (i > 0)
res.append(",");
res.append("{");
for (int j = 0; j < data[0].length; j++) {
if (j > 0)
res.append(",");
res.append(data[i][j]);
res.append("}");
res.append("}");
return res.toString();
public boolean equals(Object object) {
if (object == this ) {
return true;
if (object instanceof BigMatrixImpl == false) {
return false;
BigMatrix m = (BigMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
return false;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
if (!data[row][col].equals(m.getEntry(row, col))) {
return false;
return true;
public int hashCode() {
int ret = 7;
int nRows = getRowDimension();
int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * 
data[row][col].hashCode();
return ret;
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
protected BigMatrix getLUMatrix() throws InvalidMatrixException {
if (lu == null) {
luDecompose();
return new BigMatrixImpl(lu);
protected int[] getPermutation() {
int[] out = new int[permutation.length];
System.arraycopy(permutation, 0, out, 0, permutation.length);
return out;
private BigDecimal[][] copyOut() {
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
for (int i = 0; i < nRows; i++) {
System.arraycopy(data[i], 0, out[i], 0, data[i].length);
return out;
private void copyIn(BigDecimal[][] in) {
setSubMatrix(in,0,0);
private void copyIn(double[][] in) {
int nRows = in.length;
int nCols = in[0].length;
data = new BigDecimal[nRows][nCols];
for (int i = 0; i < nRows; i++) {
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
lu = null;
private void copyIn(String[][] in) {
int nRows = in.length;
int nCols = in[0].length;
data = new BigDecimal[nRows][nCols];
for (int i = 0; i < nRows; i++) {
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
lu = null;
private boolean isValidCoordinate(int row, int col) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
return !(row < 0 || row >= nRows || col < 0 || col >= nCols);
package org.apache.commons.math.linear;
public class MatrixUtils {
public MatrixUtils() {
super();
public static RealMatrix createRealMatrix(double[][] data) {
return new RealMatrixImpl(data);
public static RealMatrix createRealIdentityMatrix(int dimension) {
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
double[][] d = out.getDataRef();
for (int row = 0; row < dimension; row++) {
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? 1d : 0d;
return out;
public static BigMatrix createBigMatrix(double[][] data) {
return new BigMatrixImpl(data);
public static BigMatrix createBigMatrix(BigDecimal[][] data) {
return new BigMatrixImpl(data);
public static BigMatrix createBigMatrix(String[][] data) {
return new BigMatrixImpl(data);
public static RealMatrix createRowRealMatrix(double[] rowData) {
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new RealMatrixImpl(data);
public static BigMatrix createRowBigMatrix(double[] rowData) {
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {
int nCols = rowData.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
public static BigMatrix createRowBigMatrix(String[] rowData) {
int nCols = rowData.length;
String[][] data = new String[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
public static RealMatrix createColumnRealMatrix(double[] columnData) {
int nRows = columnData.length;
double[][] data = new double[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = columnData[row];
return new RealMatrixImpl(data);
public static BigMatrix createColumnBigMatrix(double[] columnData) {
int nRows = columnData.length;
double[][] data = new double[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {
int nRows = columnData.length;
BigDecimal[][] data = new BigDecimal[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
public static BigMatrix createColumnBigMatrix(String[] columnData) {
int nRows = columnData.length;
String[][] data = new String[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
public static BigMatrix createBigIdentityMatrix(int dimension) {
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
BigDecimal[][] d = out.getDataRef();
for (int row = 0; row < dimension; row++) {
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return out;
package org.apache.commons.math.linear;
public interface BigMatrix {
BigMatrix copy();
BigMatrix add(BigMatrix m) throws IllegalArgumentException;
BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;
BigMatrix scalarAdd(BigDecimal d);
BigMatrix scalarMultiply(BigDecimal d);
BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;
public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;
BigDecimal[][] getData();
double [][] getDataAsDoubleArray();
int getRoundingMode();
BigDecimal getNorm();
BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException;
BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
throws MatrixIndexException;
BigMatrix getRowMatrix(int row) throws MatrixIndexException;
BigMatrix getColumnMatrix(int column) throws MatrixIndexException;
BigDecimal[] getRow(int row) throws MatrixIndexException;
double [] getRowAsDoubleArray(int row) throws MatrixIndexException;
BigDecimal[] getColumn(int col) throws MatrixIndexException;
double [] getColumnAsDoubleArray(int col) throws MatrixIndexException;
BigDecimal getEntry(int row, int column) throws MatrixIndexException;
double getEntryAsDouble(int row, int column) throws MatrixIndexException;
BigMatrix transpose();
BigMatrix inverse() throws InvalidMatrixException;
BigDecimal getDeterminant() throws InvalidMatrixException;
boolean isSquare();
boolean isSingular();
int getRowDimension();
int getColumnDimension();
BigDecimal getTrace();
BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException;
BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;
BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;
BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
package org.apache.commons.math.linear;
public class InvalidMatrixException extends RuntimeException {
private static final long serialVersionUID = 5318837237354354107L;
public InvalidMatrixException() {
this(null);
public InvalidMatrixException(String message) {
super(message);
package org.apache.commons.math.linear;
public class QRDecompositionImpl implements QRDecomposition {
private double[][] qr;
private double[] rDiag;
private int m;
private int n;
public QRDecompositionImpl(RealMatrix matrix) {
m = matrix.getRowDimension();
n = matrix.getColumnDimension();
qr = matrix.getData();
rDiag = new double[n];
for (int minor = 0; minor < Math.min(m, n); minor++) {
double xNormSqr = 0;
for (int row = minor; row < m; row++) {
xNormSqr += qr[row][minor]*qr[row][minor];
double a = Math.sqrt(xNormSqr);
if (qr[minor][minor] > 0) a = -a;
rDiag[minor] = a;
if (a != 0.0) {
qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])
for (int col = minor+1; col < n; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= qr[row][col]*qr[row][minor];
alpha /= a*qr[minor][minor];
for (int row = minor; row < m; row++) {
qr[row][col] -= alpha*qr[row][minor];
public RealMatrix getR()
RealMatrixImpl ret = new RealMatrixImpl(m,n);
double[][] r = ret.getDataRef();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
r[row][row] = rDiag[row];
for (int col = row+1; col < n; col++) {
r[row][col] = qr[row][col];
return ret;
public RealMatrix getQ()
RealMatrixImpl ret = new RealMatrixImpl(m,m);
double[][] Q = ret.getDataRef();
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
return ret;
package org.apache.commons.math.linear;
public class RealMatrixImpl implements RealMatrix, Serializable {
private static final long serialVersionUID = 4237564493130426188L;
private double data[][] = null;
private double lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static double TOO_SMALL = 10E-12;
public RealMatrixImpl() {
public RealMatrixImpl(int rowDimension, int columnDimension) {
if (rowDimension <= 0 || columnDimension <= 0) {
throw new IllegalArgumentException(
"row and column dimensions must be postive");
data = new double[rowDimension][columnDimension];
lu = null;
public RealMatrixImpl(double[][] d) {
this.copyIn(d);
lu = null;
public RealMatrixImpl(double[] v) {
int nRows = v.length;
data = new double[nRows][1];
for (int row = 0; row < nRows; row++) {
data[row][0] = v[row];
public RealMatrix copy() {
return new RealMatrixImpl(this.copyOut());
public RealMatrix add(RealMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col] + m.getEntry(row, col);
return new RealMatrixImpl(outData);
public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col] - m.getEntry(row, col);
return new RealMatrixImpl(outData);
public RealMatrix scalarAdd(double d) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col] + d;
return new RealMatrixImpl(outData);
public RealMatrix scalarMultiply(double d) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
for (int col = 0; col < columnCount; col++) {
outData[row][col] = data[row][col] * d;
return new RealMatrixImpl(outData);
public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
double[][] outData = new double[nRows][nCols];
double sum = 0;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
sum = 0;
for (int i = 0; i < nSum; i++) {
sum += data[row][i] * m.getEntry(i, col);
outData[row][col] = sum;
return new RealMatrixImpl(outData);
public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {
return m.multiply(this);
public double[][] getData() {
return copyOut();
public double[][] getDataRef() {
return data;
public double getNorm() {
double maxColSum = 0;
for (int col = 0; col < this.getColumnDimension(); col++) {
double sum = 0;
for (int row = 0; row < this.getRowDimension(); row++) {
sum += Math.abs(data[row][col]);
maxColSum = Math.max(maxColSum, sum);
return maxColSum;
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
if (startRow < 0 || startRow > endRow || endRow > data.length ||
startColumn < 0 || startColumn > endColumn ||
endColumn > data[0].length ) {
throw new MatrixIndexException(
"invalid row or column index selection");
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
double[][] subMatrixData = subMatrix.getDataRef();
for (int i = startRow; i <= endRow; i++) {
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
throws MatrixIndexException {
if (selectedRows.length * selectedColumns.length == 0) {
throw new MatrixIndexException(
"selected row and column index arrays must be non-empty");
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
selectedColumns.length);
double[][] subMatrixData = subMatrix.getDataRef();
for (int i = 0; i < selectedRows.length; i++) {
for (int j = 0; j < selectedColumns.length; j++) {
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
throw new MatrixIndexException("matrix dimension mismatch");
return subMatrix;
public void setSubMatrix(double[][] subMatrix, int row, int column) 
throws MatrixIndexException {
if ((row < 0) || (column < 0)){
throw new MatrixIndexException
("invalid row or column index selection");          
int nRows = subMatrix.length;
if (nRows == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one row."); 
int nCols = subMatrix[0].length;
if (nCols == 0) {
throw new IllegalArgumentException(
"Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (subMatrix[r].length != nCols) {
throw new IllegalArgumentException(
"All input rows must have the same length.");
if (data == null) {
if ((row > 0)||(column > 0)) throw new MatrixIndexException
("matrix must be initialized to perfom this method");
data = new double[nRows][nCols];
System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          
if (((nRows + row) > this.getRowDimension()) ||
(nCols + column > this.getColumnDimension()))
throw new MatrixIndexException(
"invalid row or column index selection");                   
for (int i = 0; i < nRows; i++) {
System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
lu = null;
public RealMatrix getRowMatrix(int row) throws MatrixIndexException {
if ( !isValidCoordinate( row, 0)) {
throw new MatrixIndexException("illegal row argument");
int ncols = this.getColumnDimension();
double[][] out = new double[1][ncols]; 
System.arraycopy(data[row], 0, out[0], 0, ncols);
return new RealMatrixImpl(out);
public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {
if ( !isValidCoordinate( 0, column)) {
throw new MatrixIndexException("illegal column argument");
int nRows = this.getRowDimension();
double[][] out = new double[nRows][1]; 
for (int row = 0; row < nRows; row++) {
out[row][0] = data[row][column];
return new RealMatrixImpl(out);
public double[] getRow(int row) throws MatrixIndexException {
if ( !isValidCoordinate( row, 0 ) ) {
throw new MatrixIndexException("illegal row argument");
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
System.arraycopy(data[row], 0, out, 0, ncols);
return out;
public double[] getColumn(int col) throws MatrixIndexException {
if ( !isValidCoordinate(0, col) ) {
throw new MatrixIndexException("illegal column argument");
int nRows = this.getRowDimension();
double[] out = new double[nRows];
for (int row = 0; row < nRows; row++) {
out[row] = data[row][col];
return out;
public double getEntry(int row, int column)
throws MatrixIndexException {
if (!isValidCoordinate(row,column)) {
throw new MatrixIndexException("matrix entry does not exist");
return data[row][column];
public RealMatrix transpose() {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
double[][] outData = out.getDataRef();
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
outData[col][row] = data[row][col];
return out;
public RealMatrix inverse() throws InvalidMatrixException {
return solve(MatrixUtils.createRealIdentityMatrix
(this.getRowDimension()));
public double getDeterminant() throws InvalidMatrixException {
if (!isSquare()) {
throw new InvalidMatrixException("matrix is not square");
if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null
return 0d;
double det = parity;
for (int i = 0; i < this.getRowDimension(); i++) {
det *= lu[i][i];
return det;
public boolean isSquare() {
return (this.getColumnDimension() == this.getRowDimension());
public boolean isSingular() {
if (lu == null) {
luDecompose();
return false;
return true;
return false; // so the matrix is not singular
public int getRowDimension() {
return data.length;
public int getColumnDimension() {
return data[0].length;
public double getTrace() throws IllegalArgumentException {
if (!isSquare()) {
throw new IllegalArgumentException("matrix is not square");
double trace = data[0][0];
for (int i = 1; i < this.getRowDimension(); i++) {
trace += data[i][i];
return trace;
public double[] operate(double[] v) throws IllegalArgumentException {
if (v.length != this.getColumnDimension()) {
throw new IllegalArgumentException("vector has wrong length");
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[v.length];
for (int row = 0; row < nRows; row++) {
double sum = 0;
for (int i = 0; i < nCols; i++) {
sum += data[row][i] * v[i];
out[row] = sum;
return out;
public double[] preMultiply(double[] v) throws IllegalArgumentException {
int nRows = this.getRowDimension();
if (v.length != nRows) {
throw new IllegalArgumentException("vector has wrong length");
int nCols = this.getColumnDimension();
double[] out = new double[nCols];
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nRows; i++) {
sum += data[i][col] * v[i];
out[col] = sum;
return out;
public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
int nRows = this.getRowDimension();
if (b.length != nRows) {
throw new IllegalArgumentException("constant vector has wrong length");
RealMatrix bMatrix = new RealMatrixImpl(b);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
double[] out = new double[nRows];
for (int row = 0; row < nRows; row++) {
out[row] = solution[row][0];
return out;
public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {
if (b.getRowDimension() != this.getRowDimension()) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!this.isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (this.isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
double[][] bp = new double[nRowB][nColB];
for (int row = 0; row < nRowB; row++) {
for (int col = 0; col < nColB; col++) {
bp[row][col] = b.getEntry(permutation[row], col);
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
for (int j = 0; j < nColB; j++) {
bp[i][j] -= bp[col][j] * lu[i][col];
for (int col = nCol - 1; col >= 0; col--) {
for (int j = 0; j < nColB; j++) {
bp[col][j] /= lu[col][col];
for (int i = 0; i < col; i++) {
for (int j = 0; j < nColB; j++) {
bp[i][j] -= bp[col][j] * lu[i][col];
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return outMat;
public void luDecompose() throws InvalidMatrixException {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
if (nRows != nCols) {
throw new InvalidMatrixException("LU decomposition requires that the matrix be square.");
lu = this.getData();
permutation = new int[nRows];
for (int row = 0; row < nRows; row++) {
permutation[row] = row;
parity = 1;
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int row = 0; row < col; row++) {
sum = lu[row][col];
for (int i = 0; i < row; i++) {
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
int max = col; // permutation row
double largest = 0d;
for (int row = col; row < nRows; row++) {
sum = lu[row][col];
for (int i = 0; i < col; i++) {
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
if (Math.abs(sum) > largest) {
largest = Math.abs(sum);
max = row;
if (Math.abs(lu[max][col]) < TOO_SMALL) {
lu = null;
throw new InvalidMatrixException("matrix is singular");
if (max != col) {
double tmp = 0;
for (int i = 0; i < nCols; i++) {
tmp = lu[max][i];
lu[max][i] = lu[col][i];
lu[col][i] = tmp;
int temp = permutation[max];
permutation[max] = permutation[col];
permutation[col] = temp;
parity = -parity;
for (int row = col + 1; row < nRows; row++) {
lu[row][col] /= lu[col][col];
public String toString() {
StringBuffer res = new StringBuffer();
res.append("RealMatrixImpl{");
if (data != null) {
for (int i = 0; i < data.length; i++) {
if (i > 0)
res.append(",");
res.append("{");
for (int j = 0; j < data[0].length; j++) {
if (j > 0)
res.append(",");
res.append(data[i][j]);
res.append("}");
res.append("}");
return res.toString();
public boolean equals(Object object) {
if (object == this ) {
return true;
if (object instanceof RealMatrixImpl == false) {
return false;
RealMatrix m = (RealMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
return false;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
if (Double.doubleToLongBits(data[row][col]) != 
Double.doubleToLongBits(m.getEntry(row, col))) {
return false;
return true;
public int hashCode() {
int ret = 7;
int nRows = getRowDimension();
int nCols = getColumnDimension();
ret = ret * 31 + nRows;
ret = ret * 31 + nCols;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * 
MathUtils.hash(data[row][col]);
return ret;
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
protected RealMatrix getLUMatrix() throws InvalidMatrixException {
if (lu == null) {
luDecompose();
return new RealMatrixImpl(lu);
protected int[] getPermutation() {
int[] out = new int[permutation.length];
System.arraycopy(permutation, 0, out, 0, permutation.length);
return out;
private double[][] copyOut() {
int nRows = this.getRowDimension();
double[][] out = new double[nRows][this.getColumnDimension()];
for (int i = 0; i < nRows; i++) {
System.arraycopy(data[i], 0, out[i], 0, data[i].length);
return out;
private void copyIn(double[][] in) {
setSubMatrix(in,0,0);
private boolean isValidCoordinate(int row, int col) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);
package org.apache.commons.math.linear;
public class MatrixIndexException extends RuntimeException {
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
public MatrixIndexException(String message) {
super(message);
package org.apache.commons.math.linear;
public interface QRDecomposition {
public abstract RealMatrix getR();
public abstract RealMatrix getQ();
package org.apache.commons.math.linear;
public interface RealMatrix {
RealMatrix copy();
RealMatrix add(RealMatrix m) throws IllegalArgumentException;
RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;
RealMatrix scalarAdd(double d);
RealMatrix scalarMultiply(double d);
RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;
public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;
double[][] getData();
double getNorm();
RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException;
RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
throws MatrixIndexException;
RealMatrix getRowMatrix(int row) throws MatrixIndexException;
RealMatrix getColumnMatrix(int column) throws MatrixIndexException;
double[] getRow(int row) throws MatrixIndexException;
double[] getColumn(int col) throws MatrixIndexException;
double getEntry(int row, int column) throws MatrixIndexException;
RealMatrix transpose();
RealMatrix inverse() throws InvalidMatrixException;
double getDeterminant();
boolean isSquare();
boolean isSingular();
int getRowDimension();
int getColumnDimension();
double getTrace();
double[] operate(double[] v) throws IllegalArgumentException;
double[] preMultiply(double[] v) throws IllegalArgumentException;
double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;
RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;
package org.apache.commons.math.distribution;
public interface CauchyDistribution extends ContinuousDistribution {
double getMedian();
double getScale();
void setMedian(double median);
void setScale(double s);
package org.apache.commons.math.distribution;
public interface HypergeometricDistribution extends IntegerDistribution {
public abstract int getNumberOfSuccesses();
public abstract int getPopulationSize();
public abstract int getSampleSize();
public abstract void setNumberOfSuccesses(int num);
public abstract void setPopulationSize(int size);
public abstract void setSampleSize(int size);
package org.apache.commons.math.distribution;
public interface TDistribution extends ContinuousDistribution {
void setDegreesOfFreedom(double degreesOfFreedom);
double getDegreesOfFreedom();
package org.apache.commons.math.distribution;
public interface ChiSquaredDistribution extends ContinuousDistribution {
void setDegreesOfFreedom(double degreesOfFreedom);
double getDegreesOfFreedom();
package org.apache.commons.math.distribution;
public interface NormalDistribution extends ContinuousDistribution {
double getMean();
void setMean(double mean);
double getStandardDeviation();
void setStandardDeviation(double sd);
package org.apache.commons.math.distribution;
public class TDistributionImpl
extends AbstractContinuousDistribution
implements TDistribution, Serializable  {
private static final long serialVersionUID = -5852615386664158222L;
private double degreesOfFreedom;
public TDistributionImpl(double degreesOfFreedom) {
super();
setDegreesOfFreedom(degreesOfFreedom);
public void setDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException("degrees of freedom must be positive.");
this.degreesOfFreedom = degreesOfFreedom;
public double getDegreesOfFreedom() {
return degreesOfFreedom;
public double cumulativeProbability(double x) throws MathException{
double ret;
if (x == 0.0) {
ret = 0.5;
double t =
Beta.regularizedBeta(
getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),
0.5 * getDegreesOfFreedom(),
0.5);
if (x < 0.0) {
ret = 0.5 * t;
ret = 1.0 - 0.5 * t;
return ret;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return Double.NEGATIVE_INFINITY;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return -Double.MAX_VALUE;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return 0.0;
package org.apache.commons.math.distribution;
public abstract class AbstractContinuousDistribution
extends AbstractDistribution
implements ContinuousDistribution, Serializable {
private static final long serialVersionUID = -38038050983108802L;
protected AbstractContinuousDistribution() {
super();
public double inverseCumulativeProbability(final double p)
throws MathException {
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException("p must be between 0.0 and 1.0, inclusive.");
UnivariateRealFunction rootFindingFunction =
new UnivariateRealFunction() {
public double value(double x) throws FunctionEvaluationException {
return cumulativeProbability(x) - p;
throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);
double lowerBound = getDomainLowerBound(p);
double upperBound = getDomainUpperBound(p);
double[] bracket = null;
bracket = UnivariateRealSolverUtils.bracket(
rootFindingFunction, getInitialDomain(p),
lowerBound, upperBound);
if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {
return lowerBound;
if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {
return upperBound;
throw new MathException(ex);
double root = UnivariateRealSolverUtils.solve(rootFindingFunction,
bracket[0],bracket[1]);
return root;
protected abstract double getInitialDomain(double p);
protected abstract double getDomainLowerBound(double p);
protected abstract double getDomainUpperBound(double p);
package org.apache.commons.math.distribution;
public interface BinomialDistribution extends IntegerDistribution {
int getNumberOfTrials();
double getProbabilityOfSuccess();
void setNumberOfTrials(int trials);
void setProbabilityOfSuccess(double p);
package org.apache.commons.math.distribution;
public class NormalDistributionImpl extends AbstractContinuousDistribution 
implements NormalDistribution, Serializable {
private static final long serialVersionUID = 8589540077390120676L;
private double mean = 0;
private double standardDeviation = 1;
public NormalDistributionImpl(double mean, double sd){
super();
setMean(mean);
setStandardDeviation(sd);
public NormalDistributionImpl(){
this(0.0, 1.0);
public double getMean() {
return mean;
public void setMean(double mean) {
this.mean = mean;
public double getStandardDeviation() {
return standardDeviation;
public void setStandardDeviation(double sd) {
if (sd <= 0.0) {
throw new IllegalArgumentException(
"Standard deviation must be positive.");
standardDeviation = sd;
public double cumulativeProbability(double x) throws MathException {
return 0.5 * (1.0 + Erf.erf((x - mean) /
(standardDeviation * Math.sqrt(2.0))));
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
return 0.0d;
return 1.0d;
throw ex;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return Double.NEGATIVE_INFINITY;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
double ret;
if (p < .5) {
ret = -Double.MAX_VALUE;
ret = getMean();
return ret;
protected double getDomainUpperBound(double p) {
double ret;
if (p < .5) {
ret = getMean();
ret = Double.MAX_VALUE;
return ret;
protected double getInitialDomain(double p) {
double ret;
if (p < .5) {
ret = getMean() - getStandardDeviation();
ret = getMean() + getStandardDeviation();
ret = getMean();
return ret;
package org.apache.commons.math.distribution;
public class GammaDistributionImpl extends AbstractContinuousDistribution
implements GammaDistribution, Serializable  {
private static final long serialVersionUID = -3239549463135430361L;
private double alpha;
private double beta;
public GammaDistributionImpl(double alpha, double beta) {
super();
setAlpha(alpha);
setBeta(beta);
public double cumulativeProbability(double x) throws MathException{
double ret;
if (x <= 0.0) {
ret = 0.0;
ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());
return ret;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
public void setAlpha(double alpha) {
if (alpha <= 0.0) {
throw new IllegalArgumentException("alpha must be positive");
this.alpha = alpha;
public double getAlpha() {
return alpha;
public void setBeta(double beta) {
if (beta <= 0.0) {
throw new IllegalArgumentException("beta must be positive");
this.beta = beta;
public double getBeta() {
return beta;
protected double getDomainLowerBound(double p) {
return Double.MIN_VALUE;
protected double getDomainUpperBound(double p) {
double ret;
if (p < .5) {
ret = getAlpha() * getBeta();
ret = Double.MAX_VALUE;
return ret;
protected double getInitialDomain(double p) {
double ret;
if (p < .5) {
ret = getAlpha() * getBeta() * .5;
ret = getAlpha() * getBeta();
return ret;
package org.apache.commons.math.distribution;
public class PoissonDistributionImpl extends AbstractIntegerDistribution
implements PoissonDistribution, Serializable {
private static final long serialVersionUID = -3349935121172596109L;
private NormalDistribution normal;
private double mean;
public PoissonDistributionImpl(double p) {
this(p, new NormalDistributionImpl());
public PoissonDistributionImpl(double p, NormalDistribution z) {
super();
setNormal(z);
setMean(p);
public double getMean() {
return this.mean;
public void setMean(double p) {
if (p <= 0) {
throw new IllegalArgumentException(
"The Poisson mean must be positive");
this.mean = p;
normal.setMean(p);
normal.setStandardDeviation(Math.sqrt(p));
public double probability(int x) {
if (x < 0 || x == Integer.MAX_VALUE) {
return 0;
return Math.pow(getMean(), x) / 
MathUtils.factorialDouble(x) * Math.exp(-mean);
public double cumulativeProbability(int x) throws MathException {
if (x < 0) {
return 0;
if (x == Integer.MAX_VALUE) {
return 1;
return Gamma.regularizedGammaQ((double)x + 1, mean, 
1E-12, Integer.MAX_VALUE);
public double normalApproximateProbability(int x) throws MathException {
return normal.cumulativeProbability(x + 0.5);
protected int getDomainLowerBound(double p) {
return 0;
protected int getDomainUpperBound(double p) {
return Integer.MAX_VALUE;
public void setNormal(NormalDistribution value) {
normal = value;
package org.apache.commons.math.distribution;
public class CauchyDistributionImpl extends AbstractContinuousDistribution 
implements CauchyDistribution, Serializable {
private static final long serialVersionUID = 8589540077390120676L;
private double median = 0;
private double scale = 1;
public CauchyDistributionImpl(){
this(0.0, 1.0);
public CauchyDistributionImpl(double median, double s){
super();
setMedian(median);
setScale(s);
public double cumulativeProbability(double x) {
return 0.5 + (Math.atan((x - median) / scale) / Math.PI);
public double getMedian() {
return median;
public double getScale() {
return scale;
public double inverseCumulativeProbability(double p) {
double ret;
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException
("probability argument must be between 0 and 1 (inclusive)");
ret = Double.NEGATIVE_INFINITY;
ret = Double.POSITIVE_INFINITY;
ret = median + scale * Math.tan(Math.PI * (p - .5));
return ret;
public void setMedian(double median) {
this.median = median;
public void setScale(double s) {
if (s <= 0.0) {
throw new IllegalArgumentException(
"Scale must be positive.");
scale = s;
protected double getDomainLowerBound(double p) {
double ret;
if (p < .5) {
ret = -Double.MAX_VALUE;
ret = getMedian();
return ret;
protected double getDomainUpperBound(double p) {
double ret;
if (p < .5) {
ret = getMedian();
ret = Double.MAX_VALUE;
return ret;
protected double getInitialDomain(double p) {
double ret;
if (p < .5) {
ret = getMedian() - getScale();
ret = getMedian() + getScale();
ret = getMedian();
return ret;
package org.apache.commons.math.distribution;
public class PascalDistributionImpl extends AbstractIntegerDistribution
implements PascalDistribution, Serializable {
private static final long serialVersionUID = 6751309484392813623L;
private int numberOfSuccesses;
private double probabilityOfSuccess;
public PascalDistributionImpl(int r, double p) {
super();
setNumberOfSuccesses(r);
setProbabilityOfSuccess(p);
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public void setNumberOfSuccesses(int successes) {
if (successes < 0) {
throw new IllegalArgumentException(
"number of successes must be non-negative.");
numberOfSuccesses = successes;
public void setProbabilityOfSuccess(double p) {
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException(
"probability of success must be between 0.0 and 1.0, inclusive.");
probabilityOfSuccess = p;
protected int getDomainLowerBound(double p) {
return -1;
protected int getDomainUpperBound(double p) {
return Integer.MAX_VALUE - 1;
public double cumulativeProbability(int x) throws MathException {
double ret;
if (x < 0) {
ret = 0.0;
ret = Beta.regularizedBeta(getProbabilityOfSuccess(),
getNumberOfSuccesses(), x + 1);
return ret;
public double probability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
ret = MathUtils.binomialCoefficientDouble(x
+ getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1)
return ret;
public int inverseCumulativeProbability(final double p)
throws MathException {
int ret;
if (p == 0) {
ret = -1;
ret = Integer.MAX_VALUE;
ret = super.inverseCumulativeProbability(p);
return ret;
package org.apache.commons.math.distribution;
public interface IntegerDistribution extends DiscreteDistribution {
double probability(int x);
double cumulativeProbability(int x) throws MathException;
double cumulativeProbability(int x0, int x1) throws MathException;
int inverseCumulativeProbability(double p) throws MathException;
package org.apache.commons.math.distribution;
public interface WeibullDistribution extends ContinuousDistribution {
double getShape();
double getScale();
void setShape(double alpha);
void setScale(double beta);
package org.apache.commons.math.distribution;
public class WeibullDistributionImpl extends AbstractContinuousDistribution
implements WeibullDistribution, Serializable {
private static final long serialVersionUID = 8589540077390120676L;
private double alpha;
private double beta;
public WeibullDistributionImpl(double alpha, double beta){
super();
setShape(alpha);
setScale(beta);
public double cumulativeProbability(double x) {
double ret;
if (x <= 0.0) {
ret = 0.0;
ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));
return ret;
public double getShape() {
return alpha;
public double getScale() {
return beta;
public double inverseCumulativeProbability(double p) {
double ret;
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException
("probability argument must be between 0 and 1 (inclusive)");
ret = 0.0;
ret = Double.POSITIVE_INFINITY;
ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());
return ret;
public void setShape(double alpha) {
if (alpha <= 0.0) {
throw new IllegalArgumentException(
"Shape must be positive.");
this.alpha = alpha;
public void setScale(double beta) {
if (beta <= 0.0) {
throw new IllegalArgumentException(
"Scale must be positive.");
this.beta = beta;
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());
package org.apache.commons.math.distribution;
public interface ExponentialDistribution extends ContinuousDistribution {
void setMean(double mean);
double getMean();
package org.apache.commons.math.distribution;
public interface ContinuousDistribution extends Distribution {
double inverseCumulativeProbability(double p) throws MathException;
package org.apache.commons.math.distribution;
public interface PascalDistribution extends IntegerDistribution {
int getNumberOfSuccesses();
double getProbabilityOfSuccess();
void setNumberOfSuccesses(int successes);
void setProbabilityOfSuccess(double p);
package org.apache.commons.math.distribution;
public interface DiscreteDistribution extends Distribution {
double probability(double x);
package org.apache.commons.math.distribution;
public abstract class AbstractDistribution
implements Distribution, Serializable {
private static final long serialVersionUID = -38038050983108802L;
protected AbstractDistribution() {
super();
public double cumulativeProbability(double x0, double x1)
throws MathException {
if (x0 > x1) {
throw new IllegalArgumentException
("lower endpoint must be less than or equal to upper endpoint");
return cumulativeProbability(x1) - cumulativeProbability(x0);
package org.apache.commons.math.distribution;
public interface FDistribution extends ContinuousDistribution {
void setNumeratorDegreesOfFreedom(double degreesOfFreedom);
double getNumeratorDegreesOfFreedom();
void setDenominatorDegreesOfFreedom(double degreesOfFreedom);
double getDenominatorDegreesOfFreedom();
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
package org.apache.commons.math.distribution;
public class ChiSquaredDistributionImpl
extends AbstractContinuousDistribution
implements ChiSquaredDistribution, Serializable  {
private static final long serialVersionUID = -8352658048349159782L;
private GammaDistribution gamma;
public ChiSquaredDistributionImpl(double df) {
this(df, new GammaDistributionImpl(df / 2.0, 2.0));
public ChiSquaredDistributionImpl(double df, GammaDistribution g) {
super();
setGamma(g);
setDegreesOfFreedom(df);
public void setDegreesOfFreedom(double degreesOfFreedom) {
getGamma().setAlpha(degreesOfFreedom / 2.0);
public double getDegreesOfFreedom() {
return getGamma().getAlpha() * 2.0;
public double cumulativeProbability(double x) throws MathException {
return getGamma().cumulativeProbability(x);
public double inverseCumulativeProbability(final double p)
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return Double.MIN_VALUE * getGamma().getBeta();
protected double getDomainUpperBound(double p) {
double ret;
if (p < .5) {
ret = getDegreesOfFreedom();
ret = Double.MAX_VALUE;
return ret;
protected double getInitialDomain(double p) {
double ret;
if (p < .5) {
ret = getDegreesOfFreedom() * .5;
ret = getDegreesOfFreedom();
return ret;
public void setGamma(GammaDistribution g) {
this.gamma = g;
private GammaDistribution getGamma() {
return gamma;
package org.apache.commons.math.distribution;
public class ExponentialDistributionImpl extends AbstractContinuousDistribution
implements ExponentialDistribution, Serializable {
private static final long serialVersionUID = 2401296428283614780L;
private double mean;
public ExponentialDistributionImpl(double mean) {
super();
setMean(mean);
public void setMean(double mean) {
if (mean <= 0.0) {
throw new IllegalArgumentException("mean must be positive.");
this.mean = mean;
public double getMean() {
return mean;
public double cumulativeProbability(double x) throws MathException{
double ret;
if (x <= 0.0) {
ret = 0.0;
ret = 1.0 - Math.exp(-x / getMean());
return ret;
public double inverseCumulativeProbability(double p) throws MathException {
double ret;
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException
("probability argument must be between 0 and 1 (inclusive)");
ret = Double.POSITIVE_INFINITY;
ret = -getMean() * Math.log(1.0 - p);
return ret;
protected double getDomainLowerBound(double p) {
return 0;
protected double getDomainUpperBound(double p) {
if (p < .5) {
return getMean();
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
if (p < .5) {
return getMean() * .5;
return getMean();
package org.apache.commons.math.distribution;
public class BinomialDistributionImpl
extends AbstractIntegerDistribution
implements BinomialDistribution, Serializable {
private static final long serialVersionUID = 6751309484392813623L;
private int numberOfTrials;
private double probabilityOfSuccess;
public BinomialDistributionImpl(int trials, double p) {
super();
setNumberOfTrials(trials);
setProbabilityOfSuccess(p);
public int getNumberOfTrials() {
return numberOfTrials;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public void setNumberOfTrials(int trials) {
if (trials < 0) {
throw new IllegalArgumentException("number of trials must be non-negative.");
numberOfTrials = trials;
public void setProbabilityOfSuccess(double p) {
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException("probability of success must be between 0.0 and 1.0, inclusive.");
probabilityOfSuccess = p;
protected int getDomainLowerBound(double p) {
return -1;
protected int getDomainUpperBound(double p) {
return getNumberOfTrials();
public double cumulativeProbability(int x) throws MathException {
double ret;
if (x < 0) {
ret = 0.0;
ret = 1.0;
ret =
1.0 - Beta.regularizedBeta(
getProbabilityOfSuccess(),
x + 1.0,
getNumberOfTrials() - x);
return ret;
public double probability(int x) {
double ret;
if (x < 0 || x > getNumberOfTrials()) {
ret = 0.0;
ret = MathUtils.binomialCoefficientDouble(
getNumberOfTrials(), x) *
Math.pow(getProbabilityOfSuccess(), x) *
Math.pow(1.0 - getProbabilityOfSuccess(),
getNumberOfTrials() - x);
return ret;
public int inverseCumulativeProbability(final double p) throws MathException {
if (p == 0) {
return -1;
if (p == 1) {
return Integer.MAX_VALUE; 
return super.inverseCumulativeProbability(p);
package org.apache.commons.math.distribution;
public abstract class AbstractIntegerDistribution extends AbstractDistribution
implements IntegerDistribution, Serializable {
private static final long serialVersionUID = -1146319659338487221L;
protected AbstractIntegerDistribution() {
super();
public double cumulativeProbability(double x) throws MathException {
return cumulativeProbability((int) Math.floor(x));  
abstract public double cumulativeProbability(int x) throws MathException;
public double probability(double x) {
double fl = Math.floor(x);
if (fl == x) {
return this.probability((int) x);
return 0;
public double cumulativeProbability(int x0, int x1) throws MathException {
if (x0 > x1) {
throw new IllegalArgumentException
("lower endpoint must be less than or equal to upper endpoint");
return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);
public int inverseCumulativeProbability(final double p) throws MathException{
if (p < 0.0 || p > 1.0) {
throw new IllegalArgumentException(
"p must be between 0 and 1.0 (inclusive)");
int x0 = getDomainLowerBound(p);
int x1 = getDomainUpperBound(p);
double pm;
while (x0 < x1) {
int xm = x0 + (x1 - x0) / 2;
pm = cumulativeProbability(xm);
if (pm > p) {
if (xm == x1) {
--x1;
x1 = xm;
if (xm == x0) {
++x0;
x0 = xm;
pm = cumulativeProbability(x0);
while (pm > p) {
--x0;
pm = cumulativeProbability(x0);
return x0;        
protected abstract int getDomainLowerBound(double p);
protected abstract int getDomainUpperBound(double p);
package org.apache.commons.math.distribution;
public interface PoissonDistribution extends IntegerDistribution {
public double getMean();
public void setMean(double p);
public double normalApproximateProbability(int x) throws MathException;
package org.apache.commons.math.distribution;
public class FDistributionImpl
extends AbstractContinuousDistribution
implements FDistribution, Serializable  {
private static final long serialVersionUID = -8516354193418641566L;
private double numeratorDegreesOfFreedom;
private double denominatorDegreesOfFreedom;
public FDistributionImpl(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
super();
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();
ret = Beta.regularizedBeta((n * x) / (m + n * x),
0.5 * n,
0.5 * m);
return ret;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return getDenominatorDegreesOfFreedom() /
(getDenominatorDegreesOfFreedom() - 2.0);
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.denominatorDegreesOfFreedom = degreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
package org.apache.commons.math.distribution;
public interface GammaDistribution extends ContinuousDistribution {
void setAlpha(double alpha);
double getAlpha();
void setBeta(double beta);
double getBeta();
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public interface Distribution {
double cumulativeProbability(double x) throws MathException;
double cumulativeProbability(double x0, double x1) throws MathException;
package org.apache.commons.math.distribution;
public class HypergeometricDistributionImpl extends AbstractIntegerDistribution
implements HypergeometricDistribution, Serializable 
private static final long serialVersionUID = -436928820673516179L;
private int numberOfSuccesses;
private int populationSize;
private int sampleSize;
public HypergeometricDistributionImpl(int populationSize,
int numberOfSuccesses, int sampleSize) {
super();
if (numberOfSuccesses > populationSize) {
throw new IllegalArgumentException(
"number of successes must be less than or equal to " +
"population size");
if (sampleSize > populationSize) {
throw new IllegalArgumentException(
"sample size must be less than or equal to population size");
setPopulationSize(populationSize);
setSampleSize(sampleSize);
setNumberOfSuccesses(numberOfSuccesses);
public double cumulativeProbability(int x) {
double ret;
int n = getPopulationSize();
int m = getNumberOfSuccesses();
int k = getSampleSize();
int[] domain = getDomain(n, m, k);
if (x < domain[0]) {
ret = 0.0;
ret = 1.0;
ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);
return ret;
private int[] getDomain(int n, int m, int k){
return new int[]{
getLowerDomain(n, m, k),
getUpperDomain(m, k)
protected int getDomainLowerBound(double p) {
return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),
getSampleSize());
protected int getDomainUpperBound(double p) {
return getUpperDomain(getSampleSize(), getNumberOfSuccesses());
private int getLowerDomain(int n, int m, int k) {
return Math.max(0, m - (n - k));
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public int getPopulationSize() {
return populationSize;
public int getSampleSize() {
return sampleSize;
private int getUpperDomain(int m, int k){
return Math.min(k, m);
public double probability(int x) {
double ret;
int n = getPopulationSize();
int m = getNumberOfSuccesses();
int k = getSampleSize();
int[] domain = getDomain(n, m, k);
if(x < domain[0] || x > domain[1]){
ret = 0.0;
ret = probability(n, m, k, x);
return ret;
private double probability(int n, int m, int k, int x) {
return Math.exp(MathUtils.binomialCoefficientLog(m, x) +
MathUtils.binomialCoefficientLog(n - m, k - x) -
MathUtils.binomialCoefficientLog(n, k));
public void setNumberOfSuccesses(int num) {
if(num < 0){
throw new IllegalArgumentException(
"number of successes must be non-negative.");
numberOfSuccesses = num;
public void setPopulationSize(int size) {
if(size <= 0){
throw new IllegalArgumentException(
"population size must be positive.");
populationSize = size;
public void setSampleSize(int size) {
if (size < 0) {
throw new IllegalArgumentException(
"sample size must be non-negative.");
sampleSize = size;
public double upperCumulativeProbability(int x) {
double ret;
int n = getPopulationSize();
int m = getNumberOfSuccesses();
int k = getSampleSize();
int[] domain = getDomain(n, m, k);
if (x < domain[0]) {
ret = 1.0;
ret = 0.0;
ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);
return ret;
private double innerCumulativeProbability(
int x0, int x1, int dx, int n, int m, int k)
double ret = probability(n, m, k, x0);
while (x0 != x1) {
x0 += dx;
ret += probability(n, m, k, x0);
return ret;
package org.apache.commons.math;
public class ArgumentOutsideDomainException extends FunctionEvaluationException {
private static final long serialVersionUID = -4965972841162580234L;
public ArgumentOutsideDomainException(double argument, double lower, double upper) {
super(argument,
"Argument {0} outside domain [{1} ; {2}]",
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
package org.apache.commons.math.special;
public class Erf implements Serializable {
private static final long serialVersionUID = 490960015010326571L;
private Erf() {
super();
public static double erf(double x) throws MathException {
double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);
if (x < 0) {
ret = -ret;
return ret;
package org.apache.commons.math.special;
public class Gamma implements Serializable {
private static final long serialVersionUID = -6587513359895466954L;
private static final double DEFAULT_EPSILON = 10e-15;
private static double[] lanczos =
0.99999999999999709182,
57.156235665862923517,
-59.597960355475491248,
14.136097974741747174,
-0.49191381609762019978,
.33994649984811888699e-4,
.46523628927048575665e-4,
-.98374475304879564677e-4,
.15808870322491248884e-3,
-.21026444172410488319e-3,
.21743961811521264320e-3,
-.16431810653676389022e-3,
.84418223983852743293e-4,
-.26190838401581408670e-4,
.36899182659531622704e-5,
private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);
private Gamma() {
super();
public static double logGamma(double x) {
double ret;
if (Double.isNaN(x) || (x <= 0.0)) {
ret = Double.NaN;
double g = 607.0 / 128.0;
double sum = 0.0;
for (int i = lanczos.length - 1; i > 0; --i) {
sum = sum + (lanczos[i] / (x + i));
sum = sum + lanczos[0];
double tmp = x + g + .5;
ret = ((x + .5) * Math.log(tmp)) - tmp +
HALF_LOG_2_PI + Math.log(sum / x);
return ret;
public static double regularizedGammaP(double a, double x)
throws MathException
return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
public static double regularizedGammaP(double a, 
double x, 
double epsilon, 
int maxIterations) 
throws MathException
double ret;
if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
ret = Double.NaN;
ret = 0.0;
ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
double n = 0.0; // current element index
double an = 1.0 / a; // n-th element in the series
double sum = an; // partial sum
while (Math.abs(an) > epsilon && n < maxIterations) {
n = n + 1.0;
an = an * (x / (a + n));
sum = sum + an;
if (n >= maxIterations) {
throw new MaxIterationsExceededException(maxIterations);
ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
return ret;
public static double regularizedGammaQ(double a, double x)
throws MathException
return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
public static double regularizedGammaQ(final double a, 
double x, 
double epsilon, 
int maxIterations) 
throws MathException
double ret;
if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
ret = Double.NaN;
ret = 1.0;
ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
ContinuedFraction cf = new ContinuedFraction() {
private static final long serialVersionUID = 5378525034886164398L;
protected double getA(int n, double x) {
return ((2.0 * n) + 1.0) - a + x;
protected double getB(int n, double x) {
return n * (a - n);
ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
return ret;
package org.apache.commons.math.special;
public class Beta implements Serializable {
private static final long serialVersionUID = -3833485397404128220L;
private static final double DEFAULT_EPSILON = 10e-15;
private Beta() {
super();
public static double regularizedBeta(double x, double a, double b)
throws MathException
return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);
public static double regularizedBeta(double x, double a, double b,
double epsilon) throws MathException
return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);
public static double regularizedBeta(double x, double a, double b,
int maxIterations) throws MathException
return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);
public static double regularizedBeta(double x, final double a,
final double b, double epsilon, int maxIterations) throws MathException
double ret;
if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||
(x > 1) || (a <= 0.0) || (b <= 0.0))
ret = Double.NaN;
ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
ContinuedFraction fraction = new ContinuedFraction() {
private static final long serialVersionUID = -7658917278956100597L;
protected double getB(int n, double x) {
double ret;
double m;
if (n % 2 == 0) { // even
m = n / 2.0;
ret = (m * (b - m) * x) /
((a + (2 * m) - 1) * (a + (2 * m)));
m = (n - 1.0) / 2.0;
ret = -((a + m) * (a + b + m) * x) /
((a + (2 * m)) * (a + (2 * m) + 1.0));
return ret;
protected double getA(int n, double x) {
return 1.0;
ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -
Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *
1.0 / fraction.evaluate(x, epsilon, maxIterations);
return ret;
public static double logBeta(double a, double b) {
return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);
public static double logBeta(double a, double b, double epsilon,
int maxIterations) {
double ret;
if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {
ret = Double.NaN;
ret = Gamma.logGamma(a) + Gamma.logGamma(b) -
Gamma.logGamma(a + b);
return ret;
package org.apache.commons.math.ode;
class SwitchState implements Serializable {
private static final long serialVersionUID = 3256541562455482289L;
private SwitchingFunction function;
private double maxCheckInterval;
private double convergence;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
public SwitchState(SwitchingFunction function,
double maxCheckInterval, double convergence) {
this.function         = function;
this.maxCheckInterval = maxCheckInterval;
this.convergence      = Math.abs(convergence);
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = SwitchingFunction.CONTINUE;
public void reinitializeBegin(double t0, double[] y0) {
this.t0 = t0;
g0 = function.g(t0, y0);
g0Positive = (g0 >= 0);
public boolean evaluateStep(final StepInterpolator interpolator) {
double t1 = interpolator.getCurrentTime();
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
double gb = function.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return function.g(t, interpolator.getInterpolatedState());
throw new FunctionEvaluationException(t, e);
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(1000);
double root = solver.solve(ta, tb);
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
throw new RuntimeException("internal error");
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
throw new RuntimeException("unexpected exception: " + e.getMessage());
throw new RuntimeException("unexpected exception: " + e.getMessage());
public double getEventTime() {
return pendingEventTime;
public void stepAccepted(double t, double[] y) {
t0 = t;
g0 = function.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = function.eventOccurred(t, y);
g0Positive = (g0 >= 0);
nextAction = SwitchingFunction.CONTINUE;
public boolean stop() {
return nextAction == SwitchingFunction.STOP;
public boolean reset(double t, double[] y) {
if (! pendingEvent) {
return false;
if (nextAction == SwitchingFunction.RESET_STATE) {
function.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
return (nextAction == SwitchingFunction.RESET_STATE)
|| (nextAction == SwitchingFunction.RESET_DERIVATIVES);
package org.apache.commons.math.ode;
public class GillIntegrator
extends RungeKuttaIntegrator {
private static final String methodName = "Gill";
private static final double sqrt2 = Math.sqrt(2.0);
private static final double[] c = {
1.0 / 2.0, 1.0 / 2.0, 1.0
private static final double[][] a = {
private static final double[] b = {
1.0 / 6.0, (2.0 - sqrt2) / 6.0, (2.0 + sqrt2) / 6.0, 1.0 / 6.0
public GillIntegrator(double step) {
super(false, c, a, b, new GillStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public class StepNormalizer
implements StepHandler {
public StepNormalizer(double h, FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime  = Double.NaN;
lastState = null;
forward   = true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
double nextTime;
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, true);
private double h;
private FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private boolean forward;
package org.apache.commons.math.ode;
class EulerStepInterpolator
extends RungeKuttaStepInterpolator {
public EulerStepInterpolator() {
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new EulerStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];
private static final long serialVersionUID = -7179861704951334960L;
package org.apache.commons.math.ode;
public class HighamHall54Integrator
extends RungeKuttaFehlbergIntegrator {
private static final String methodName = "Higham-Hall 5(4)";
private static final double[] c = {
2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0
private static final double[][] a = {
private static final double[] b = {
1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0
private static final double[] e = {
-1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0
public HighamHall54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(false, c, a, b, new HighamHall54StepInterpolator(),
minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
public HighamHall54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(false, c, a, b, new HighamHall54StepInterpolator(),
minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public String getName() {
return methodName;
public int getOrder() {
return 5;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double error = 0;
for (int j = 0; j < y0.length; ++j) {
double errSum = e[0] * yDotK[0][j];
for (int l = 1; l < e.length; ++l) {
errSum += e[l] * yDotK[l][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null)
? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)
: (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
error += ratio * ratio;
return Math.sqrt(error / y0.length);
package org.apache.commons.math.ode;
class MidpointStepInterpolator
extends RungeKuttaStepInterpolator {
public MidpointStepInterpolator() {
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new MidpointStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double coeff1 = oneMinusThetaH * theta;
double coeff2 = oneMinusThetaH * (1.0 + theta);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
+ coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];
private static final long serialVersionUID = -865524111506042509L;
package org.apache.commons.math.ode;
class GillStepInterpolator
extends RungeKuttaStepInterpolator {
public GillStepInterpolator() {
public GillStepInterpolator(GillStepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new GillStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double soMt      = s * (1 - theta);
double c23       = soMt * (1 + 2 * theta);
double coeff1    = soMt * (1 - fourTheta);
double coeff2    = c23  * tMq;
double coeff3    = c23  * tPq;
double coeff4    = s * (1 + theta * (1 + fourTheta));
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
- coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]
- coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
private static final double tMq = 2 - Math.sqrt(2.0);
private static final double tPq = 2 + Math.sqrt(2.0);
private static final long serialVersionUID = -107804074496313322L;
package org.apache.commons.math.ode;
public class FirstOrderConverter
implements FirstOrderDifferentialEquations {
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
this.equations = equations;
dimension      = equations.getDimension();
z              = new double[dimension];
zDot           = new double[dimension];
zDDot          = new double[dimension];
public int getDimension() {
return 2 * dimension;
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException {
System.arraycopy(y, 0,         z,    0, dimension);
System.arraycopy(y, dimension, zDot, 0, dimension);
equations.computeSecondDerivatives(t, z, zDot, zDDot);
System.arraycopy(zDot,  0, yDot, 0,         dimension);
System.arraycopy(zDDot, 0, yDot, dimension, dimension);
private SecondOrderDifferentialEquations equations;
private int dimension;
private double[] z;
private double[] zDot;
private double[] zDDot;
package org.apache.commons.math.ode;
public class IntegratorException
extends MathException {
public IntegratorException(String specifier, String[] parts) {
super(specifier, parts);
private static final long serialVersionUID = -1390328069787882608L;
package org.apache.commons.math.ode;
public interface SecondOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void integrate(SecondOrderDifferentialEquations equations,
double t0, double[] y0, double[] yDot0,
double t, double[] y, double[] yDot)
throws DerivativeException, IntegratorException;
package org.apache.commons.math.ode;
public abstract class FirstOrderIntegratorFactory {
protected FirstOrderIntegratorFactory() {
public static FirstOrderIntegratorFactory newInstance() {
FirstOrderIntegratorFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (FirstOrderIntegratorFactory) dc.newInstance(
FirstOrderIntegratorFactory.class,
"org.apache.commons.math.analysis.FirstOrderIntegratorFactoryImpl");
return new FirstOrderIntegratorFactoryImpl();
return factory;
public abstract FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step);
public abstract AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance);
public abstract FirstOrderIntegrator newEulerIntegrator(double step);
public abstract FirstOrderIntegrator newMidpointIntegrator(double step);
public abstract FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step);
public abstract FirstOrderIntegrator newGillIntegrator(double step);
public abstract FirstOrderIntegrator newThreeEighthesIntegrator(double step);
public abstract AdaptiveStepsizeIntegrator newHighamHall54Integrator(
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newHighamHall54Integrator(
double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newDormandPrince54Integrator(
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newDormandPrince54Integrator(
double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance);
public abstract AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance);
package org.apache.commons.math.ode;
public class GraggBulirschStoerIntegrator
extends AdaptiveStepsizeIntegrator {
private static final String methodName = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
denseOutput = (handler.requiresDenseOutput()
|| (! switchesHandler.isEmpty()));
setStabilityCheck(true, -1, -1, -1);
setStepsizeControl(-1, -1, -1, -1);
setOrderControl(-1, -1, -1);
setInterpolationControl(true, -1);
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
denseOutput = (handler.requiresDenseOutput()
|| (! switchesHandler.isEmpty()));
setStabilityCheck(true, -1, -1, -1);
setStepsizeControl(-1, -1, -1, -1);
setOrderControl(-1, -1, -1);
setInterpolationControl(true, -1);
if false, the check will be skipped
public void setStabilityCheck(boolean performTest,
int maxIter, int maxChecks,
double stabilityReduction) {
this.performTest = performTest;
this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;
this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;
if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {
this.stabilityReduction = 0.5;
this.stabilityReduction = stabilityReduction;
public void setStepsizeControl(double stepControl1, double stepControl2,
double stepControl3, double stepControl4) {
if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {
this.stepControl1 = 0.65;
this.stepControl1 = stepControl1;
if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {
this.stepControl2 = 0.94;
this.stepControl2 = stepControl2;
if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {
this.stepControl3 = 0.02;
this.stepControl3 = stepControl3;
if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {
this.stepControl4 = 4.0;
this.stepControl4 = stepControl4;
public void setOrderControl(int maxOrder,
double orderControl1, double orderControl2) {
if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {
this.maxOrder = 18;
if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {
this.orderControl1 = 0.8;
this.orderControl1 = orderControl1;
if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {
this.orderControl2 = 0.9;
this.orderControl2 = orderControl2;
initializeArrays();
public void setStepHandler (StepHandler handler) {
super.setStepHandler(handler);
denseOutput = (handler.requiresDenseOutput()
|| (! switchesHandler.isEmpty()));
initializeArrays();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence) {
super.addSwitchingFunction(function, maxCheckInterval, convergence);
denseOutput = (handler.requiresDenseOutput()
|| (! switchesHandler.isEmpty()));
initializeArrays();
private void initializeArrays() {
int size = maxOrder / 2;
if ((sequence == null) || (sequence.length != size)) {
sequence        = new int[size];
costPerStep     = new int[size];
coeff           = new double[size][];
costPerTimeUnit = new double[size];
optimalStep     = new double[size];
if (denseOutput) {
for (int k = 0; k < size; ++k) {
sequence[k] = 4 * k + 2;
for (int k = 0; k < size; ++k) {
sequence[k] = 2 * (k + 1); 
costPerStep[0] = sequence[0] + 1;
for (int k = 1; k < size; ++k) {
costPerStep[k] = costPerStep[k-1] + sequence[k];
for (int k = 0; k < size; ++k) {
coeff[k] = (k > 0) ? new double[k] : null;
for (int l = 0; l < k; ++l) {
double ratio = ((double) sequence[k]) / sequence[k-l-1];
coeff[k][l] = 1.0 / (ratio * ratio - 1.0);
public void setInterpolationControl(boolean useInterpolationError,
int mudif) {
this.useInterpolationError = useInterpolationError;
if ((mudif <= 0) || (mudif >= 7)) {
this.mudif = 4;
this.mudif = mudif;
public String getName() {
return methodName;
private void rescale(double[] y1, double[] y2, double[] scale) {
if (vecAbsoluteTolerance == null) {
for (int i = 0; i < scale.length; ++i) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
for (int i = 0; i < scale.length; ++i) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;
private boolean tryStep(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double step, int k,
double[] scale, double[][] f,
double[] yMiddle, double[] yEnd,
double[] yTmp)
throws DerivativeException {
int    n        = sequence[k];
double subStep  = step / n;
double subStep2 = 2 * subStep;
double t = t0 + subStep;
for (int i = 0; i < y0.length; ++i) {
yTmp[i] = y0[i];
yEnd[i] = y0[i] + subStep * f[0][i];
equations.computeDerivatives(t, yEnd, f[1]);
for (int j = 1; j < n; ++j) {
if (2 * j == n) {
System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);
t += subStep;
for (int i = 0; i < y0.length; ++i) {
double middle = yEnd[i];
yEnd[i]       = yTmp[i] + subStep2 * f[j][i];
yTmp[i]       = middle;
equations.computeDerivatives(t, yEnd, f[j+1]);
if (performTest && (j <= maxChecks) && (k < maxIter)) {
double initialNorm = 0.0;
for (int l = 0; l < y0.length; ++l) {
double ratio = f[0][l] / scale[l];
initialNorm += ratio * ratio;
double deltaNorm = 0.0;
for (int l = 0; l < y0.length; ++l) {
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
deltaNorm += ratio * ratio;
if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {
return false;
for (int i = 0; i < y0.length; ++i) {
yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);
return true;
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
for (int j = 1; j < k; ++j) {
for (int i = 0; i < last.length; ++i) {
diag[k-j-1][i] = diag[k-j][i]
+ coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
for (int i = 0; i < last.length; ++i) {
last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: "
+ "ODE problem has dimension {0}"
+ ", state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new String[] {
Double.toString(Math.abs(t - t0))
boolean forward = (t > t0);
double[] yDot0   = new double[y0.length];
double[] y1      = new double[y0.length];
double[] yTmp    = new double[y0.length];
double[] yTmpDot = new double[y0.length];
double[][] diagonal = new double[sequence.length-1][];
double[][] y1Diag = new double[sequence.length-1][];
for (int k = 0; k < sequence.length-1; ++k) {
diagonal[k] = new double[y0.length];
y1Diag[k] = new double[y0.length];
double[][][] fk  = new double[sequence.length][][];
for (int k = 0; k < sequence.length; ++k) {
fk[k]    = new double[sequence[k] + 1][];
fk[k][0] = yDot0;
for (int l = 0; l < sequence[k]; ++l) {
fk[k][l+1] = new double[y0.length];
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[] yDot1      = null;
double[][] yMidDots = null;
if (denseOutput) {
yDot1    = new double[y0.length];
yMidDots = new double[1 + 2 * sequence.length][];
for (int j = 0; j < yMidDots.length; ++j) {
yMidDots[j] = new double[y0.length];
yMidDots    = new double[1][];
yMidDots[0] = new double[y0.length];
double[] scale = new double[y0.length];
rescale(y, y, scale);
double log10R = Math.log(Math.max(1.0e-10,
(vecRelativeTolerance == null)
? scalRelativeTolerance
: vecRelativeTolerance[0]))
/ Math.log(10.0);
int targetIter = Math.max(1,
Math.min(sequence.length - 2,
(int) Math.floor(0.5 - 0.6 * log10R)));
AbstractStepInterpolator interpolator = null;
if (denseOutput || (! switchesHandler.isEmpty())) {
interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,
y1, yDot1,
yMidDots, forward);
interpolator = new DummyStepInterpolator(y, forward);
interpolator.storeTime(t0);
double  currentT         = t0;
double  hNew             = 0;
double  maxError         = Double.MAX_VALUE;
boolean previousRejected = false;
boolean firstTime        = true;
boolean newStep          = true;
boolean lastStep         = false;
boolean firstStepAlreadyComputed = false;
handler.reset();
costPerTimeUnit[0] = 0;
while (! lastStep) {
double h;
double error;
boolean reject = false;
if (newStep) {
interpolator.shift();
if (! firstStepAlreadyComputed) {
equations.computeDerivatives(currentT, y, yDot0);
if (firstTime) {
hNew = initializeStep(equations, forward,
2 * targetIter + 1, scale,
currentT, y, yDot0, yTmp, yTmpDot);
if (! forward) {
hNew = -hNew;
newStep = false;
h = hNew;
if ((forward && (currentT + h > t))
|| ((! forward) && (currentT + h < t))) {
h = t - currentT;
double nextT = currentT + h;
lastStep = forward ? (nextT >= t) : (nextT <= t);
int k = -1;
for (boolean loop = true; loop; ) {
++k;
if ( ! tryStep(equations, currentT, y, h, k, scale, fk[k],
(k == 0) ? yMidDots[0] : diagonal[k-1],
(k == 0) ? y1 : y1Diag[k-1],
yTmp)) {
hNew   = Math.abs(filterStep(h * stabilityReduction, false));
reject = true;
loop   = false;
if (k > 0) {
extrapolate(0, k, y1Diag, y1);
rescale(y, y1, scale);
error = 0;
for (int j = 0; j < y0.length; ++j) {
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
error += e * e;
error = Math.sqrt(error / y0.length);
if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
hNew   = Math.abs(filterStep(h * stabilityReduction, false));
reject = true;
loop   = false;
maxError = Math.max(4 * error, 1.0);
double exp = 1.0 / (2 * k + 1);
double fac = stepControl2 / Math.pow(error / stepControl1, exp);
double pow = Math.pow(stepControl3, exp);
fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));
optimalStep[k]     = Math.abs(filterStep(h * fac, true));
costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];
switch (k - targetIter) {
case -1 :
if ((targetIter > 1) && ! previousRejected) {
if (error <= 1.0) {
loop = false;
double ratio = ((double) sequence [k] * sequence[k+1])
/ (sequence[0] * sequence[0]);
if (error > ratio * ratio) {
reject = true;
loop   = false;
targetIter = k;
if ((targetIter > 1)
&& (costPerTimeUnit[targetIter-1]
< orderControl1 * costPerTimeUnit[targetIter])) {
--targetIter;
hNew = optimalStep[targetIter];
break;
case 0:
if (error <= 1.0) {
loop = false;
double ratio = ((double) sequence[k+1]) / sequence[0];
if (error > ratio * ratio) {
reject = true;
loop = false;
if ((targetIter > 1)
&& (costPerTimeUnit[targetIter-1]
< orderControl1 * costPerTimeUnit[targetIter])) {
--targetIter;
hNew = optimalStep[targetIter];
break;
case 1 :
if (error > 1.0) {
reject = true;
if ((targetIter > 1)
&& (costPerTimeUnit[targetIter-1]
< orderControl1 * costPerTimeUnit[targetIter])) {
--targetIter;
hNew = optimalStep[targetIter];
loop = false;
break;
default :
if ((firstTime || lastStep) && (error <= 1.0)) {
loop = false;
break;
double hInt = getMaxStep();
if (denseOutput && ! reject) {
for (int j = 1; j <= k; ++j) {
extrapolate(0, j, diagonal, yMidDots[0]);
equations.computeDerivatives(currentT + h, y1, yDot1);
int mu = 2 * k - mudif + 3;
for (int l = 0; l < mu; ++l) {
int l2 = l / 2;
double factor = Math.pow(0.5 * sequence[l2], l);
int middleIndex = fk[l2].length / 2;
for (int i = 0; i < y0.length; ++i) {
yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];
for (int j = 1; j <= k - l2; ++j) {
factor = Math.pow(0.5 * sequence[j + l2], l);
middleIndex = fk[l2+j].length / 2;
for (int i = 0; i < y0.length; ++i) {
diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];
extrapolate(l2, j, diagonal, yMidDots[l+1]);
for (int i = 0; i < y0.length; ++i) {
yMidDots[l+1][i] *= h;
for (int j = (l + 1) / 2; j <= k; ++j) {
for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
for (int i = 0; i < y0.length; ++i) {
fk[j][m][i] -= fk[j][m-2][i];
if (mu >= 0) {
GraggBulirschStoerStepInterpolator gbsInterpolator
= (GraggBulirschStoerStepInterpolator) interpolator;
gbsInterpolator.computeCoefficients(mu, h);
if (useInterpolationError) {
double interpError = gbsInterpolator.estimateError(scale);
hInt = Math.abs(h / Math.max(Math.pow(interpError, 1.0 / (mu+4)),
0.01));
if (interpError > 10.0) {
hNew = hInt;
reject = true;
if (!reject) {
interpolator.storeTime(currentT + h);
if (switchesHandler.evaluateStep(interpolator)) {
reject = true;
hNew = Math.abs(switchesHandler.getEventTime() - currentT);
if (!reject) {
firstStepAlreadyComputed = true;
System.arraycopy(yDot1, 0, yDot0, 0, y0.length);
if (! reject) {
currentT += h;
System.arraycopy(y1, 0, y, 0, y0.length);
switchesHandler.stepAccepted(currentT, y);
if (switchesHandler.stop()) {
lastStep = true;
interpolator.storeTime(currentT);
handler.handleStep(interpolator, lastStep);
if (switchesHandler.reset(currentT, y) && ! lastStep) {
firstStepAlreadyComputed = false;
int optimalIter;
if (k == 1) {
optimalIter = 2;
if (previousRejected) {
optimalIter = 1;
optimalIter = k;
if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {
optimalIter = k-1;
optimalIter = Math.min(k+1, sequence.length - 2);
optimalIter = k - 1;
if ((k > 2)
&& (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {
optimalIter = k - 2;
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
optimalIter = Math.min(k, sequence.length - 2);
if (previousRejected) {
targetIter = Math.min(optimalIter, k);
hNew = Math.min(Math.abs(h), optimalStep[targetIter]);
if (optimalIter <= k) {
hNew = optimalStep[optimalIter];
if ((k < targetIter)
&& (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {
hNew = filterStep(optimalStep[k]
false);
hNew = filterStep(optimalStep[k]
false);
targetIter = optimalIter;
newStep = true;
hNew = Math.min(hNew, hInt);
if (! forward) {
hNew = -hNew;
firstTime = false;
if (reject) {
lastStep = false;
previousRejected = true;
previousRejected = false;
private int maxOrder;
private int[] sequence;
private int[] costPerStep;
private double[] costPerTimeUnit;
private double[] optimalStep;
private double[][] coeff;
private boolean performTest;
private int maxChecks;
private int maxIter;
private double stabilityReduction;
private double stepControl1;
private double stepControl2;
private double stepControl3;
private double stepControl4;
private double orderControl1;
private double orderControl2;
private boolean denseOutput;
private boolean useInterpolationError;
private int mudif;
package org.apache.commons.math.ode;
public interface FixedStepHandler {
public void handleStep(double t, double[] y, boolean isLast);
package org.apache.commons.math.ode;
class DormandPrince853StepInterpolator
extends RungeKuttaStepInterpolator {
public DormandPrince853StepInterpolator() {
super();
yDotKLast = null;
yTmp      = null;
v         = null;
vectorsInitialized = false;
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
super(interpolator);
if (interpolator.currentState == null) {
yDotKLast = null;
v         = null;
vectorsInitialized = false;
int dimension = interpolator.currentState.length;
yDotKLast    = new double[3][];
for (int k = 0; k < yDotKLast.length; ++k) {
yDotKLast[k] = new double[dimension];
System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,
dimension);
v = new double[7][];
for (int k = 0; k < v.length; ++k) {
v[k] = new double[dimension];
System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);
vectorsInitialized = interpolator.vectorsInitialized;
yTmp = null;
public Object clone() {
return new DormandPrince853StepInterpolator(this);
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
super.reinitialize(equations, y, yDotK, forward);
int dimension = currentState.length;
yDotKLast = new double[3][];
for (int k = 0; k < yDotKLast.length; ++k) {
yDotKLast[k] = new double[dimension];
yTmp = new double[dimension];
v = new double[7][];
for (int k = 0; k < v.length; ++k) {
v[k]  = new double[dimension];
vectorsInitialized = false;
public void storeTime(double t) {
super.storeTime(t);
vectorsInitialized = false;
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
if (! vectorsInitialized) {
if (v == null) {
v = new double[7][];
for (int k = 0; k < 7; ++k) {
v[k] = new double[interpolatedState.length];
finalizeStep();
for (int i = 0; i < interpolatedState.length; ++i) {
v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i]
+ b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i]
+ b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i]
+ d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i]
+ d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i]
+ d[k][9]  * yDotKLast[0][i]
+ d[k][10] * yDotKLast[1][i]
+ d[k][11] * yDotKLast[2][i]);
vectorsInitialized = true;
double eta = oneMinusThetaH / h;
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
-   eta * (v[0][i]
- theta * (v[1][i]
+ theta * (v[2][i]
+   eta * (v[3][i]
+ theta * (v[4][i]
+   eta * (v[5][i]
+ theta * (v[6][i])))))));
protected void doFinalize()
throws DerivativeException {
double s;
for (int j = 0; j < currentState.length; ++j) {
s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j]
+ k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j]
+ k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];
yTmp[j] = currentState[j] + h * s;
equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);
for (int j = 0; j < currentState.length; ++j) {
s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j]
+ k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j]
+ k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j]
+ k15_14 * yDotKLast[0][j];
yTmp[j] = currentState[j] + h * s;
equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);
for (int j = 0; j < currentState.length; ++j) {
s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j]
+ k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j]
+ k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j]
+ k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];
yTmp[j] = currentState[j] + h * s;
equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);
public void writeExternal(ObjectOutput out)
throws IOException {
finalizeStep();
throw new IOException(e.getMessage());
out.writeInt(currentState.length);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(yDotKLast[0][i]);
out.writeDouble(yDotKLast[1][i]);
out.writeDouble(yDotKLast[2][i]);
super.writeExternal(out);
public void readExternal(ObjectInput in)
throws IOException {
yDotKLast = new double[3][];
int dimension = in.readInt();
yDotKLast[0] = new double[dimension];
yDotKLast[1] = new double[dimension];
yDotKLast[2] = new double[dimension];
for (int i = 0; i < dimension; ++i) {
yDotKLast[0][i] = in.readDouble();
yDotKLast[1][i] = in.readDouble();
yDotKLast[2][i] = in.readDouble();
super.readExternal(in);
private double[][] yDotKLast;
private double[] yTmp;
private double[][] v;
private boolean vectorsInitialized;
private static double b_01 =         104257.0 / 1920240.0;
private static double b_06 =        3399327.0 / 763840.0;
private static double b_07 =       66578432.0 / 35198415.0;
private static double b_08 =    -1674902723.0 / 288716400.0;
private static double b_09 = 54980371265625.0 / 176692375811392.0;
private static double b_10 =        -734375.0 / 4826304.0;
private static double b_11 =      171414593.0 / 851261400.0;
private static double b_12 =         137909.0 / 3084480.0;
private static double c14    = 1.0 / 10.0;
private static double k14_01 =       13481885573.0 / 240030000000.0      - b_01;
private static double k14_06 =                 0.0                       - b_06;
private static double k14_07 =      139418837528.0 / 549975234375.0      - b_07;
private static double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;
private static double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;
private static double k14_10 =          57799439.0 / 377055000.0         - b_10;
private static double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;
private static double k14_12 =        1458939311.0 / 192780000000.0      - b_12;
private static double k14_13 =             -4149.0 / 500000.0;
private static double c15    = 1.0 / 5.0;
private static double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;
private static double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;
private static double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;
private static double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;
private static double k15_09 =                 0.0                       - b_09;
private static double k15_10 =                 0.0                       - b_10;
private static double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;
private static double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;
private static double k15_13 =      -11518334563.0 / 33831184612500.0;
private static double k15_14 =        1912306948.0 / 13532473845.0;
private static double c16    = 7.0 / 9.0;
private static double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;
private static double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;
private static double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;
private static double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;
private static double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;
private static double k16_10 =                 0.0                       - b_10;
private static double k16_11 =                 0.0                       - b_11;
private static double k16_12 =                 0.0                       - b_12;
private static double k16_13 =       -1199007803.0 / 857031517296.0;
private static double k16_14 =      157882067000.0 / 53564469831.0;
private static double k16_15 =     -290468882375.0 / 31741908048.0;
private static double[][] d = {
-118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,
3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,
2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,
-126493.0 / 1421424.0,                    98350000.0 / 5419179.0,
-18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},
19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,
-4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,
-85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,
2479159.0 / 157936.0,                    -18750000.0 / 602131.0,
-19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},
-13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,
-296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,
-18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,
-11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,
519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},
-595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,
2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,
53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,
-1718875.0 / 39484.0,                      58000000.0 / 602131.0,
-1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}
private static final long serialVersionUID = 4165537490327432186L;
package org.apache.commons.math.ode;
public class DummyStepInterpolator
extends AbstractStepInterpolator {
public DummyStepInterpolator() {
super();
protected DummyStepInterpolator(double[] y, boolean forward) {
super(y, forward);
protected DummyStepInterpolator(DummyStepInterpolator interpolator) {
super(interpolator);
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
throws DerivativeException {
public void writeExternal(ObjectOutput out)
throws IOException {
writeBaseExternal(out);
public void readExternal(ObjectInput in)
throws IOException {
double t = readBaseExternal(in);
setInterpolatedTime(t);
throw new IOException(e.getMessage());
private static final long serialVersionUID = 1708010296707839488L;
package org.apache.commons.math.ode;
public class ThreeEighthesIntegrator
extends RungeKuttaIntegrator {
private static final String methodName = "3/8";
private static final double[] c = {
1.0 / 3.0, 2.0 / 3.0, 1.0
private static final double[][] a = {
private static final double[] b = {
1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0
public ThreeEighthesIntegrator(double step) {
super(false, c, a, b, new ThreeEighthesStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public interface StepHandler {
public boolean requiresDenseOutput();
public void reset();
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException;
package org.apache.commons.math.ode;
public class DummyStepHandler
implements StepHandler {
private DummyStepHandler() {
public static DummyStepHandler getInstance() {
if (instance == null) {
instance = new DummyStepHandler();
return instance;
public boolean requiresDenseOutput() {
return false;
public void reset() {
public void handleStep(StepInterpolator interpolator, boolean isLast) {
private static DummyStepHandler instance = null;
package org.apache.commons.math.ode;
public class ClassicalRungeKuttaIntegrator
extends RungeKuttaIntegrator {
private static final String methodName = "classical Runge-Kutta";
private static final double[] c = {
1.0 / 2.0, 1.0 / 2.0, 1.0
private static final double[][] a = {
private static final double[] b = {
1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0
public ClassicalRungeKuttaIntegrator(double step) {
super(false, c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public class FirstOrderIntegratorFactoryImpl extends
FirstOrderIntegratorFactory {
public FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step) {
return newClassicalRungeKuttaIntegrator(step);
public AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
double minStep, double maxStep, double scalAbsoluteTolerance,
double scalRelativeTolerance) {
return newDormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
public AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
double minStep, double maxStep, double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
return newDormandPrince853Integrator(minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
public FirstOrderIntegrator newEulerIntegrator(double step) {
return new EulerIntegrator(step);
public FirstOrderIntegrator newMidpointIntegrator(double step) {
return new MidpointIntegrator(step);
public FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step) {
return new ClassicalRungeKuttaIntegrator(step);
public FirstOrderIntegrator newGillIntegrator(double step) {
return new GillIntegrator(step);
public FirstOrderIntegrator newThreeEighthesIntegrator(double step) {
return new ThreeEighthesIntegrator(step);
public AdaptiveStepsizeIntegrator newHighamHall54Integrator(double minStep,
double maxStep, double scalAbsoluteTolerance,
double scalRelativeTolerance) {
return new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
public AdaptiveStepsizeIntegrator newHighamHall54Integrator(double minStep,
double maxStep, double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
return new HighamHall54Integrator(minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(
double minStep, double maxStep, double scalAbsoluteTolerance,
double scalRelativeTolerance) {
return new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(double minStep,
double maxStep, double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
return new DormandPrince54Integrator(minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
public AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
double minStep, double maxStep, double scalAbsoluteTolerance,
double scalRelativeTolerance) {
return new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
public AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
double minStep, double maxStep, double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
return new DormandPrince853Integrator(minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
public AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
double minStep, double maxStep, double scalAbsoluteTolerance,
double scalRelativeTolerance) {
return new GraggBulirschStoerIntegrator(minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
public AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
double minStep, double maxStep, double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
return new GraggBulirschStoerIntegrator(minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
package org.apache.commons.math.ode;
public class MidpointIntegrator
extends RungeKuttaIntegrator {
private static final String methodName = "midpoint";
private static final double[] c = {
1.0 / 2.0
private static final double[][] a = {
private static final double[] b = {
0.0, 1.0
public MidpointIntegrator(double step) {
super(false, c, a, b, new MidpointStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
abstract class RungeKuttaStepInterpolator
extends AbstractStepInterpolator {
protected RungeKuttaStepInterpolator() {
super();
yDotK     = null;
equations = null;
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
super(interpolator);
if (interpolator.currentState != null) {
int dimension = currentState.length;
yDotK = new double[interpolator.yDotK.length][];
for (int k = 0; k < interpolator.yDotK.length; ++k) {
yDotK[k] = new double[dimension];
System.arraycopy(interpolator.yDotK[k], 0,
yDotK[k], 0, dimension);
yDotK = null;
equations = null;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
reinitialize(y, forward);
this.yDotK = yDotK;
this.equations = equations;
public void writeExternal(ObjectOutput out)
throws IOException {
writeBaseExternal(out);
out.writeInt(yDotK.length);
for (int k = 0; k < yDotK.length; ++k) {
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(yDotK[k][i]);
public void readExternal(ObjectInput in)
throws IOException {
double t = readBaseExternal(in);
int kMax = in.readInt();
yDotK = new double[kMax][];
for (int k = 0; k < kMax; ++k) {
yDotK[k] = new double[currentState.length];
for (int i = 0; i < currentState.length; ++i) {
yDotK[k][i] = in.readDouble();
equations = null;
setInterpolatedTime(t);
throw new IOException(e.getMessage());
protected double[][] yDotK;
protected FirstOrderDifferentialEquations equations;
package org.apache.commons.math.ode;
public interface StepInterpolator
extends Externalizable {
public double getPreviousTime();
public double getCurrentTime();
public double getInterpolatedTime();
public void setInterpolatedTime(double time)
throws DerivativeException;
public double[] getInterpolatedState();
public boolean isForward();
package org.apache.commons.math.ode;
class DormandPrince54StepInterpolator
extends RungeKuttaStepInterpolator {
public DormandPrince54StepInterpolator() {
super();
v1 = null;
v2 = null;
v3 = null;
v4 = null;
vectorsInitialized = false;
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
super(interpolator);
if (interpolator.v1 == null) {
v1 = null;
v2 = null;
v3 = null;
v4 = null;
vectorsInitialized = false;
v1 = (double[]) interpolator.v1.clone();
v2 = (double[]) interpolator.v2.clone();
v3 = (double[]) interpolator.v3.clone();
v4 = (double[]) interpolator.v4.clone();
vectorsInitialized = interpolator.vectorsInitialized;
public Object clone() {
return new DormandPrince54StepInterpolator(this);
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
super.reinitialize(equations, y, yDotK, forward);
v1 = null;
v2 = null;
v3 = null;
v4 = null;
vectorsInitialized = false;
public void storeTime(double t) {
super.storeTime(t);
vectorsInitialized = false;
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
if (! vectorsInitialized) {
if (v1 == null) {
v1 = new double[interpolatedState.length];
v2 = new double[interpolatedState.length];
v3 = new double[interpolatedState.length];
v4 = new double[interpolatedState.length];
for (int i = 0; i < interpolatedState.length; ++i) {
v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i]
+ a74 * yDotK[4][i] + a75 * yDotK[5][i]);
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i]
+ d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);
vectorsInitialized = true;
double eta = oneMinusThetaH / h;
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
- eta * (v1[i]
- theta * (v2[i]
+ theta * (v3[i]
+ eta * v4[i])));
private double[] v1;
private double[] v2;
private double[] v3;
private double[] v4;
private boolean vectorsInitialized;
private static final double a70 =    35.0 /  384.0;
private static final double a72 =   500.0 / 1113.0;
private static final double a73 =   125.0 /  192.0;
private static final double a74 = -2187.0 / 6784.0;
private static final double a75 =    11.0 /   84.0;
private static final double d0 =  -12715105075.0 /  11282082432.0;
private static final double d2 =   87487479700.0 /  32700410799.0;
private static final double d3 =  -10690763975.0 /   1880347072.0;
private static final double d4 =  701980252875.0 / 199316789632.0;
private static final double d5 =   -1453857185.0 /    822651844.0;
private static final double d6 =      69997945.0 /     29380423.0;
private static final long serialVersionUID = 4104157279605906956L;
package org.apache.commons.math.ode;
public class DormandPrince54Integrator
extends RungeKuttaFehlbergIntegrator {
private static final String methodName = "Dormand-Prince 5(4)";
private static final double[] c = {
1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0
private static final double[][] a = {
private static final double[] b = {
35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0
private static final double e1 =     71.0 / 57600.0;
private static final double e3 =    -71.0 / 16695.0;
private static final double e4 =     71.0 / 1920.0;
private static final double e5 = -17253.0 / 339200.0;
private static final double e6 =     22.0 / 525.0;
private static final double e7 =     -1.0 / 40.0;
public DormandPrince54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, c, a, b, new DormandPrince54StepInterpolator(),
minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
public DormandPrince54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, c, a, b, new DormandPrince54StepInterpolator(),
minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public String getName() {
return methodName;
public int getOrder() {
return 5;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double error = 0;
for (int j = 0; j < y0.length; ++j) {
double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j]
+ e4 * yDotK[3][j] +  e5 * yDotK[4][j]
+ e6 * yDotK[5][j] +  e7 * yDotK[6][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null)
? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)
: (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
error += ratio * ratio;
return Math.sqrt(error / y0.length);
package org.apache.commons.math.ode;
public interface SwitchingFunction extends Serializable {
public static final int STOP = 0;
public static final int RESET_STATE = 1;
public static final int RESET_DERIVATIVES = 2;
public static final int CONTINUE = 3;
public double g(double t, double[] y);
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
package org.apache.commons.math.ode;
class GraggBulirschStoerStepInterpolator
extends AbstractStepInterpolator {
private double[] y0Dot;
private double[] y1;
private double[] y1Dot;
private double[][] yMidDots;
private double[][] polynoms;
private double[] errfac;
private int currentDegree;
private void resetTables(int maxDegree) {
if (maxDegree < 0) {
polynoms      = null;
errfac        = null;
currentDegree = -1;
double[][] newPols = new double[maxDegree + 1][];
if (polynoms != null) {
System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);
for (int i = polynoms.length; i < newPols.length; ++i) {
newPols[i] = new double[currentState.length];
for (int i = 0; i < newPols.length; ++i) {
newPols[i] = new double[currentState.length];
polynoms = newPols;
if (maxDegree <= 4) {
errfac = null;
errfac = new double[maxDegree - 4];
for (int i = 0; i < errfac.length; ++i) {
int ip5 = i + 5;
errfac[i] = 1.0 / (ip5 * ip5);
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
for (int j = 0; j <= i; ++j) {
errfac[i] *= e / (j + 1);
currentDegree = 0;
public GraggBulirschStoerStepInterpolator() {
y0Dot    = null;
y1       = null;
y1Dot    = null;
yMidDots = null;
resetTables(-1);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double[] y1, double[] y1Dot,
double[][] yMidDots,
boolean forward) {
super(y, forward);
this.y0Dot    = y0Dot;
this.y1       = y1;
this.y1Dot    = y1Dot;
this.yMidDots = yMidDots;
resetTables(yMidDots.length + 4);
public GraggBulirschStoerStepInterpolator
(GraggBulirschStoerStepInterpolator interpolator) {
super(interpolator);
int dimension = currentState.length;
y0Dot    = null;
y1       = null;
y1Dot    = null;
yMidDots = null;
if (interpolator.polynoms == null) {
polynoms = null;
currentDegree = -1;
resetTables(interpolator.currentDegree);
for (int i = 0; i < polynoms.length; ++i) {
polynoms[i] = new double[dimension];
System.arraycopy(interpolator.polynoms[i], 0,
polynoms[i], 0, dimension);
currentDegree = interpolator.currentDegree;
public Object clone() {
return new GraggBulirschStoerStepInterpolator(this);
public void computeCoefficients(int mu, double h) {
if ((polynoms == null) || (polynoms.length <= (mu + 4))) {
resetTables(mu + 4);
currentDegree = mu + 4;
for (int i = 0; i < currentState.length; ++i) {
double yp0   = h * y0Dot[i];
double yp1   = h * y1Dot[i];
double ydiff = y1[i] - currentState[i];
double aspl  = ydiff - yp1;
double bspl  = yp0 - ydiff;
polynoms[0][i] = currentState[i];
polynoms[1][i] = ydiff;
polynoms[2][i] = aspl;
polynoms[3][i] = bspl;
if (mu < 0) {
return;
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);
if (mu > 0) {
double ph1 = ydiff + 0.25 * (aspl - bspl);
polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);
if (mu > 1) {
double ph2 = yp1 - yp0;
polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);
if (mu > 2) {
double ph3 = 6 * (bspl - aspl);
polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);
for (int j = 4; j <= mu; ++j) {
double fac1 = 0.5 * j * (j - 1);
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
polynoms[j+4][i] = 16 * (yMidDots[j][i]
+ fac1 * polynoms[j+2][i]
- fac2 * polynoms[j][i]);
public double estimateError(double[] scale) {
double error = 0;
if (currentDegree >= 5) {
for (int i = 0; i < currentState.length; ++i) {
double e = polynoms[currentDegree][i] / scale[i];
error += e * e;
error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];
return error;
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
int dimension = currentState.length;
double oneMinusTheta = 1.0 - theta;
double theta05       = theta - 0.5;
double t4            = theta * oneMinusTheta;
t4 = t4 * t4;
for (int i = 0; i < dimension; ++i) {
interpolatedState[i] = polynoms[0][i]
+ theta * (polynoms[1][i]
+ oneMinusTheta * (polynoms[2][i] * theta
+ polynoms[3][i] * oneMinusTheta));
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
public void writeExternal(ObjectOutput out)
throws IOException {
int dimension = currentState.length;
writeBaseExternal(out);
out.writeInt(currentDegree);
for (int k = 0; k <= currentDegree; ++k) {
for (int l = 0; l < dimension; ++l) {
out.writeDouble(polynoms[k][l]);
public void readExternal(ObjectInput in)
throws IOException {
double t = readBaseExternal(in);
int dimension = currentState.length;
int degree = in.readInt();
resetTables(degree);
currentDegree = degree;
for (int k = 0; k <= currentDegree; ++k) {
for (int l = 0; l < dimension; ++l) {
polynoms[k][l] = in.readDouble();
setInterpolatedTime(t);
throw new IOException(e.getMessage());
private static final long serialVersionUID = 7320613236731409847L;
package org.apache.commons.math.ode;
public abstract class RungeKuttaFehlbergIntegrator
extends AdaptiveStepsizeIntegrator {
protected RungeKuttaFehlbergIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
this.fsal      = fsal;
this.c         = c;
this.a         = a;
this.b         = b;
this.prototype = prototype;
exp = -1.0 / getOrder();
this.safety = 0.9;
setMinReduction(0.2);
setMaxGrowth(10.0);
protected RungeKuttaFehlbergIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double   minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
this.fsal      = fsal;
this.c         = c;
this.a         = a;
this.b         = b;
this.prototype = prototype;
exp = -1.0 / getOrder();
this.safety = 0.9;
setMinReduction(0.2);
setMaxGrowth(10.0);
public abstract String getName();
public abstract int getOrder();
public double getSafety() {
return safety;
public void setSafety(double safety) {
this.safety = safety;
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new String[] {
Double.toString(Math.abs(t - t0))
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
double  currentT  = t0;
double  hNew      = 0;
boolean firstTime = true;
boolean lastStep;
handler.reset();
do {
interpolator.shift();
double h     = 0;
double error = 0;
for (boolean loop = true; loop;) {
if (firstTime || !fsal) {
equations.computeDerivatives(currentT, y, yDotK[0]);
if (firstTime) {
double[] scale;
if (vecAbsoluteTolerance != null) {
scale = vecAbsoluteTolerance;
scale = new double[y0.length];
for (int i = 0; i < scale.length; ++i) {
scale[i] = scalAbsoluteTolerance;
hNew = initializeStep(equations, forward, getOrder(), scale,
currentT, y, yDotK[0], yTmp, yDotK[1]);
firstTime = false;
h = hNew;
if ((forward && (currentT + h > t))
|| ((! forward) && (currentT + h < t))) {
h = t - currentT;
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + h * sum;
equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + h * sum;
error = estimateError(yDotK, y, yTmp, h);
if (error <= 1.0) {
interpolator.storeTime(currentT + h);
if (switchesHandler.evaluateStep(interpolator)) {
hNew = switchesHandler.getEventTime() - currentT;
loop = false;
double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
hNew = filterStep(h * factor, false);
currentT += h;
System.arraycopy(yTmp, 0, y, 0, y0.length);
switchesHandler.stepAccepted(currentT, y);
if (switchesHandler.stop()) {
lastStep = true;
lastStep = forward ? (currentT >= t) : (currentT <= t);
interpolator.storeTime(currentT);
handler.handleStep(interpolator, lastStep);
if (fsal) {
System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
if (switchesHandler.reset(currentT, y) && ! lastStep) {
equations.computeDerivatives(currentT, y, yDotK[0]);
if (! lastStep) {
double  factor     = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
double  scaledH    = h * factor;
double  nextT      = currentT + scaledH;
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, nextIsLast);
public double getMinReduction() {
return minReduction;
public void setMinReduction(double minReduction) {
this.minReduction = minReduction;
public double getMaxGrowth() {
return maxGrowth;
public void setMaxGrowth(double maxGrowth) {
this.maxGrowth = maxGrowth;
protected abstract double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h);
private boolean fsal;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double exp;
private double safety;
private double minReduction;
private double maxGrowth;
package org.apache.commons.math.ode;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
double coeff23   = s * (( fourTheta - 2) * theta - 2);
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
+ coeff1  * yDotK[0][i]
+ coeff23 * (yDotK[1][i] + yDotK[2][i])
+ coeff4  * yDotK[3][i];
private static final long serialVersionUID = -6576285612589783992L;
package org.apache.commons.math.ode;
public abstract class AdaptiveStepsizeIntegrator
implements FirstOrderIntegrator {
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
this.minStep     = minStep;
this.maxStep     = maxStep;
this.initialStep = -1.0;
this.scalAbsoluteTolerance = scalAbsoluteTolerance;
this.scalRelativeTolerance = scalRelativeTolerance;
this.vecAbsoluteTolerance  = null;
this.vecRelativeTolerance  = null;
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
this.minStep     = minStep;
this.maxStep     = maxStep;
this.initialStep = -1.0;
this.scalAbsoluteTolerance = 0;
this.scalRelativeTolerance = 0;
this.vecAbsoluteTolerance  = vecAbsoluteTolerance;
this.vecRelativeTolerance  = vecRelativeTolerance;
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public void setInitialStepSize(double initialStepSize) {
if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {
initialStep = -1.0;
initialStep = initialStepSize;
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence) {
switchesHandler.add(function, maxCheckInterval, convergence);
public double initializeStep(FirstOrderDifferentialEquations equations,
boolean forward, int order, double[] scale,
double t0, double[] y0, double[] yDot0,
double[] y1, double[] yDot1)
throws DerivativeException {
if (initialStep > 0) {
return forward ? initialStep : -initialStep;
double ratio;
double yOnScale2 = 0;
double yDotOnScale2 = 0;
for (int j = 0; j < y0.length; ++j) {
ratio         = y0[j] / scale[j];
yOnScale2    += ratio * ratio;
ratio         = yDot0[j] / scale[j];
yDotOnScale2 += ratio * ratio;
double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))
? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));
if (! forward) {
h = -h;
for (int j = 0; j < y0.length; ++j) {
y1[j] = y0[j] + h * yDot0[j];
equations.computeDerivatives(t0 + h, y1, yDot1);
double yDDotOnScale = 0;
for (int j = 0; j < y0.length; ++j) {
ratio         = (yDot1[j] - yDot0[j]) / scale[j];
yDDotOnScale += ratio * ratio;
yDDotOnScale = Math.sqrt(yDDotOnScale) / h;
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
double h1 = (maxInv2 < 1.0e-15)
? Math.max(1.0e-6, 0.001 * Math.abs(h))
: Math.pow(0.01 / maxInv2, 1.0 / order);
h = Math.min(100.0 * Math.abs(h), h1);
h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0
if (h < getMinStep()) {
h = getMinStep();
if (h > getMaxStep()) {
h = getMaxStep();
if (! forward) {
h = -h;
return h;
protected double filterStep(double h, boolean acceptSmall)
throws IntegratorException {
if (Math.abs(h) < minStep) {
if (acceptSmall) {
h = (h < 0) ? -minStep : minStep;
throw new IntegratorException("minimal step size ({0}) reached,"
+ " integration needs {1}",
new String[] {
Double.toString(minStep),
Double.toString(Math.abs(h))
if (h > maxStep) {
h = maxStep;
h = -maxStep;
return h;
public abstract void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException;
public double getMinStep() {
return minStep;
public double getMaxStep() {
return maxStep;
private double minStep;
private double maxStep;
private double initialStep;
protected double scalAbsoluteTolerance;
protected double scalRelativeTolerance;
protected double[] vecAbsoluteTolerance;
protected double[] vecRelativeTolerance;
protected StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
public class EulerIntegrator
extends RungeKuttaIntegrator {
private static final String methodName = "Euler";
private static final double[] c = {
private static final double[][] a = {
private static final double[] b = {
1.0
public EulerIntegrator(double step) {
super(false, c, a, b, new EulerStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public interface SecondOrderDifferentialEquations {
public int getDimension();
public void computeSecondDerivatives(double t, double[] y, double[] yDot,
double[] yDDot)
throws DerivativeException;
package org.apache.commons.math.ode;
public class DormandPrince853Integrator
extends RungeKuttaFehlbergIntegrator {
private static final String methodName = "Dormand-Prince 8 (5, 3)";
private static final double sqrt6 = Math.sqrt(6.0);
private static final double[] c = {
(12.0 - 2.0 * sqrt6) / 135.0, (6.0 - sqrt6) / 45.0, (6.0 - sqrt6) / 30.0,
(6.0 + sqrt6) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,
6.0/7.0, 1.0, 1.0
private static final double[][] a = {
(-402.0 - 197.0 * sqrt6) / 1000.0, (168.0 + 73.0 * sqrt6) / 375.0},
(118.0 - 23.0 * sqrt6) / 1024.0, -9.0 / 512.0},
(51544.0 - 4784.0 * sqrt6) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},
(-1324889724104.0 - 318801444819.0 * sqrt6) / 626556937500.0,
(-1324889724104.0 + 318801444819.0 * sqrt6) / 626556937500.0,
96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,
-165125654.0 / 3796875.0},
(-4521408.0 - 1137963.0 * sqrt6) / 2937500.0,
(-4521408.0 + 1137963.0 * sqrt6) / 2937500.0,
96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,
-4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},
(354216.0 + 94326.0 * sqrt6) / 112847.0,
(354216.0 - 94326.0 * sqrt6) / 112847.0,
-43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,
14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,
-1477884375.0 / 485066827.0},
(-3457480.0 - 960905.0 * sqrt6) / 551636.0,
(-3457480.0 + 960905.0 * sqrt6) / 551636.0,
-844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,
-2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,
226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},
66578432.0/35198415.0, -1674902723.0/288716400.0,
54980371265625.0/176692375811392.0, -734375.0/4826304.0,
171414593.0/851261400.0, 137909.0/3084480.0}
private static final double[] b = {
104257.0/1920240.0,
0.0,
0.0,
0.0,
0.0,
3399327.0/763840.0,
66578432.0/35198415.0,
-1674902723.0/288716400.0,
54980371265625.0/176692375811392.0,
-734375.0/4826304.0,
171414593.0/851261400.0,
137909.0/3084480.0,
0.0
private static final double e1_01 =         116092271.0 / 8848465920.0;
private static final double e1_06 =          -1871647.0 / 1527680.0;
private static final double e1_07 =         -69799717.0 / 140793660.0;
private static final double e1_08 =     1230164450203.0 / 739113984000.0;
private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;
private static final double e1_10 =         464500805.0 / 1389975552.0;
private static final double e1_11 =     1606764981773.0 / 19613062656000.0;
private static final double e1_12 =           -137909.0 / 6168960.0;
private static final double e2_01 =           -364463.0 / 1920240.0;
private static final double e2_06 =           3399327.0 / 763840.0;
private static final double e2_07 =          66578432.0 / 35198415.0;
private static final double e2_08 =       -1674902723.0 / 288716400.0;
private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;
private static final double e2_10 =           -734375.0 / 4826304.0;
private static final double e2_11 =         171414593.0 / 851261400.0;
private static final double e2_12 =             69869.0 / 3084480.0;
public DormandPrince853Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, c, a, b,
new DormandPrince853StepInterpolator(),
minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
public DormandPrince853Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, c, a, b,
new DormandPrince853StepInterpolator(),
minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public String getName() {
return methodName;
public int getOrder() {
return 8;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double error1 = 0;
double error2 = 0;
for (int j = 0; j < y0.length; ++j) {
double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j]
+ e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j]
+ e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j]
+ e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j]
+ e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j]
+ e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j]
+ e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null)
? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)
: (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio1  = errSum1 / tol;
error1        += ratio1 * ratio1;
double ratio2  = errSum2 / tol;
error2        += ratio2 * ratio2;
double den = error1 + 0.01 * error2;
if (den <= 0.0) {
den = 1.0;
return Math.abs(h) * error1 / Math.sqrt(y0.length * den);
package org.apache.commons.math.ode;
class ThreeEighthesStepInterpolator
extends RungeKuttaStepInterpolator {
public ThreeEighthesStepInterpolator() {
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new ThreeEighthesStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta2 = 4 * theta * theta;
double s          = oneMinusThetaH / 8.0;
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
double coeff2     = 3 * s * (1 + theta - fourTheta2);
double coeff3     = 3 * s * (1 + theta);
double coeff4     = s * (1 + theta + fourTheta2);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
- coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]
- coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
private static final long serialVersionUID = -3345024435978721931L;
package org.apache.commons.math.ode;
public abstract class AbstractStepInterpolator
implements StepInterpolator, Cloneable {
protected double previousTime;
protected double currentTime;
protected double h;
protected double[] currentState;
protected double interpolatedTime;
protected double[] interpolatedState;
private boolean finalized;
private boolean forward;
protected AbstractStepInterpolator() {
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
protected AbstractStepInterpolator(double[] y, boolean forward) {
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = y;
interpolatedState = new double[y.length];
finalized         = false;
this.forward      = forward;
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
previousTime      = interpolator.previousTime;
currentTime       = interpolator.currentTime;
h                 = interpolator.h;
interpolatedTime  = interpolator.interpolatedTime;
if (interpolator.currentState != null) {
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
finalized = interpolator.finalized;
forward   = interpolator.forward;
protected void reinitialize(double[] y, boolean forward) {
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = y;
interpolatedState = new double[y.length];
finalized         = false;
this.forward      = forward;
public Object clone() {
return super.clone();
return null;
public void shift() {
previousTime = currentTime;
public void storeTime(double t) {
currentTime      = t;
h                = currentTime - previousTime;
interpolatedTime = t;
System.arraycopy(currentState, 0, interpolatedState, 0,
currentState.length);
finalized = false;
public double getPreviousTime() {
return previousTime;
public double getCurrentTime() {
return currentTime;
public double getInterpolatedTime() {
return interpolatedTime;
public void setInterpolatedTime(double time)
throws DerivativeException {
interpolatedTime = time;
double oneMinusThetaH = currentTime - interpolatedTime;
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
public boolean isForward() {
return forward;
protected abstract void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException;
public double[] getInterpolatedState() {
return (double[]) interpolatedState.clone();
public final void finalizeStep()
throws DerivativeException {
if (! finalized) {
doFinalize();
finalized = true;
protected void doFinalize()
throws DerivativeException {
public abstract void writeExternal(ObjectOutput out)
throws IOException;
public abstract void readExternal(ObjectInput in)
throws IOException;
protected void writeBaseExternal(ObjectOutput out)
throws IOException {
out.writeInt(currentState.length);
out.writeDouble(previousTime);
out.writeDouble(currentTime);
out.writeDouble(h);
out.writeBoolean(forward);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(currentState[i]);
out.writeDouble(interpolatedTime);
finalizeStep();
throw new IOException(e.getMessage());
protected double readBaseExternal(ObjectInput in)
throws IOException {
int dimension = in.readInt();
previousTime  = in.readDouble();
currentTime   = in.readDouble();
h             = in.readDouble();
forward       = in.readBoolean();
currentState  = new double[dimension];
for (int i = 0; i < currentState.length; ++i) {
currentState[i] = in.readDouble();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
finalized = true;
return in.readDouble();
package org.apache.commons.math.ode;
public class ContinuousOutputModel
implements StepHandler, Serializable {
public ContinuousOutputModel() {
steps = new ArrayList();
reset();
public void append(ContinuousOutputModel model) {
if (model.steps.size() == 0) {
return;
if (steps.size() == 0) {
initialTime = model.initialTime;
forward     = model.forward;
if (getInterpolatedState().length != model.getInterpolatedState().length) {
throw new IllegalArgumentException("state vector dimension mismatch");
if (forward ^ model.forward) {
throw new IllegalArgumentException("propagation direction mismatch");
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
double current  = lastInterpolator.getCurrentTime();
double previous = lastInterpolator.getPreviousTime();
double step = current - previous;
double gap = model.getInitialTime() - current;
if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {
throw new IllegalArgumentException("hole between time ranges");
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
AbstractStepInterpolator ai = (AbstractStepInterpolator) iter.next();
steps.add(ai.clone());
index = steps.size() - 1;
finalTime = ((StepInterpolator) steps.get(index)).getCurrentTime();
public boolean requiresDenseOutput() {
return true;
public void reset() {
initialTime = Double.NaN;
finalTime   = Double.NaN;
forward     = true;
index       = 0;
steps.clear();
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
if (steps.size() == 0) {
initialTime = interpolator.getPreviousTime();
forward     = interpolator.isForward();
ai.finalizeStep();
steps.add(ai.clone());
if (isLast) {
finalTime = ai.getCurrentTime();
index     = steps.size() - 1;
public double getInitialTime() {
return initialTime;
public double getFinalTime() {
return finalTime;
public double getInterpolatedTime() {
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public void setInterpolatedTime(double time) {
int iMin = 0;
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());
int iMax = steps.size() - 1;
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());
if (locatePoint(time, sMin) <= 0) {
index = iMin;
sMin.setInterpolatedTime(time);
return;
if (locatePoint(time, sMax) >= 0) {
index = iMax;
sMax.setInterpolatedTime(time);
return;
while (iMax - iMin > 5) {
StepInterpolator si = (StepInterpolator) steps.get(index);
int location = locatePoint(time, si);
if (location < 0) {
iMax = index;
tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());
iMin = index;
tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime());
si.setInterpolatedTime(time);
return;
int iMed = (iMin + iMax) / 2;
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {
index = iMed;
double d12 = tMax - tMed;
double d23 = tMed - tMin;
double d13 = tMax - tMin;
double dt1 = time - tMax;
double dt2 = time - tMed;
double dt3 = time - tMin;
double iLagrange = (  (dt2 * dt3 * d23) * iMax
- (dt1 * dt3 * d13) * iMed
+ (dt1 * dt2 * d12) * iMin)
/ (d12 * d23 * d13);
index = (int) Math.rint(iLagrange);
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
if (index < low) {
index = low;
index = high;
index = iMin;
while ((index <= iMax)
&& (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {
++index;
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
throw new RuntimeException("unexpected DerivativeException caught: "
+ de.getMessage());
public double[] getInterpolatedState() {
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private int locatePoint(double time, StepInterpolator interval) {
if (forward) {
if (time < interval.getPreviousTime()) {
return -1;
return +1;
return 0;
if (time > interval.getPreviousTime()) {
return -1;
return +1;
return 0;
private double initialTime;
private double finalTime;
private boolean forward;
private int index;
private ArrayList steps;
private static final long serialVersionUID = 2259286184268533249L;
package org.apache.commons.math.ode;
public interface FirstOrderDifferentialEquations {
public int getDimension();
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException;
package org.apache.commons.math.ode;
public class SwitchingFunctionsHandler {
public SwitchingFunctionsHandler() {
functions   = new ArrayList();
first       = null;
initialized = false;
public void add(SwitchingFunction function,
double maxCheckInterval, double convergence) {
functions.add(new SwitchState(function, maxCheckInterval, convergence));
public boolean isEmpty() {
return functions.isEmpty();
public boolean evaluateStep(StepInterpolator interpolator) {
first = null;
if (functions.isEmpty()) {
return false;
if (! initialized) {
double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
double [] y = interpolator.getInterpolatedState();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
initialized = true;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
throw new RuntimeException("unexpected exception: " + e.getMessage());
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
public void stepAccepted(double t, double[] y) {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
public boolean stop() {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
return true;
return false;
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private ArrayList functions;
private SwitchState first;
private boolean initialized;
package org.apache.commons.math.ode;
class HighamHall54StepInterpolator
extends RungeKuttaStepInterpolator {
public HighamHall54StepInterpolator() {
super();
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
super(interpolator);
public Object clone() {
return new HighamHall54StepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double theta2 = theta * theta;
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i]
+ b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i]
+ b4 * yDotK[4][i] + b5 * yDotK[5][i];
private static final long serialVersionUID = -3583240427587318654L;
package org.apache.commons.math.ode;
public interface FirstOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence);
public void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException;
package org.apache.commons.math.ode;
public abstract class RungeKuttaIntegrator
implements FirstOrderIntegrator {
protected RungeKuttaIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double step) {
this.fsal       = fsal;
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
handler         = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public abstract String getName();
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence) {
switchesHandler.add(function, maxCheckInterval, convergence);
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new String[] {
Double.toString(Math.abs(t - t0))
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
double  currentT  = t0;
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
double  h         = (t - t0) / nbStep;
boolean firstTime = true;
boolean lastStep  = false;
handler.reset();
for (long i = 0; ! lastStep; ++i) {
interpolator.shift();
boolean needUpdate = false;
for (boolean loop = true; loop;) {
if (firstTime || !fsal) {
equations.computeDerivatives(currentT, y, yDotK[0]);
firstTime = false;
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + h * sum;
equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + h * sum;
interpolator.storeTime(currentT + h);
if (switchesHandler.evaluateStep(interpolator)) {
needUpdate = true;
h = switchesHandler.getEventTime() - currentT;
loop = false;
currentT += h;
System.arraycopy(yTmp, 0, y, 0, y0.length);
switchesHandler.stepAccepted(currentT, y);
if (switchesHandler.stop()) {
lastStep = true;
lastStep = (i == (nbStep - 1));
interpolator.storeTime(currentT);
handler.handleStep(interpolator, lastStep);
if (fsal) {
System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
if (switchesHandler.reset(currentT, y) && ! lastStep) {
equations.computeDerivatives(currentT, y, yDotK[0]);
if (needUpdate) {
nbStep = Math.max(1l, Math.abs(Math.round((t - currentT) / step)));
h = (t - currentT) / nbStep;
i = -1;
private boolean fsal;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
private StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
package org.apache.commons.math.ode;
public class DerivativeException
extends MathException {
public DerivativeException(String specifier, String[] parts) {
super(specifier, parts);
public DerivativeException(Throwable cause) {
super(cause);
private static final long serialVersionUID = -4100440615830558122L;
package org.apache.commons.math.stat;
public final class StatUtils {
private static UnivariateStatistic sum = new Sum();
private static UnivariateStatistic sumSq = new SumOfSquares();
private static UnivariateStatistic prod = new Product();
private static UnivariateStatistic sumLog = new SumOfLogs();
private static UnivariateStatistic min = new Min();
private static UnivariateStatistic max = new Max();
private static UnivariateStatistic mean = new Mean();
private static Variance variance = new Variance();
private static Percentile percentile = new Percentile();
private static GeometricMean geometricMean = new GeometricMean();
private StatUtils() {
public static double sum(final double[] values) {
return sum.evaluate(values);
public static double sum(final double[] values, final int begin, 
final int length) {
return sum.evaluate(values, begin, length);
public static double sumSq(final double[] values) {
return sumSq.evaluate(values);
public static double sumSq(final double[] values, final int begin,
final int length) {
return sumSq.evaluate(values, begin, length);
public static double product(final double[] values) {
return prod.evaluate(values);
public static double product(final double[] values, final int begin,
final int length) {
return prod.evaluate(values, begin, length);
public static double sumLog(final double[] values) {
return sumLog.evaluate(values);
public static double sumLog(final double[] values, final int begin,
final int length) {
return sumLog.evaluate(values, begin, length);
public static double mean(final double[] values) {
return mean.evaluate(values);
public static double mean(final double[] values, final int begin,
final int length) {
return mean.evaluate(values, begin, length);
public static double geometricMean(final double[] values) {
return geometricMean.evaluate(values);
public static double geometricMean(final double[] values, final int begin,
final int length) {
return geometricMean.evaluate(values, begin, length);
public static double variance(final double[] values) {
return variance.evaluate(values);
public static double variance(final double[] values, final int begin,
final int length) {
return variance.evaluate(values, begin, length);
public static double variance(final double[] values, final double mean, 
final int begin, final int length) {
return variance.evaluate(values, mean, begin, length);    
public static double variance(final double[] values, final double mean) {
return variance.evaluate(values, mean);    
public static double max(final double[] values) {
return max.evaluate(values);
public static double max(final double[] values, final int begin,
final int length) {
return max.evaluate(values, begin, length);
public static double min(final double[] values) {
return min.evaluate(values);
public static double min(final double[] values, final int begin,
final int length) {
return min.evaluate(values, begin, length);
public static double percentile(final double[] values, final double p) {
return percentile.evaluate(values,p);
public static double percentile(final double[] values, final int begin, 
final int length, final double p) {
return percentile.evaluate(values, begin, length, p);
public static double sumDifference(final double[] sample1, final double[] sample2)
throws IllegalArgumentException {
int n = sample1.length;
if (n  != sample2.length || n < 1) {
throw new IllegalArgumentException 
("Input arrays must have the same (positive) length.");
double result = 0;
for (int i = 0; i < n; i++) {
result += sample1[i] - sample2[i];
return result;
public static double meanDifference(final double[] sample1, final double[] sample2)
throws IllegalArgumentException {
return sumDifference(sample1, sample2) / (double) sample1.length;
public static double varianceDifference(final double[] sample1, final double[] sample2, 
double meanDifference)  throws IllegalArgumentException {
double sum1 = 0d;
double sum2 = 0d;
double diff = 0d;
int n = sample1.length;
if (n < 2 || n != sample2.length) {
throw new IllegalArgumentException("Input array lengths must be equal and at least 2.");
for (int i = 0; i < n; i++) {
diff = sample1[i] - sample2[i];
sum1 += (diff - meanDifference) *(diff - meanDifference);
sum2 += diff - meanDifference;
return (sum1 - (sum2 * sum2 / (double) n)) / (double) (n - 1);
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestUtils  {
protected TestUtils() {
super();
private static TTest tTest = new TTestImpl();
private static ChiSquareTest chiSquareTest = 
new ChiSquareTestImpl();
private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest = 
new ChiSquareTestImpl();
public static void setChiSquareTest(TTest tTest) {
TestUtils.tTest = tTest;
public static TTest getTTest() {
return tTest;
public static void setChiSquareTest(ChiSquareTest chiSquareTest) {
TestUtils.chiSquareTest = chiSquareTest;
public static ChiSquareTest getChiSquareTest() {
return chiSquareTest;
public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {
TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;
public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {
return unknownDistributionChiSquareTest;
public static double homoscedasticT(double[] sample1, double[] sample2)
throws IllegalArgumentException {
return tTest.homoscedasticT(sample1, sample2);
public static double homoscedasticT(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException {
return tTest.homoscedasticT(sampleStats1, sampleStats2);
public static boolean homoscedasticTTest(double[] sample1, double[] sample2,
double alpha)
throws IllegalArgumentException, MathException {
return tTest. homoscedasticTTest(sample1, sample2, alpha);
public static double homoscedasticTTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
return tTest.homoscedasticTTest(sample1, sample2);
public static double homoscedasticTTest(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException {
return tTest.homoscedasticTTest(sampleStats1, sampleStats2);
public static double pairedT(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
return tTest.pairedT(sample1, sample2);
public static boolean pairedTTest(double[] sample1, double[] sample2,
double alpha)
throws IllegalArgumentException, MathException {
return tTest.pairedTTest(sample1, sample2, alpha);
public static double pairedTTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
return tTest.pairedTTest(sample1, sample2);
public static double t(double mu, double[] observed)
throws IllegalArgumentException {
return tTest.t(mu, observed);
public static double t(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException {
return tTest.t(mu, sampleStats);
public static double t(double[] sample1, double[] sample2)
throws IllegalArgumentException {
return tTest.t(sample1, sample2);
public static double t(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException {
return tTest.t(sampleStats1, sampleStats2);
public static boolean tTest(double mu, double[] sample, double alpha)
throws IllegalArgumentException, MathException {
return tTest.tTest(mu, sample, alpha);
public static double tTest(double mu, double[] sample)
throws IllegalArgumentException, MathException {
return tTest.tTest(mu, sample);
public static boolean tTest(double mu, StatisticalSummary sampleStats,
double alpha)
throws IllegalArgumentException, MathException {
return tTest. tTest(mu, sampleStats, alpha);
public static double tTest(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException, MathException {
return tTest.tTest(mu, sampleStats);
public static boolean tTest(double[] sample1, double[] sample2, double alpha)
throws IllegalArgumentException, MathException {
return tTest.tTest(sample1, sample2, alpha);
public static double tTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
return tTest.tTest(sample1, sample2);
public static boolean tTest(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2, double alpha)
throws IllegalArgumentException, MathException {
return tTest. tTest(sampleStats1, sampleStats2, alpha);
public static double tTest(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException {
return tTest.tTest(sampleStats1, sampleStats2);
public static double chiSquare(double[] expected, long[] observed)
throws IllegalArgumentException {
return chiSquareTest.chiSquare(expected, observed);
public static double chiSquare(long[][] counts) 
throws IllegalArgumentException {
return chiSquareTest.chiSquare(counts);
public static boolean chiSquareTest(double[] expected, long[] observed,
double alpha)
throws IllegalArgumentException, MathException {
return chiSquareTest.chiSquareTest(expected, observed, alpha);
public static double chiSquareTest(double[] expected, long[] observed)
throws IllegalArgumentException, MathException {
return chiSquareTest.chiSquareTest(expected, observed);
public static boolean chiSquareTest(long[][] counts, double alpha)
throws IllegalArgumentException, MathException {
return chiSquareTest. chiSquareTest(counts, alpha);
public static double chiSquareTest(long[][] counts)
throws IllegalArgumentException, MathException {
return chiSquareTest. chiSquareTest(counts);
public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException {
return unknownDistributionChiSquareTest.chiSquareDataSetsComparison(observed1, observed2);
public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException, MathException {
return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2);
public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,
double alpha)
throws IllegalArgumentException, MathException {
return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);
package org.apache.commons.math.stat.inference;
public interface TTest {
public abstract double pairedT(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException;
public abstract double pairedTTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException;
public abstract boolean pairedTTest(
double[] sample1,
double[] sample2,
double alpha)
throws IllegalArgumentException, MathException;
public abstract double t(double mu, double[] observed)
throws IllegalArgumentException;
public abstract double t(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException;
public abstract double homoscedasticT(double[] sample1, double[] sample2)
throws IllegalArgumentException;
public abstract double t(double[] sample1, double[] sample2)
throws IllegalArgumentException;
public abstract double t(
StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException;
public abstract double homoscedasticT(
StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException;
public abstract double tTest(double mu, double[] sample)
throws IllegalArgumentException, MathException;
public abstract boolean tTest(double mu, double[] sample, double alpha)
throws IllegalArgumentException, MathException;
public abstract double tTest(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException, MathException;
public abstract boolean tTest(
double mu,
StatisticalSummary sampleStats,
double alpha)
throws IllegalArgumentException, MathException;
public abstract double tTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException;
public abstract double homoscedasticTTest(
double[] sample1,
double[] sample2)
throws IllegalArgumentException, MathException;
public abstract boolean tTest(
double[] sample1,
double[] sample2,
double alpha)
throws IllegalArgumentException, MathException;
public abstract boolean homoscedasticTTest(
double[] sample1,
double[] sample2,
double alpha)
throws IllegalArgumentException, MathException;
public abstract double tTest(
StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException;
public abstract double homoscedasticTTest(
StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException;
public abstract boolean tTest(
StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2,
double alpha)
throws IllegalArgumentException, MathException;
package org.apache.commons.math.stat.inference;
public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {
private ChiSquaredDistribution distribution;
public ChiSquareTestImpl() {
this(new ChiSquaredDistributionImpl(1.0));
public ChiSquareTestImpl(ChiSquaredDistribution x) {
super();
setDistribution(x);
public double chiSquare(double[] expected, long[] observed)
throws IllegalArgumentException {
double sumSq = 0.0d;
double dev = 0.0d;
if ((expected.length < 2) || (expected.length != observed.length)) {
throw new IllegalArgumentException(
"observed, expected array lengths incorrect");
if (!isPositive(expected) || !isNonNegative(observed)) {
throw new IllegalArgumentException(
"observed counts must be non-negative and expected counts must be postive");
for (int i = 0; i < observed.length; i++) {
dev = ((double) observed[i] - expected[i]);
sumSq += dev * dev / expected[i];
return sumSq;
public double chiSquareTest(double[] expected, long[] observed)
throws IllegalArgumentException, MathException {
distribution.setDegreesOfFreedom(expected.length - 1.0);
return 1.0 - distribution.cumulativeProbability(
chiSquare(expected, observed));
public boolean chiSquareTest(double[] expected, long[] observed, 
double alpha) throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException(
"bad significance level: " + alpha);
return (chiSquareTest(expected, observed) < alpha);
public double chiSquare(long[][] counts) throws IllegalArgumentException {
checkArray(counts);
int nRows = counts.length;
int nCols = counts[0].length;
double[] rowSum = new double[nRows];
double[] colSum = new double[nCols];
double total = 0.0d;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
rowSum[row] += (double) counts[row][col];
colSum[col] += (double) counts[row][col];
total += (double) counts[row][col];
double sumSq = 0.0d;
double expected = 0.0d;
for (int row = 0; row < nRows; row++) {
for (int col = 0; col < nCols; col++) {
expected = (rowSum[row] * colSum[col]) / total;
sumSq += (((double) counts[row][col] - expected) * 
((double) counts[row][col] - expected)) / expected; 
return sumSq;
public double chiSquareTest(long[][] counts)
throws IllegalArgumentException, MathException {
checkArray(counts);
double df = ((double) counts.length -1) * ((double) counts[0].length - 1);
distribution.setDegreesOfFreedom(df);
return 1 - distribution.cumulativeProbability(chiSquare(counts));
public boolean chiSquareTest(long[][] counts, double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (chiSquareTest(counts) < alpha);
public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException {
if ((observed1.length < 2) || (observed1.length != observed2.length)) {
throw new IllegalArgumentException(
"oberved1, observed2 array lengths incorrect");
if (!isNonNegative(observed1) || !isNonNegative(observed2)) {
throw new IllegalArgumentException(
"observed counts must be non-negative");
long countSum1 = 0;
long countSum2 = 0;
boolean unequalCounts = false;
double weight = 0.0;
for (int i = 0; i < observed1.length; i++) {
countSum1 += observed1[i];
countSum2 += observed2[i];   
if (countSum1 * countSum2 == 0) {
throw new IllegalArgumentException(
"observed counts cannot all be 0"); 
unequalCounts = (countSum1 != countSum2);
if (unequalCounts) {
weight = Math.sqrt((double) countSum1 / (double) countSum2);
double sumSq = 0.0d;
double dev = 0.0d;
double obs1 = 0.0d;
double obs2 = 0.0d;
for (int i = 0; i < observed1.length; i++) {
if (observed1[i] == 0 && observed2[i] == 0) {
throw new IllegalArgumentException(
"observed counts must not both be zero");
obs1 = (double) observed1[i];
obs2 = (double) observed2[i];
if (unequalCounts) { // apply weights
dev = obs1/weight - obs2 * weight;
dev = obs1 - obs2;
sumSq += (dev * dev) / (obs1 + obs2);
return sumSq;
public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException, MathException {
distribution.setDegreesOfFreedom((double) observed1.length - 1);
return 1 - distribution.cumulativeProbability(
chiSquareDataSetsComparison(observed1, observed2));
public boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,
double alpha) throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException(
"bad significance level: " + alpha);
return (chiSquareTestDataSetsComparison(observed1, observed2) < alpha);
private void checkArray(long[][] in) throws IllegalArgumentException {
if (in.length < 2) {
throw new IllegalArgumentException("Input table must have at least two rows");
if (in[0].length < 2) {
throw new IllegalArgumentException("Input table must have at least two columns");
if (!isRectangular(in)) {
throw new IllegalArgumentException("Input table must be rectangular");
if (!isNonNegative(in)) {
throw new IllegalArgumentException("All entries in input 2-way table must be non-negative");
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
private boolean isRectangular(long[][] in) {
for (int i = 1; i < in.length; i++) {
if (in[i].length != in[0].length) {
return false;
return true;
private boolean isPositive(double[] in) {
for (int i = 0; i < in.length; i ++) {
if (in[i] <= 0) {
return false;
return true;
private boolean isNonNegative(long[] in) {
for (int i = 0; i < in.length; i ++) {
if (in[i] < 0) {
return false;
return true;
private boolean isNonNegative(long[][] in) {
for (int i = 0; i < in.length; i ++) {
for (int j = 0; j < in[i].length; j++) {
if (in[i][j] < 0) {
return false;
return true;
public void setDistribution(ChiSquaredDistribution value) {
distribution = value;
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
package org.apache.commons.math.stat.inference;
public interface UnknownDistributionChiSquareTest extends ChiSquareTest {
double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException;
double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
throws IllegalArgumentException, MathException;
boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)
throws IllegalArgumentException, MathException;
package org.apache.commons.math.stat.inference;
public class TTestImpl implements TTest  {
private TDistribution distribution;
public TTestImpl() {
this(new TDistributionImpl(1.0));
public TTestImpl(TDistribution t) {
super();
setDistribution(t);
public double pairedT(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
if ((sample1 == null) || (sample2 == null ||
Math.min(sample1.length, sample2.length) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
double meanDifference = StatUtils.meanDifference(sample1, sample2);
return t(meanDifference, 0,  
StatUtils.varianceDifference(sample1, sample2, meanDifference),
(double) sample1.length);
public double pairedTTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
double meanDifference = StatUtils.meanDifference(sample1, sample2);
return tTest(meanDifference, 0, 
StatUtils.varianceDifference(sample1, sample2, meanDifference), 
(double) sample1.length);
public boolean pairedTTest(double[] sample1, double[] sample2, double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (pairedTTest(sample1, sample2) < alpha);
public double t(double mu, double[] observed)
throws IllegalArgumentException {
if ((observed == null) || (observed.length < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return t(StatUtils.mean(observed), mu, StatUtils.variance(observed),
observed.length);
public double t(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException {
if ((sampleStats == null) || (sampleStats.getN() < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return t(sampleStats.getMean(), mu, sampleStats.getVariance(),
sampleStats.getN());
public double homoscedasticT(double[] sample1, double[] sample2)
throws IllegalArgumentException {
if ((sample1 == null) || (sample2 == null ||
Math.min(sample1.length, sample2.length) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return homoscedasticT(StatUtils.mean(sample1), StatUtils.mean(sample2),
StatUtils.variance(sample1), StatUtils.variance(sample2),
(double) sample1.length, (double) sample2.length);
public double t(double[] sample1, double[] sample2)
throws IllegalArgumentException {
if ((sample1 == null) || (sample2 == null ||
Math.min(sample1.length, sample2.length) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return t(StatUtils.mean(sample1), StatUtils.mean(sample2),
StatUtils.variance(sample1), StatUtils.variance(sample2),
(double) sample1.length, (double) sample2.length);
public double t(StatisticalSummary sampleStats1, 
StatisticalSummary sampleStats2)
throws IllegalArgumentException {
if ((sampleStats1 == null) ||
(sampleStats2 == null ||
Math.min(sampleStats1.getN(), sampleStats2.getN()) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return t(sampleStats1.getMean(), sampleStats2.getMean(), 
sampleStats1.getVariance(), sampleStats2.getVariance(),
(double) sampleStats1.getN(), (double) sampleStats2.getN());
public double homoscedasticT(StatisticalSummary sampleStats1, 
StatisticalSummary sampleStats2)
throws IllegalArgumentException {
if ((sampleStats1 == null) ||
(sampleStats2 == null ||
Math.min(sampleStats1.getN(), sampleStats2.getN()) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(), 
sampleStats1.getVariance(), sampleStats2.getVariance(), 
(double) sampleStats1.getN(), (double) sampleStats2.getN());
public double tTest(double mu, double[] sample)
throws IllegalArgumentException, MathException {
if ((sample == null) || (sample.length < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return tTest( StatUtils.mean(sample), mu, StatUtils.variance(sample),
sample.length);
public boolean tTest(double mu, double[] sample, double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (tTest(mu, sample) < alpha);
public double tTest(double mu, StatisticalSummary sampleStats)
throws IllegalArgumentException, MathException {
if ((sampleStats == null) || (sampleStats.getN() < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return tTest(sampleStats.getMean(), mu, sampleStats.getVariance(),
sampleStats.getN());
public boolean tTest( double mu, StatisticalSummary sampleStats,
double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (tTest(mu, sampleStats) < alpha);
public double tTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
if ((sample1 == null) || (sample2 == null ||
Math.min(sample1.length, sample2.length) < 2)) {
throw new IllegalArgumentException("insufficient data");
return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2),
StatUtils.variance(sample1), StatUtils.variance(sample2),
(double) sample1.length, (double) sample2.length);
public double homoscedasticTTest(double[] sample1, double[] sample2)
throws IllegalArgumentException, MathException {
if ((sample1 == null) || (sample2 == null ||
Math.min(sample1.length, sample2.length) < 2)) {
throw new IllegalArgumentException("insufficient data");
return homoscedasticTTest(StatUtils.mean(sample1), 
StatUtils.mean(sample2), StatUtils.variance(sample1),
StatUtils.variance(sample2), (double) sample1.length, 
(double) sample2.length);
public boolean tTest(double[] sample1, double[] sample2,
double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (tTest(sample1, sample2) < alpha);
public boolean homoscedasticTTest(double[] sample1, double[] sample2,
double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (homoscedasticTTest(sample1, sample2) < alpha);
public double tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException {
if ((sampleStats1 == null) || (sampleStats2 == null ||
Math.min(sampleStats1.getN(), sampleStats2.getN()) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),
sampleStats2.getVariance(), (double) sampleStats1.getN(), 
(double) sampleStats2.getN());
public double homoscedasticTTest(StatisticalSummary sampleStats1, 
StatisticalSummary sampleStats2)
throws IllegalArgumentException, MathException {
if ((sampleStats1 == null) || (sampleStats2 == null ||
Math.min(sampleStats1.getN(), sampleStats2.getN()) < 2)) {
throw new IllegalArgumentException("insufficient data for t statistic");
return homoscedasticTTest(sampleStats1.getMean(),
sampleStats2.getMean(), sampleStats1.getVariance(),
sampleStats2.getVariance(), (double) sampleStats1.getN(), 
(double) sampleStats2.getN());
public boolean tTest(StatisticalSummary sampleStats1,
StatisticalSummary sampleStats2, double alpha)
throws IllegalArgumentException, MathException {
if ((alpha <= 0) || (alpha > 0.5)) {
throw new IllegalArgumentException("bad significance level: " + alpha);
return (tTest(sampleStats1, sampleStats2) < alpha);
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
protected double df(double v1, double v2, double n1, double n2) {
return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) /
((v1 * v1) / (n1 * n1 * (n1 - 1d)) + (v2 * v2) /
(n2 * n2 * (n2 - 1d)));
protected double t(double m, double mu, double v, double n) {
return (m - mu) / Math.sqrt(v / n);
protected double t(double m1, double m2,  double v1, double v2, double n1,
double n2)  {
return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));
protected double homoscedasticT(double m1, double m2,  double v1,
double v2, double n1, double n2)  {
double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2); 
return (m1 - m2) / Math.sqrt(pooledVariance * (1d / n1 + 1d / n2));
protected double tTest(double m, double mu, double v, double n)
throws MathException {
double t = Math.abs(t(m, mu, v, n));
distribution.setDegreesOfFreedom(n - 1);
return 1.0 - distribution.cumulativeProbability(-t, t);
protected double tTest(double m1, double m2, double v1, double v2, 
double n1, double n2)
throws MathException {
double t = Math.abs(t(m1, m2, v1, v2, n1, n2));
double degreesOfFreedom = 0;
degreesOfFreedom = df(v1, v2, n1, n2);
distribution.setDegreesOfFreedom(degreesOfFreedom);
return 1.0 - distribution.cumulativeProbability(-t, t);
protected double homoscedasticTTest(double m1, double m2, double v1,
double v2, double n1, double n2)
throws MathException {
double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));
double degreesOfFreedom = (double) (n1 + n2 - 2);
distribution.setDegreesOfFreedom(degreesOfFreedom);
return 1.0 - distribution.cumulativeProbability(-t, t);
public void setDistribution(TDistribution value) {
distribution = value;
package org.apache.commons.math.stat.inference;
public interface ChiSquareTest {
double chiSquare(double[] expected, long[] observed) 
throws IllegalArgumentException;
double chiSquareTest(double[] expected, long[] observed) 
throws IllegalArgumentException, MathException;
boolean chiSquareTest(double[] expected, long[] observed, double alpha) 
throws IllegalArgumentException, MathException;
double chiSquare(long[][] counts) 
throws IllegalArgumentException;
double chiSquareTest(long[][] counts) 
throws IllegalArgumentException, MathException;
boolean chiSquareTest(long[][] counts, double alpha) 
throws IllegalArgumentException, MathException;
package org.apache.commons.math.stat.descriptive;
public abstract class AbstractUnivariateStatistic
implements UnivariateStatistic, Serializable {
private static final long serialVersionUID = -8007759382851708045L;
public double evaluate(final double[] values) {
test(values, 0, 0);
return evaluate(values, 0, values.length);
public abstract double evaluate(final double[] values, final int begin, final int length);
protected boolean test(
final double[] values,
final int begin,
final int length) {
if (values == null) {
throw new IllegalArgumentException("input value array is null");
if (begin < 0) {
throw new IllegalArgumentException("start position cannot be negative");
if (length < 0) {
throw new IllegalArgumentException("length cannot be negative");
if (begin + length > values.length) {
throw new IllegalArgumentException(
"begin + length > values.length");
if (length == 0) {
return false;
return true;
package org.apache.commons.math.stat.descriptive;
public abstract class SummaryStatistics implements StatisticalSummary, Serializable {
private static final long serialVersionUID = -6400596334135654825L;
public static SummaryStatistics newInstance(Class cls) throws 
InstantiationException, IllegalAccessException {
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
instance = (SummaryStatistics) dc.newInstance(
SummaryStatistics.class,
"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl");
return new SummaryStatisticsImpl();
return instance;
public StatisticalSummary getSummary() {
return new StatisticalSummaryValues(getMean(), getVariance(), getN(),
getMax(), getMin(), getSum());
public abstract void addValue(double v);
public abstract double getMean();
public abstract double getGeometricMean();
public abstract double getVariance();
public abstract double getStandardDeviation();
public abstract double getMax();
public abstract double getMin();
public abstract long getN();
public abstract double getSum();
public abstract double getSumsq();
public abstract void clear();
public boolean equals(Object object) {
if (object == this ) {
return true;
if (object instanceof SummaryStatistics == false) {
return false;
SummaryStatistics stat = (SummaryStatistics) object;
return (MathUtils.equals(stat.getGeometricMean(), 
this.getGeometricMean()) &&
MathUtils.equals(stat.getMax(), this.getMax()) && 
MathUtils.equals(stat.getMean(),this.getMean()) &&
MathUtils.equals(stat.getMin(),this.getMin()) &&
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
MathUtils.equals(stat.getSumsq(),this.getSumsq()) &&
MathUtils.equals(stat.getVariance(),this.getVariance()));
public int hashCode() {
int result = 31 + MathUtils.hash(getGeometricMean());
result = result * 31 + MathUtils.hash(getGeometricMean());
result = result * 31 + MathUtils.hash(getMax());
result = result * 31 + MathUtils.hash(getMean());
result = result * 31 + MathUtils.hash(getMin());
result = result * 31 + MathUtils.hash(getN());
result = result * 31 + MathUtils.hash(getSum());
result = result * 31 + MathUtils.hash(getSumsq());
result = result * 31 + MathUtils.hash(getVariance());
return result;
package org.apache.commons.math.stat.descriptive;
public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {
private static final long serialVersionUID = 5188298269533339922L;
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
return new DescriptiveStatisticsImpl();
return factory;
public static final int INFINITE_WINDOW = -1;
public abstract void addValue(double v);
public double getMean() {
return apply(new Mean());
public double getGeometricMean() {
return apply(new GeometricMean());
public double getVariance() {
return apply(new Variance());
public double getStandardDeviation() {
double stdDev = Double.NaN;
if (getN() > 0) {
if (getN() > 1) {
stdDev = Math.sqrt(getVariance());
stdDev = 0.0;
return (stdDev);
public double getSkewness() {
return apply(new Skewness());
public double getKurtosis() {
return apply(new Kurtosis());
public double getMax() {
return apply(new Max());
public double getMin() {
return apply(new Min());
public abstract long getN();
public double getSum() {
return apply(new Sum());
public double getSumsq() {
return apply(new SumOfSquares());
public abstract void clear();
public abstract int getWindowSize();
public abstract void setWindowSize(int windowSize);
public abstract double[] getValues();
public double[] getSortedValues() {
double[] sort = getValues();
Arrays.sort(sort);
return sort;
public abstract double getElement(int index);
public double getPercentile(double p) {
return apply(new Percentile(p));
public String toString() {
StringBuffer outBuffer = new StringBuffer();
outBuffer.append("DescriptiveStatistics:\n");
outBuffer.append("n: " + getN() + "\n");
outBuffer.append("min: " + getMin() + "\n");
outBuffer.append("max: " + getMax() + "\n");
outBuffer.append("mean: " + getMean() + "\n");
outBuffer.append("std dev: " + getStandardDeviation() + "\n");
outBuffer.append("median: " + getPercentile(50) + "\n");
outBuffer.append("skewness: " + getSkewness() + "\n");
outBuffer.append("kurtosis: " + getKurtosis() + "\n");
return outBuffer.toString();
public abstract double apply(UnivariateStatistic stat);
package org.apache.commons.math.stat.descriptive.moment;
public class SecondMoment extends FirstMoment implements Serializable {
private static final long serialVersionUID = 3942403127395076445L;  
protected double m2;
public SecondMoment() {
super();
m2 = Double.NaN;
public void increment(final double d) {
if (n < 1) {
m1 = m2 = 0.0;
super.increment(d);
m2 += ((double) n - 1) * dev * nDev;
public void clear() {
super.clear();
m2 = Double.NaN;
public double getResult() {
return m2;
package org.apache.commons.math.stat.descriptive.moment;
public class Mean extends AbstractStorelessUnivariateStatistic 
implements Serializable {
private static final long serialVersionUID = -1296043746617791564L;    
protected FirstMoment moment;
protected boolean incMoment;
public Mean() {
incMoment = true;
moment = new FirstMoment();
public Mean(final FirstMoment m1) {
this.moment = m1;
incMoment = false;
public void increment(final double d) {
if (incMoment) {
moment.increment(d);
public void clear() {
if (incMoment) {
moment.clear();
public double getResult() {
return moment.m1;
public long getN() {
return moment.getN();
public double evaluate(final double[] values,final int begin, final int length) {
if (test(values, begin, length)) {
Sum sum = new Sum();
return sum.evaluate(values, begin, length) / ((double) length);
return Double.NaN;
package org.apache.commons.math.stat.descriptive.moment;
public class FourthMoment extends ThirdMoment implements Serializable{
private static final long serialVersionUID = 4763990447117157611L;
protected double m4;
public FourthMoment() {
super();
m4 = Double.NaN;
public void increment(final double d) {
if (n < 1) {
m4 = 0.0;
m3 = 0.0;
m2 = 0.0;
m1 = 0.0;
double prevM3 = m3;
double prevM2 = m2;
super.increment(d);
double n0 = (double) n;
m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +
((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);
public double getResult() {
return m4;
public void clear() {
super.clear();
m4 = Double.NaN;
package org.apache.commons.math.stat.descriptive.moment;
public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = -9111962718267217978L;  
protected SecondMoment moment = null;
protected boolean incMoment = true;
private boolean isBiasCorrected = true;
public Variance() {
moment = new SecondMoment();
public Variance(final SecondMoment m2) {
incMoment = false;
this.moment = m2;
public Variance(boolean isBiasCorrected) {
moment = new SecondMoment();
this.isBiasCorrected = isBiasCorrected;
public Variance(boolean isBiasCorrected, SecondMoment m2) {
incMoment = false;
this.moment = m2;
this.isBiasCorrected = isBiasCorrected;      
public void increment(final double d) {
if (incMoment) {
moment.increment(d);
public double getResult() {
if (moment.n == 0) {
return Double.NaN;
return 0d;
if (isBiasCorrected) {
return moment.m2 / ((double) moment.n - 1d);
return moment.m2 / ((double) moment.n);
public long getN() {
return moment.getN();
public void clear() {
if (incMoment) {
moment.clear();
public double evaluate(final double[] values) {
if (values == null) {
throw new IllegalArgumentException("input values array is null");
return evaluate(values, 0, values.length);
public double evaluate(final double[] values, final int begin, final int length) {
double var = Double.NaN;
if (test(values, begin, length)) {
clear();
if (length == 1) {
var = 0.0;
Mean mean = new Mean();
double m = mean.evaluate(values, begin, length);
var = evaluate(values, m, begin, length);
return var;
public double evaluate(final double[] values, final double mean, 
final int begin, final int length) {
double var = Double.NaN;
if (test(values, begin, length)) {
if (length == 1) {
var = 0.0;
double accum = 0.0;
double dev = 0.0;
double accum2 = 0.0;
for (int i = begin; i < begin + length; i++) {
dev = values[i] - mean;
accum += dev * dev;
accum2 += dev;
double len = (double) length;            
if (isBiasCorrected) {
var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
var = (accum - (accum2 * accum2 / len)) / len;
return var;
public double evaluate(final double[] values, final double mean) {
return evaluate(values, mean, 0, values.length);
public boolean isBiasCorrected() {
return isBiasCorrected;
public void setBiasCorrected(boolean isBiasCorrected) {
this.isBiasCorrected = isBiasCorrected;
package org.apache.commons.math.stat.descriptive.moment;
public class Kurtosis extends AbstractStorelessUnivariateStatistic  {
private static final long serialVersionUID = 2784465764798260919L;  
protected FourthMoment moment;
protected boolean incMoment;
public Kurtosis() {
incMoment = true;
moment = new FourthMoment();
public Kurtosis(final FourthMoment m4) {
incMoment = false;
this.moment = m4;
public void increment(final double d) {
if (incMoment) {
moment.increment(d);
throw new IllegalStateException
("Statistics constructed from external moments cannot be incremented");
public double getResult() {
double kurtosis = Double.NaN;
if (moment.getN() > 3) {
double variance = moment.m2 / (double) (moment.n - 1);
if (moment.n <= 3 || variance < 10E-20) {
kurtosis = 0.0;
double n = (double) moment.n;
kurtosis =
(n * (n + 1) * moment.m4 -
3 * moment.m2 * moment.m2 * (n - 1)) /
((n - 1) * (n -2) * (n -3) * variance * variance);
return kurtosis;
public void clear() {
if (incMoment) {
moment.clear();
throw new IllegalStateException
("Statistics constructed from external moments cannot be cleared");
public long getN() {
return moment.getN();
public double evaluate(final double[] values,final int begin, final int length) {
double kurt = Double.NaN;   
if (test(values, begin, length) && length > 3) {       
Variance variance = new Variance();
variance.incrementAll(values, begin, length);
double mean = variance.moment.m1;
double stdDev = Math.sqrt(variance.getResult());
double accum3 = 0.0;
for (int i = begin; i < begin + length; i++) {
accum3 += Math.pow((values[i] - mean), 4.0);
accum3 /= Math.pow(stdDev, 4.0d);
double n0 = length;
double coefficientOne =
(n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));
double termTwo =
((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));
kurt = (coefficientOne * accum3) - termTwo;
return kurt;
package org.apache.commons.math.stat.descriptive.moment;
public class GeometricMean extends AbstractStorelessUnivariateStatistic {
private static final long serialVersionUID = -8178734905303459453L;  
private SumOfLogs sumOfLogs;
public GeometricMean() {
sumOfLogs = new SumOfLogs();
public void increment(final double d) {
sumOfLogs.increment(d);
public double getResult() {
if (sumOfLogs.getN() > 0) {
return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());
return Double.NaN;
public void clear() {
sumOfLogs.clear();
public double evaluate(
final double[] values, final int begin, final int length) {
return Math.exp(
sumOfLogs.evaluate(values, begin, length) / (double) length);
public long getN() {
return sumOfLogs.getN();
package org.apache.commons.math.stat.descriptive.moment;
public class StandardDeviation extends AbstractStorelessUnivariateStatistic
implements Serializable {
private static final long serialVersionUID = 5728716329662425188L;  
private Variance variance = null;
public StandardDeviation() {
variance = new Variance();
public StandardDeviation(final SecondMoment m2) {
variance = new Variance(m2);
public StandardDeviation(boolean isBiasCorrected) {
variance = new Variance(isBiasCorrected);
public StandardDeviation(boolean isBiasCorrected, SecondMoment m2) {
variance = new Variance(isBiasCorrected, m2);
public void increment(final double d) {
variance.increment(d);
public long getN() {
return variance.getN();
public double getResult() {
return Math.sqrt(variance.getResult());
public void clear() {
variance.clear();
public double evaluate(final double[] values)  {
return Math.sqrt(variance.evaluate(values));
public double evaluate(final double[] values, final int begin, final int length)  {
return Math.sqrt(variance.evaluate(values, begin, length));
public double evaluate(final double[] values, final double mean,
final int begin, final int length)  {
return Math.sqrt(variance.evaluate(values, mean, begin, length));
public double evaluate(final double[] values, final double mean)  {
return Math.sqrt(variance.evaluate(values, mean));
public boolean isBiasCorrected() {
return variance.isBiasCorrected();
public void setBiasCorrected(boolean isBiasCorrected) {
variance.setBiasCorrected(isBiasCorrected);
package org.apache.commons.math.stat.descriptive.moment;
public class VectorialCovariance implements Serializable {
private static final long serialVersionUID = 4118372414238930270L;
private double[] sums;
private double[] productsSums;
private long n;
public VectorialCovariance(int dimension) {
sums         = new double[dimension];
productsSums = new double[dimension * (dimension + 1) / 2];
n            = 0;
public void increment(double[] v) throws DimensionMismatchException {
if (v.length != sums.length) {
throw new DimensionMismatchException(v.length, sums.length);
int k = 0;
for (int i = 0; i < v.length; ++i) {
sums[i] += v[i];
for (int j = 0; j <= i; ++j) {
productsSums[k++] += v[i] * v[j];
n++;
public RealMatrix getResult() {
int dimension = sums.length;
RealMatrixImpl result = new RealMatrixImpl(dimension, dimension);
if (n > 1) {
double[][] resultData = result.getDataRef();
double c = 1.0 / (n * (n - 1));
int k = 0;
for (int i = 0; i < dimension; ++i) {
for (int j = 0; j <= i; ++j) {
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);
resultData[i][j] = e;
resultData[j][i] = e;
return result;
public long getN() {
return n;
package org.apache.commons.math.stat.descriptive.moment;
public class ThirdMoment extends SecondMoment implements Serializable {
private static final long serialVersionUID = -7818711964045118679L;  
protected double m3;
protected double nDevSq;
public ThirdMoment() {
super();
m3 = Double.NaN;
nDevSq = Double.NaN;
public void increment(final double d) {
if (n < 1) {
m3 = m2 = m1 = 0.0;
double prevM2 = m2;
super.increment(d);
nDevSq = nDev * nDev;
double n0 = (double) n;
m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;
public double getResult() {
return m3;
public void clear() {
super.clear();
m3 = Double.NaN;
nDevSq = Double.NaN;
package org.apache.commons.math.stat.descriptive.moment;
public class FirstMoment extends AbstractStorelessUnivariateStatistic 
implements Serializable {
private static final long serialVersionUID = -803343206421984070L; 
protected long n;
protected double m1;
protected double dev;
protected double nDev;
public FirstMoment() {
n = 0;
m1 = Double.NaN;
dev = Double.NaN;
nDev = Double.NaN;
public void increment(final double d) {
if (n == 0) {
m1 = 0.0;
n++;
double n0 = (double) n;
dev = d - m1;
nDev = dev / n0;
m1 += nDev;
public void clear() {
m1 = Double.NaN;
n = 0;
dev = Double.NaN;
nDev = Double.NaN;
public double getResult() {
return m1;
public long getN() {
return n;
package org.apache.commons.math.stat.descriptive.moment;
public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = 7101857578996691352L;    
protected ThirdMoment moment = null;
protected boolean incMoment;
public Skewness() {
incMoment = true;
moment = new ThirdMoment();
public Skewness(final ThirdMoment m3) {
incMoment = false;
this.moment = m3;
public void increment(final double d) {
if (incMoment) {
moment.increment(d);
public double getResult() {
if (moment.n < 3) {
return Double.NaN;
double variance = moment.m2 / (double) (moment.n - 1);
if (variance < 10E-20) {
return 0.0d;
double n0 = (double) moment.getN();
return  (n0 * moment.m3) /
((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);
public long getN() {
return moment.getN();
public void clear() {
if (incMoment) {
moment.clear();
public double evaluate(final double[] values,final int begin, 
final int length) {
double skew = Double.NaN;
if (test(values, begin, length) && length > 2 ){
Mean mean = new Mean();
double m = mean.evaluate(values, begin, length);
double accum = 0.0;
double accum2 = 0.0;
for (int i = begin; i < begin + length; i++) {
accum += Math.pow((values[i] - m), 2.0);
accum2 += (values[i] - m);
double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / ((double) length))) /
(double) (length - 1));
double accum3 = 0.0;
for (int i = begin; i < begin + length; i++) {
accum3 += Math.pow(values[i] - m, 3.0d);
accum3 /= Math.pow(stdDev, 3.0d);
double n0 = length;
skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;
return skew;
package org.apache.commons.math.stat.descriptive.moment;
public class VectorialMean implements Serializable {
private static final long serialVersionUID = 8223009086481006892L;
private Mean[] means;
public VectorialMean(int dimension) {
means = new Mean[dimension];
for (int i = 0; i < dimension; ++i) {
means[i] = new Mean();
public void increment(double[] v) throws DimensionMismatchException {
if (v.length != means.length) {
throw new DimensionMismatchException(v.length, means.length);
for (int i = 0; i < v.length; ++i) {
means[i].increment(v[i]);
public double[] getResult() {
double[] result = new double[means.length];
for (int i = 0; i < result.length; ++i) {
result[i] = means[i].getResult();
return result;
public long getN() {
return (means.length == 0) ? 0 : means[0].getN();
package org.apache.commons.math.stat.descriptive;
public class StatisticalSummaryValues implements Serializable, 
StatisticalSummary {
private static final long serialVersionUID = -5108854841843722536L;
private final double mean;
private final double variance;
private final long n;
private final double max;
private final double min;
private final double sum;
public StatisticalSummaryValues(double mean, double variance, long n,
double max, double min, double sum) {
super();
this.mean = mean;
this.variance = variance;
this.n = n;
this.max = max;
this.min = min;
this.sum = sum;
public double getMax() {
return max;
public double getMean() {
return mean;
public double getMin() {
return min;
public long getN() {
return n;
public double getSum() {
return sum;
public double getStandardDeviation() {
return Math.sqrt(variance);
public double getVariance() {
return variance;
public boolean equals(Object object) {
if (object == this ) {
return true;
if (object instanceof StatisticalSummaryValues == false) {
return false;
StatisticalSummaryValues stat = (StatisticalSummaryValues) object;
return (MathUtils.equals(stat.getMax(), this.getMax()) && 
MathUtils.equals(stat.getMean(),this.getMean()) &&
MathUtils.equals(stat.getMin(),this.getMin()) &&
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
MathUtils.equals(stat.getVariance(),this.getVariance()));
public int hashCode() {
int result = 31 + MathUtils.hash(getMax());
result = result * 31 + MathUtils.hash(getMean());
result = result * 31 + MathUtils.hash(getMin());
result = result * 31 + MathUtils.hash(getN());
result = result * 31 + MathUtils.hash(getSum());
result = result * 31 + MathUtils.hash(getVariance());
return result;
package org.apache.commons.math.stat.descriptive;
public interface StatisticalSummary {
public abstract double getMean();
public abstract double getVariance();
public abstract double getStandardDeviation();
public abstract double getMax();
public abstract double getMin();
public abstract long getN();
public abstract double getSum();
package org.apache.commons.math.stat.descriptive;
public interface StorelessUnivariateStatistic extends UnivariateStatistic {
void increment(double d);
void incrementAll(double[] values);
void incrementAll(double[] values, int start, int length);
double getResult();
long getN();
void clear();
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
private static final long serialVersionUID = -1868088725461221010L;
protected int windowSize;
protected ResizableDoubleArray eDA;
public DescriptiveStatisticsImpl() {
this(INFINITE_WINDOW);
public DescriptiveStatisticsImpl(int window) {
super();
eDA = new ResizableDoubleArray();
setWindowSize(window);
public int getWindowSize() {
return windowSize;
public double[] getValues() {
double[] copiedArray = new double[eDA.getNumElements()];
System.arraycopy(
eDA.getElements(),
0,
copiedArray,
0,
eDA.getNumElements());
return copiedArray;
public double getElement(int index) {
return eDA.getElement(index);
public long getN() {
return eDA.getNumElements();
public void addValue(double v) {
if (windowSize != INFINITE_WINDOW) {
if (getN() == windowSize) {
eDA.addElementRolling(v);
eDA.addElement(v);
eDA.addElement(v);
public void clear() {
eDA.clear();
public void setWindowSize(int windowSize) {
if (windowSize < 1) {
if (windowSize != INFINITE_WINDOW) {
throw new IllegalArgumentException("window size must be positive.");
this.windowSize = windowSize;
if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {
eDA.discardFrontElements(eDA.getNumElements() - windowSize);
public double apply(UnivariateStatistic stat) {
return stat.evaluate(eDA.getValues(), eDA.start(), eDA.getNumElements());
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
private static final long serialVersionUID = 8787174276883311692L;
protected long n = 0;
protected SecondMoment secondMoment = null;
protected Sum sum = null;
protected SumOfSquares sumsq = null;
protected Min min = null;
protected Max max = null;
protected SumOfLogs sumLog = null;
protected GeometricMean geoMean = null;
protected Mean mean = null;
protected Variance variance = null;
public SummaryStatisticsImpl() {
sum = new Sum();
sumsq = new SumOfSquares();
min = new Min();
max = new Max();
sumLog = new SumOfLogs();
geoMean = new GeometricMean();
secondMoment = new SecondMoment();
public void addValue(double value) {
sum.increment(value);
sumsq.increment(value);
min.increment(value);
max.increment(value);
sumLog.increment(value);
geoMean.increment(value);
secondMoment.increment(value);
n++;
public long getN() {
return n;
public double getSum() {
return sum.getResult();
public double getSumsq() {
return sumsq.getResult();
public double getMean() {
return new Mean(secondMoment).getResult();
public double getStandardDeviation() {
double stdDev = Double.NaN;
if (getN() > 0) {
if (getN() > 1) {
stdDev = Math.sqrt(getVariance());
stdDev = 0.0;
return (stdDev);
public double getVariance() {
return new Variance(secondMoment).getResult();
public double getMax() {
return max.getResult();
public double getMin() {
return min.getResult();
public double getGeometricMean() {
return geoMean.getResult();
public String toString() {
StringBuffer outBuffer = new StringBuffer();
outBuffer.append("SummaryStatistics:\n");
outBuffer.append("n: " + getN() + "\n");
outBuffer.append("min: " + getMin() + "\n");
outBuffer.append("max: " + getMax() + "\n");
outBuffer.append("mean: " + getMean() + "\n");
outBuffer.append("geometric mean: " + getGeometricMean() + "\n");
outBuffer.append("variance: " + getVariance() + "\n");
outBuffer.append("sum of squares: " + getSumsq() + "\n");
outBuffer.append("standard deviation: " + getStandardDeviation() + "\n");
return outBuffer.toString();
public void clear() {
this.n = 0;
min.clear();
max.clear();
sum.clear();
sumLog.clear();
sumsq.clear();
geoMean.clear();
secondMoment.clear();
package org.apache.commons.math.stat.descriptive;
public interface UnivariateStatistic {
double evaluate(double[] values);
double evaluate(double[] values, int begin, int length);
package org.apache.commons.math.stat.descriptive.rank;
public class Percentile extends AbstractUnivariateStatistic implements Serializable {
private static final long serialVersionUID = -8091216485095130416L; 
private double quantile = 0.0;
public Percentile() {
this(50.0);
public Percentile(final double p) {
setQuantile(p);
public double evaluate(final double[] values, final double p) {
test(values, 0, 0);
return evaluate(values, 0, values.length, p);
public double evaluate( final double[] values, final int start, final int length) {
return evaluate(values, start, length, quantile);
public double evaluate(final double[] values, final int begin, 
final int length, final double p) {
test(values, begin, length);
if ((p > 100) || (p <= 0)) {
throw new IllegalArgumentException("invalid quantile value: " + p);
if (length == 0) {
return Double.NaN;
if (length == 1) {
return values[begin]; // always return single value for n = 1
double n = (double) length;
double pos = p * (n + 1) / 100;
double fpos = Math.floor(pos);
int intPos = (int) fpos;
double dif = pos - fpos;
double[] sorted = new double[length];
System.arraycopy(values, begin, sorted, 0, length);
Arrays.sort(sorted);
if (pos < 1) {
return sorted[0];
if (pos >= n) {
return sorted[length - 1];
double lower = sorted[intPos - 1];
double upper = sorted[intPos];
return lower + dif * (upper - lower);
public double getQuantile() {
return quantile;
public void setQuantile(final double p) {
if (p <= 0 || p > 100) {
throw new IllegalArgumentException("Illegal quantile value: " + p);
quantile = p;
package org.apache.commons.math.stat.descriptive.rank;
public class Max extends AbstractStorelessUnivariateStatistic {
private static final long serialVersionUID = -5593383832225844641L;    
private long n;
private double value;
public Max() {
n = 0;
value = Double.NaN;
public void increment(final double d) {
if (d > value || Double.isNaN(value)) {
value = d;
n++;
public void clear() {
value = Double.NaN;
n = 0;
public double getResult() {
return value;
public long getN() {
return n;
public double evaluate(final double[] values, final int begin, final int length) {
double max = Double.NaN;
if (test(values, begin, length)) {
max = values[begin];
for (int i = begin; i < begin + length; i++) {
if (!Double.isNaN(values[i])) {
max = (max > values[i]) ? max : values[i];
return max;
package org.apache.commons.math.stat.descriptive.rank;
public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = -2941995784909003131L;  
private long n;
private double value;
public Min() {
n = 0;
value = Double.NaN;
public void increment(final double d) {
if (d < value || Double.isNaN(value)) {
value = d;
n++;
public void clear() {
value = Double.NaN;
n = 0;
public double getResult() {
return value;
public long getN() {
return n;
public double evaluate(final double[] values,final int begin, final int length) {
double min = Double.NaN;
if (test(values, begin, length)) {
min = values[begin];
for (int i = begin; i < begin + length; i++) {
if (!Double.isNaN(values[i])) {
min = (min < values[i]) ? min : values[i];
return min;
package org.apache.commons.math.stat.descriptive.rank;
public class Median extends Percentile implements Serializable {
private static final long serialVersionUID = -3961477041290915687L;    
public Median() {
super(50.0);
package org.apache.commons.math.stat.descriptive.summary;
public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = 1460986908574398008L;  
private long n;
private double value;
public SumOfSquares() {
n = 0;
value = Double.NaN;
public void increment(final double d) {
if (n == 0) {
value = d * d;
value += d * d;
n++;
public double getResult() {
return value;
public long getN() {
return n;
public void clear() {
value = Double.NaN;
n = 0;
public double evaluate(final double[] values,final int begin, final int length) {
double sumSq = Double.NaN;
if (test(values, begin, length)) {
sumSq = 0.0;
for (int i = begin; i < begin + length; i++) {
sumSq += values[i] * values[i];
return sumSq;
package org.apache.commons.math.stat.descriptive.summary;
public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = 2824226005990582538L;   
private long n;
private double value;
public Product() {
n = 0;
value = Double.NaN;
public void increment(final double d) {
if (n == 0) {
value = d;
value *= d;
n++;
public double getResult() {
return value;
public long getN() {
return n;
public void clear() {
value = Double.NaN;
n = 0;
public double evaluate(final double[] values, final int begin, final int length) {
double product = Double.NaN;
if (test(values, begin, length)) {
product = 1.0;
for (int i = begin; i < begin + length; i++) {
product *= values[i];
return product;
package org.apache.commons.math.stat.descriptive.summary;
public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = -8231831954703408316L;  
private long n;
private double value;
public Sum() {
n = 0;
value = Double.NaN;
public void increment(final double d) {
if (n == 0) {
value = d;
value += d;
n++;
public double getResult() {
return value;
public long getN() {
return n;
public void clear() {
value = Double.NaN;
n = 0;
public double evaluate(final double[] values, final int begin, final int length) {
double sum = Double.NaN;
if (test(values, begin, length)) {
sum = 0.0;
for (int i = begin; i < begin + length; i++) {
sum += values[i];
return sum;
package org.apache.commons.math.stat.descriptive.summary;
public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {
private static final long serialVersionUID = -370076995648386763L;    
private int n;
private double value;
public SumOfLogs() {
value = 0d;
n = 0;
public void increment(final double d) {
value += Math.log(d);
n++;
public double getResult() {
if (n > 0) {
return value;
return Double.NaN;
public long getN() {
return n;
public void clear() {
value = 0d;
n = 0;
public double evaluate(final double[] values, final int begin, final int length) {
double sumLog = Double.NaN;
if (test(values, begin, length)) {
sumLog = 0.0;
for (int i = begin; i < begin + length; i++) {
sumLog += Math.log(values[i]);
return sumLog;
package org.apache.commons.math.stat.descriptive;
public abstract class AbstractStorelessUnivariateStatistic
extends AbstractUnivariateStatistic
implements StorelessUnivariateStatistic, Serializable {
private static final long serialVersionUID = -44915725420072521L;
public double evaluate(final double[] values) {
if (values == null) {
throw new IllegalArgumentException("input value array is null");
return evaluate(values, 0, values.length);
public double evaluate(final double[] values, final int begin, final int length) {
if (test(values, begin, length)) {
clear();
incrementAll(values, begin, length);
return getResult();
public abstract void clear();
public abstract double getResult();
public abstract void increment(final double d);
public void incrementAll(double[] values) {
if (values == null) {
throw new IllegalArgumentException("input values array is null");
incrementAll(values, 0, values.length);
public void incrementAll(double[] values, int begin, int length) {
if (test(values, begin, length)) {
int k = begin + length;
for (int i = begin; i < k; i++) {
increment(values[i]);
public boolean equals(Object object) {
if (object == this ) {
return true;
if (object instanceof AbstractStorelessUnivariateStatistic == false) {
return false;
AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;
return (MathUtils.equals(stat.getResult(), this.getResult()) && 
MathUtils.equals(stat.getN(), this.getN()));
public int hashCode() {
return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());
package org.apache.commons.math.stat.regression;
public class SimpleRegression implements Serializable {
private static final long serialVersionUID = -3004689053607543335L;
private TDistribution distribution;
private double sumX = 0d;
private double sumXX = 0d;
private double sumY = 0d;
private double sumYY = 0d;
private double sumXY = 0d;
private long n = 0;
private double xbar = 0;
private double ybar = 0;
public SimpleRegression() {
this(new TDistributionImpl(1.0));
public SimpleRegression(TDistribution t) {
super();
setDistribution(t);
public void addData(double x, double y) {
if (n == 0) {
xbar = x;
ybar = y;
double dx = x - xbar;
double dy = y - ybar;
sumXX += dx * dx * (double) n / (double) (n + 1.0);
sumYY += dy * dy * (double) n / (double) (n + 1.0);
sumXY += dx * dy * (double) n / (double) (n + 1.0);
xbar += dx / (double) (n + 1.0);
ybar += dy / (double) (n + 1.0);
sumX += x;
sumY += y;
n++;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
public void addData(double[][] data) {
for (int i = 0; i < data.length; i++) {
addData(data[i][0], data[i][1]);
public void clear() {
sumX = 0d;
sumXX = 0d;
sumY = 0d;
sumYY = 0d;
sumXY = 0d;
n = 0;
public long getN() {
return n;
public double predict(double x) {
double b1 = getSlope();
return getIntercept(b1) + b1 * x;
public double getIntercept() {
return getIntercept(getSlope());
public double getSlope() {
if (n < 2) {
return Double.NaN; //not enough data 
if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {
return Double.NaN; //not enough variation in x
return sumXY / sumXX;
public double getSumSquaredErrors() {
return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
public double getTotalSumSquares() {
if (n < 2) {
return Double.NaN;
return sumYY;
public double getRegressionSumSquares() {
return getRegressionSumSquares(getSlope());
public double getMeanSquareError() {
if (n < 3) {
return Double.NaN;
return getSumSquaredErrors() / (double) (n - 2);
public double getR() {
double b1 = getSlope();
double result = Math.sqrt(getRSquare());
if (b1 < 0) {
result = -result;
return result;
public double getRSquare() {
double ssto = getTotalSumSquares();
return (ssto - getSumSquaredErrors()) / ssto;
public double getInterceptStdErr() {
return Math.sqrt(
getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));
public double getSlopeStdErr() {
return Math.sqrt(getMeanSquareError() / sumXX);
public double getSlopeConfidenceInterval() throws MathException {
return getSlopeConfidenceInterval(0.05d);
public double getSlopeConfidenceInterval(double alpha)
throws MathException {
if (alpha >= 1 || alpha <= 0) {
throw new IllegalArgumentException();
return getSlopeStdErr() *
distribution.inverseCumulativeProbability(1d - alpha / 2d);
public double getSignificance() throws MathException {
return 2d * (1.0 - distribution.cumulativeProbability(
Math.abs(getSlope()) / getSlopeStdErr()));
private double getIntercept(double slope) {
return (sumY - slope * sumX) / ((double) n);
private double getRegressionSumSquares(double slope) {
return slope * slope * sumXX;
public void setDistribution(TDistribution value) {
distribution = value;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
package org.apache.commons.math.stat;
public class Frequency implements Serializable {
private static final long serialVersionUID = -3845586908418844111L;
private TreeMap freqTable = null;
public Frequency() {
freqTable = new TreeMap();
public Frequency(Comparator comparator) {
freqTable = new TreeMap(comparator);
public String toString() {
NumberFormat nf = NumberFormat.getPercentInstance();
StringBuffer outBuffer = new StringBuffer();
outBuffer.append("Value \t Freq. \t Pct. \t Cum Pct. \n");
Iterator iter = freqTable.keySet().iterator();
while (iter.hasNext()) {
Object value = iter.next();
outBuffer.append(value);
outBuffer.append('\t');
outBuffer.append(getCount(value));
outBuffer.append('\t');
outBuffer.append(nf.format(getPct(value)));
outBuffer.append('\t');
outBuffer.append(nf.format(getCumPct(value)));
outBuffer.append('\n');
return outBuffer.toString();
public void addValue(Object v) {
Object obj = v;
if (v instanceof Integer) {
obj = new Long(((Integer) v).longValue());
Long count = (Long) freqTable.get(obj);
if (count == null) {
freqTable.put(obj, new Long(1));
freqTable.put(obj, new Long(count.longValue() + 1));
throw new IllegalArgumentException("Value not comparable to existing values.");
public void addValue(int v) {
addValue(new Long(v));
public void addValue(Integer v) {
addValue(new Long(v.longValue()));
public void addValue(long v) {
addValue(new Long(v));
public void addValue(char v) {
addValue(new Character(v));
public void clear() {
freqTable.clear();
public Iterator valuesIterator() {
return freqTable.keySet().iterator();
public long getSumFreq() {
long result = 0;
Iterator iterator = freqTable.values().iterator();
while (iterator.hasNext())  {
result += ((Long) iterator.next()).longValue();
return result;
public long getCount(Object v) {
if (v instanceof Integer) {
return getCount(((Integer) v).longValue());
long result = 0;
Long count =  (Long) freqTable.get(v);
if (count != null) {
result = count.longValue();
return result;
public long getCount(int v) {
return getCount(new Long(v));
public long getCount(long v) {
return getCount(new Long(v));
public long getCount(char v) {
return getCount(new Character(v));
public double getPct(Object v) {
if (getSumFreq() == 0) {
return Double.NaN;
return (double) getCount(v) / (double) getSumFreq();        
public double getPct(int v) {
return getPct(new Long(v));       
public double getPct(long v) {
return getPct(new Long(v));         
public double getPct(char v) {
return getPct(new Character(v));         
public long getCumFreq(Object v) {
if (getSumFreq() == 0) {
return 0;
if (v instanceof Integer) {
return getCumFreq(((Integer) v).longValue());
Comparator c = freqTable.comparator();
if (c == null) {
c = new NaturalComparator();
long result = 0;
Long value = (Long) freqTable.get(v);
if (value != null) {
result = value.longValue();
return result;   // v is not comparable
if (c.compare(v, freqTable.firstKey()) < 0) {
return 0;  // v is comparable, but less than first value
if (c.compare(v, freqTable.lastKey()) >= 0) {
return getSumFreq();    // v is comparable, but greater than the last value
Iterator values = valuesIterator();
while (values.hasNext()) {
Object nextValue = values.next();
if (c.compare(v, nextValue) > 0) {
result += getCount(nextValue);
return result;
return result;
public long getCumFreq(int v) {
return getCumFreq(new Long(v));       
public long getCumFreq(long v) {
return getCumFreq(new Long(v));         
public long getCumFreq(char v) {
return getCumFreq(new Character(v));         
public double getCumPct(Object v) {
if (getSumFreq() == 0) {
return Double.NaN;
return (double) getCumFreq(v) / (double) getSumFreq();        
public double getCumPct(int v) {
return getCumPct(new Long(v));       
public double getCumPct(long v) {
return getCumPct(new Long(v));         
public double getCumPct(char v) {
return getCumPct(new Character(v));         
private static class NaturalComparator implements Comparator {
public int compare(Object o1, Object o2) {
return ((Comparable)o1).compareTo(o2);
package org.apache.commons.math.estimation;
public interface EstimationProblem {
public WeightedMeasurement[] getMeasurements();
public EstimatedParameter[] getUnboundParameters();
public EstimatedParameter[] getAllParameters();
package org.apache.commons.math.estimation;
public class EstimationException
extends MathException {
private static final long serialVersionUID = -7414806622114810487L;
public EstimationException(String specifier, String[] parts) {
super(specifier, parts);
public EstimationException(Throwable cause) {
super(cause);
package org.apache.commons.math.estimation;
public class GaussNewtonEstimator
implements Estimator, Serializable {
public GaussNewtonEstimator(int maxIterations,
double convergence,
double steadyStateThreshold) {
this.maxIterations        = maxIterations;
this.steadyStateThreshold = steadyStateThreshold;
this.convergence          = convergence;
public void estimate(EstimationProblem problem)
throws EstimationException {
int    iterations = 0;
double previous   = 0.0;
double current    = 0.0;
do {
if (++iterations > maxIterations) {
throw new EstimationException ("unable to converge in {0} iterations",
new String[] {
Integer.toString(maxIterations)
linearEstimate(problem);
previous = current;
current  = evaluateCriterion(problem);
|| (Math.abs(previous - current) > (current * steadyStateThreshold)
&& (Math.abs(current) > convergence)));
public void linearEstimate(EstimationProblem problem)
throws EstimationException {
EstimatedParameter[]  parameters   = problem.getUnboundParameters();
WeightedMeasurement[] measurements = problem.getMeasurements();
RealMatrix b              = new RealMatrixImpl(parameters.length, 1);
RealMatrix a              = new RealMatrixImpl(parameters.length, parameters.length);
double[] grad             = new double[parameters.length];
RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);
double[][] bDecrementData = bDecrement.getDataRef();
RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);
double[][] wggData        = wGradGradT.getDataRef();
for (int i = 0; i < measurements.length; ++i) {
if (! measurements [i].isIgnored()) {
double weight   = measurements[i].getWeight();
double residual = measurements[i].getResidual();
for (int j = 0; j < parameters.length; ++j) {
grad[j] = measurements[i].getPartial(parameters[j]);
bDecrementData[j][0] = weight * residual * grad[j];
for (int k = 0; k < parameters.length; ++k) {
double[] wggRow = wggData[k];
double gk = grad[k];
for (int l = 0; l < parameters.length; ++l) {
wggRow[l] =  weight * gk * grad[l];
a = a.add(wGradGradT);
b = b.add(bDecrement);
RealMatrix dX = a.solve(b);
for (int i = 0; i < parameters.length; ++i) {
parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));
throw new EstimationException(e);
private double evaluateCriterion(EstimationProblem problem) {
double criterion = 0.0;
WeightedMeasurement[] measurements = problem.getMeasurements();
for (int i = 0; i < measurements.length; ++i) {
double residual = measurements[i].getResidual();
criterion      += measurements[i].getWeight() * residual * residual;
return criterion;
public double getRMS(EstimationProblem problem) {
double criterion = evaluateCriterion(problem);
int n = problem.getMeasurements().length;
return Math.sqrt(criterion / n);
private int    maxIterations;
private double steadyStateThreshold;
private double convergence;
private static final long serialVersionUID = -7606628156644194170L;
package org.apache.commons.math.estimation;
public abstract class WeightedMeasurement implements Serializable {
public WeightedMeasurement(double weight, double measuredValue) {
this.weight        = weight;
this.measuredValue = measuredValue;
ignored            = false;
public WeightedMeasurement(double weight, double measuredValue,
boolean ignored) {
this.weight        = weight;
this.measuredValue = measuredValue;
this.ignored       = ignored;
public double getWeight() {
return weight;
public double getMeasuredValue() {
return measuredValue;
public double getResidual() {
return measuredValue - getTheoreticalValue();
public abstract double getTheoreticalValue();
public abstract double getPartial(EstimatedParameter parameter);
public void setIgnored(boolean ignored) {
this.ignored = ignored;
public boolean isIgnored() {
return ignored;
private final double  weight;
private final double  measuredValue;
private       boolean ignored;
package org.apache.commons.math.estimation;
public class SimpleEstimationProblem implements EstimationProblem {
public SimpleEstimationProblem() {
parameters   = new ArrayList();
measurements = new ArrayList();
public EstimatedParameter[] getAllParameters() {
return (EstimatedParameter[]) parameters.toArray(new EstimatedParameter[parameters.size()]);
public EstimatedParameter[] getUnboundParameters() {
ArrayList unbound = new ArrayList(parameters.size());
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
if (! p.isBound()) {
unbound.add(p);
return (EstimatedParameter[]) unbound.toArray(new EstimatedParameter[unbound.size()]);
public WeightedMeasurement[] getMeasurements() {
return (WeightedMeasurement[]) measurements.toArray(new WeightedMeasurement[measurements.size()]);
protected void addParameter(EstimatedParameter p) {
parameters.add(p);
protected void addMeasurement(WeightedMeasurement m) {
measurements.add(m);
private ArrayList parameters;
private ArrayList measurements;
package org.apache.commons.math.estimation;
public class EstimatedParameter
implements Serializable {
public EstimatedParameter(String name, double firstEstimate) {
this.name = name;
estimate  = firstEstimate;
bound     = false;
public EstimatedParameter(String name,
double firstEstimate,
boolean bound) {
this.name  = name;
estimate   = firstEstimate;
this.bound = bound;
public EstimatedParameter(EstimatedParameter parameter) {
name     = parameter.name;
estimate = parameter.estimate;
bound    = parameter.bound;
public void setEstimate(double estimate) {
this.estimate = estimate;
public double getEstimate() {
return estimate;
public String getName() {
return name;
public void setBound(boolean bound) {
this.bound = bound;
public boolean isBound() {
return bound;
private   String  name;
protected double  estimate;
private   boolean bound;
private static final long serialVersionUID = -555440800213416949L;
package org.apache.commons.math.estimation;
public interface Estimator {
public void estimate(EstimationProblem problem)
throws EstimationException;
public double getRMS(EstimationProblem problem);
package org.apache.commons.math.estimation;
public class LevenbergMarquardtEstimator implements Serializable, Estimator {
public LevenbergMarquardtEstimator() {
setInitialStepBoundFactor(100.0);
setMaxCostEval(1000);
setCostRelativeTolerance(1.0e-10);
setParRelativeTolerance(1.0e-10);
setOrthoTolerance(1.0e-10);
public void setInitialStepBoundFactor(double initialStepBoundFactor) {
this.initialStepBoundFactor = initialStepBoundFactor;
public void setMaxCostEval(int maxCostEval) {
this.maxCostEval = maxCostEval;
public void setCostRelativeTolerance(double costRelativeTolerance) {
this.costRelativeTolerance = costRelativeTolerance;
public void setParRelativeTolerance(double parRelativeTolerance) {
this.parRelativeTolerance = parRelativeTolerance;
public void setOrthoTolerance(double orthoTolerance) {
this.orthoTolerance = orthoTolerance;
public int getCostEvaluations() {
return costEvaluations;
public int getJacobianEvaluations() {
return jacobianEvaluations;
private void updateJacobian() {
++jacobianEvaluations;
Arrays.fill(jacobian, 0);
for (int i = 0, index = 0; i < rows; i++) {
WeightedMeasurement wm = measurements[i];
double factor = -Math.sqrt(wm.getWeight());
for (int j = 0; j < cols; ++j) {
jacobian[index++] = factor * wm.getPartial(parameters[j]);
private void updateResidualsAndCost() {
++costEvaluations;
cost = 0;
for (int i = 0, index = 0; i < rows; i++, index += cols) {
WeightedMeasurement wm = measurements[i];
double residual = wm.getResidual();
residuals[i] = Math.sqrt(wm.getWeight()) * residual;
cost += wm.getWeight() * residual * residual;
cost = Math.sqrt(cost);
public double getRMS(EstimationProblem problem) {
WeightedMeasurement[] wm = problem.getMeasurements();
double criterion = 0;
for (int i = 0; i < wm.length; ++i) {
double residual = wm[i].getResidual();
criterion += wm[i].getWeight() * residual * residual;
return Math.sqrt(criterion / wm.length);
public void estimate(EstimationProblem problem)
throws EstimationException {
measurements = problem.getMeasurements();
parameters   = problem.getUnboundParameters();
rows        = measurements.length;
cols        = parameters.length;
solvedCols  = Math.min(rows, cols);
jacobian    = new double[rows * cols];
diagR       = new double[cols];
jacNorm     = new double[cols];
beta        = new double[cols];
permutation = new int[cols];
lmDir       = new double[cols];
residuals   = new double[rows];
double   delta   = 0, xNorm = 0;
double[] diag    = new double[cols];
double[] oldX    = new double[cols];
double[] oldRes  = new double[rows];
double[] work1   = new double[cols];
double[] work2   = new double[cols];
double[] work3   = new double[cols];
updateResidualsAndCost();
lmPar               = 0;
costEvaluations     = 0;
jacobianEvaluations = 0;
boolean firstIteration = true;
while (costEvaluations < maxCostEval) {
updateJacobian();
qrDecomposition();
qTy(residuals);
for (int k = 0; k < solvedCols; ++k) {
int pk = permutation[k];
jacobian[k * cols + pk] = diagR[pk];
if (firstIteration) {
xNorm = 0;
for (int k = 0; k < cols; ++k) {
double dk = jacNorm[k];
if (dk == 0) {
dk = 1.0;
double xk = dk * parameters[k].getEstimate();
xNorm  += xk * xk;
diag[k] = dk;
xNorm = Math.sqrt(xNorm);
delta = (xNorm == 0)
? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
double maxCosine = 0;
if (cost != 0) {
for (int j = 0; j < solvedCols; ++j) {
int    pj = permutation[j];
double s  = jacNorm[pj];
if (s != 0) {
double sum = 0;
for (int i = 0, index = pj; i <= j; ++i, index += cols) {
sum += jacobian[index] * residuals[i];
maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
if (maxCosine <= orthoTolerance) {
return;
for (int j = 0; j < cols; ++j) {
diag[j] = Math.max(diag[j], jacNorm[j]);
for (double ratio = 0; ratio < 1.0e-4;) {
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
oldX[pj] = parameters[pj].getEstimate();
double previousCost = cost;
double[] tmpVec = residuals;
residuals = oldRes;
oldRes    = tmpVec;
determineLMParameter(oldRes, delta, diag, work1, work2, work3);
double lmNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
lmDir[pj] = -lmDir[pj];
parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);
double s = diag[pj] * lmDir[pj];
lmNorm  += s * s;
lmNorm = Math.sqrt(lmNorm);
if (firstIteration) {
delta = Math.min(delta, lmNorm);
updateResidualsAndCost();
double actRed = -1.0;
if (0.1 * cost < previousCost) {
double r = cost / previousCost;
actRed = 1.0 - r * r;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double dirJ = lmDir[pj];
work1[j] = 0;
for (int i = 0, index = pj; i <= j; ++i, index += cols) {
work1[i] += jacobian[index] * dirJ;
double coeff1 = 0;
for (int j = 0; j < solvedCols; ++j) {
coeff1 += work1[j] * work1[j];
double pc2 = previousCost * previousCost;
coeff1 = coeff1 / pc2;
double coeff2 = lmPar * lmNorm * lmNorm / pc2;
double preRed = coeff1 + 2 * coeff2;
double dirDer = -(coeff1 + coeff2);
ratio = (preRed == 0) ? 0 : (actRed / preRed);
if (ratio <= 0.25) {
double tmp =
(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
tmp = 0.1;
delta = tmp * Math.min(delta, 10.0 * lmNorm);
lmPar /= tmp;
delta = 2 * lmNorm;
lmPar *= 0.5;
if (ratio >= 1.0e-4) {
firstIteration = false;
xNorm = 0;
for (int k = 0; k < cols; ++k) {
double xK = diag[k] * parameters[k].getEstimate();
xNorm    += xK * xK;
xNorm = Math.sqrt(xNorm);
cost = previousCost;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
parameters[pj].setEstimate(oldX[pj]);
tmpVec    = residuals;
residuals = oldRes;
oldRes    = tmpVec;
if (((Math.abs(actRed) <= costRelativeTolerance)
&& (preRed <= costRelativeTolerance)
&& (ratio <= 2.0))
|| (delta <= parRelativeTolerance * xNorm)) {
return;
if (costEvaluations >= maxCostEval) {
break;
if ((Math.abs(actRed) <= 2.2204e-16)
&& (preRed <= 2.2204e-16)
&& (ratio <= 2.0)) {
throw new EstimationException("cost relative tolerance is too small ({0}),"
+ " no further reduction in the"
+ " sum of squares is possible",
new String[] {
Double.toString(costRelativeTolerance)
throw new EstimationException("parameters relative tolerance is too small"
+ " ({0}), no further improvement in"
+ " the approximate solution is possible",
new String[] {
Double.toString(parRelativeTolerance)
throw new EstimationException("orthogonality tolerance is too small ({0}),"
+ " solution is orthogonal to the jacobian",
new String[] {
Double.toString(orthoTolerance)
throw new EstimationException("maximal number of evaluations exceeded ({0})",
new String[] {
Integer.toString(maxCostEval)
private void determineLMParameter(double[] qy, double delta, double[] diag,
double[] work1, double[] work2, double[] work3) {
for (int j = 0; j < rank; ++j) {
lmDir[permutation[j]] = qy[j];
for (int j = rank; j < cols; ++j) {
lmDir[permutation[j]] = 0;
for (int k = rank - 1; k >= 0; --k) {
int pk = permutation[k];
double ypk = lmDir[pk] / diagR[pk];
for (int i = 0, index = pk; i < k; ++i, index += cols) {
lmDir[permutation[i]] -= ypk * jacobian[index];
lmDir[pk] = ypk;
double dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work1[pj] = s;
dxNorm += s * s;
dxNorm = Math.sqrt(dxNorm);
double fp = dxNorm - delta;
if (fp <= 0.1 * delta) {
lmPar = 0;
return;
double sum2, parl = 0;
if (rank == solvedCols) {
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] *= diag[pj] / dxNorm; 
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0, index = pj; i < j; ++i, index += cols) {
sum += jacobian[index] * work1[permutation[i]];
double s = (work1[pj] - sum) / diagR[pj];
work1[pj] = s;
sum2 += s * s;
parl = fp / (delta * sum2);
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0, index = pj; i <= j; ++i, index += cols) {
sum += jacobian[index] * qy[i];
sum /= diag[pj];
sum2 += sum * sum;
double gNorm = Math.sqrt(sum2);
double paru = gNorm / delta;
if (paru == 0) {
paru = 2.2251e-308 / Math.min(delta, 0.1);
lmPar = Math.min(paru, Math.max(lmPar, parl));
if (lmPar == 0) {
lmPar = gNorm / dxNorm;
for (int countdown = 10; countdown >= 0; --countdown) {
if (lmPar == 0) {
lmPar = Math.max(2.2251e-308, 0.001 * paru);
double sPar = Math.sqrt(lmPar);
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = sPar * diag[pj];
determineLMDirection(qy, work1, work2, work3);
dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work3[pj] = s;
dxNorm += s * s;
dxNorm = Math.sqrt(dxNorm);
double previousFP = fp;
fp = dxNorm - delta;
if ((Math.abs(fp) <= 0.1 * delta)
|| ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
return;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = work3[pj] * diag[pj] / dxNorm; 
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] /= work2[j];
double tmp = work1[pj];
for (int i = j + 1; i < solvedCols; ++i) {
work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
double s = work1[permutation[j]];
sum2 += s * s;
double correction = fp / (delta * sum2);
if (fp > 0) {
parl = Math.max(parl, lmPar);
paru = Math.min(paru, lmPar);
lmPar = Math.max(parl, lmPar + correction);
private void determineLMDirection(double[] qy, double[] diag,
double[] lmDiag, double[] work) {
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
for (int i = j + 1; i < solvedCols; ++i) {
jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];
lmDir[j] = diagR[pj];
work[j]  = qy[j];
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double dpj = diag[pj];
if (dpj != 0) {
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);
lmDiag[j] = dpj;
double qtbpj = 0;
for (int k = j; k < solvedCols; ++k) {
int pk = permutation[k];
if (lmDiag[k] != 0) {
double sin, cos;
double rkk = jacobian[k * cols + pk];
if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
double cotan = rkk / lmDiag[k];
sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);
cos   = sin * cotan;
double tan = lmDiag[k] / rkk;
cos = 1.0 / Math.sqrt(1.0 + tan * tan);
sin = cos * tan;
jacobian[k * cols + pk] = cos * rkk + sin * lmDiag[k];
double temp = cos * work[k] + sin * qtbpj;
qtbpj = -sin * work[k] + cos * qtbpj;
work[k] = temp;
for (int i = k + 1; i < solvedCols; ++i) {
double rik = jacobian[i * cols + pk];
temp = cos * rik + sin * lmDiag[i];
lmDiag[i] = -sin * rik + cos * lmDiag[i];
jacobian[i * cols + pk] = temp;
int index = j * cols + permutation[j];
lmDiag[j]       = jacobian[index];
jacobian[index] = lmDir[j];
int nSing = solvedCols;
for (int j = 0; j < solvedCols; ++j) {
if ((lmDiag[j] == 0) && (nSing == solvedCols)) {
nSing = j;
if (nSing < solvedCols) {
work[j] = 0;
if (nSing > 0) {
for (int j = nSing - 1; j >= 0; --j) {
int pj = permutation[j];
double sum = 0;
for (int i = j + 1; i < nSing; ++i) {
sum += jacobian[i * cols + pj] * work[i];
work[j] = (work[j] - sum) / lmDiag[j];
for (int j = 0; j < lmDir.length; ++j) {
lmDir[permutation[j]] = work[j];
private void qrDecomposition() {
for (int k = 0; k < cols; ++k) {
permutation[k] = k;
double norm2 = 0;
for (int index = k; index < jacobian.length; index += cols) {
double akk = jacobian[index];
norm2 += akk * akk;
jacNorm[k] = Math.sqrt(norm2);
for (int k = 0; k < cols; ++k) {
int nextColumn = -1;
double ak2 = Double.NEGATIVE_INFINITY;
for (int i = k; i < cols; ++i) {
double norm2 = 0;
int iDiag = k * cols + permutation[i];
for (int index = iDiag; index < jacobian.length; index += cols) {
double aki = jacobian[index];
norm2 += aki * aki;
if (norm2 > ak2) {
nextColumn = i;
ak2        = norm2;
if (ak2 == 0) {
rank = k;
return;
int pk                  = permutation[nextColumn];
permutation[nextColumn] = permutation[k];
permutation[k]          = pk;
int    kDiag = k * cols + pk;
double akk   = jacobian[kDiag];
double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);
double betak = 1.0 / (ak2 - akk * alpha);
beta[pk]     = betak;
diagR[pk]        = alpha;
jacobian[kDiag] -= alpha;
for (int dk = cols - 1 - k; dk > 0; --dk) {
int dkp = permutation[k + dk] - pk;
double gamma = 0;
for (int index = kDiag; index < jacobian.length; index += cols) {
gamma += jacobian[index] * jacobian[index + dkp];
gamma *= betak;
for (int index = kDiag; index < jacobian.length; index += cols) {
jacobian[index + dkp] -= gamma * jacobian[index];
rank = solvedCols;
private void qTy(double[] y) {
for (int k = 0; k < cols; ++k) {
int pk = permutation[k];
int kDiag = k * cols + pk;
double gamma = 0;
for (int i = k, index = kDiag; i < rows; ++i, index += cols) {
gamma += jacobian[index] * y[i];
gamma *= beta[pk];
for (int i = k, index = kDiag; i < rows; ++i, index += cols) {
y[i] -= gamma * jacobian[index];
private WeightedMeasurement[] measurements;
private EstimatedParameter[] parameters;
private double[] jacobian;
private int cols;
private int solvedCols;
private int rows;
private double[] diagR;
private double[] jacNorm;
private double[] beta;
private int[] permutation;
private int rank;
private double lmPar;
private double[] lmDir;
private double[] residuals;
private double cost;
private double initialStepBoundFactor;
private int maxCostEval;
private int costEvaluations;
private int jacobianEvaluations;
private double costRelativeTolerance;
private double parRelativeTolerance;
private double orthoTolerance;
private static final long serialVersionUID = 5387476316105068340L;
package org.apache.commons.math;
public class FunctionEvaluationException extends MathException  {
private static final long serialVersionUID = -7619974756160279127L;
private double argument = Double.NaN;
public FunctionEvaluationException(double argument) {
super("Evaluation failed for argument = {0}",
new Object[] { new Double(argument) });
this.argument = argument;
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String pattern, Object[] arguments) {
super(pattern, arguments);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
public FunctionEvaluationException(double argument, Throwable cause) {
super(cause);
this.argument = argument;
public FunctionEvaluationException(double argument,
String pattern, Object[] arguments,
Throwable cause) {
super(pattern, arguments, cause);
this.argument = argument;
public double getArgument() {
return this.argument;
package org.apache.commons.math;
public class DimensionMismatchException extends MathException {
private static final long serialVersionUID = -1316089546353786411L;
public DimensionMismatchException(int dimension1, int dimension2) {
super("dimension mismatch {0} != {1}",
new Object[] {
new Integer(dimension1), new Integer(dimension2)
this.dimension1 = dimension1;
this.dimension2 = dimension2;
public int getDimension1() {
return dimension1;
public int getDimension2() {
return dimension2;
private int dimension1;
private int dimension2;
package org.apache.commons.math.geometry;
public final class RotationOrder {
private RotationOrder(String name,
Vector3D a1, Vector3D a2, Vector3D a3) {
this.name = name;
this.a1   = a1;
this.a2   = a2;
this.a3   = a3;
public String toString() {
return name;
public Vector3D getA1() {
return a1;
public Vector3D getA2() {
return a2;
public Vector3D getA3() {
return a3;
public static final RotationOrder XYZ =
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
public static final RotationOrder XZY =
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
public static final RotationOrder YXZ =
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
public static final RotationOrder YZX =
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
public static final RotationOrder ZXY =
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
public static final RotationOrder ZYX =
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
public static final RotationOrder XYX =
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
public static final RotationOrder XZX =
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
public static final RotationOrder YXY =
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
public static final RotationOrder YZY =
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
public static final RotationOrder ZXZ =
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
public static final RotationOrder ZYZ =
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
private final String name;
private final Vector3D a1;
private final Vector3D a2;
private final Vector3D a3;
package org.apache.commons.math.geometry;
public class Rotation implements Serializable {
public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
public Rotation(double q0, double q1, double q2, double q3,
boolean needsNormalization) {
if (needsNormalization) {
double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
q0 *= inv;
q1 *= inv;
q2 *= inv;
q3 *= inv;
this.q0 = q0;
this.q1 = q1;
this.q2 = q2;
this.q3 = q3;
public Rotation(Vector3D axis, double angle) {
double norm = axis.getNorm();
if (norm == 0) {
throw new ArithmeticException("null norm");
double halfAngle = -0.5 * angle;
double coeff = Math.sin(halfAngle) / norm;
q0 = Math.cos (halfAngle);
q1 = coeff * axis.getX();
q2 = coeff * axis.getY();
q3 = coeff * axis.getZ();
public Rotation(double[][] m, double threshold)
throws NotARotationMatrixException {
if ((m.length != 3) || (m[0].length != 3)
|| (m[1].length != 3) || (m[2].length != 3)) {
throw new NotARotationMatrixException("a {0}x{1} matrix"
+ " cannot be a rotation matrix",
new String[] {
Integer.toString(m.length),
Integer.toString(m[0].length)
double[][] ort = orthogonalizeMatrix(m, threshold);
double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2])
- ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2])
+ ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
if (det < 0.0) {
throw new NotARotationMatrixException("the closest orthogonal matrix"
+ " has a negative determinant {0}",
new String[] {
Double.toString(det)
double s = ort[0][0] + ort[1][1] + ort[2][2];
if (s > -0.19) {
q0 = 0.5 * Math.sqrt(s + 1.0);
double inv = 0.25 / q0;
q1 = inv * (ort[1][2] - ort[2][1]);
q2 = inv * (ort[2][0] - ort[0][2]);
q3 = inv * (ort[0][1] - ort[1][0]);
s = ort[0][0] - ort[1][1] - ort[2][2];
if (s > -0.19) {
q1 = 0.5 * Math.sqrt(s + 1.0);
double inv = 0.25 / q1;
q0 = inv * (ort[1][2] - ort[2][1]);
q2 = inv * (ort[0][1] + ort[1][0]);
q3 = inv * (ort[0][2] + ort[2][0]);
s = ort[1][1] - ort[0][0] - ort[2][2];
if (s > -0.19) {
q2 = 0.5 * Math.sqrt(s + 1.0);
double inv = 0.25 / q2;
q0 = inv * (ort[2][0] - ort[0][2]);
q1 = inv * (ort[0][1] + ort[1][0]);
q3 = inv * (ort[2][1] + ort[1][2]);
s = ort[2][2] - ort[0][0] - ort[1][1];
q3 = 0.5 * Math.sqrt(s + 1.0);
double inv = 0.25 / q3;
q0 = inv * (ort[0][1] - ort[1][0]);
q1 = inv * (ort[0][2] + ort[2][0]);
q2 = inv * (ort[2][1] + ort[1][2]);
public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
double u1u1 = Vector3D.dotProduct(u1, u1);
double u2u2 = Vector3D.dotProduct(u2, u2);
double v1v1 = Vector3D.dotProduct(v1, v1);
double v2v2 = Vector3D.dotProduct(v2, v2);
if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)
|| (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))
throw new ArithmeticException("null norm");
double u1x = u1.getX();
double u1y = u1.getY();
double u1z = u1.getZ();
double u2x = u2.getX();
double u2y = u2.getY();
double u2z = u2.getZ();
double coeff = Math.sqrt (u1u1 / v1v1);
double v1x   = coeff * v1.getX();
double v1y   = coeff * v1.getY();
double v1z   = coeff * v1.getZ();
v1 = new Vector3D(v1x, v1y, v1z);
double u1u2   = Vector3D.dotProduct(u1, u2);
double v1v2   = Vector3D.dotProduct(v1, v2);
double coeffU = u1u2 / u1u1;
double coeffV = v1v2 / u1u1;
double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
double alpha  = coeffU - beta * coeffV;
double v2x    = alpha * v1x + beta * v2.getX();
double v2y    = alpha * v1y + beta * v2.getY();
double v2z    = alpha * v1z + beta * v2.getZ();
v2 = new Vector3D(v2x, v2y, v2z);
Vector3D uRef = u1;
Vector3D vRef = v1;
double dx1 = v1x - u1.getX();
double dy1 = v1y - u1.getY();
double dz1 = v1z - u1.getZ();
double dx2 = v2x - u2.getX();
double dy2 = v2y - u2.getY();
double dz2 = v2z - u2.getZ();
Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,
dz1 * dx2 - dx1 * dz2,
dx1 * dy2 - dy1 * dx2);
double c = k.getX() * (u1y * u2z - u1z * u2y)
+ k.getY() * (u1z * u2x - u1x * u2z)
+ k.getZ() * (u1x * u2y - u1y * u2x);
if (c < (1.0e-10 * u1u1 * u2u2)) {
Vector3D u3 = Vector3D.crossProduct(u1, u2);
Vector3D v3 = Vector3D.crossProduct(v1, v2);
double u3x  = u3.getX();
double u3y  = u3.getY();
double u3z  = u3.getZ();
double v3x  = v3.getX();
double v3y  = v3.getY();
double v3z  = v3.getZ();
double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;
double dx3 = v3x - u3x;
double dy3 = v3y - u3y;
double dz3 = v3z - u3z;
k = new Vector3D(dy1 * dz3 - dz1 * dy3,
dz1 * dx3 - dx1 * dz3,
dx1 * dy3 - dy1 * dx3);
c = k.getX() * (u1y * u3z - u1z * u3y)
+ k.getY() * (u1z * u3x - u1x * u3z)
+ k.getZ() * (u1x * u3y - u1y * u3x);
if (c < (1.0e-10 * u1u1 * u3u3)) {
k = new Vector3D(dy2 * dz3 - dz2 * dy3,
dz2 * dx3 - dx2 * dz3,
dx2 * dy3 - dy2 * dx3);
c = k.getX() * (u2y * u3z - u2z * u3y)
+ k.getY() * (u2z * u3x - u2x * u3z)
+ k.getZ() * (u2x * u3y - u2y * u3x);
if (c < (1.0e-10 * u2u2 * u3u3)) {
q0 = 1.0;
q1 = 0.0;
q2 = 0.0;
q3 = 0.0;
return;
uRef = u2;
vRef = v2;
c = Math.sqrt(c);
double inv = 1.0 / (c + c);
q1 = inv * k.getX();
q2 = inv * k.getY();
q3 = inv * k.getZ();
k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
uRef.getZ() * q1 - uRef.getX() * q3,
uRef.getX() * q2 - uRef.getY() * q1);
c = Vector3D.dotProduct(k, k);
q0 = Vector3D.dotProduct(vRef, k) / (c + c);
public Rotation(Vector3D u, Vector3D v) {
double normProduct = u.getNorm() * v.getNorm();
if (normProduct < 1.0e-15) {
throw new ArithmeticException("null norm");
double dot = Vector3D.dotProduct(u, v);
if (dot < ((2.0e-15 - 1.0) * normProduct)) {
Vector3D w = u.orthogonal();
q0 = 0.0;
q1 = -w.getX();
q2 = -w.getY();
q3 = -w.getZ();
q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));
double coeff = 1.0 / (2.0 * q0 * normProduct);
q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());
q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());
q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());
public Rotation(RotationOrder order,
double alpha1, double alpha2, double alpha3) {
Rotation r1 = new Rotation(order.getA1(), alpha1);
Rotation r2 = new Rotation(order.getA2(), alpha2);
Rotation r3 = new Rotation(order.getA3(), alpha3);
Rotation composed = r1.applyTo(r2.applyTo(r3));
q0 = composed.q0;
q1 = composed.q1;
q2 = composed.q2;
q3 = composed.q3;
public Rotation revert() {
return new Rotation(-q0, q1, q2, q3, false);
public double getQ0() {
return q0;
public double getQ1() {
return q1;
public double getQ2() {
return q2;
public double getQ3() {
return q3;
public Vector3D getAxis() {
double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;
if (squaredSine < 1.0e-12) {
return new Vector3D(1, 0, 0);
double inverse = 1 / Math.sqrt(squaredSine);
return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
double inverse = -1 / Math.sqrt(squaredSine);
return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
public double getAngle() {
if ((q0 < -0.1) || (q0 > 0.1)) {
return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
return 2 * Math.acos(-q0);
return 2 * Math.acos(q0);
public double[] getAngles(RotationOrder order)
throws CardanEulerSingularityException {
if (order == RotationOrder.XYZ) {
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(-(v1.getY()), v1.getZ()),
Math.asin(v2.getZ()),
Math.atan2(-(v2.getY()), v2.getX())
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(v1.getZ(), v1.getY()),
-Math.asin(v2.getY()),
Math.atan2(v2.getZ(), v2.getX())
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(v1.getX(), v1.getZ()),
-Math.asin(v2.getZ()),
Math.atan2(v2.getX(), v2.getY())
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(-(v1.getZ()), v1.getX()),
Math.asin(v2.getX()),
Math.atan2(-(v2.getZ()), v2.getY())
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(-(v1.getX()), v1.getY()),
Math.asin(v2.getY()),
Math.atan2(-(v2.getX()), v2.getZ())
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
throw new CardanEulerSingularityException(true);
return new double[] {
Math.atan2(v1.getY(), v1.getX()),
-Math.asin(v2.getX()),
Math.atan2(v2.getY(), v2.getZ())
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getY(), -v1.getZ()),
Math.acos(v2.getX()),
Math.atan2(v2.getY(), v2.getZ())
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getZ(), v1.getY()),
Math.acos(v2.getX()),
Math.atan2(v2.getZ(), -v2.getY())
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getX(), v1.getZ()),
Math.acos(v2.getY()),
Math.atan2(v2.getX(), -v2.getZ())
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getZ(), -v1.getX()),
Math.acos(v2.getY()),
Math.atan2(v2.getZ(), v2.getX())
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getX(), -v1.getY()),
Math.acos(v2.getZ()),
Math.atan2(v2.getX(), v2.getY())
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
throw new CardanEulerSingularityException(false);
return new double[] {
Math.atan2(v1.getY(), v1.getX()),
Math.acos(v2.getZ()),
Math.atan2(v2.getY(), -v2.getX())
public double[][] getMatrix() {
double q0q0  = q0 * q0;
double q0q1  = q0 * q1;
double q0q2  = q0 * q2;
double q0q3  = q0 * q3;
double q1q1  = q1 * q1;
double q1q2  = q1 * q2;
double q1q3  = q1 * q3;
double q2q2  = q2 * q2;
double q2q3  = q2 * q3;
double q3q3  = q3 * q3;
double[][] m = new double[3][];
m[0] = new double[3];
m[1] = new double[3];
m[2] = new double[3];
m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;
m [1][0] = 2.0 * (q1q2 - q0q3);
m [2][0] = 2.0 * (q1q3 + q0q2);
m [0][1] = 2.0 * (q1q2 + q0q3);
m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;
m [2][1] = 2.0 * (q2q3 - q0q1);
m [0][2] = 2.0 * (q1q3 - q0q2);
m [1][2] = 2.0 * (q2q3 + q0q1);
m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;
return m;
public Vector3D applyTo(Vector3D u) {
double x = u.getX();
double y = u.getY();
double z = u.getZ();
double s = q1 * x + q2 * y + q3 * z;
return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,
2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);
public Vector3D applyInverseTo(Vector3D u) {
double x = u.getX();
double y = u.getY();
double z = u.getZ();
double s = q1 * x + q2 * y + q3 * z;
double m0 = -q0;
return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,
2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);
public Rotation applyTo(Rotation r) {
return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),
r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),
r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),
r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),
false);
public Rotation applyInverseTo(Rotation r) {
return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),
-r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),
-r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),
-r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),
false);
private double[][] orthogonalizeMatrix(double[][] m, double threshold)
throws NotARotationMatrixException {
double x00 = m[0][0];
double x01 = m[0][1];
double x02 = m[0][2];
double x10 = m[1][0];
double x11 = m[1][1];
double x12 = m[1][2];
double x20 = m[2][0];
double x21 = m[2][1];
double x22 = m[2][2];
double fn = 0;
double fn1;
double[][] o = new double[3][];
o[0] = new double[3];
o[1] = new double[3];
o[2] = new double[3];
int i = 0;
while (++i < 11) {
double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;
double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;
double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;
double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;
double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;
double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;
double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;
double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;
double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;
o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);
o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);
o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);
o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);
o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);
o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);
o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);
o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);
o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);
double corr00 = o[0][0] - m[0][0];
double corr01 = o[0][1] - m[0][1];
double corr02 = o[0][2] - m[0][2];
double corr10 = o[1][0] - m[1][0];
double corr11 = o[1][1] - m[1][1];
double corr12 = o[1][2] - m[1][2];
double corr20 = o[2][0] - m[2][0];
double corr21 = o[2][1] - m[2][1];
double corr22 = o[2][2] - m[2][2];
fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02
+ corr10 * corr10 + corr11 * corr11 + corr12 * corr12
+ corr20 * corr20 + corr21 * corr21 + corr22 * corr22;
if (Math.abs(fn1 - fn) <= threshold)
return o;
x00 = o[0][0];
x01 = o[0][1];
x02 = o[0][2];
x10 = o[1][0];
x11 = o[1][1];
x12 = o[1][2];
x20 = o[2][0];
x21 = o[2][1];
x22 = o[2][2];
fn  = fn1;
throw new NotARotationMatrixException("unable to orthogonalize matrix"
+ " in {0} iterations",
new String[] {
Integer.toString(i - 1)
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private static final long serialVersionUID = 5127795878493115119L;
package org.apache.commons.math.geometry;
public class CardanEulerSingularityException
extends MathException {
public CardanEulerSingularityException(boolean isCardan) {
super(isCardan ? "Cardan angles singularity" : "Euler angles singularity", new Object[0]);
private static final long serialVersionUID = -1360952845582206770L;
package org.apache.commons.math.geometry;
public class NotARotationMatrixException
extends MathException {
public NotARotationMatrixException(String specifier, String[] parts) {
super(specifier, parts);
private static final long serialVersionUID = 5647178478658937642L;
package org.apache.commons.math.geometry;
public class Vector3D
implements Serializable {
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
public Vector3D(double x, double y, double z) {
this.x = x;
this.y = y;
this.z = z;
public Vector3D(double alpha, double delta) {
double cosDelta = Math.cos(delta);
this.x = Math.cos(alpha) * cosDelta;
this.y = Math.sin(alpha) * cosDelta;
this.z = Math.sin(delta);
public Vector3D(double a, Vector3D u) {
this.x = a * u.x;
this.y = a * u.y;
this.z = a * u.z;
public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {
this.x = a1 * u1.x + a2 * u2.x;
this.y = a1 * u1.y + a2 * u2.y;
this.z = a1 * u1.z + a2 * u2.z;
public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
double a3, Vector3D u3) {
this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;
this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;
this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;
public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
double a3, Vector3D u3, double a4, Vector3D u4) {
this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;
this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;
this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;
public double getX() {
return x;
public double getY() {
return y;
public double getZ() {
return z;
public double getNorm() {
return Math.sqrt (x * x + y * y + z * z);
public double getAlpha() {
return Math.atan2(y, x);
public double getDelta() {
return Math.asin(z / getNorm());
public Vector3D add(Vector3D v) {
return new Vector3D(x + v.x, y + v.y, z + v.z);
public Vector3D add(double factor, Vector3D v) {
return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);
public Vector3D subtract(Vector3D v) {
return new Vector3D(x - v.x, y - v.y, z - v.z);
public Vector3D subtract(double factor, Vector3D v) {
return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);
public Vector3D normalize() {
double s = getNorm();
if (s == 0) {
throw new ArithmeticException("null norm");
return multiply(1 / s);
public Vector3D orthogonal() {
double threshold = 0.6 * getNorm();
if (threshold == 0) {
throw new ArithmeticException("null norm");
if ((x >= -threshold) && (x <= threshold)) {
double inverse  = 1 / Math.sqrt(y * y + z * z);
return new Vector3D(0, inverse * z, -inverse * y);
double inverse  = 1 / Math.sqrt(x * x + z * z);
return new Vector3D(-inverse * z, 0, inverse * x);
double inverse  = 1 / Math.sqrt(x * x + y * y);
return new Vector3D(inverse * y, -inverse * x, 0);
public static double angle(Vector3D v1, Vector3D v2) {
double normProduct = v1.getNorm() * v2.getNorm();
if (normProduct == 0) {
throw new ArithmeticException("null norm");
double dot = dotProduct(v1, v2);
double threshold = normProduct * 0.9999;
if ((dot < -threshold) || (dot > threshold)) {
Vector3D v3 = crossProduct(v1, v2);
if (dot >= 0) {
return Math.asin(v3.getNorm() / normProduct);
return Math.PI - Math.asin(v3.getNorm() / normProduct);
return Math.acos(dot / normProduct);
public Vector3D negate() {
return new Vector3D(-x, -y, -z);
public Vector3D multiply(double a) {
return new Vector3D(a * x, a * y, a * z);
public static double dotProduct(Vector3D v1, Vector3D v2) {
return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
return new Vector3D(v1.y * v2.z - v1.z * v2.y,
v1.z * v2.x - v1.x * v2.z,
v1.x * v2.y - v1.y * v2.x);
private final double x;
private final double y;
private final double z;
private static final long serialVersionUID = 7318440192750283659L;
package org.apache.commons.math.random;
public interface NormalizedRandomGenerator {
public double nextNormalizedDouble();
package org.apache.commons.math.random;
public class GaussianRandomGenerator implements NormalizedRandomGenerator {
public GaussianRandomGenerator(RandomGenerator generator) {
this.generator = generator;
public double nextNormalizedDouble() {
return generator.nextGaussian();
private RandomGenerator generator;
package org.apache.commons.math.random;
public interface RandomGenerator {
void setSeed(long seed);
void nextBytes(byte[] bytes);
int nextInt();
int nextInt(int n);
long nextLong();
boolean nextBoolean();
float nextFloat();
double nextDouble();
double nextGaussian();
package org.apache.commons.math.random;
public class CorrelatedRandomVectorGenerator
implements RandomVectorGenerator {
public CorrelatedRandomVectorGenerator(double[] mean,
RealMatrix covariance, double small,
NormalizedRandomGenerator generator)
throws NotPositiveDefiniteMatrixException, DimensionMismatchException {
int order = covariance.getRowDimension();
if (mean.length != order) {
throw new DimensionMismatchException(mean.length, order);
this.mean = (double[]) mean.clone();
decompose(covariance, small);
this.generator = generator;
normalized = new double[rank];
public CorrelatedRandomVectorGenerator(RealMatrix covariance, double small,
NormalizedRandomGenerator generator)
throws NotPositiveDefiniteMatrixException {
int order = covariance.getRowDimension();
mean = new double[order];
for (int i = 0; i < order; ++i) {
mean[i] = 0;
decompose(covariance, small);
this.generator = generator;
normalized = new double[rank];
public NormalizedRandomGenerator getGenerator() {
return generator;
public RealMatrix getRootMatrix() {
return root;
public int getRank() {
return rank;
private void decompose(RealMatrix covariance, double small)
throws NotPositiveDefiniteMatrixException {
int order = covariance.getRowDimension();
double[][] c = covariance.getData();
double[][] b = new double[order][order];
int[] swap  = new int[order];
int[] index = new int[order];
for (int i = 0; i < order; ++i) {
index[i] = i;
rank = 0;
for (boolean loop = true; loop;) {
swap[rank] = rank;
for (int i = rank + 1; i < order; ++i) {
int ii  = index[i];
int isi = index[swap[i]];
if (c[ii][ii] > c[isi][isi]) {
swap[rank] = i;
if (swap[rank] != rank) {
int tmp = index[rank];
index[rank] = index[swap[rank]];
index[swap[rank]] = tmp;
int ir = index[rank];
if (c[ir][ir] < small) {
if (rank == 0) {
throw new NotPositiveDefiniteMatrixException();
for (int i = rank; i < order; ++i) {
if (c[index[i]][index[i]] < -small) {
throw new NotPositiveDefiniteMatrixException();
++rank;
loop = false;
double sqrt = Math.sqrt(c[ir][ir]);
b[rank][rank] = sqrt;
double inverse = 1 / sqrt;
for (int i = rank + 1; i < order; ++i) {
int ii = index[i];
double e = inverse * c[ii][ir];
b[i][rank] = e;
c[ii][ii] -= e * e;
for (int j = rank + 1; j < i; ++j) {
int ij = index[j];
double f = c[ii][ij] - e * b[j][rank];
c[ii][ij] = f;
c[ij][ii] = f;
loop = ++rank < order;
root = new RealMatrixImpl(order, rank);
for (int i = 0; i < order; ++i) {
System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);
public double[] nextVector() {
for (int i = 0; i < rank; ++i) {
normalized[i] = generator.nextNormalizedDouble();
double[] correlated = new double[mean.length];
for (int i = 0; i < correlated.length; ++i) {
correlated[i] = mean[i];
for (int j = 0; j < rank; ++j) {
correlated[i] += root.getEntry(i, j) * normalized[j];
return correlated;
private double[] mean;
private RealMatrixImpl root;
private int rank;
private NormalizedRandomGenerator generator;
private double[] normalized;
package org.apache.commons.math.random;
public class UniformRandomGenerator implements NormalizedRandomGenerator {
public UniformRandomGenerator(RandomGenerator generator) {
this.generator = generator;
public double nextNormalizedDouble() {
return SQRT3 * (2 * generator.nextDouble() - 1.0);
private RandomGenerator generator;
private static final double SQRT3 = Math.sqrt(3.0);
package org.apache.commons.math.random;
public class UncorrelatedRandomVectorGenerator
implements RandomVectorGenerator {
public UncorrelatedRandomVectorGenerator(double[] mean,
double[] standardDeviation,
NormalizedRandomGenerator generator) {
if (mean.length != standardDeviation.length) {
throw new IllegalArgumentException("dimension mismatch");
this.mean              = (double[]) mean.clone();
this.standardDeviation = (double[]) standardDeviation.clone();
this.generator = generator;
public UncorrelatedRandomVectorGenerator(int dimension,
NormalizedRandomGenerator generator) {
mean              = new double[dimension];
standardDeviation = new double[dimension];
Arrays.fill(standardDeviation, 1.0);
this.generator = generator;
public double[] nextVector() {
double[] random = new double[mean.length]; 
for (int i = 0; i < random.length; ++i) {
random[i] = mean[i] + standardDeviation[i] * generator.nextNormalizedDouble();
return random;
private double[] mean;
private double[] standardDeviation;
private NormalizedRandomGenerator generator;
package org.apache.commons.math.random;
public class ValueServer {
private int mode = 5;
private URL valuesFileURL = null;
private double mu = 0.0;
private double sigma = 0.0;
private EmpiricalDistribution empiricalDistribution = null;
private BufferedReader filePointer = null;
private RandomData randomData = new RandomDataImpl();
public static final int DIGEST_MODE = 0;
public static final int REPLAY_MODE = 1;
public static final int UNIFORM_MODE = 2;
public static final int EXPONENTIAL_MODE = 3;
public static final int GAUSSIAN_MODE = 4;
public static final int CONSTANT_MODE = 5;
public ValueServer() {
public double getNext() throws IOException {
switch (mode) {
case DIGEST_MODE: return getNextDigest();
case REPLAY_MODE: return getNextReplay();
case UNIFORM_MODE: return getNextUniform();
case EXPONENTIAL_MODE: return getNextExponential();
case GAUSSIAN_MODE: return getNextGaussian();
case CONSTANT_MODE: return mu;
default: throw new IllegalStateException
("Bad mode: " + mode);
public void fill(double[] values) throws IOException {
for (int i = 0; i < values.length; i++) {
values[i] = getNext();
public double[] fill(int length) throws IOException {
double[] out = new double[length];
for (int i = 0; i < length; i++) {
out[i] = getNext();
return out;
public void computeDistribution() throws IOException {
empiricalDistribution = new EmpiricalDistributionImpl();
empiricalDistribution.load(valuesFileURL);
public void computeDistribution(int binCount)
throws IOException {
empiricalDistribution = new EmpiricalDistributionImpl(binCount);
empiricalDistribution.load(valuesFileURL);
mu = empiricalDistribution.getSampleStats().getMean();
sigma = empiricalDistribution.getSampleStats().getStandardDeviation();
public int getMode() {
return mode;
public void setMode(int mode) {
this.mode = mode;
public URL getValuesFileURL() {
return valuesFileURL;
public void setValuesFileURL(String url) throws MalformedURLException {
this.valuesFileURL = new URL(url);
public void setValuesFileURL(URL url) {
this.valuesFileURL = url;
public EmpiricalDistribution getEmpiricalDistribution() {
return empiricalDistribution;
public void resetReplayFile() throws IOException {
if (filePointer != null) {
filePointer.close();
filePointer = null;
filePointer = new BufferedReader(new InputStreamReader(valuesFileURL.openStream()));
public void closeReplayFile() throws IOException {
if (filePointer != null) {
filePointer.close();
filePointer = null;
public double getMu() {
return mu;
public void setMu(double mu) {
this.mu = mu;
public double getSigma() {
return sigma;
public void setSigma(double sigma) {
this.sigma = sigma;
private double getNextDigest() {
if ((empiricalDistribution == null) ||
(empiricalDistribution.getBinStats().size() == 0)) {
throw new IllegalStateException("Digest not initialized");
return empiricalDistribution.getNextValue();
private double getNextReplay() throws IOException {
String str = null;
if (filePointer == null) {
resetReplayFile();
if ((str = filePointer.readLine()) == null) {
closeReplayFile();
resetReplayFile();
str = filePointer.readLine();
return Double.valueOf(str).doubleValue();
private double getNextUniform() {
return randomData.nextUniform(0, 2 * mu);
private double getNextExponential() {
return randomData.nextExponential(mu);
private double getNextGaussian() {
return randomData.nextGaussian(mu, sigma);
public ValueServer(RandomData randomData) {
super();
this.randomData = randomData;
package org.apache.commons.math.random;
public interface RandomData {
String nextHexString(int len);
int nextInt(int lower, int upper);
long nextLong(long lower, long upper);
String nextSecureHexString(int len);
int nextSecureInt(int lower, int upper);
long nextSecureLong(long lower, long upper);
long nextPoisson(double mean);
double nextGaussian(double mu, double sigma);
double nextExponential(double mean);
double nextUniform(double lower, double upper);
int[] nextPermutation(int n, int k);
Object[] nextSample(Collection c, int k);
package org.apache.commons.math.random;
public interface RandomVectorGenerator {
public double[] nextVector();
package org.apache.commons.math.random;
public abstract class AbstractRandomGenerator implements RandomGenerator {
private double cachedNormalDeviate = Double.NaN;
public AbstractRandomGenerator() {
super();
public void clear() {
cachedNormalDeviate = Double.NaN;
public abstract void setSeed(long seed);  
public void nextBytes(byte[] bytes) {
int bytesOut = 0;
while (bytesOut < bytes.length) {
int randInt = nextInt();
for (int i = 0; i < 3; i++) {
if ( i > 0) {
randInt = randInt >> 8;
bytes[bytesOut++] = (byte) randInt;
if (bytesOut == bytes.length) {
return;
public int nextInt() {
return (int) (nextDouble() * Integer.MAX_VALUE);
public int nextInt(int n) {
if (n <= 0 ) {
throw new IllegalArgumentException("upper bound must be positive");
int result = (int) (nextDouble() * n);
return result < n ? result : n - 1;
public long nextLong() {
return (long) (nextDouble() * Long.MAX_VALUE);
public boolean nextBoolean() {
return nextDouble() <= 0.5;
public float nextFloat() {
return (float) nextDouble();
public abstract double nextDouble();  
public double nextGaussian() {
if (!Double.isNaN(cachedNormalDeviate)) {
double dev = cachedNormalDeviate;
cachedNormalDeviate = Double.NaN;
return dev;
double v1 = 0;
double v2 = 0;
double s = 1;
while (s >=1 ) { 
v1 = 2 * nextDouble() - 1; 
v2 = 2 * nextDouble() - 1; 
s = v1 * v1 + v2 * v2;
if (s != 0) {
s = Math.sqrt(-2 * Math.log(s) / s);   
cachedNormalDeviate = v2 * s;
return v1 * s;      
package org.apache.commons.math.random;
public class JDKRandomGenerator extends Random implements RandomGenerator {
private static final long serialVersionUID = -3561898582944940550L;
package org.apache.commons.math.random;
public class RandomAdaptor extends Random implements RandomGenerator {
private static final long serialVersionUID = 2570805822599485047L;
private RandomGenerator randomGenerator = null;
private RandomAdaptor() { }
public RandomAdaptor(RandomGenerator randomGenerator) {
this.randomGenerator = randomGenerator;
public static Random createAdaptor(RandomGenerator randomGenerator) {
return new RandomAdaptor(randomGenerator);
public boolean nextBoolean() {
return randomGenerator.nextBoolean();
public void nextBytes(byte[] bytes) {
randomGenerator.nextBytes(bytes);
public double nextDouble() {
return randomGenerator.nextDouble();
public float nextFloat() {
return randomGenerator.nextFloat();
public double nextGaussian() {
return randomGenerator.nextGaussian();
public int nextInt() {
return randomGenerator.nextInt();
public int nextInt(int n) {
return randomGenerator.nextInt(n);
public long nextLong() {
return randomGenerator.nextLong();
public void setSeed(long seed) {
if (randomGenerator != null) {  // required to avoid NPE in constructor
randomGenerator.setSeed(seed);
package org.apache.commons.math.random;
public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {
private static final long serialVersionUID = -6773236347582113490L;
private ArrayList binStats = null;
private SummaryStatistics sampleStats = null;
private int binCount = 1000;
private boolean loaded = false;
private double[] upperBounds = null;
private RandomData randomData = new RandomDataImpl();
public EmpiricalDistributionImpl() {
binStats = new ArrayList();
public EmpiricalDistributionImpl(int binCount) {
this.binCount = binCount;
binStats = new ArrayList();
public void load(double[] in) {
DataAdapter da = new ArrayDataAdapter(in);
da.computeStats();
fillBinStats(in);
throw new RuntimeException(e.getMessage());
loaded = true;
public void load(URL url) throws IOException {
BufferedReader in =
new BufferedReader(new InputStreamReader(url.openStream()));
DataAdapter da = new StreamDataAdapter(in);
da.computeStats();
throw new IOException(e.getMessage());
in = new BufferedReader(new InputStreamReader(url.openStream()));
fillBinStats(in);
loaded = true;
if (in != null) {
in.close();
public void load(File file) throws IOException {
BufferedReader in = new BufferedReader(new FileReader(file));
DataAdapter da = new StreamDataAdapter(in);
da.computeStats();
throw new IOException(e.getMessage());
in = new BufferedReader(new FileReader(file));
fillBinStats(in);
loaded = true;
if (in != null) {
in.close();
private abstract class DataAdapter{
public abstract void computeBinStats(double min, double delta)
throws Exception;
public abstract void computeStats() throws Exception;
private class DataAdapterFactory{
public DataAdapter getAdapter(Object in) {
if (in instanceof BufferedReader) {
BufferedReader inputStream = (BufferedReader) in;
return new StreamDataAdapter(inputStream);
double[] inputArray = (double[]) in;
return new ArrayDataAdapter(inputArray);
throw new IllegalArgumentException(
"Input data comes from the" + " unsupported source");
private class StreamDataAdapter extends DataAdapter{
private BufferedReader inputStream;
public StreamDataAdapter(BufferedReader in){
super();
inputStream = in;
public void computeBinStats(double min, double delta)
throws IOException {
String str = null;
double val = 0.0d;
while ((str = inputStream.readLine()) != null) {
val = Double.parseDouble(str);
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
stats.addValue(val);
inputStream.close();
inputStream = null;
public void computeStats() throws IOException {
String str = null;
double val = 0.0;
sampleStats = SummaryStatistics.newInstance();
while ((str = inputStream.readLine()) != null) {
val = new Double(str).doubleValue();
sampleStats.addValue(val);
inputStream.close();
inputStream = null;
private class ArrayDataAdapter extends DataAdapter{
private double[] inputArray;
public ArrayDataAdapter(double[] in){
super();
inputArray = in;
public void computeStats() throws IOException {
sampleStats = SummaryStatistics.newInstance();
for (int i = 0; i < inputArray.length; i++) {
sampleStats.addValue(inputArray[i]);
public void computeBinStats(double min, double delta)
throws IOException {
for (int i = 0; i < inputArray.length; i++) {
SummaryStatistics stats =
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
stats.addValue(inputArray[i]);
private void fillBinStats(Object in) throws IOException {
double min = sampleStats.getMin();
double max = sampleStats.getMax();
double delta = (max - min)/(new Double(binCount)).doubleValue();
double[] binUpperBounds = new double[binCount];
binUpperBounds[0] = min + delta;
for (int i = 1; i< binCount - 1; i++) {
binUpperBounds[i] = binUpperBounds[i-1] + delta;
binUpperBounds[binCount -1] = max;
if (!binStats.isEmpty()) {
binStats.clear();
for (int i = 0; i < binCount; i++) {
SummaryStatistics stats = SummaryStatistics.newInstance();
binStats.add(i,stats);
DataAdapterFactory aFactory = new DataAdapterFactory();
DataAdapter da = aFactory.getAdapter(in);
da.computeBinStats(min, delta);
if(e instanceof RuntimeException){
throw new RuntimeException(e.getMessage());
throw new IOException(e.getMessage());
upperBounds = new double[binCount];
upperBounds[0] =
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
for (int i = 1; i < binCount-1; i++) {
upperBounds[i] = upperBounds[i-1] +
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
upperBounds[binCount-1] = 1.0d;
private int findBin(double min, double value, double delta) {
return Math.min(
Math.max((int) Math.ceil((value- min) / delta) - 1, 0), 
binCount - 1);
public double getNextValue() throws IllegalStateException {
if (!loaded) {
throw new IllegalStateException("distribution not loaded");
double x = Math.random();
for (int i = 0; i < binCount; i++) {
if (x <= upperBounds[i]) {
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
if (stats.getN() > 0) {
if (stats.getStandardDeviation() > 0) {  // more than one obs
return randomData.nextGaussian
(stats.getMean(),stats.getStandardDeviation());
return stats.getMean(); // only one obs in bin
throw new RuntimeException("No bin selected");
public StatisticalSummary getSampleStats() {
return sampleStats;
public int getBinCount() {
return binCount;
public List getBinStats() {
return binStats;
Bins are: <br/>
public double[] getUpperBounds() {
int len = upperBounds.length;
double[] out = new double[len];
System.arraycopy(upperBounds, 0, out, 0, len);
return out;
public boolean isLoaded() {
return loaded;
package org.apache.commons.math.random;
public class RandomDataImpl implements RandomData, Serializable {
private static final long serialVersionUID = -626730818244969716L;
private RandomGenerator rand = null;
private SecureRandom secRand = null;
public RandomDataImpl() {
public RandomDataImpl(RandomGenerator rand) {
super();
this.rand = rand;
public String nextHexString(int len) {
if (len <= 0) {
throw new IllegalArgumentException("length must be positive");
RandomGenerator ran = getRan();
StringBuffer outBuffer = new StringBuffer();
byte[] randomBytes = new byte[(len / 2) + 1];
ran.nextBytes(randomBytes);
for (int i = 0; i < randomBytes.length; i++) {
Integer c = new Integer(randomBytes[i]);
String hex = Integer.toHexString(c.intValue() + 128);
if (hex.length() == 1)  {
hex = "0" + hex;
outBuffer.append(hex);
return outBuffer.toString().substring(0, len);
public int nextInt(int lower, int upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("upper bound must be > lower bound");
RandomGenerator rand = getRan();
double r = rand.nextDouble();
return (int)((r * upper) + ((1.0 - r) * lower) + r);
public long nextLong(long lower, long upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("upper bound must be > lower bound");
RandomGenerator rand = getRan();
double r = rand.nextDouble();
return (long)((r * upper) + ((1.0 - r) * lower) + r);
public String nextSecureHexString(int len) {
if (len <= 0) {
throw new IllegalArgumentException("length must be positive");
SecureRandom secRan = getSecRan();
MessageDigest alg = null;
alg = MessageDigest.getInstance("SHA-1");
return null; // gulp FIXME? -- this *should* never fail.
alg.reset();
int numIter = (len / 40) + 1;
StringBuffer outBuffer = new StringBuffer();
for (int iter = 1; iter < numIter + 1; iter++) {
byte[] randomBytes = new byte[40];
secRan.nextBytes(randomBytes);
alg.update(randomBytes);
byte hash[] = alg.digest();
for (int i = 0; i < hash.length; i++) {
Integer c = new Integer(hash[i]);
String hex = Integer.toHexString(c.intValue() + 128);
if (hex.length() == 1) {
hex = "0" + hex;
outBuffer.append(hex);
return outBuffer.toString().substring(0, len);
public int nextSecureInt(int lower, int upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("lower bound must be < upper bound");
SecureRandom sec = getSecRan();
return lower + (int) (sec.nextDouble() * (upper - lower + 1));
public long nextSecureLong(long lower, long upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("lower bound must be < upper bound");
SecureRandom sec = getSecRan();
return lower + (long) (sec.nextDouble() * (upper - lower + 1));
public long nextPoisson(double mean) {
if (mean <= 0) {
throw new IllegalArgumentException("Poisson mean must be > 0");
double p = Math.exp(-mean);
long n = 0;
double r = 1.0d;
double rnd = 1.0d;
RandomGenerator rand = getRan();
while (n < 1000 * mean) {
rnd = rand.nextDouble();
r = r * rnd;
if (r >= p) {
n++;
return n;
return n;
public double nextGaussian(double mu, double sigma) {
if (sigma <= 0) {
throw new IllegalArgumentException("Gaussian std dev must be > 0");
RandomGenerator rand = getRan();
return sigma * rand.nextGaussian() + mu;
public double nextExponential(double mean)  {
if (mean < 0.0)  {
throw new IllegalArgumentException
("Exponential mean must be >= 0");
RandomGenerator rand = getRan();
double unif = rand.nextDouble();
while (unif == 0.0d) {
unif = rand.nextDouble();
return -mean * Math.log(unif);
public double nextUniform(double lower, double upper) {
if (lower >= upper) {
throw new IllegalArgumentException
("lower bound must be < upper bound");
RandomGenerator rand = getRan();
double u = rand.nextDouble();
while(u <= 0.0){
u = rand.nextDouble();
return lower + u * (upper - lower);
private RandomGenerator getRan() {
if (rand == null) {
rand = new JDKRandomGenerator();
rand.setSeed(System.currentTimeMillis());
return rand;
private SecureRandom getSecRan() {
if (secRand == null) {
secRand = new SecureRandom();
secRand.setSeed(System.currentTimeMillis());
return secRand;
public void reSeed(long seed) {
if (rand == null) {
rand = new JDKRandomGenerator();
rand.setSeed(seed);
public void reSeedSecure() {
if (secRand == null) {
secRand = new SecureRandom();
secRand.setSeed(System.currentTimeMillis());
public void reSeedSecure(long seed) {
if (secRand == null) {
secRand = new SecureRandom();
secRand.setSeed(seed);
public void reSeed() {
if (rand == null) {
rand = new JDKRandomGenerator();
rand.setSeed(System.currentTimeMillis());
public void setSecureAlgorithm(String algorithm, String provider)
throws NoSuchAlgorithmException, NoSuchProviderException {
secRand = SecureRandom.getInstance(algorithm, provider);
public int[] nextPermutation(int n, int k) {
if (k > n) {
throw new IllegalArgumentException
("permutation k exceeds n");
if (k == 0) {
throw new IllegalArgumentException
("permutation k must be > 0");
int[] index = getNatural(n);
shuffle(index, n - k);
int[] result = new int[k];
for (int i = 0; i < k; i++) {
result[i] = index[n - i - 1];
return result;
public Object[] nextSample(Collection c, int k) {
int len = c.size();
if (k > len) {
throw new IllegalArgumentException
("sample size exceeds collection size");
if (k == 0) {
throw new IllegalArgumentException
("sample size must be > 0");
Object[] objects = c.toArray();
int[] index = nextPermutation(len, k);
Object[] result = new Object[k];
for (int i = 0; i < k; i++) {
result[i] = objects[index[i]];
return result;
private void shuffle(int[] list, int end) {
int target = 0;
for (int i = list.length - 1 ; i >= end; i--) {
if (i == 0) {
target = 0;
target = nextInt(0, i);
int temp = list[target];
list[target] = list[i];
list[i] = temp;
private int[] getNatural(int n) {
int[] natural = new int[n];
for (int i = 0; i < n; i++) {
natural[i] = i;
return natural;
package org.apache.commons.math.random;
public interface EmpiricalDistribution {
void load(double[] dataArray);
void load(File file) throws IOException;
void load(URL url) throws IOException;
double getNextValue() throws IllegalStateException;
StatisticalSummary getSampleStats() throws IllegalStateException;
boolean isLoaded();
int getBinCount();
List getBinStats();
double[] getUpperBounds();
package org.apache.commons.math.random;
public class NotPositiveDefiniteMatrixException extends MathException {
private static final long serialVersionUID = 4122929125438624648L;
public NotPositiveDefiniteMatrixException() {
super("not positive definite matrix", new Object[0]);
package org.apache.commons.math.fraction;
public class Fraction extends Number implements Comparable {
public static final Fraction ONE = new Fraction(1, 1);
public static final Fraction ZERO = new Fraction(0, 1);
private static final long serialVersionUID = 6222990762865980424L;
private int denominator;
private int numerator;
public Fraction(double value) throws FractionConversionException {
this(value, 1.0e-5, 100);
public Fraction(double value, double epsilon, int maxIterations)
throws FractionConversionException
double r0 = value;
int a0 = (int)Math.floor(r0);
if (Math.abs(a0 - value) < epsilon) {
this.numerator = a0;
this.denominator = 1;
return;
int p0 = 1;
int q0 = 0;
int p1 = a0;
int q1 = 1;
int p2 = 0;
int q2 = 1;
int n = 0;
boolean stop = false;
do {
++n;
double r1 = 1.0 / (r0 - a0);
int a1 = (int)Math.floor(r1);
p2 = (a1 * p1) + p0;
q2 = (a1 * q1) + q0;
double convergent = (double)p2 / (double)q2;
if (n < maxIterations && Math.abs(convergent - value) > epsilon) {
p0 = p1;
p1 = p2;
q0 = q1;
q1 = q2;
a0 = a1;
r0 = r1;
stop = true;
if (n >= maxIterations) {
throw new FractionConversionException(value, maxIterations);
this.numerator = p2;
this.denominator = q2;
reduce();
public Fraction(int num, int den) {
super();
if (den == 0) {
throw new ArithmeticException("The denominator must not be zero");
if (den < 0) {
if (num == Integer.MIN_VALUE ||
den == Integer.MIN_VALUE) {
throw new ArithmeticException("overflow: can't negate");
num = -num;
den = -den;
this.numerator = num;
this.denominator = den;
reduce();
public Fraction abs() {
Fraction ret;
if (numerator >= 0) {
ret = this;
ret = negate();
return ret;        
public int compareTo(Object object) {
int ret = 0;
if (this != object) { 
Fraction other = (Fraction)object;
double first = doubleValue();
double second = other.doubleValue();
if (first < second) {
ret = -1;
ret = 1;
return ret;
public double doubleValue() {
return (double)numerator / (double)denominator;
public boolean equals(Object other) {
boolean ret;
if (this == other) { 
ret = true;
ret = false;
Fraction rhs = (Fraction)other;
ret = (numerator == rhs.numerator) &&
(denominator == rhs.denominator);
ret = false;
return ret;
public float floatValue() {
return (float)doubleValue();
public int getDenominator() {
return denominator;
public int getNumerator() {
return numerator;
public int hashCode() {
return 37 * (37 * 17 + getNumerator()) + getDenominator();
public int intValue() {
return (int)doubleValue();
public long longValue() {
return (long)doubleValue();
public Fraction negate() {
if (numerator==Integer.MIN_VALUE) {
throw new ArithmeticException("overflow: too large to negate");
return new Fraction(-numerator, denominator);
public Fraction reciprocal() {
return new Fraction(denominator, numerator);
public Fraction add(Fraction fraction) {
return addSub(fraction, true /* add */);
public Fraction subtract(Fraction fraction) {
return addSub(fraction, false /* subtract */);
private Fraction addSub(Fraction fraction, boolean isAdd) {
if (fraction == null) {
throw new IllegalArgumentException("The fraction must not be null");
if (numerator == 0) {
return isAdd ? fraction : fraction.negate();
if (fraction.numerator == 0) {
return this;
int d1 = MathUtils.gcd(denominator, fraction.denominator);
if (d1==1) {
int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);
int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);
return new Fraction
(isAdd ? MathUtils.addAndCheck(uvp, upv) : 
MathUtils.subAndCheck(uvp, upv),
MathUtils.mulAndCheck(denominator, fraction.denominator));
BigInteger uvp = BigInteger.valueOf(numerator)
.multiply(BigInteger.valueOf(fraction.denominator/d1));
BigInteger upv = BigInteger.valueOf(fraction.numerator)
.multiply(BigInteger.valueOf(denominator/d1));
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);
BigInteger w = t.divide(BigInteger.valueOf(d2));
if (w.bitLength() > 31) {
throw new ArithmeticException
("overflow: numerator too large after multiply");
return new Fraction (w.intValue(), 
MathUtils.mulAndCheck(denominator/d1, 
fraction.denominator/d2));
public Fraction multiply(Fraction fraction) {
if (fraction == null) {
throw new IllegalArgumentException("The fraction must not be null");
if (numerator == 0 || fraction.numerator == 0) {
return ZERO;
int d1 = MathUtils.gcd(numerator, fraction.denominator);
int d2 = MathUtils.gcd(fraction.numerator, denominator);
return getReducedFraction
(MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),
MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));
public Fraction divide(Fraction fraction) {
if (fraction == null) {
throw new IllegalArgumentException("The fraction must not be null");
if (fraction.numerator == 0) {
throw new ArithmeticException("The fraction to divide by must not be zero");
return multiply(fraction.reciprocal());
public static Fraction getReducedFraction(int numerator, int denominator) {
if (denominator == 0) {
throw new ArithmeticException("The denominator must not be zero");
if (numerator==0) {
return ZERO; // normalize zero.
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
numerator/=2; denominator/=2;
if (denominator < 0) {
if (numerator==Integer.MIN_VALUE ||
denominator==Integer.MIN_VALUE) {
throw new ArithmeticException("overflow: can't negate");
numerator = -numerator;
denominator = -denominator;
int gcd = MathUtils.gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);
private void reduce() {
int d = MathUtils.gcd(numerator, denominator);
if (d > 1) {
numerator /= d;
denominator /= d;
if (denominator < 0) {
numerator *= -1;
denominator *= -1;
package org.apache.commons.math.fraction;
public class FractionFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
private NumberFormat denominatorFormat;
private NumberFormat numeratorFormat;
public FractionFormat() {
this(getDefaultNumberFormat());
public FractionFormat(NumberFormat format) {
this(format, (NumberFormat)format.clone());
public FractionFormat(NumberFormat numeratorFormat,
NumberFormat denominatorFormat)
super();
this.numeratorFormat = numeratorFormat;
this.denominatorFormat = denominatorFormat;
public static String formatFraction(Fraction f) {
return getImproperInstance().format(f);
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public static FractionFormat getImproperInstance() {
return getImproperInstance(Locale.getDefault());
public static FractionFormat getImproperInstance(Locale locale) {
NumberFormat f = getDefaultNumberFormat(locale);
return new FractionFormat(f);
public static FractionFormat getProperInstance() {
return getProperInstance(Locale.getDefault());
public static FractionFormat getProperInstance(Locale locale) {
NumberFormat f = getDefaultNumberFormat(locale);
return new ProperFractionFormat(f);
protected static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getNumberInstance(locale);
nf.setMaximumFractionDigits(0);
nf.setParseIntegerOnly(true);
return nf;
public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);
toAppendTo.append(" / ");
getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,
pos);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos)
StringBuffer ret = null;
if (obj instanceof Fraction) {
ret = format( (Fraction)obj, toAppendTo, pos);
ret = format( new Fraction(((Number)obj).doubleValue()),
toAppendTo, pos);
throw new IllegalArgumentException(
"Cannot convert given object to a fraction.");
throw new IllegalArgumentException(
"Cannot format given object as a fraction");
return ret;
public NumberFormat getDenominatorFormat() {
return denominatorFormat;
public NumberFormat getNumeratorFormat() {
return numeratorFormat;
public Fraction parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
Fraction result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable fraction number: \"" +
source + "\"", parsePosition.getErrorIndex());
return result;
public Fraction parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
Number num = getNumeratorFormat().parse(source, pos);
if (num == null) {
pos.setIndex(initialIndex);
return null;
int startIndex = pos.getIndex();
char c = parseNextCharacter(source, pos);
switch (c) {
case 0 :
return new Fraction(num.intValue(), 1);
case '/' :
break;
default :
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
Number den = getDenominatorFormat().parse(source, pos);
if (den == null) {
pos.setIndex(initialIndex);
return null;
return new Fraction(num.intValue(), den.intValue());
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
public void setDenominatorFormat(NumberFormat format) {
if (format == null) {
throw new IllegalArgumentException(
"denominator format can not be null.");
this.denominatorFormat = format;
public void setNumeratorFormat(NumberFormat format) {
if (format == null) {
throw new IllegalArgumentException(
"numerator format can not be null.");
this.numeratorFormat = format;
protected static void parseAndIgnoreWhitespace(
String source, ParsePosition pos)
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
protected static char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
package org.apache.commons.math.fraction;
public class ProperFractionFormat extends FractionFormat {
private static final long serialVersionUID = -6337346779577272307L;
private NumberFormat wholeFormat;
public ProperFractionFormat() {
this(getDefaultNumberFormat());
public ProperFractionFormat(NumberFormat format) {
this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());
public ProperFractionFormat(NumberFormat wholeFormat,
NumberFormat numeratorFormat,
NumberFormat denominatorFormat)
super(numeratorFormat, denominatorFormat);
setWholeFormat(wholeFormat);
public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
int num = fraction.getNumerator();
int den = fraction.getDenominator();
int whole = num / den;
num = num % den;
if (whole != 0) {
getWholeFormat().format(whole, toAppendTo, pos);
toAppendTo.append(' ');
num = Math.abs(num);
getNumeratorFormat().format(num, toAppendTo, pos);
toAppendTo.append(" / ");
getDenominatorFormat().format(den, toAppendTo,
pos);
return toAppendTo;
public NumberFormat getWholeFormat() {
return wholeFormat;
public Fraction parse(String source, ParsePosition pos) {
Fraction ret = super.parse(source, pos);
if (ret != null) {
return ret;
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
Number whole = getWholeFormat().parse(source, pos);
if (whole == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
Number num = getNumeratorFormat().parse(source, pos);
if (num == null) {
pos.setIndex(initialIndex);
return null;
if (num.intValue() < 0) {
pos.setIndex(initialIndex);
return null;
int startIndex = pos.getIndex();
char c = parseNextCharacter(source, pos);
switch (c) {
case 0 :
return new Fraction(num.intValue(), 1);
case '/' :
break;
default :
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
Number den = getDenominatorFormat().parse(source, pos);
if (den == null) {
pos.setIndex(initialIndex);
return null;
if (den.intValue() < 0) {
pos.setIndex(initialIndex);
return null;
int w = whole.intValue();
int n = num.intValue();
int d = den.intValue();
return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
public void setWholeFormat(NumberFormat format) {
if (format == null) {
throw new IllegalArgumentException(
"whole format can not be null.");
this.wholeFormat = format;
package org.apache.commons.math.fraction;
public class FractionConversionException extends MaxIterationsExceededException {
private static final long serialVersionUID = 4588659344016668813L;
public FractionConversionException(double value, int maxIterations) {
super(maxIterations,
"Unable to convert {0} to fraction after {1} iterations",
new Object[] { new Double(value), new Integer(maxIterations) });
package org.apache.commons.math.transform;
public class FastSineTransformer implements Serializable {
public FastSineTransformer() {
super();
public double[] transform(double f[]) throws MathException,
IllegalArgumentException {
return fst(f);
public double[] transform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
data[0] = 0.0;
return fst(data);
public double[] transform2(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = Math.sqrt(2.0 / f.length);
return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);
public double[] transform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
data[0] = 0.0;
double scaling_coefficient = Math.sqrt(2.0 / n);
return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);
public double[] inversetransform(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = 2.0 / f.length;
return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);
public double[] inversetransform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
data[0] = 0.0;
double scaling_coefficient = 2.0 / n;
return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);
public double[] inversetransform2(double f[]) throws MathException,
IllegalArgumentException {
return transform2(f);
public double[] inversetransform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
return transform2(f, min, max, n);
protected double[] fst(double f[]) throws MathException,
IllegalArgumentException {
double A, B, x[], F[] = new double[f.length];
FastFourierTransformer.verifyDataSet(f);
if (f[0] != 0.0) {
throw new IllegalArgumentException
("The first element is not zero: " + f[0]);
int N = f.length;
if (N == 1) {       // trivial case
F[0] = 0.0;
return F;
x = new double[N];
x[0] = 0.0;
x[N >> 1] = 2.0 * f[N >> 1];
for (int i = 1; i < (N >> 1); i++) {
A = Math.sin(i * Math.PI / N) * (f[i] + f[N-i]);
B = 0.5 * (f[i] - f[N-i]);
x[i] = A + B;
x[N-i] = A - B;
FastFourierTransformer transformer = new FastFourierTransformer();
Complex y[] = transformer.transform(x);
F[0] = 0.0;
F[1] = 0.5 * y[0].getReal();
for (int i = 1; i < (N >> 1); i++) {
F[2*i] = -y[i].getImaginary();
F[2*i+1] = y[i].getReal() + F[2*i-1];
return F;
package org.apache.commons.math.transform;
public class FastFourierTransformer implements Serializable {
private Complex omega[] = new Complex[0];
private int omegaCount = 0;
public FastFourierTransformer() {
super();
public Complex[] transform(double f[]) throws MathException,
IllegalArgumentException {
return fft(f, false);
public Complex[] transform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = sample(f, min, max, n);
return fft(data, false);
public Complex[] transform(Complex f[]) throws MathException,
IllegalArgumentException {
computeOmega(f.length);
return fft(f);
public Complex[] transform2(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f, false), scaling_coefficient);
public Complex[] transform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / Math.sqrt(n);
return scaleArray(fft(data, false), scaling_coefficient);
public Complex[] transform2(Complex f[]) throws MathException,
IllegalArgumentException {
computeOmega(f.length);
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f), scaling_coefficient);
public Complex[] inversetransform(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = 1.0 / f.length;
return scaleArray(fft(f, true), scaling_coefficient);
public Complex[] inversetransform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / n;
return scaleArray(fft(data, true), scaling_coefficient);
public Complex[] inversetransform(Complex f[]) throws MathException,
IllegalArgumentException {
computeOmega(-f.length);    // pass negative argument
double scaling_coefficient = 1.0 / f.length;
return scaleArray(fft(f), scaling_coefficient);
public Complex[] inversetransform2(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f, true), scaling_coefficient);
public Complex[] inversetransform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = sample(f, min, max, n);
double scaling_coefficient = 1.0 / Math.sqrt(n);
return scaleArray(fft(data, true), scaling_coefficient);
public Complex[] inversetransform2(Complex f[]) throws MathException,
IllegalArgumentException {
computeOmega(-f.length);    // pass negative argument
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
return scaleArray(fft(f), scaling_coefficient);
protected Complex[] fft(double f[], boolean isInverse) throws
MathException, IllegalArgumentException {
verifyDataSet(f);
Complex F[] = new Complex[f.length];
if (f.length == 1) {
F[0] = new Complex(f[0], 0.0);
return F;
int N = f.length >> 1;
Complex c[] = new Complex[N];
for (int i = 0; i < N; i++) {
c[i] = new Complex(f[2*i], f[2*i+1]);
computeOmega(isInverse ? -N : N);
Complex z[] = fft(c);
computeOmega(isInverse ? -2*N : 2*N);
F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);
F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);
for (int i = 1; i < N; i++) {
Complex A = z[N-i].conjugate();
Complex B = z[i].add(A);
Complex C = z[i].subtract(A);
Complex D = omega[i].multiply(Complex.I);
F[i] = B.subtract(C.multiply(D));
F[2*N-i] = F[i].conjugate();
return scaleArray(F, 0.5);
protected Complex[] fft(Complex data[]) throws MathException,
IllegalArgumentException {
int i, j, k, m, N = data.length;
Complex A, B, C, D, E, F, z, f[] = new Complex[N];
verifyDataSet(data);
if (N == 1) {
f[0] = data[0];
return f;
if (N == 2) {
f[0] = data[0].add(data[1]);
f[1] = data[0].subtract(data[1]);
return f;
j = 0;
for (i = 0; i < N; i++) {
f[i] = data[j];
k = N >> 1;
while (j >= k && k > 0) {
j -= k; k >>= 1;
j += k;
for (i = 0; i < N; i += 4) {
A = f[i].add(f[i+1]);
B = f[i+2].add(f[i+3]);
C = f[i].subtract(f[i+1]);
D = f[i+2].subtract(f[i+3]);
E = C.add(D.multiply(Complex.I));
F = C.subtract(D.multiply(Complex.I));
f[i] = A.add(B);
f[i+2] = A.subtract(B);
f[i+1] = omegaCount < 0 ? E : F;
f[i+3] = omegaCount > 0 ? E : F;
for (i = 4; i < N; i <<= 1) {
m = N / (i<<1);
for (j = 0; j < N; j += i<<1) {
for (k = 0; k < i; k++) {
z = f[i+j+k].multiply(omega[k*m]);
f[i+j+k] = f[j+k].subtract(z);
f[j+k] = f[j+k].add(z);
return f;
protected void computeOmega(int n) throws IllegalArgumentException {
if (n == 0) {
throw new IllegalArgumentException
("Cannot compute 0-th root of unity, indefinite result.");
if (n == omegaCount) { return; }
if (n + omegaCount == 0) {
for (int i = 0; i < Math.abs(omegaCount); i++) {
omega[i] = omega[i].conjugate();
omegaCount = n;
return;
omega = new Complex[Math.abs(n)];
double t = 2.0 * Math.PI / n;
double cost = Math.cos(t);
double sint = Math.sin(t);
omega[0] = new Complex(1.0, 0.0);
for (int i = 1; i < Math.abs(n); i++) {
omega[i] = new Complex(
omega[i-1].getReal() * cost + omega[i-1].getImaginary() * sint,
omega[i-1].getImaginary() * cost - omega[i-1].getReal() * sint);
omegaCount = n;
public static double[] sample(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
if (n <= 0) {
throw new IllegalArgumentException("Number of samples not positive.");
verifyInterval(min, max);
double s[] = new double[n];
double h = (max - min) / n;
for (int i = 0; i < n; i++) {
s[i] = f.value(min + i * h);
return s;
public static double[] scaleArray(double f[], double d) {
for (int i = 0; i < f.length; i++) {
f[i] *= d;
return f;
public static Complex[] scaleArray(Complex f[], double d) {
for (int i = 0; i < f.length; i++) {
f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());
return f;
public static boolean isPowerOf2(long n) {
return (n > 0) && ((n & (n - 1)) == 0);
public static void verifyDataSet(double d[]) throws IllegalArgumentException {
if (!isPowerOf2(d.length)) {
throw new IllegalArgumentException
("Number of samples not power of 2, consider padding for fix.");
public static void verifyDataSet(Object o[]) throws IllegalArgumentException {
if (!isPowerOf2(o.length)) {
throw new IllegalArgumentException
("Number of samples not power of 2, consider padding for fix.");
public static void verifyInterval(double lower, double upper) throws
IllegalArgumentException {
if (lower >= upper) {
throw new IllegalArgumentException
("Endpoints do not specify an interval: [" + lower +
", " + upper + "]");
package org.apache.commons.math.transform;
public class FastCosineTransformer implements Serializable {
public FastCosineTransformer() {
super();
public double[] transform(double f[]) throws MathException,
IllegalArgumentException {
return fct(f);
public double[] transform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
return fct(data);
public double[] transform2(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));
return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);
public double[] transform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
double scaling_coefficient = Math.sqrt(2.0 / (n-1));
return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);
public double[] inversetransform(double f[]) throws MathException,
IllegalArgumentException {
double scaling_coefficient = 2.0 / (f.length - 1);
return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);
public double[] inversetransform(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
double data[] = FastFourierTransformer.sample(f, min, max, n);
double scaling_coefficient = 2.0 / (n - 1);
return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);
public double[] inversetransform2(double f[]) throws MathException,
IllegalArgumentException {
return transform2(f);
public double[] inversetransform2(
UnivariateRealFunction f, double min, double max, int n)
throws MathException, IllegalArgumentException {
return transform2(f, min, max, n);
protected double[] fct(double f[]) throws MathException,
IllegalArgumentException {
double A, B, C, F1, x[], F[] = new double[f.length];
int N = f.length - 1;
if (!FastFourierTransformer.isPowerOf2(N)) {
throw new IllegalArgumentException
("Number of samples not power of 2 plus one: " + f.length);
if (N == 1) {       // trivial case
F[0] = 0.5 * (f[0] + f[1]);
F[1] = 0.5 * (f[0] - f[1]);
return F;
x = new double[N];
x[0] = 0.5 * (f[0] + f[N]);
x[N >> 1] = f[N >> 1];
F1 = 0.5 * (f[0] - f[N]);   // temporary variable for F[1]
for (int i = 1; i < (N >> 1); i++) {
A = 0.5 * (f[i] + f[N-i]);
B = Math.sin(i * Math.PI / N) * (f[i] - f[N-i]);
C = Math.cos(i * Math.PI / N) * (f[i] - f[N-i]);
x[i] = A - B;
x[N-i] = A + B;
F1 += C;
FastFourierTransformer transformer = new FastFourierTransformer();
Complex y[] = transformer.transform(x);
F[0] = y[0].getReal();
F[1] = F1;
for (int i = 1; i < (N >> 1); i++) {
F[2*i] = y[i].getReal();
F[2*i+1] = F[2*i-1] - y[i].getImaginary();
F[N] = y[N >> 1].getReal();
return F;
package org.apache.commons.math;
public class MathConfigurationException extends MathException implements Serializable{
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException() {
super();
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String pattern, Object[] arguments) {
super(pattern, arguments);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
public MathConfigurationException(Throwable cause) {
super(cause);
public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
package org.apache.commons.math;
public class MathException extends Exception {
private static final long serialVersionUID = -8602234299177097102L;
private static final boolean JDK_SUPPORTS_NESTED;
boolean flag = false;
Throwable.class.getDeclaredMethod("getCause", new Class[0]);
flag = true;
flag = false;
JDK_SUPPORTS_NESTED = flag;
private static ResourceBundle cachedResources = null;
private final String pattern;
private final Object[] arguments;
private final Throwable rootCause;
private static String translate(String s, Locale locale) {
if ((cachedResources == null) || (! cachedResources.getLocale().equals(locale))) {
cachedResources =
ResourceBundle.getBundle("org.apache.commons.math.MessagesResources", locale);
if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {
return cachedResources.getString(s);
return s;
private static String buildMessage(String pattern, Object[] arguments, Locale locale) {
MessageFormat mf = new MessageFormat(translate(pattern, locale));
mf.setLocale(locale);
return mf.format(arguments);        
public MathException() {
super();
this.pattern   = null;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String pattern, Object[] arguments) {
super(buildMessage(pattern, arguments, Locale.US));
this.pattern   = pattern;
this.arguments = arguments;
this.rootCause = null;
public MathException(Throwable rootCause) {
super((rootCause == null ? null : rootCause.getMessage()));
this.pattern   = getMessage();
this.arguments = new Object[0];
this.rootCause = rootCause;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
public MathException(String pattern, Object[] arguments, Throwable rootCause) {
super(buildMessage(pattern, arguments, Locale.US));
this.pattern   = pattern;
this.arguments = arguments;
this.rootCause = rootCause;
public String getPattern() {
return pattern;
public Object[] getArguments() {
return arguments;
public String getMessage(Locale locale) {
return (pattern == null) ? null : buildMessage(pattern, arguments, locale);
public Throwable getCause() {
return rootCause;
public void printStackTrace() {
printStackTrace(System.err);
public void printStackTrace(PrintStream out) {
synchronized (out) {
PrintWriter pw = new PrintWriter(out, false);
printStackTrace(pw);
pw.flush();
public void printStackTrace(PrintWriter out) {
synchronized (out) {
super.printStackTrace(out);
if (rootCause != null && JDK_SUPPORTS_NESTED == false) {
out.print("Caused by: ");
rootCause.printStackTrace(out);
package org.apache.commons.math;
public class ConvergenceException extends MathException {
private static final long serialVersionUID = 4380655778005469702L;
public ConvergenceException() {
super("Convergence failed", new Object[0]);
public ConvergenceException(String pattern, Object[] arguments) {
super(pattern, arguments);
public ConvergenceException(Throwable cause) {
super(cause);
public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
package org.spaceroots.mantissa;
public class AllTests {
public static Test suite() { 
TestSuite suite= new TestSuite("org.spaceroots.mantissa"); 
suite.addTest(org.spaceroots.mantissa.linalg.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.functions.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.roots.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.fitting.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.quadrature.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.utilities.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.algebra.AllTests.suite()); 
return suite; 
package org.spaceroots.mantissa.roots;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.roots"); 
suite.addTest(BrentSolverTest.suite());
return suite; 
package org.spaceroots.mantissa.roots;
public abstract class TestProblem implements ComputableFunction {
private double a;
private double b;
private double expectedRoot;
protected TestProblem(double a, double b, double expectedRoot) {
this.a            = a;
this.b            = b;
this.expectedRoot = expectedRoot;
public double getA() {
return a;
public double getB() {
return b;
public double getExpectedRoot() {
return expectedRoot;
public boolean checkResult(double foundRoot, double tol) {
return Math.abs(foundRoot - expectedRoot) <= tol;
public static TestProblem[] getAPSProblems() {
ArrayList problems = new ArrayList();
problems.add(new APSProblem1(Math.PI / 2, Math.PI, 1.8954942670340));
double[] roots2To11 = {
3.0229153472731,  6.6837535608081, 11.238701655002, 19.676000080623,
29.828227326505,  41.906116195289,  55.953595800143, 71.985665586588,
90.008868539167, 110.02653274833
for (int k = 0, n = 1; n <= 10; ++n) {
problems.add(new APSProblems2To11(1.0e-9 + n * n,
(n+1) * (n+1) - 1.0e-9,
roots2To11[k++]));
problems.add(new APSProblems12To14( -40, -9.0, 31.0, 0.0));
problems.add(new APSProblems12To14(-100, -9.0, 31.0, 0.0));
problems.add(new APSProblems12To14(-200, -9.0, 31.0, 0.0));
int[] n15 = { 4, 6, 8, 10, 12 };
double[] roots15 = {
0.66874030497642, 0.76472449133173, 0.81776543395794,
0.85133992252078, 0.87448527222117
for (int k = 0; k < n15.length; ++k) {
problems.add(new APSProblems15To17(n15[k], 0.2, 0.0, 5.0, roots15[k]));
int[] n16 = { 4, 6, 8, 10, 12 };
for (int k = 0; k < n16.length; ++k) {
problems.add(new APSProblems15To17(n16[k], 1.0, 0.0, 5.0, 1.0));
int[] n17 = { 8, 10, 12, 14 };
for (int k = 0; k < n17.length; ++k) {
problems.add(new APSProblems15To17(n17[k], 1.0, -0.95, 4.05, 1.0));
problems.add(new APSProblem18(0.0, 1.5, 0.52359877559830));
int[] n19 = { 1, 2, 3, 4, 5, 20, 40, 60, 80, 100 };
double[] roots19 = {
0.42247770964124,   0.30669941048320,   0.22370545765466,
0.17171914751951,   0.13825715505682,   3.4657359020854e-2,
1.7328679513999e-2, 1.1552453009332e-2, 8.6643397569993e-3,
6.9314718055995e-3
for (int k = 0; k < n19.length; ++k) {
problems.add(new APSProblem19(n19[k], 0.0, 1.0, roots19[k]));
int[] n20 = { 5, 10, 20 };
double[] roots20 = {
3.8402551840622e-2, 9.9000099980005e-3, 2.4937500390620e-3
for (int k = 0; k < n20.length; ++k) {
problems.add(new APSProblem20(n20[k], 0.0, 1.0, roots20[k]));
int[] n21 = { 2, 5, 10, 15, 20 };
double[] roots21 = {
0.5, 0.34595481584824, 0.24512233375331,
0.19554762353657, 0.16492095727644
for (int k = 0; k < n21.length; ++k) {
problems.add(new APSProblem21(n21[k], 0.0, 1.0, roots21[k]));
int[] n22 = { 1, 2, 4, 5, 8, 15, 20 };
double[] roots22 = {
0.27550804099948,   0.13775402049974,   1.0305283778156e-2,
3.6171081789041e-3, 4.1087291849640e-4, 2.5989575892908e-5,
7.6685951221853e-6
for (int k = 0; k < n22.length; ++k) {
problems.add(new APSProblem22(n22[k], 0.0, 1.0, roots22[k]));
int[] n23 = { 1, 5, 10, 15, 20 };
double[] roots23 = {
0.40105813754155, 0.51615351875793, 0.53952222690842,
0.54818229434066, 0.55270466667849
for (int k = 0; k < n23.length; ++k) {
problems.add(new APSProblem23(n23[k], 0.0, 1.0, roots23[k]));
int[] n24 = { 2, 5, 15, 20 };
for (int k = 0; k < n24.length; ++k) {
problems.add(new APSProblem24(n24[k], 0.01, 1, 1.0 / n24[k]));
int[] n25 = {
2,  3,  4,  5,  6,
7,  9, 11, 13, 15,
17, 19, 21, 23, 25,
27, 29, 31, 33
for (int k = 0; k < n25.length; ++k) {
problems.add(new APSProblem25(n25[k], 1.0, 100.0, n25[k]));
problems.add(new APSProblem26(-1.0, 4.0, 0.0));
int[] n27 = {
1,  2,  3,  4,  5,  6,  7,  8,  9,  10,
11, 12, 13, 14, 15, 16, 17, 18, 19,  20,
21, 22, 23, 24, 25, 26, 27, 28, 29,  30,
31, 32, 33, 34, 35, 36, 37, 38, 39,  40
for (int k = 0; k < n27.length; ++k) {
problems.add(new APSProblem27(n27[k], -10000.0, Math.PI / 2,
0.62380651896161));
int[] n28 = {
20,  21,  22,  23,  24,  25,  26,  27,  28,   29,
30,  31,  32,  33,  34,  35,  36,  37,  38,   39, 40,
100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };
double[] roots28 = {
5.9051305594220e-5, 5.6367155339937e-5, 5.3916409455592e-5,
5.1669892394942e-5, 4.9603096699145e-5, 4.7695285287639e-5,
4.5928793239949e-5, 4.4288479195665e-5, 4.2761290257883e-5,
4.1335913915954e-5, 4.0002497338020e-5, 3.8752419296207e-5,
3.7578103559958e-5, 3.6472865219959e-5, 3.5430783356532e-5,
3.4446594929961e-5, 3.3515605877800e-5, 3.2633616249437e-5,
3.1796856858426e-5, 3.1001935436965e-5, 3.0245790670210e-5,
1.2277994232462e-5, 6.1695393904409e-6, 4.1198585298293e-6,
3.0924623877272e-6, 2.4752044261050e-6, 2.0633567678513e-6,
1.7690120078154e-6, 1.5481615698859e-6, 1.3763345366022e-6,
1.2388385788997e-6
for (int k = 0; k < n28.length; ++k) {
problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));
return (TestProblem[]) problems.toArray(new TestProblem[problems.size()]);
private static class APSProblem1 extends TestProblem {
private static final long serialVersionUID = -186095948802525864L;
public APSProblem1(double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
public double valueAt(double x) {
return Math.sin(x) - x / 2;
private static class APSProblems2To11 extends TestProblem {
private static final long serialVersionUID = -1284328672006328516L;
public APSProblems2To11(double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
public double valueAt(double x) {
double f = 0;
for (int i = 1; i <= 20; ++i) {
double n = 2.0 * i - 5.0;
double d = x - i * i;
f += n * n / (d * d * d);
return -2 * f;
private static class APSProblems12To14 extends TestProblem {
private static final long serialVersionUID = 3371996034561221313L;
private int n;
public APSProblems12To14(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
public double valueAt(double x) {
return n * x * Math.exp(-x);
private static class APSProblems15To17 extends TestProblem {
private static final long serialVersionUID = -5460543876513796612L;
private int    n;
private double u;
public APSProblems15To17(int n, double u,
double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
this.u = u;
public double valueAt(double x) {
return Math.pow(x, n) - u;
private static class APSProblem18 extends TestProblem {
private static final long serialVersionUID = 6762799934117390438L;
public APSProblem18(double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
public double valueAt(double x) {
return Math.sin(x) - 0.5;
private static class APSProblem19 extends TestProblem {
private static final long serialVersionUID = 4962041891152128524L;
private int n;
public APSProblem19(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
public double valueAt(double x) {
return 2.0 * x * Math.exp(-n) - 2.0 *Math.exp(-n * x) + 1.0;
private static class APSProblem20 extends TestProblem {
private static final long serialVersionUID = -7391954140799812791L;
private int n;
private int oPoMn2;
public APSProblem20(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
int oMn =  1 - n;
oPoMn2 = 1 + oMn * oMn;
public double valueAt(double x) {
double v = 1.0 - n * x;
return oPoMn2 * x - v * v;
private static class APSProblem21 extends TestProblem {
private static final long serialVersionUID = -4160028543895639114L;
private int n;
public APSProblem21(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
public double valueAt(double x) {
return x * x - Math.pow(1 - x, n);
private static class APSProblem22 extends TestProblem {
private static final long serialVersionUID = 3807046732154081146L;
private int n;
private int oPoMn4;
public APSProblem22(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n   = n;
int oMn  = 1 - n;
int oMn2 = oMn * oMn;
oPoMn4   = 1 + oMn2 * oMn2;
public double valueAt(double x) {
double oMnx  = 1 - n * x;
double oMnx2 = oMnx * oMnx;
return oPoMn4 * x - oMnx2 * oMnx2;
private static class APSProblem23 extends TestProblem {
private static final long serialVersionUID = -486669213837396921L;
private int n;
public APSProblem23(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
public double valueAt(double x) {
return (x - 1.0) * Math.exp(-n * x) + Math.pow(x, n);
private static class APSProblem24 extends TestProblem {
private static final long serialVersionUID = -628275471717968182L;
private int n;
public APSProblem24(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
this.n = n;
public double valueAt(double x) {
return (n * x - 1.0) / ((n - 1) * x);
private static class APSProblem25 extends TestProblem {
private static final long serialVersionUID = 5207170686914959073L;
private double u;
private double v;;
public APSProblem25(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
u = 1.0 / n;
v = Math.pow(n, u);
public double valueAt(double x) {
return Math.pow(x, u) - v;
private static class APSProblem26 extends TestProblem {
private static final long serialVersionUID = 1063884352586457076L;
public APSProblem26(double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
public double valueAt(double x) {
if (x == 0.0) {
return 0;
return x / Math.exp(1 / (x * x));
public boolean checkResult(double foundRoot, double tol) {
return Math.abs(foundRoot) <= 0.03768;
private static class APSProblem27 extends TestProblem {
private static final long serialVersionUID = -3549158218723499035L;
private double u;
public APSProblem27(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
u = n / 20.0;
public double valueAt(double x) {
if (x >= 0.0) {
return (x / 1.5 + Math.sin(x) - 1.0) * u;
return -u;
private static class APSProblem28 extends TestProblem {
private static final long serialVersionUID = -8198306839874267863L;
private double threshold;
private static final double yHigh= Math.exp(1.0) - 1.859;
private int    u;
public APSProblem28(int n, double a, double b, double expectedRoot) {
super(a, b, expectedRoot);
threshold = 0.002 / (1 + n);
u         = (n + 1) * 500;
public double valueAt(double x) {
if (x >= threshold) {
return yHigh;
return Math.exp(u * x) - 1.859;
return -0.859;
package org.spaceroots.mantissa.roots;
public class BrentSolverTest
extends TestCase {
public BrentSolverTest(String name) {
super(name);
public void testAlefeldPotraShi()
throws FunctionException {
TestProblem[] problems = TestProblem.getAPSProblems();
BrentSolver solver     = new BrentSolver();
for (int i = 0; i < problems.length; ++i) {
TestProblem p = problems[i];
double tol = 1.0e-10 * Math.abs(p.getExpectedRoot());
assertTrue(solver.findRoot(p, new Checker(tol), 1000,
p.getA(), p.valueAt(p.getA()),
p.getB(), p.valueAt(p.getB())));
assertTrue(p.checkResult(solver.getRoot(), tol));
private static class Checker implements ConvergenceChecker {
private double tolerance;
public Checker (double tolerance) {
this.tolerance = tolerance;
public int converged (double xLow, double fLow,
double xHigh, double fHigh) {
return (Math.abs(xHigh - xLow) <= tolerance)
? ((Math.abs(fLow) <= Math.abs(fHigh))
? ConvergenceChecker.LOW
: ConvergenceChecker.HIGH)
: ConvergenceChecker.NONE;
public static Test suite() {
return new TestSuite(BrentSolverTest.class);
package org.spaceroots.mantissa.fitting;
public class AllTests {
public static Test suite() { 
TestSuite suite= new TestSuite("org.spaceroots.mantissa.fitting"); 
suite.addTest(AbstractCurveFitterTest.suite());
suite.addTest(PolynomialFitterTest.suite());
suite.addTest(HarmonicFitterTest.suite());
return suite; 
package org.spaceroots.mantissa.fitting;
public class AbstractCurveFitterTest
extends TestCase {
public AbstractCurveFitterTest(String name) {
super(name);
fitter = null;
public void testAlreadySorted() {
for (double x = 0.0; x < 100.0; x += 1.0) {
fitter.addWeightedPair(1.0, x, 0.0);
checkSorted();
public void testReversed() {
for (double x = 0.0; x < 100.0; x += 1.0) {
fitter.addWeightedPair(1.0, 100.0 - x, 0.0);
checkSorted();
public void testRandom() {
Random randomizer = new Random(86757343594l);
for (int i = 0; i < 100; ++i) {
fitter.addWeightedPair(1.0, 10.0 * randomizer.nextDouble(), 0.0);
checkSorted();
public void checkSorted() {
fitter.doSort();
WeightedMeasurement[] measurements = fitter.getMeasurements();
for (int i = 1; i < measurements.length; ++i) {
AbstractCurveFitter.FitMeasurement m1
= (AbstractCurveFitter.FitMeasurement) measurements[i-1];
AbstractCurveFitter.FitMeasurement m2
= (AbstractCurveFitter.FitMeasurement) measurements[i];
assertTrue(m1.x <= m2.x);
public static Test suite() {
return new TestSuite(AbstractCurveFitterTest.class);
public void setUp() {
fitter = new DummyFitter();
public void tearDown() {
fitter = null;
private static class DummyFitter
extends AbstractCurveFitter {
public DummyFitter() {
super(10, new LevenbergMarquardtEstimator());
public double valueAt(double x) {
return 0.0;
public double partial(double x, EstimatedParameter p) {
return 0.0;
public void doSort() {
sortMeasurements();
private static final long serialVersionUID = 4016396219767783678L;
private DummyFitter fitter;
package org.spaceroots.mantissa.fitting;
public class PolynomialFitterTest
extends TestCase {
public PolynomialFitterTest(String name) {
super(name);
public void testNoError()
throws EstimationException {
Random randomizer = new Random(64925784252l);
for (int degree = 0; degree < 10; ++degree) {
Polynom p = new Polynom(degree);
for (int i = 0; i <= degree; ++i) {
p.initCoeff (i, randomizer.nextGaussian());
PolynomialFitter fitter =
new PolynomialFitter(degree, new LevenbergMarquardtEstimator());
for (int i = 0; i <= degree; ++i) {
fitter.addWeightedPair(1.0, i, p.valueAt(i));
Polynom fitted = new Polynom(fitter.fit());
for (double x = -1.0; x < 1.0; x += 0.01) {
double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))
/ (1.0 + Math.abs(p.valueAt(x)));
assertTrue(Math.abs(error) < 1.0e-5);
public void testSmallError()
throws EstimationException {
Random randomizer = new Random(53882150042l);
for (int degree = 0; degree < 10; ++degree) {
Polynom p = new Polynom(degree);
for (int i = 0; i <= degree; ++i) {
p.initCoeff(i, randomizer.nextGaussian());
PolynomialFitter fitter =
new PolynomialFitter(degree, new LevenbergMarquardtEstimator());
for (double x = -1.0; x < 1.0; x += 0.01) {
fitter.addWeightedPair(1.0, x,
p.valueAt(x) + 0.1 * randomizer.nextGaussian());
Polynom fitted = new Polynom(fitter.fit());
for (double x = -1.0; x < 1.0; x += 0.01) {
double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))
/ (1.0 + Math.abs(p.valueAt(x)));
assertTrue(Math.abs(error) < 0.1);
public void testRedundantSolvable() {
checkUnsolvableProblem(new LevenbergMarquardtEstimator(), true);
public void testRedundantUnsolvable() {
checkUnsolvableProblem(new GaussNewtonEstimator(10, 1.0e-7, 1.0e-7,
1.0e-10),
false);
private void checkUnsolvableProblem(Estimator estimator,
boolean solvable) {
Random randomizer = new Random(1248788532l);
for (int degree = 0; degree < 10; ++degree) {
Polynom p = new Polynom(degree);
for (int i = 0; i <= degree; ++i) {
p.initCoeff(i, randomizer.nextGaussian());
PolynomialFitter fitter = new PolynomialFitter(degree, estimator);
for (double x = -1.0; x < 1.0; x += 0.01) {
fitter.addWeightedPair(1.0, 0.0, p.valueAt(0.0));
fitter.fit();
assertTrue(solvable || (degree == 0));
assertTrue((! solvable) && (degree > 0));
public static Test suite() {
return new TestSuite(PolynomialFitterTest.class);
private static class Polynom {
public Polynom(int degree) {
coeffs = new double[degree + 1];
for (int i = 0; i < coeffs.length; ++i) {
coeffs[i] = 0.0;
public Polynom(double[]coeffs) {
this.coeffs = coeffs;
public void initCoeff(int i, double c) {
coeffs[i] = c;
public double valueAt(double x) {
double y = coeffs[coeffs.length - 1];
for (int i = coeffs.length - 2; i >= 0; --i) {
y = y * x + coeffs[i];
return y;
private double[] coeffs;
package org.spaceroots.mantissa.fitting;
public class HarmonicFitterTest
extends TestCase {
public HarmonicFitterTest(String name) {
super(name);
public void testNoError()
throws EstimationException {
HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);
HarmonicFitter fitter =
new HarmonicFitter(new LevenbergMarquardtEstimator());
for (double x = 0.0; x < 1.3; x += 0.01) {
fitter.addWeightedPair(1.0, x, f.valueAt(x));
double[] coeffs = fitter.fit();
HarmonicFunction fitted = new HarmonicFunction(coeffs[0],
coeffs[1],
coeffs[2]);
assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-13);
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-13);
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-13);
for (double x = -1.0; x < 1.0; x += 0.01) {
assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-13);
public void test1PercentError()
throws EstimationException {
Random randomizer = new Random(64925784252l);
HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);
HarmonicFitter fitter =
new HarmonicFitter(new LevenbergMarquardtEstimator());
for (double x = 0.0; x < 10.0; x += 0.1) {
fitter.addWeightedPair(1.0, x,
f.valueAt(x) + 0.01 * randomizer.nextGaussian());
double[] coeffs = fitter.fit();
new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);
assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 2.7e-3);
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.3e-2);
WeightedMeasurement[] measurements = fitter.getMeasurements();
for (int i = 0; i < measurements.length; ++i) {
WeightedMeasurement m = measurements[i];
assertTrue(Math.abs(measurements[i].getMeasuredValue()
- m.getTheoreticalValue()) < 0.04);
public void testUnsorted()
throws EstimationException {
Random randomizer = new Random(64925784252l);
HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);
HarmonicFitter fitter =
new HarmonicFitter(new LevenbergMarquardtEstimator());
int size = 100;
double[] xTab = new double[size];
double[] yTab = new double[size];
for (int i = 0; i < size; ++i) {
xTab[i] = 0.1 * i;
yTab[i] = f.valueAt (xTab[i]) + 0.01 * randomizer.nextGaussian();
for (int i = 0; i < size; ++i) {
int i1 = randomizer.nextInt(size);
int i2 = randomizer.nextInt(size);
double xTmp = xTab[i1];
double yTmp = yTab[i1];
xTab[i1] = xTab[i2];
yTab[i1] = yTab[i2];
xTab[i2] = xTmp;
yTab[i2] = yTmp;
for (int i = 0; i < size; ++i) {
fitter.addWeightedPair(1.0, xTab[i], yTab[i]);
double[] coeffs = fitter.fit();
new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);
assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.5e-2);
WeightedMeasurement[] measurements = fitter.getMeasurements();
for (int i = 0; i < measurements.length; ++i) {
WeightedMeasurement m = measurements[i];
assertTrue(Math.abs(m.getMeasuredValue() - m.getTheoreticalValue())
< 0.04);
public static Test suite() {
return new TestSuite(HarmonicFitterTest.class);
private static double center(double a, double ref) {
double twoPi = Math.PI + Math.PI;
return a - twoPi * Math.floor((a + Math.PI - ref) / twoPi);
private static class HarmonicFunction {
public HarmonicFunction(double a, double omega, double phi) {
this.a     = a;
this.omega = omega;
this.phi   = phi;
public double valueAt(double x) {
return a * Math.cos(omega * x + phi);
public double getA() {
return a;
public double getOmega() {
return omega;
public double getPhi() {
return phi;
private double a;
private double omega;
private double phi;
package org.spaceroots.mantissa.linalg;
public class AllTests {
public static Test suite() {
TestSuite suite = new TestSuite("org.spaceroots.mantissa.linalg"); 
suite.addTest(NonNullRangeTest.suite()); 
suite.addTest(GeneralMatrixTest.suite()); 
suite.addTest(DiagonalMatrixTest.suite()); 
suite.addTest(LowerTriangularMatrixTest.suite()); 
suite.addTest(UpperTriangularMatrixTest.suite()); 
suite.addTest(GeneralSquareMatrixTest.suite()); 
suite.addTest(SymetricalMatrixTest.suite()); 
suite.addTest(MatrixFactoryTest.suite());
return suite; 
package org.spaceroots.mantissa.linalg;
public class GeneralMatrixTest
extends TestCase {
public GeneralMatrixTest(String name) {
super(name);
public void testDimensions() {
GeneralMatrix m = new GeneralMatrix(3, 4);
assertTrue(m.getRows() == 3);
assertTrue(m.getColumns() == 4);
public void testInvalidDimensions() {
boolean gotIt;
gotIt = false;
new GeneralMatrix(0, 2);
gotIt = true;
assertTrue(gotIt);
gotIt = false;
new GeneralMatrix(1, -3, null);
gotIt = true;
assertTrue(gotIt);
public void testElements() {
Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
checkMatrix(m, new BilinearPattern(1.0, 0.01));
public void testCopy() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
GeneralMatrix m2 = new GeneralMatrix(m1);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = 0; j < m1.getColumns(); ++j) {
m1.setElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix(m2, new BilinearPattern(1.0, 0.01));
public void testDuplicate() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = m1.duplicate();
assertTrue(m2 instanceof GeneralMatrix);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = 0; j < m1.getColumns(); ++j) {
m1.setElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix (m2, new BilinearPattern(1.0, 0.01));
public void testAddKO() {
boolean gotIt = false;
new GeneralMatrix(2, 3).add(new GeneralMatrix(3, 2));
gotIt = true;
assertTrue(gotIt);
public void testAddOK() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = buildMatrix(m1.getRows(),
m1.getColumns(),
new BilinearPattern(100, -0.01));
Matrix m3 = m1.add(m2);
checkMatrix(m3, new BilinearPattern(101, 0));
public void testSelfAdd() {
GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = buildMatrix(m1.getRows(),
m1.getColumns(),
new BilinearPattern(100, -0.01));
m1.selfAdd(m2);
checkMatrix(m1, new BilinearPattern(101, 0));
public void testSubKO() {
boolean gotIt = false;
new GeneralMatrix(2, 3).sub(new GeneralMatrix(3, 2));
gotIt = true;
assertTrue(gotIt);
public void testSubOK() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = buildMatrix(m1.getRows(),
m1.getColumns(),
new BilinearPattern(100, -0.01));
Matrix m3 = m1.sub(m2);
checkMatrix(m3, new BilinearPattern(-99, 0.02));
public void testSelfSub() {
GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = buildMatrix(m1.getRows(),
m1.getColumns(),
new BilinearPattern(100, -0.01));
m1.selfSub(m2);
checkMatrix(m1, new BilinearPattern(-99, 0.02));
public void testMulMKO() {
boolean gotIt = false;
new GeneralMatrix(2, 3).mul(new GeneralMatrix(2, 3));
gotIt = true;
assertTrue(gotIt);
public void testMulMOK() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = buildMatrix(m1.getColumns(), 4, new BilinearPattern(2, -1));
Matrix m3 = m1.mul(m2);
checkMatrix(m3, new ComplexPattern(m1.getColumns()));
public void testMulD() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = m1.mul(2.5);
checkMatrix(m2, new BilinearPattern(2.5, 0.025));
public void testSelfMul() {
Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
m.selfMul(2.5);
checkMatrix(m, new BilinearPattern(2.5, 0.025));
public void testTranspose() {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
Matrix m2 = m1.getTranspose();
assertTrue(m1.getRows() == m2.getColumns());
assertTrue(m1.getColumns() == m2.getRows());
checkMatrix(m2, new BilinearPattern(0.01, 1.0));
public static Test suite() {
return new TestSuite(GeneralMatrixTest.class);
private interface ElementPattern {
public double value(int i, int j);
private static class BilinearPattern implements ElementPattern {
public BilinearPattern(double coeffI, double coeffJ) {
this.coeffI = coeffI;
this.coeffJ = coeffJ;
public double value(int i, int j) {
return coeffI * i + coeffJ * j;
private final double coeffI;
private final double coeffJ;
private static class ComplexPattern implements ElementPattern {
public ComplexPattern(int p) {
this.p = p;
public double value(int i, int j) {
return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0
- i* j
+ (p - 1) * (2 * p - 1) / 300.0);
private final int p;
public GeneralMatrix buildMatrix(int rows, int columns,
BilinearPattern pattern) {
GeneralMatrix m = new GeneralMatrix(rows, columns);
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j){
m.setElement(i, j, pattern.value(i, j));
return m;
public void checkMatrix(Matrix m, ElementPattern pattern) {
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j) {
assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))
< 1.0e-10);
package org.spaceroots.mantissa.linalg;
public class MatrixFactoryTest
extends TestCase {
public MatrixFactoryTest(String name) {
super(name);
public void testInvalidDimensions() {
boolean gotIt;
gotIt = false;
MatrixFactory.buildMatrix(0, 2, null, 1, 1);
gotIt = true;
assertTrue(gotIt);
public void testDiagonal() {
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 0);
assertTrue(m instanceof DiagonalMatrix);
public void testLowerTriangular() {
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 0);
assertTrue(m instanceof LowerTriangularMatrix);
public void testUpperTriangular() {
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 1);
assertTrue(m instanceof UpperTriangularMatrix);
public void testSquare() {
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 1);
assertTrue(m instanceof GeneralSquareMatrix);
public void testGeneral() {
Matrix m = MatrixFactory.buildMatrix(3, 4, null, 0, 0);
assertTrue(m instanceof GeneralMatrix);
public static Test suite() {
return new TestSuite(MatrixFactoryTest.class);
package org.spaceroots.mantissa.linalg;
public class LowerTriangularMatrixTest
extends TestCase {
public LowerTriangularMatrixTest(String name) {
super(name);
public void testNoSetOutsideOfLowerTriangle() {
LowerTriangularMatrix l = new LowerTriangularMatrix(4);
for (int i = 0; i < l.getRows(); ++i) {
for (int j = 0; j < l.getColumns(); ++j) {
if (i >= j) {
l.setElement(i, j, i + 0.1 * j);
boolean gotIt = false;
l.setElement(i, j, -1.3);
gotIt = true;
assertTrue(gotIt);
checkMatrix(l, new BilinearPattern(1.0, 0.1));
public void testCopy() {
LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));
LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);
checkMatrix (l2, new BilinearPattern(1.0, 0.01));
public void testDuplicate() {
LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));
Matrix l2 = l1.duplicate();
assertTrue(l2 instanceof LowerTriangularMatrix);
checkMatrix(l2, new BilinearPattern(1.0, 0.01));
public void testTranspose() {
LowerTriangularMatrix l = buildMatrix(7, new BilinearPattern(1.0, 0.1));
Matrix transposed = l.getTranspose();
assertTrue(transposed instanceof UpperTriangularMatrix);
for (int i = 0; i < transposed.getRows(); ++i){
for (int j = 0; j < transposed.getColumns(); ++j) {
double expected = (i > j) ? 0.0 : (j + 0.1 * i);
assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);
public void testSelfAdd() {
LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));
LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));
l1.selfAdd(l2);
checkMatrix(l1, new BilinearPattern(5, -0.6));
public void testSelfSub() {
LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));
LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));
l1.selfSub(l2);
checkMatrix(l1, new BilinearPattern(1, 0.2));
public void testDeterminant() {
LowerTriangularMatrix l = buildMatrix(4, new ElementPattern() {
public double value(int i, int j) {
return (i == j) ? 2.0 : 1.0;
assertTrue(Math.abs(l.getDeterminant(1.0e-10) - Math.pow(2.0, l.getRows()))
< 1.0e-10);
public void testSolve()
throws SingularMatrixException {
LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {
public double value(int i, int j) {
return 1.0;
GeneralMatrix b = new GeneralMatrix(l.getRows(), 3);
for (int i = 0; i < b.getRows(); ++i) {
b.setElement(i, 0, i + 1.0);
b.setElement(i, 1, (i + 1.0) * (i + 2.0) / 2.0);
b.setElement(i, 2, 0.0);
Matrix result = l.solve(b, 1.0e-10);
assertTrue(result.getRows() == b.getRows());
assertTrue(result.getColumns() == b.getColumns());
for (int i = 0; i < result.getRows(); ++i) {
assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);
boolean gotIt = false;
l.setElement(3, 3, 0.0);
l.solve(b, 1.0e-10);
gotIt = true;
assertTrue(gotIt);
public void testInverse()
throws SingularMatrixException {
LowerTriangularMatrix l = buildMatrix(5, new ElementPattern() {
public double value(int i, int j) {
return 1.0;
Matrix inverse = l.getInverse(1.0e-10);
assertTrue(inverse instanceof LowerTriangularMatrix);
checkMatrix(inverse, new ElementPattern() {
public double value(int i, int j) {
return (i == j) ? 1.0 : ((i == j + 1) ? -1.0 : 0.0);
public static Test suite() {
return new TestSuite(LowerTriangularMatrixTest.class);
public interface ElementPattern {
public double value(int i, int j);
private static class BilinearPattern implements ElementPattern {
public BilinearPattern(double coeffI, double coeffJ) {
this.coeffI = coeffI;
this.coeffJ = coeffJ;
public double value(int i, int j) {
return coeffI * i + coeffJ * j;
private final double coeffI;
private final double coeffJ;
public LowerTriangularMatrix buildMatrix(int order,
ElementPattern pattern) {
LowerTriangularMatrix m = new LowerTriangularMatrix(order);
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j <= i; ++j) {
m.setElement(i, j, pattern.value(i, j));
return m;
public void checkMatrix(Matrix m, ElementPattern pattern) {
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j) {
double expected = (j <= i) ? pattern.value(i, j) : 0.0;
assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);
package org.spaceroots.mantissa.linalg;
public class GeneralSquareMatrixTest
extends TestCase {
public GeneralSquareMatrixTest(String name) {
super(name);
public void testDimensions() {
GeneralSquareMatrix m = new GeneralSquareMatrix(3);
assertTrue(m.getRows() == 3);
assertTrue(m.getColumns() == 3);
public void testInvalidDimensions() {
boolean gotIt;
gotIt = false;
new GeneralSquareMatrix(0);
gotIt = true;
assertTrue(gotIt);
gotIt = false;
new GeneralSquareMatrix(-3, null);
gotIt = true;
assertTrue(gotIt);
public void testElements() {
Matrix m = buildMatrix(5, new BilinearPattern(1.0, 0.01));
checkMatrix(m, new BilinearPattern(1.0, 0.01));
public void testCopy() {
GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));
GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = 0; j < m1.getColumns(); ++j) {
m1.setElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix(m2, new BilinearPattern(1.0, 0.01));
public void testDuplicate() {
GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));
Matrix m2 = m1.duplicate();
assertTrue(m2 instanceof GeneralSquareMatrix);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = 0; j < m1.getColumns(); ++j) {
m1.setElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix(m2, new BilinearPattern(1.0, 0.01));
public void testSelfAdd() {
GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));
GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));
m1.selfAdd(m2);
checkMatrix(m1, new BilinearPattern(3, -0.02));
public void testSelfSub() {
GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));
GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));
m1.selfSub(m2);
checkMatrix(m1, new BilinearPattern(-1, 0.04));
public void testDeterminant() {
GeneralSquareMatrix m1 = buildProblem1().a;
assertTrue(Math.abs(m1.getDeterminant(1.0e-10) - 6.0) < 1.0e-10);
GeneralSquareMatrix m2 = buildProblem2().a;
assertTrue(Math.abs(m2.getDeterminant(1.0e-10) + 0.9999999) < 1.0e-10);
GeneralSquareMatrix m3 = buildProblem3().a;
assertTrue(Math.abs(m3.getDeterminant(1.0e-10) - 0.0) < 1.0e-10);
public void testSolve()
throws SingularMatrixException {
LinearProblem p;
Matrix result;
p = buildProblem1();
result = p.a.solve(p.b, 1.0e-10);
checkSolve(p, result);
p = buildProblem2();
result = p.a.solve(p.b, 1.0e-10);
checkSolve(p, result);
p = buildProblem3();
result = p.a.solve(p.b, 1.0e-10);
fail("got " + result + ", should have caught an exception");
fail("wrong exception caught: " + e.getMessage());
public void testInverse()
throws SingularMatrixException {
SquareMatrix a, inverse;
a = buildProblem1().a;
inverse = a.getInverse(1.0e-10);
checkMatrix(a.mul(inverse), new IdentityPattern());
a = buildProblem2().a;
inverse = a.getInverse(1.0e-10);
checkMatrix(a.mul(inverse), new IdentityPattern());
a = buildProblem3().a;
inverse = a.getInverse(1.0e-10);
fail("got " + inverse + ", should have caught an exception");
fail("wrong exception caught: " + e.getMessage());
public static Test suite() {
return new TestSuite(GeneralSquareMatrixTest.class);
private interface ElementPattern {
public double value(int i, int j);
private static class BilinearPattern implements ElementPattern {
public BilinearPattern(double coeffI, double coeffJ) {
this.coeffI = coeffI;
this.coeffJ = coeffJ;
public double value(int i, int j) {
return coeffI * i + coeffJ * j;
private final double coeffI;
private final double coeffJ;
private static class IdentityPattern implements ElementPattern {
public double value(int i, int j) {
return (i == j) ? 1.0 : 0.0;
public GeneralSquareMatrix buildMatrix(int order,
ElementPattern pattern) {
GeneralSquareMatrix m = new GeneralSquareMatrix(order);
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j){
m.setElement(i, j, pattern.value(i, j));
return m;
public void checkMatrix(Matrix m, ElementPattern pattern) {
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j) {
assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))
< 1.0e-10);
private static class LinearProblem {
public GeneralSquareMatrix a;
public Matrix              x;
public Matrix              b;
public LinearProblem(GeneralSquareMatrix a, Matrix x, Matrix b) {
this.a = a;
this.x = x;
this.b = b;
private LinearProblem buildProblem1() {
GeneralSquareMatrix a = new GeneralSquareMatrix(4);
a.setElement(0, 0,   2.0);
a.setElement(0, 1,   1.0);
a.setElement(0, 2,   0.0);
a.setElement(0, 3,   4.0);
a.setElement(1, 0,  -4.0);
a.setElement(1, 1,  -2.0);
a.setElement(1, 2,   3.0);
a.setElement(1, 3,  -7.0);
a.setElement(2, 0,   4.0);
a.setElement(2, 1,   1.0);
a.setElement(2, 2,  -2.0);
a.setElement(2, 3,   8.0);
a.setElement(3, 0,   0.0);
a.setElement(3, 1,  -3.0);
a.setElement(3, 2, -12.0);
a.setElement(3, 3,  -1.0);
GeneralMatrix x = new GeneralMatrix(4, 1);
x.setElement(0, 0,  3.0);
x.setElement(1, 0,  4.0);
x.setElement(2, 0, -1.0);
x.setElement(3, 0, -2.0);
GeneralMatrix b = new GeneralMatrix(4, 1);
b.setElement(0, 0,  2.0);
b.setElement(1, 0, -9.0);
b.setElement(2, 0,  2.0);
b.setElement(3, 0,  2.0);
return new LinearProblem(a, x, b);
private LinearProblem buildProblem2()
double epsilon = 1.0e-7;
GeneralSquareMatrix a = new GeneralSquareMatrix(2);
a.setElement(0, 0, epsilon);
a.setElement(0, 1, 1.0);
a.setElement(1, 0, 1.0);
a.setElement(1, 1, 1.0);
GeneralMatrix x = new GeneralMatrix(2, 2);
x.setElement(0, 0, 1.0 + epsilon);
x.setElement(1, 0, 1.0 - epsilon);
x.setElement(0, 1, epsilon);
x.setElement(1, 1, 1.0);
GeneralMatrix b = new GeneralMatrix(2, 2);
b.setElement(0, 0, 1.0 + epsilon * epsilon);
b.setElement(1, 0, 2.0);
b.setElement(0, 1, 1.0 + epsilon * epsilon);
b.setElement(1, 1, 1.0 + epsilon);
return new LinearProblem(a, x, b);
private LinearProblem buildProblem3 ()
GeneralSquareMatrix a = new GeneralSquareMatrix(3);
a.setElement(0, 0,  1.0);
a.setElement(0, 1,  2.0);
a.setElement(0, 1, -3.0);
a.setElement(1, 0,  2.0);
a.setElement(1, 1,  1.0);
a.setElement(1, 1,  3.0);
a.setElement(2, 0, -3.0);
a.setElement(2, 1,  0.0);
a.setElement(2, 1, -9.0);
GeneralMatrix x = new GeneralMatrix(3, 1);
GeneralMatrix b = new GeneralMatrix(3, 1);
return new LinearProblem(a, x, b);
private void checkSolve(LinearProblem p, Matrix result)
Matrix residual = p.a.mul(result).sub(p.b);
for (int i = 0; i < residual.getRows(); ++i) {
for (int j = 0; j < residual.getColumns(); ++j) {
assertTrue(Math.abs(residual.getElement(i, j)) < 1.0e-10);
for (int i = 0; i < result.getRows(); ++i) {
for (int j = 0; j < result.getColumns(); ++j) {
assertTrue(Math.abs(result.getElement(i, j) - p.x.getElement(i, j))
< 1.0e-10);
package org.spaceroots.mantissa.linalg;
public class DiagonalMatrixTest
extends TestCase {
public DiagonalMatrixTest(String name) {
super(name);
public void testConstantDiagonal() {
checkMatrix(new DiagonalMatrix(5, 2.7), 2.7);
public void testNoSetOutsideOfDiagonal() {
DiagonalMatrix d = new DiagonalMatrix(4);
for (int i = 0; i < d.getRows(); ++i) {
for (int j = 0; j < d.getColumns(); ++j) {
if (i == j) {
d.setElement(i, j, 2.7);
boolean gotIt = false;
d.setElement(i, j, -1.3);
gotIt = true;
assertTrue(gotIt);
checkMatrix(d, 2.7);
public void testCopy() {
DiagonalMatrix d1 = new DiagonalMatrix(7, 4.3);
DiagonalMatrix d2 = new DiagonalMatrix(d1);
for (int i = 0; i < d1.getRows(); ++i) {
d1.setElement(i, i, -1.0);
assertTrue(d2.getRows() == d1.getRows());
assertTrue(d2.getColumns() == d1.getColumns());
checkMatrix(d2, 4.3);
public void testDuplicate() {
DiagonalMatrix d1 = new DiagonalMatrix(6, -8.8);
Matrix d2 = d1.duplicate();
assertTrue(d2 instanceof DiagonalMatrix);
for (int i = 0; i < d1.getRows(); ++i) {
d1.setElement(i, i, -1.0);
assertTrue(d2.getRows() == d1.getRows());
assertTrue(d2.getColumns() == d1.getColumns());
checkMatrix(d2, -8.8);
public void testTranspose() {
DiagonalMatrix d = new DiagonalMatrix(5, 3.4);
Matrix transposed = d.getTranspose();
assertTrue(transposed instanceof DiagonalMatrix);
checkMatrix(transposed, 3.4);
public void testDeterminant() {
double expected;
expected = 1.0;
for (int k = 1; k < 10; ++k) {
expected *= 2;
DiagonalMatrix d = new DiagonalMatrix(k, 2.0);
assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);
expected = 1.0;
for (int k = 1; k < 10; ++k) {
expected *= k;
DiagonalMatrix d = new DiagonalMatrix(k);
for (int i = 0; i < k; ++i) {
d.setElement(i, i, i + 1);
assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);
public void testSolve()
throws SingularMatrixException {
DiagonalMatrix d = new DiagonalMatrix(6);
for (int i = 0; i < d.getRows(); ++i) {
d.setElement(i, i, i + 1.0);
GeneralMatrix b = new GeneralMatrix(6, 3);
for (int i = 0; i < b.getRows(); ++i) {
b.setElement(i, 0, i + 1.0);
b.setElement(i, 1, (i + 1.0) * (i + 1.0));
b.setElement(i, 2, 0.0);
Matrix result = d.solve(b, 1.0e-10);
assertTrue(result.getRows() == b.getRows());
assertTrue(result.getColumns() == b.getColumns());
for (int i = 0; i < result.getRows(); ++i) {
assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);
boolean gotIt = false;
d.setElement(3, 3, 0.0);
d.solve(b, 1.0e-10);
gotIt = true;
assertTrue(gotIt);
public void testInverse()
throws SingularMatrixException {
DiagonalMatrix d = new DiagonalMatrix(4);
for (int i = 0; i < d.getRows (); ++i) {
d.setElement(i, i, i + 1.0);
Matrix inverse = d.getInverse(1.0e-10);
assertTrue(inverse instanceof DiagonalMatrix);
for (int i = 0; i < inverse.getRows(); ++i) {
assertTrue(Math.abs(inverse.getElement(i, i) - 1.0 / (i + 1.0)) < 1.0e-10);
public static Test suite() {
return new TestSuite(DiagonalMatrixTest.class);
public void checkMatrix(Matrix d, double value) {
for (int i = 0; i < d.getRows(); ++i) {
for (int j = 0; j < d.getColumns(); ++j) {
double expected = (i == j) ? value : 0.0;
assertTrue(Math.abs(d.getElement(i, j) - expected) < 1.0e-10);
package org.spaceroots.mantissa.linalg;
public class UpperTriangularMatrixTest
extends TestCase {
public UpperTriangularMatrixTest(String name) {
super(name);
public void testNoSetOutsideOfUpperTriangle() {
UpperTriangularMatrix u = new UpperTriangularMatrix(4);
for (int i = 0; i < u.getRows(); ++i) {
for (int j = 0; j < u.getColumns(); ++j) {
if (i <= j) {
u.setElement(i, j, i + 0.1 * j);
boolean gotIt = false;
u.setElement(i, j, -1.3);
gotIt = true;
assertTrue(gotIt);
checkMatrix(u, new BilinearPattern(1.0, 0.1));
public void testCopy() {
UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));
UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);
checkMatrix(u2, new BilinearPattern(1.0, 0.1));
public void testDuplicate() {
UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));
Matrix u2 = u1.duplicate();
assertTrue(u2 instanceof UpperTriangularMatrix);
checkMatrix(u2, new BilinearPattern(1.0, 0.1));
public void testTranspose() {
UpperTriangularMatrix u = buildMatrix(7, new BilinearPattern(1.0, 0.1));
Matrix transposed = u.getTranspose();
assertTrue(transposed instanceof LowerTriangularMatrix);
for (int i = 0; i < transposed.getRows(); ++i){
for (int j = 0; j < transposed.getColumns(); ++j) {
double expected = (i < j) ? 0.0 : (j + 0.1 * i);
assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);
public void testSelfAdd() {
UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));
UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));
u1.selfAdd(u2);
checkMatrix(u1, new BilinearPattern(5, -0.6));
public void testSelfSub() {
UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));
UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));
u1.selfSub(u2);
checkMatrix(u1, new BilinearPattern(1, 0.2));
public void testDeterminant() {
UpperTriangularMatrix u = buildMatrix(4, new ElementPattern() {
public double value(int i, int j) {
return (i == j) ? 2.0 : 1.0;
assertTrue(Math.abs(u.getDeterminant(1.0e-10) - Math.pow(2.0, u.getRows()))
< 1.0e-10);
public void testSolve()
throws SingularMatrixException {
int rows = 7;
UpperTriangularMatrix u = buildMatrix(rows, new ElementPattern() {
public double value(int i, int j) {
return 1.0;
GeneralMatrix b = new GeneralMatrix(rows, 3);
for (int i = 0; i < rows; ++i) {
b.setElement(i, 0, rows - i);
b.setElement(i, 1, (rows - i) * (rows + 1 - i) / 2.0);
b.setElement(i, 2, 0.0);
Matrix result = u.solve(b, 1.0e-10);
assertTrue(result.getRows() == b.getRows());
assertTrue(result.getColumns() == b.getColumns());
for (int i = 0; i < result.getRows(); ++i) {
assertTrue(Math.abs(result.getElement(i, 0) - 1.0)        < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 1) - (rows - i)) < 1.0e-10);
assertTrue(Math.abs(result.getElement(i, 2) - 0.0)        < 1.0e-10);
boolean gotIt = false;
u.setElement(3, 3, 0.0);
u.solve(b, 1.0e-10);
gotIt = true;
assertTrue(gotIt);
public void testInverse()
throws SingularMatrixException {
UpperTriangularMatrix u = buildMatrix(5, new ElementPattern() {
public double value(int i, int j) {
return 1.0;
Matrix inverse = u.getInverse(1.0e-10);
assertTrue(inverse instanceof UpperTriangularMatrix);
checkMatrix(inverse, new ElementPattern() {
public double value(int i, int j) {
return (i == j) ? 1.0 : ((i == j - 1) ? -1.0 : 0.0);
public static Test suite() {
return new TestSuite(UpperTriangularMatrixTest.class);
public interface ElementPattern {
public double value(int i, int j);
private static class BilinearPattern implements ElementPattern {
public BilinearPattern(double coeffI, double coeffJ) {
this.coeffI = coeffI;
this.coeffJ = coeffJ;
public double value(int i, int j) {
return coeffI * i + coeffJ * j;
private final double coeffI;
private final double coeffJ;
public UpperTriangularMatrix buildMatrix(int order,
ElementPattern pattern) {
UpperTriangularMatrix m = new UpperTriangularMatrix (order);
for (int i = 0; i < m.getRows(); ++i) {
for (int j = i; j < m.getColumns(); ++j) {
m.setElement(i, j, pattern.value(i, j));
return m;
public void checkMatrix(Matrix m, ElementPattern pattern) {
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j) {
double expected = (i <= j) ? pattern.value(i, j) : 0.0;
assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);
package org.spaceroots.mantissa.linalg;
public class NonNullRangeTest
extends TestCase {
public NonNullRangeTest(String name) {
super(name);
public void testPublicAttributes() {
NonNullRange r = new NonNullRange(2, 7);
assertTrue(r.begin == 2);
assertTrue(r.end   == 7);
public void testCopy() {
NonNullRange r1 = new NonNullRange(2, 7);
NonNullRange r2 = new NonNullRange(r1);
assertTrue(r2.begin == r1.begin);
assertTrue(r1.end   == r1.end);
public void testIntersection() {
NonNullRange r1 = new NonNullRange(-4, 8);
NonNullRange r2 = new NonNullRange(3, 12);
NonNullRange r3 = NonNullRange.intersection(r1, r2);
assertTrue(r3.begin == 3);
assertTrue(r3.end   == 8);
public void testReunion() {
NonNullRange r1 = new NonNullRange(-4, 8);
NonNullRange r2 = new NonNullRange(3, 12);
NonNullRange r3 = NonNullRange.reunion(r1, r2);
assertTrue(r3.begin == -4);
assertTrue(r3.end   == 12);
public static Test suite() {
return new TestSuite(NonNullRangeTest.class);
package org.spaceroots.mantissa.linalg;
public class SymetricalMatrixTest
extends TestCase {
public SymetricalMatrixTest(String name) {
super(name);
public void testBuildWAAt() {
double[] a = { 1.0, 2.0, 3.0 };
SymetricalMatrix s = new SymetricalMatrix(0.99, a);
checkMatrix(s, new ElementPattern() {
public double value(int i, int j) {
return 0.99 * (i + 1) * (j + 1);
public void testNoSetOutsideOfDiagonal() {
SymetricalMatrix s = new SymetricalMatrix(4);
for (int i = 0; i < s.getRows(); ++i) {
for (int j = 0; j < s.getColumns(); ++j) {
if (i == j) {
s.setElement(i, j, 0.5);
boolean gotIt = false;
s.setElement
(i, j, -1.3);
gotIt = true;
assertTrue(gotIt);
checkMatrix(s, new ElementPattern() {
public double value(int i, int j) {
return (i == j) ? 0.5 : 0.0;
public void testSetElementAndSymetricalElement() {
SymetricalMatrix s = new SymetricalMatrix(5);
s.setElementAndSymetricalElement(1, 2, 3.4);
assertTrue(Math.abs(s.getElement(1, 2) - 3.4) < 1.0e-10);
assertTrue(Math.abs(s.getElement(2, 1) - 3.4) < 1.0e-10);
public void testCopy() {
SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {
public double value(int i, int j) {
return i * i + j * j;
SymetricalMatrix m2 = new SymetricalMatrix(m1);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = i; j < m1.getColumns(); ++j) {
m1.setElementAndSymetricalElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix(m2, new ElementPattern() {
public double value(int i, int j) {
return i * i + j * j;
public void testDuplicate() {
SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {
public double value(int i, int j) {
return i * j;
Matrix m2 = m1.duplicate();
assertTrue(m2 instanceof SymetricalMatrix);
for (int i = 0; i < m1.getRows(); ++i) {
for (int j = i; j < m1.getColumns(); ++j) {
m1.setElementAndSymetricalElement(i, j, -1.0);
assertTrue(m2.getRows() == m1.getRows());
assertTrue(m2.getColumns() == m1.getColumns());
checkMatrix(m2, new ElementPattern() {
public double value(int i, int j) {
return i * j;
public void testSelfAdd() {
double[] a1 = { 2.0, 4.0, 8.0, 16.0 };
SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);
double[] a2 = { 3.0, 9.0, 27.0, 81.0 };
SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);
s1.selfAdd(s2);
checkMatrix(s1, new ElementPattern() {
public double value(int i, int j) {
return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)
+ Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);
public void testSelfSub() {
double[] a1 = { 2.0, 4.0, 8.0, 16.0 };
SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);
double[] a2 = { 3.0, 9.0, 27.0, 81.0 };
SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);
s1.selfSub(s2);
checkMatrix(s1, new ElementPattern() {
public double value(int i, int j) {
return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)
- Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);
public void testSelfAddWAAt() {
SymetricalMatrix s = new SymetricalMatrix(3);
double[] a1 = { 1.0, 2.0, 3.0 };
s.selfAddWAAt(1.0, a1);
double[] a2 = { 0.1, 0.2, 0.3 };
s.selfAddWAAt(2.0, a2);
checkMatrix(s, new ElementPattern() {
public double value(int i, int j) {
return 1.02 * (i + 1) * (j + 1);
public void testSingular()
throws SingularMatrixException {
SymetricalMatrix s = new SymetricalMatrix(3);
double[] a1 = { 1.0, 2.0, 3.0 };
s.selfAddWAAt(1.0, a1);
double[] a2 = { 0.1, 0.2, 0.3 };
s.selfAddWAAt(2.0, a2);
Matrix b = new GeneralMatrix(3, 1);
b.setElement(0, 0,  6.12);
b.setElement(1, 0, 12.24);
b.setElement(2, 0, 18.36);
boolean gotIt = false;
s.solve(b, 1.0e-10);
gotIt = true;
assertTrue(gotIt);
public void testSolve()
throws SingularMatrixException {
SymetricalMatrix s = new SymetricalMatrix(3);
double[] a1 = { 1.0, 2.0, 3.0 };
s.selfAddWAAt(1.0, a1);
double[] a2 = { 0.1, 0.2, 0.3 };
s.selfAddWAAt(2.0, a2);
double[] a3 = { 1.2, -3.0, 2.1 };
s.selfAddWAAt(3.0, a3);
double[] a4 = { 0.4, 0.1, 3.1 };
s.selfAddWAAt(2.0, a4);
Matrix b = new GeneralMatrix(3, 1);
b.setElement(0, 0, 10.08);
b.setElement(1, 0, 10.26);
b.setElement(2, 0, 42.57);
Matrix x = s.solve(b, 1.0e-10);
checkMatrix (x, new ElementPattern() {
public double value(int i, int j) {
return 1.0;
assertTrue(Math.abs(s.getDeterminant(1.0e-10) - 782.846532) < 1.0e-10);
public static Test suite() {
return new TestSuite(SymetricalMatrixTest.class);
public interface ElementPattern {
public double value(int i, int j);
public SymetricalMatrix buildMatrix(int order,
ElementPattern pattern) {
SymetricalMatrix m = new SymetricalMatrix(order);
for (int i = 0; i < m.getRows(); ++i) {
for (int j = i; j < m.getColumns(); ++j) {
m.setElementAndSymetricalElement(i, j, pattern.value(i, j));
return m;
public void checkMatrix(Matrix m, ElementPattern pattern) {
for (int i = 0; i < m.getRows(); ++i) {
for (int j = 0; j < m.getColumns(); ++j) {
assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))
< 1.0e-10);
package org.spaceroots.mantissa.quadrature;
public class AllTests
public static Test suite ()
TestSuite suite= new TestSuite ("org.spaceroots.mantissa.quadrature"); 
suite.addTest (org.spaceroots.mantissa.quadrature.scalar.AllTests.suite ());
suite.addTest (org.spaceroots.mantissa.quadrature.vectorial.AllTests.suite ());
return suite; 
package org.spaceroots.mantissa.quadrature.vectorial;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.quadrature.vectorial"); 
suite.addTest(GaussLegendreIntegratorTest.suite());
return suite; 
package org.spaceroots.mantissa.quadrature.vectorial;
public class GaussLegendreIntegratorTest
extends TestCase {
public GaussLegendreIntegratorTest(String name) {
super(name);
public void testExactIntegration()
throws FunctionException {
Random random = new Random(86343623467878363l);
int order = 0;
while (true) {
GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,
7.0);
int availableOrder = integrator.getEvaluationsPerStep();
if (availableOrder < order) {
return;
for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {
for (int i = 0; i < 10; ++i) {
Polynom p = new Polynom(degree, random, 100.0);
double[] s0 = integrator.integrate(p, -5.0, 15.0);
double[] s1 = p.exactIntegration(-5.0, 15.0);
for (int j = 0; j < p.getDimension(); ++j) {
assertTrue(Math.abs(s0[j] - s1[j]) < 1.0e-12 * (1.0 + Math.abs(s0[j])));
++order;
public static Test suite() {
return new TestSuite(GaussLegendreIntegratorTest.class);
private static class Polynom implements ComputableFunction {
public Polynom (int degree, Random random, double max) {
coeffs0 = new double[degree + 1];
coeffs1 = new double[degree + 1];
for (int i = 0; i <= degree; ++i) {
coeffs0[i] = 2.0 * max * (random.nextDouble() - 0.5);
coeffs1[i] = 2.0 * max * (random.nextDouble() - 0.5);
public int getDimension() {
return 2;
public double[] valueAt(double t)
throws FunctionException {
double[] y = new double[2];
y[0] = coeffs0[coeffs0.length - 1];
for (int i = coeffs0.length - 2; i >= 0; --i) {
y[0] = y[0] * t + coeffs0[i];
y[1] = coeffs1 [coeffs1.length - 1];
for (int i = coeffs1.length - 2; i >= 0; --i) {
y[1] = y[1] * t + coeffs1[i];
return y;
public double[] exactIntegration(double a, double b)
throws FunctionException {
double[] res = new double[2];
double yb = coeffs0[coeffs0.length - 1] / coeffs0.length;
double ya = yb;
for (int i = coeffs0.length - 2; i >= 0; --i) {
yb = yb * b + coeffs0[i] / (i + 1);
ya = ya * a + coeffs0[i] / (i + 1);
res[0] = yb * b - ya * a;
yb = coeffs1[coeffs1.length - 1] / coeffs1.length;
ya = yb;
for (int i = coeffs1.length - 2; i >= 0; --i) {
yb = yb * b + coeffs1[i] / (i + 1);
ya = ya * a + coeffs1[i] / (i + 1);
res[1] = yb * b - ya * a;
return res;
private double[] coeffs0;
private double[] coeffs1;
private static final long serialVersionUID = -8032020368915042278L;
package org.spaceroots.mantissa.quadrature.scalar;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.quadrature.scalar"); 
suite.addTest(GaussLegendreIntegratorTest.suite());
return suite; 
package org.spaceroots.mantissa.quadrature.scalar;
public class GaussLegendreIntegratorTest
extends TestCase {
public GaussLegendreIntegratorTest(String name) {
super(name);
public void testExactIntegration()
throws FunctionException {
Random random = new Random(86343623467878363l);
int order = 0;
while (true) {
GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,
7.0);
int availableOrder = integrator.getEvaluationsPerStep();
if (availableOrder < order) {
return;
for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {
for (int i = 0; i < 10; ++i) {
Polynom p = new Polynom(degree, random, 100.0);
double s0 = integrator.integrate(p, -5.0, 15.0);
double s1 = p.exactIntegration(-5.0, 15.0);
assertTrue(Math.abs(s0 - s1) < 1.0e-12 * (1.0 + Math.abs(s0)));
++order;
public static Test suite() {
return new TestSuite(GaussLegendreIntegratorTest.class);
private static class Polynom implements ComputableFunction {
public Polynom(int degree, Random random, double max) {
coeffs = new double[degree + 1];
for (int i = 0; i <= degree; ++i) {
coeffs[i] = 2.0 * max * (random.nextDouble() - 0.5);
public double valueAt(double t)
throws FunctionException {
double y = coeffs[coeffs.length - 1];
for (int i = coeffs.length - 2; i >= 0; --i) {
y = y * t + coeffs[i];
return y;
public double exactIntegration(double a, double b)
throws FunctionException {
double yb = coeffs[coeffs.length - 1] / coeffs.length;
double ya = yb;
for (int i = coeffs.length - 2; i >= 0; --i) {
yb = yb * b + coeffs[i] / (i + 1);
ya = ya * a + coeffs[i] / (i + 1);
return yb * b - ya * a;
private double[] coeffs;
private static final long serialVersionUID = -7304282612679254557L;
package org.spaceroots.mantissa.utilities;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.utilities"); 
suite.addTest(ArrayMapperTest.suite());
suite.addTest(MappableArrayTest.suite());
suite.addTest(MappableScalarTest.suite());
suite.addTest(IntervalTest.suite());
suite.addTest(IntervalsListTest.suite());
return suite; 
package org.spaceroots.mantissa.utilities;
public class IntervalTest
extends TestCase {
public IntervalTest(String name) {
super(name);
public void test1() {
check(new Interval(-10.0, 10.0), new Interval(11.0, 12.0), 2.5,
true, false, false,
new Interval(-10.0, 12.0), new Interval(11.0, 11.0));
public void test2() {
check(new Interval(-10.0, 10.0), new Interval(9.0, 12.0), 50.0,
false, false, true,
new Interval(-10.0, 12.0), new Interval(9.0, 10.0));
public void test3() {
check(new Interval(-10.0, 10.0), new Interval(-12.0, -11.0), 0.0,
true, false, false,
new Interval(-12.0, 10.0), new Interval(-10.0, -10.0));
public void test4() {
check(new Interval(-10.0, 10.0), new Interval(-4.0, 5.0), 0.0,
true, true, true,
new Interval(-10.0, 10.0), new Interval(-4.0, 5.0));
public void test5() {
check(new Interval(-10.0, 10.0), new Interval(-10.0, 10.0), 0.0,
true, true, true,
new Interval(-10.0, 10.0), new Interval(-10.0, 10.0));
private void check(Interval i1, Interval i2, double x,
boolean b1, boolean b2, boolean b3,
Interval add, Interval inter) {
assertTrue(i1.contains(x)    ^ (!b1));
assertTrue(i1.contains(i2)   ^ (!b2));
assertTrue(i1.intersects(i2) ^ (!b3));
assertEquals(add.getInf(), Interval.add(i1, i2).getInf(), 1.0e-10);
assertEquals(add.getSup(), Interval.add(i1, i2).getSup(), 1.0e-10);
assertEquals(inter.getInf(), Interval.intersection(i1, i2).getInf(), 1.0e-10);
assertEquals(inter.getSup(), Interval.intersection(i1, i2).getSup(), 1.0e-10);
Interval ia = new Interval(i1);
ia.addToSelf(i2);
assertEquals(add.getInf(), ia.getInf(), 1.0e-10);
assertEquals(add.getSup(), ia.getSup(), 1.0e-10);
Interval ib = new Interval(i1);
ib.intersectSelf(i2);
assertEquals(inter.getInf(), ib.getInf(), 1.0e-10);
assertEquals(inter.getSup(), ib.getSup(), 1.0e-10);
public static Test suite() {
return new TestSuite(IntervalTest.class);
package org.spaceroots.mantissa.utilities;
public class IntervalsListTest
extends TestCase {
public IntervalsListTest(String name) {
super(name);
public void testAddBetween() {
IntervalsList il =
new IntervalsList (new Interval(10, 20), new Interval(50, 60));
il.addToSelf(new Interval(30, 40));
checkEquals(new Interval[] {
new Interval(10, 20),
new Interval(30, 40),
new Interval(50, 60)
public void testAddReducingLastHole() {
IntervalsList il =
new IntervalsList (new Interval(10, 20), new Interval(50, 60));
il.addToSelf(new Interval(30, 55));
checkEquals(new Interval[] {
new Interval(10, 20),
new Interval(30, 60)
public void test1() {
IntervalsList list1 = new IntervalsList(-2.0, -1.0);
IntervalsList list2 = new IntervalsList(new Interval(-0.9, -0.8));
check(list1, list2, 2.5,
true, false, 1, true, false, 1, false,
new Interval[] { new Interval(-2.0, -1.0),
new Interval(-0.9, -0.8) },
new Interval[0]);
list2.addToSelf(new Interval(1.0, 3.0));
check(list1, list2, 2.5,
true, false, 1, false, false, 2, false,
new Interval[] { new Interval(-2.0, -1.0),
new Interval(-0.9, -0.8),
new Interval( 1.0,  3.0) },
new Interval[0]);
list1.addToSelf(new Interval(-1.2, 0.0));
check(list1, list2, -1.1,
true, false, 1, false, false, 2, true,
new Interval[] { new Interval(-2.0,  0.0),
new Interval( 1.0,  3.0) },
new Interval[] { new Interval(-0.9, -0.8) });
IntervalsList list = new IntervalsList(new Interval(-10.0, -8.0));
list.addToSelf(new Interval(-6.0, -4.0));
list.addToSelf(new Interval(-0.85, 1.2));
list1.addToSelf(list);
check(list1, list2, 0,
false, false, 3, false, false, 2, true,
new Interval[] { new Interval(-10.0, -8.0),
new Interval( -6.0, -4.0),
new Interval( -2.0,  3.0) },
new Interval[] { new Interval( -0.9, -0.8),
new Interval(  1.0,  1.2) });
private void check(IntervalsList l1, IntervalsList l2, double x,
boolean b1, boolean b2, int i1,
boolean b3, boolean b4, int i2,
boolean b5, Interval[] add, Interval[] inter) {
assertTrue(l1.isConnex()     ^ (!b1));
assertTrue(l1.isEmpty()      ^ (!b2));
assertEquals(i1, l1.getIntervals().size());
assertTrue(l2.isConnex()     ^ (!b3));
assertTrue(l2.isEmpty()      ^ (!b4));
assertEquals(i2, l2.getIntervals().size());
assertTrue(l1.contains(x)    ^ (!b5));
checkEquals(add,   IntervalsList.add(l1, l2));
checkEquals(inter, IntervalsList.intersection(l1, l2));
private void checkEquals(Interval[] sa, IntervalsList sb) {
assertEquals(sa.length, sb.getIntervals().size());
Iterator iterB = sb.getIntervals().iterator();
for (int i = 0; i < sa.length; ++i) {
Interval ib = (Interval) iterB.next();
assertEquals(sa[i].getInf(), ib.getInf(), 1.0e-10);
assertEquals(sa[i].getSup(), ib.getSup(), 1.0e-10);
public static Test suite() {
return new TestSuite(IntervalsListTest.class);
package org.spaceroots.mantissa.utilities;
public class ArrayMapperTest
extends TestCase {
public ArrayMapperTest(String name) {
super(name);
mapper = null;
b1 = null;
b2 = null;
b3 = null;
public void testDimensionCheck() {
int size = b1.getStateDimension();
size += b2.getStateDimension();
size += b3.getStateDimension();
assertTrue(mapper.getDataArray().length == size);
public void testUpdateObjects() {
double[] data = new double [7];
for (int i = 0; i < 7; ++i) {
data [i] = i * 0.1;
mapper.updateObjects(data);
assertTrue(Math.abs(b1.getElement(0) - 0.0) < 1.0e-10);
assertTrue(Math.abs(b2.getElement(0) - 0.4) < 1.0e-10);
assertTrue(Math.abs(b2.getElement(1) - 0.3) < 1.0e-10);
assertTrue(Math.abs(b2.getElement(2) - 0.2) < 1.0e-10);
assertTrue(Math.abs(b2.getElement(3) - 0.1) < 1.0e-10);
assertTrue(Math.abs(b3.getElement(0) - 0.6) < 1.0e-10);
assertTrue(Math.abs(b3.getElement(1) - 0.5) < 1.0e-10);
public void testUpdateArray() {
b1.setElement(0,  0.0);
b2.setElement(0, 40.0);
b2.setElement(1, 30.0);
b2.setElement(2, 20.0);
b2.setElement(3, 10.0);
b3.setElement(0, 60.0);
b3.setElement(1, 50.0);
mapper.updateArray();
double[] data = mapper.getDataArray();
for (int i = 0; i < 7; ++i) {
assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);
public void setUp() {
b1 = new DomainObject(1);
b2 = new DomainObject(4);
b3 = new DomainObject(2);
mapper = new ArrayMapper();
mapper.manageMappable(b1);
mapper.manageMappable(b2);
mapper.manageMappable(b3);
public void tearOff() {
b1 = null;
b2 = null;
b3 = null;
mapper = null;
public static Test suite() {
return new TestSuite(ArrayMapperTest.class);
private static class DomainObject implements ArraySliceMappable {
private double[] data;
public DomainObject(int size) {
data = new double [size];
public int getStateDimension() {
return data.length;
public void mapStateFromArray(int start, double[] array) {
for (int i = 0; i < data.length; ++i) {
data [data.length - 1 - i] = array [start + i];
public void mapStateToArray(int start, double[] array) {
for (int i = 0; i < data.length; ++i) {
array [start + i] = data [data.length - 1 - i];
public double getElement(int i) {
return data [i];
public void setElement(int i, double value) {
data [i] = value;
private DomainObject b1;
private DomainObject b2;
private DomainObject b3;
private ArrayMapper mapper;
package org.spaceroots.mantissa.utilities;
public class MappableArrayTest
extends TestCase {
public MappableArrayTest(String name) {
super(name);
array1 = null;
array2 = null;
array3 = null;
mapper = null;
public void testDimensionCheck() {
assertTrue(mapper.getDataArray().length == 9);
public void testUpdateObjects() {
double[] data = new double [mapper.getDataArray().length];
for (int i = 0; i < data.length; ++i) {
data [i] = i * 0.1;
mapper.updateObjects(data);
double[] a1 = array1.getArray();
assertTrue(Math.abs(a1[0] - 0.0) < 1.0e-10);
assertTrue(Math.abs(a1[1] - 0.1) < 1.0e-10);
assertTrue(Math.abs(a1[2] - 0.2) < 1.0e-10);
assertTrue(Math.abs(a1[3] - 0.3) < 1.0e-10);
double[] a2 = array2.getArray();
assertTrue(Math.abs(a2[0] - 0.4) < 1.0e-10);
assertTrue(Math.abs(a2[1] - 0.5) < 1.0e-10);
double[] a3 = array3.getArray();
assertTrue(Math.abs(a3[0] - 0.6) < 1.0e-10);
assertTrue(Math.abs(a3[1] - 0.7) < 1.0e-10);
assertTrue(Math.abs(a3[2] - 0.8) < 1.0e-10);
public static Test suite() {
return new TestSuite(MappableArrayTest.class);
public void setUp() {
array1 = new MappableArray(4);
array2 = new MappableArray(new double[2]);
array3 = new MappableArray(new double[3]);
mapper = new ArrayMapper();
mapper.manageMappable(array1);
mapper.manageMappable(array2);
mapper.manageMappable(array3);
public void tearDown() {
array1 = null;
array2 = null;
array3 = null;
mapper = null;
private MappableArray array1;
private MappableArray array2;
private MappableArray array3;
private ArrayMapper   mapper;
package org.spaceroots.mantissa.utilities;
public class MappableScalarTest
extends TestCase {
public MappableScalarTest(String name) {
super(name);
mapper  = null;
scalar1 = null;
scalar2 = null;
scalar3 = null;
public void testDimensionCheck() {
assertTrue(mapper.getDataArray().length == 3);
public void testUpdateObjects() {
double[] data = new double [mapper.getDataArray().length];
for (int i = 0; i < data.length; ++i) {
data [i] = i * 0.1;
mapper.updateObjects(data);
assertTrue(Math.abs(scalar1.getValue() - 0.0) < 1.0e-10);
assertTrue(Math.abs(scalar2.getValue() - 0.1) < 1.0e-10);
assertTrue(Math.abs(scalar3.getValue() - 0.2) < 1.0e-10);
public void testUpdateArray() {
scalar1.setValue(00.0);
scalar2.setValue(10.0);
scalar3.setValue(20.0);
mapper.updateArray();
double[] data = mapper.getDataArray();
for (int i = 0; i < data.length; ++i) {
assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);
public static Test suite() {
return new TestSuite(MappableScalarTest.class);
public void setUp() {
scalar1 = new MappableScalar();
scalar2 = new MappableScalar(2);
scalar3 = new MappableScalar(-3);
mapper = new ArrayMapper();
mapper.manageMappable(scalar1);
mapper.manageMappable(scalar2);
mapper.manageMappable(scalar3);
public void tearDown() {
scalar1 = null;
scalar2 = null;
scalar3 = null;
mapper = null;
private MappableScalar scalar1;
private MappableScalar scalar2;
private MappableScalar scalar3;
private ArrayMapper mapper;
package org.spaceroots.mantissa.functions;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions"); 
suite.addTest(org.spaceroots.mantissa.functions.scalar.AllTests.suite()); 
suite.addTest(org.spaceroots.mantissa.functions.vectorial.AllTests.suite()); 
return suite;
package org.spaceroots.mantissa.functions.vectorial;
public class VectorialValuedPairTest
extends TestCase {
public VectorialValuedPairTest(String name) {
super(name);
public void testConstructor() {
double[] tab = new double[2];
tab[0] = -8.4;
tab[1] = -3.2;
VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);
assertTrue(Math.abs(pair.x    - 1.2) < 1.0e-10);
assertTrue(Math.abs(pair.y[0] + 8.4) < 1.0e-10);
assertTrue(Math.abs(pair.y[1] + 3.2) < 1.0e-10);
public void testCopyConstructor() {
double[] tab = new double[2];
tab[0] = -8.4;
tab[1] = -3.2;
VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);
VectorialValuedPair pair2 = new VectorialValuedPair(pair1.x,
pair1.y);
assertTrue(Math.abs(pair2.x    - pair1.x)    < 1.0e-10);
assertTrue(Math.abs(pair2.y[0] - pair1.y[0]) < 1.0e-10);
assertTrue(Math.abs(pair2.y[1] - pair1.y[1]) < 1.0e-10);
assertTrue(Math.abs(pair2.x    - 1.2)        < 1.0e-10);
assertTrue(Math.abs(pair2.y[0] + 8.4)        < 1.0e-10);
assertTrue(Math.abs(pair2.y[1] + 3.2)        < 1.0e-10);
public static Test suite() {
return new TestSuite(VectorialValuedPairTest.class);
package org.spaceroots.mantissa.functions.vectorial;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions.vectorial"); 
suite.addTest(VectorialValuedPairTest.suite()); 
suite.addTest(ComputableFunctionSamplerTest.suite()); 
suite.addTest(BasicSampledFunctionIteratorTest.suite());
return suite; 
package org.spaceroots.mantissa.functions.vectorial;
public class ComputableFunctionSamplerTest
extends TestCase {
public ComputableFunctionSamplerTest(String name) {
super(name);
public void testBeginStepNumber()
throws FunctionException {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 0.099, 11);
assertTrue(sampler.size() == 11);
assertTrue(sampler.getDimension() == 2);
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.495) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.495) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.990) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).x    - 0.990) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 0.990) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 1.980) < 1.0e-10);
public void testRangeNumber()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function (0.0, 1.0), range, 11);
assertTrue(sampler.size() == 11);
assertTrue(sampler.getDimension() == 2);
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).x    - 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 2.0) < 1.0e-10);
public void testRangeStepNoAdjust()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0),
range, 0.083, false);
assertTrue(sampler.size() == 12);
assertTrue(sampler.getDimension() == 2);
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.415) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.415) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.830) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(11).x    - 0.913) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(11).y[0] + 0.913) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(11).y[1] + 1.826) < 1.0e-10);
public void testRangeStepAdjust()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0),
range, 0.083, true);
assertTrue(sampler.size() == 13);
assertTrue(sampler.getDimension() == 2);
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(6).x     - 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(6).y[0]  + 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(6).y[1]  + 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(12).x    - 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(12).y[0] + 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(12).y[1] + 2.0) < 1.0e-10);
public void testOutOfRange()
throws FunctionException {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);
boolean exceptionOccurred = false;
sampler.samplePointAt(-1);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
exceptionOccurred = false;
sampler.samplePointAt(10);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public void testUnderlyingException() {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new ExceptionGeneratingFunction(),
0.0, 0.1, 11);
boolean exceptionOccurred = false;
sampler.samplePointAt(2);
exceptionOccurred = true;
assertTrue(! exceptionOccurred);
exceptionOccurred = false;
sampler.samplePointAt(8);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public static Test suite() {
return new TestSuite(ComputableFunctionSamplerTest.class);
private static class Function
implements ComputableFunction {
private double   min;
private double   max;
private double[] values;
public int getDimension() {
return 2;
public Function(double min, double max) {
this.min = min;
this.max = max;
values   = new double[2];
public double[] valueAt(double x)
throws FunctionException {
if (x < min || x > max) {
throw new FunctionException("outside of range");
values[0] = -x;
values[1] = -2.0 * x;
return values;
private static final long serialVersionUID = -1859103913610458563L;
private static class ExceptionGeneratingFunction
implements ComputableFunction {
public int getDimension() {
return 2;
public double[] valueAt(double x)
throws FunctionException {
if (x < 0.5) {
double[] res = new double[2];
res[0] = -x;
res[1] = -2.0 * x;
return res;
throw new FunctionException("upper half range exception");
private static final long serialVersionUID = 2849780376767626912L;
package org.spaceroots.mantissa.functions.vectorial;
public class BasicSampledFunctionIteratorTest
extends TestCase {
public BasicSampledFunctionIteratorTest(String name) {
super(name);
public void testIteration()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));
for (int i = 0; i < 10; ++i) {
assertTrue(iter.hasNext());
VectorialValuedPair pair = iter.nextSamplePoint();
assertTrue(Math.abs(pair.x    - 0.1 * i) < 1.0e-10);
assertTrue(Math.abs(pair.y[0] + 0.1 * i) < 1.0e-10);
assertTrue(Math.abs(pair.y[1] + 0.2 * i) < 1.0e-10);
public void testExhausted()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));
for (int i = 0; i < 10; ++i) {
assertTrue(iter.hasNext());
iter.nextSamplePoint();
assertTrue(! iter.hasNext());
boolean exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public void testUnderlyingException()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());
boolean exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(! exceptionOccurred);
exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public static Test suite() {
return new TestSuite(BasicSampledFunctionIteratorTest.class);
private static class Function
implements SampledFunction {
private static final long serialVersionUID = -6049535144225908344L;
private double   begin;
private double   step;
private int      n;
private double[] values;
public Function(double begin, double step, int n) {
this.begin  = begin;
this.step   = step;
this.n      = n;
values      = new double[2];
public int size() {
return n;
public int getDimension() {
return 2;
public VectorialValuedPair samplePointAt(int i)
throws FunctionException {
if (i < 0 || i >= n) {
throw new FunctionException("outside of range");
double x = begin + i * step;
values[0] = -x;
values[1] = 2.0 * values[0];
return new VectorialValuedPair(x, values);
private static class ExceptionGeneratingFunction
implements SampledFunction {
private static final long serialVersionUID = 3750401068561053681L;
private boolean fireException = false;
public int size() {
return 2;
public int getDimension() {
return 2;
public VectorialValuedPair samplePointAt(int i)
throws FunctionException {
if (fireException) {
throw new FunctionException("boom");
fireException = true;
return new VectorialValuedPair(0.0, new double[] { 0, 1 });
package org.spaceroots.mantissa.functions.scalar;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions.scalar"); 
suite.addTest(ScalarValuedPairTest.suite()); 
suite.addTest(ComputableFunctionSamplerTest.suite()); 
suite.addTest(BasicSampledFunctionIteratorTest.suite());
return suite; 
package org.spaceroots.mantissa.functions.scalar;
public class ComputableFunctionSamplerTest
extends TestCase {
public ComputableFunctionSamplerTest(String name) {
super(name);
public void testBeginStepNumber()
throws FunctionException {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0),
0.0, 0.099, 11);
assertTrue(sampler.size() == 11);
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.495) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.495) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 0.990) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 0.990) < 1.0e-10);
public void testRangeNumber()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0), range, 11);
assertTrue(sampler.size() == 11);
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 1.0) < 1.0e-10);
public void testRangeStepNoAdjust()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0),
range, 0.083, false);
assertTrue(sampler.size() == 12);
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.415) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.415) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(11).getX() - 0.913) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(11).getY() + 0.913) < 1.0e-10);
public void testRangeStepAdjust()
throws FunctionException {
double[] range = new double[2];
range[0] = 0.0;
range[1] = 1.0;
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0),
range, 0.083, true);
assertTrue(sampler.size() == 13);
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(6).getX()  - 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(6).getY()  + 0.5) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(12).getX() - 1.0) < 1.0e-10);
assertTrue(Math.abs(sampler.samplePointAt(12).getY() + 1.0) < 1.0e-10);
public void testOutOfRange()
throws FunctionException {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);
boolean exceptionOccurred = false;
sampler.samplePointAt(-1);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
exceptionOccurred = false;
sampler.samplePointAt(10);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public void testUnderlyingException() {
ComputableFunctionSampler sampler =
new ComputableFunctionSampler(new ExceptionGeneratingFunction(),
0.0, 0.1, 11);
boolean exceptionOccurred = false;
sampler.samplePointAt(2);
exceptionOccurred = true;
assertTrue(! exceptionOccurred);
exceptionOccurred = false;
sampler.samplePointAt(8);
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public static Test suite() {
return new TestSuite(ComputableFunctionSamplerTest.class);
private static class Function
implements ComputableFunction {
private static final long serialVersionUID = -7173012970400285826L;
private double min;
private double max;
public Function(double min, double max) {
this.min = min;
this.max = max;
public double valueAt(double x)
throws FunctionException {
if (x < min || x > max) {
throw new FunctionException("outside of range");
return -x;
private static class ExceptionGeneratingFunction
implements ComputableFunction {
private static final long serialVersionUID = 7853080602731012102L;
public double valueAt(double x)
throws FunctionException {
if (x < 0.5) {
return -x;
throw new FunctionException("upper half range exception");
package org.spaceroots.mantissa.functions.scalar;
public class ScalarValuedPairTest
extends TestCase {
public ScalarValuedPairTest(String name) {
super(name);
public void testConstructor() {
ScalarValuedPair pair = new ScalarValuedPair(1.2, -8.4);
assertTrue(Math.abs(pair.getX() - 1.2) < 1.0e-10);
assertTrue(Math.abs(pair.getY() + 8.4) < 1.0e-10);
public void testCopyConstructor() {
ScalarValuedPair pair1 = new ScalarValuedPair(1.2, -8.4);
ScalarValuedPair pair2 = new ScalarValuedPair(pair1);
assertTrue(Math.abs(pair2.getX() - pair1.getX()) < 1.0e-10);
assertTrue(Math.abs(pair2.getY() - pair1.getY()) < 1.0e-10);
assertTrue(Math.abs(pair2.getX() - 1.2) < 1.0e-10);
assertTrue(Math.abs(pair2.getY() + 8.4) < 1.0e-10);
public static Test suite() {
return new TestSuite(ScalarValuedPairTest.class);
package org.spaceroots.mantissa.functions.scalar;
public class BasicSampledFunctionIteratorTest
extends TestCase {
public BasicSampledFunctionIteratorTest(String name) {
super(name);
public void testIteration()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));
for (int i = 0; i < 10; ++i) {
assertTrue(iter.hasNext());
ScalarValuedPair pair = iter.nextSamplePoint();
assertTrue(Math.abs(pair.getX() - 0.1 * i) < 1.0e-10);
assertTrue(Math.abs(pair.getY() + 0.1 * i) < 1.0e-10);
public void testExhausted()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));
for (int i = 0; i < 10; ++i) {
assertTrue(iter.hasNext());
iter.nextSamplePoint();
assertTrue(! iter.hasNext());
boolean exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public void testUnderlyingException()
throws ExhaustedSampleException, FunctionException {
BasicSampledFunctionIterator iter =
new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());
boolean exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(! exceptionOccurred);
exceptionOccurred = false;
iter.nextSamplePoint();
exceptionOccurred = true;
assertTrue(exceptionOccurred);
public static Test suite() {
return new TestSuite(BasicSampledFunctionIteratorTest.class);
private static class Function
implements SampledFunction {
private static final long serialVersionUID = -5071329620086891960L;
private double begin;
private double step;
private int    n;
public Function(double begin, double step, int n) {
this.begin = begin;
this.step  = step;
this.n     = n;
public int size() {
return n;
public ScalarValuedPair samplePointAt(int i)
throws FunctionException {
if (i < 0 || i >= n) {
throw new FunctionException("outside of range");
double x = begin + i * step;
return new ScalarValuedPair(x, -x);
private static class ExceptionGeneratingFunction
implements SampledFunction {
private static final long serialVersionUID = 1417147976215668305L;
private boolean fireException = false;
public int size() {
return 2;
public ScalarValuedPair samplePointAt(int i)
throws FunctionException {
if (fireException) {
throw new FunctionException("boom");
fireException = true;
return new ScalarValuedPair(0.0, 0.0);
package org.spaceroots.mantissa.random;
public class AllTests {
public static Test suite() {
TestSuite suite = new TestSuite("org.spaceroots.mantissa.random"); 
suite.addTest(ScalarSampleStatisticsTest.suite());
suite.addTest(VectorialSampleStatisticsTest.suite());
suite.addTest(UniformRandomGeneratorTest.suite()); 
suite.addTest(GaussianRandomGeneratorTest.suite()); 
suite.addTest(UncorrelatedRandomVectorGeneratorTest.suite()); 
suite.addTest(CorrelatedRandomVectorGeneratorTest.suite()); 
return suite; 
package org.spaceroots.mantissa.random;
public class ScalarSampleStatisticsTest
extends TestCase {
public ScalarSampleStatisticsTest(String name) {
super(name);
points = null;
public void testBasicStats() {
ScalarSampleStatistics sample = new ScalarSampleStatistics();
for (int i = 0; i < points.length; ++i) {
sample.add(points[i]);
assertEquals(points.length, sample.size());
assertEquals(-5.0, sample.getMin(), 1.0e-12);
assertEquals(10.4, sample.getMax(), 1.0e-12);
assertEquals( 3.0, sample.getMean(), 1.0e-12);
assertEquals( 3.920034013457876, sample.getStandardDeviation(),
1.0e-12);
public void testAddSample() {
ScalarSampleStatistics all  = new ScalarSampleStatistics();
ScalarSampleStatistics even = new ScalarSampleStatistics();
ScalarSampleStatistics odd  = new ScalarSampleStatistics();
for (int i = 0; i < points.length; ++i) {
all.add(points[i]);
if (i % 2 == 0) {
even.add(points[i]);
odd.add(points[i]);
even.add(odd);
assertEquals(all.size(), even.size());
assertEquals(all.getMin(), even.getMin(), 1.0e-12);
assertEquals(all.getMax(), even.getMax(), 1.0e-12);
assertEquals(all.getMean(), even.getMean(), 1.0e-12);
assertEquals(all.getStandardDeviation(), even.getStandardDeviation(),
1.0e-12);
public void testAddArray() {
ScalarSampleStatistics loop   = new ScalarSampleStatistics();
ScalarSampleStatistics direct = new ScalarSampleStatistics();
for (int i = 0; i < points.length; ++i) {
loop.add(points[i]);
direct.add(points);
assertEquals(loop.size(), direct.size());
assertEquals(loop.getMin(), direct.getMin(), 1.0e-12);
assertEquals(loop.getMax(), direct.getMax(), 1.0e-12);
assertEquals(loop.getMean(), direct.getMean(), 1.0e-12);
assertEquals(loop.getStandardDeviation(), direct.getStandardDeviation(),
1.0e-12);
public void setUp() {
points = new double[] {1.0, 4.2, -5, 4.0, 2.9, 10.4, 0.0, 4.1, 4.2, 4.2};
public void tearDown() {
points = null;
public static Test suite() {
return new TestSuite(ScalarSampleStatisticsTest.class);
private double[] points;
package org.spaceroots.mantissa.algebra;
public class PolynomialDoubleTest
extends TestCase {
public PolynomialDoubleTest(String name) {
super(name);
public void testConstructors() {
Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);
double[] a = p.getCoefficients();
assertEquals(a.length, 3);
assertEquals(-5.0, a[0], 1.0e-12);
assertEquals(3.0,  a[1], 1.0e-12);
assertEquals(1.0,  a[2], 1.0e-12);
assertEquals(p.getDegree(), 2);
assertEquals(1, new Polynomial.Double(0.0, 3.0, 5.0).getDegree());
assertEquals(0, new Polynomial.Double(0.0, 0.0, 5.0).getDegree());
assertEquals(0, new Polynomial.Double(0.0, 0.0, 0.0).getDegree());
assertEquals(1, new Polynomial.Double(3.0, 5.0).getDegree());
assertEquals(0, new Polynomial.Double(0.0, 5.0).getDegree());
assertEquals(0, new Polynomial.Double(0.0, 0.0).getDegree());
assertEquals(0, new Polynomial.Double(5.0).getDegree());
assertEquals(0, new Polynomial.Double(0.0).getDegree());
public void testConversion() {
Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);
r = (Polynomial.Rational) r.multiply(new RationalNumber(1l, 2l));
Polynomial.Double p = new Polynomial.Double(r);
checkPolynomial(p, "-2.5 + 1.5 x + 0.5 x^2");
public void testString() {
Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);
checkPolynomial(p, "-5.0 + 3.0 x + x^2");
checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),
"-2.0 x + 3.0 x^2");
checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),
"1.0 - 2.0 x + 3.0 x^2");
checkPolynomial(new Polynomial.Double(3.0,  2.0, 0.0),
"2.0 x + 3.0 x^2");
checkPolynomial(new Polynomial.Double(3.0,  2.0, 1.0),
"1.0 + 2.0 x + 3.0 x^2");
checkPolynomial(new Polynomial.Double(3.0,  0.0, 1.0),
"1.0 + 3.0 x^2");
checkPolynomial(new Polynomial.Double(0.0),
"0");
public void testAddition() {
Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);
Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);
assertTrue(p1.add(p2).isZero());
p2 = p1.add(p1);
checkPolynomial(p2, "-4.0 + 2.0 x");
p1 = new Polynomial.Double(2.0, -4.0, 1.0);
p2 = new Polynomial.Double(-2.0, 3.0, -1.0);
p1 = p1.add(p2);
assertEquals(1, p1.getDegree());
checkPolynomial(p1, "-x");
public void testSubtraction() {
Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);
assertTrue(p1.subtract(p1).isZero());
Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);
p2 = p2.subtract(p1);
checkPolynomial(p2, "5.0 x");
p1 = new Polynomial.Double(2.0, -4.0, 1.0);
p2 = new Polynomial.Double(2.0, 3.0, -1.0);
p1 = p1.subtract(p2);
assertEquals(1, p1.getDegree());
checkPolynomial(p1, "2.0 - 7.0 x");
public void testMultiplication() {
Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);
Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);
checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");
p1 = new Polynomial.Double(1.0, 0.0);
p2 = p1;
for (int i = 2; i < 10; ++i) {
p2 = p2.multiply(p1);
checkPolynomial(p2, "x^" + i);
public void checkPolynomial(Polynomial.Double p, String reference) {
assertEquals(reference, p.toString());
public static Test suite() {
return new TestSuite(PolynomialDoubleTest.class);
package org.spaceroots.mantissa.algebra;
public class AllTests {
public static Test suite() { 
TestSuite suite = new TestSuite("org.spaceroots.mantissa.algebra"); 
suite.addTest(RationalNumberTest.suite());
suite.addTest(PolynomialRationalTest.suite());
suite.addTest(PolynomialDoubleTest.suite());
suite.addTest(ChebyshevTest.suite());
suite.addTest(HermiteTest.suite());
suite.addTest(LegendreTest.suite());
suite.addTest(LaguerreTest.suite());
suite.addTest(PolynomialFractionTest.suite());
return suite; 
package org.spaceroots.mantissa.algebra;
public class LaguerreTest
extends TestCase {
public LaguerreTest(String name) {
super(name);
public void testOne() {
assertTrue(new Laguerre().isOne());
public void testFirstPolynomials() {
checkLaguerre(new Laguerre(3), 6l, "6 - 18 x + 9 x^2 - x^3");
checkLaguerre(new Laguerre(2), 2l, "2 - 4 x + x^2");
checkLaguerre(new Laguerre(1), 1l, "1 - x");
checkLaguerre(new Laguerre(0), 1l, "1");
checkLaguerre(new Laguerre(7), 5040l,
"5040 - 35280 x + 52920 x^2 - 29400 x^3"
+ " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");
checkLaguerre(new Laguerre(6),  720l,
"720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4"
+ " - 36 x^5 + x^6");
checkLaguerre(new Laguerre(5),  120l,
"120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");
checkLaguerre(new Laguerre(4),   24l,
"24 - 96 x + 72 x^2 - 16 x^3 + x^4");
public void testDifferentials() {
for (int k = 0; k < 12; ++k) {
Polynomial.Rational Lk0 = new Laguerre(k);
Polynomial.Rational Lk1 = (Polynomial.Rational) Lk0.getDerivative();
Polynomial.Rational Lk2 = (Polynomial.Rational) Lk1.getDerivative();
Polynomial.Rational g0 = new Polynomial.Rational(k);
Polynomial.Rational g1 = new Polynomial.Rational(-1l, 1l);
Polynomial.Rational g2 = new Polynomial.Rational(1l, 0l);
Polynomial.Rational Lk0g0 = Lk0.multiply(g0);
Polynomial.Rational Lk1g1 = Lk1.multiply(g1);
Polynomial.Rational Lk2g2 = Lk2.multiply(g2);
Polynomial.Rational d = Lk0g0.add(Lk1g1.add(Lk2g2));
assertTrue(d.isZero());
public void checkLaguerre(Laguerre p, long denominator, String reference) {
assertTrue(p.multiply(denominator).toString().equals(reference));
public static Test suite() {
return new TestSuite(LaguerreTest.class);
package org.spaceroots.mantissa.algebra;
public class ChebyshevTest
extends TestCase {
public ChebyshevTest(String name) {
super(name);
public void testOne() {
assertTrue(new Chebyshev().isOne());
public void testFirstPolynomials() {
checkPolynomial(new Chebyshev(3), "-3 x + 4 x^3");
checkPolynomial(new Chebyshev(2), "-1 + 2 x^2");
checkPolynomial(new Chebyshev(1), "x");
checkPolynomial(new Chebyshev(0), "1");
checkPolynomial(new Chebyshev(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7");
checkPolynomial(new Chebyshev(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6");
checkPolynomial(new Chebyshev(5), "5 x - 20 x^3 + 16 x^5");
checkPolynomial(new Chebyshev(4), "1 - 8 x^2 + 8 x^4");
public void testBounds() {
for (int k = 0; k < 12; ++k) {
OrthogonalPolynomial Tk = new Chebyshev(k);
for (double x = -1.0; x <= 1.0; x += 0.02) {
assertTrue(Math.abs(Tk.valueAt(x)) < (1.0 + 1.0e-12));
public void testDifferentials() {
for (int k = 0; k < 12; ++k) {
Polynomial.Rational Tk0 = new Chebyshev(k);
Polynomial.Rational Tk1 = (Polynomial.Rational) Tk0.getDerivative();
Polynomial.Rational Tk2 = (Polynomial.Rational) Tk1.getDerivative();
Polynomial.Rational g0 = new Polynomial.Rational(k * k);
Polynomial.Rational g1 = new Polynomial.Rational(-1l, 0l);
Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);
Polynomial.Rational Tk0g0 = Tk0.multiply(g0);
Polynomial.Rational Tk1g1 = Tk1.multiply(g1);
Polynomial.Rational Tk2g2 = Tk2.multiply(g2);
Polynomial.Rational d = Tk0g0.add(Tk1g1.add(Tk2g2));
assertTrue(d.isZero());
public void checkPolynomial(Polynomial.Rational p, String reference) {
assertTrue(p.toString().equals(reference));
public static Test suite() {
return new TestSuite(ChebyshevTest.class);
package org.spaceroots.mantissa.algebra;
public class LegendreTest
extends TestCase {
public LegendreTest(String name) {
super(name);
public void testOne() {
assertTrue(new Legendre().isOne());
public void testFirstPolynomials() {
checkLegendre(new Legendre(3),  2l, "-3 x + 5 x^3");
checkLegendre(new Legendre(2),  2l, "-1 + 3 x^2");
checkLegendre(new Legendre(1),  1l, "x");
checkLegendre(new Legendre(0),  1l, "1");
checkLegendre(new Legendre(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7");
checkLegendre(new Legendre(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6");
checkLegendre(new Legendre(5),  8l, "15 x - 70 x^3 + 63 x^5");
checkLegendre(new Legendre(4),  8l, "3 - 30 x^2 + 35 x^4");
public void testDifferentials() {
for (int k = 0; k < 12; ++k) {
Polynomial.Rational Pk0 = new Legendre(k);
Polynomial.Rational Pk1 = (Polynomial.Rational) Pk0.getDerivative();
Polynomial.Rational Pk2 = (Polynomial.Rational) Pk1.getDerivative();
Polynomial.Rational g0 = new Polynomial.Rational(k * (k + 1));
Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);
Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);
Polynomial.Rational Pk0g0 = Pk0.multiply(g0);
Polynomial.Rational Pk1g1 = Pk1.multiply(g1);
Polynomial.Rational Pk2g2 = Pk2.multiply(g2);
Polynomial.Rational d = Pk0g0.add(Pk1g1.add(Pk2g2));
assertTrue(d.isZero());
public void testHighDegree() {
checkLegendre(new Legendre(40), 274877906944l,
"34461632205"
+ " - 28258538408100 x^2"
+ " + 3847870979902950 x^4"
+ " - 207785032914759300 x^6"
+ " + 5929294332103310025 x^8"
+ " - 103301483474866556880 x^10"
+ " + 1197358103913226000200 x^12"
+ " - 9763073770369381232400 x^14"
+ " + 58171647881784229843050 x^16"
+ " - 260061484647976556945400 x^18"
+ " + 888315281771246239250340 x^20"
+ " - 2345767627188139419665400 x^22"
+ " + 4819022625419112503443050 x^24"
+ " - 7710436200670580005508880 x^26"
+ " + 9566652323054238154983240 x^28"
+ " - 9104813935044723209570256 x^30"
+ " + 6516550296251767619752905 x^32"
+ " - 3391858621221953912598660 x^34"
+ " + 1211378079007840683070950 x^36"
+ " - 265365894974690562152100 x^38"
+ " + 26876802183334044115405 x^40");
public void checkLegendre(Legendre p, long denominator, String reference) {
assertTrue(p.multiply(denominator).toString().equals(reference));
public static Test suite() {
return new TestSuite(LegendreTest.class);
package org.spaceroots.mantissa.algebra;
public class RationalNumberTest
extends TestCase {
public RationalNumberTest(String name) {
super(name);
public void testNullDenominator() {
new RationalNumber(1l, 0l);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testToString() {
checkValue(new RationalNumber(1l, 2l),  "1/2");
checkValue(new RationalNumber(-1l, 2l), "-1/2");
checkValue(new RationalNumber(1l, -2l), "-1/2");
checkValue(new RationalNumber(-1l, -2l), "1/2");
checkValue(new RationalNumber(0l, 500l), "0");
checkValue(new RationalNumber(-12l), "-12");
checkValue(new RationalNumber(12l), "12");
public void testSimplification() {
checkValue(new RationalNumber(2l, 4l), "1/2");
checkValue(new RationalNumber(307692l, 999999l), "4/13");
checkValue(new RationalNumber(999999l, 307692l), "13/4");
public void testInvert() {
RationalNumber f = new RationalNumber(2l, 4l).invert();
checkValue(f, "2");
f = f.invert();
checkValue(f, "1/2");
f = new RationalNumber(120l).invert();
checkValue(f, "1/120");
f = new RationalNumber(0l, 4l);
f.invert();
fail("an exception should have been thrown");
fail("wrong exception caught");
f = new RationalNumber(307692l, 999999l);
RationalNumber fInverse = f.invert();
checkValue(fInverse, "13/4");
checkValue(f, "4/13");
public void testAddition() {
RationalNumber f1 = new RationalNumber(4l, 6l);
f1 = f1.add(f1);
checkValue(f1, "4/3");
checkValue(new RationalNumber(17l, 3l).add(new RationalNumber(-17l, 3l)),
"0");
checkValue(new RationalNumber(2l, 3l).add(new RationalNumber(3l, 4l)),
"17/12");
checkValue(new RationalNumber(1l, 6l).add(new RationalNumber(2l, 6l)),
"1/2");
checkValue(new RationalNumber(4l, 5l).add(new RationalNumber(-3l, 4l)),
"1/20");
checkValue(new RationalNumber(-3l, 4l).add(new RationalNumber(4l, 5l)),
"1/20");
public void testSubtraction() {
RationalNumber f1 = new RationalNumber(4l, 6l);
f1 = f1.subtract(f1);
checkValue(f1, "0");
checkValue(new RationalNumber(7l, 3l).subtract(new RationalNumber(-7l, 3l)),
"14/3");
checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(2l, 3l)),
"1/12");
checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(-2l, 3l)),
"17/12");
checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(2l, 3l)),
"-17/12");
checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(-2l, 3l)),
"-1/12");
checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(3l, 4l)),
"-1/12");
checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(3l, 4l)),
"-17/12");
checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(-3l, 4l)),
"17/12");
checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(-3l, 4l)),
"1/12");
checkValue(new RationalNumber(1l, 6l).subtract(new RationalNumber(2l, 6l)),
"-1/6");
checkValue(new RationalNumber(1l, 2l).subtract(new RationalNumber(1l, 6l)),
"1/3");
public void testMultiplication() {
RationalNumber f = new RationalNumber(2l, 3l);
f = f.multiply(new RationalNumber(9l,4l));
checkValue(f, "3/2");
checkValue(new RationalNumber(1l, 2l).multiply(new RationalNumber(0l)),
"0");
checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(-5l, 2l)),
"-2/3");
checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(5l, 2l)),
"-2/3");
checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(5l, 2l)),
"2/3");
checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(-5l, 2l)),
"2/3");
public void testDivision() {
RationalNumber f = new RationalNumber(2l, 3l);
f = f.divide(new RationalNumber(4l,9l));
checkValue(f, "3/2");
new RationalNumber(1l, 2l).divide(new RationalNumber(0l));
fail("an exception should have been thrown");
fail("wrong exception caught");
checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(-2l, 5l)),
"-2/3");
checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(2l, 5l)),
"-2/3");
checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(2l, 5l)),
"2/3");
checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(-2l, 5l)),
"2/3");
private void checkValue(RationalNumber f, String reference) {
assertTrue(f.toString().equals(reference));
public static Test suite() {
return new TestSuite(RationalNumberTest.class);
package org.spaceroots.mantissa.algebra;
public class HermiteTest
extends TestCase {
public HermiteTest(String name) {
super(name);
public void testOne() {
assertTrue(new Hermite().isOne());
public void testFirstPolynomials() {
checkPolynomial(new Hermite(3), "-12 x + 8 x^3");
checkPolynomial(new Hermite(2), "-2 + 4 x^2");
checkPolynomial(new Hermite(1), "2 x");
checkPolynomial(new Hermite(0), "1");
checkPolynomial(new Hermite(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");
checkPolynomial(new Hermite(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6");
checkPolynomial(new Hermite(5), "120 x - 160 x^3 + 32 x^5");
checkPolynomial(new Hermite(4), "12 - 48 x^2 + 16 x^4");
public void testDifferentials() {
for (int k = 0; k < 12; ++k) {
Polynomial.Rational Hk0 = new Hermite(k);
Polynomial.Rational Hk1 = (Polynomial.Rational) Hk0.getDerivative();
Polynomial.Rational Hk2 = (Polynomial.Rational) Hk1.getDerivative();
Polynomial.Rational g0 = new Polynomial.Rational(2l * k);
Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);
Polynomial.Rational g2 = new Polynomial.Rational(1l);
Polynomial.Rational Hk0g0 = Hk0.multiply(g0);
Polynomial.Rational Hk1g1 = Hk1.multiply(g1);
Polynomial.Rational Hk2g2 = Hk2.multiply(g2);
Polynomial.Rational d = Hk0g0.add(Hk1g1.add(Hk2g2));
assertTrue(d.isZero());
public void checkPolynomial(Polynomial.Rational p, String reference) {
assertTrue(p.toString().equals(reference));
public static Test suite() {
return new TestSuite(HermiteTest.class);
package org.spaceroots.mantissa.algebra;
public class PolynomialRationalTest
extends TestCase {
public PolynomialRationalTest(String name) {
super(name);
public void testZero() {
assertTrue(new Polynomial.Rational().isZero());
public void testConstructors() {
Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);
RationalNumber[]  a = p.getCoefficients();
assertEquals(a.length, 3);
assertEquals(new RationalNumber(-5l), a[0]);
assertEquals(new RationalNumber(3l), a[1]);
assertEquals(new RationalNumber(1l), a[2]);
assertEquals(2, p.getDegree());
assertEquals(1, new Polynomial.Rational(0l, 3l, 5l).getDegree());
assertEquals(0, new Polynomial.Rational(0l, 0l, 5l).getDegree());
assertEquals(0, new Polynomial.Rational(0l, 0l, 0l).getDegree());
assertEquals(1, new Polynomial.Rational(3l, 5l).getDegree());
assertEquals(0, new Polynomial.Rational(0l, 5l).getDegree());
assertEquals(0, new Polynomial.Rational(0l, 0l).getDegree());
assertEquals(0, new Polynomial.Rational(5l).getDegree());
assertEquals(0, new Polynomial.Rational(0l).getDegree());
public void testString() {
Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);
checkPolynomial(p, "-5 + 3 x + x^2");
checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), "-2 x + 3 x^2");
checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), "1 - 2 x + 3 x^2");
checkPolynomial(new Polynomial.Rational(3l,  2l, 0l), "2 x + 3 x^2");
checkPolynomial(new Polynomial.Rational(3l,  2l, 1l), "1 + 2 x + 3 x^2");
checkPolynomial(new Polynomial.Rational(3l,  0l, 1l), "1 + 3 x^2");
checkPolynomial(new Polynomial.Rational(0l), "0");
public void testAddition() {
Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);
Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);
assertTrue(p1.add(p2).isZero());
p2 = p1.add(p1);
checkPolynomial(p2, "-4 + 2 x");
p1 = new Polynomial.Rational(2l, -4l, 1l);
p2 = new Polynomial.Rational(-2l, 3l, -1l);
p1 = p1.add(p2);
assertEquals(1, p1.getDegree());
checkPolynomial(p1, "-x");
public void testSubtraction() {
Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);
assertTrue(p1.subtract(p1).isZero());
Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);
p2 = p2.subtract(p1);
checkPolynomial(p2, "5 x");
p1 = new Polynomial.Rational(2l, -4l, 1l);
p2 = new Polynomial.Rational(2l, 3l, -1l);
p1 = p1.subtract(p2);
assertEquals(1, p1.getDegree());
checkPolynomial(p1, "2 - 7 x");
public void testMultiplication() {
Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);
Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);
checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");
p1 = new Polynomial.Rational(1l, 0l);
p2 = p1;
for (int i = 2; i < 10; ++i) {
p2 = p2.multiply(p1);
checkPolynomial(p2, "x^" + i);
public void testLCM() {
Polynomial.Rational p = new Polynomial.Rational(new RationalNumber(2l, 5l),
new RationalNumber(-1l, 6l),
new RationalNumber(3l, 4l));
checkPolynomial(p, "3/4 - 1/6 x + 2/5 x^2");
BigInteger lcm = p.getDenominatorsLCM();
assertEquals(BigInteger.valueOf(60l), lcm);
p = (Polynomial.Rational) p.multiply(lcm);
checkPolynomial(p, "45 - 10 x + 24 x^2");
public void testEuclidianDivision() {
Polynomial.Rational p = new Polynomial.Rational(4l, 6l, -3l);
Polynomial.Rational q = new Polynomial.Rational(3l, 2l);
Polynomial.DivisionResult res = Polynomial.Rational.euclidianDivision(p, q);
checkPolynomial(res.quotient,  "10/9 + 4/3 x");
checkPolynomial(res.remainder, "-47/9");
public void checkPolynomial(Polynomial.Rational p, String reference) {
assertEquals(reference, p.toString());
public static Test suite() {
return new TestSuite(PolynomialRationalTest.class);
package org.spaceroots.mantissa.algebra;
public class PolynomialFractionTest
extends TestCase {
public PolynomialFractionTest(String name) {
super(name);
public void testNullDenominator() {
new PolynomialFraction(1l, 0l);
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testToString() {
checkValue(new PolynomialFraction(1l, 2l),  "1/2");
checkValue(new PolynomialFraction(-1l, 2l), "-1/2");
checkValue(new PolynomialFraction(1l, -2l), "-1/2");
checkValue(new PolynomialFraction(-1l, -2l), "1/2");
checkValue(new PolynomialFraction(0l, 500l), "0");
checkValue(new PolynomialFraction(-12l), "-12");
checkValue(new PolynomialFraction(12l), "12");
public void testSimplification() {
checkValue(new PolynomialFraction(2l, 4l), "1/2");
checkValue(new PolynomialFraction(307692l, 999999l), "4/13");
checkValue(new PolynomialFraction(999999l, 307692l), "13/4");
public void testInvert() {
PolynomialFraction f = new PolynomialFraction(2l, 4l);
f= f.invert();
checkValue(f, "2");
f = f.invert();
checkValue(f, "1/2");
f = new PolynomialFraction(120l);
f = f.invert();
checkValue(f, "1/120");
f = new PolynomialFraction(0l, 4l);
f = f.invert();
fail("an exception should have been thrown");
fail("wrong exception caught");
f = new PolynomialFraction(307692l, 999999l);
PolynomialFraction fInverse = f.invert();
checkValue(fInverse, "13/4");
checkValue(f, "4/13");
public void testAddition() {
PolynomialFraction f1 = new PolynomialFraction(4l, 6l);
f1 = f1.add(f1);
checkValue(f1, "4/3");
checkValue(new PolynomialFraction(17l, 3l).add(new PolynomialFraction(-17l, 3l)),
"0");
checkValue(new PolynomialFraction(2l, 3l).add(new PolynomialFraction(3l, 4l)),
"17/12");
checkValue(new PolynomialFraction(1l, 6l).add(new PolynomialFraction(2l, 6l)),
"1/2");
checkValue(new PolynomialFraction(4l, 5l).add(new PolynomialFraction(-3l, 4l)),
"1/20");
checkValue(new PolynomialFraction(-3l, 4l).add(new PolynomialFraction(4l, 5l)),
"1/20");
public void testSubtraction() {
PolynomialFraction f1 = new PolynomialFraction(4l, 6l);
checkValue(f1.subtract(f1), "0");
checkValue(new PolynomialFraction(7l, 3l).subtract(new PolynomialFraction(-7l, 3l)),
"14/3");
checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(2l, 3l)),
"1/12");
checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),
"17/12");
checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(2l, 3l)),
"-17/12");
checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),
"-1/12");
checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(3l, 4l)),
"-1/12");
checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(3l, 4l)),
"-17/12");
checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),
"17/12");
checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),
"1/12");
checkValue(new PolynomialFraction(1l, 6l).subtract(new PolynomialFraction(2l, 6l)),
"-1/6");
checkValue(new PolynomialFraction(1l, 2l).subtract(new PolynomialFraction(1l, 6l)),
"1/3");
public void testMultiplication() {
PolynomialFraction f = new PolynomialFraction(2l, 3l);
checkValue(f.multiply(new PolynomialFraction(9l,4l)), "3/2");
checkValue(new PolynomialFraction(1l, 2l).multiply(new PolynomialFraction(0l)),
"0");
checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),
"-2/3");
checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(5l, 2l)),
"-2/3");
checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(5l, 2l)),
"2/3");
checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),
"2/3");
public void testDivision() {
PolynomialFraction f = new PolynomialFraction(2l, 3l);
checkValue(f.divide(new PolynomialFraction(4l,9l)), "3/2");
new PolynomialFraction(1l, 2l).divide(new PolynomialFraction(0l));
fail("an exception should have been thrown");
fail("wrong exception caught");
checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(-2l, 5l)),
"-2/3");
checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(2l, 5l)),
"-2/3");
checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(2l, 5l)),
"2/3");
checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(-2l, 5l)),
"2/3");
public void testEuclidianDivision() {
checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 0l, -1l),
new Polynomial.Rational(2l, 2l)),
"-1/2 + 1/2 x");
checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 3l, 2l),
new Polynomial.Rational(2l, 10l, 12l)),
"(1 + x)/(6 + 2 x)");
private void checkValue(PolynomialFraction f, String reference) {
assertTrue(f.toString().equals(reference));
public static Test suite() {
return new TestSuite(PolynomialFractionTest.class);
package org.spaceroots.mantissa.roots;
public class BrentSolver implements RootsFinder {
private static final double epsilon = Math.pow(2.0, -52);
private double root;
public BrentSolver() {
root = Double.NaN;
public boolean findRoot(ComputableFunction function,
ConvergenceChecker checker,
int maxIter,
double x0, double f0, double x1, double f1)
throws FunctionException {
double a  = x0;
double fa = f0;
double b  = x1;
double fb = f1;
double c  = a;
double fc = fa;
double d  = b - a;
double e  = d;
double tolS;
for (int iter = 0; iter < maxIter; ++iter) {
if (Math.abs(fc) < Math.abs(fb)) {
a  = b;
b  = c;
c  = a;
fa = fb;
fb = fc;
fc = fa;
tolS = 2 * epsilon * Math.abs(b);
double xm = 0.5 * (c - b);
double xLow, fLow, xHigh, fHigh;
if (b < c) {
xLow   = b;
fLow   = fb;
xHigh  = c;
fHigh  = fc;
xLow   = c;
fLow   = fc;
xHigh  = b;
fHigh  = fb;
switch (checker.converged(xLow, fLow, xHigh, fHigh)) {
case ConvergenceChecker.LOW :
root = xLow;
return true;
case ConvergenceChecker.HIGH :
root = xHigh;
return true;
default :
if ((Math.abs(xm) < tolS) || (Math.abs(fb) < Double.MIN_VALUE)) {
root = b;
return true;
if ((Math.abs(e) < tolS) || (Math.abs(fa) <= Math.abs(fb))) {
d = xm;
e = d;
double p, q, r, s;
s = fb / fa;
if (Math.abs(a - c) < epsilon * Math.max(Math.abs(a), Math.abs(c))) {
p = 2.0 * xm * s;
q = 1.0 - s;
q = fa / fc;
r = fb / fc;
p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0));
q = (q - 1.0) * (r - 1.0) * (s - 1.0);
if (p > 0.0) {
q = -q;
p = -p;
if (((2.0 * p) < (3.0 * xm * q - Math.abs(tolS * q)))
&&
(p < Math.abs(0.5 * e * q))) {
e = d;
d = p / q;
d = xm;
e = d;
a  = b;
fa = fb;
b += ((Math.abs(d) > tolS) ? d : (xm > 0.0 ? tolS : -tolS));
fb = function.valueAt(b);
if (fb * fc > 0) {
c  = a;
fc = fa;
d  = b - a;
e  = d;
return false;
public double getRoot() {
return root;
package org.spaceroots.mantissa.roots;
public interface ConvergenceChecker {
public static final int NONE = 0;
public static final int LOW  = 1;
public static final int HIGH = 2;
public int converged (double xLow, double fLow, double xHigh, double fHigh);
package org.spaceroots.mantissa.roots;
public interface RootsFinder {
public boolean findRoot(ComputableFunction function,
ConvergenceChecker checker,
int maxIter,
double x0, double f0, double x1, double f1)
throws FunctionException;
public double getRoot();
package org.spaceroots.mantissa.fitting;
public class HarmonicCoefficientsGuesser
implements Serializable{
public HarmonicCoefficientsGuesser(AbstractCurveFitter.FitMeasurement[] measurements) {
this.measurements =
(AbstractCurveFitter.FitMeasurement[]) measurements.clone();
a                 = Double.NaN;
omega             = Double.NaN;
public void guess()
throws ExhaustedSampleException, FunctionException, EstimationException {
guessAOmega();
guessPhi();
private void guessAOmega()
throws ExhaustedSampleException, FunctionException, EstimationException {
double sx2 = 0.0;
double sy2 = 0.0;
double sxy = 0.0;
double sxz = 0.0;
double syz = 0.0;
F2FP2Iterator iter = new F2FP2Iterator(measurements);
SampledFunctionIterator sampler =
new EnhancedSimpsonIntegratorSampler(iter);
VectorialValuedPair p0 = sampler.nextSamplePoint();
double   p0X = p0.x;
double[] p0Y = p0.y;
while (sampler.hasNext()) {
VectorialValuedPair point = sampler.nextSamplePoint();
double   pX = point.x;
double[] pY = point.y;
double x = pX    - p0X;
double y = pY[0] - p0Y[0];
double z = pY[1] - p0Y[1];
sx2 += x * x;
sy2 += y * y;
sxy += x * y;
sxz += x * z;
syz += y * z;
double c1 = sy2 * sxz - sxy * syz;
double c2 = sxy * sxz - sx2 * syz;
double c3 = sx2 * sy2 - sxy * sxy;
if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {
throw new EstimationException("unable to guess a first estimate");
a     = Math.sqrt(c1 / c2);
omega = Math.sqrt(c2 / c3);
private void guessPhi()
throws ExhaustedSampleException, FunctionException {
SampledFunctionIterator iter = new FFPIterator(measurements);
double fcMean = 0.0;
double fsMean = 0.0;
while (iter.hasNext()) {
VectorialValuedPair point = iter.nextSamplePoint();
double   omegaX = omega * point.x;
double   cosine = Math.cos(omegaX);
double   sine   = Math.sin(omegaX);
fcMean += omega * point.y[0] * cosine - point.y[1] *   sine;
fsMean += omega * point.y[0] *   sine + point.y[1] * cosine;
phi = Math.atan2(-fsMean, fcMean);
public double getOmega() {
return omega;
public double getA() {
return a;
public double getPhi() {
return phi;
private AbstractCurveFitter.FitMeasurement[] measurements;
private double a;
private double omega;
private double phi;
private static final long serialVersionUID = 2400399048702758814L;
package org.spaceroots.mantissa.fitting;
public class PolynomialFitter
extends AbstractCurveFitter {
public PolynomialFitter(int degree, Estimator estimator) {
super(degree + 1, estimator);
for (int i = 0; i < coefficients.length; ++i) {
coefficients[i] = new PolynomialCoefficient(i);
public PolynomialFitter(PolynomialCoefficient[] coefficients,
Estimator estimator) {
super(coefficients, estimator);
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public double valueAt(double x) {
double y = coefficients[coefficients.length - 1].getEstimate();
for (int i = coefficients.length - 2; i >= 0; --i) {
y = y * x + coefficients[i].getEstimate();
return y;
public double partial(double x, EstimatedParameter p) {
if (p instanceof PolynomialCoefficient) {
return Math.pow(x, ((PolynomialCoefficient) p).degree);
throw new RuntimeException("internal error");
private static final long serialVersionUID = -744904084649890769L;
package org.spaceroots.mantissa.fitting;
public class HarmonicFitter
extends AbstractCurveFitter {
public HarmonicFitter(Estimator estimator) {
super(3, estimator);
coefficients[0]  = new EstimatedParameter("a", 2.0 * Math.PI);
coefficients[1]  = new EstimatedParameter("omega", 0.0);
coefficients[2]  = new EstimatedParameter("phi", 0.0);
firstGuessNeeded = true;
public HarmonicFitter(EstimatedParameter[] coefficients,
Estimator estimator) {
super(coefficients, estimator);
firstGuessNeeded = false;
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public double[] fit()
throws EstimationException {
if (firstGuessNeeded) {
if (measurements.size() < 4) {
throw new EstimationException("sample must contain at least {0} points",
new String[] {
Integer.toString(4)
sortMeasurements();
HarmonicCoefficientsGuesser guesser =
new HarmonicCoefficientsGuesser((FitMeasurement[]) getMeasurements());
guesser.guess();
coefficients[0].setEstimate(guesser.getA());
coefficients[1].setEstimate(guesser.getOmega());
coefficients[2].setEstimate(guesser.getPhi());
throw new EstimationException(e);
throw new EstimationException(e);
firstGuessNeeded = false;
return super.fit();
public double getAmplitude() {
return coefficients[0].getEstimate();
public double getPulsation() {
return coefficients[1].getEstimate();
public double getPhase() {
return coefficients[2].getEstimate();
public double valueAt(double x) {
double a     = coefficients[0].getEstimate();
double omega = coefficients[1].getEstimate();
double phi   = coefficients[2].getEstimate();
return a * Math.cos(omega * x + phi);
public double partial(double x, EstimatedParameter p) {
double a     = coefficients[0].getEstimate();
double omega = coefficients[1].getEstimate();
double phi   = coefficients[2].getEstimate();
if (p == coefficients[0]) {
return Math.cos(omega * x + phi);
return -a * x * Math.sin(omega * x + phi);
return -a * Math.sin(omega * x + phi);
private boolean firstGuessNeeded;
private static final long serialVersionUID = -8722683066277473450L;
package org.spaceroots.mantissa.fitting;
public abstract class AbstractCurveFitter
implements EstimationProblem, Serializable {
protected AbstractCurveFitter(int n, Estimator estimator) {
coefficients   = new EstimatedParameter[n];
measurements   = new ArrayList();
this.estimator = estimator;
protected AbstractCurveFitter(EstimatedParameter[] coefficients,
Estimator estimator) {
this.coefficients = coefficients;
measurements      = new ArrayList();
this.estimator     = estimator;
public void addWeightedPair(double weight, double x, double y) {
measurements.add(new FitMeasurement(weight, x, y));
public double[] fit()
throws EstimationException {
estimator.estimate(this);
double[] fittedCoefficients = new double[coefficients.length];
for (int i = 0; i < coefficients.length; ++i) {
fittedCoefficients[i] = coefficients[i].getEstimate();
return fittedCoefficients;
public WeightedMeasurement[] getMeasurements() {
return (WeightedMeasurement[]) measurements.toArray(new FitMeasurement[measurements.size()]);
public EstimatedParameter[] getUnboundParameters() {
return (EstimatedParameter[]) coefficients.clone();
public EstimatedParameter[] getAllParameters() {
return (EstimatedParameter[]) coefficients.clone();
protected void sortMeasurements() {
FitMeasurement curr = (FitMeasurement) measurements.get(0);
for (int j = 1; j < measurements.size (); ++j) {
FitMeasurement prec = curr;
curr = (FitMeasurement) measurements.get(j);
if (curr.x < prec.x) {
int i = j - 1;
FitMeasurement mI = (FitMeasurement) measurements.get(i);
while ((i >= 0) && (curr.x < mI.x)) {
measurements.set(i + 1, mI);
if (i-- != 0) {
mI = (FitMeasurement) measurements.get(i);
mI = null;
measurements.set(i + 1, curr);
curr = (FitMeasurement) measurements.get(j);
public abstract double valueAt(double x);
public abstract double partial(double x, EstimatedParameter p);
public class FitMeasurement
extends WeightedMeasurement {
public FitMeasurement(double weight, double x, double y) {
super(weight, y);
this.x = x;
public double getTheoreticalValue() {
return valueAt(x);
public double getPartial(EstimatedParameter p) {
return partial(x, p);
public final double x;
private static final long serialVersionUID = -2682582852369995960L;
protected EstimatedParameter[] coefficients;
protected List measurements;
private Estimator estimator;
package org.spaceroots.mantissa.fitting;
class FFPIterator
implements SampledFunctionIterator, Serializable {
public FFPIterator(AbstractCurveFitter.FitMeasurement[] measurements) {
this.measurements = measurements;
current   = measurements[0];
currentY  = current.getMeasuredValue();
next      = measurements[1];
nextY     = next.getMeasuredValue();
nextIndex = 2;
public int getDimension() {
return 2;
public boolean hasNext() {
return nextIndex < measurements.length;
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
if (nextIndex >= measurements.length) {
throw new ExhaustedSampleException(measurements.length);
previous  = current;
previousY = currentY;
current   = next;
currentY  = nextY;
next      = measurements[nextIndex++];
nextY     = next.getMeasuredValue();
double[] table = new double[2];
table[0] = currentY;
table[1] = (nextY - previousY) / (next.x - previous.x);
return new VectorialValuedPair(current.x, table);
private AbstractCurveFitter.FitMeasurement[] measurements;
private int nextIndex;
private AbstractCurveFitter.FitMeasurement previous;
private double previousY;
private AbstractCurveFitter.FitMeasurement current;
private double nextY;
private AbstractCurveFitter.FitMeasurement next;
private double currentY;
private static final long serialVersionUID = -3187229691615380125L;
package org.spaceroots.mantissa.fitting;
public class PolynomialCoefficient
extends EstimatedParameter {
public PolynomialCoefficient(int degree) {
super("a" + degree, 0.0);
this.degree = degree;
public final int degree;
private static final long serialVersionUID = 5775845068390259552L;
package org.spaceroots.mantissa.fitting;
class F2FP2Iterator
implements SampledFunctionIterator, Serializable {
public F2FP2Iterator(AbstractCurveFitter.FitMeasurement[] measurements) {
ffpIterator = new FFPIterator(measurements);
public int getDimension() {
return 2;
public boolean hasNext() {
return ffpIterator.hasNext();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
VectorialValuedPair point = ffpIterator.nextSamplePoint();
double[] y = point.y;
return new VectorialValuedPair(point.x,
new double[] {
y[0] * y[0], y[1] * y[1]             
private FFPIterator ffpIterator;
private static final long serialVersionUID = -8113110433795298072L;
package org.spaceroots.mantissa;
public class MessagesResources
extends ListResourceBundle {
public MessagesResources() {
public Object[][] getContents() {
return (Object[][]) contents.clone();
"unable to converge in {0} iterations" },
"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible" },
"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible" },
"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian" },
"maximal number of evaluations exceeded ({0})" },
"unable to guess a first estimate" },
"sample must contain at least {0} points" },
"sample contains only {0} elements" },
"Cardan angles singularity" },
"Euler angles singularity" },
"a {0}x{1} matrix cannot be a rotation matrix" },
"the closest orthogonal matrix has a negative determinant {0}" },
"unable to orthogonalize matrix in {0} iterations" },
"singular matrix" },
"minimal step size ({0}) reached, integration needs {1}" },
+ " state vector has dimension {1}",
"dimensions mismatch: ODE problem has dimension {0},"
+ " state vector has dimension {1}" },
"too small integration interval: length = {0}" },
"none of the {0} start points lead to convergence"  },
"dimension mismatch {0} != {1}" },
"not positive definite matrix" }
package org.spaceroots.mantissa.linalg;
public class SingularMatrixException
extends MantissaException {
public SingularMatrixException() {
super("singular matrix");
private static final long serialVersionUID = 7531357987468317564L;
package org.spaceroots.mantissa.linalg;
public class UpperTriangularMatrix
extends SquareMatrix {
public UpperTriangularMatrix(int order) {
super(order);
public UpperTriangularMatrix(int order, double[] data) {
super(order, data);
public UpperTriangularMatrix(UpperTriangularMatrix u) {
super(u);
public Matrix duplicate() {
return new UpperTriangularMatrix(this);
public void setElement(int i, int j, double value) {
if (i > j) {
throw new ArrayIndexOutOfBoundsException("cannot set elements"
+ " below diagonal of a"
+ " upper triangular matrix");
super.setElement(i, j, value);
public void selfAdd(UpperTriangularMatrix u) {
if ((rows != u.rows) || (columns != u.columns)) {
throw new IllegalArgumentException("cannot add a "
+ u.rows + 'x' + u.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
for (int index = i * (columns + 1); index < (i + 1) * columns; ++index) {
data[index] += u.data[index];
public void selfSub(UpperTriangularMatrix u) {
if ((rows != u.rows) || (columns != u.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ u.rows + 'x' + u.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
for (int index = i * (columns + 1); index < (i + 1) * columns; ++index) {
data[index] -= u.data[index];
public double getDeterminant(double epsilon) {
double determinant = data[0];
for (int index = columns + 1; index < columns * columns; index += columns + 1) {
determinant *= data[index];
return determinant;
public Matrix solve(Matrix b, double epsilon)
throws SingularMatrixException {
if (b.getRows() != rows) {
throw new IllegalArgumentException("dimension mismatch");
int bRows  = b.getRows();
int bCols  = b.getColumns();
double[] resultData = new double[bRows * bCols];
int resultIndex     = bRows * bCols - 1;
int lowerElements   = 0;
int upperElements   = 0;
int minJ            = columns;
int maxJ            = 0;
for (int i = rows - 1; i >= 0; --i) {
double diag = data[i * (columns + 1)];
if (Math.abs(diag) < epsilon) {
throw new SingularMatrixException();
double inv = 1.0 / diag;
NonNullRange range = b.getRangeForRow(i);
minJ = Math.min(minJ, range.begin);
maxJ = Math.max(maxJ, range.end);
int j = bCols - 1;
while (j >= maxJ) {
resultData[resultIndex] = 0.0;
--resultIndex;
--j;
int bIndex = i * bCols + maxJ - 1;
while (j >= minJ) {
int index1 = (i + 1) * columns - 1;
int index2 = (bRows - 1) * bCols + j;
double value = b.data[bIndex];
while (index1 >= i * (columns + 1)) {
value -= data[index1] * resultData[index2];
--index1;
index2 -= bCols;
value *= inv;
resultData[resultIndex] = value;
if (j < i) {
++lowerElements;
++upperElements;
--bIndex;
--resultIndex;
--j;
while (j >= 0) {
resultData[resultIndex] = 0.0;
--resultIndex;
--j;
return MatrixFactory.buildMatrix(bRows, bCols, resultData,
lowerElements, upperElements);
public NonNullRange getRangeForRow(int i) {
return new NonNullRange (i, columns);
public NonNullRange getRangeForColumn(int j) {
return new NonNullRange (0, j + 1);
private static final long serialVersionUID = -197266611942032237L;
package org.spaceroots.mantissa.linalg;
public class GeneralMatrix
extends Matrix {
public GeneralMatrix(int rows, int columns) {
super(rows, columns);
public GeneralMatrix(int rows, int columns, double[] data) {
super(rows, columns, data);
public GeneralMatrix(Matrix m) {
super(m);
public Matrix duplicate() {
return new GeneralMatrix(this);
public void selfAdd(Matrix m) {
if ((rows != m.rows) || (columns != m.columns)) {
throw new IllegalArgumentException("cannot add a "
+ m.rows + 'x' + m.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int index = 0; index < rows * columns; ++index) {
data[index] += m.data[index];
public void selfSub(Matrix m) {
if ((rows != m.rows) || (columns != m.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ m.rows + 'x' + m.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
for (int index = 0; index < rows * columns; ++index) {
data[index] -= m.data[index];
protected NonNullRange getRangeForRow(int i) {
return new NonNullRange(0, columns);
protected NonNullRange getRangeForColumn(int j) {
return new NonNullRange(0, rows);
private static final long serialVersionUID = 4350328622456299819L;
package org.spaceroots.mantissa.linalg;
public abstract class SquareMatrix
extends Matrix {
protected SquareMatrix(int order) {
super(order, order);
protected SquareMatrix(int order, double[] data) {
super(order, order, data);
protected SquareMatrix(SquareMatrix m) {
super(m);
public abstract double getDeterminant(double epsilon);
public SquareMatrix getInverse(double epsilon)
throws SingularMatrixException {
return solve(new DiagonalMatrix (columns), epsilon);
public abstract Matrix solve(Matrix b, double epsilon)
throws SingularMatrixException;
public SquareMatrix solve(SquareMatrix b, double epsilon)
throws SingularMatrixException {
return (SquareMatrix) solve((Matrix) b, epsilon);
package org.spaceroots.mantissa.linalg;
public abstract class Matrix
implements Serializable {
protected Matrix(int rows, int columns) {
if (rows <= 0 || columns <= 0) {
throw new IllegalArgumentException("cannot build a matrix"
+ " with negative or null dimension");
this.rows    = rows;
this.columns = columns;
data = new double[rows * columns];
for (int i = 0; i < data.length; ++i) {
data[i] = 0.0;
public Matrix(int rows, int columns, double[] data) {
if (rows <= 0 || columns <= 0) {
throw new IllegalArgumentException("cannot build a matrix"
+ " with negative or null dimension");
this.rows    = rows;
this.columns = columns;
this.data    = (data == null) ? null : (double[]) data.clone();
protected Matrix(Matrix m) {
rows    = m.rows;
columns = m.columns;
data    = new double[rows * columns];
System.arraycopy(m.data, 0, data, 0, m.data.length);
public abstract Matrix duplicate();
public int getRows() {
return rows;
public int getColumns() {
return columns;
public double getElement(int i, int j) {
if (i < 0 || i >= rows || j < 0 || j >= columns) {
throw new IllegalArgumentException("cannot get element ("
+ i + ", " + j + ") from a "
+ rows + 'x' + columns
+ " matrix");
return data[i * columns + j];
public void setElement(int i, int j, double value) {
if (i < 0 || i >= rows || j < 0 || j >= columns) {
throw new IllegalArgumentException("cannot set element ("
+ i + ", " + j + ") in a "
+ rows + 'x' + columns
+ " matrix");
data[i * columns + j] = value;
public Matrix add(Matrix m) {
if ((rows != m.rows) || (columns != m.columns)) {
throw new IllegalArgumentException("cannot add a "
+ m.rows + 'x' + m.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
double[] resultData    = new double[rows * columns];
int      resultIndex   = 0;
int      lowerElements = 0;
int      upperElements = 0;
for (int i = 0; i < rows; ++i) {
NonNullRange r = NonNullRange.reunion(getRangeForRow(i),
m.getRangeForRow(i));
int j = 0;
while (j < r.begin) {
resultData[resultIndex] = 0.0;
++resultIndex;
++j;
while (j < r.end) {
resultData[resultIndex] = data[resultIndex] + m.data[resultIndex];
if (j < i) {
++lowerElements;
++upperElements;
++resultIndex;
++j;
while (j < columns) {
resultData[resultIndex++] = 0.0;
++resultIndex;
++j;
return MatrixFactory.buildMatrix(rows, columns, resultData,
lowerElements, upperElements);
public Matrix sub(Matrix m) {
if ((rows != m.rows) || (columns != m.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ m.rows + 'x' + m.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
double[] resultData    = new double[rows * columns];
int      resultIndex   = 0;
int      lowerElements = 0;
int      upperElements = 0;
for (int i = 0; i < rows; ++i) {
NonNullRange r = NonNullRange.reunion(getRangeForRow(i),
m.getRangeForRow(i));
int j = 0;
while (j < r.begin) {
resultData[resultIndex] = 0.0;
++resultIndex;
++j;
while (j < r.end) {
resultData[resultIndex] = data[resultIndex] - m.data[resultIndex];
if (j < i) {
++lowerElements;
++upperElements;
++resultIndex;
++j;
while (j < columns) {
resultData[resultIndex++] = 0.0;
++resultIndex;
++j;
return MatrixFactory.buildMatrix(rows, columns, resultData,
lowerElements, upperElements);
public Matrix mul(Matrix m) {
if (columns != m.rows) {
throw new IllegalArgumentException("cannot multiply a "
+ rows + 'x' + columns
+ " matrix by a "
+ m.rows + 'x' + m.columns
+ " matrix");
double[] resultData = new double[rows * m.columns];
int resultIndex     = 0;
int lowerElements   = 0;
int upperElements   = 0;
for (int i = 0; i < rows; ++i) {
for (int j = 0; j < m.columns; ++j) {
double value = 0.0;
NonNullRange r = NonNullRange.intersection(getRangeForRow(i),
m.getRangeForColumn(j));
if (r.begin < r.end) {
int k    = r.begin;
int idx  = i * columns + k;
int midx = k * m.columns + j;
while (k++ < r.end) {
value += data[idx++] * m.data[midx];
midx  += m.columns;
if (j < i) {
++lowerElements;
++upperElements;
resultData[resultIndex++] = value;
return MatrixFactory.buildMatrix(rows, m.columns, resultData,
lowerElements, upperElements);
public Matrix mul(double a) {
Matrix copy = duplicate();
copy.selfMul(a);
return copy;
public void selfMul(double a) {
for (int i = 0; i < rows; ++i) {
NonNullRange r = getRangeForRow(i);
for (int j = r.begin, index = i * columns + r.begin; j < r.end; ++j) {
data[index++] *= a;
public Matrix getTranspose() {
double[] resultData    = new double[columns * rows];
int      resultIndex   = 0;
int      upperElements = 0;
int      lowerElements = 0;
for (int i = 0; i < columns; ++i) {
NonNullRange range = getRangeForColumn(i);
int j     = 0;
int index = i;
while (j < range.begin) {
resultData[resultIndex++] = 0.0;
index += columns;
++j;
while (j < range.end) {
resultData[resultIndex] = data[index];
if (j < i) {
++lowerElements;
++upperElements;
index += columns;
++resultIndex;
++j;
while (j < rows) {
resultData[resultIndex] = 0.0;
++resultIndex;
++j;
return MatrixFactory.buildMatrix(columns, rows, resultData,
lowerElements, upperElements);
protected abstract NonNullRange getRangeForRow(int i);
protected abstract NonNullRange getRangeForColumn(int j);
public String toString() {
String separator = System.getProperty("line.separator");
StringBuffer buf = new StringBuffer();
for (int index = 0; index < rows * columns; ++index) {
if (index > 0) {
if (index % columns == 0) {
buf.append(separator);
buf.append(' ');
buf.append(Double.toString(data[index]));
return buf.toString();
protected final int rows;
protected final int columns;
protected final double[] data;
package org.spaceroots.mantissa.linalg;
public class MatrixFactory {
private MatrixFactory() {
public static Matrix buildMatrix(int rows, int columns, double[] data,
int lowerElements, int upperElements) {
if (rows == columns) {
if (lowerElements == 0 && upperElements == 0) {
return new DiagonalMatrix(rows, data);
return new UpperTriangularMatrix(rows, data);
return new LowerTriangularMatrix(rows, data);
return new GeneralSquareMatrix(rows, data);
return new GeneralMatrix(rows, columns, data);
public static Matrix buildMatrix(int rows, int columns, double[] data) {
if (rows == columns) {
return new GeneralSquareMatrix(rows, data);
return new GeneralMatrix(rows, columns, data);
package org.spaceroots.mantissa.linalg;
class NonNullRange
implements Serializable {
public final int begin;
public final int end;
public NonNullRange(int begin, int end)
this.begin = begin;
this.end   = end;
public NonNullRange(NonNullRange range) {
begin = range.begin;
end   = range.end;
public static NonNullRange intersection(NonNullRange first,
NonNullRange second) {
return new NonNullRange(Math.max(first.begin, second.begin),
Math.min(first.end, second.end));
public static NonNullRange reunion(NonNullRange first,
NonNullRange second) {
return new NonNullRange(Math.min(first.begin, second.begin),
Math.max(first.end, second.end));
private static final long serialVersionUID = 8175301560126132666L;
package org.spaceroots.mantissa.linalg;
public class GeneralSquareMatrix
extends SquareMatrix {
public GeneralSquareMatrix(int order) {
super(order);
permutations     = null;
evenPermutations = true;
lower            = null;
upper            = null;
public GeneralSquareMatrix(int order, double[] data) {
super(order, data);
permutations     = null;
evenPermutations = true;
lower            = null;
upper            = null;
public GeneralSquareMatrix(GeneralSquareMatrix s) {
super(s);
if (s.permutations != null) {
permutations     = (int[]) s.permutations.clone();
evenPermutations = s.evenPermutations;
lower            = new LowerTriangularMatrix(s.lower);
upper            = new UpperTriangularMatrix(s.upper);
permutations     = null;
evenPermutations = true;
lower            = null;
upper            = null;
public Matrix duplicate() {
return new GeneralSquareMatrix(this);
public void setElement(int i, int j, double value) {
super.setElement(i, j, value);
permutations     = null;
evenPermutations = true;
lower            = null;
upper            = null;
public void selfAdd(SquareMatrix s) {
if ((rows != s.rows) || (columns != s.columns)) {
throw new IllegalArgumentException("cannot add a "
+ s.rows + 'x' + s.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int index = 0; index < rows * columns; ++index) {
data[index] += s.data[index];
public void selfSub(SquareMatrix s) {
if ((rows != s.rows) || (columns != s.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ s.rows + 'x' + s.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
for (int index = 0; index < rows * columns; ++index) {
data[index] -= s.data[index];
public double getDeterminant(double epsilon) {
if (permutations == null)
computeLUFactorization(epsilon);
double d = upper.getDeterminant(epsilon);
return evenPermutations ? d : -d;
return 0.0;
public Matrix solve(Matrix b, double epsilon)
throws SingularMatrixException {
if (b.getRows() != rows) {
throw new IllegalArgumentException("dimension mismatch");
if (permutations == null) {
computeLUFactorization(epsilon);
double[] permData = new double[b.data.length];
int bCols = b.getColumns();
for (int i = 0; i < rows; ++i) {
NonNullRange range = b.getRangeForRow(permutations[i]);
for (int j = range.begin; j < range.end; ++j) {
permData[i * bCols + j] = b.data[permutations[i] * bCols + j];
Matrix permB = MatrixFactory.buildMatrix(b.getRows(), bCols, permData);
return upper.solve(lower.solve(permB, epsilon), epsilon);
protected NonNullRange getRangeForRow(int i) {
return new NonNullRange(0, columns);
protected NonNullRange getRangeForColumn(int j) {
return new NonNullRange(0, rows);
private void computeLUFactorization(double epsilon)
throws SingularMatrixException {
double[] work = new double[rows * columns];
for (int index = 0; index < work.length; ++index) {
work[index] = data[index];
permutations = new int[rows];
for (int i = 0; i < rows; ++i) {
permutations[i] = i;
evenPermutations = true;
for (int k = 0; k < rows; ++k) {
double maxElt = Math.abs(work[permutations[k] * columns + k]);
int    jMax   = k;
for (int i = k + 1; i < rows; ++i) {
double curElt = Math.abs(work[permutations[i] * columns + k]);
if (curElt > maxElt) {
maxElt = curElt;
jMax   = i;
if (maxElt < epsilon) {
throw new SingularMatrixException();
if (k != jMax) {
int tmp            = permutations[k];
permutations[k]    = permutations[jMax];
permutations[jMax] = tmp;
evenPermutations   = ! evenPermutations;
double inv = 1.0 / work[permutations[k] * columns + k];
for (int i = k + 1; i < rows; ++i) {
double factor = inv * work[permutations[i] * columns + k];
work[permutations[i] * columns + k] = factor;
int index1 = permutations[i] * columns + k;
int index2 = permutations[k] * columns + k;
for (int j = k + 1; j < columns; ++j) {
work[++index1] -= factor * work[++index2];
double[] lowerData = new double[rows * columns];
double[] upperData = new double[rows * columns];
int index = 0;
for (int i = 0; i < rows; ++i) {
int workIndex = permutations[i] * columns;
int j         = 0;
while (j++ < i) {
lowerData[index]   = work[workIndex++];
upperData[index++] = 0.0;
lowerData[index]   = 1.0;
upperData[index++] = work[workIndex++];
while (j++ < columns) {
lowerData[index]   = 0.0;
upperData[index++] = work[workIndex++];
lower = new LowerTriangularMatrix(rows, lowerData);
upper = new UpperTriangularMatrix(rows, upperData);
private int[]                 permutations;
private boolean               evenPermutations;
private LowerTriangularMatrix lower;
private UpperTriangularMatrix upper;
private static final long serialVersionUID = -506293526695298279L;
package org.spaceroots.mantissa.linalg;
public class LowerTriangularMatrix
extends SquareMatrix {
public LowerTriangularMatrix(int order) {
super(order);
public LowerTriangularMatrix(int order, double[] data) {
super(order, data);
public LowerTriangularMatrix(LowerTriangularMatrix l) {
super(l);
public Matrix duplicate() {
return new LowerTriangularMatrix(this);
public void setElement(int i, int j, double value) {
if (i < j) {
throw new ArrayIndexOutOfBoundsException("cannot set elements"
+ " above diagonal of a"
+ " lower triangular matrix");
super.setElement(i, j, value);
public void selfAdd(LowerTriangularMatrix l) {
if ((rows != l.rows) || (columns != l.columns)) {
throw new IllegalArgumentException("cannot add a "
+ l.rows + 'x' + l.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
for (int index = i * columns; index < i * (columns + 1) + 1; ++index) {
data[index] += l.data[index];
public void selfSub(LowerTriangularMatrix l) {
if ((rows != l.rows) || (columns != l.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ l.rows + 'x' + l.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
for (int index = i * columns; index < i * (columns + 1) + 1; ++index) {
data[index] -= l.data[index];
public double getDeterminant(double epsilon) {
double determinant = data[0];
for (int index = columns + 1; index < columns * columns; index += columns + 1) {
determinant *= data[index];
return determinant;
public Matrix solve(Matrix b, double epsilon)
throws SingularMatrixException {
if (b.getRows () != rows) {
throw new IllegalArgumentException("dimension mismatch");
int bRows  = b.getRows();
int bCols  = b.getColumns();
double[] resultData = new double[bRows * bCols];
int resultIndex     = 0;
int lowerElements   = 0;
int upperElements   = 0;
int minJ            = columns;
int maxJ            = 0;
for (int i = 0; i < rows; ++i) {
double diag = data[i * (columns + 1)];
if (Math.abs(diag) < epsilon) {
throw new SingularMatrixException();
double inv = 1.0 / diag;
NonNullRange range = b.getRangeForRow(i);
minJ = Math.min(minJ, range.begin);
maxJ = Math.max(maxJ, range.end);
int j = 0;
while (j < minJ) {
resultData[resultIndex] = 0.0;
++resultIndex;
++j;
int bIndex = i * bCols + minJ;
while (j < maxJ) {
int index1 = i * columns;
int index2 = j;
double value = b.data[bIndex];
while (index1 < i * (columns + 1)) {
value -= data[index1] * resultData[index2];
++index1;
index2 += bCols;
value *= inv;
resultData[resultIndex] = value;
if (j < i) {
++lowerElements;
++upperElements;
++bIndex;
++resultIndex;
++j;
while (j < bCols) {
resultData[resultIndex] = 0.0;
++resultIndex;
++j;
return MatrixFactory.buildMatrix(bRows, bCols, resultData,
lowerElements, upperElements);
public NonNullRange getRangeForRow(int i) {
return new NonNullRange(0, i + 1);
public NonNullRange getRangeForColumn(int j) {
return new NonNullRange(j, rows);
private static final long serialVersionUID = 3592505328858227281L;
package org.spaceroots.mantissa.linalg;
public class DiagonalMatrix
extends SquareMatrix {
public DiagonalMatrix(int order) {
this(order, 1.0);
public DiagonalMatrix(int order, double value) {
super(order);
for (int index = 0; index < order * order; index += order + 1) {
data[index] = value;
public DiagonalMatrix(int order, double[] data) {
super(order, data);
public DiagonalMatrix(DiagonalMatrix d) {
super(d);
public Matrix duplicate() {
return new DiagonalMatrix(this);
public void setElement(int i, int j, double value) {
if (i != j) {
throw new ArrayIndexOutOfBoundsException("cannot set elements"
+ " out of diagonal in a"
+ " diagonal matrix");
super.setElement(i, j, value);
public double getDeterminant(double epsilon) {
double determinant = data[0];
for (int index = columns + 1; index < columns * columns; index += columns + 1) {
determinant *= data[index];
return determinant;
public SquareMatrix getInverse(double epsilon)
throws SingularMatrixException {
DiagonalMatrix inv = new DiagonalMatrix (columns);
for (int index = 0; index < columns * columns; index += columns + 1) {
if (Math.abs(data[index]) < epsilon) {
throw new SingularMatrixException();
inv.data[index] = 1.0 / data[index];
return inv;
public Matrix solve(Matrix b, double epsilon)
throws SingularMatrixException {
Matrix result = b.duplicate();
for (int i = 0; i < columns; ++i) {
double diag = data[i * (columns + 1)];
if (Math.abs(diag) < epsilon) {
throw new SingularMatrixException();
double inv = 1.0 / diag;
NonNullRange range = result.getRangeForRow(i);
for (int index = i * b.columns + range.begin;
index < i * b.columns + range.end;
++index) {
result.data[index] = inv * b.data[index];
return result;
public NonNullRange getRangeForRow(int i) {
return new NonNullRange(i, i + 1);
public NonNullRange getRangeForColumn(int j) {
return new NonNullRange(j, j + 1);
private static final long serialVersionUID = -2965166085913895323L;
package org.spaceroots.mantissa.linalg;
public class SymetricalMatrix
extends GeneralSquareMatrix {
public SymetricalMatrix(int order) {
super(order);
public SymetricalMatrix(int order, double[] data) {
super(order, data);
public SymetricalMatrix(SymetricalMatrix s) {
super(s);
public SymetricalMatrix(double w, double[] a) {
super(a.length, new double[a.length * a.length]);
for (int i = 0; i < a.length; ++i) {
int indexU = i * (columns + 1);
int indexL = indexU;
double factor = w * a[i];
data[indexU] = factor * a[i];
for (int j = i + 1; j < columns; ++j) {
++indexU;
indexL += columns;
data[indexU] = factor * a[j];
data[indexL] = data[indexU];
public Matrix duplicate() {
return new SymetricalMatrix(this);
public void setElement(int i, int j, double value) {
if (i != j) {
throw new ArrayIndexOutOfBoundsException("cannot separately set"
+ " elements out of diagonal"
+ " in a symetrical matrix");
super.setElement(i, j, value);
public void setElementAndSymetricalElement(int i, int j, double value) {
super.setElement(i, j, value);
if (i != j) {
super.setElement(j, i, value);
public void selfAdd(SymetricalMatrix s) {
if ((rows != s.rows) || (columns != s.columns)) {
throw new IllegalArgumentException("cannot add a "
+ s.rows + 'x' + s.columns
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
int indexU = i * (columns + 1);
int indexL = indexU;
data[indexU] += s.data[indexU];
for (int j = i + 1; j < columns; ++j) {
++indexU;
indexL += columns;
data[indexU] += s.data[indexU];
data[indexL]  = data[indexU];
public void selfSub(SymetricalMatrix s) {
if ((rows != s.rows) || (columns != s.columns)) {
throw new IllegalArgumentException("cannot substract a "
+ s.rows + 'x' + s.columns
+ " matrix from a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
int indexU = i * (columns + 1);
int indexL = indexU;
data[indexU] -= s.data[indexU];
for (int j = i + 1; j < columns; ++j) {
++indexU;
indexL += columns;
data[indexU] -= s.data[indexU];
data[indexL] = data[indexU];
public void selfAddWAAt(double w, double[] a) {
if (rows != a.length) {
throw new IllegalArgumentException("cannot add a "
+ a.length + 'x' + a.length
+ " matrix to a "
+ rows + 'x' + columns
+ " matrix");
for (int i = 0; i < rows; ++i) {
int indexU = i * (columns + 1);
int indexL = indexU;
double factor   = w * a[i];
data[indexU] += factor * a[i];
for (int j = i + 1; j < columns; ++j) {
++indexU;
indexL += columns;
data[indexU] += factor * a[j];
data[indexL]  = data[indexU];
private static final long serialVersionUID = -2083829252075519221L;
package org.spaceroots.mantissa;
public class MessagesResources_fr
extends ListResourceBundle {
public MessagesResources_fr() {
public Object[][] getContents() {
return (Object[][]) contents.clone();
"pas de convergence apr\u00e8s {0} it\u00e9rations" },
"trop petite tol\u00e9rance relative sur le co\u00fbt ({0}), aucune r\u00e9duction de la somme des carr\u00e9s n''est possible" },
"trop petite tol\u00e9rance relative sur les param\u00e8tres ({0}), aucune am\u00e9lioration de la solution approximative n''est possible" },
"trop petite tol\u00e9rance sur l''orthogonalit\u00e9 ({0}), la solution est orthogonale \u00e0 la jacobienne" },
"nombre maximal d''\u00e9valuations d\u00e9pass\u00e9 ({0})" },
"impossible de trouver une premi\u00e8re estim\u00e9e" },
"l''\u00e9chantillon doit contenir au moins {0} points" },
"l''\u00e9chantillon ne contient que {0} points" },
"singularit\u00e9 d''angles de Cardan" },
"singularit\u00e9 d''angles d''Euler" },
"une matrice {0}x{1} ne peut pas \u00e9tre une matrice de rotation" },
"la matrice orthogonale la plus proche a un d\u00e9terminant n\u00e9gatif {0}" },
"impossible de rendre la matrice orthogonale en {0} it\u00e9rations" },
"matrice singuli\u00e8re" },
"pas minimal ({0}) atteint, l''int\u00e9gration n\u00e9cessite {1}" },
+ " state vector has dimension {1}",
"incompatibilit\u00e9 de dimensions entre le probl\u00e8me ODE ({0}),"
+ " et le vecteur d''\u00e9tat ({1})" },
"intervalle d''int\u00e9gration trop petit : {0}" },
"aucun des {0} points de d\u00e9part n''aboutit \u00e0 une convergence"  },
"dimensions incompatibles {0} != {1}" },
"matrice non d\u00e9finie positive" }
package org.spaceroots.mantissa;
public class MantissaException
extends Exception {
private static final long serialVersionUID = 1L;
private static ResourceBundle resources
= ResourceBundle.getBundle("org.spaceroots.mantissa.MessagesResources");
public static String translate(String s) {
return resources.getString(s);
return s;
public static String translate(String specifier, String[] parts) {
return new MessageFormat(translate(specifier)).format(parts);
public MantissaException() {
super();
public MantissaException(String message) {
super(translate(message));
public MantissaException(String specifier, String[] parts) {
super(translate(specifier, parts));
public MantissaException(Throwable cause) {
super(cause);
public MantissaException(String message, Throwable cause) {
super(translate(message), cause);
public MantissaException(String specifier, String[] parts, Throwable cause) {
super(translate(specifier, parts), cause);
package org.spaceroots.mantissa.quadrature.vectorial;
public interface ComputableFunctionIntegrator {
public double[] integrate(ComputableFunction f, double a, double b)
throws FunctionException;
package org.spaceroots.mantissa.quadrature.vectorial;
public interface SampledFunctionIntegrator {
public double[] integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException;
package org.spaceroots.mantissa.quadrature.vectorial;
public class RiemannIntegrator
implements SampledFunctionIntegrator {
public double[] integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
RiemannIntegratorSampler sampler = new RiemannIntegratorSampler(iter);
double[] sum = null;
while (true) {
sum = sampler.nextSamplePoint().y;
return sum;
package org.spaceroots.mantissa.quadrature.vectorial;
public class EnhancedSimpsonIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private VectorialValuedPair next;
private double[] sum;
public EnhancedSimpsonIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
next = iter.nextSamplePoint();
sum = new double[iter.getDimension()];
for (int i = 0; i < sum.length; ++i) {
sum[i] = 0.0;
public boolean hasNext() {
return iter.hasNext();
public int getDimension() {
return iter.getDimension();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
VectorialValuedPair previous = next;
VectorialValuedPair current  = iter.nextSamplePoint();
next = iter.nextSamplePoint();
double h1 = current.x - previous.x;
double h2 = next.x    - current.x;
double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);
double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);
double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);
double[] pY = previous.y;
double[] cY = current.y;
double[] nY = next.y;
for (int i = 0; i < sum.length; ++i) {
sum [i] += cP * pY[i] + cC * cY[i] + cN * nY[i];
double halfDx = 0.5 * (current.x - previous.x);
double[] pY = previous.y;
double[] cY = current.y;
for (int i = 0; i < sum.length; ++i) {
sum [i] += halfDx * (pY[i] + cY[i]);
return new VectorialValuedPair(current.x, sum);
return new VectorialValuedPair(next.x, (double[]) sum.clone());
package org.spaceroots.mantissa.quadrature.vectorial;
public class EnhancedSimpsonIntegrator
implements SampledFunctionIntegrator {
public double[] integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
EnhancedSimpsonIntegratorSampler sampler =
new EnhancedSimpsonIntegratorSampler(iter);
double[] sum = null;
while (true) {
sum = sampler.nextSamplePoint().y;
return sum;
package org.spaceroots.mantissa.quadrature.vectorial;
public class TrapezoidIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private VectorialValuedPair current;
private double[] sum;
public TrapezoidIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
current = iter.nextSamplePoint();
sum = new double[iter.getDimension()];
for (int i = 0; i < sum.length; ++i) {
sum[i] = 0.0;
public boolean hasNext() {
return iter.hasNext();
public int getDimension() {
return iter.getDimension();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
VectorialValuedPair previous = current;
current = iter.nextSamplePoint();
double halfDx = 0.5 * (current.x - previous.x);
double[] pY = previous.y;
double[] cY = current.y;
for (int i = 0; i < sum.length; ++i) {
sum[i] += halfDx * (pY[i] + cY[i]);
return new VectorialValuedPair (current.x, (double[]) sum.clone());
package org.spaceroots.mantissa.quadrature.vectorial;
public class RiemannIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private VectorialValuedPair current;
private double[] sum;
public RiemannIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
current = iter.nextSamplePoint();
sum = new double[iter.getDimension()];
for (int i = 0; i < sum.length; ++i) {
sum[i] = 0.0;
public boolean hasNext() {
return iter.hasNext();
public int getDimension() {
return iter.getDimension();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
VectorialValuedPair previous = current;
current = iter.nextSamplePoint();
double step =  (current.x - previous.x);
double[] pY = previous.y;
for (int i = 0; i < sum.length; ++i) {
sum[i] += step * pY[i];
return new VectorialValuedPair (current.x, (double[]) sum.clone());
package org.spaceroots.mantissa.quadrature.vectorial;
public class GaussLegendreIntegrator
implements ComputableFunctionIntegrator {
public GaussLegendreIntegrator(int minPoints, double rawStep) {
if (minPoints <= 2) {
weightedRoots = new double[][] {
weightedRoots = new double[][] {
weightedRoots = new double[][] {
-Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) },
-Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },
Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },
Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) }
weightedRoots = new double[][] {
-Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) },
-Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },
0.0 },
Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },
Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) }
this.rawStep = rawStep;
public int getEvaluationsPerStep() {
return weightedRoots.length;
public double[] integrate(ComputableFunction f, double a, double b)
throws FunctionException {
if (b < a) {
double tmp = b;
b          = a;
a          = tmp;
long   n     = Math.round(0.5 + (b - a) / rawStep);
double step  = (b - a) / n;
double halfStep = step / 2.0;
double midPoint = a + halfStep;
double[] sum = new double[f.getDimension()];
for (int k = 0; k < sum.length; ++k) {
sum[k] = 0.0;
for (long i = 0; i < n; ++i) {
for (int j = 0; j < weightedRoots.length; ++j) {
double[] value = f.valueAt(midPoint + halfStep * weightedRoots[j][1]);
for (int k = 0; k < sum.length; ++k) {
sum[k] += weightedRoots[j][0] * value[k];
midPoint += step;
for (int k = 0; k < sum.length; ++k) {
sum [k] *= halfStep;
return sum;
double[][] weightedRoots;
double rawStep;
package org.spaceroots.mantissa.quadrature.vectorial;
public class TrapezoidIntegrator
implements SampledFunctionIntegrator {
public double[] integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
TrapezoidIntegratorSampler sampler =
new TrapezoidIntegratorSampler(iter);
double[] sum = null;
while (true) {
sum = sampler.nextSamplePoint().y;
return sum;
package org.spaceroots.mantissa.quadrature.scalar;
public interface ComputableFunctionIntegrator {
public double integrate(ComputableFunction f, double a, double b)
throws FunctionException;
package org.spaceroots.mantissa.quadrature.scalar;
public interface SampledFunctionIntegrator {
public double integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException;
package org.spaceroots.mantissa.quadrature.scalar;
public class RiemannIntegrator
implements SampledFunctionIntegrator {
public double integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
RiemannIntegratorSampler sampler = new RiemannIntegratorSampler(iter);
double sum = 0.0;
while (true) {
sum = sampler.nextSamplePoint().getY();
return sum;
package org.spaceroots.mantissa.quadrature.scalar;
public class EnhancedSimpsonIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private ScalarValuedPair next;
private double sum;
public EnhancedSimpsonIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
next = iter.nextSamplePoint();
sum = 0.0;
public boolean hasNext() {
return iter.hasNext();
public ScalarValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
ScalarValuedPair previous = next;
ScalarValuedPair current  = iter.nextSamplePoint();
next = iter.nextSamplePoint();
double h1 = current.getX() - previous.getX();
double h2 = next.getX()    - current.getX();
double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);
double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);
double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);
sum += cP * previous.getY() + cC * current.getY() + cN * next.getY();
sum += 0.5 * (current.getX() - previous.getX()) * (previous.getY() + current.getY());
return new ScalarValuedPair(current.getX(), sum);
return new ScalarValuedPair(next.getX(), sum);
package org.spaceroots.mantissa.quadrature.scalar;
public class EnhancedSimpsonIntegrator
implements SampledFunctionIntegrator {
public double integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
EnhancedSimpsonIntegratorSampler sampler
= new EnhancedSimpsonIntegratorSampler(iter);
double sum = 0.0;
while (true) {
sum = sampler.nextSamplePoint().getY();
return sum;
package org.spaceroots.mantissa.quadrature.scalar;
public class TrapezoidIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private ScalarValuedPair current;
private double sum;
public TrapezoidIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
current = iter.nextSamplePoint();
sum = 0.0;
public boolean hasNext() {
return iter.hasNext ();
public ScalarValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
ScalarValuedPair previous = current;
current = iter.nextSamplePoint();
sum    += 0.5
return new ScalarValuedPair(current.getX(), sum);
package org.spaceroots.mantissa.quadrature.scalar;
public class RiemannIntegratorSampler
implements SampledFunctionIterator {
private SampledFunctionIterator iter;
private ScalarValuedPair current;
private double sum;
public RiemannIntegratorSampler(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
this.iter = iter;
current = iter.nextSamplePoint();
sum = 0.0;
public boolean hasNext() {
return iter.hasNext();
public ScalarValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
ScalarValuedPair previous = current;
current = iter.nextSamplePoint();
sum    += (current.getX() - previous.getX()) * previous.getY();
return new ScalarValuedPair(current.getX(), sum);
package org.spaceroots.mantissa.quadrature.scalar;
public class GaussLegendreIntegrator
implements ComputableFunctionIntegrator {
public GaussLegendreIntegrator(int minPoints, double rawStep) {
if (minPoints <= 2) {
weightedRoots = new double[][] {
weightedRoots = new double[][] {
weightedRoots = new double[][] {
-Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) },
-Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },
Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },
Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) }
weightedRoots = new double[][] {
-Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) },
-Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },
0.0 },
Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },
Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) }
this.rawStep = rawStep;
public int getEvaluationsPerStep() {
return weightedRoots.length;
public double integrate(ComputableFunction f, double a, double b)
throws FunctionException {
if (b < a) {
double tmp = b;
b          = a;
a          = tmp;
long   n     = Math.round(0.5 + (b - a) / rawStep);
double step  = (b - a) / n;
double halfStep = step / 2.0;
double midPoint = a + halfStep;
double sum = 0.0;
for (long i = 0; i < n; ++i) {
for (int j = 0; j < weightedRoots.length; ++j) {
sum += weightedRoots[j][0]
midPoint += step;
return halfStep * sum;
double[][] weightedRoots;
double rawStep;
package org.spaceroots.mantissa.quadrature.scalar;
public class TrapezoidIntegrator
implements SampledFunctionIntegrator {
public double integrate(SampledFunctionIterator iter)
throws ExhaustedSampleException, FunctionException {
TrapezoidIntegratorSampler sampler = new TrapezoidIntegratorSampler(iter);
double sum = 0.0;
while (true) {
sum = sampler.nextSamplePoint().getY();
return sum;
package org.spaceroots.mantissa.utilities;
class ArrayMapperEntry {
public final ArraySliceMappable object;
public final int offset;
public ArrayMapperEntry(ArraySliceMappable object, int offset) {
this.object = object;
this.offset = offset;
package org.spaceroots.mantissa.utilities;
public class Interval {
public Interval() {
inf = 0;
sup = 0;
public Interval(double a, double b) {
if (a <= b) {
inf = a;
sup = b;
inf = b;
sup = a;
public Interval(Interval i) {
inf = i.inf;
sup = i.sup;
public double getInf() {
return inf;
public double getSup() {
return sup;
public double getLength() {
return sup - inf;
public boolean contains(double x) {
return (inf <= x) && (x <= sup);
public boolean contains(Interval i) {
return (inf <= i.inf) && (i.sup <= sup);
public boolean intersects(Interval i) {
return (inf <= i.sup) && (i.inf <= sup);
public void addToSelf(Interval i) {
inf = Math.min(inf, i.inf);
sup = Math.max(sup, i.sup);
public static Interval add(Interval i1, Interval i2) {
Interval copy = new Interval(i1);
copy.addToSelf(i2);
return copy;
public void intersectSelf(Interval i) {
inf = Math.max(inf, i.inf);
sup = Math.max(Math.min(sup, i.sup), inf);
public static Interval intersection(Interval i1, Interval i2) {
Interval copy = new Interval(i1);
copy.intersectSelf(i2);
return copy;
private double inf;
private double sup;
package org.spaceroots.mantissa.utilities;
public interface ArraySliceMappable {
public int getStateDimension();
public void mapStateFromArray(int start, double[] array);
public void mapStateToArray(int start, double[] array);
package org.spaceroots.mantissa.utilities;
public class MappableArray
implements ArraySliceMappable {
public MappableArray(int dimension) {
internalArray = new double[dimension];
for (int i = 0; i < dimension; ++i) {
internalArray[i] = 0;
public MappableArray(double[] array) {
internalArray = (double[]) array.clone();
public double[] getArray () {
return (double[]) internalArray.clone();
public int getStateDimension() {
return internalArray.length;
public void mapStateFromArray(int start, double[] array) {
System.arraycopy(array, start, internalArray, 0, internalArray.length);
public void mapStateToArray(int start, double[] array) {
System.arraycopy(internalArray, 0, array, start, internalArray.length);
double[] internalArray;
package org.spaceroots.mantissa.utilities;
public class ArrayMapper {
public ArrayMapper() {
domainObjects = new ArrayList();
size          = 0;
internalData  = null;
public ArrayMapper(ArraySliceMappable object) {
domainObjects = new ArrayList();
domainObjects.add(new ArrayMapperEntry(object, 0));
size = object.getStateDimension();
internalData = new double [size];
public void manageMappable(ArraySliceMappable object) {
domainObjects.add(new ArrayMapperEntry(object, size));
size += object.getStateDimension();
if (internalData != null) {
internalData = new double [size];
public double[] getDataArray() {
if (internalData == null) {
internalData = new double [size];
return (double[]) internalData.clone();
public void updateObjects() {
if (internalData == null) {
internalData = new double [size];
updateObjects(internalData);
public void updateObjects(double[] data) {
for (Iterator iter = domainObjects.iterator(); iter.hasNext();) {
ArrayMapperEntry entry = (ArrayMapperEntry) iter.next();
entry.object.mapStateFromArray(entry.offset, data);
public void updateArray() {
if (internalData == null) {
internalData = new double [size];
updateArray(internalData);
public void updateArray(double[] data) {
for (Iterator iter = domainObjects.iterator(); iter.hasNext();) {
ArrayMapperEntry entry = (ArrayMapperEntry) iter.next();
entry.object.mapStateToArray(entry.offset, data);
private ArrayList domainObjects;
private int size;
private double[] internalData;
package org.spaceroots.mantissa.utilities;
public class MappableScalar
implements ArraySliceMappable {
public MappableScalar() {
value = 0;
public MappableScalar(double value) {
this.value = value;
public double getValue () {
return value;
public void setValue (double value) {
this.value = value;
public int getStateDimension() {
return 1;
public void mapStateFromArray(int start, double[] array) {
value = array[start];
public void mapStateToArray(int start, double[] array) {
array[start] = value;
double value;
package org.spaceroots.mantissa.utilities;
public class IntervalsList {
public IntervalsList() {
intervals = new ArrayList();
public IntervalsList(double a, double b) {
intervals = new ArrayList();
intervals.add(new Interval(a, b));
public IntervalsList(Interval i) {
intervals = new ArrayList();
intervals.add(i);
public IntervalsList(Interval i1, Interval i2) {
intervals = new ArrayList();
if (i1.intersects(i2)) {
intervals.add(new Interval(Math.min(i1.getInf(), i2.getInf()),
Math.max(i1.getSup(), i2.getSup())));
intervals.add(i1);
intervals.add(i2);
intervals.add(i2);
intervals.add(i1);
public IntervalsList(IntervalsList list) {
intervals = new ArrayList(list.intervals.size());
for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {
intervals.add(new Interval((Interval) iterator.next()));
public boolean isEmpty() {
return intervals.isEmpty();
public boolean isConnex() {
return intervals.size() == 1;
public double getInf() {
return intervals.isEmpty()
? Double.NaN : ((Interval) intervals.get(0)).getInf();
public double getSup() {
return intervals.isEmpty()
? Double.NaN : ((Interval) intervals.get(intervals.size() - 1)).getSup();
public int getSize() {
return intervals.size();
public Interval getInterval(int i) {
return (Interval) intervals.get(i);
public List getIntervals() {
return intervals;
public boolean contains(double x) {
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
if (((Interval) iterator.next()).contains(x)) {
return true;
return false;
public boolean contains(Interval i) {
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
if (((Interval) iterator.next()).contains(i)) {
return true;
return false;
public boolean intersects(Interval i) {
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
if (((Interval) iterator.next()).intersects(i)) {
return true;
return false;
public void addToSelf(Interval i) {
List    newIntervals = new ArrayList();
double  inf          = Double.NaN;
double  sup          = Double.NaN;
boolean pending      = false;
boolean processed    = false;
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
Interval local = (Interval) iterator.next();
if (local.getSup() < i.getInf()) {
newIntervals.add(local);
if (! pending) {
inf     = Math.min(local.getInf(), i.getInf());
pending   = true;
processed = true;
sup = Math.max(local.getSup(), i.getSup());
if (pending) {
newIntervals.add(new Interval(inf, sup));
pending   = false;
newIntervals.add(i);
processed = true;
newIntervals.add(local);
if (pending) {
newIntervals.add(new Interval(inf, sup));
newIntervals.add(i);
intervals = newIntervals;
public static IntervalsList add(IntervalsList list, Interval i) {
IntervalsList copy = new IntervalsList(list);
copy.addToSelf(i);
return copy;
public void subtractFromSelf(Interval i) {
double a = Math.min(getInf(), i.getInf());
double b = Math.max(getSup(), i.getSup());
intersectSelf(new IntervalsList(new Interval(a - 1.0, i.getInf()),
new Interval(i.getSup(), b + 1.0)));
public static IntervalsList subtract(IntervalsList list, Interval i) {
IntervalsList copy = new IntervalsList(list);
copy.subtractFromSelf(i);
return copy;
public void intersectSelf(Interval i) {
List newIntervals = new ArrayList();
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
Interval local = (Interval) iterator.next();
if (local.intersects(i)) {
newIntervals.add(Interval.intersection(local, i));
intervals = newIntervals;
public static IntervalsList intersection(IntervalsList list, Interval i) {
IntervalsList copy = new IntervalsList(list);
copy.intersectSelf(i);
return copy;
public void addToSelf(IntervalsList list) {
for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {
addToSelf((Interval) iterator.next());
public static IntervalsList add(IntervalsList list1, IntervalsList list2) {
IntervalsList copy = new IntervalsList(list1);
copy.addToSelf(list2);
return copy;
public void subtractFromSelf(IntervalsList list) {
for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {
subtractFromSelf((Interval) iterator.next());
public static IntervalsList subtract(IntervalsList list1, IntervalsList list2) {
IntervalsList copy = new IntervalsList(list1);
copy.subtractFromSelf(list2);
return copy;
public void intersectSelf(IntervalsList list) {
intervals = intersection(this, list).intervals;
public static IntervalsList intersection(IntervalsList list1, IntervalsList list2) {
IntervalsList list = new IntervalsList();
for (Iterator iterator = list2.intervals.iterator(); iterator.hasNext();) {
list.addToSelf(intersection(list1, (Interval) iterator.next()));
return list;
private List intervals;
package org.spaceroots.mantissa.functions;
public class ExhaustedSampleException
extends MantissaException {
public ExhaustedSampleException(int size) {
super("sample contains only {0} elements",
new String[] { Integer.toString(size) });
private static final long serialVersionUID = -1490493298938282440L;
package org.spaceroots.mantissa.functions;
public class FunctionException
extends MantissaException {
public FunctionException(String specifier, String[] parts) {
super(specifier, parts);
public FunctionException(String message) {
super(message);
public FunctionException(Throwable cause) {
super(cause);
private static final long serialVersionUID = 1455885104381976115L;
package org.spaceroots.mantissa.functions.vectorial;
public class VectorialValuedPair
implements Serializable {
public VectorialValuedPair(double x, double[] y) {
this.x = x;
this.y = (double[]) y.clone();
public final double x;
public final double[] y;
private static final long serialVersionUID = -7397116933564410103L;
package org.spaceroots.mantissa.functions.vectorial;
public interface ComputableFunction extends Serializable {
public int getDimension();
public double[] valueAt(double x)
throws FunctionException;
package org.spaceroots.mantissa.functions.vectorial;
public class BasicSampledFunctionIterator
implements SampledFunctionIterator, Serializable {
public BasicSampledFunctionIterator(SampledFunction function) {
this.function = function;
next          = 0;
public int getDimension() {
return function.getDimension();
public boolean hasNext() {
return next < function.size();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
if (next >= function.size()) {
throw new ExhaustedSampleException(function.size());
int current = next++;
return function.samplePointAt(current);
private final SampledFunction function;
private int next;
private static final long serialVersionUID = -4386278658288500627L;
package org.spaceroots.mantissa.functions.vectorial;
public interface SampledFunction extends Serializable {
public int size();
public int getDimension();
public VectorialValuedPair samplePointAt(int index)
throws ArrayIndexOutOfBoundsException, FunctionException;
package org.spaceroots.mantissa.functions.vectorial;
public interface SampledFunctionIterator {
public int getDimension();
public boolean hasNext();
public VectorialValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException;
package org.spaceroots.mantissa.functions.vectorial;
public class ComputableFunctionSampler
implements SampledFunction, Serializable {
public ComputableFunctionSampler(ComputableFunction function,
double begin, double step, int n) {
this.function = function;
this.begin    = begin;
this.step     = step;
this.n        = n;
public ComputableFunctionSampler(ComputableFunction function,
double[] range, int n) {
this.function = function;
begin         = range[0];
step          = (range[1] - range[0]) / (n - 1);
this.n        = n;
public ComputableFunctionSampler(ComputableFunction function,
double[] range, double step,
boolean adjustStep) {
this.function = function;
begin         = range[0];
if (adjustStep) {
n    = (int) Math.ceil((range[1] - range[0]) / step);
this.step = (range[1] - range[0]) / (n - 1);
n    = (int) Math.floor((range[1] - range[0]) / step);
this.step = step;
public int size() {
return n;
public int getDimension() {
return function.getDimension();
public VectorialValuedPair samplePointAt(int index)
throws ArrayIndexOutOfBoundsException, FunctionException {
if (index < 0 || index >= n) {
throw new ArrayIndexOutOfBoundsException();
double x = begin + index * step;
return new VectorialValuedPair (x, function.valueAt(x));
private ComputableFunction function;
private double begin;
private double step;
private int n;
private static final long serialVersionUID = 1368582688313212821L;
package org.spaceroots.mantissa.functions.scalar;
public interface ComputableFunction extends Serializable {
public double valueAt(double x)
throws FunctionException;
package org.spaceroots.mantissa.functions.scalar;
public class BasicSampledFunctionIterator
implements SampledFunctionIterator, Serializable {
private final SampledFunction function;
private int next;
public BasicSampledFunctionIterator(SampledFunction function) {
this.function = function;
next          = 0;
public boolean hasNext() {
return next < function.size();
public ScalarValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException {
if (next >= function.size()) {
throw new ExhaustedSampleException(function.size());
int current = next++;
return function.samplePointAt(current);
private static final long serialVersionUID = -9106690005598356403L;
package org.spaceroots.mantissa.functions.scalar;
public class ScalarValuedPair
implements Serializable {
public ScalarValuedPair(double x, double y) {
this.x = x;
this.y = y;
public ScalarValuedPair(ScalarValuedPair p) {
x = p.x;
y = p.y;
public double getX() {
return x;
public double getY() {
return y;
public void setX(double x) {
this.x = x;
public void setY(double y) {
this.y = y;
private double x;
private double y;
private static final long serialVersionUID = 1884346552569300794L;
package org.spaceroots.mantissa.functions.scalar;
public interface SampledFunction extends Serializable {
public int size();
public ScalarValuedPair samplePointAt(int index)
throws ArrayIndexOutOfBoundsException, FunctionException;
package org.spaceroots.mantissa.functions.scalar;
public interface SampledFunctionIterator {
public boolean hasNext();
public ScalarValuedPair nextSamplePoint()
throws ExhaustedSampleException, FunctionException;
package org.spaceroots.mantissa.functions.scalar;
public class ComputableFunctionSampler
implements SampledFunction, Serializable {
private ComputableFunction function;
private double begin;
private double step;
private int n;
public ComputableFunctionSampler(ComputableFunction function,
double begin, double step, int n) {
this.function = function;
this.begin    = begin;
this.step     = step;
this.n        = n;
public ComputableFunctionSampler(ComputableFunction function,
double[] range, int n) {
this.function = function;
begin         = range[0];
step          = (range[1] - range[0]) / (n - 1);
this.n        = n;
public ComputableFunctionSampler(ComputableFunction function,
double[] range, double step,
boolean adjustStep) {
this.function = function;
begin         = range [0];
if (adjustStep) {
n         = (int) Math.ceil((range[1] - range[0]) / step);
this.step = (range[1] - range[0]) / (n - 1);
n         = (int) Math.floor((range[1] - range[0]) / step);
this.step = step;
public int size() {
return n;
public ScalarValuedPair samplePointAt(int index)
throws ArrayIndexOutOfBoundsException, FunctionException {
if (index < 0 || index >= n) {
throw new ArrayIndexOutOfBoundsException();
double x = begin + index * step;
return new ScalarValuedPair(x, function.valueAt(x));
private static final long serialVersionUID = -5127043442851795719L;
package org.spaceroots.mantissa.random;
public class ScalarSampleStatistics {
private int n;
private double min;
private double max;
private double sum;
private double sum2;
public ScalarSampleStatistics() {
n    = 0;
min  = Double.NaN;
max  = min;
sum  = 0;
sum2 = 0;
public void add(double x) {
if (n++ == 0) {
min  = x;
max  = x;
sum  = x;
sum2 = x * x;
if (x < min) {
min = x;
max = x;
sum  += x;
sum2 += x * x;
public void add(double[] points) {
for (int i = 0; i < points.length; ++i) {
add(points[i]);
public void add(ScalarSampleStatistics s) {
if (s.n == 0) {
return;
if (n == 0) {
n    = s.n;
min  = s.min;
max  = s.max;
sum  = s.sum;
sum2 = s.sum2;
n += s.n;
if (s.min < min) {
min = s.min;
max = s.max;
sum  += s.sum;
sum2 += s.sum2;
public int size() {
return n;
public double getMin() {
return min;
public double getMax() {
return max;
public double getMean() {
return (n == 0) ? 0 : (sum / n);
public double getStandardDeviation() {
if (n < 2) {
return 0;
return Math.sqrt((n * sum2 - sum * sum) / (n * (n - 1)));
package org.spaceroots.mantissa.random;
public class VectorialSampleStatistics {
private int dimension;
private int n;
private int[] minIndices;
private double[] min;
private double[] max;
private int[] maxIndices;
private double[] sum;
private double[] sum2;
public VectorialSampleStatistics() {
dimension  = -1;
n          = 0;
min        = null;
minIndices = null;
max        = null;
maxIndices = null;
sum        = null;
sum2       = null;
public void add(double[] x) {
if (n == 0) {
dimension  = x.length;
minIndices = new int[dimension];
maxIndices = new int[dimension];
min        = (double[]) x.clone();
max        = (double[]) x.clone();
sum        = (double[]) x.clone();
sum2       = new double[dimension * (dimension + 1) / 2];
int k = 0;
for (int i = 0; i < dimension; ++i) {
for (int j = 0; j <= i; ++j) {
sum2[k++] = x[i] * x[j];
int k = 0;
for (int i = 0; i < dimension; ++i) {
if (x[i] < min[i]) {
min[i]        = x[i];
minIndices[i] = n;
max[i]        = x[i];
maxIndices[i] = n;
sum[i] += x[i];
for (int j = 0; j <= i; ++j) {
sum2[k++] += x[i] * x[j];
++n;
public void add(double[][] points) {
for (int i = 0; i < points.length; ++i) {
add(points[i]);
public void add(VectorialSampleStatistics s) {
if (s.n == 0) {
return;
if (n == 0) {
dimension = s.dimension;
min        = (double[]) s.min.clone();
minIndices = (int[])    s.minIndices.clone();
max        = (double[]) s.max.clone();
maxIndices = (int[])    s.maxIndices.clone();
sum        = (double[]) s.sum.clone();
sum2       = (double[]) s.sum2.clone();
int k = 0;
for (int i = 0; i < dimension; ++i) {
if (s.min[i] < min[i]) {
min[i]        = s.min[i];
minIndices[i] = n;
max[i]        = s.max[i];
maxIndices[i] = n;
sum[i] += s.sum[i];
for (int j = 0; j <= i; ++j) {
sum2[k] += s.sum2[k];
++k;
n += s.n;
public int size() {
return n;
public double[] getMin() {
return (double[]) min.clone();
public int[] getMinIndices() {
return (int[]) minIndices.clone();
public double[] getMax() {
return (double[]) max.clone();
public int[] getMaxIndices() {
return (int[]) maxIndices.clone();
public double[] getMean() {
if (n == 0) {
return new double[0];
double[] mean = new double[dimension];
for (int i = 0; i < dimension; ++i) {
mean[i] = sum[i] / n;
return mean;
public SymetricalMatrix getCovarianceMatrix(SymetricalMatrix covariance) {
if (n < 2) {
return null;
if (covariance == null) {
covariance = new SymetricalMatrix(dimension);
double c = 1.0 / (n * (n - 1));
int k = 0;
for (int i = 0; i < dimension; ++i) {
for (int j = 0; j <= i; ++j) {
double e = c * (n * sum2[k] - sum[i] * sum[j]);
covariance.setElementAndSymetricalElement(i, j, e);
++k;
return covariance;
package org.spaceroots.mantissa.algebra;
public class PolynomialFraction implements Serializable {
public PolynomialFraction() {
this(new Polynomial.Rational(RationalNumber.ZERO),
new Polynomial.Rational(RationalNumber.ONE));
public PolynomialFraction(long numerator, long denominator) {
this(new Polynomial.Rational(numerator),
new Polynomial.Rational(denominator));
public PolynomialFraction(BigInteger numerator, BigInteger denominator) {
this(new Polynomial.Rational(new RationalNumber(numerator)),
new Polynomial.Rational(new RationalNumber(denominator)));
public PolynomialFraction(RationalNumber numerator,
RationalNumber denominator) {
this(new Polynomial.Rational(numerator),
new Polynomial.Rational(denominator));
public PolynomialFraction(Polynomial.Rational numerator,
Polynomial.Rational denominator) {
if (denominator.isZero()) {
throw new ArithmeticException("null denominator");
p = numerator;
q = denominator;
RationalNumber[] a = q.getCoefficients();
if (a[a.length - 1].isNegative()) {
p = (Polynomial.Rational) p.negate();
q = (Polynomial.Rational) q.negate();
simplify();
public PolynomialFraction(long l) {
this(l, 1l);
public PolynomialFraction(BigInteger i) {
this(i, BigInteger.ONE);
public PolynomialFraction(RationalNumber r) {
this(r.getNumerator(), r.getDenominator());
public PolynomialFraction(Polynomial.Rational p) {
this(p, new Polynomial.Rational(1l));
public PolynomialFraction negate() {
return new PolynomialFraction((Polynomial.Rational) p.negate(), q);
public PolynomialFraction add(PolynomialFraction f) {
return new PolynomialFraction(p.multiply(f.q).add(f.p.multiply(q)),
q.multiply(f.q));
public PolynomialFraction subtract(PolynomialFraction f) {
return new PolynomialFraction(p.multiply(f.q).subtract(f.p.multiply(q)),
q.multiply(f.q));
public PolynomialFraction multiply(PolynomialFraction f) {
PolynomialFraction product =
new PolynomialFraction(p.multiply(f.p), q.multiply(f.q));
product.simplify();
return product;
public PolynomialFraction divide(PolynomialFraction f) {
if (f.p.isZero()) {
throw new ArithmeticException("divide by zero");
Polynomial.Rational newP = p.multiply(f.q);
Polynomial.Rational newQ = q.multiply(f.p);
RationalNumber[] a = newQ.getCoefficients();
if (a[a.length - 1].isNegative()) {
newP = (Polynomial.Rational) newP.negate();
newQ = (Polynomial.Rational) newQ.negate();
PolynomialFraction result = new PolynomialFraction(newP, newQ);
result.simplify();
return result;
public PolynomialFraction invert() {
if (p.isZero()) {
throw new ArithmeticException("divide by zero");
RationalNumber[] a = p.getCoefficients();
PolynomialFraction inverse =
(a[a.length - 1].isNegative())
? new PolynomialFraction((Polynomial.Rational) q.negate(),
(Polynomial.Rational) p.negate())
: new PolynomialFraction(q, p);
inverse.simplify();
return inverse;
private void simplify() {
Polynomial.Rational a = p;
Polynomial.Rational b = q;
if (a.getDegree() < b.getDegree()) {
Polynomial.Rational tmp = a;
a = b;
b = tmp;
Polynomial.DivisionResult res =
Polynomial.Rational.euclidianDivision(a, b);
while (res.remainder.getDegree() != 0) {
a = b;
b = res.remainder;
res = Polynomial.Rational.euclidianDivision(a, b);
if (res.remainder.isZero()) {
p = Polynomial.Rational.euclidianDivision(p, b).quotient;
q = Polynomial.Rational.euclidianDivision(q, b).quotient;
if (q.getDegree() == 0) {
if (! q.isOne()) {
p = (Polynomial.Rational) p.divide(q.getCoefficients()[0]);
q = new Polynomial.Rational(1l);
BigInteger lcm = p.getDenominatorsLCM();
if (lcm.compareTo(BigInteger.ONE) != 0) {
p = (Polynomial.Rational) p.multiply(lcm);
q = (Polynomial.Rational) q.multiply(lcm);
lcm = q.getDenominatorsLCM();
if (lcm.compareTo(BigInteger.ONE) != 0) {
p = (Polynomial.Rational) p.multiply(lcm);
q = (Polynomial.Rational) q.multiply(lcm);
if (q.getCoefficients()[q.getDegree()].isNegative()) {
p = (Polynomial.Rational) p.negate();
q = (Polynomial.Rational) q.negate();
public Polynomial.Rational getNumerator() {
return p;
public Polynomial.Rational getDenominator() {
return q;
public String toString() {
if (p.isZero()) {
return "0";
return p.toString();
StringBuffer s = new StringBuffer();
String pString = p.toString();
if (pString.indexOf(' ') > 0) {
s.append('(');
s.append(pString);
s.append(')');
s.append(pString);
s.append('/');
String qString = q.toString();
if (qString.indexOf(' ') > 0) {
s.append('(');
s.append(qString);
s.append(')');
s.append(qString);
return s.toString();
private Polynomial.Rational p;
private Polynomial.Rational q;
private static final long serialVersionUID = 6033909492898954748L;
package org.spaceroots.mantissa.algebra;
public abstract class OrthogonalPolynomial
extends Polynomial.Rational {
protected OrthogonalPolynomial(int degree, CoefficientsGenerator generator) {
a       = generator.getCoefficients(degree);
package org.spaceroots.mantissa.algebra;
public class RationalNumber implements Serializable {
public static final RationalNumber ZERO = new RationalNumber(0l);
public static final RationalNumber ONE  = new RationalNumber(1l);
public RationalNumber() {
p = BigInteger.ZERO;
q = BigInteger.ONE;
public RationalNumber(long numerator, long denominator) {
if (denominator == 0l) {
throw new ArithmeticException("divide by zero");
p = BigInteger.valueOf(numerator);
q = BigInteger.valueOf(denominator);
if (q.signum() < 0) {
p = p.negate();
q = q.negate();
simplify();
public RationalNumber(BigInteger numerator, BigInteger denominator) {
if (denominator.signum() == 0) {
throw new ArithmeticException("divide by zero");
p = numerator;
q = denominator;
if (q.signum() < 0) {
p = p.negate();
q = q.negate();
simplify();
public RationalNumber(long l) {
p = BigInteger.valueOf(l);
q = BigInteger.ONE;
public RationalNumber(BigInteger i) {
p = i;
q = BigInteger.ONE;
public RationalNumber negate() {
return new RationalNumber(p.negate(), q);
public RationalNumber add(long l) {
return add(BigInteger.valueOf(l));
public RationalNumber add(BigInteger l) {
return new RationalNumber(p.add(q.multiply(l)), q);
public RationalNumber add(RationalNumber r) {
return new RationalNumber(p.multiply(r.q).add(r.p.multiply(q)),
q.multiply(r.q));
public RationalNumber subtract(long l) {
return subtract(BigInteger.valueOf(l));
public RationalNumber subtract(BigInteger l) {
return new RationalNumber(p.subtract(q.multiply(l)), q);
public RationalNumber subtract(RationalNumber r) {
return new RationalNumber(p.multiply(r.q).subtract(r.p.multiply(q)),
q.multiply(r.q));
public RationalNumber multiply(long l) {
return multiply(BigInteger.valueOf(l));
public RationalNumber multiply(BigInteger l) {
return new RationalNumber(p.multiply(l), q);
public RationalNumber multiply(RationalNumber r) {
return new RationalNumber(p.multiply(r.p), q.multiply(r.q));
public RationalNumber divide(long l) {
return divide(BigInteger.valueOf(l));
public RationalNumber divide(BigInteger l) {
if (l.signum() == 0) {
throw new ArithmeticException("divide by zero");
if (l.signum() > 0) {
return new RationalNumber(p, q.multiply(l));
return new RationalNumber(p.negate(), q.multiply(l.negate()));
public RationalNumber divide(RationalNumber r) {
if (r.p.signum() == 0) {
throw new ArithmeticException("divide by zero");
BigInteger newP = p.multiply(r.q);
BigInteger newQ = q.multiply(r.p);
return (newQ.signum() < 0) ? new RationalNumber(newP.negate(),
newQ.negate())
: new RationalNumber(newP, newQ);
public RationalNumber invert() {
if (p.signum() == 0) {
throw new ArithmeticException("divide by zero");
return (q.signum() < 0) ? new RationalNumber(q.negate(), p.negate())
: new RationalNumber(q, p);
private void simplify() {
if (p.signum() == 0) {
q = BigInteger.ONE;
BigInteger gcd = p.gcd(q);
p = p.divide(gcd);
q = q.divide(gcd);
public BigInteger getNumerator() {
return p;
public BigInteger getDenominator() {
return q;
public boolean isZero() {
return p.signum() == 0;
public boolean isOne() {
return (p.compareTo(BigInteger.ONE) == 0)
&& (q.compareTo(BigInteger.ONE) == 0);
public boolean isInteger() {
return q.compareTo(BigInteger.ONE) == 0;
public boolean isNegative() {
return p.signum() < 0;
public static RationalNumber abs(RationalNumber r) {
return new RationalNumber(r.p.abs(), r.q);
public double doubleValue() {
BigInteger[] result = p.divideAndRemainder(q);
return result[0].doubleValue()
+ (result[1].doubleValue() / q.doubleValue());
public boolean equals(Object o) {
if (o instanceof RationalNumber) {
RationalNumber r = (RationalNumber) o;
return (p.compareTo(r.p) == 0) && (q.compareTo(r.q) == 0);
return false;
public int hashCode() {
return p.hashCode() ^ q.hashCode();
public String toString() {
return p + ((q.compareTo(BigInteger.ONE) == 0) ? "" : ("/" + q));
private BigInteger p;
private BigInteger q;
private static final long serialVersionUID = -324954393137577531L;
package org.spaceroots.mantissa.algebra;
public abstract class CoefficientsGenerator {
protected CoefficientsGenerator(RationalNumber a00,
RationalNumber a01, RationalNumber a11) {
l = new ArrayList();
l.add(a00);
l.add(a01);
l.add(a11);
maxDegree = 1;
protected void setRecurrenceCoefficients(RationalNumber b2k,
RationalNumber b3k,
RationalNumber b4k) {
this.b2k = b2k;
this.b3k = b3k;
this.b4k = b4k;
protected abstract void setRecurrenceCoefficients(int k);
private void computeUpToDegree(int degree) {
int startK = (maxDegree - 1) * maxDegree / 2;
for (int k = maxDegree; k < degree; ++k) {
int startKm1 = startK;
startK += k;
setRecurrenceCoefficients(k);
RationalNumber ckPrev = null;
RationalNumber ck     = (RationalNumber) l.get(startK);
RationalNumber ckm1   = (RationalNumber) l.get(startKm1);
l.add(ck.multiply(b2k).subtract(ckm1.multiply(b4k)));
for (int i = 1; i < k; ++i) {
ckPrev = ck;
ck     = (RationalNumber) l.get(startK + i);
ckm1   = (RationalNumber) l.get(startKm1 + i);
l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)).subtract(ckm1.multiply(b4k)));
ckPrev = ck;
ck     = (RationalNumber) l.get(startK + k);
l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)));
l.add(ck.multiply(b3k));
maxDegree = degree;
public RationalNumber[] getCoefficients(int degree) {
synchronized (this) {
if (degree > maxDegree) {
computeUpToDegree(degree);
int start = degree * (degree + 1) / 2;
RationalNumber[] a = new RationalNumber[degree + 1];
for (int i = 0; i <= degree; ++i) {
a[i] = (RationalNumber) l.get(start + i);
return a;
private ArrayList l;
private int maxDegree;
private RationalNumber b2k;
private RationalNumber b3k;
private RationalNumber b4k;
package org.spaceroots.mantissa.algebra;
public class Chebyshev
extends OrthogonalPolynomial {
private static final CoefficientsGenerator generator =
new CoefficientsGenerator(new RationalNumber(1l),
new RationalNumber(0l),
new RationalNumber(1l)) {
public void setRecurrenceCoefficients(int k) {
setRecurrenceCoefficients(new RationalNumber(0l),
new RationalNumber(2l),
new RationalNumber(1l));
public Chebyshev() {
super(0, generator);
public Chebyshev(int degree) {
super(degree, generator);
private static final long serialVersionUID = -893367988717182601L;
package org.spaceroots.mantissa.algebra;
public abstract class Polynomial implements Serializable {
public abstract boolean isZero();
public abstract boolean isOne();
public abstract boolean isIdentity();
public abstract int getDegree();
public abstract Polynomial negate();
public abstract Polynomial multiply(RationalNumber r);
public abstract Polynomial multiply(long l);
public Polynomial multiply(BigInteger i) {
return multiply(new RationalNumber(i));
public Polynomial divide(long l) {
return divide(new RationalNumber(l));
public Polynomial divide(RationalNumber r) {
return multiply(r.invert());
public Polynomial divide(BigInteger i) {
return divide(new RationalNumber(i));
public abstract double valueAt(double x);
public abstract Polynomial getDerivative();
public static class Rational extends Polynomial {
public Rational() {
a = new RationalNumber[] { RationalNumber.ZERO };
public Rational(long value) {
this(new RationalNumber(value));
public Rational(RationalNumber value) {
a = new RationalNumber[] { value };
public Rational(long a1, long a0) {
this(new RationalNumber(a1), new RationalNumber(a0));
public Rational(RationalNumber a1, RationalNumber a0) {
if (! a1.isZero()) {
a = new RationalNumber[] { a0, a1 };
a = new RationalNumber[] { a0 };
public Rational(long a2, long a1, long a0) {
this(new RationalNumber(a2),
new RationalNumber(a1),
new RationalNumber(a0));
public Rational(RationalNumber a2, RationalNumber a1, RationalNumber a0) {
if (! a2.isZero()) {
a = new RationalNumber[] { a0, a1, a2 };
if (! a1.isZero()) {
a = new RationalNumber[] { a0, a1 };
a = new RationalNumber[] { a0 };
public Rational(long a3, long a2, long a1, long a0) {
this(new RationalNumber(a3),
new RationalNumber(a2),
new RationalNumber(a1),
new RationalNumber(a0));
public Rational(RationalNumber a3, RationalNumber a2,
RationalNumber a1, RationalNumber a0) {
if (! a3.isZero()) {
a = new RationalNumber[] { a0, a1, a2, a3 };
if (! a2.isZero()) {
a = new RationalNumber[] { a0, a1, a2 };
if (! a1.isZero()) {
a = new RationalNumber[] { a0, a1 };
a = new RationalNumber[] { a0 };
public Rational(RationalNumber[] a) {
int i = a.length - 1;
while ((i > 0) && (a[i].isZero())) {
--i;
this.a = new RationalNumber[i + 1];
System.arraycopy(a, 0, this.a, 0, i + 1);
public Rational(RationalNumber c, int degree) {
if (c.isZero() || degree < 0) {
a = new RationalNumber[] { RationalNumber.ZERO };
a = new RationalNumber[degree + 1];
Arrays.fill(a, 0, degree, RationalNumber.ZERO);
a[degree] = c;
public boolean isZero() {
return (a.length == 1) && a[0].isZero();
public boolean isOne() {
return (a.length == 1) && a[0].isOne();
public boolean isIdentity() {
return (a.length == 2) && a[0].isZero() && a[1].isOne();
public int getDegree() {
return a.length - 1;
public RationalNumber[] getCoefficients() {
return (RationalNumber[]) a.clone();
public Rational add(Rational p) {
int lowLength  = Math.min(a.length, p.a.length);
int highLength = Math.max(a.length, p.a.length);
RationalNumber[] newA = new RationalNumber[highLength];
for (int i = 0; i < lowLength; ++i) {
newA[i] = a[i].add(p.a[i]);
System.arraycopy((a.length < p.a.length) ? p.a : a,
lowLength, newA, lowLength, highLength - lowLength);
return new Rational(newA);
public Rational subtract(Rational p) {
int lowLength  = Math.min(a.length, p.a.length);
int highLength = Math.max(a.length, p.a.length);
RationalNumber[] newA = new RationalNumber[highLength];
for (int i = 0; i < lowLength; ++i) {
newA[i] = a[i].subtract(p.a[i]);
if (a.length < p.a.length) {
for (int i = lowLength; i < highLength; ++i) {
newA[i] = p.a[i].negate();
System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);
return new Rational(newA);
public Polynomial negate() {
RationalNumber[] newA = new RationalNumber[a.length];
for (int i = 0; i < a.length; ++i) {
newA[i] = a[i].negate();
return new Rational(newA);
public Rational multiply(Rational p) {
RationalNumber[] newA = new RationalNumber[a.length + p.a.length - 1];
for (int i = 0; i < newA.length; ++i) {
newA[i] = RationalNumber.ZERO;
for (int j = Math.max(0, i + 1 - p.a.length);
j < Math.min(a.length, i + 1);
++j) {
newA[i] = newA[i].add(a[j].multiply(p.a[i-j]));
return new Rational(newA);
public Polynomial multiply(long l) {
return multiply(new RationalNumber(l));
public Polynomial multiply(RationalNumber r) {
if (r.isZero()) {
return new Rational(new RationalNumber[] { RationalNumber.ZERO });
if (r.isOne()) {
return this;
RationalNumber[] newA = new RationalNumber[a.length];
for (int i = 0; i < a.length; ++i) {
newA[i] = a[i].multiply(r);
return new Rational(newA);
public double valueAt(double x) {
double y = 0;
for (int i = a.length - 1; i >= 0; --i) {
y = y * x + a[i].doubleValue();
return y;
public Polynomial getDerivative() {
if (a.length == 1) {
return new Rational();
RationalNumber[] newA = new RationalNumber[a.length - 1];
for (int i = 1; i < a.length; ++i) {
newA[i - 1] = a[i].multiply(i);
return new Rational(newA);
public static DivisionResult euclidianDivision(Rational dividend,
Rational divisor) {
Rational quotient  = new Rational(0l);
Rational remainder = dividend;
int divisorDegree   = divisor.getDegree();
int remainderDegree = remainder.getDegree();
while ((! remainder.isZero()) && (remainderDegree >= divisorDegree)) {
RationalNumber c =
remainder.a[remainderDegree].divide(divisor.a[divisorDegree]);
Rational monomial = new Rational(c, remainderDegree - divisorDegree);
remainder = remainder.subtract(monomial.multiply(divisor));
quotient  = quotient.add(monomial);
remainderDegree = remainder.getDegree();
return new DivisionResult(quotient, remainder);
public BigInteger getDenominatorsLCM() {
BigInteger lcm = BigInteger.ONE;
for (int i = 0; i < a.length; ++i) {
RationalNumber newCoeff = a[i].multiply(lcm);
if (! newCoeff.isInteger()) {
lcm = lcm.multiply(newCoeff.getDenominator());
return lcm;
public String toString() {
StringBuffer s = new StringBuffer();
if (a[0].isZero()) {
if (a.length == 1) {
return "0";
s.append(a[0].toString());
for (int i = 1; i < a.length; ++i) {
if (! a[i].isZero()) {
if (s.length() > 0) {
if (a[i].isNegative()) {
s.append(" - ");
s.append(" + ");
if (a[i].isNegative()) {
s.append("-");
RationalNumber absAi = RationalNumber.abs(a[i]);
if (! absAi.isOne()) {
s.append(absAi.toString());
s.append(' ');
s.append("x");
if (i > 1) {
s.append('^');
s.append(Integer.toString(i));
return s.toString();
protected RationalNumber[] a;
private static final long serialVersionUID = -794133890636181115L;
public static class DivisionResult {
public final Rational quotient;
public final Rational remainder;
public DivisionResult(Rational quotient, Rational remainder) {
this.quotient  = quotient;
this.remainder = remainder;
public static class Double extends Polynomial {
public Double() {
a = new double[] { 0.0 };
public Double(long value) {
this((double) value);
public Double(double value) {
a = new double[] { value };
public Double(long a1, long a0) {
this((double) a1, (double) a0);
public Double(double a1, double a0) {
if (a1 != 0) {
a = new double[] { a0, a1 };
a = new double[] { a0 };
public Double(long a2, long a1, long a0) {
this((double) a2, (double) a1, (double) a0);
public Double(double a2, double a1, double a0) {
if (a2 != 0) {
a = new double[] { a0, a1, a2 };
if (a1 != 0) {
a = new double[] { a0, a1 };
a = new double[] { a0 };
public Double(long a3, long a2, long a1, long a0) {
this((double) a3, (double) a2, (double) a1, (double) a0);
public Double(double a3, double a2, double a1, double a0) {
if (a3 != 0) {
a = new double[] { a0, a1, a2, a3 };
if (a2 != 0) {
a = new double[] { a0, a1, a2 };
if (a1 != 0) {
a = new double[] { a0, a1 };
a = new double[] { a0 };
public Double(double[] a) {
int i = a.length - 1;
while ((i > 0) && (a[i] == 0)) {
--i;
this.a = new double[i + 1];
System.arraycopy(a, 0, this.a, 0, i + 1);
public Double(double c, int degree) {
if ((c == 0) || degree < 0) {
a = new double[] { 0.0 };
a = new double[degree + 1];
Arrays.fill(a, 0, degree, 0.0);
a[degree] = c;
public Double(Rational r) {
a = new double[r.a.length];
for (int i = 0; i < a.length; ++i) {
a[i] = r.a[i].doubleValue();
public boolean isZero() {
return (a.length == 1) && (a[0] == 0);
public boolean isOne() {
return (a.length == 1) && ((a[0] - 1.0) == 0);
public boolean isIdentity() {
return (a.length == 2) && (a[0] == 0) && ((a[1] - 1.0) == 0);
public int getDegree() {
return a.length - 1;
public double[] getCoefficients() {
return (double[]) a.clone();
public Double add(Double p) {
int lowLength  = Math.min(a.length, p.a.length);
int highLength = Math.max(a.length, p.a.length);
double[] newA = new double[highLength];
for (int i = 0; i < lowLength; ++i) {
newA[i] = a[i] + p.a[i];
System.arraycopy((a.length < p.a.length) ? p.a : a,
lowLength, newA, lowLength, highLength - lowLength);
return new Double(newA);
public Double subtract(Double p) {
int lowLength  = Math.min(a.length, p.a.length);
int highLength = Math.max(a.length, p.a.length);
double[] newA = new double[highLength];
for (int i = 0; i < lowLength; ++i) {
newA[i] = a[i] - p.a[i];
if (a.length < p.a.length) {
for (int i = lowLength; i < highLength; ++i) {
newA[i] = -p.a[i];
System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);
return new Double(newA);
public Polynomial negate() {
double[] newA = new double[a.length];
for (int i = 0; i < a.length; ++i) {
newA[i] = -a[i];
return new Double(newA);
public Double multiply(Double p) {
double[] newA = new double[a.length + p.a.length - 1];
for (int i = 0; i < newA.length; ++i) {
newA[i] = 0.0;
for (int j = Math.max(0, i + 1 - p.a.length);
j < Math.min(a.length, i + 1);
++j) {
newA[i] += a[j] * p.a[i-j];
return new Double(newA);
public Polynomial multiply(long l) {
return multiply((double) l);
public Polynomial multiply(RationalNumber r) {
return multiply(r.doubleValue());
public Polynomial multiply(double r) {
if (r == 0) {
return new Double(new double[] { 0.0 });
double[] newA = new double[a.length];
for (int i = 0; i < a.length; ++i) {
newA[i] = a[i] * r;
return new Double(newA);
public double valueAt(double x) {
double y = 0;
for (int i = a.length - 1; i >= 0; --i) {
y = y * x + a[i];
return y;
public Polynomial getDerivative() {
if (a.length == 1) {
return new Double();
double[] newA = new double[a.length - 1];
for (int i = 1; i < a.length; ++i) {
newA[i - 1] = a[i] * i;
return new Double(newA);
public String toString() {
StringBuffer s = new StringBuffer();
if (a[0] == 0.0) {
if (a.length == 1) {
return "0";
s.append(java.lang.Double.toString(a[0]));
for (int i = 1; i < a.length; ++i) {
if (a[i] != 0) {
if (s.length() > 0) {
if (a[i] < 0) {
s.append(" - ");
s.append(" + ");
if (a[i] < 0) {
s.append("-");
double absAi = Math.abs(a[i]);
if ((absAi - 1) != 0) {
s.append(java.lang.Double.toString(absAi));
s.append(' ');
s.append("x");
if (i > 1) {
s.append('^');
s.append(Integer.toString(i));
return s.toString();
protected double[] a;
private static final long serialVersionUID = -4210522025715687648L;
package org.spaceroots.mantissa.algebra;
public class Legendre
extends OrthogonalPolynomial {
private static final CoefficientsGenerator generator =
new CoefficientsGenerator(new RationalNumber(1l),
new RationalNumber(0l),
new RationalNumber(1l)) {
public void setRecurrenceCoefficients(int k) {
long kP1 = k + 1;
setRecurrenceCoefficients(new RationalNumber(0l),
new RationalNumber(2 * k + 1, kP1),
new RationalNumber(k, kP1));
public Legendre() {
super(0, generator);
public Legendre(int degree) {
super(degree, generator);
private static final long serialVersionUID = 4014485393845978429L;
package org.spaceroots.mantissa.algebra;
public class Hermite
extends OrthogonalPolynomial {
private static final CoefficientsGenerator generator =
new CoefficientsGenerator(new RationalNumber(1l),
new RationalNumber(0l),
new RationalNumber(2l)) {
public void setRecurrenceCoefficients(int k) {
setRecurrenceCoefficients(new RationalNumber(0l),
new RationalNumber(2l),
new RationalNumber(k * 2l));
public Hermite() {
super(0, generator);
public Hermite(int degree) {
super(degree, generator);
private static final long serialVersionUID = 7910082423686662133L;
package org.spaceroots.mantissa.algebra;
public class Laguerre
extends OrthogonalPolynomial {
private static final CoefficientsGenerator generator =
new CoefficientsGenerator(new RationalNumber(1l),
new RationalNumber(1l),
new RationalNumber(-1l)) {
public void setRecurrenceCoefficients(int k) {
long kP1 = k + 1;
setRecurrenceCoefficients(new RationalNumber(2 * k + 1, kP1),
new RationalNumber(-1l, kP1),
new RationalNumber(k, kP1));
public Laguerre() {
super(0, generator);
public Laguerre(int degree) {
super(degree, generator);
private static final long serialVersionUID = 3213856667479179710L;
