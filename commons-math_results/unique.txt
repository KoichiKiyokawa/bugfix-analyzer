f.addValue(twoL);
public int getBinCount() {
setMean(p);
public abstract class RungeKuttaFehlbergIntegrator
double chiSquareTest(long[][] counts) 
for (int k = 0; k < parameters.length; ++k) {
return Math.atan2(y, x);
if (a.length < 1 || c.length < 1) {
assertEquals(loop.getMin(), direct.getMin(), 1.0e-12);
outData[row][col] = data[row][col].add(m.getEntry(row, col));
BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);
double scaling_coefficient = 1.0 / n;
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
Vector3D u3 = Vector3D.crossProduct(u1, u2);
assertTrue("reflexive, non-empty", statistic.equals(statistic));
throws NotARotationMatrixException {
handler         = DummyStepHandler.getInstance();
public boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,
setNormal(z);
y[0] = y[0] * t + coeffs0[i];
if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {
expected[0] = 1;
assertTrue(r3.begin == -4);
public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {
public class ForwardDifferenceDerivative extends AbstractDifferenceDerivative {
assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     
this.temperature = temperature;
void setMedian(double median);
testStatistic.test(testArray, -1, 1);  // start negative
return 1.0d;
if (r.isOne()) {
assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);
double dx = interpolatedY[0] - theoreticalY[0];
for (int i = 0; i < vertices.length; ++i) {
protected double[] fct(double f[]) throws MathException,
Polynomial.Rational q = new Polynomial.Rational(3l, 2l);
assertTrue(map.containsTransformer(expected));
public void testContainsTransformer(){
if (swap[rank] != rank) {
probabilityOfSuccess = p;
double expected = 0.0d;
public class PolynomialFitter
private static class APSProblem28 extends TestProblem {
return quantile;
("row and column dimensions must be positive");
double maxStep      = pb.getFinalTime() - pb.getInitialTime();
suite.addTest(ScalarSampleStatisticsTest.suite());
for (int i = 0; i < largeSampleSize; i++) {
public LowerTriangularMatrixTest(String name) {
double result;
this.point = (double[]) point.clone();
solver.solve(1, 1.5);
ret += probability(n, m, k, x0);
BigInteger gcd = p.gcd(q);
if (denseOutput || (! switchesHandler.isEmpty())) {
MatrixUtils.createBigMatrix(detData2).getData();
for (int index = i * columns; index < i * (columns + 1) + 1; ++index) {
s.append('(');
maxIndices = new int[dimension];
x[i] = sum / decomp[i][i];
lower + " initial=" + initial + " upper=" + upper);
if ((rows != m.rows) || (columns != m.columns)) {
public Function(double begin, double step, int n) {
f2 = new Fraction(-2, 13*17*2);
private SumOfLogs sumOfLogs;
source + "\"", parsePosition.getErrorIndex());
public static void verifyInterval(double lower, double upper) throws
assertTrue(bos.size () < 35000);
0.0, -2.0, 2.0);
private double degreesOfFreedom;
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };
double[] roots15 = {
IntervalsList list2 = new IntervalsList(new Interval(-0.9, -0.8));
public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {
lastError = 0;
double[][] mv1 = m1.getData();
double invR3 = 1 / (r2 * Math.sqrt(r2));
sup = Math.max(local.getSup(), i.getSup());
sumSq.increment(Double.NEGATIVE_INFINITY);
(standardDeviation * Math.sqrt(2.0))));
assertEquals(4d, testDa.getElement(1), 0);
return a1;
assertTrue(m2 instanceof SymetricalMatrix);
public static RealMatrix createColumnRealMatrix(double[] columnData) {
private int maxChecks;
b[rank][rank] = sqrt;
double upperTail = distribution.cumulativeProbability((double) i);
for (int i = 1; i < Math.abs(n); i++) {
this.paramsAccuracy       = 1.0e-5;
assertFalse(z.isNaN());
double[] xLargest      = simplex[n].point;
assertEquals(Math.PI, x, accuracy);
protected TestRandomGenerator testGenerator = new TestRandomGenerator();
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
double t = t0 + subStep;
vectorsInitialized = true;
double dz2 = v2z - u2.getZ();
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1)); 
f.addValue(bChar);
double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j]
jacobian[index++] = factor * wm.getPartial(parameters[j]);
public boolean hasNext() {
if (mean.length != standardDeviation.length) {
x1 = x2; y1 = y2;
return iter.hasNext();
double alpha1, double alpha2, double alpha3) {
public Complex subtract(Complex rhs) {
public abstract class TestFactory {
private double value;
TestUtils.assertContains(result, expected, tolerance);
public static double regularizedGammaQ(final double a, 
double[] s1 = p.exactIntegration(-5.0, 15.0);
if (isBracketing(min, initial, p)) {
super(arg0);
double   theoreticalMinCost,
assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));
double tmp3 = x1 * tmp2 / temp;
c[ii][ij] = f;
finalTime   = Double.NaN;
public double getPhi() {
private static class FreudensteinRothFunction extends MinpackFunction {
assertEquals(1.0, p[1].getEstimate(), 1.0e-10);
int    pj = permutation[j];
assertEquals(0, random.nextGaussian(), 0);
absoluteAccuracy);
c = Math.sqrt(c);
scalar2 = new MappableScalar(2);
assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 0.990) < 1.0e-10);
checkLegendre(new Legendre(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6");
this((double) value);
(cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);
NumberFormat old = properFormat.getDenominatorFormat();
expected = 1.0;
public void testCounts() {
public HypergeometricDistributionImpl(int populationSize,
RealMatrixImpl m = new RealMatrixImpl(singular);
new LinearMeasurement(new double[] { 1.0, -2.0 },
new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());
assertEquals(1.235f, MathUtils.round(x, 3), 0.0);
public final class ValueServerTest extends RetryTestCase {
if ((polynoms == null) || (polynoms.length <= (mu + 4))) {
return getCumPct(new Character(v));         
FastFourierTransformer.verifyDataSet(f);
case BigDecimal.ROUND_FLOOR :
assertEquals(2, p.getColumnDimension());
internalArray = tempArray;
return operate(bd);
solver.resetRelativeAccuracy();
v = v.multiply(3);
public FunctionException(String message) {
this.khi   = khi;
parameters   = new ArrayList();
int mudif) {
GillIntegrator integ = new GillIntegrator(step);
assertTrue(Double.isNaN(Complex.NaN.abs()));
for (int col=0; col<numCols; col++) {
public void testMinpackHelicalValley()
in.close();
public void testAEqualQR() {
return apply(new GeometricMean());
private static final long serialVersionUID = 2570805822599485047L;
double step = (pb.getFinalTime() - pb.getInitialTime())
"none of the {0} start points lead to convergence"  },
public Double subtract(Double p) {
tstGen(5); // ridiculous tolerance; but ridiculous grid size
super(l);
package org.spaceroots.mantissa.functions;
n    = (int) Math.ceil((range[1] - range[0]) / step);
double[] exp = new double[] {
ObjectOutputStream so = new ObjectOutputStream(fo);
public abstract int getOrder();
private void buildSimplex(double[] vertexA, double[] vertexB) {
public abstract double tTest(double mu, double[] sample)
public class MedianTest extends UnivariateStatisticAbstractTest{
private void buildSimplex(double[][] vertices) {
if (f.length == 1) {
public class DuplicateSampleAbscissaException extends MathException  {
Iterator values = valuesIterator();
return new NonNullRange(j, j + 1);
return new TestSuite(RotationTest.class);
(new Complex(theta, 0))).multiply(new Complex(r, 0));
jacobian[m - 2][0] = 1;
public void testCosInf() {
assertEquals(nf, improperFormat.getDenominatorFormat());
public boolean isInfinite() {
private static double k16_13 =       -1199007803.0 / 857031517296.0;
assertTrue(Math.abs(pair2.y[1] + 3.2)        < 1.0e-10);
RationalNumber[]  a = p.getCoefficients();
s2 += dx * parameters[j].getEstimate();
assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);
this.expansionMode = expansionMode;
a = new double[] { a0, a1, a2, a3 };
double[] theoreticalY  = problem.computeTheoreticalState(cT);
Math.sqrt(1795769.0)), false);
WeightedMeasurement[] measurements = new WeightedMeasurement[m];
dx1 * dy3 - dy1 * dx3);
public PolynomialDoubleTest(String name) {
d2v = dv.add(z.multiply(d2v));
public class QRDecompositionImpl implements QRDecomposition {
maxStep = step;
public void testExactIntegration()
public DerivativeException(Throwable cause) {
11.3,
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.5) < 1.0e-10);
getClass().getResourceAsStream(resource)));
public double value(double t) throws FunctionEvaluationException {
yDotK[k] = new double[currentState.length];
assertEquals("Incorrect inverse cumulative probability value returned for " 
xR[j] = centroid[j] + rho * (centroid[j] - xLargest[j]);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
x = new double[] {one, nan, three};
public void setStepHandler (StepHandler handler) {
Complex z = x.add(Complex.NaN);
if (index < 0 || index >= n) {
return getReducedFraction
+ " the approximate solution is possible",
errfac[i] *= e / (j + 1);
testProbability(-1.000, 4.0, 2.0, .0000);
y = p.y;
this.measurements = measurements;
assertEquals("slope std err", 0.429796848199937E-03,
BigMatrixImpl identity = new BigMatrixImpl(id);
double logSum = 0;
public void testSmallStep()
ret = Integer.MAX_VALUE;
public abstract double valueAt(double x);
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
double pT = interpolator.getPreviousTime();
public class MathConfigurationExceptionTest extends TestCase {
statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); 
hNew = Math.abs(switchesHandler.getEventTime() - currentT);
assertEquals(0.0, StatUtils.mean(sample), 0.012);
if (delta / oldDelta > 1) {
RealMatrix invert();
return value.doubleValue();
int N = f.length >> 1;
private static final long serialVersionUID = -5460543876513796612L;
return freqTable.keySet().iterator();
RealMatrix R = new QRDecompositionImpl(matrix).getR();
if (n < 1) {
if (0.1 * cost < previousCost) {
public Polynom (int degree, Random random, double max) {
if (q.getCoefficients()[q.getDegree()].isNegative()) {
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
protected double defaultRelativeAccuracy;
double n0 = (double) moment.getN();
public BigMatrix copy() {
while (values.hasNext()) {
throw new ArithmeticException("Inexact result from rounding");
HarmonicFunction fitted = new HarmonicFunction(coeffs[0],
public void testSSENonNegative() {
org.apache.commons.math.distribution.FDistributionImpl fd =
previousTime  = in.readDouble();
this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;
public BigDecimal[][] getDataRef() {
("Knot values must be strictly increasing.");
assertEquals("empty hash code", emptyHash, u.hashCode());
assertEquals(1.2, ex.getDuplicateAbscissa(), 0);
interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,
protected GeometricMean stat;
assertEquals("4x3 Q size", qr.getQ().getColumnDimension(), 4);
public double cumulativeProbability(int x0, int x1) throws MathException {
public void checkSorted() {
this.khi   = 2.0;
return scale;
private double scale = 1;
problem.getUnboundParameters()[0].getEstimate(),
empiricalDistribution = new EmpiricalDistributionImpl(1);
if (needsNormalization) {
assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),
return Complex.I.negate().multiply(log(sqrt1z(z).add(
suite.addTest(RationalNumberTest.suite());
return multiply(r.invert());
protected double[][] getJacobian() {
h = (t - currentT) / nbStep;
"sample contains only {0} elements" },
protected boolean isBracketing(double lower, double upper, 
protected double[] vecRelativeTolerance;
double [][] getDataAsDoubleArray();
+ theta * (polynoms[1][i]
testStatistic.chiSquare(counts6);
p >= Math.abs(0.5 * oldDelta * p1)) {
public double integrate(double min, double max) throws MaxIterationsExceededException,
= ResourceBundle.getBundle("org.spaceroots.mantissa.MessagesResources");
if (checker.converged(simplex)) {
public abstract boolean tTest(
return new TestSuite(UniformRandomGeneratorTest.class);
public void testConstructorSingleFormat() {
inverseCumulativeTestPoints = null;
expected *= k;
public void setMu(double mu) {
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
private static class Polynom implements ComputableFunction {
solver = new SecantSolver(f);
double probability(double x);
assertEquals("stats with same data should have the same hashcode", 
private double[][] yMidDots;
a = problem.a;
suite.setName("Percentile Tests");
RealMatrixImpl m2 = new RealMatrixImpl();
public static Complex cos(Complex z) {
throws java.lang.Exception { 
double t, double[] y)
prod = 1;
ckPrev = ck;
private static final long serialVersionUID = -2682582852369995960L;
double coefficients[], z, expected, result, tolerance = 1E-12;
verifyCumulativeProbabilities();      
return Math.acos(dot / normProduct);
f2 = new Fraction(1, Integer.MAX_VALUE);
private int numberOfSuccesses;
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(row),
public boolean isForward() {
double twoPi = Math.PI + Math.PI;
super.reinitialize(equations, y, yDotK, forward);
double x = 2.576 / Math.sqrt(2.0);
da.addElement(-2.0);
interpolator.setInterpolatedTime(time);
TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);
double[] inputArray = (double[]) in;
case BigDecimal.ROUND_DOWN :
(n2 * n2 * (n2 - 1d)));
double ph1 = ydiff + 0.25 * (aspl - bspl);
private static final long serialVersionUID = 2849780376767626912L;
BigDecimal[] out = new BigDecimal[ncols];
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
GeometricMean mean = new GeometricMean();
public void testErf1960() throws MathException {
u.addObject(new Foo());
TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);
TrapezoidIntegrator qtrap = new TrapezoidIntegrator(this.f);
throw new ArithmeticException("null denominator");
Complex expected = new Complex(-1.2323, 0);
public void testWithInitialCapacityAndExpansionFactor() {
return minimalIterationCount;
public UncorrelatedRandomVectorGeneratorTest(String name) {
if (equations.getDimension() != y0.length) {
((SwitchState) iter.next()).stepAccepted(t, y);
a[i] = divdiff[0];
number = parseNumber(source, special[i], pos);
private static double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;
if (moment.n < 3) {
if (mean <= 0.0) {
return p.toString();
this.densityTestPoints = densityTestPoints;
RealMatrix Q = qr.getQ();
functionValueAccuracy = accuracy;
public void testCreateColumnRealMatrix() {
computeCoefficients();
return new Complex(t, b / (2.0 * t));
+ coeff23 * (yDotK[1][i] + yDotK[2][i])
public PascalDistribution createPascalDistribution(
if ((lmDiag[j] == 0) && (nSing == solvedCols)) {
return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,
assertEquals("Rows01Cols23", mRows01Cols23,
return min.evaluate(values);
double correction = fp / (delta * sum2);
double second = other.doubleValue();
public Double(double a1, double a0) {
throw new EstimationException ("unable to converge in {0} iterations",
gbsInterpolator.computeCoefficients(mu, h);
if (pString.indexOf(' ') > 0) {
new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);
for (int i = 0; i < residual.getRows(); ++i) {
for (int j = k + 1; j < columns; ++j) {
numerator /= gcd;
if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {
assertTrue(map.classes().contains(TransformerMapTest.class));
public void testNullIntervalCheck() {
protected final void clearResult() {
if (alpha <= 0.0) {
public GammaDistribution createGammaDistribution(
double   pX = point.x;
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
checkValue(t, pb.getFinalTime());
public Double(long value) {
TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);
assertEquals("number of observations", 36, regression.getN());
assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
public void testLogZero() {
for (int i = 0; i < sample1.length; i++) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
public RealMatrix getRowMatrix(int row) throws MatrixIndexException {
if ((startIndex + index) >= internalArray.length) {
determinant *= data[index];
assertTrue(u.toString().indexOf("NaN") == -1);  
MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));
syz += y * z;
int index2 = permutations[k] * columns + k;
double first = doubleValue();
return new Double(newA);
double[] copiedArray = new double[length];
public void testSinZero() throws MathException {
public final class LaguerreSolverTest extends TestCase {
private String propertyGetter = null;
String msg = "Cannot set an element at a negative index";
if (f == null) {
values[i] = getNext();
public void testMeanAndStandardDeviation() {
private MappableArray array2;
public abstract float floatValue(Evaluation argument) throws EvaluationException ;
hexString = randomData.nextHexString(0);
public Evaluation evaluate(EvaluationContext context)
public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
double fa = f0;
if ( i >= polynomials.length ) {
for (int i = 0; i < vertexA.length; ++i) {
result.data[index] = inv * b.data[index];
Interval ib = (Interval) iterB.next();
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));
public void testRangeNumber()
ComplexUtils.pow(Complex.ZERO, Complex.I));
regression = new SimpleRegression();
public BigMatrix inverse() throws InvalidMatrixException {
FileInputStream fi = null;
double h);
public void testResetFunctionValueAccuracy(){
y = new double[n];
double theoreticalStartCost) {
yTab[i] = f.valueAt (xTab[i]) + 0.01 * randomizer.nextGaussian();
double steadyStateThreshold) {
public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {
double stabilityReduction) {
return sumOfLogs.getN();
"StdDev of n = 1 set should be zero, instead it is: "
vs.getEmpiricalDistribution() != null);
private void qTy(double[] y) {
oneSidedPStats.addValue(oneSidedP[i]);
if (sum <= numericalZero) {
public VectorialCovariance(int dimension) {
int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);
2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2
for (int i = 0; i < arguments.length; ++i) {
statistic.clear();
assertTrue(maxError > 0.005);
return Math.sqrt(variance.evaluate(values, mean, begin, length));
/ (1.0 + Math.abs(p.valueAt(x)));
a.setElement(1, 0,  -4.0);
public class MidpointIntegrator
assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));
public class CholeskySolverTest 
assertTrue("Didn't throw exception", false);
public void testSolve() {
3d * Math.PI / 2d,
observed[findSample(sets,cSamp)]++;
double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);
oldDelta = delta;
assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
"Impossible de convertir {0} en fraction apr\u00e8s {1} it\u00e9rations" },
for (int k = 0; k < sequence.length-1; ++k) {
protected double populationVariance(double[] v) {
return 1 - distribution.cumulativeProbability(
y[i] -= gamma * jacobian[index];
|| (m[1].length != 3) || (m[2].length != 3)) {
private double  maxStep = 0;
assertEquals(loop.getMax(), direct.getMax(), 1.0e-12);
public class FractionTest extends TestCase {
this.estimate = estimate;
minpackTest(new BrownAlmostLinearFunction(10, 5.0,
"0");
result.simplify();
this.propertyName = propertyName;
list.add(o);
new BilinearPattern(100, -0.01));
public double doubleValue(Evaluation argument) throws EvaluationException {
assertEquals(0, MathUtils.lcm(0, b));
void setMean(double mean);
expr.execute();
assertEquals( "Number of elements should be 6", 6, da.getNumElements());
double z[] = new double[n + 1];
double value;
BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);
public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {
for (int row = 0; row < this.getRowDimension(); row++) {
int degree = in.readInt();
Complex oldc = null;
double r, t[][] = new double[m][m], s, olds;
public abstract short shortValue(Evaluation argument) throws EvaluationException ;
"Number of elements must be zero or a positive " + "integer";
protected abstract String getResourceName();
((ResizableDoubleArray)da).setContractionCriteria(10f);
TDistributionImpl td = new TDistributionImpl(5.);
-2 * x04 * x08 * (temp - x11) * tmp4
return getCumPct(new Long(v));         
Assert.assertEquals("Equals check", object, object2);
protected void checkIdentityMatrix(RealMatrix m) {
Arrays.sort(minima, pointCostPairComparator);
double s = (work1[pj] - sum) / diagR[pj];
"Cannot format given Object as a Date");
result = solver.solve(0.8, 1.2);
assertEquals(0d, min.getResult(), 0);
ret = MathUtils.binomialCoefficientDouble(
initialized = true;
targetIter = Math.min(optimalIter, k);
rd2.reSeedSecure();
public ComplexFormat(String imaginaryCharacter, NumberFormat format) {
private int currentDegree;
dev = Double.NaN;
Vector3D v3 = crossProduct(v1, v2);
sum  += s.sum;
sum = 0.0;
max.increment(value);
assertTrue(Math.abs(sampler.samplePointAt(12).y[1] + 2.0) < 1.0e-10);
return mu;
private double data[][] = null;
public class PolynomialSplineFunctionTest extends TestCase {
for (int i = 0; i < currentState.length; ++i) {
interpolatedTime = t;
assertTrue(Math.abs(sampler.samplePointAt(11).getY() + 0.913) < 1.0e-10);
case BigDecimal.ROUND_HALF_UP : {
new EstimatedParameter[] { p[2], p[3], p[4] },
3 * moment.m2 * moment.m2 * (n - 1)) /
m.setSubMatrix(new double[][] {{}}, 0, 0);
f.addValue('c');
super(f, 100, 1E-6);
int numRows = m.getRowDimension();
sample[i] = generator.nextNormalizedDouble();
double v3y  = v3.getY();
private double mu = 0.0;
return -2 * f;
return measurements;
double b = x[2] - x[3];
0.266328593812698,  0.499999334628884,
102.95630140987), false);
while (index1 >= i * (columns + 1)) {
problems.add(new APSProblem1(Math.PI / 2, Math.PI, 1.8954942670340));
+ i + ", " + j + ") in a "
TestSuite suite = new TestSuite(RandomDataTest.class);
assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );
EulerStepInterpolator interpolator = new EulerStepInterpolator();
Complex z = new Complex(-3.0, 0.0);
inf = i.inf;
this.step = (range[1] - range[0]) / (n - 1);
protected final int rows;
max = values[begin];
assertTrue(bos.size () > 98000);
val = new Double(str).doubleValue();
testRegularizedGamma(Double.NaN, 0.0, 1.0);
assertTrue(Math.abs(error) < 0.1);
System.arraycopy(upperBounds, 0, out, 0, len);
for (i = 0; i < n; i++) {
this.n     = n;
public void testNextUniform() {    
boolean isLast) {
return new DiagonalMatrix(rows, data);
for (j = 1; j <= i; j++) {
s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j]
int b = 50;
denominator = -denominator;
private RealMatrixImpl decompMatrix;
private double s;
private double previousEventTime;
double oldValue = solver.getRelativeAccuracy();
interpolator = new DummyStepInterpolator(y, forward);
Number den = getDenominatorFormat().parse(source, pos);
for (int j = 0; j < yMidDots.length; ++j) {
y1[j] = y0[j] + h * yDot0[j];
BigMatrix getRowMatrix(int row) throws MatrixIndexException;
Arrays.fill(a, 0, degree, 0.0);
protected double sumSq = 3595.250d;
boolean adjustStep) {
assertEquals(pattern, ex.getPattern());
public void testBracketSin() throws MathException {
mean.clear();
double d11 = m2[1][1] - m3[1][1];
minpackTest(new WatsonFunction(9, 100.0,
long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) + 
public class ComplexFormat extends Format implements Serializable {
if (in[i] < 0) {
Complex result[]; double tolerance = 1E-12;
public static ChiSquareTest getChiSquareTest() {
testDa = new ResizableDoubleArray(2, 2.0f);
assertTrue(handler.getLastError() > 0.0004);
one = randomData.nextSample(hs,0);
("Abscissa and value arrays must have the same length.");
public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {
return 1;
u /= 2;
int startKm1 = startK;
return (double)numerator / (double)denominator;
public class GaussNewtonEstimator
public double[] getCoefficients() {
for (int i = 0; i < rows; ++i) {
yDotOnScale2 += ratio * ratio;
private SwitchState first;
fitter.addWeightedPair(1.0, i, p.valueAt(i));
assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), 
"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl");
for (int j = 0; j < 60; j++) {
public void test2() {
super(33, startParams, theoreticalStartCost,
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
private double solve(double x0, double y0,
variance.incrementAll(values, begin, length);
u.addObject("14.5");
Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),
assertEquals(5.0, p[4].getEstimate(), 1.0e-10);
return a3;
return new Rotation(-q0, q1, q2, q3, false);
p.initCoeff (i, randomizer.nextGaussian());
minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },
EstimatedParameter p = new EstimatedParameter("p", 0.0);
public ContinuedFractionTest(String name) {
public RandomAdaptorTest(String name) {
System.arraycopy((a.length < p.a.length) ? p.a : a,
long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};
assertClose("inverse multiply",m.multiply(mInv),
/ (sequence[0] * sequence[0]);
assertTrue(Math.abs(d01) > 4.0e-7);
private void testDecompose(double[][] lowerTriangularMatrix, String message) 
public void testNoSetOutsideOfLowerTriangle() {
assertEquals("SSE", 26.6173985294224,
if (x[i - 1] >= x[i]) {
public RealMatrix getQ()
private TransformerMap transformers = new TransformerMap();
DifferentiableUnivariateRealFunction f);
MathUtils.subAndCheck(uvp, upv),
double coeff3     = 3 * s * (1 + theta);
this.age = age;
public boolean nextBoolean() {
return costEvaluations;
throw new FunctionException("upper half range exception");
void setScale(double s);
u.getGeometricMean(), 0.00001 );
for (int j = 0; j < m.columns; ++j) {
Assert.assertEquals(expected, actual, relativeError);
TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);
assertEquals(39.25,MathUtils.round(39.245, 2), 0.0);
double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);
double[] rowSum = new double[nRows];
assertEquals( 1L, MathUtils.indicator( 2L ) ) ;
public class InteractionTest extends TestCase {
RealMatrix R = qr.getR();
f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);
return c;
qrDecomposition();
SampledFunctionIterator iter = new FFPIterator(measurements);
public double evaluate(double x) throws MathException {
private static Comparator pointCostPairComparator = new Comparator() {
TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);
assertEquals(0.0, coefficients[0], tolerance);
if (theoreticalStartCost > 1.0e6) {
randomData.reSeed();
return stat.evaluate(v, 0, v.length);
tstGetSortedValues(test4);
Polynom p = new Polynom(degree, random, 100.0);
public BrentSolverTest(String name) {
TestUtils.t(mu, (double[]) null);
RealMatrix mRow3 = new RealMatrixImpl(subRow3);
assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);
Double summariesValue = (Double)this.getProperty(summaries, name);
x = min + 0.5 * spacing;    // the first new point
public ChiSquaredDistributionImpl(double df, GammaDistribution g) {
private SecureRandom getSecRan() {
NumberFormat old = properFormat.getNumeratorFormat();
integ.setStepHandler(new KeplerHandler(pb));
protected SumOfLogs sumLog = null;
assertEquals(2, pInverse.getRowDimension());
fail("expecting NoSuchProviderException");
parity = 1;
double[][] refC    = new double[][] {
private double getNextExponential() {
public APSProblem28(int n, double a, double b, double expectedRoot) {
return suite; 
assertEquals(new RationalNumber(-5l), a[0]);
sum = c[i];
return secRand;
public class UpperTriangularMatrixTest
if (i <= j) {
yMidDots, forward);
public short shortValue(Evaluation argument) throws EvaluationException {
super(list);
GraggBulirschStoerIntegrator integrator =
if (temp == 0) {
public void integrate(SecondOrderDifferentialEquations equations,
private int maxDegree;
exceptionOccurred = true;
Frequency freq = new Frequency();
public static float indicator(final float x) {
public PoissonDistributionImpl(double p, NormalDistribution z) {
public abstract Evaluation compile(EvaluationContext context)
Polynomial.Rational Pk0 = new Legendre(k);
double defaultAbsoluteAccuracy) {
throws IllegalArgumentException, MathException;
x.setElement(3, 0, -2.0);
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
public GillIntegrator(double step) {
UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);
MullerSolver solver = new MullerSolver(f);
TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
ret = getDegreesOfFreedom();
fitter.addWeightedPair(1.0, x, f.valueAt(x));
coeffs1[i] = 2.0 * max * (random.nextDouble() - 0.5);
sup = a;
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
assertTrue(solver.getIterationCount() <= 7);
int      upperElements = 0;
new CoefficientsGenerator(new RationalNumber(1l),
public void testSetMean() throws Exception {
assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);
"must have n >= k for binomial coefficient (n,k)");
public void resetReplayFile() throws IOException {
a = new double[] { a0, a1, a2 };
assertEquals(inf, z.abs(), 0);
long s = (long)x - (long)y;
long[] observed = {0,0,0,0,0,0};
public class ComplexUtils {
public class Chebyshev
transformer.transform(f, 1, -1, 65);
return binomialCoefficient(n - 1, k - 1) +
float defaultExpansionFactor = 2.0f;
fail("alpha out of range, IllegalArgumentException expected");
yOnScale2    += ratio * ratio;
public class BetaTest extends TestCase {
private final double  weight;
checkValue(new PolynomialFraction(2l, 4l), "1/2");
public abstract double getSum();
private int populationSize;
if (r < 0) {
new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));
-1.51373031394421,   0.99299727291842
F[2*i] = y[i].getReal();
private static final long serialVersionUID = -186095948802525864L;
data[index] += l.data[index];
return new RationalNumber(r.p.abs(), r.q);
TestUtils.tTest(mu, tooShortObs);
dz1 * dx2 - dx1 * dz2,
minpackTest(new WatsonFunction(6, 100.0,
RealMatrix m = new RealMatrixImpl(bigSingular);
+ m[2].getResidual() * m[2].getPartial(p[2]));
double sum = Double.NaN;
assertTrue(p.checkResult(solver.getRoot(), tol));
SummaryStatistics u = SummaryStatistics.newInstance(SummaryStatisticsImpl.class);
throw new IllegalArgumentException("input values array is null");
private double quantile = 0.0;
p = buildProblem3();
assertEquals(-4.0, coefficients[0], tolerance);
private static final long serialVersionUID = -803343206421984070L; 
double value = Double.NaN;
int emptyHash = u.hashCode();
float contractionCriteria, int expansionMode) {
fsMean += omega * point.y[0] *   sine + point.y[1] * cosine;
private static final long serialVersionUID = -6400596334135654825L;
public boolean intersects(Interval i) {
|| lowerData.length != lu.getRowDimension()) {
public final int end;
public InteractionTest(String name) {
errfac        = null;
double inverse  = 1 / Math.sqrt(y * y + z * z);
t = stage(min, max, i);
res.append(",");
b.transform(target);
randomData.nextPoisson(-1);
fail("Expecting IllegalArgumentException - bad samples number");
public final class FrequencyTest extends TestCase {
public void addData(double x, double y) {
TestProblem3 pb;
double result = coefficients[n - 1];
return q3;
public Frequency() {
int bCols = b.getColumns();
private boolean fsal;
double[] out = new double[ncols];
double factor = -Math.sqrt(wm.getWeight());
d = (DescriptiveStatistics) u;
assertEquals(Math.PI, x, 1.0e-4);
" max=" + maximalIterationCount);
fmin = f.value(min);
public Laguerre(int degree) {
Complex z = x.subtract(y);
this.list = list;
double s0 = integrator.integrate(p, -5.0, 15.0);
assertEquals("chi-square test statistic", 2.153846,
TestUtils.t(sample1, sample2), 1E-10);
new TestProblem4(),
(empiricalDistribution2.getSampleStats().getMean(),
double[] sample2 = {0d, 6d, 11d, 2d};
public ExhaustedSampleException(int size) {
double dp = p;
assertEquals(i + "! ",(double)factorial(i),
public void testAddBetween() {
new RationalNumber(1l, 2l).divide(new RationalNumber(0l));
return tTest.pairedTTest(sample1, sample2);
assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());
public String getName() {
Double.isNaN(StatUtils.mean(values)));
lastSeen = false;
Complex C = z[i].subtract(A);
public void resetFunctionValueAccuracy() {
throw new IllegalArgumentException("cannot build a matrix"
("Cannot compute 0-th root of unity, indefinite result.");
assertEquals( (byte)1, MathUtils.indicator( (byte)0 ) ) ;
verifyCumulativeProbabilities();
finalized = false;
for (int i = 0; i < lowLength; ++i) {
"org.apache.commons.math.MathConfigurationException: inner message";
assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);
solver.setAbsoluteAccuracy(expected);
public void testDfAccessors() {
public void testMinpackChebyquad()
return t - switchTime;
loop.add(points[i]);
double z = pY[1] - p0Y[1];
double xm = 0.5 * (x0 + x2);
double cotan = rkk / lmDiag[k];
ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);
double relTolerance = absTolerance;
DiagonalMatrix d1 = new DiagonalMatrix(7, 4.3);
if (x[i] < min[i]) {
new Interval(i.getSup(), b + 1.0)));
protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };
private FixedStepHandler handler;
this.begin  = begin;
list[target] = list[i];
for (int r = 1; r < nRows; r++) {
public class TestUtilsTest extends TestCase {
public void testSolveAccuracyNull()  throws MathException {
sum = sum - decomp[col][k]*decomp[col][k];
double[][] m5 = { { 0.0, 0.0, 1.0 },
double derivativebound = Math.E;
assertTrue(u2 instanceof UpperTriangularMatrix);
public static IntervalsList intersection(IntervalsList list, Interval i) {
private String[] hex = 
outBuffer.append("n: " + getN() + "\n");
RealMatrix getColumnMatrix(int column) throws MatrixIndexException;
assertEquals(11, da.getNumElements());
public void testBinomialCoefficient() {
this.rootCause = null;
assertTrue(Math.abs(result.getElement(i, 0) - 1.0)        < 1.0e-10);
assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
return this.mean;
assertTrue(Double.isNaN(z.real));
solvedCols  = Math.min(rows, cols);
if (i < 10) { // make sure not top-coded
for (int i = 0; i < test.length; i++) {
assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);
public interface DifferentiableUnivariateRealFunction
public void testLogGammaNan() {
coefficients[j] += t * tc[j];
f.addValue(twoI);
return generator;
double subStep2 = 2 * subStep;
m.getEntry(10, 4);
if (k > len) {
return scaleArray(fft(data, true), scaling_coefficient);
double expected = 1.0e-2;    
!TestUtils.homoscedasticTTest(sample1, sample2, 0.48));
yDot[0] = y[2];
public ProperFractionFormat() {
fail("Expecting IllegalArgumentException ");  
cf.setRealFormat(nf);
System.arraycopy(vertexB, 0, vertex, 0, i);
problems.add(new APSProblem19(n19[k], 0.0, 1.0, roots19[k]));
result = value.longValue();
range, 0.083, false);
private double sigma = 0.0;
return p.hashCode() ^ q.hashCode();
assertEquals("3x3 R size", qr.getR().getRowDimension(), 3);
double a = Math.sqrt(xNormSqr);
pendingEventTime  = Double.NaN;
ratio         = y0[j] / scale[j];
private double v;;
f1 = new Fraction(Integer.MIN_VALUE, 3);
eDA.clear();
f.addValue("one");
Matrix transposed = l.getTranspose();
TestFactory factory = null;
assertEquals(4, testDa.getInternalLength());         
vs.fill(val);
if (r >= p) {
public void setPower(Evaluation power) {
if (!("".equals(line) || line.startsWith("#"))) {
lmDiag[j]       = jacobian[index];
1.44686540984712, 0.20034404483314,
TestUtils.chiSquare(counts5);
assertEquals(3.0, p.evaluate(d), 1.0e-5);
q2 = 0.5 * Math.sqrt(s + 1.0);
TestSuite suite = new TestSuite(SkewnessTest.class);
protected RungeKuttaStepInterpolator() {
"unable to converge in {0} iterations" },
return 0.5 * (1.0 + Erf.erf((x - mean) /
assertTrue(Math.abs(a1[3] - 0.3) < 1.0e-10);
UnivariateRealSolver solver = factory.newSecantSolver(function);
if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {
public Throwable getCause() {
double meanDifference = StatUtils.meanDifference(sample1, sample2);
suite.setName("TestUtils Tests");
assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);
assertContains(null, values, x, epsilon);
0,
cumulativeTestValues[i], 
protected TestProblemAbstract() {
public abstract class OrthogonalPolynomial
s1 = new StandardDeviation(false);
v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i]
void setDegreesOfFreedom(double degreesOfFreedom);
public void testWindowSize() {
distribution.setShape(0.0);
return new Variance();
return "Equals";
return Complex.I.multiply(
return sumYY;
TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);
new EstimatedParameter("p0", 1),
mu[0] = 0d;
if (nCols == 0) {
RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);
MathUtils.subAndCheck(bigNeg, 1);
String expected = "1 / 2";
public static final int INFINITE_WINDOW = -1;
public StatUtilsTest(String name) {
if (i > numElements) {
switch (mode) {
public void testSetRealFormatNull() {
0.979430303349865, 0.979430303349865,
(imaginary * q - real) / denominator);
suite.addTest(ArrayMapperTest.suite());
checkEquals(add,   IntervalsList.add(l1, l2));
0.5);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
fail("expecting MatrixIndexException");
assertTrue(ex.getMessage().indexOf("3.14") > 0);
this.c         = c;
public void testSetAbsoluteAccuracy(){
rnd = rand.nextDouble();
private final double min;
!testStatistic.tTest(sample1, sample2, 0.1));
double oMnx2 = oMnx * oMnx;
length = list.size() - Math.max(0, list.size() - windowSize);
public NelderMead() {
super(message, cause);
da.setElement(1000, 3.4);
delta = N1.multiply((N.multiply(H)).subtract(G2));
if (++iterations > maxIterations) {
public void testRedundantUnsolvable() {
intersectSelf(new IntervalsList(new Interval(a - 1.0, i.getInf()),
if (p == 1) {
if (randomGenerator != null) {  // required to avoid NPE in constructor
for (int i = 0; i < 1000; i++) {
public class PolynomialCoefficient
assertEquals("N", n, u.getN(), tolerance);
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);
randomData.nextSecureHexString(-1);
improperFormat.setDenominatorFormat(old);
System.arraycopy(y0, 0, y, 0, y0.length);
if (! a2.isZero()) {
implements GammaDistribution, Serializable  {
"equal to one an endless loop of contraction and " +
double fpos = Math.floor(pos);
ComplexUtils.exp(Complex.ZERO), 10e-12);
alpha /= a*qr[minor][minor];
+ corr20 * corr20 + corr21 * corr21 + corr22 * corr22;
return (m - mu) / Math.sqrt(v / n);
return function.samplePointAt(current);
public final class TrapezoidIntegratorTest extends TestCase {
private double getNextReplay() throws IOException {
double theta05       = theta - 0.5;
public void testTrivial() throws EstimationException {
RealMatrix mRows00Cols33 = new RealMatrixImpl(subRows00Cols33);
this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());
double expected = 10.01787;
public void setScale(double s) {
(h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;
interpolatedTime  = interpolator.interpolatedTime;
return real;
getTolerance());
m.solve(bs);
public static boolean chiSquareTest(long[][] counts, double alpha)
EstimatedParameter vj = parameters[j];
for (int i = 0; i < 3; ++i) {
suite.addTest(GeneralSquareMatrixTest.suite()); 
phi = Math.atan2(-fsMean, fcMean);
private static final long serialVersionUID = 3942403127395076445L;  
char c;
(354216.0 - 94326.0 * sqrt6) / 112847.0,
checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(2l, 3l)),
if (!isStrictlyIncreasing(knots)) {
assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);
double initial = 0.0, tolerance;
int maxIterations, double convergence,
throws IllegalArgumentException {
descriptives.clear();
new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);
31, 32, 33, 34, 35, 36, 37, 38, 39,  40
private static final long serialVersionUID = -2965166085913895323L;
class TestProblemHandler
CholeskySolver solver = 
assertEquals(f.degree(), 0);
f = new Fraction(Integer.MAX_VALUE, 1);
Polynomial.DivisionResult res =
private int parity = 1;
if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
assertTrue(Math.abs(a1[2] - 0.2) < 1.0e-10);
int getMaximalIterationCount();
assertEquals(a, MathUtils.lcm(a, 1));
public SymetricalMatrix getCovarianceMatrix(SymetricalMatrix covariance) {
return geoMean.getResult();
new TestProblem3(),
public double[] transform(
double scaling_coefficient = Math.sqrt(2.0 / (n-1));
double q0q2  = q0 * q2;
Vector3D u = new Vector3D(-1, 1, -1);
/ Math.log(10.0);
assertEquals(3d, testDa.getElement(2), 0);   
estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));
bracket[0],bracket[1]);
Complex A = z[N-i].conjugate();
public Interval(Interval i) {
+ " - 103301483474866556880 x^10"
public abstract AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
assertTrue(calls <= previousCalls);
public static Complex atan(Complex z) {
public static double regularizedBeta(double x, final double a,
boolean newStep          = true;
public CauchyDistributionTest(String arg0) {
if (2 * j == n) {
"5040 - 35280 x + 52920 x^2 - 29400 x^3"
Polynomial.Rational Tk1 = (Polynomial.Rational) Tk0.getDerivative();
public RationalNumber negate() {
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
max.increment(testArray[3]);
private static final CoefficientsGenerator generator =
private static double k14_12 =        1458939311.0 / 192780000000.0      - b_12;
public F2FP2Iterator(AbstractCurveFitter.FitMeasurement[] measurements) {
private double[][] m6 = {{1, 0,  0}, 
0.649, 0.649, 0.694, 0.644, 0.624,
if (Math.abs(yMin) <= functionValueAccuracy) {
public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
newA[i] = newA[i].add(a[j].multiply(p.a[i-j]));
f[i] = tmp1 * tmp1 + tmp2 * tmp2;
minpackTest(new WatsonFunction(6, 0.0,
int getColumnDimension();
int pk                  = permutation[nextColumn];
Vector3D v3 = Vector3D.crossProduct(v1, v2);
public abstract UnivariateStatistic getUnivariateStatistic();
private Evaluation power;
public void setAlpha(double alpha) {
regression.getSignificance(),1E-11);    
f.addValue("One");
public abstract boolean pairedTTest(
public void checkPolynomial(Polynomial.Rational p, String reference) {
yb = yb * b + coeffs0[i] / (i + 1);
if (b.getRows() != rows) {
0.60111470965373,   0.760828981186491,
public void selfAdd(Matrix m) {
public interface ComputableFunctionIntegrator {
c[j] = z[j] - mu[j] * c[j + 1];
if (c == null) {
assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());
-2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,
double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])
new String[] { Integer.toString(size) });
assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);
if (model.steps.size() == 0) {
checkVector(v1, new Vector3D(4, 4, 4));
double corr02 = o[0][2] - m[0][2];
double actualP = Gamma.regularizedGammaP(a, x);
public void testDoubleDimension() {
public synchronized int start() {
observed5, observed6);
target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};
public class ProperFractionFormat extends FractionFormat {
delta = tmp * Math.min(delta, 10.0 * lmNorm);
assertTrue(Math.abs(pair2.x    - 1.2)        < 1.0e-10);
public void testErf0() throws MathException {
public boolean pairedTTest(double[] sample1, double[] sample2, double alpha)
public double[] nextVector() {
double getNumeratorDegreesOfFreedom();
double oneMinusThetaH)
private static class KeplerHandler implements StepHandler {
new EstimatedParameter[] { p[0], p[1], p[2], p[3] },
super(31, buildArray(n, x0), theoreticalStartCost,
public class ValueServer {
protected long smallSampleSize = 1000;
synchronized (out) {
fail("Expecting MatrixIndexException");
public class MinpackTest
public abstract class AbstractDistribution
double previous = lastInterpolator.getPreviousTime();
public void testSumSq() {
random.setSeed(seed);
double[][] outData = new double[rowCount][columnCount];
MessageDigest alg = null;
RealMatrix b = generator.getRootMatrix();
a = buildProblem1().a;
return new TestSuite(WeightedMeasurementTest.class);
double x = pX    - p0X;
return solve(min, max);
if (i < (starts - 1)) {
double[] y1      = new double[y0.length];
104257.0/1920240.0,
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
Fraction c = new Fraction(-5, 3);
double d = Math.cos(a2) + MathUtils.cosh(b2);
protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, 
-12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,
((double) counts[row][col] - expected)) / expected; 
if ((observed1.length < 2) || (observed1.length != observed2.length)) {
return 2 * Math.acos(q0);
private WeightedMeasurement[] measurements;
Math.acos(v2.getY()),
return getDefaultNumberFormat(Locale.getDefault());
if (Math.abs(mv1[i][j] -mv2[i][j]) > delta) 
public void testSmallSamples() throws Exception {
Rational monomial = new Rational(c, remainderDegree - divisorDegree);
Skewness skew = new Skewness();
double x0, double f0, double x1, double f1)
qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])
Fraction ret;
assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));
public final class ListUnivariateImplTest extends TestCase {
oldt = t;
private static final double e1_11 =     1606764981773.0 / 19613062656000.0;
cf.setImaginaryFormat(nf);
this.beta = beta;
generator = new CorrelatedRandomVectorGenerator(mean,
if (sumOfLogs.getN() > 0) {
return randomGenerator.nextInt();
z = -2.0; expected = 0.0; result = p.value(z);
u.addValue(i + 2);
public void testBasicStats() throws DimensionMismatchException {
public PolynomialFractionTest(String name) {
assertEquals("cum freq, empty table", 0, f.getCumFreq(0));
this.distribution = distribution;
BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
public int inverseCumulativeProbability(final double p)
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
return ((Double) getArguments()[0]).doubleValue();
RealMatrix mt = new RealMatrixImpl(testData2T);
double[] interpolatedY = interpolator.getInterpolatedState ();
checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);
PolynomialFitter fitter = new PolynomialFitter(degree, estimator);
throw new NotARotationMatrixException("unable to orthogonalize matrix"
if (den == 0) {
private double stabilityReduction;
assertEquals(sa.length, sb.getIntervals().size());
assertEquals(loop.size(), direct.size());
double a  = x0;
return new RealMatrixImpl(outData);
public void testSubAndCheck() {
double curr = interpolator.getCurrentTime();
return new SwitchingFunction[] { new Bounce(), new Stop() };
double[][] yMidDots,
public abstract void writeExternal(ObjectOutput out)
public void addValue(long v) {
double u2z = u2.getZ();
Complex z[] = fft(c);
throw new IllegalArgumentException("beta must be positive");
TestSuite suite = new TestSuite(CholeskySolverTest.class);
in = new BufferedReader(new InputStreamReader(url.openStream()));
public ScalarValuedPairTest(String name) {
super(weight, y);
public class ScalarSampleStatistics {
observed.length);
protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };
problems.add(new APSProblem18(0.0, 1.5, 0.52359877559830));
int nRows = in.length;
testLogGamma(Double.NaN, -1.0);
regression.getInterceptStdErr(),10E-12);
Polynomial.Rational g1 = new Polynomial.Rational(-1l, 1l);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
public void testMeanAccessors() {
double relativeError = Double.MAX_VALUE;
int iterations = randomData.nextInt(100, 3000);
s.solve(b, 1.0e-10);
da.addElementRolling(6);
assertTrue(Math.abs(error) < Math.abs(previousError));
super(message);
public static NonNullRange reunion(NonNullRange first,
int n = simplex.length - 1;
return methodName;
m.getColumnMatrix(3));
TDistribution distribution = (TDistribution) getDistribution();
while (j >= k && k > 0) {
this.iter = iter;
lmDiag[j] = dpj;
assertTrue(Math.abs(s0[j] - s1[j]) < 1.0e-12 * (1.0 + Math.abs(s0[j])));
public class ThirdMoment extends SecondMoment implements Serializable {
public class DefaultValue extends Number implements Evaluation {
String actual = properFormat.format(c); 
(Polynomial.Rational) p.negate())
return ((2.0 * n) + 1.0) - a + x;
private void dumpMatrix(BigMatrix m) {
protected Max stat;
outData[row][col] = data[row][col].multiply(d);
new EstimatedParameter[] { p[3], p[2], p[5] },
sum[k] = 0.0;
return (newQ.signum() < 0) ? new RationalNumber(newP.negate(),
if (s <= 0.0) {
double x = 2.807 / Math.sqrt(2.0);
for (int i = 0; i < m.getRows(); ++i) {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
Complex d2v = null;
public float getContractionCriteria() {
double syz = 0.0;
initialTime = Double.NaN;
long bits     = Double.doubleToLongBits(d);
+ " above diagonal of a"
return sumSq;
estimate = parameter.estimate;
public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
NewtonSolver solver = new NewtonSolver(f);
public class GraggBulirschStoerIntegratorTest
if (x1 == 0) {
data[indexU] += s.data[indexU];
assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());
test3[i], test2[i],0.0);
long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};
return new PolynomialFunction(differentiate(coefficients));
sb.append(value);
if (factory == null) {
Integer.toString(y0.length)
private static final double e2_12 =             69869.0 / 3084480.0;
double[] sort = getValues();
variance = new Variance();
System.arraycopy(values, begin, sorted, 0, length);
public TDistribution createTDistribution(double degreesOfFreedom) {
public DiagonalMatrixTest(String name) {
d.setElement(i, i, i + 1.0);
private static NumberFormat getDefaultNumberFormat() {
for (int i = 0; i < oneSidedP.length; i++) {
assertEquals(0, first.intValue());
B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;
void setAbsoluteAccuracy(double accuracy);
double getAlpha();
for (double x = 0.0; x < 1.3; x += 0.01) {
TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);
public synchronized int getNumElements() {
new LinearMeasurement(new double[] { 2.0 },
public void testRosenbrock()
public abstract FirstOrderIntegrator newThreeEighthesIntegrator(double step);
this.result = result;
System.arraycopy(x, 0, out, 0, x.length);
MathUtils.hash(real));
double xval[] = { 0.0, 1.0 };
long q1 = Long.MAX_VALUE/4;
return new DormandPrince853Integrator(minStep, maxStep,
for (int j = 0; j <= i; ++j) {
i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);
private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },
checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(5l, 2l)),
public boolean checkTheoreticalMinCost(double rms) {
C = (1 + q) * y2;
F1 = 0.5 * (f[0] - f[N]);   // temporary variable for F[1]
super.setElement(i, j, value);
m = new RealMatrixImpl(detData);
numberOfSuccesses = num;
public final class NevilleInterpolatorTest extends TestCase {
for (int i = 0; i < f.length; i++) {
assertTrue(Math.abs(a2[1] - 0.5) < 1.0e-10);
super.setStepHandler(handler);
if (a2 != 0) {
for (int i = coeffs1.length - 2; i >= 0; --i) {
u.addObject("10");
this.maxIterations        = maxIterations;
Complex pv = null;
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);
double yTmp = yTab[i1];
public void testUnderlyingException() {
TestProblem1 pb1 = new TestProblem1();
519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},
dataArray = new double[list.size()];
sumLog = new SumOfLogs();
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.830) < 1.0e-10);
public class MullerSolver extends UnivariateRealSolverImpl {
return simplex[0].cost;
properFormat.setDenominatorFormat(old);
s.append(')');
super(2, startParams, theoreticalStartCost,
double tolerance = 10E-15;
double addElementRolling(double value);
RealMatrix m3 = new RealMatrixImpl(d3);   
problems.add(new APSProblem24(n24[k], 0.01, 1, 1.0 / n24[k]));
public LevenbergMarquardtEstimatorTest(String name) {
int result = (int) (nextDouble() * n);
public void testlogNull() {
test4 = new double[5];
sum.increment(1);
a = new RationalNumber[] { value };
false, false, true,
RationalNumber b3k,
assertEquals(1, sum.getResult(), 0);
stats.addValue(next);
-0.663806046485249e-8, 1.00000164411786,
return max.evaluate(values, begin, length);
MathUtils.round(1.234, 2, 1923);
BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);
distribution.setStandardDeviation(1);
assertFraction(-1, 2, new Fraction(-2, 4));
h = Math.min(100.0 * Math.abs(h), h1);
public abstract class Polynomial implements Serializable {
ContinuousOutputModel cm = new ContinuousOutputModel();
integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);
public void testAcosInf() {
Assert.assertTrue(msg, Double.isNaN(expected));
public void testMoreLargeValues() {
p.setBound(true);
sum2 += sum * sum;
((ResizableDoubleArray)da).discardFrontElements(5);
outBuffer.append("variance: " + getVariance() + "\n");
if (resultComputed) {
if (i < 0 || i >= n) {
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
double yp0   = h * y0Dot[i];
log(Complex.I.add(z).divide(Complex.I.subtract(z))))
protected double real;
private static final double yHigh= Math.exp(1.0) - 1.859;
double fb;
int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);
public PowellSingularFunction(double[] startParams,
0.661, 0.612, 0.558, 0.533, 0.495,
private transient UnivariateRealFunction derivative;
TestUtils.t(0d, oneSidedP), 10E-10);
value += d * d;
public void testNextFloat() {
checkValue(new PolynomialFraction(1l, 2l).multiply(new PolynomialFraction(0l)),
return transformer;
private String propertyName;
if(num < 0){
beta[pk]     = betak;
u.addObject("9");
double[] xC = new double[n];
public int getNumerator() {
protected void replaceWorstPoint(PointCostPair pointCostPair) {
this.phi   = phi;
this.step  = step;
minima    = null;
double[] c = { -1.5, 3.0 };
this(new Polynomial.Rational(new RationalNumber(numerator)),
this(new Polynomial.Rational(RationalNumber.ZERO),
yDot[0][0] = (y[0] - y0[0]) / dt;
assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));
o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);
p2 = p1;
assertEquals(new BigMatrixImpl(testData), 
Complex expected = new Complex(-0.000187346, 0.999356);
assertEquals(Math.PI, ex.getArgument(), 0);
parameters.add(p);
this.initialCapacity = initialCapacity;
assertFalse(pattern.equals(ex.getMessage()));
x02 * (temp - x09) * (temp - x09) * tmp2,
private double probability(int n, int m, int k, int x) {
if (index > 0) {
return trace;
standardDeviation[i] = 0.5 * Math.abs(vertexA[i] - vertexB[i]);
normalized = new double[rank];
assertTrue("big singular",m.isSingular());
assertEquals("chi-square p value", 0.541096, 
private final Vector3D a3;
Vector3D a1, Vector3D a2, Vector3D a3) {
HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);
private double getRegressionSumSquares(double slope) {
(12.0 - 2.0 * sqrt6) / 135.0, (6.0 - sqrt6) / 45.0, (6.0 - sqrt6) / 30.0,
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));
properFormat.setDenominatorFormat(nf);
GeneralSquareMatrix m3 = buildProblem3().a;
cost += wm.getWeight() * residual * residual;
return new TestSuite(GillStepInterpolatorTest.class);
checkVector(r.applyTo(Vector3D.plusK),
public class LaguerreTest
protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {
suite.setName("StatisticalSummaryValues Tests");
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(bigCol),
return new FDistributionImpl(5.0, 6.0);
ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);
assertFraction(-1, 6, a.subtract(b));
unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);
den = 1.0;
UnivariateRealSolverFactory factory = null;
public abstract UnivariateRealSolver newNewtonSolver(
(Double.doubleToRawLongBits(imaginary) ==
((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);
suite.addTest(HermiteTest.suite());
if ((c == 0) || degree < 0) {
private NumberFormat numeratorFormat;
TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);
private static final long serialVersionUID = -4160028543895639114L;
throw new IllegalArgumentException("input value array is null");
protected int n;
MonitoredFunction f = new MonitoredFunction(new QuinticFunction());
minpackTest(new WatsonFunction(9, 10.0,
setDistribution(x);
this.y = y;
public void testDegenerateNoSuccesses() throws Exception {
b3.setElement(0, 60.0);
+ " - 36 x^5 + x^6");
0.840666673818329,
private int solvedCols;
-1674902723.0/288716400.0,
0.754179768272449, 0.904300082378518,
public BrownDennisFunction(int m, double[] startParams,
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
for (Iterator iter = list.iterator(); iter.hasNext();) {
super(interpolator);
c = k.getX() * (u2y * u3z - u2z * u3y)
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
private int    n;
public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {
RealMatrix triangularMatrix = 
String expected = "property";
ComplexUtils.tanh(null); 
this.a     = a;
new EstimatedParameter("p4", 0),
l.setElement(i, j, -1.3);
public void testConstructors() {
private void checkSolve(LinearProblem p, Matrix result)
return sum.evaluate(values, begin, length);
for (int j=0;j<data[i].length;j++) {
assertTrue(handler.getLastError() > 0.01);
Vector3D w = u.orthogonal();
new EstimatedParameter("p0", 2),
return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);
Math.PI,
assertEquals( (int)1, MathUtils.indicator( (int)(0) ) ) ;
public void testMinStep()
context.doubleValue(power)
mean = Double.NaN;
protected double[] row = {1,2,3};
(51544.0 - 4784.0 * sqrt6) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},
lastTime = interpolator.getPreviousTime();
ra = null;
return s;
FirstOrderIntegrator integ;
if (dist < min_dist) {
Iterator iter = certifiedValues.keySet().iterator();
l.setElement(i, j, i + 0.1 * j);
fail("expecting NoSuchAlgorithmException");
index     = steps.size() - 1;
s1.selfAdd(s2);
check(list1, list2, 0,
RealMatrix permuted = permuteRows(matrix, permutation);
long   n     = Math.round(0.5 + (b - a) / rawStep);
double lowerTail = distribution.cumulativeProbability((double)-i);
if (selectedRows.length * selectedColumns.length == 0) {
this.h       = Math.abs(h);
hNew = Math.min(hNew, hInt);
testStatistic.chiSquare(counts3);
&&
c[ii][ii] -= e * e;
private double[][] m2 = {{1, 0} , 
ret = MathUtils.binomialCoefficientDouble(x
private double argument = Double.NaN;
return new BackwardDifferenceDerivative(function, h);
Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);
alg.reset();
int nSing = solvedCols;
assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);
Fraction third = new Fraction(1, 2);
return Math.asin(v3.getNorm() / normProduct);
transformers = new TransformerMap();
x1 = max; y1 = f.value(x1);
RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
return map.containsKey(key);
forward     = true;
int i, j, k, m, N = data.length;
int maxJ            = 0;
TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);
reset();
66578432.0/35198415.0,
for (int j = 0; j < rank; ++j) {
z = Math.PI / 4; expected = f.value(z); result = p.value(z);
size += b3.getStateDimension();
BigMatrix bMatrix = new BigMatrixImpl(b);
private ArrayMapper   mapper;
return new TestSuite(EulerStepInterpolatorTest.class);
public StatisticalSummaryValuesTest(String name) {
public abstract double getResult();
x1 = x1 + 0.5 * tolerance;
int starts, long seed)
for (int i = 0; i < test4.length; i++) {
incrementAll(values, 0, values.length);
-3.24727115337025,     7.28843489775302,
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});
assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);
throws FractionConversionException
if (mu > 2) {
maxIndices = (int[])    s.maxIndices.clone();
private boolean tryStep(FirstOrderDifferentialEquations equations,
private static final long serialVersionUID = -3775334783473775723L;
public static void assertContains(Complex[] values,
public void testSmallDf() throws Exception {
"population size must be positive.");
return new DefaultValue(f);
double [] getColumnAsDoubleArray(int col) throws MatrixIndexException;
public Legendre(int degree) {
y = f.value(x);
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
return new Vector3D(1, 0, 0);
RealMatrixImpl identity = new RealMatrixImpl(id);
int oMn =  1 - n;
fitter.addWeightedPair(1.0, 10.0 * randomizer.nextDouble(), 0.0);
public double inverseCumulativeProbability(final double p)
UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);
randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");
for (int j = 0; j < m; j++) {
for (int i = 1; i < 10; i++) {
assertEquals(4, f.getDenominator());
public class SwitchingFunctionsHandler {
parl = fp / (delta * sum2);
public class Expm1Function implements DifferentiableUnivariateRealFunction {
private static final long serialVersionUID = 7101857578996691352L;    
assertEquals(50.01f,  MathUtils.round(50.005f, 2), 0.0f);
fail("expecting ArithmeticException");
jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];
c = k.getX() * (u1y * u3z - u1z * u3y)
private double[] inputArray;
assertTrue(maxError < 0.001);
double alpha, double beta) {
return getMean() * .5;
return new HighamHall54Integrator(minStep, maxStep,
Double.toString(det)
this.py = py;
private final double x;
private double[][] coeff;
assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);
Arrays.fill(jacobian, 0);
-3.2472711515214,      7.28843489430665,
temp = cos * rik + sin * lmDiag[i];
f1 = new Fraction(1, Integer.MAX_VALUE);
protected void computeOmega(int n) throws IllegalArgumentException {
1.0, 1.0, 1.0, 1.0, 1.0
tmp1 = Math.atan(x2 / x1) / twoPi;
Complex dv = null;
Exception cause = new Exception(inMsg);
if (maxElt < epsilon) {
d -= corr;
if (result == Long.MAX_VALUE) {
verifyInterval(lower, upper);
if (switchesHandler.stop()) {
double[] a2 = array2.getArray();
TestUtils.t(0d, oneSidedPStats),1E-10);
double temp = 2 * tmp2;
|| (! switchesHandler.isEmpty()));
return ((DefaultValue)argument.evaluate(this)).shortValue();
assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));
public final class RealMatrixImplTest extends TestCase {
double d10 = m2[1][0] - m3[1][0];
protected double[] knots = {-1, 0, 1, 2};
assertEquals( 7.5, f.value( 3.0), tolerance );
public static final RotationOrder YXY =
public void readExternal(ObjectInput in)
return new Complex(real * rhs.real - imaginary * rhs.imaginary,
this.coeffI = coeffI;
return new NonNullRange (0, j + 1);
if(Double.isNaN(expected)){
double f2  = e * Math.sin(E);
x[N-i] = A + B;
public void testConstantDiagonal() {
public void testOutOfRange()
Matrix m = buildMatrix(5, new BilinearPattern(1.0, 0.01));
sy2 += y * y;
+ " diagonal matrix");
yDotKLast[k] = new double[dimension];
sign = -sign;
public abstract double t(double[] sample1, double[] sample2)
this.convergence          = convergence;
StatUtils.sumSq(x);
if (s != 0) {
void incrementAll(double[] values);
System.arraycopy(zDDot, 0, yDot, dimension, dimension);
return new TestSuite(Vector3DTest.class);
34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};
public void testNewBisectionSolverNull() {
suite.setName("Descriptive Statistics Tests");
return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));
ret = negate();
Object result;
public Patient(VitalStats vitalStats, Integer age) {
a.setElement(3, 2, -12.0);
public void testMulMOK() {
p += dp;
assertTrue(Double.isNaN(x.add(z).real));
f[i] = parameters[i].getEstimate() + sum;
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
double obs2 = 0.0d;
protected double absoluteAccuracy;
if (n < 0) {
public void testMutators() {
public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {
previousEventTime = t;
hNew = -hNew;
int m = getNumberOfSuccesses();
new RealMatrixImpl(new double[][]{{numericalZero/2, 0},
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
long i, np;
FunctionEvaluationException, IllegalArgumentException;
0.391, 0.396, 0.405, 0.428, 0.429,
throw new RuntimeException("unexpected exception: " + e.getMessage());
patientList.add( p2 );
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); 
return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2),
m = UnivariateRealSolverUtils.midpoint(min, max);
assertEquals(50.09f,  MathUtils.round(50.085f, 2), 0.0f);
data [data.length - 1 - i] = array [start + i];
assertEquals(Fraction.getReducedFraction
private boolean performTest;
public void testTransformBigDecimal() throws Exception {
assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);
assertTrue(stack.startsWith(outerMsg));
TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);
fail("invalid improper fraction.");
out.writeDouble(h);
public class VectorialCovariance implements Serializable {
protected double mean = 12.404545454545455d;
assertEquals("Rows03Cols123", mRows03Cols123,
EmpiricalDistribution dist = new EmpiricalDistributionImpl();
double f1 = f.value(lower);
public void setSampleSize(int size) {
public void testPremultiplyVector() {
int indexU = i * (columns + 1);
f.addValue(new Integer(1));
NelderMead nm = new NelderMead();
if (expansionMode == MULTIPLICATIVE_MODE) { 
int ii = index[i];
public ScalarValuedPair(ScalarValuedPair p) {
for (int i = 0; i < covariance.getRowDimension(); ++i) {
u.addValue( 4.0 );
Fraction first = new Fraction(1, 2);
toAppendTo, pos);
Fraction result = parse(source, parsePosition);
protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {
theoreticalMinCost, buildArray(n, -1.0));
int endIndex = startIndex + n;
f.addValue("Z");
checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(5l, 2l)),
for (int i = 0; i < minima.length; ++i) {
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1)); 
setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, 
boolean lastStep;
a.setElement(0, 0, epsilon);
fitter.addWeightedPair(1.0, x, 0.0);
a.setElement(1, 2,   3.0);
Polynomial.Rational Lk2 = (Polynomial.Rational) Lk1.getDerivative();
if (rhs.isNaN()) {
private Complex infZero = new Complex(inf, 0);
TestUtils.tTest(sampleStats1, sampleStats2, 0.2));
public final class RiddersSolverTest extends TestCase {
return new SummaryStatisticsImpl();
new CostFunction() {
stat.increment(new double[] {-1.0,  1.0});
0.5, 0.34595481584824, 0.24512233375331,
return kurtosis;
if (interpError > 10.0) {
double t4            = theta * oneMinusTheta;
private StepHandler handler;
sumsq = new SumOfSquares();
assertEquals(2, testDa.getInternalLength());
String input = "1.0";
private void testRegularizedBeta(double expected, double x, double a,
public EnhancedSimpsonIntegratorSampler(SampledFunctionIterator iter)
public class DimensionMismatchException extends MathException {
currentDegree = interpolator.currentDegree;
new double[] { -0.5 }, new double[] { 0.5 });
fail("Can not have 0.0 alpha.");
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
xLow   = c;
public class HarmonicFitterTest
suite.setName("Skewness Tests");
double residual = wm[i].getResidual();
private double mean = 2;
if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&
hNew = optimalStep[targetIter];
lowerData.length != upperData.length
PrintStream ps = new PrintStream(baos);
public void testSqrtRealNegative() {
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
public void integrate (FirstOrderDifferentialEquations equations,
q1 = 0;
int lowerElements, int upperElements) {
public HarmonicFunction(double a, double omega, double phi) {
new RationalNumber(1l));
F2FP2Iterator iter = new F2FP2Iterator(measurements);
covariance.setElementAndSymetricalElement(i, j, e);
double tol = (vecAbsoluteTolerance == null)
public int intValue() {
private static final double[] e = {
return getIntercept(getSlope());
public double[] getUpperBounds() {
"Contraction criteria can never be smaller than " +
VectorialCovariance covStat = new VectorialCovariance(mean.length);
public class GammaDistributionImpl extends AbstractContinuousDistribution
double numericalZero = 77.77d;
assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(luDataLUDecomposition), normTolerance);
suite.addTest(org.spaceroots.mantissa.utilities.AllTests.suite()); 
suite.setName("StandardDeviation Tests");
startColumn < 0 || startColumn > endColumn ||
public abstract boolean tTest(double mu, double[] sample, double alpha)
public void testNoError()
double xLow, fLow, xHigh, fHigh;
b.setElement(2, 0, 18.36);
s.append(java.lang.Double.toString(a[0]));
public boolean requiresDenseOutput() {
n = n + 1.0;
for (int k = 0; k < n21.length; ++k) {
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
: Math.pow(0.01 / maxInv2, 1.0 / order);
RationalNumber f = new RationalNumber(2l, 3l);
public static double sumSq(final double[] values, final int begin,
new TestProblem2(),
assertEquals("3x4 R size", qr.getR().getRowDimension(), 3);
if (Double.isNaN(x) || (x <= 0.0)) {
this.initialStepBoundFactor = initialStepBoundFactor;
il.addToSelf(new Interval(30, 40));
Object result = null;
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
public void testDifferenceStats() throws Exception {
public double transform(Object o) throws MathException {
tmp2 = ti;
assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);
r = new Rotation(m4, 1.0e-7);
this.stepControl1 = 0.65;
public VarianceTest(String name) {
problems.add(new APSProblem27(n27[k], -10000.0, Math.PI / 2,
if (ak2 == 0) {
public class LowerTriangularMatrixTest
String source = "1 / 2";
this.denominator = 1;
throw new ArithmeticException("overflow: add");
p = buildProblem2();
t0         = 0;
if (reflectedCost < originalCost) {
protected Product stat;
double ydiff = y1[i] - currentState[i];
fireException = true;
private ArrayList domainObjects;
public static BigMatrix createBigMatrix(double[][] data) {
public Rational(RationalNumber a1, RationalNumber a0) {
super(problem);
private static final long serialVersionUID = 1112491292565386596L;
return sigma;
public double[] makeInverseCumulativeTestValues() {
0.0431536648587336, 0.193091637843267,
v2[i] = h * yDotK[0][i] - v1[i];
public interface FDistribution extends ContinuousDistribution {
-10.271848098614,       9.07411353715783,
ret = 1.0;
Complex iPi = Complex.I.multiply(new Complex(pi,0));
x2 = max; y2 = f.value(x2);
if (sampleSize > populationSize) {
public double getSlope() {
for (int l = 0; l < mu; ++l) {
t.addValue(1d);
"All input rows must have the same length.");
if (Math.abs(y1) <= functionValueAccuracy) {
assertEquals("chi-square p-value", 0.0, cst, 1E-3);
throws FunctionException {
public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
double t1 = interpolator.getCurrentTime();
q = (q - 1.0) * (r - 1.0) * (s - 1.0);
super.increment(d);
return getCumFreq(new Long(v));       
TestUtils.assertEquals(new Complex(inf, pi),
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
assertEquals(-3.0, coefficients[0], tolerance);
"clear", new Class[]{}).invoke(u, new Object[]{});
equations.computeDerivatives(currentT, y, yDot0);
assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));
++n;
deltaNorm += ratio * ratio;
this.resultComputed = true;
norm2 += akk * akk;
return super.fit();
public Evaluation evaluate(byte b) {
f.getCount(3) + f.getCount(4) + f.getCount(5);
+ b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i]
assertTrue(sin.value(result[1]) > 0);
this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;
return ((Number)o).doubleValue();
Double expectedValue = (Double)certifiedValues.get(name);
super(m);
double inv = 1.0 / work[permutations[k] * columns + k];
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
public PolynomialFunction getPolynomialFunction() {
for (int i = 0; i < 10; i ++) {
value = d;
0.85133992252078, 0.87448527222117
private UnivariateRealFunction function;
int endColumn) throws MatrixIndexException {
Complex w = z.multiply(infOne);
double scaling_coefficient = 2.0 / n;
return getPartialDiY() - getPartialRadiusY();
dist.cumulativeProbability(x);
private double alpha;
return stats.getMean(); // only one obs in bin
if (Math.floor(unscaled) / 2.0 == Math.floor(Math
u.addValue(2.0);
new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});
assertFraction(-1, 2, new Fraction(2, -4));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
RealMatrix mInv = new RealMatrixImpl(testDataInv);
DefaultValue(double d) {
TestUtils.chiSquare(counts4);
int k = getSampleSize();
return new ClassicalRungeKuttaIntegrator(step);
return empiricalDistribution;
double getElement(int index);
return new TestSuite(GeneralMatrixTest.class);
checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");
private static double k15_14 =        1912306948.0 / 13532473845.0;
double skew = Double.NaN;
return pattern;
this.y1Dot    = y1Dot;
protected SquareMatrix(SquareMatrix m) {
assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
boolean found = false;
assertTrue(f.getCallsCount() < referenceCallsCount);
public class Multiply implements Evaluation, Serializable {
public Evaluation evaluate(float f) {
densityTestValues[i], 
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);
private double minReduction;
pos.setBeginIndex(0);
while (true) {
newA[i] = a[i].subtract(p.a[i]);
assertNotNull(line);
lmDir[permutation[j]] = 0;
toAppendTo.append(')');
y = 0;
new PolynomialFunctionNewtonForm(a, c);
solver.decompose(pdMatrix);
public UnivariateRealSolver newNewtonSolver(
-0.663710223017410e-8, 1.00000164411787,
if (squaredSine < 1.0e-12) {
throw new IllegalArgumentException("Dataset arrays must have same length.");
private void updateJacobian() {
lu[max][i] = lu[col][i];
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(-3l, 4l)),
public abstract long getN();
throw new FractionConversionException(value, maxIterations);
return (a.length == 1) && a[0].isZero();
points.add(new PointModel(px, py));
double coeff4    = s * (1 + theta * (1 + fourTheta));
public void testLcm() {
assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);
return new Complex((imaginary * q + real) / denominator,
for (int i = 0; i < length; i++) {
public Fraction add(Fraction fraction) {
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
double factor = w * a[i];
new RationalNumber(2 * k + 1, kP1),
fail(msg);
yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);
double expected = 0.0;
integ.setStepHandler(new StepNormalizer(range / 10.0,
new LinearMeasurement(new double[] {2},
m.setElementAndSymetricalElement(i, j, pattern.value(i, j));
assertClose("scalar add",new RealMatrixImpl(testDataPlus2),
m.setSubMatrix(testData,-1,1);
vs.getNext();
double[] getElements();
public SummaryStatisticsImplTest(String name) {
1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0
for (int i = 0, index = 0; i < rows; i++, index += cols) {
double  inf          = Double.NaN;
double error = 0;
zDot           = new double[dimension];
result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);
if (denseOutput) {
private DomainObject b2;
double x1 = parameters[0].getEstimate();
properFormat = FractionFormat.getProperInstance(getLocale());
public class NewtonSolver extends UnivariateRealSolverImpl {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
p.setBound(false);
Fraction zero2 = new Fraction(0,2);
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =
q3 = 0.5 * Math.sqrt(s + 1.0);
assertEquals(i + "! ",factorial(i),MathUtils.factorial(i));
summary = u.getSummary();
StorelessUnivariateStatistic statistic =
"numerator format can not be null.");
double[] result = new double[means.length];
public void setMean(double p) {
new EstimatedParameter[] {
TestSuite suite = new TestSuite(MedianTest.class);
return new BisectionSolver(f);
public abstract Matrix duplicate();
public class RationalNumber implements Serializable {
assertTrue(Math.abs(m.getMeasuredValue() - m.getTheoreticalValue())
public void testEqualsAndHashCode() {
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.415) < 1.0e-10);
package org.apache.commons.math;
double q1q3  = q1 * q3;
for (j = 0; j < n; j++) {
checkValue(new PolynomialFraction(-12l), "-12");
public NormalizedRandomGenerator getGenerator() {
-Math.sin(a) * MathUtils.sinh(b));
fLow   = fb;
assertClose("identity operate",testVector,x,entryTolerance);
verifyCumulativeProbabilities();       
public class GillStepInterpolatorTest
if (c.compare(v, nextValue) > 0) {
public interface Decomposition {
package org.spaceroots.mantissa.algebra;
d = new double[n];
private static double k16_10 =                 0.0                       - b_10;
coeffs[i] = 2.0 * max * (random.nextDouble() - 0.5);
return new TestSuite(LevenbergMarquardtEstimatorTest.class);
public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
1.30997663810096,  0.43155248076,
double a[] = { 1.0, 2.0, 3.0, 4.0 };
this.x = x;
("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);
String separator = System.getProperty("line.separator");
assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);
minpackTest(new LinearRank1Function(10, 5, 1.0,
RandomAdaptor randomAdaptor = new RandomAdaptor(generator);
Complex D = omega[i].multiply(Complex.I);
StatisticalSummaryValues stat = (StatisticalSummaryValues) object;
assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);
range[0] = 0.0;
protected SecondMoment moment = null;
Math.asin(v2.getX()),
public void testPaseNegativeInfinity() {
maxError = error;
v1 = null;
q3 *= inv;
+ (result[1].doubleValue() / q.doubleValue());
public void testFactorial() {
assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
private double[] jacobian;
assertEquals("number of observations", 17, regression.getN());
66578432.0/35198415.0, -1674902723.0/288716400.0,
Fraction f = new Fraction(1,1);
return 37 * (17 * MathUtils.hash(imaginary) + 
setParamsAccuracy(2.0e-2);
verifyBracketing(min, max, f);
quotient  = quotient.add(monomial);
throw new IllegalArgumentException("Polynomial coefficient array must have postive length.");
private static final long serialVersionUID = -44915725420072521L;
throw new IllegalArgumentException("Illegal quantile value: " + p);
UnivariateRealFunction p = interpolator.interpolate(x, y);
private int starts;
assertEquals(2.5, p.evaluate(d), 1.0e-5);
currentTime       = interpolator.currentTime;
protected double[] singletonArray = {0};
if (currentDegree >= 5) {
private SampledFunctionIterator iter;
public void testChiSquare() throws Exception {
for (int k = 0; k < n17.length; ++k) {
public double getSigma() {
dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);
double initial, double lowerBound, double upperBound) 
private void determineLMParameter(double[] qy, double delta, double[] diag,
System.arraycopy(c, 0, this.coefficients, 0, c.length);
MathUtils.cosh(a) * Math.sin(b));
return mean.evaluate(values);
b.setElement(i, 1, (i + 1.0) * (i + 1.0));
m.setIgnored(false);
assertEquals(1, p.degree());
this.measuredValue = measuredValue;
new Fraction(Integer.MIN_VALUE, -1);
0.32, 0.35, 0.39, 0.37, 0.58,
m.solve(testVector2);
simplex[i]        = pointCostPair;
Math.min(sequence.length - 2,
public void testPopulation() {
MathUtils.addAndCheck(bigNeg, -1);
long nextPoisson(double mean);
public ConvergenceException(Throwable cause) {
assertTrue(Math.abs(sampler.samplePointAt(12).getX() - 1.0) < 1.0e-10);
assertTrue(it.next() instanceof Long);
assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
testStatistic.test(singletonArray, 2, 1);  // start past end
assertEquals(f.value(x[i]), y[i], knotTolerance);
final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);
int den = fraction.getDenominator();
EstimatedParameter[] x = {
suite.addTest(ScalarValuedPairTest.suite()); 
assertEquals(5.0, coefficients[1], tolerance);
mu[i] = h[i] / g;
new GeneralMatrix(1, -3, null);
private static double k15_13 =      -11518334563.0 / 33831184612500.0;
this.contractionCriteria = contractionCriteria;
PolynomialFunctionNewtonForm(double a[], double c[]) throws
-   eta * (v[0][i]
public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {
+ " state vector has dimension {1}" },
assertEquals((RealMatrixImpl) MatrixUtils.createRowRealMatrix(row),
if (v == null) {
private double[] points;
l.add(ck.multiply(b2k).subtract(ckm1.multiply(b4k)));
assertTrue(Math.abs(inverse.getElement(i, i) - 1.0 / (i + 1.0)) < 1.0e-10);
assertTrue(Double.isNaN(statistic.getResult()));
return Math.pow(x, u) - v;
private List patientList = null;
int order = 0;
assertTrue(solver.getIterationCount() <= 2);
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
public interface BigMatrix {
outData[row][col] = data[row][col] + m.getEntry(row, col);
TestUtils.assertEquals(Complex.I, 
if (p.value(initial) == 0.0) { return initial; }
assertEquals("one sample p value", 0.000521637019637,
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
fail("Decomposing matrix m6"); 
randomData.nextHexString(0);
double a[] = { 1.0 };
double[] sample1,
public VectorialValuedPair(double x, double[] y) {
double norm = Q.multiply(R).subtract(A).getNorm();
new EstimatedParameter("p3", 3)
checkValue(m.getResidual(), 0.0);
double c  = a;
BigDecimal tmp = ZERO;
assertTrue(estimator.getRMS(problem) > 0.1);
double coeff = Math.sin(halfAngle) / norm;
distribution.setDegreesOfFreedom(0d);
public double g(double t, double[] y);
public PolynomialFraction negate() {
throws IOException;
public void computeDerivatives(double t, double[] y, double[] yDot) {
while (j >= 0) {
da.addElement(i);
double  factor     = Math.min(maxGrowth,
double[] yTab = new double[size];
double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};
public Polynomial.Rational getNumerator() {
-3.24727109519451,     7.2884347837505,
double actualQ = Gamma.regularizedGammaQ(a, x);
DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" ); 
c[i] += lowerTriangularMatrix[i][j];
yDot[0] = rate;
xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
tmp.delete();
sqrt10 * (x1 - x4) * (x1 - x4)
public static double max(final double[] values, final int begin,
private final double mean;
if( Double.isNaN(value) || Double.isInfinite(value) ) {
public Vector3D getA2() {
public FitMeasurement(double weight, double x, double y) {
return new GeneralSquareMatrix(this);
case BigDecimal.ROUND_UNNECESSARY :
permutations     = (int[]) s.permutations.clone();
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
checkPolynomial(new Polynomial.Double(3.0,  2.0, 1.0),
private static class WatsonFunction extends MinpackFunction {
FastSineTransformer transformer = new FastSineTransformer();
public StringBuffer format(Object obj, StringBuffer toAppendTo,
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
double[] controlArray = { 2.0, 4.0, 6.0 };
parl = Math.max(parl, lmPar);
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});
this.max = max;
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);
theta += pi / 6;
public class MultiDirectional
DescriptiveStatistics stats = DescriptiveStatistics.newInstance();
assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;
ageU.getMax(), 0.001 );
double range = pb.getFinalTime() - pb.getInitialTime();
+  "  Endpoints: [" + min + "," + max + "]");
assertEquals(cause, ex.getCause());
new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },
assertTrue(Double.isNaN(sumSq.getResult())); 
if (costEvaluations >= maxCostEval) {
public APSProblem18(double a, double b, double expectedRoot) {
protected char getDecimalCharacter() {
public double getRoot();
da = new ResizableDoubleArray(2, 0.5f);
double[]   y    =   { 0.0, 1.0, -2.0 };
53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,
return stat.evaluate(eDA.getValues(), eDA.start(), eDA.getNumElements());
public FractionFormat() {
o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);
super(name);
q0 = 0.0;
UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);
m1.setElement(i, j, -1.0);
return (WeightedMeasurement[]) measurements.toArray(new FitMeasurement[measurements.size()]);
throw new EstimationException("maximal number of evaluations exceeded ({0})",
public class Vector3DTest
public TrapezoidIntegrator(UnivariateRealFunction f) {
double d = rhs.getImaginary();
double[] data = mapper.getDataArray();
double im = complex.getImaginary();
vs.setMode(ValueServer.CONSTANT_MODE);
if (N == 1) {
double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());
DynaBean dynaBean = null;
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
String source = "10 / a";
Double.isInfinite(MathUtils.factorialDouble(171)));
m = new RealMatrixImpl(id);
PolynomialFunction h = new PolynomialFunction( h_coeff );
data[i * columns + j] = value;
public final class MathUtils {
double[] out = new double[nRows];
ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());
33695.7133432541,
public static double erf(double x) throws MathException {
hNew = initializeStep(equations, forward, getOrder(), scale,
if (Math.abs(sum) > largest) {
probabilityOfSuccess);
int x0 = getDomainLowerBound(p);
public class TrapezoidIntegratorSampler
inputStream = null;
public void testSinFunction() throws MathException {
return solve(min, yMin, max, yMax, initial, yInitial);
public static byte sign(final byte x) {
return temperature;
int n = vertexA.length;
testDa.addElement(1d); // x,0
public ContinuousOutputModelTest(String name) {
while (mean <= 10000000.0) {
assertEquals("number of observations", 0, regression.getN());
double[] sample2 = {4, 6, 8, 10, 16};
new EmpiricalDistributionImpl().load(x);
public void testParseSimpleWithDecimals() {
double[] observed =
assertEquals(2d, distribution.getBeta(), 0);
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };
jacobian[kDiag] -= alpha;
public void testSubtractNaN() {
z = -2.0; expected = -5.0; result = p.value(z);
assertEquals(meanDifference, StatUtils.mean(diff), tolerance);
public CostException(String pattern, Object[] arguments) {
return upperBound;
if (o instanceof RationalNumber) {
public class Hermite
suite.addTest(GaussLegendreIntegratorTest.suite());
private boolean isPositive(double[] in) {
RealMatrix mRows01Cols23 = new RealMatrixImpl(subRows01Cols23);
public ConvergenceException(String msg) {
int ii  = index[i];
public void testOne() {
return data;
public VariableStepHandler() {
protected double fourthMoment = 9244.080993773481;
centroid[j] += x[j];
((ResizableDoubleArray)da).setExpansionFactor(8f);  
double  hNew      = 0;
testStatistic.homoscedasticT(sample1, sample2), 10E-11);
ContinuedFraction cf = new ContinuedFraction() {
TestSuite suite = new TestSuite(TTestTest.class);
if (xm == x1) {
("Number of samples not power of 2 plus one: " + f.length);
private double sumY = 0d;
BigMatrix copy();
return maxIterations;
protected ResizableDoubleArray eDA;
return Double.parseDouble(((Foo) o).heresFoo());
public class MathConfigurationException extends MathException implements Serializable{
public void mapStateFromArray(int start, double[] array);
z = new Complex(inf, neginf);
this.real = real;
public Complex[] transform(double f[]) throws MathException,
Number value;
stats.addValue(test2[i]);
Integer int1 = new Integer(1);
public void setBiasCorrected(boolean isBiasCorrected) {
if (p <= 0 || p > 100) {
UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));
public int eventOccurred(double t, double[] y);
return variance.evaluate(values, begin, length);
NormalDistribution distribution = (NormalDistribution) getDistribution();
DiagonalMatrix inv = new DiagonalMatrix (columns);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
&& regression.getSignificance() < 1.0);       
assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);
int extra = list.size() - windowSize;
private double std = Math.sqrt(var);
a = new double[r.a.length];
private UnivariateRealFunction f;
setHeartRate( heartrate );
cumulativeTestValues = makeCumulativeTestValues();
assertEquals(1.0, coefficients[2], tolerance);
double[] f = new double[m];
return v;
interpolator.shift();
heartU.getMax(), 0.001 );
new LinearMeasurement(new double[] { 3.0, 2.0 },
return data.length;
throw new IllegalArgumentException("constant vector has wrong length");
++k;
return initialTime;
super(order, order);
q3 = coeff * axis.getZ();
return resources.getString(s);
t0                = Double.NaN;
assertEquals(1L, second.longValue());
public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {
assertTrue(transposed instanceof UpperTriangularMatrix);
private double numericalZero = 10E-12;
assertEquals(10, MathUtils.gcd(-a,  b));
private int twoI = 2;
FunctionEvaluationException, IllegalArgumentException {
measurements   = new ArrayList();
assertTrue("different seeds",
return new WeibullDistributionImpl(1.2, 2.1);
if (local.getSup() < i.getInf()) {
" valeur a finale = {5}, valeur b finale = {6}, f(a) = {7}, f(b) = {8}" },
0.523, 0.562, 0.607, 0.653, 0.672,
public FastFourierTransformer() {
private static final long serialVersionUID = 2067325783137941016L;
assertFraction(317, 100, new Fraction(317.0 / 100.0));
abstract class TestProblemAbstract
u.getPercentile(120);
return sign * y[0];
assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);
assertEquals(3, f.getNumerator());
private static final long serialVersionUID = 6975050568227951931L;
double[][] yDot = { new double[y0.length] };
public void testBuildWAAt() {
c = Vector3D.dotProduct(k, k);
checkPolynomial(new Hermite(2), "-2 + 4 x^2");
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);
q = (x2 - x1) / (x1 - x0);
Complex c = new Complex(-1.2323, -1.4343);
return chiSquareTest.chiSquareTest(expected, observed, alpha);
7,  9, 11, 13, 15,
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});
if (c < (1.0e-10 * u2u2 * u3u3)) {
permutation[nextColumn] = permutation[k];
protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {
for (int k = 0; k < n16.length; ++k) {
double[][] Q = ret.getDataRef();
private void checkVector(Vector3D v1, Vector3D v2) {
checkMatrix(u1, new BilinearPattern(1, 0.2));
assertTrue(Double.isNaN(MathUtils.log(0, 0)));
"Shape must be positive.");
internalArray = (double[]) array.clone();
u.addObject("12.1");
actRed = 1.0 - r * r;
r = new Rotation(-1, 0, 0, 0, false);
long[] observed6 = {0, 0, 0, 0, 0};
public boolean isForward();
assertEquals("N",n,u2.getN(),tolerance);
double maxStep        = pb.getFinalTime() - pb.getInitialTime();
sampleStats.addValue(inputArray[i]);
int nColB = b.getColumnDimension();
public Double(double[] a) {
s = ort[1][1] - ort[0][0] - ort[2][2];
assertTrue(solvable || (degree == 0));
if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {
assertEquals(3.0, MathUtils.log(2,8), 0);
int nextInt(int n);
assertEquals(-0.5, result[1].getImaginary(), tolerance);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
.setScale(scale, roundingMethod))
public PolynomialRationalTest(String name) {
TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);
double b = initial;
private static final long serialVersionUID = 5127795878493115119L;
public double getProbabilityOfSuccess() {
maxIndices[i] = n;
private static class IdentityPattern implements ElementPattern {
rg.setSeed(seed);
(u.equals(t) ||t.equals(u)));
Matrix transposed = u.getTranspose();
q1 = coeff * axis.getX();
interpolator.setInterpolatedTime(0.5);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);
testSolve(m6, "Solving matrix m6");
"imaginaryFormat can not be null.");
System.arraycopy(c, 0, subarray, 0, subarray.length);
test(values, 0, 0);
"  Values: [" + yMin + "," + yMax + "]");       
double newValue = 1.0e-2;       
throw new FunctionEvaluationException(t, e);
return newClassicalRungeKuttaIntegrator(step);
public Vector3D(double alpha, double delta) {
double sigma = populationStandardDeviation(values);
p.setQuantile(25);
for (int j = i; j < m1.getColumns(); ++j) {
for (int index = 0; index < rows * columns; ++index) {
double getAbsoluteAccuracy();
private static double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;
class TestProblem2
public static int addAndCheck(int x, int y) {
boolean resetDerivatives = false;
public void estimate(EstimationProblem problem)
private static final long serialVersionUID = 4014485393845978429L;
yDot[3] = -invR3  * y[1];
public Rational subtract(Rational p) {
return evaluate(coefficients, x);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public void testSetImaginaryCharacterEmpty() {
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
fail("generated value equal to an endpoint: " + result);
return max;
"oSuchMethodException in Transformation: "
estimator2.estimate(problem2);
Fraction nullFraction = null;
if (measurements.size() < 4) {
assertEquals(compareValue,secondDataValue,tolerance);
public static boolean equals(double x, double y) {
private int next;
ex.printStackTrace(ps);
k++; // cast out twos.
assertEquals(ResizableDoubleArray.ADDITIVE_MODE, 
double tmp1 = x1 + temp * x2 - Math.exp(temp);
double[] out = new double[len];
assertEquals(new BigMatrixImpl(bigColMatrix), 
if (z.isNaN()) {
assertEquals("total count",3,u.getN(),tolerance);
assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);
for (int col = 0; col < dimension; col++) {
table[1] = (nextY - previousY) / (next.x - previous.x);
min        = null;
for (int i = 0; i < EulerOrders.length; ++i) {
throw new IllegalArgumentException("window size must be positive.");
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 1);
double t = Math.abs(t(m, mu, v, n));
if (denominator == 0) {
exponent | (mantissa + 1));
denominatorDegreesOfFreedom);
assertEquals(a, MathUtils.gcd( a,  0));
tmp = 0.1;
126887.903284750), false);
o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);
Long count = (Long) freqTable.get(obj);
public HarmonicFitterTest(String name) {
double  currentT  = t0;
finalized = true;
10.3,
this.vecRelativeTolerance  = vecRelativeTolerance;
for (int i = 0; i < m.length; i++) {
("Endpoints do not specify an interval: [" + lower +
double[] bracket = null;
result = result * 31 + MathUtils.hash(getMean());
case UNIFORM_MODE: return getNextUniform();
private RandomGenerator randomGenerator = null;
f.add(null);
-0.896796038685958
("largest n for binomialCoefficient = " + (test - 1) );
stats.setWindowSize(12);
this.vecAbsoluteTolerance  = vecAbsoluteTolerance;
index = (int) Math.rint(iLagrange);
RationalNumber f1 = new RationalNumber(4l, 6l);
assertTrue(solver instanceof BisectionSolver);
private static final long serialVersionUID = -3549158218723499035L;
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
public class GammaTest extends TestCase {
assertTrue(Double.isNaN(w.imaginary));  
return randomGenerator.nextGaussian();
double[] y0 = { 0.0 };
public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {
double scalAbsoluteTolerance = 1.0e-10;
value += c[nearest];    // fork down
public long getCount(char v) {
protected OrthogonalPolynomial(int degree, CoefficientsGenerator generator) {
testDataPlusInv[row][col],sumEntries[row][col],
testValue(10.011, 1.0, 2.0, .9933);
float x = 1.234567890f;
handler.reset();
double step = current - previous;
fail("Decomposing matrix m7"); 
result = result * 31 + MathUtils.hash(getVariance());
p = buildProblem1();
TestSuite suite = new TestSuite(MathUtilsTest.class);
return mean.evaluate(values, begin, length);
public RationalNumber[] getCoefficients() {
41153.4665543031, 9.37794514651874,
int endColumn) throws MatrixIndexException;
2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);
error += ratio * ratio;
assertTrue(Math.abs(a1[1] - 0.1) < 1.0e-10);
sumX += x;
int a = 30;
return new VectorialValuedPair(current.x, sum);
throw new IllegalArgumentException("Coefficient array must have positive length for evaluation");
InvalidMatrixException ex = new InvalidMatrixException();
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);
RealMatrix m5 = new RealMatrixImpl(d5);
public Double(Rational r) {
DescriptiveStatistics u = null;
("Bad input array sizes, should have difference 1.");
public abstract class CertifiedDataAbstractTest extends TestCase {
public double getImaginary() {
b.setElement(i, 1, (rows - i) * (rows + 1 - i) / 2.0);
StringBuffer buf = new StringBuffer();
- i* j
out.writeBoolean(forward);
u.getMean(), Double.MIN_VALUE);
public void testRegularizedGammaNegativePositive() {
GeneralMatrix b = new GeneralMatrix(rows, 3);
return 0d;
private static class APSProblem20 extends TestProblem {
return ffpIterator.hasNext();
protected Matrix(Matrix m) {
public void testChiSquareIndependence() throws Exception {
-20571594.1977912
for (int i = 1; i < (n - 1); ++i) {
assertEquals(0.25, f.getPct('a'), 0.0);
fail();
finalizeStep();
f[i] = (i + 1) * sum - 1;
private RealMatrixImpl covariance;
return halfStep * sum;
polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); 
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)
BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;
public void testPowNaNExponent() {
TestUtils.t(sampleStats1, (SummaryStatistics) null);
protected RandomDataImpl randomData = null; 
variance = new Variance(isBiasCorrected, m2);
assertEquals("3x3 singular Q'Q = I", 0, norm, normTolerance);
public PoissonDistributionTest(String name) {
assertEquals(6.0, c[1], tolerance);
assertEquals(0, random.nextDouble(), 0);
for (k = 0; k < i; k++) {
public ValueChecker(double threshold) {
double x2 = x0;
m.setSubMatrix(detData2,0,0);
return subMatrix;
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);
"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian" },
public class EvaluationException extends MathException {
return variance.getN();
throw new RuntimeException(e.getMessage());
jacobian[i][j] = (i == j) ? (1 - t) : -t;
this.numerator = p2;
public int getCalls() {
pv = coefficients[n];
protected double t0;
assertTrue(Math.abs(d10) > 4.0e-7);
protected void setCostAccuracy(double costAccuracy) {
double var = Double.NaN;
public double evaluate(final double[] values, final int begin, final int length)  {
for (int i = 0; i < values.length; i++) {
assertTrue(minima[i-1].cost <= minima[i].cost);
8.2,
2.39868475104871, 4.56887554791452,
protected double result;
normTolerance);
return rootCause;
return "Multiply";
double absTolerance = 1.0e-8;
return new PolynomialSplineFunction(knots, derivativePolynomials);
public LowerTriangularMatrix(int order, double[] data) {
oos.writeObject(integ.getStepHandler());
z = new Complex(3.0, 4.0);
return Math.exp(u * x) - 1.859;
vs.computeDistribution(500);
boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)
public GeneralMatrix buildMatrix(int rows, int columns,
public double[] getInterpolatingValues() {
return new Complex(Math.cos(a) * MathUtils.cosh(b),
private boolean loaded = false;
assertEquals("a pct",0.5,f.getPct(aChar),tolerance);
for (int i = 0; i < c.length; i++) {
certifiedValues = new HashMap();
DuplicateSampleAbscissaException, IllegalArgumentException {
assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 1.0) < 1.0e-10);
f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));
intervals = intersection(this, list).intervals;
double dk = jacNorm[k];
p1 = new Polynomial.Double(1.0, 0.0);
0.192807810476249,
public class ChebyshevTest
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
private TestProblem3 pb;
if (! finalized) {
private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, 
StatUtils.max(x, 0, 4);
public class EulerIntegrator
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
double n = (double) u.getN(); 
for (int j = n -2; j >=0; j--) {
distribution = value;
ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();
private int[] minIndices;
assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);
public double[][] getDataRef() {
return randomGenerator.nextFloat();
("Input arrays must have the same (positive) length.");
newc = oldc.add(newc.multiply(root[i]));
super(msg);
private static final double e3 =    -71.0 / 16695.0;
return new UpperTriangularMatrix(this);
128.026364472323, 0.0,
private double[] rDiag;
int p2 = 0;
sup = Math.max(sup, i.sup);
assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
class TestProblem3
public UnivariateStatistic getUnivariateStatistic() {
TestSuite suite = new TestSuite("org.spaceroots.mantissa.quadrature.scalar"); 
InvalidMatrixException ex = new InvalidMatrixException(msg);
226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},
- fac2 * polynoms[j][i]);
public void testBeginStepNumber()
lower            = new LowerTriangularMatrix(s.lower);
("Statistics constructed from external moments cannot be incremented");
assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     
public static double midpoint(double a, double b) {
double[] a3 = array3.getArray();
for (int k = 0; k < sequence.length; ++k) {
public void testAbsNaN() {
double expected = 0.95;
processed = true;
assertTrue(transposed instanceof LowerTriangularMatrix);
regression.clear();
new Double(97.4) );
throw new MathException("IllegalAccessException in Transformation: " + e.getMessage(), e);
x0 = x1; y0 = y1;
while ((str = inputStream.readLine()) != null) {
array1 = new MappableArray(4);
public void fill(double[] values) throws IOException {
protected double[] getInverseCumulativeTestPoints() {
yTmp[j] = y[j] + h * sum;
this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;
inf = Math.min(inf, i.inf);
check(new Interval(-10.0, 10.0), new Interval(-12.0, -11.0), 0.0,
public void setProbabilityOfSuccess(double p) {
new EstimatedParameter[] { p[1], p[2] },
public synchronized double addElementRolling(double value) {
int ncols = this.getColumnDimension();
private static final long serialVersionUID = 6552227503458976920L;
public double getDeterminant(double epsilon) {
-Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },
if (pm > p) {
double cumulativeProbability(double x) throws MathException;
public void setNumberOfTrials(int trials) {
Polynomial.Rational Hk1 = (Polynomial.Rational) Hk0.getDerivative();
suite.addTest(org.spaceroots.mantissa.functions.AllTests.suite()); 
a = new double[] { a0, a1 };
setCostAccuracy(2.0e-4);
throws NoSuchAlgorithmException, NoSuchProviderException {
public MatrixIndexException(String message) {
double rnd = 1.0d;
throw new IllegalArgumentException("Input array lengths must be equal and at least 2.");
return i * j;
double halfDx = 0.5 * (current.x - previous.x);
assertTrue( zero.equals(zero));
if (x.length < 3) {
double   sine   = Math.sin(omegaX);
public RationalNumber subtract(long l) {
assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);
increasing = (gb >= ga);
assertEquals(expected, t.transform(input), 1.0e-4);
double dt1 = time - tMax;
distribution = null;
return getResult();
String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";
assertTrue(Math.abs(pair.getX() - 0.1 * i) < 1.0e-10);
q = BigInteger.valueOf(denominator);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,
.multiply(BigInteger.valueOf(fraction.denominator/d1));
public void testPolar2ComplexInf() {
double[][] vertices)
new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,
VectorialMean meanStat = new VectorialMean(vertices[0].length);
assertEquals( f.value( 456.89), c[0], tolerance );
int ret;
previousTime = currentTime;
assertEquals(0.0, mean[0], 1.0e-12);
if (i1.intersects(i2)) {
yEnd[i] = y0[i] + subStep * f[0][i];
? Double.NaN : ((Interval) intervals.get(intervals.size() - 1)).getSup();
this.costAccuracy         = 1.0e-8;
if ((m.length != 3) || (m[0].length != 3)
FunctionEvaluationException  {
if (!isSquare()) {
public final class StatUtilsTest extends TestCase {
assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());
private static TestProblemAbstract[] pool = {
throw new IllegalStateException("No result available.");
((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);
q.multiply(f.q));
public class IntervalsList {
return new DescriptiveStatisticsImpl();
public double getPulsation() {
if (y2 == 0.0) { return max; }
double v2, double n1, double n2)
assertTrue(upperTail > 0.99999);
testRegularizedGamma(Double.NaN, Double.NaN, 1.0);
alpha1, alpha2, alpha3);
largest = Math.abs(sum);
protected abstract double[][] getJacobian();
bp[row][col] = b.getEntry(permutation[row], col);
steps.clear();
s.append(" - ");
public boolean isIgnored() {
double[] theoreticalY  = pb.computeTheoreticalState(time);
protected CoefficientsGenerator(RationalNumber a00,
s.append(a[0].toString());
assertEquals(msg + " " +  i + " elements differ", 
context.doubleValue(left) / context.doubleValue(right)
fk[k][l+1] = new double[y0.length];
return numericalZero;
public void testZeroReal() {
return h;
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
new String[] {
class TestProblem1
protected abstract double getDomainLowerBound(double p);
String message) 
public static int indicator(final int x) {
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
if (functions.isEmpty()) {
throw new NotARotationMatrixException("a {0}x{1} matrix"
checkVector(r2.applyTo(u), r1.applyTo(u));
assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);
public class MappableScalarTest
public abstract UnivariateRealSolver newBisectionSolver(
result *= i;
divdiff = new double[n];
public void testSubtract() {
u.addValue(4.0);
internalArray[startIndex + (numElements - 1)] = value;
fitter.addWeightedPair(1.0, 0.0, p.valueAt(0.0));
min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;
public int getRowDimension() {
new double[] { 0.9817314852934 }), false);
assertFraction(10, 21, c.abs());
throws IllegalStateException, IllegalArgumentException {
return variance.evaluate(values, mean);    
return Math.sqrt(variance);
m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;
TestUtils.assertEquals(0d, 
yDDot[i] = -omega2 * y[i];
this.degree = degree;
long sign     = bits & 0x8000000000000000L;
if (x >= threshold) {
BigDecimal[][] outData = out.getDataRef();
private static final double d5 =   -1453857185.0 /    822651844.0;
return new PascalDistributionImpl(10,0.70);
f.addValue('a');
public UniformRandomGeneratorTest(String name) {
TestSuite suite = new TestSuite(FrequencyTest.class);
if (max != col) {
return multiply(BigInteger.valueOf(l));
v4 = new double[interpolatedState.length];
unbound.add(p);
return yb * b - ya * a;
return new RealMatrixImpl(out);
double y[] = { 0.0, -4.0, -24.0 };
previousError = error;
measurements.add(m);
private double tolerance = 10E-15;
out.writeInt(currentState.length);
Polynomial.Rational Tk2 = (Polynomial.Rational) Tk1.getDerivative();
assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);
public void testSetFunctionValueAccuracy(){
for (double lambda = 0; lambda < 6.2; lambda += 0.2) {
System.arraycopy(vertexA, i, vertex, i, n - i);
MathUtils.binomialCoefficient(4,5);
protected double scalAbsoluteTolerance;
if (nextIndex >= measurements.length) {
public Kurtosis(final FourthMoment m4) {
public PolynomialFraction(BigInteger numerator, BigInteger denominator) {
RationalNumber ckPrev = null;
private void setMultiStart(int starts, RandomVectorGenerator generator) {
protected double[] testDataCol3 = {3d,3d,8d};
hInt = Math.abs(h / Math.max(Math.pow(interpError, 1.0 / (mu+4)),
private double[] values;
new RationalNumber(1l, 0l);
assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);
double ratio = f[0][l] / scale[l];
private static final String methodName = "Gill";
public static final int STOP = 0;
return x;
secondMoment.increment(value);
assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
public double getTrace() throws IllegalArgumentException {
public StandardDeviation(boolean isBiasCorrected, SecondMoment m2) {
private double cachedNormalDeviate = Double.NaN;
public RationalNumber divide(BigInteger l) {
checkLaguerre(new Laguerre(4),   24l,
q = denominator;
m[i],n[i],tolerance);
updateObjects(internalData);
QRDecomposition qr = new QRDecompositionImpl(A);
int populationSize = 3456;
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
fail("negative length -- IllegalArgumentException expected");
private double[] errfac;
assertFraction(1, 3, a.multiply(b));
return scaleArray(fft(f), scaling_coefficient);
public void printStackTrace(PrintStream out) {
assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);
BigDecimal[] out = new BigDecimal[nRows];
incrementAll(values, begin, length);
fail("invalid minus in improper fraction.");
System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);
d1.setElement(i, i, -1.0);
Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);
checkVector(axis, Vector3D.minusK);
theta = -2 * pi;
double rkk = jacobian[k * cols + pk];
ElementPattern pattern) {
checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(-2l, 3l)),
oldt = qtrap.stage(min, max, 0);
throw new IllegalArgumentException("function can not be null.");    
assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));
fail("Expecting IllegalArgumentException for df = 0");
Complex expected = new Complex(1.2323, 1.4343);
observed[i] = freq.getCount(i);
RealMatrix bbt = b.multiply(b.transpose());
double res = 1.0d; 
assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8); 
if (b.getRowDimension() != this.getRowDimension()) {
public abstract byte byteValue(Evaluation argument) throws EvaluationException ;
ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, 
F[2*i+1] = y[i].getReal() + F[2*i-1];
clear();
public class AbstractCurveFitterTest
double   x11 = parameters[10].getEstimate();
f = f1.subtract(f2); // should overflow
public void testMinpackRosenbrok()
for (int j = 0; j < m.getColumns(); ++j){
public double getDeterminant() {
if ((result == lower) || (result == upper)) {
RealMatrix mRows02Cols13 = new RealMatrixImpl(subRows02Cols13);
if (firstTime || !fsal) {
private static final long serialVersionUID = -8032020368915042278L;
assertTrue("variance should not be zero (n = 2)", 
m = (n - 1.0) / 2.0;
public void testRandom() throws Exception {
private double evaluateCriterion(EstimationProblem problem) {
private   String  name;
jacobian[index + dkp] -= gamma * jacobian[index];
0.746, 0.679, 0.608, 0.655, 0.616,
double[] c = new double[lowerTriangularMatrix.length];
s1 += j * dx * parameters[j].getEstimate();
public void testHash() {
public boolean isNaN() {
distribution.setAlpha(3d);
xTab[i] = 0.1 * i;
RealMatrix bs = new RealMatrixImpl(bigSingular);
hNew = initializeStep(equations, forward,
suite.addTest(AbstractCurveFitterTest.suite());
throws DerivativeException;
sumXX += dx * dx * (double) n / (double) (n + 1.0);
work1[pj] = work3[pj] * diag[pj] / dxNorm; 
public void testStoredUnivariateImpl() throws Exception {
f = f.invert();
public ArrayMapper(ArraySliceMappable object) {
public MultiDirectional() {
for (int j = 0; j < m.getColumnDimension(); j++) {
Rotation r1 = new Rotation(order.getA1(), alpha1);
return minStep;
String expected = "30" + getDecimalCharacter() + "23";
while (x == x1 || x == x2) {
z = new Complex(0, neginf);
outBuffer.append("max: " + getMax() + "\n");
public MappableScalarTest(String name) {
"Cardan angles singularity" },
for (int j = 0; j < i; ++j) {
return new TestSuite(MidpointStepInterpolatorTest.class);
double t  = 1 + 2 * sum / m;
double nextUniform(double lower, double upper);
public void testSinInf() {
omega[i-1].getImaginary() * cost - omega[i-1].getReal() * sint);
3.0,
for (int i=0;i<bd.length;i++) {
new EstimatedParameter("p4", 4),
return new TestSuite(MappableArrayTest.class);
newA[i] = p.a[i].negate();
-1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0
u.addObject("9.9");
if (fi != null) {
LowerTriangularMatrix l = buildMatrix(4, new ElementPattern() {
public class MappableArray
statistic.hashCode() != emptyHash);
"than one.  If the contractionCriteria is less than or " +
assertEquals("critical value for " + p, expected, actual, 10e-4);
return new TestFactoryImpl();
assertEquals(1.0, optimum.point[1], 0.01);
end   = range.end;
return tTest.homoscedasticT(sample1, sample2);
Math.PI / 6d,
interpolatedTime  = Double.NaN;
f2 = new Fraction(1, Integer.MAX_VALUE - 1);
range[1] = 1.0;
public static Complex cosh(Complex z) {
setOrthoTolerance(1.0e-10);
public int[] makeCumulativeTestPoints() {
for (int i = 0; i < mean.length; ++i) {
transformer.transform(f, -1, 1, 100);
pw.flush();
public void testNegativeBoth() {
np = 1L << (n-1);           // number of new points in this stage
return solve(bd);
+ " - 2345767627188139419665400 x^22"
Polynomial.Rational g0 = new Polynomial.Rational(k);
double y = 0;
public interface StorelessUnivariateStatistic extends UnivariateStatistic {
BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
assertEquals(all.getMin(), even.getMin(), 1.0e-12);
public double normalApproximateProbability(int x) throws MathException;
Complex c = new Complex(1.2323, -1.4343);
testStatistic.chiSquare(expected,observed) < 16.27);    
descriptivesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());
public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
public Checker (double tolerance) {
double[] values = {35d, 23d, 42d, 10d};
public void testTransformNull(){
public static double t(StatisticalSummary sampleStats1,
da.addElement(22.0);
if (moment.getN() > 3) {
double[] diag    = new double[cols];
assertTrue(Double.isInfinite(MathUtils.nextAfter( Double.MAX_VALUE, Double.POSITIVE_INFINITY)));
checkPolynomial(new Polynomial.Rational(3l,  0l, 1l), "1 + 3 x^2");
public SimpleEstimationProblem() {
boolean chiSquareTest(double[] expected, long[] observed, double alpha) 
BigMatrix m3 = new BigMatrixImpl(d3);
Rotation r = new Rotation();
domainObjects.add(new ArrayMapperEntry(object, size));
this(50.0);
TestUtils.t(mu, sampleStats), 10E-10);
public SimpleRegression() {
public EstimationException(Throwable cause) {
3.8402551840622e-2, 9.9000099980005e-3, 2.4937500390620e-3
p.initCoeff(i, randomizer.nextGaussian());
assertTrue(lowerTail > 0.0d);
return null;
assertEquals(0L, f.getCumFreq('b'));
permutations     = null;
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
this.yDotK = yDotK;
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
h = maxStep;
long countSum1 = 0;
assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);
DifferentiableUnivariateRealFunction f) {
return chiSquareTest. chiSquareTest(counts);
"-1/2 + 1/2 x");
B = Math.sin(i * Math.PI / N) * (f[i] - f[N-i]);
public MathConfigurationException(String message) {
o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);
polynomials[i] = new PolynomialFunction(coefficients);
public final int degree;
chiSquare(expected, observed));
val = testGenerator.nextLong();
if (test(values, begin, length) && length > 3) {       
d[i][j] = data[i][j].doubleValue();
++i;
if (fraction == null) {
return new GillIntegrator(step);
b          = a;
checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));
assertEquals(3, spline.getN());
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
"120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");
Double.isNaN( u.getStandardDeviation() ) );
sum = sum.add(data[row][i].multiply(v[i]));
testStatistic = TestUtils.getTTest();
setTolerance(6e-6);
+ m[1].getResidual() * m[1].getPartial(p[0])
&& (ratio <= 2.0)) {
void setRelativeAccuracy(double accuracy);
Double.NEGATIVE_INFINITY, 1d, 0d};
"une matrice {0}x{1} ne peut pas \u00e9tre une matrice de rotation" },
return 5;
private static final long serialVersionUID = -1146319659338487221L;
"\u00c9chec de convergence de fraction continue pour la valeur {0}" },
public static double pairedTTest(double[] sample1, double[] sample2)
private static final long serialVersionUID = -8602234299177097102L;
public void reset() {
Complex z = new Complex(-3.0, -4.0);
checkValue(m.getTheoreticalValue(), theoretical());
sum = lu[row][col];
assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);
jacobian[j][j] = 2;
assertTrue("e not NaN", Double.isNaN(regression.getR()));
protected File file = null;
if (locatePoint(time, sMin) <= 0) {
return subtract(BigInteger.valueOf(l));
if (!isBracketing(lower, upper, f)) {
this.performTest = performTest;
double sint = Math.sin(t);
olds = s;
return ignored;
result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);
public EmpiricalDistributionImpl() {
assertEquals("two sample homoscedastic p value", 0.4833963785, 
System.out.println
testArray[i],
public class Vector3D
private static final long serialVersionUID = 4237564493130426188L;
throw new IllegalStateException("no decomposed matrix available");
assertEquals("chi-square p value", 0.124115, 
private void testValue(double expected, double a, double b, double p) throws Exception {
assertTrue(r.end   == 7);
checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(2l, 5l)),
public double getPartialDiY() {
new double[] {0.0, Double.POSITIVE_INFINITY});
private int numerator;
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-13);
if (columns != m.rows) {
for(int i = 0; i < test1.length; i++){
public class VectorialValuedPairTest
+ a.length + 'x' + a.length
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
Object[] nextSample(Collection c, int k);
public void testQuadraticFunction() throws MathException {
throw new IllegalArgumentException("insufficient data for t statistic");
public void load(URL url) throws IOException {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
setInverseCumulativeTestValues(
return new SecondMoment();
protected UnivariateRealIntegratorImpl(
public Vector3D(double x, double y, double z) {
public boolean contains(double x) {
f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);
return this.max;
return sum / (double) v.length;
p2 = p2.multiply(p1);
double v1v2   = Vector3D.dotProduct(v1, v2);
j -= k; k >>= 1;
public BetaTest(String name) {
covData[i][i] = bbt.getEntry(i, i);
errorScale = null;
public NumberFormat getDenominatorFormat() {
double actual, double relativeError) {
int oldValue = solver.getMaximalIterationCount();
xx = xx + 245d/1000d;
-4.54137546660822,     1.0120118885369
if (w.bitLength() > 31) {
maxDegree = degree;
return Math.pow(x, n) - u;
public void testParseDifferentImaginaryChar() {
public class MatrixFactoryTest
p2 = new Polynomial.Double(2.0, 3.0, -1.0);
fa = function.value(a);
private RationalNumber b2k;
for (int i = 0; i < data.length; i++) {
this.offset = offset;
(sampleStats2 == null ||
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682
assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.003));
testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);
synchronized int getInternalLength() {
public interface SampledFunction extends Serializable {
assertTrue(minima[i+1] == null);
m.getSubMatrix(0 , 0 , 3, 3));
new LinearMeasurement(new double[] { -3.0, -9.0 },
if (length < 0) {
nbSteps = 0;
double max, double min, double sum) {
public Double getTemperature() {
Random random = RandomAdaptor.createAdaptor(generator);
mv1[0].length != mv2[0].length) 
BigDecimal[][] d = out.getDataRef();
estimator.estimate(problem);
for (int row = 0; row < rowCount; row++) {
double[][] diagonal = new double[sequence.length-1][];
if ((sampleStats1 == null) ||
int tmp = index[rank];
public NonNullRange(NonNullRange range) {
public void resetRelativeAccuracy() {
double h1 = current.getX() - previous.getX();
fail("Expecting IllegalArgumentException for p = -1");
m.inverse();
return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());
lastTime  = Double.NaN;
implements StepHandler, Serializable {
return homoscedasticTTest(StatUtils.mean(sample1), 
m = new BigMatrixImpl(bigSingular);
-tmp4,
protected boolean resultComputed = false;
class GillStepInterpolator
public static double tTest(double mu, StatisticalSummary sampleStats)
public void testBinomialCoefficientFail() {
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
assertEquals(5, dme.getDimension1());
1.88623796907732, 1.88623796907732,
public double getCumPct(char v) {
double[] test1 = {5,4,3,2,1,0};
Polynomial.Rational Hk0 = new Hermite(k);
data[index++] *= a;
divider = x[j] - x[i+j];
w = (c[j+1] - d[j]) / divider;
min  = s.min;
f[1] = data[0].subtract(data[1]);
double deltaNorm = 0.0;
GeneralSquareMatrix a = new GeneralSquareMatrix(3);
public MaxIterationsExceededException(int maxIterations,
public class Mean extends AbstractStorelessUnivariateStatistic 
double derivativebound = 1.0;
if (x1 < 0) {
Integer.toString(equations.getDimension()),
private static final long serialVersionUID = -4100440615830558122L;
matrix = new QRDecompositionImpl(matrix).getQ();
private static double b_07 =       66578432.0 / 35198415.0;
UnivariateRealSolver solver = new BrentSolver(f);
x[N-i] = A - B;
assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     
public int getDimension1() {
double factor = Math.min(maxGrowth,
inverse = a.getInverse(1.0e-10);
upperData[i][j] = 0d;
this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;
protected FourthMoment stat;
if (d * (direction - d) >= 0) {
MathUtils.equals(stat.getN(), this.getN()) &&
resetReplayFile();
double   delta   = 0, xNorm = 0;
Fraction f = f1.multiply(f2);
double probability(int x);
public void testPropStats() {
context.doubleValue(left) + context.doubleValue(right)
3399327.0/763840.0,
private double orthoTolerance;
entry.object.mapStateFromArray(entry.offset, data);
new EulerIntegrator(0.01).integrate(pb,
double halfAngle = -0.5 * angle;
TestSuite suite = new TestSuite(StandardDeviationTest.class);
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
a          = tmp;
"not positive definite matrix" }
Matrix result = u.solve(b, 1.0e-10);
assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));
dist.setMean(-1);
da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);
assertTrue(Math.abs(d22) > 4.0e-7);
assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);
private Complex negInfInf = new Complex(negInf, inf);
throw new IllegalArgumentException 
public MessagesResources() {
public static double product(final double[] values) {
false, false, 3, false, false, 2, true,
private static final long serialVersionUID = 6033909492898954748L;
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
private double rate;
assertFalse(m.equals(new RealMatrixImpl(bigSingular))); 
public boolean isNegative() {
assertEquals(0.706281887248, result, 1E-10);
return polynomials[i].value(v - knots[i]);
public void testExpm1Function2() throws MathException {
public void setUp() throws IOException {
ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * 
public EstimatedParameter[] getUnboundParameters() {
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
public void testSignDouble() {
p.getB(), p.valueAt(p.getB())));
maxJ = Math.max(maxJ, range.end);
public class UnivariateRealSolverUtilsTest extends TestCase {
TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);
double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());
assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);
return new TestSuite(RationalNumberTest.class);
nextY     = next.getMeasuredValue();
public RationalNumber subtract(BigInteger l) {
c[i] = new Complex(f[2*i], f[2*i+1]);
public double getShape() {
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 0);
String source = "1 + 1i";
assertEquals(-4.0, z.getImaginary(), 1.0e-5);
public void testConstructorCause(){
m.subtract(new BigMatrixImpl(testData2));
fitter.fit();
double[] range, int n) {
double[] y1, double[] yDot1)
int bIndex = i * bCols + maxJ - 1;
assertEquals(inf, w.real, 0);
implements FirstOrderIntegrator {
RandomDataImpl rd2 = new RandomDataImpl();
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
public void testRegularizedGammaPositiveZero() {
private double[] y;
assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);
double expected = (i > j) ? 0.0 : (j + 0.1 * i);
td = x[i+j] - z;
checkValue(new RationalNumber(2l, 4l), "1/2");
q = 1.0 - s;
double result = dist.normalApproximateProbability(110)
sMin.setInterpolatedTime(time);
omega[0] = new Complex(1.0, 0.0);
public void guess()
double[] g_coeff = { 6.0, -4.0, 3.0 };
regression.predict(0), 10E-12);
for (int i = 0; i <= n; i++) {
return multiply(new RationalNumber(i));
for (int i = 0; i < test2.length; i++) {
throw new IllegalArgumentException("p must be between 0.0 and 1.0, inclusive.");
temp * x01 * tmp1,
public void computeDistribution(int binCount)
String nextSecureHexString(int len);
public double getNext() throws IOException {
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);
public class SinFunction implements DifferentiableUnivariateRealFunction {
String os = "";
HarmonicCoefficientsGuesser guesser =
protected Skewness stat;
return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);  
return y;
public SimpsonIntegrator(UnivariateRealFunction f) {
public abstract double t(
public void testCreateIdentityMatrix() {
-0.156731503955652,    1.05281517654573,
for (int i = 0; i < sample.length; ++i) {
scale = s;
return function.g(t, interpolator.getInterpolatedState());
this.pattern   = pattern;
public abstract int getPopulationSize();
public class CertifiedDataTest extends TestCase  {
assertTrue(bos.size () > 82000);
in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));
scalar1.setValue(00.0);
double rawStep;
private NumberFormat realFormat;
public GaussNewtonEstimator(int maxIterations,
dynaBean = dynaClass.newInstance();
public void testSqrtImaginaryNegative() {
yDot[i] = t * (t * t - y[i]);
package org.apache.commons.math.stat.inference;
-59.597960355475491248,
((v1 * v1) / (n1 * n1 * (n1 - 1d)) + (v2 * v2) /
SymetricalMatrix s = new SymetricalMatrix(0.99, a);
this.errorScale = (double[]) errorScale.clone(); 
this.c          = c;
package org.apache.commons.math.stat.descriptive.moment;
public static double mean(final double[] values, final int begin,
vectorsInitialized = interpolator.vectorsInitialized;
fail("Expecting IllegalArgumentException for p = 2");
double sum1 = 0d;
public class VectorialMean implements Serializable {
ret = (numerator == rhs.numerator) &&
SumOfSquares sumSq = new SumOfSquares();
long[] observed1 = { 500, 623, 72, 70, 31 };
protected double previousTime;
double ratio = ((double) sequence[k+1]) / sequence[0];
public class Percentile extends AbstractUnivariateStatistic implements Serializable {
F[1] = F1;
100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };
expected *= 2;
public class BrentSolver implements RootsFinder {
private static final long serialVersionUID = -7397116933564410103L;
double actRed = -1.0;
return new WeibullDistributionImpl(alpha, beta);
double tmp2 = Math.exp(-temp * x5);
PolynomialFitter fitter =
omega = Math.sqrt(c2 / c3);
DescriptiveStatistics d = null;
for (int row = 0; row < col; row++) {
new BigMatrixImpl(new String[][] {{},{}});
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
implements ComputableFunction {
assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
double x10 = m[1][0];
assertTrue(Math.abs(pair.getY() + 8.4) < 1.0e-10);
return callsCount;
public static TestProblemAbstract[] getProblems() {
if (Math.abs(x - oldx) <= tolerance) {
lmPar = Math.min(paru, Math.max(lmPar, parl));
double   t0 = 0;
setDistribution(new HypergeometricDistributionImpl(5,5,3));
0.0147639625185392,   0.146342341096326,
PointCostPair tmp = simplex[i];
System.arraycopy(currentState, 0, interpolatedState, 0,
double coeffU = u1u2 / u1u1;
mI = (FitMeasurement) measurements.get(i);
assertEquals(2, f.getNumerator());
parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);
public abstract Polynomial multiply(RationalNumber r);
TestUtils.chiSquareTest(counts), 1E-9);       
return internalArray[startIndex + index];
y[1] =  3.0;
public interface UnivariateRealSolver {
public AbstractRandomGeneratorTest(String name) {
testProbability(5.000, 2.0, 2.0, .7127);
assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);
equations.computeDerivatives(currentT + h, y1, yDot1);
double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
throw new CardanEulerSingularityException(true);
public void setUp() 
fail("Expecting NullPointerException");
double[] test2 = {5,2,1,3,4,0};
public static double variance(final double[] values, final int begin,
double scalRelativeTolerance);
double log10R = Math.log(Math.max(1.0e-10,
assertEquals("p value", 0.0136390585873,
hexString = randomData.nextSecureHexString(100);
public Double() {
factory.newBisectionSolver(null);
assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);
distribution.setDegreesOfFreedom(expected.length - 1.0);
assertEquals("Number of elements should be equals to " + (iterations +1),
assertTrue(x.equals(y));
if (!isValidCoordinate(row,column)) {
protected AbstractCurveFitter(int n, Estimator estimator) {
0.710, 0.729, 0.720, 0.636, 0.581,
if (endIndex < source.length()) {
protected abstract void iterateSimplex()
testDa.addElement(1d);
double yDDotOnScale = 0;
private static final String methodName = "Dormand-Prince 8 (5, 3)";
assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.495) < 1.0e-10);
Double.POSITIVE_INFINITY};
assertEquals(8.0, y[0], 1.0e-12);
rDiag = new double[n];
if (p.value(min) == 0.0) { return min; }
ComplexUtils.sqrt1z(null); 
assertTrue(zero.equals(zero2));
if (d == 0.0) {
if (x == 0.0) {
private static class APSProblem26 extends TestProblem {
if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {
setRecurrenceCoefficients(new RationalNumber(0l),
interpolator.reinitialize(new DummyEquations(), y, yDot, true);
assertTrue(Math.abs(error) < 1.0e-10);
throw new IllegalArgumentException("number of trials must be non-negative.");
normal.setMean(p);
public void setValuesFileURL(URL url) {
polynoms[1][i] = ydiff;
result = result * 31 + MathUtils.hash(getMax());
public void checkPolynomial(Polynomial.Double p, String reference) {
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);
private void simplify() {
assertTrue(Math.abs(pair.getX() - 1.2) < 1.0e-10);
System.arraycopy(polynomials, 0, this.polynomials, 0, n);
if (getN() == windowSize) {
public class FourthMoment extends ThirdMoment implements Serializable{
public FunctionEvaluationException(double argument, Throwable cause) {
F[N] = y[N >> 1].getReal();
public void testMulD() {
if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {
DescriptiveStatistics ageU = new BeanListUnivariateImpl( patientList,
throw new IllegalArgumentException("Coefficient array must have positive length for differentiation");
integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);
for (int j = rank; j < cols; ++j) {
private double[] coeffs1;
public double getQuantile() {
if (! absAi.isOne()) {
64.5856498144943, 11.1517793413499,
public void testConstruction() {
double out = 1;
assertFraction(10, 21, a.abs());
da.setElement(1, 3.0);
jacobian[i] = new double[] { j1, j2, j3, j4 };
public double[] getSortedValues() {
factory = null;
public static BigMatrix createRowBigMatrix(String[] rowData) {
assertEquals( 0.0, f.value( 1.0), tolerance );
return Math.sqrt(variance.evaluate(values, begin, length));
private static final double tMq = 2 - Math.sqrt(2.0);
interpolator.setInterpolatedTime(t0);
public abstract class UnivariateStatisticAbstractTest extends TestCase {
u.setElement(i, j, -1.3);
0.0456, 0.0342, 0.0323, 0.0235, 0.0246
public boolean containsTransformer(NumberTransformer value) {
for (int i = 0; i < starts; ++i) {
private static final long serialVersionUID = -2941995784909003131L;  
double[] a2 = { 0.1, 0.2, 0.3 };
accum3 /= Math.pow(stdDev, 3.0d);
public Double(long a2, long a1, long a0) {
if (j == 41) {
checkLegendre(new Legendre(3),  2l, "-3 x + 5 x^3");
inverseCumulativeTestValues = makeInverseCumulativeTestValues();   
double   x1 = parameters[0].getEstimate();
public void testQuantiles() throws Exception {
public ExponentialDistribution createExponentialDistribution(double mean) {
public static double variance(final double[] values, final double mean) {
private BigInteger p;
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);
private boolean initialized;
q = BigInteger.ONE;
-4.54137541918194,     1.01201187975044
public synchronized void addElement(double value) {
FirstOrderIntegrator integ = new EulerIntegrator(step);
double hInt = getMaxStep();
b.setElement(i, 1, (i + 1.0) * (i + 2.0) / 2.0);
protected abstract NonNullRange getRangeForRow(int i);
for (int j =0; j < 20; j++) {
addToSelf((Interval) iterator.next());
package org.apache.commons.math.stat;
assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());
final int length) {
Double.MIN_VALUE );
public int getDimension();
Complex z = new Complex(inf, nan);
if (step < minStep) {
public HypergeometricDistributionTest(String name) {
double alpha, double beta);
super.testAdd1000();
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);
private int findPerm(int[][] p, int[] samp) {
private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;
public boolean isZero() {
permutation = new int[nRows];
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
public double predict(double x) {
extends AbstractIntegerDistribution
return (int)doubleValue();
if (p == coefficients[0]) {
c = p2 / q2;
if (x0 == x2) {
moment.increment(d);
m.setSubMatrix(testDataPlus3,0,0);      
checkValue(new PolynomialFraction(1l, 6l).add(new PolynomialFraction(2l, 6l)),
double e = c * (n * productsSums[k++] - sums[i] * sums[j]);
return map.remove(key);
return (Object[][]) contents.clone();
assertEquals(0.0, result[i].getImaginary(), tolerance);
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
double g = 607.0 / 128.0;
if (rows <= 0 || columns <= 0) {
cachedResources =
RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
protected StepHandler handler;
private boolean firstGuessNeeded;
sum2[k++] += x[i] * x[j];
public void testCumulativeProbabilities() throws Exception {
for (int i = 0; i < 7; ++i) {
0.0175364017658228,
rd2 = new RandomDataImpl();
this.b            = b;
return a.length - 1;
public class VectorialMeanTest
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
new UnivariateRealFunction() {
public void testChiSquareDataSetsComparisonUnEqualCounts()
private static GeometricMean geometricMean = new GeometricMean();
assertEquals(1, new Polynomial.Double(0.0, 3.0, 5.0).getDegree());
for (int i=0; i<mv1.length; i++) 
90.008868539167, 110.02653274833
3.0924623877272e-6, 2.4752044261050e-6, 2.0633567678513e-6,
extends OrthogonalPolynomial {
if (h > maxStep) {
verifySummary(summary);     
double p1;
testLogBeta(Double.NaN, -1.0, 2.0);
testStatistic.tTest(sample1, sample2), 1E-10);
return new double[]{0};
sampleStats1.addValue(sample1[i]);
return (double[]) interpolatedState.clone();
double x22 = m[2][2];
public void testCreateRealMatrix() {
(denominator == rhs.denominator);
return solve(MatrixUtils.createBigIdentityMatrix
MatrixUtils.createBigMatrix(bigColMatrix));
public class TestFactoryImpl extends TestFactory {
public class FunctionException
private static final long serialVersionUID = -7818711964045118679L;  
assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 1.0) < 1.0e-10);
vs.closeReplayFile();
checkPolynomial(new Hermite(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");
Integer.toString(m[0].length)
private double[][] m4 = {{1, 0, 0}, 
assertTrue(z.isNaN());
NumberFormat nf = NumberFormat.getInstance();
BigDecimal[][] getData();
Vector3D  i = k.orthogonal();
long result = 0;
PolynomialFunction polynomials[] = f.getPolynomials();
return unknownDistributionChiSquareTest.chiSquareDataSetsComparison(observed1, observed2);
return new NonNullRange(Math.min(first.begin, second.begin),
public static short indicator(final short x) {
DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,
testProbability(0.504, 4.0, 1.0, .0018);
ComplexUtils.atan(null); 
if (x < 0.5) {
+ " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");
TestSuite suite = new TestSuite(CertifiedDataTest.class);
checkPolynomial(new Chebyshev(4), "1 - 8 x^2 + 8 x^4");
private static final long serialVersionUID = 490960015010326571L;
if (! measurements [i].isIgnored()) {
u.addValue(randomData.nextGaussian(0,1));
setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447, 
target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};
public void testFloatValue() {
public class DerivativeException
long s = (long)x + (long)y;
if (n < 2 || n != sample2.length) {
a[i] = (RationalNumber) l.get(start + i);
protected abstract char getDecimalCharacter();
newIntervals.add(new Interval(inf, sup));
assertTrue(handler.getMaximalError() < 1.0e-3);
if (mu < 0) {
private static double roundUnscaled(double unscaled, double sign,
BigDecimal trace = data[0][0];
RealMatrix add(RealMatrix m) throws IllegalArgumentException;
assertEquals(m2,m);
this.stepControl3 = stepControl3;
if (!found) {
public UnivariateStatisticAbstractTest(String name) {
public BigMatrix getRowMatrix(int row) throws MatrixIndexException {
private void minpackTest(MinpackFunction function, boolean exceptionExpected) {
verifyInverseCumulativeProbabilities();       
+ " interval." + "  Initial: " + initial
private static final double sqrt6 = Math.sqrt(6.0);
sequence        = new int[size];
assertTrue(r.begin == 2);
new RationalNumber(3l, 4l));
private int costEvaluations;
return new Fraction(num.intValue(), den.intValue());
public class CorrelatedRandomVectorGeneratorTest
public double[] valueAt(double t)
return sumLog.evaluate(values, begin, length);
private Variance variance = null;
index = iMed;
for (int i = 0; i < Math.abs(omegaCount); i++) {
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
if (! a1.isZero()) {
do {
lu = m.getLUMatrix();
expected[0] = 0;
RationalNumber[] newA = new RationalNumber[a.length];
11.0 * Math.sqrt(169000121.0)), false);
assertTrue(solver.getIterationCount() <= 8);
return n;
assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);
protected double[] expected = {250,250,250,250};
assertEquals("total count",0,u.getN(),tolerance);      
public void testConstructorPatternArgumentsCause(){
assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
private double [][] points;
public double[] integrate(ComputableFunction f, double a, double b)
int numberOfSucceses = 55;
if (vecAbsoluteTolerance != null) {
private double lastTime;
assertTrue(Math.abs(d02) > 4.0e-7);
protected void verifyIterationCount() throws IllegalArgumentException {
m1 += nDev;
checkPolynomial(new Polynomial.Double(3.0,  2.0, 0.0),
double[][] weightedRoots;
private double[][] a;
a[degree] = c;
LowerTriangularMatrix l = new LowerTriangularMatrix(4);
BigInteger[] result = p.divideAndRemainder(q);
public boolean converged(PointCostPair[] simplex) {
computeOmega(f.length);
assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));        
return age;
iterations +1, eDA3.getNumElements() );
double expected = 0.99;
return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;
String source = "2 -2 / 3";
simplex[i] = new PointCostPair(vertices[i], Double.NaN);
public void testDegenerate0() throws Exception {
double r2 = y[0] * y[0] + y[1] * y[1];
public LaguerreSolver(UnivariateRealFunction f) throws
return getJacobian()[index][j];
if (x0 > x1) {
public BinomialDistributionImpl(int trials, double p) {
- interpolator.getPreviousTime());
if (n < k) {
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
public ContinuousDistributionAbstractTest(String name) {
StringBuffer s = new StringBuffer();
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testMultiplyNaNInf() {
public FunctionEvaluationException(double argument,
assertEquals("significance", 0.261829133982,
public void testAbs() {
(x > 1) || (a <= 0.0) || (b <= 0.0))
assertTrue("stats with same data should be equal", statistic.equals(statistic2));
equations.computeDerivatives(t0 + h, y1, yDot1);
NonNullRange r = NonNullRange.intersection(getRangeForRow(i),
yDotK[k], 0, dimension);
product = 1.0;
double secondDataValue = 3.6485326248346936;
test = new double[] {2, 4, 6, 8};
PolynomialFraction f = new PolynomialFraction(2l, 3l);
this.x = Math.cos(alpha) * cosDelta;
new Object[] { new Double(x) });
public Chebyshev(int degree) {
public BisectionSolver(UnivariateRealFunction f) {
if (fb * fc > 0) {
solver.decompose(
assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0     
double originalCost = original[0].cost;
x -= dx;
sumYY = 0d;
TestSuite suite = new TestSuite(TestUtilsTest.class);
return new Vector3D(0, inverse * z, -inverse * y);
random.nextBytes(bytes);
return new TestSuite(ContinuousOutputModelTest.class);
private static class LinearMeasurement extends WeightedMeasurement {
return lowerBound;
public Mean() {
double pc2 = previousCost * previousCost;
return rank;
public final class BrentSolverTest extends TestCase {
throws ExhaustedSampleException, FunctionException, EstimationException {
upperData[index++] = work[workIndex++];
assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);
midx  += m.columns;
public void testNextGaussian() { 
assertEquals("sum entry entry",
m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); 
e);
assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
distribution.setStandardDeviation(sigma);
public double getMax() {
problems.add(new APSProblem25(n25[k], 1.0, 100.0, n25[k]));
public void testConstructor() {
fb = function.value(b);
MathException {
void setNumeratorDegreesOfFreedom(double degreesOfFreedom);
public void mapStateFromArray(int start, double[] array) {
private MappableArray array3;
eDA2.addElement( 2.0 );
double q1 = 1.0;
public class InvalidMatrixException extends RuntimeException {
private static double k16_12 =                 0.0                       - b_12;
protected Variance variance = null;
double t0, double t,
return a2;
public abstract int getDegree();
double t = 2.0 * Math.PI / n;
PrintWriter pw = new PrintWriter(out, false);
assertEquals("Incorrect density value returned for " + densityTestPoints[i],
assertFalse("chi-square test result", 
min = (min < values[i]) ? min : values[i];
suite.addTest(PolynomialRationalTest.suite());
VectorialValuedPair pair2 = new VectorialValuedPair(pair1.x,
0.5318646, 0.1526342});
f2 = new Fraction(2,59049);
assertEquals(add.getInf(), Interval.add(i1, i2).getInf(), 1.0e-10);
entry.object.mapStateToArray(entry.offset, data);
c = p.getCoefficients();
integ.setStepHandler(cm);
public void computeStats() throws IOException {
new GeneralMatrix(2, 3).mul(new GeneralMatrix(2, 3));
public NonNullRange getRangeForColumn(int j) {
private static final long serialVersionUID = -8007759382851708045L;
public DiagonalMatrix(DiagonalMatrix d) {
if (Double.isNaN(expected)) {
x = new double[n];
f.setCallsCount(0);
pb1.getInitialTime(), pb1.getInitialState(),
this.n = 0;
testStatistic.chiSquareTest(expected1, observed1, 95);
assertEquals(arguments[i], ex.getArguments()[i]);
protected double[] nullArray = null;
testLocalMaximum(derivative);
return meth.invoke(bean, new Object[0]);
return random.nextDouble();
double contractedCost = evaluateNewSimplex(original, gamma);
double accum3 = 0.0;
public class StandardDeviation extends AbstractStorelessUnivariateStatistic
divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;
lowerData[index]   = work[workIndex++];
for (int j = 1; j < (n - 1); ++j) {
return sum.evaluate(values, begin, length) / ((double) length);
int rows = 7;
double expected = Math.random();
return probabilityOfSuccess;
jacobian[m - 1][0]= -2 * parameters[0].getEstimate();
public class ThreeEighthesIntegrator
private SummaryStatistics sampleStats = null;
public void testDimensions() {
p1 = p2;
m3 = Double.NaN;
if (f.value(max) == 0.0) { return max; }
PolynomialFunction f = new PolynomialFunction(coefficients);
new Interval(-10.0, 10.0), new Interval(-10.0, 10.0));
public UnivariateRealFunction interpolate(double x[], double y[]) {
double inverse = -1 / Math.sqrt(squaredSine);
forward   = true;
this.quotient  = quotient;
public BigMatrix scalarMultiply(BigDecimal d) {
double aki = jacobian[index];
if ((cachedResources == null) || (! cachedResources.getLocale().equals(locale))) {
throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);
x = spline.value(2.5);
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
FirstOrderIntegratorFactory factory =
double[] copiedArray = new double[eDA.getNumElements()];
+ " in a symetrical matrix");
return 0.99 * (i + 1) * (j + 1);
+ u.rows + 'x' + u.columns
assertEquals(name, b.getPropertyName());
parameters = new EstimatedParameter[n];
Double.doubleToRawLongBits(rhs.getImaginary())); 
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
percentile.evaluate(nullArray);
estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));
+ k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];
reinitialize(y, forward);
for (int row = col; row < nRows; row++) {
new RealMatrixImpl(testData2).solve(bs);
int d = den.intValue();
double stepControl3, double stepControl4) {
+ " - 260061484647976556945400 x^18"
-0.000563932146980154, 0.347820540050756,
int getMinimalIterationCount();
public static void assertContains(String msg, double[] values,
max = x;
return intervals;
if (delta >= 0.0) {
double[] mean = meanStat.getResult();
assertEquals(13*13*17*2*2, f.getDenominator());
result = solver.solve(1, 4);
public BrentSolver(UnivariateRealFunction f) {
z[n] = 0d;
public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
if(e instanceof RuntimeException){
for (int j = 0; j < selectedColumns.length; j++) {
public interface UnivariateRealIntegrator {
((n - 1) * (n -2) * (n -3) * variance * variance);
public void testSelfMul() {
public void checkMatrix(Matrix m, ElementPattern pattern) {
if (lmDiag[k] != 0) {
while (Math.abs(an) > epsilon && n < maxIterations) {
public void testOneSampleT() throws Exception {
SummaryStatistics stats = SummaryStatistics.newInstance();
return evaluate(values, mean, 0, values.length);
p = BigInteger.valueOf(numerator);
public BilinearPattern(double coeffI, double coeffJ) {
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
public double evaluate(final double[] values, final double mean, 
throws IntegratorException {
q0 = composed.q0;
m1.getColumns(),
assertTrue(Double.isNaN(w.imaginary));
for (int i=0; i<c.length; i++) 
distribution.cumulativeProbability(lower);
1.36579949521007, 4.82373199748107,
for (int l = 0; l < k; ++l) {
private static class APSProblem21 extends TestProblem {
public static void assertSame(Complex expected, Complex actual) {
assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);
protected String[][] stringRowMatrix = {{"1", "2", "3"}};
"1.0 + 2.0 x + 3.0 x^2");
long result = Math.round(factorialDouble(n));
public Rational(RationalNumber a2, RationalNumber a1, RationalNumber a0) {
TestSuite suite = new TestSuite(ListUnivariateImplTest.class);
ti   = temp * tmp2 - tmp1;
implements FirstOrderDifferentialEquations {
if (windowSize != DescriptiveStatistics.INFINITE_WINDOW) {
assertEquals(0.0, optimum.point[0], 0.07);
public class RiemannIntegrator
true, false, 1, false, false, 2, true,
needUpdate = true;
return tTest.pairedTTest(sample1, sample2, alpha);
assertTrue(Math.abs(d00) > 4.0e-7);
verifyInterval(min,max);
Vector3D v1 = new Vector3D(0, 0, 2);
ffpIterator = new FFPIterator(measurements);
double y[] = { 0.0, 0.5, 1.0 };
double c = k.getX() * (u1y * u2z - u1z * u2y)
Assert.assertEquals(a.length, b.length);
return intervals.size() == 1;
double c = rhs.getReal();
TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);
public LaguerreTest(String name) {
sum.clear();
testSolve(m1, "Solving matrix m1");  
MathUtils.binomialCoefficient(test, test / 2);
return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2);
SummaryStatistics.class,
double sin, cos;
private boolean vectorsInitialized;
public Polynomial divide(long l) {
Product product = new Product();
new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);
InstantiationException, IllegalAccessException {
RealMatrix lower =new RealMatrixImpl(lowerData);
return moment.getN();
MatrixUtils.createRealMatrix(testData));
String valueString = line.substring(n + 1).trim();
private static TTest tTest = new TTestImpl();
Complex[] root = solveAll(c, initial);
public void testApplyInverseTo() {
double cst = csti.chiSquareTest(exp, obs); 
if (count == null) {
double scaling_coefficient = 2.0 / f.length;
assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);
Integer c = new Integer(hash[i]);
if (! firstStepAlreadyComputed) {
assertEquals(1, new Polynomial.Double(3.0, 5.0).getDegree());
double dRdX = 0;
double[] newA = new double[a.length + p.a.length - 1];
&& (q.compareTo(BigInteger.ONE) == 0);
return ((DefaultValue)argument.evaluate(this)).byteValue();
public void setExpansionMode(int expansionMode) {
public abstract HypergeometricDistribution
checkSorted();
public static UnivariateRealFunction decorate(UnivariateRealFunction function, double h) {
checkMatrix(m, new BilinearPattern(1.0, 0.01));
assertEquals( -8.06637, f.value( 1.3), tolerance );
0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406
public void testRedundantEquations() throws EstimationException {
w = oneInf.multiply(oneNegInf);
private static final long serialVersionUID = -8516354193418641566L;
hNew = filterStep(optimalStep[k]
protected double readBaseExternal(ObjectInput in)
return 3.0;
double sum = 0;
super(cause);
throw new DimensionMismatchException(v.length, means.length);
freqTable.put(obj, new Long(1));
public HermiteTest(String name) {
return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
assertEquals("valuesFileURL test","http://www.apache.org",url.toString());
nextAction        = function.eventOccurred(t, y);
extends Matrix {
+ ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);
minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },
if (step > maxStep) {
if (in[0].length < 2) {
public int[] nextPermutation(int n, int k) {
Complex expected = new Complex(0.936812, -2.30551);
assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));
y[i] = c * y0[i];
middleIndex = fk[l2+j].length / 2;
Complex z = initial;
public Kurtosis() {
return new RationalNumber(p.negate(), q.multiply(l.negate()));
double tolerance =
throw new IllegalArgumentException("probability of success must be between 0.0 and 1.0, inclusive.");
assertEquals(30.01d,  MathUtils.round(30.005d, 2), 0.0d);
return (double[]) min.clone();
Complex z = oneInf.divide(Complex.ONE);
new Interval(-0.9, -0.8) },
SummaryStatistics sampleStats = null;
regression.getSlopeStdErr(),10E-12);
suite.addTest(MappableArrayTest.suite());
assertTrue(Double.isNaN(MathUtils.log(1, -1)));
switchesHandler = new SwitchingFunctionsHandler();
private static class APSProblems2To11 extends TestProblem {
public RationalNumber subtract(RationalNumber r) {
if (s.permutations != null) {
public static Complex pow(Complex y, Complex x) {
super(a.length, new double[a.length * a.length]);
assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);
Rational quotient  = new Rational(0l);
assertEquals(-1.0, c[4], tolerance);
Estimator estimator) {
public void testAddSample() {
outBuffer.append("min: " + getMin() + "\n");
1.0173699343977738,10E-7);
double x05 = parameters[4].getEstimate();
private static final double sqrt2 = Math.sqrt(2.0);
public void setSigma(double sigma) {
int dkp = permutation[k + dk] - pk;
den == Integer.MIN_VALUE) {
initialTime = model.initialTime;
System.arraycopy(m.data, 0, data, 0, m.data.length);
rescale(y, y1, scale);
minpackTest(new BrownAlmostLinearFunction(40, 0.5,
b3.setElement(1, 50.0);
assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);
int[] index = new int[order];
assertEquals(1d, testDa.getElement(0), 0);
TestSuite suite = new TestSuite(SumLogTest.class);
VectorialValuedPair point = ffpIterator.nextSamplePoint();
distribution = makeDistribution();
lowerElements, upperElements);
return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, 
MathUtils.factorialDouble(-1);
-0.403574643314272, 0.236736269844604
public Object putTransformer(Class key, NumberTransformer transformer) {
return this.product;
PointCostPair pair = simplex[i];
throws Exception {
0.099206d, 0.003968d, 0d};
Double.doubleToLongBits(m.getEntry(row, col))) {
--x1;
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);
double initialNorm = 0.0;
double a = initial;
double[][] yMidDots = null;
new LinearMeasurement(new double[] { epsilon, 1.0 },
public FastSineTransformer() {
public boolean isLoaded() {
if (k != j) {
private static double b_06 =        3399327.0 / 763840.0;
error += e * e;
for (int i = 0, index = 0; i < rows; i++) {
QRDecomposition qr = new QRDecompositionImpl(matrix);
assertEquals("0", 1, MathUtils.factorial(0));
assertTrue("mean should be one (n = 1)", 
public CholeskySolverTest(String nameOfTest) {
assertEquals(expected, distribution.getScale(), 0.0);
TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);   
pb.getFinalTime(), new double[pb.getDimension()]);
y[2] = -4.0;
checkValue(new PolynomialFraction(7l, 3l).subtract(new PolynomialFraction(-7l, 3l)),
public void testIllConditioned() throws EstimationException {
public void storeTime(double t) {
assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));
double[] interpolatedY = interpolator.getInterpolatedState();
inf = b;
v1 = new Vector3D(v1x, v1y, v1z);
public double t(double mu, double[] observed)
assertEquals( 54.84375, f.value( -1.5), tolerance );
private double[][] d4 = new double[][] {{1},{2},{3},{4}};
min.increment(testArray[2]);
public interface ChiSquareTest {
"16 and an expansion factor of 2.0",
protected static char parseNextCharacter(String source, ParsePosition pos) {
NonNullRange r = getRangeForRow(i);
--targetIter;
str = filePointer.readLine();
double[] xOriginal    = original[i].point;
F[2*i+1] = F[2*i-1] - y[i].getImaginary();
result = UnivariateRealSolverUtils.solve(f, 0.85, 5);
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 1.0) < 1.0e-10);
if (Math.abs(lu[max][col]) < TOO_SMALL) {
"Continued fraction convergents diverged to +/- infinity for value {0}",
private static final long serialVersionUID = 5378525034886164398L;
public void testVariableSteps()
public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {
assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);
long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };
yDotK[k][i] = in.readDouble();
public void testPowell()
pb.getFinalTime() - range / 21.0);
public void testUnivariateImpl() throws Exception {
product.increment(Double.NEGATIVE_INFINITY);
r = r * rnd;
public StringBuffer format(Complex complex, StringBuffer toAppendTo,
parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));
private int dimension2;
+ " - 7710436200670580005508880 x^26"
return partial(x, p);
public void testGetColumnMatrix() {
class TestProblem5
assertEquals(result, 0, 1E-6);
CholeskySolver solver = new CholeskySolver();
this.rho   = 1.0;
"ending loop of expansion and contraction as a newly " +
return finalTime;
current  = evaluateCriterion(problem);
double dxNorm = 0;
Complex z = new Complex(initial, 0.0);
for (double x = 0.0; x < 100.0; x += 1.0) {
private static class Stop implements SwitchingFunction {
l.add(ck.multiply(b3k));
long exponent = bits & 0x7ff0000000000000L;
public void setInterpolatedTime(double time) {
firstTime = true;
assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));
public void testModes() throws Exception {
m [0][1] = 2.0 * (q1q2 + q0q3);
public class EstimatedParameterTest
double a = x[1] - x[0] * x[0];
public void testRegularizedGammaPositivePositive() {
size += b2.getStateDimension();
Complex z = x.multiply(y);
this.y = Math.sin(alpha) * cosDelta;
(-1324889724104.0 + 318801444819.0 * sqrt6) / 626556937500.0,
r = new Rotation(42, 0, 0, 0, true);
for (int i = 1; i < measurements.length; ++i) {
public static double binomialCoefficientDouble(final int n, final int k) {
double gb = function.g(tb, interpolator.getInterpolatedState());
public TestProblem2(TestProblem2 problem) {
checkUnsolvableProblem(new LevenbergMarquardtEstimator(), true);
public void testAsinNull() {
while (nextInStep) {
x2 = 0.5 * (x0 + x1); y2 = f.value(x2);
da.addElement(6.0);
long m = ((long)x) * ((long)y);
double coeffV = v1v2 / u1u1;
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );
eDA3.addElement( 2.0 );
public BigDecimal getDeterminant() throws InvalidMatrixException {
double[][] testData3x4 = { 
for (int i = 0; i < v.length; i++) {
costPerStep     = new int[size];
0.0442053461357828, 0.199490672309881,
this.argument = argument;
diag[k] = dk;
private GammaDistribution getGamma() {
for (int j = 4; j <= mu; ++j) {
return (MathUtils.equals(stat.getResult(), this.getResult()) && 
"The expansion factor must be a number greater than 1.0";
mu + 5 * sigma});
Math.atan2(-(v2.getZ()), v2.getY())
-118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,
public EmpiricalDistribution getEmpiricalDistribution() {
testStatistic.tTest(sampleStats1, sampleStats2, .95);
min = 0.0; max = 2.0 * Math.PI * N / (N-1);
double n = getNumeratorDegreesOfFreedom();
lmPar = gNorm / dxNorm;
assertEquals(expected, result, tolerance);
public void test3() {
+ " - 28258538408100 x^2"
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
", " + upper + "]");
if (x < 0) {
super(true, c, a, b, new DormandPrince54StepInterpolator(),
Assert.fail(msg + 
for (int i = 1; i < (7 - j); i++) {
public String getPropertyName() {
EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);
public void testTrace() {
break;
this.fsal      = fsal;
u.addValue(test3[i]);
private double getNextGaussian() {
return new DormandPrince853StepInterpolator(this);
public void testParseZeroReal() {
public HighamHall54IntegratorTest(String name) {
public interface QRDecomposition {
covStat.increment(v);
assertTrue(error < Math.abs(previousError));
return this.thirdMoment;
1.00082109454817,    -2.61773112070507,
this.m = m;
return x1;
sum2 += diff - meanDifference;
public double getQ2() {
boolean nextBoolean();
f = new PolynomialFraction(120l);
public Laguerre() {
int x = (int)data[i][0];
jacobian[m - 1][1]= 1;
assertTrue(handler.getMaximalError() < 5.0e-8);
yDot1    = new double[y0.length];
a.setElement(2, 1,  0.0);
throw new MathException("ClassCastException in Transformation: " + e.getMessage(), e);
public AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
throw new IllegalArgumentException("insufficient data");
new BigMatrixImpl(0, 1);
public class SimpleRegression implements Serializable {
public double valueAt(double t)
private char parseNextCharacter(String source, ParsePosition pos) {
this.step       = step;
++lowerElements;
TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);
private static final double[][] a = {
public Complex parse(String source) throws ParseException {
private Complex oneNegInf = new Complex(1, negInf);
setShape(alpha);
assertEquals(refMean[i], mean[i], 1.0e-12);
denseOutput = (handler.requiresDenseOutput()
assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);
assertTrue(x.divide(w).equals(Complex.ZERO));
BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);
public void resetMaximalIterationCount() {
m1.selfAdd(m2);
Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);
double[] result = UnivariateRealSolverUtils.bracket(sin, 
Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {
while (j < bCols) {
package org.spaceroots.mantissa.fitting;
return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
Math.max((int) Math.ceil((value- min) / delta) - 1, 0), 
private static class HelicalValleyFunction extends MinpackFunction {
double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };
BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);
assertTrue(handler.getMaximalError() < 1.0e-6);
testLogGamma(0.6931471805599457, 3.0);
int getBinCount();
public double[] inversetransform(double f[]) throws MathException,
assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))
values[0] = -x;
public void testExhausted()
problems.add(new APSProblems12To14(-100, -9.0, 31.0, 0.0));
index < i * b.columns + range.end;
public ScalarValuedPair samplePointAt(int index)
? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)
if (res.remainder.isZero()) {
(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);
public class UncorrelatedRandomVectorGeneratorTest
(imaginary - real * q) / denominator);
t0 = t;
EstimatedParameter p = (EstimatedParameter) iterator.next();
n    = (int) Math.floor((range[1] - range[0]) / step);
testValue(5.000, 2.0, 2.0, .7127);
FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));
public RealMatrixImpl(double[][] d) {
ComplexUtils.cosh(null); 
public void testRank() {
RealMatrix m = new RealMatrixImpl(matrixData);
setDistribution(new BinomialDistributionImpl(5,1.0d));
paru = 2.2251e-308 / Math.min(delta, 0.1);
double[] angles = r.getAngles(EulerOrders[i]);
return new Fraction (w.intValue(), 
if (index < 0) {
delta = 0.5 * dx;
new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);
assertTrue(Math.abs(scalar2.getValue() - 0.1) < 1.0e-10);
return maximalIterationCount;
assertEquals(50.09d,  MathUtils.round(50.085d, 2), 0.0d);
assertEquals(3d, testDa.getElement(1), 0);
assertEquals(0.0, optimum.cost, 6.0e-4);
if (fraction.numerator == 0) {
t0    = problem.t0;
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
estimator1.estimate(problem1);
assertFalse(Double.isNaN(skew.getResult()));      
imaginary - rhs.getImaginary());
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
checkLaguerre(new Laguerre(7), 5040l,
public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {
Math.pow(
public double[] getErrorScale() {
super(m, buildArray(n, x0), theoreticalStartCost,
final int begin,
minima[i] = null;
coefficients[0] = a[n];
private double stepControl2;
m = new RealMatrixImpl();
interpolator.storeTime(currentT + h);
fail("expecting NullPointerException");
result = solver.solveAll(coefficients, initial);
double ratio =  handler.getMaximalError() / absTolerance;
yDotK = new double[kMax][];
doFinalize();
public abstract double homoscedasticT(double[] sample1, double[] sample2)
evenPermutations   = ! evenPermutations;
delta = 0.5 * oldDelta;
minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },
cf.setRealFormat(null);
checkAngle(r.getAngle(), 0.5 * Math.PI);
0.188053165007911,
setStepsizeControl(-1, -1, -1, -1);
assertEquals("3x3 nonsingular A = QR", 0, norm, normTolerance);
double a2 = 2.0 * z.getReal();
min = 0; max = 1; expected = -1.0/48;
name     = parameter.name;
public abstract class AbstractDifferenceDerivative extends UnivariateRealFunctionProxy implements UnivariateRealFunction {
"must have n >= 0 for binomial coefficient (n,k)");
private Complex zeroInf = new Complex(0, inf);
Number im = parseNumber(source, getRealFormat(), pos);
int n = problem.getMeasurements().length;
problems.add(new APSProblems15To17(n17[k], 1.0, -0.95, 4.05, 1.0));
for (int col = minor; col < m; col++) {
assertTrue(Double.isNaN(percentile.evaluate(specialValues)));   
public MathConfigurationException(Throwable cause) {
testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract
problems.add(new APSProblems2To11(1.0e-9 + n * n,
private static final long serialVersionUID = 1417147976215668305L;
assertEquals("std err intercept", 0.286036932,
private int maxCostEval;
double   cosine = Math.cos(omegaX);
private Complex oneNaN = new Complex(1, nan);
double discarded = internalArray[startIndex];
public class FDistributionImpl
return product;
permutation[k]          = pk;
double[] work1, double[] work2, double[] work3) {
while(u <= 0.0){
p1 = p1.add(p2);
s.selfAddWAAt(2.0, a2);
Throwable cause) {
public final class MathUtilsTest extends TestCase {
return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
jacobian[i][j] = dx * tmp4;
public void setShape(double alpha) {
v1 = new Variance(false);
assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);
mean[i] = 0;
x.setElement(0, 0, 1.0 + epsilon);
this.estimator = estimator;
optimalIter = 1;
0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,
return randomGenerator.nextBoolean();
line = reader.readLine(); // one's or two's line
double[][] m2 = { { 0.83203, -0.55012, -0.07139 },
public class FractionConversionException extends MaxIterationsExceededException {
-2.17958042710327, 0.0, -0.648846697642915,
return new Percentile(95.0);
public void testNextUniformExclusiveEndpoints() {
public void luDecompose() throws InvalidMatrixException {
if ((str = filePointer.readLine()) == null) {
double A, B, x[], F[] = new double[f.length];
TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);
minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },
double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };
resetTables(-1);
"Max should be 1212.0",
assertEquals(w.real, inf, 0);
this.rho   = rho;
return getCumFreq(new Long(v));         
getGamma().setAlpha(degreesOfFreedom / 2.0);
protected double[] getCumulativeTestValues() {
for (int i = 0; i < 1024; i++) {
if (value != null) {
JDK_SUPPORTS_NESTED = flag;
public int getMaxIterations() {
public static DummyStepHandler getInstance() {
points = null;
v3 = null;
double x12 = m[1][2];
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(-2l, 5l)),
public HarmonicFitter(EstimatedParameter[] coefficients,
this(0.1);
distribution.setNumeratorDegreesOfFreedom(0d);
public void testCreateRowBigMatrix() {
Double.parseDouble(
assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);
Math.atan2(-(v1.getY()), v1.getZ()),
RealMatrix estimatedCorrelation = covStat.getResult();
this.moment = m4;
double v1 = 0;
assertEquals(1.0, p[3].getEstimate(), 1.0e-10);
++bIndex;
this.rawStep = rawStep;
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
public void testSqrt1zNaN() {
public int nextInt(int n) {
private double integrateWithSpecifiedStep(double omega,
m = new BigMatrixImpl();
private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {
size          = 0;
public void closeReplayFile() throws IOException {
max        = (double[]) s.max.clone();
return getImproperInstance(Locale.getDefault());
IntervalsList list = new IntervalsList();
private double maxCheckInterval;
protected ContinuedFraction() {
public Rational(long a3, long a2, long a1, long a0) {
public Percentile(final double p) {
TestUtils.assertEquals(new Complex(inf, -pi / 4),
private int cols;
return coeffI * i + coeffJ * j;
testStatistic.chiSquareTest(counts, 0);
return new MidpointStepInterpolator(this);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
private int dimension1;
private static class BrownDennisFunction extends MinpackFunction {
val = vs.getNext();
return outMat;
d[i] = data[i].doubleValue();
double threshold = costAccuracy * (1.0 + theoreticalStartCost);
SummaryStatistics stat = (SummaryStatistics) object;
if (n < 2) {
private final int p;
sup = 0;
suite.setName("BigMatrixImpl Tests");
new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },
public interface HypergeometricDistribution extends IntegerDistribution {
protected double entryTolerance = 10E-16;
public void handleStep(double t,
testi = rd.nextPermutation(10,6);
public class RotationTest
regression.addData(data);
absoluteAccuracy = accuracy;
checkMatrix(m1, new BilinearPattern(101, 0));
result = solver.solve(0.6, 7.0, 0.999999);
return cumulativeProbability(x1) - cumulativeProbability(x0);
return p.signum() == 0;
private static final long serialVersionUID = -2271007547170169872L;
toAppendTo.append(" / ");
(new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});
return new SumOfLogs();
String msg =
this.median = median;
return result;
protected BigDecimal[] bigCol = 
assertEquals(4d, distribution.getAlpha(), 0);
return factory;
public void testAcosNaN() {
assertEquals("chi-square test statistic", 7.232189,
super(m, buildChebyquadArray(n, factor), theoreticalStartCost,
public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {
private Erf() {
double error2 = 0;
: new RationalNumber(q, p);
public void testSetRelativeAccuracy(){
public void testRegularizedGammaPositiveNan() {
if (Double.isNaN(pair.cost)) {
delta = 2 * lmNorm;
ret = ret * 31 + nRows;
boolean ignored) {
double[] binUpperBounds = new double[binCount];
assertEquals("Column3", mColumn3, 
assertFalse(x.equals(y));
new Interval(30, 60)
return forward ? initialStep : -initialStep;
Percentile p = new Percentile(30);
double b[] = new double[n];
assertTrue(Math.abs(pair2.x    - pair1.x)    < 1.0e-10);
public class DummyStepInterpolator
Polynomial.Rational.euclidianDivision(a, b);
throw new MathException("Conversion Exception in Transformation: {0}",
DataAdapter da = new StreamDataAdapter(in);
checkPolynomial(res.remainder, "-47/9");
assertEquals(0.0, mean[1], 1.0e-12);
return q;
double tol = 1.0e-10 * Math.abs(p.getExpectedRoot());
assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);
return "Square Root";
this.mudif = mudif;
if (cost != 0) {
public double inverseCumulativeProbability(double p) throws MathException {
this.a = new double[a.length];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
assertTrue(Math.abs(u.getDeterminant(1.0e-10) - Math.pow(2.0, u.getRows()))
if (lmPar == 0) {
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
y3 = f.value(x3);
public double getFunctionValueAccuracy() {
checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),
coeff[k] = (k > 0) ? new double[k] : null;
this(r.getNumerator(), r.getDenominator());
m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  
double current  = lastInterpolator.getCurrentTime();
public Rotation(Vector3D u, Vector3D v) {
return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
return new Rational(new RationalNumber[] { RationalNumber.ZERO });
ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);
this(p, new NormalDistributionImpl());
Fraction f2 = Fraction.ONE;
double coeff2     = 3 * s * (1 + theta - fourTheta2);
return 100 * a * a + b * b;
public void setY(double y) {
min = -1.0; max = 1.5; expected = 0.0;
return new NormalDistributionImpl(mean, sd);
("Invalid endpoint parameters:  lowerBound=" + lowerBound + 
extends MathException {
private double[] densityTestValues;
public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {
MathException ex = new MathException();
if (h > getMaxStep()) {
&& (ratio <= 2.0))
assertEquals("slope conf interval half-width", 2.97802204827, 
double diff = distribution.cumulativeProbability(upper) - 
7.0),
-1.65685424949238, 0.795649469518633 };
private LinearProblem buildProblem3 ()
double epsilon) {
private static double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;
m2 = Double.NaN;
private static final long serialVersionUID = 3213856667479179710L;
private SecureRandom secRand = null;
replaceWorstPoint(new PointCostPair(xE, costE));
result = transformer.inversetransform(f, min, max, N);
for (int i = 0; i < m1.getRows(); ++i) {
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
public IntervalsListTest(String name) {
private double g0;
BigDecimal[][] upperData = new BigDecimal[n][n];
assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));
VectorialValuedPair pair = iter.nextSamplePoint();
specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,
protected EmpiricalDistribution empiricalDistribution = null;
IntervalsList copy = new IntervalsList(list1);
if (shouldContract()) {
assertFalse(Double.isNaN(sum.getResult()));
for (int dk = cols - 1 - k; dk > 0; --dk) {
throw new IllegalArgumentException("matrix dimension mismatch");
hNew = switchesHandler.getEventTime() - currentT;
public void testAngles()
double[] estimatedMean = meanStat.getResult();
super(specifier, parts);
Matrix result = d.solve(b, 1.0e-10);
stats.addValue(inputArray[i]);
new Interval[] { new Interval(-0.9, -0.8) });
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testGetImaginaryFormat() {
yDotKLast[1] = new double[dimension];
assertTrue(Math.abs(pair.y[0] + 8.4) < 1.0e-10);
alpha -= Q[row][col] * qr[row][minor];
1.0 / 3.0, 2.0 / 3.0, 1.0
out[i] = data[i][col].doubleValue();
long nextLong(long lower, long upper);
double gr = cf.evaluate(0.0, 10e-9);
double[] range, double step,
protected Matrix(int rows, int columns) {
public BackwardDifferenceDerivative(UnivariateRealFunction function, double h) {
System.arraycopy(zDot,  0, yDot, 0,         dimension);
assertEquals("-1 2 / 3", actual);
throw new ConvergenceException("none of the {0} start points"
public SymetricalMatrixTest(String name) {
throw new InvalidMatrixException("coefficient matrix is not square");
public GaussLegendreIntegratorTest(String name) {
return new NewtonSolver(f);
public Polynomial multiply(BigInteger i) {
value += d;
iterations + 1 , eDA2.getNumElements() );
double[][] sumEntries = asDouble(mPlusMInv.getData());
cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));
StatUtils.product(x);
t += subStep;
double v = 1.0 - n * x;
testRegularizedGamma(Double.NaN, 1.0, -1.0);
nDev = Double.NaN;
VectorialValuedPair current  = iter.nextSamplePoint();
ret = getMedian() - getScale();
public void testRegularizedBetaPositiveNegativePositive() {
public void testProperties() throws Exception {
return mf.format(arguments);        
public abstract GammaDistribution createGammaDistribution(
private static final long serialVersionUID = 4978222553983172543L;
protected void setParamsAccuracy(double paramsAccuracy) {
for (int i = begin; i < k; i++) {
problems.add(new APSProblems12To14(-200, -9.0, 31.0, 0.0));
for (double x = -1.0; x <= 1.0; x += 0.02) {
this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;
TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);
y = y * x + a[i];
catch (ArrayIndexOutOfBoundsException e) {
Double.isNaN(actual));
public class LegendreTest
this.a3   = a3;
if (correction > 0.0) {             // x1 < x < x3
assertEquals(5.0, c[1], tolerance);
+ (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;
)
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
setDistribution(new PascalDistributionImpl(5,1.0d));
assertClose("identity multiply",identity.multiply(mInv),
assertTrue(m instanceof GeneralSquareMatrix);
public FunctionException(String specifier, String[] parts) {
values   = new double[2];
fail(ex.getMessage());
FunctionEvaluationException;
binUpperBounds[binCount -1] = max;
assertEquals(inter.getInf(), Interval.intersection(i1, i2).getInf(), 1.0e-10);
assertEquals(new RationalNumber(3l), a[1]);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
return new UnivariateRealFunction() {
+ cumulativeTestPoints[i], cumulativeTestValues[i], 
if (v != null) {
dv = pv.add(z.multiply(dv));
+ e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j]
this.b4k = b4k;
return (a + b) * .5;
RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);
private double[] emptyObs = {};
double[] x = simplex[i].point;
RealMatrix getRowMatrix(int row) throws MatrixIndexException;
assertEquals(2310, MathUtils.lcm(a, c));
public void testSubtraction() {
maxDegree = 1;
public abstract Polynomial getDerivative();
return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);
new ThreeEighthesIntegrator(0.01).integrate(pb,
Fraction c = new Fraction(5, 3);
public interface ChiSquaredDistribution extends ContinuousDistribution {
so.flush();
this.theoreticalStartCost = theoreticalStartCost;
public CenterDifferenceDerivative(UnivariateRealFunction function, double h) {
if (r.isZero()) {
public void handleStep(double t, double[] y, boolean isLast);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);
double x = 1.234567890;
double[] vertexA, double[] vertexB,
double an = 1.0 / a; // n-th element in the series
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
sampSet.add(samp[j]);
double q = d / c;
public double[] fill(int length) throws IOException {
double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;
public UnivariateRealSolver newDefaultSolver(UnivariateRealFunction f) {
solver.setFunctionValueAccuracy(newValue);
expected = MatrixUtils.createBigMatrix
solver.setMaximalIterationCount(expected);
throw new IllegalArgumentException("Initial guess is not in search"
steadyStateThreshold, epsilon));
assertEquals(Integer.MAX_VALUE, f.getDenominator());
public MinpackTest(String name) {
m = new BigMatrixImpl(testData);
return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};
double sPar = Math.sqrt(lmPar);
public PolynomialFitterTest(String name) {
assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);
assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);
sumSq.increment(Double.POSITIVE_INFINITY);
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
return sumSq.evaluate(values, begin, length);
private ChiSquaredDistribution distribution;
public void selfAdd(SymetricalMatrix s) {
while (index1 < i * (columns + 1)) {
public static double regularizedGammaP(double a, 
cumulativeTestPoints = null;
assertTrue(r2.begin == r1.begin);
protected double[][] subRows23Cols00 = {{2} , {4}};
bracket = UnivariateRealSolverUtils.bracket(
String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
lastStep = (i == (nbStep - 1));
getNumeratorFormat().format(num, toAppendTo, pos);
StatUtils.min(ra.getElements()),
fail("expecting IllegalArgumentException for getPercentile(0)");
data = new BigDecimal[nRows][nCols];
return copy;
fail( "Trying to discard a negative number of element is not allowed");
(354216.0 + 94326.0 * sqrt6) / 112847.0,
return (ssto - getSumSquaredErrors()) / ssto;
public void testNextIntExtremeValues() {
public int getWindowSize() {
private boolean firstTime = true;
this.a = new double[i + 1];
public void testPutTransformer(){
value += d[nearest];    // fork up
Fraction b = new Fraction(2, 3);
public static double chiSquare(long[][] counts) 
Complex H = null;
TestSuite suite = new TestSuite(BrentSolverTest.class);
assertEquals(expected, actual, 1.0e-5);
public class EulerStepInterpolatorTest
case 1 :
public VectorialValuedPair samplePointAt(int i)
public NumberFormat getWholeFormat() {
a = new RationalNumber[] { a0, a1 };
this.relativeAccuracy = defaultRelativeAccuracy;
coeffs0 = new double[degree + 1];
public double evaluate(final double[] values,final int begin, final int length) {
assertNotNull(ce.getCause());
super(argument,
RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);
SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();    
return( vitalStats );
(i, j, -1.3);
for (int col = row+1; col < n; col++) {
private double[][] qr;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);
Math.pow(getProbabilityOfSuccess(), x) *
assertClose("m-n = m + -n",m.subtract(m2),
public ArrayMapperEntry(ArraySliceMappable object, int offset) {
assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));
for (int i = 0; i<largeSampleSize; i++) {
AdaptiveStepsizeIntegrator integ =
omega[i] = new Complex(
identity,entryTolerance);
double tmp3 = (i <= 7) ? tmp1 : tmp2;
Double.isNaN(u.getStandardDeviation()));
public String toString() {
new UniformRandomGenerator(rg));
return new TTestImpl();
return expansionFactor;
private Complex nanInf = new Complex(nan, inf);
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
for (int i = 0; i < sorted.length-1; i++) {
ret = format( (Complex)obj, toAppendTo, pos);
new BigMatrixImpl(new String[][] {});
false);
"bad significance level: " + alpha);
private boolean isBiasCorrected = true;
3101.60039334535, 3.48263016573496), false);
Object nextValue = values.next();
public abstract Object clone();
private AbstractCurveFitter.FitMeasurement[] measurements;
super(pattern, arguments, cause);
TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);
if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {
double expandedCost = evaluateNewSimplex(original, khi);
assertEquals(-(N >> 1), result[2], tolerance);
public abstract Polynomial negate();
public abstract FirstOrderIntegrator newGillIntegrator(double step);
SymetricalMatrix m2 = new SymetricalMatrix(m1);
protected AbstractIntegerDistribution() {
double tolS;
public ComputableFunctionSamplerTest(String name) {
Integer.toString(4)
sum += parameters[i].getEstimate();
assertEquals("a string pct",0.0,f.getPct(aString),tolerance);
double relTolerance = 1.0e-8;
getNumberOfSuccesses(), x + 1);
private static final long serialVersionUID = -3345024435978721931L;
currentState  = new double[dimension];
double residual = wm.getResidual();
cm.setInterpolatedTime(time);
Complex z = new Complex(0.0, 4);
decomp[col][col] += Math.sqrt(sum);
private ComputableFunction function;
private void findBinomialLimits() {
double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };
DescriptiveStatistics factory = null;
dp.value(x - knots[index]), dSpline.value(x), tolerance);
double factor = inv * work[permutations[i] * columns + k];
private double sumYY = 0d;
private static final long serialVersionUID = 7531357987468317564L;
assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));
"IllegalAccessException in Transformation: "
public static final BigDecimal[][] asBigDecimal(double [][] data) {
assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);
obj = new Long(((Integer) v).longValue());
if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
suite.addTest(org.spaceroots.mantissa.functions.vectorial.AllTests.suite()); 
findFactorialLimits();
int callsWithDenseOutput = pb2.getCalls();
Math.abs(expected * solver.getRelativeAccuracy()));
double convergence,
public DormandPrince54Integrator(double minStep, double maxStep,
int[] n24 = { 2, 5, 15, 20 };
public void resetState(double t, double[] y) {
public abstract void setSeed(long seed);  
f.divide(null);
long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};
if (polynoms != null) {
return this.argument;
lmDir[pk] = ypk;
for (int a = 1; a < 100; ++a) {
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
int nSum = this.getColumnDimension();
public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {
private double[] v4;
throw new IllegalArgumentException(
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
MathUtils.round(1.234f, 2, 1923);
q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
if (function == null) {
public final double[] point;
public DistributionFactoryImpl() {
public void testConstructorString(){
checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(3l, 4l)),
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
private int oPoMn2;
factory = (DescriptiveStatistics) dc.newInstance(
public WeightedMeasurement(double weight, double measuredValue,
public double[] inversetransform(
double[] nY = next.y;
return getSlopeStdErr() *
private double getNextDigest() {
new RationalNumber(k, kP1));
for (int i = 0; i < stages; ++i) {
assertEquals("slope conf interval half-width", 0.0270713794287, 
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {
out.writeDouble(interpolatedTime);
public class Rotation implements Serializable {
private static final long serialVersionUID = 1L;
double[] d = new double[] {1, 3, 2, 4};
this.costAccuracy = costAccuracy;
distribution.probability(densityTestPoints[i]), tolerance);
FitMeasurement curr = (FitMeasurement) measurements.get(0);
return (RationalNumber[]) a.clone();
public final class MatrixUtilsTest extends TestCase {
protected void verifyInterval(double lower, double upper) throws
public double[] getValues() {
q1 = 0.5 * Math.sqrt(s + 1.0);
double largest = 0d;
resetTables(mu + 4);
public class UnivariateRealSolverFactoryImpl extends UnivariateRealSolverFactory {
testSolve(m2, "Solving matrix m2");
public int getStateDimension() {
Number ret = null;
double nextT = currentT + h;
assertClose("inverse multiply",m.preMultiply(mInv),
private int findSample(Object[] u, Object[] samp) {
double step  = Math.pow(2.0, -(i + 1));
checkMatrix(m, new BilinearPattern(2.5, 0.025));
public double[] getMax() {
private ArrayList parameters;
double v2z    = alpha * v1z + beta * v2.getZ();
assertTrue(Math.abs(pair.getY() + 0.1 * i) < 1.0e-10);
public class Patient {
public static Locale[] getAvailableLocales() {
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
fail ("expecting ArithmeticException");
public void testVectorOnePair() {
private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);
assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 2.0) < 1.0e-10);
this(degree,
min        = (double[]) x.clone();
m = new BigMatrixImpl(id);
public double[] getNewtonCoefficients() {
double[] sample2)
l1.selfAdd(l2);
protected double[][] subRow3 = {{4,5,6,7}};
double[] d = new double[]{1, 2, 3};
jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };
covariance,
double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;
57.156235665862923517,
return (pairedTTest(sample1, sample2) < alpha);
ComplexUtils.log(null); 
- eta * (v1[i]
double[] test4 = null;
Math.atan2(z.getImaginary(), z.getReal()));        
double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
private int dimension;
public static FractionFormat getProperInstance() {
public void setHeartRate(Double heartrate) {
assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);
double denominator = d * q + c;
if (index < n) {
super(3, estimator);
Complex expected = new Complex(-1.2323, -1.4343);
public void testSetBeta() {
private static final double entryTolerance = 10e-16;
public void testCumulativeProbability2() throws Exception {
Complex result[]; int N = 1 << 8;
protected FirstOrderIntegratorFactory() {
list.add(Double.valueOf(str));
RationalNumber[] a = p.getCoefficients();
upperData[i][j] = new BigDecimal(0);
randomData.setSecureAlgorithm("NOSUCHTHING","SUN");
public void testNextSample() {
public Complex[] transform2(
public ValueServer() {
protected double[] testVector = {1,2,3};
protected void setFinalConditions(double t1) {
assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);
5383344372.34005, 1.88424820499951,
Complex expected, result[];
++calls;
fail("sample not found:{" + samp[0] + "," + samp[1] + "}");
subMatrixData[i - startRow][j - startColumn] = data[i][j];
functions   = new ArrayList();
minpackTest(new WatsonFunction(12, 100.0,
public Frequency(Comparator comparator) {
throw new RuntimeException("internal error");
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);
public void testFormatObject() {
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
public RandomDataImpl(RandomGenerator rand) {
ybar += dy / (double) (n + 1.0);
long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);
private double pi = Math.PI;
return new Min();
return Complex.NaN;
double x[] = { 1.0, 2.0, 2.0, 4.0 };
return new GraggBulirschStoerStepInterpolator(this);
double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;
if (getN() > 0) {
double value, c[], d[], tc, td, divider, w, dist, min_dist;
testSolve(m5, "Solving matrix m5");
("Endpoints do not specify an interval: [" + lower + 
assertEquals("nonsingular test",-3d,m.getDeterminant(),normTolerance);
double kurtosis = Double.NaN;
return jacobian;
int i = 1, j, m = maximalIterationCount + 1;
return new VectorialValuedPair(x, values);
double ti = 4 * tmp2 + temp * tmp4 - tmp3;
public static void assertContains(double[] values, double x,
private static final long serialVersionUID = 8787174276883311692L;
double coefficientOne =
public final Rational quotient;
"Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,
fail("negative mean.  IllegalArgumentException expected");
for (int i = -12; i < -4; ++i) {
minpackTest(new ChebyquadFunction(1, 8, 10.0,
populationSize = size;
int n = 6;
z = new Complex(nan, 4.0);
assertSame(expected.getImaginary(), actual.getImaginary());
protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};
private static final long serialVersionUID = 8589540077390120676L;
(GraggBulirschStoerStepInterpolator interpolator) {
result += sample1[i] - sample2[i];
upperBounds = new double[binCount];
System.out.println("End");
Q[row][col] -= alpha*qr[row][minor];
b.setElement(i, 2, 0.0);
assertEquals("five pct",0,f.getPct(5),tolerance);
+ s.rows + 'x' + s.columns
private double ybar = 0;
public double getNumeratorDegreesOfFreedom() {
public long nextPoisson(double mean) {
assertEquals("total count",0,u.getN(),tolerance);
return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);
int[] n15 = { 4, 6, 8, 10, 12 };
TestUtils.chiSquareTest(expected, observed, .01);
double q = imaginary / real;
public class RealVector {
for (int i = 0; i < 3; i++) {
double[] y0 = new double[2];
if (normProduct == 0) {
if (s.n == 0) {
jacobian[i][j] = 0;
assertEquals(1d, mean.getResult(), 0);
this.parameters = parameters;
public void testParameterAccessors() {
assertTrue(ex.getMessage().indexOf("1.2") > 0);
public PolynomialFunction(double c[]) {
setResult(x, i);
this(null);
if (a.length < p.a.length) {
assertEquals("mean",mean,u.getMean(),tolerance);
n         = y0.length;
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
RealMatrix mRow0 = new RealMatrixImpl(subRow0);
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue(solver.getIterationCount() > 0);
super(function, h);
assertFraction(3, 4, a.divide(b));
checkAngle(r.getAngle(), 2 * Math.PI / 3);
public TestProblem1() {
RationalNumber ckm1   = (RationalNumber) l.get(startKm1);
Complex x = new Complex(3, 4);
private void decompose(RealMatrix covariance, double small)
return new NonNullRange(i, i + 1);
this.step     = step;
0.0, -0.433545502649478, 0.0 };
BigMatrix add(BigMatrix m) throws IllegalArgumentException;
assertEquals( -2.0, f.value( 1.5), tolerance );
assertClose("double, string", m1, m2, Double.MIN_VALUE);
private static final double epsilon = Math.pow(2.0, -52);
public SecondMoment() {
this.denominator = den;
public void testBracketCornerSolution() throws MathException {
this.isBiasCorrected = isBiasCorrected;
for (int j = 1; j < measurements.size (); ++j) {
il.addToSelf(new Interval(30, 55));
assertTrue(x.equals(x));
0.54818229434066, 0.55270466667849
res[1] = -2.0 * x;
public abstract class AbstractRandomGenerator implements RandomGenerator {
assertEquals("total count",4,f.getSumFreq());
assertEquals(48.13516790438953, circle.getY(),      1.0e-10);
percentile.setQuantile(0);
if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {
if (ret != null) {
if (f.p.isZero()) {
da.computeBinStats(min, delta);
double[] tooShortEx = { 1 };
double scalAbsoluteTolerance = 1.0e-8;
g0Positive        = true;
public void testQuinticFunction() throws MathException {
matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);
public class GillIntegrator
unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));
sign = +1;
new RationalNumber(-1l)) {
private double[] tooShortObs = { 1.0 };
private static final long serialVersionUID = -7304282612679254557L;
public NumberTransformer getTransformer() {
public abstract Decomposer newQRDecopmposer();
for (long i = 0; i < n; ++i) {
boolean iev = false;
return new Product();
return testInstance.partial(p);
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));    
for (int j = 0; j < s.getColumns(); ++j) {
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
x.setElement(0, 0,  3.0);
list.remove(0);
assertEquals(3, testDa.getNumElements());
return this.fourthMoment;
randomData.nextHexString(-1);
if (ratio >= 1.0e-4) {
BigInteger uvp = BigInteger.valueOf(numerator)
return;
.getNorm();
for (int i = 3; i < 1001; i++) {
private static final long serialVersionUID = -3922448707008868580L;
result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);
t = y[i] / d;
public void testLimits() {
("Input arrays must not be empty.");
System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          
increasing        = true;
min = new Min();
for (double ratio = 0; ratio < 1.0e-4;) {
9.9,
String expected = "0 / 1";
this.begin    = begin;
map = new HashMap();
assertEquals( "intercept", -0.262323073774029,
3.0229153472731,  6.6837535608081, 11.238701655002, 19.676000080623,
p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));
return t1;
-164378671.653535
public MaxIterationsExceededException(int maxIterations) {
distribution.setDegreesOfFreedom(degreesOfFreedom);
m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;
double[] oneSidedP =
fcMean += omega * point.y[0] * cosine - point.y[1] *   sine;
u.addObject("10.3");
f[i] = s1 - s2 * s2 - 1;
+ " + 1211378079007840683070950 x^36"
getNumberOfTrials(), x) *
public PointCostPair[] getMinima() {
Polynomial.Rational d = Tk0g0.add(Tk1g1.add(Tk2g2));
for (int i = 0; i < 7; i++) {
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
extends AbstractStepInterpolator {
assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);
throw new IntegratorException("minimal step size ({0}) reached,"
num = num % den;
assertTrue(sampler.size() == 11);
super(function);
solver.setNumericalZero(numericalZero);
startIndex += i;
assertTrue("r NaN", !Double.isNaN(regression.getR()));
return (internalArray.length);
double min = sampleStats.getMin();
assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);
for (int i=0; i<4; i++) {
public Mean(final FirstMoment m1) {
estimate  = firstEstimate;
20.0124960961895, 6.99887517584575,
if ((rows != u.rows) || (columns != u.columns)) {
19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,
if (isBracketing(min, initial, f)) {
return getIntercept(b1) + b1 * x;
public TestProblem4() {
private double h;
intervals.add(new Interval((Interval) iterator.next()));
return 1.0 - distribution.cumulativeProbability(-t, t);
package org.spaceroots.mantissa;
StatUtils.mean(sample2), StatUtils.variance(sample1),
work[j] = (work[j] - sum) / lmDiag[j];
distribution.inverseCumulativeProbability(-1);
this.end   = end;
Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) }
copy.subtractFromSelf(i);
assertEquals(0, bytes[0]);  
getImaginaryCharacter()) != 0) {
return maxColSum;
private static final long serialVersionUID = -5852615386664158222L;
public static void assertContains(String msg, Complex[] values,
if (r == 0) {
return y0;
assertTrue(Math.abs(d11) > 4.0e-7);
m[1] = new double[3];
x[i] = A - B;
assertEquals(1, MathUtils.gcd( a, -c));
double[] test2 = {1,2,3,4};
public final class DescriptiveStatisticsImplTest extends TestCase {
assertEquals(4.0, z.getImaginary(), 1.0e-5);
private static double b_01 =         104257.0 / 1920240.0;
v = t;
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
double[][][] fk  = new double[sequence.length][][];
if (maxCosine <= orthoTolerance) {
return new TestSuite(SymetricalMatrixTest.class);
double mean = 1.0;
return dev;
q = fa / fc;
+ e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j]
assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);
new UncorrelatedRandomVectorGenerator(mean, standardDeviation,
double norm2 = 0;
int getIterationCount() throws IllegalStateException;
&& (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {
public Polynom(double[]coeffs) {
public void testDiagonal() {
+ " matrix by a "
this((double) a3, (double) a2, (double) a1, (double) a0);
double a     = coefficients[0].getEstimate();
EnhancedSimpsonIntegratorSampler sampler
public void increment(final double d) {
nDevSq = nDev * nDev;
public void test1() {
ScalarSampleStatistics sample = new ScalarSampleStatistics();
return inf;
alpha -= qr[row][col]*qr[row][minor];
public void testSinh() {
public ChebyshevTest(String name) {
public static double tTest(StatisticalSummary sampleStats1,
assertEquals(0.0905214, actual, 10e-4);
ConvergenceException, FunctionEvaluationException {
if (isRootOK(min, max, z)) {
p.setQuantile(75);
double firstEstimate,
public Vector3D subtract(double factor, Vector3D v) {
private static final long serialVersionUID = 4588659344016668813L;
return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,
Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
int j = bCols - 1;
public Hermite(int degree) {
private static double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;
27.88302995d, 68.0230835d, 669.6485619d};
x0 = x1;
public class IntervalsListTest
assertTrue(maxError < 1.0e-6);
public BasicSampledFunctionIterator(SampledFunction function) {
public double transform(Object o) {
v3 = new double[interpolatedState.length];
GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));
int maxIterations) {
public abstract void integrate (FirstOrderDifferentialEquations equations,
public DormandPrince853Integrator(double minStep, double maxStep,
private double standardDeviation = 1;
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-13);
((ResizableDoubleArray)da).getExpansionMode());
q = new Polynomial.Rational(1l);
super(coefficients, estimator);
throws DerivativeException, IntegratorException {
return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;
assertTrue(m2.getColumns() == m1.getColumns());
int value = 0;
SymetricalMatrix s = new SymetricalMatrix(4);
ComplexFormat complexFormat = null;
public void setStandardDeviation(double sd) {
assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));
p = (PolynomialFunction)f;
out.writeDouble(polynoms[k][l]);
Percentile p = new Percentile(90); 
this.maxGrowth = maxGrowth;
double x11 = m[1][1];
5.47722557505166, 0.217310402535861e-4,
((ResizableDoubleArray) da).setNumElements( -3 );
value = trans.transform(o);
private static final double[] c = {
f.clear();
public void testBasicStats() {
public Evaluation evaluate(short s) {
public PolynomialFraction(Polynomial.Rational numerator,
super.tearDown();
problems.add(new APSProblem26(-1.0, 4.0, 0.0));
standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};
this.object = object;
ComplexUtils.log(infNegInf), 10e-12);
public void testUpdateArray() {
private void tstGen(double tolerance)throws Exception {
p.setEstimate(e);
coeff1 = coeff1 / pc2;
+ a74 * yDotK[4][i] + a75 * yDotK[5][i]);
double initial, double lowerBound, double upperBound, 
assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);
q1 = q2;
double[] out = new double[nCols];
return numberOfTrials;
assertEquals(1.4, distribution.getStandardDeviation(), 0);  
Fraction f1 = new Fraction(3, 5);
reduce();
TestUtils.assertSame(Complex.NaN, 
Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),
yMidDots = new double[1 + 2 * sequence.length][];
extends AbstractUnivariateStatistic
return new TestSuite(ThreeEighthesStepInterpolatorTest.class);
public double[] transform2(
private static final double d2 =   87487479700.0 /  32700410799.0;
n     = problem.n;
String name = line.substring(0, n).trim();
public PointCostPair(double[] point, double cost) {
public void setUp() {  
public ComplexFormat() {
SumOfLogs sum = new SumOfLogs();
protected TestProblemAbstract(TestProblemAbstract problem) {
double ret;
if (b < a) {
return mode;
TestSuite suite = new TestSuite(BigMatrixImplTest.class);
if (q.signum() < 0) {
public int inverseCumulativeProbability(final double p) throws MathException{
public void testRegularizedGammaNanPositive() {
assertEquals(1, MathUtils.gcd(-a,  c));
return heartrate;
final double degreesOfFreedom) {
measurements      = new ArrayList();
public void testSubAndCheckErrorMessage() {
verifySequence(min, initial, max);
public static double round(double x, int scale) {
0.0, new double[pb.getDimension()],
public abstract int[] makeCumulativeTestPoints();
-11.5959274272203, 13.2041866926242,
da = null;
circle.addPoint( 45.0,  97.0);
BigMatrixImpl m2 = new BigMatrixImpl(testData2);
public void testConstructor(){
f.addValue(threeL);
291.521868819476, 1.4638501094228), false);
assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);
void setStandardDeviation(double sd);
statistic2.increment(1d);
public static double sumSq(final double[] values) {
expected = (rowSum[row] * colSum[col]) / total;
SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);
return (p.compareTo(BigInteger.ONE) == 0)
public void setCostRelativeTolerance(double costRelativeTolerance) {
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));
return new GeneralMatrix(rows, columns, data);
public void testSinNaN() {
assertTrue(Math.abs(Tk.valueAt(x)) < (1.0 + 1.0e-12));
int intPos = (int) fpos;
BigInteger lcm = BigInteger.ONE;
public MonitoredFunction(UnivariateRealFunction f) {
s1.selfSub(s2);
public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {
vs.computeDistribution();
int[] index = getNatural(n);
private ContinuousDistribution distribution;
if (v.length != means.length) {
return tTest.tTest(mu, sample, alpha);
"p must be between 0 and 1.0 (inclusive)");
assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);   
return numeratorDegreesOfFreedom;
return (i == j) ? 0.5 : 0.0;
return this.geoMean;
public class BinomialDistributionImpl
assertNull(ex.getCause());
public static double homoscedasticTTest(StatisticalSummary sampleStats1,
computeLUFactorization(epsilon);
HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);
double sigma = distribution.getStandardDeviation();
l.setElement(3, 3, 0.0);
this.a2   = a2;
private VectorialValuedPair current;
public static byte indicator(final byte x) {
return function;
this(l, 1l);
double[] singletonArray = new double[] {1d};
StringBuffer sb = new StringBuffer();
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
x.setElement(2, 0, -1.0);
new GeneralMatrix(2, 3).sub(new GeneralMatrix(3, 2));
public double getMaxGrowth() {
evaluations++;
public WeightedMeasurementTest(String name) {
public RationalNumber add(RationalNumber r) {
normalized[i] = generator.nextNormalizedDouble();
setCumulativeTestValues(new double[] {0, 0});
assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);
public void testInverseCumulativeProbabilities() throws Exception {
private double[] factors;
MathUtils.addAndCheck(big, 1);
coeffs[2]);
double n1, double n2)
private static class ExceptionGeneratingFunction
+ " + 58171647881784229843050 x^16"
newIntervals.add(Interval.intersection(local, i));
da.computeStats();
private static final long serialVersionUID = -8837442489133392138L;
MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);
public static int subAndCheck(int x, int y) {
protected double[] testDataRow1 = {1d,2d,3d};
this.stepControl1 = stepControl1;
public double[] valueAt(double x)
assertEquals(5.0, z.abs(), 1.0e-5);
if (!isRectangular(in)) {
private static final long serialVersionUID = -6530173849413811929L;
b.setElement(1, 0, 12.24);
double weight   = measurements[i].getWeight();
this.defaultRelativeAccuracy = 1E-14;
f = f1.subtract(f2);
value = new Integer(i);
double sum    = b[0] * yDotK[0][j];
-158848033.259565,
(-402.0 - 197.0 * sqrt6) / 1000.0, (168.0 + 73.0 * sqrt6) / 375.0},
setResult(t, i);
line.substring(line.lastIndexOf(":") + 1).trim());
this.degreesOfFreedom = degreesOfFreedom;
implements WeibullDistribution, Serializable {
public interface NumberTransformer {
public long nextSecureLong(long lower, long upper) {
public void testNextPoisson() {
protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},
private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};
fail("expecting IllegalArgumentException");
expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));
if (list.size() > windowSize) {
testStatistic.chiSquare(expected,observed) < 20.52); 
double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));
double dy3 = v3y - u3y;
assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));
BufferedReader inputStream = (BufferedReader) in;
for (int k = 0; k < n23.length; ++k) {
a.setElement(1, 1,  -2.0);
p = 2.0 * xm * s;
integrator.setMaximalIterationCount(50);
String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";
public Vector3D subtract(Vector3D v) {
Fraction f1 = new Fraction(1,32768*3);
return determinant;
distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));
public Interval() {
new double[] { 25.0, 5.0, -5.0, -1.0 },
|| ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
data[index] -= s.data[index];
u.addValue( i + 2 );
ScalarValuedPair pair = iter.nextSamplePoint();
double t = i + 1;
if (index + 1 > numElements) {
t.addValue(2d);
assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.003));
return multiply(r.doubleValue());
public VitalStats() {
System.arraycopy(interpolator.yDotK[k], 0,
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
long[] observed1 = {10, -1, 12, 10, 15};
assertTrue("empty value set should return NaN",
assertEquals(1.235, MathUtils.round(x, 3), 0.0);
return (this.getColumnDimension() == this.getRowDimension());
protected TestUtils() {
public void handleStep(StepInterpolator interpolator, boolean isLast)
StatisticalSummary getSampleStats() throws IllegalStateException;
protected int                  m;
return getImproperInstance().format(f);
private MappableScalar scalar3;
extends RungeKuttaStepInterpolator {
throw new EstimationException("unable to guess a first estimate");
public void testLargeValues() {
double inverse  = 1 / Math.sqrt(x * x + z * z);
public Double add(Double p) {
equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);
private Frequency f = null;
curr = (FitMeasurement) measurements.get(j);
problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));
min  = x;
throw new MatrixIndexException
BigDecimal d[][] = new BigDecimal[data.length][data[0].length];
setFinalConditions(1.0);
protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();
for (int i = 1; i < simplex.length; ++i) {
0.979430303349865, 1.20569696650135
public void testNexFail() {
1212.0,
(n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));
this.arguments = new Object[0];
String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";
s.append(pString);
"sample must contain at least {0} points" },
GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);
private Complex oneInf = new Complex(1, inf);
Math.atan2(v1.getX(), v1.getZ()),
if (state.getEventTime() > first.getEventTime()) {
BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
public void testResetAbsoluteAccuracy(){
-4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},
setDistribution(new TDistributionImpl(1d));
return x / Math.exp(1 / (x * x));
Matrix m2 = m1.mul(2.5);
return out;
0.997754216442807, 1.06737350671578
sum += data[row][i] * v[i];
hex = "0" + hex;
public void testSolve()
double   p0X = p0.x;
int[] perm = randomData.nextPermutation(1,1);
double x3 = parameters[2].getEstimate();
if (lu == null) {
if (lowerElements == 0 && upperElements == 0) {
public Rational(RationalNumber c, int degree) {
protected Sum stat;
return coefficients[1].getEstimate();
(k == 0) ? yMidDots[0] : diagonal[k-1],
testStatistic.t(0d, oneSidedPStats),1E-10);
index[rank] = index[swap[rank]];
circle.addPoint(110.0, -20.0);
properFormat.setNumeratorFormat(nf);
System.arraycopy( internalArray, startIndex, elementArray, 0,
boolean firstIteration = true;
this.x = a1 * u1.x + a2 * u2.x;
double scalAbsoluteTolerance,
new LinearMeasurement(new double[] { 1.0, 3.0 },
public boolean chiSquareTest(double[] expected, long[] observed, 
v = -v;
for (int j = rank + 1; j < i; ++j) {
url = getClass().getResource("testData.txt");
public static final int MULTIPLICATIVE_MODE = 0;
public double getSum() {
tmp4 = ti;
uRef.getZ() * q1 - uRef.getX() * q3,
public double value(double z) throws FunctionEvaluationException {
this.polynomials = new PolynomialFunction[n];
d[j] = (c[j + 1] - c[j]) / (3d * h[j]);
double cumulativeProbability(double x0, double x1) throws MathException;
double v2 = 0;
variance = new Variance(isBiasCorrected);
return randomData.nextGaussian
1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0
double maxCosine = 0;
this.step   = step;
return evenPermutations ? d : -d;
double[] mean = new double[dimension];
minIndices[i] = n;
public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(
regression.predict(1), 10E-12);
NonNullRange r = NonNullRange.reunion(getRangeForRow(i),
b.setPropertyName(name);
protected void reinitialize(double[] y, boolean forward) {
public APSProblem20(int n, double a, double b, double expectedRoot) {
public boolean isSquare() {
integ.setStepHandler(new KeplerStepHandler(pb));
this.generator = null;
if (rows != a.length) {
HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0,
bound    = parameter.bound;
private static final long serialVersionUID = 3371996034561221313L;
BigMatrix m5 = new BigMatrixImpl(d5);
private Map certifiedValues;
new Polynomial.Rational(denominator));
private static class Circle implements EstimationProblem {
public void testRandomAccess()
public double[] fit()
denominator = Math.sqrt(B * B - delta);
assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);     
public void testNextLongExtremeValues() {
scale = vecAbsoluteTolerance;
public double value(double x) {
StatUtils.variance(x, 0, 4);
if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {
sum = sum + (lanczos[i] / (x + i));
jdkSupportsNesting = false;
double dx = (x2 - x1);
threshold = 0.002 / (1 + n);
m2,entryTolerance); 
scalRelativeTolerance);
private Complex negInfNegInf = new Complex(negInf, negInf);
public void testMinpackBard()
if (c.compare(v, freqTable.lastKey()) >= 0) {
double expected = (j <= i) ? pattern.value(i, j) : 0.0;
new CorrelatedRandomVectorGenerator(mean,
(new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});
distribution.setMean(2d);
package org.apache.commons.math.fraction;
for (int i = k; i < cols; ++i) {
if (k != jMax) {
equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);
ib.intersectSelf(i2);
this.coeffs = coeffs;
result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);
protected int[] getPermutation() {
double[] scale;
assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);
Throwable.class.getDeclaredMethod("getCause", new Class[0]);
context.doubleValue(left) * context.doubleValue(right)
cumulativeTestValues = null;
scalAbsoluteTolerance,
return ZERO; // normalize zero.
double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));
String name = "property";
assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);
SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);
assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));
extends Externalizable {
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
empiricalDistribution = new EmpiricalDistributionImpl(1001);
public class Frequency implements Serializable {
private void testLogGamma(double expected, double x) {
2.d * Math.PI };
if (a.length == 1) {
public void testNaNContracts() {
assertEquals("1 2 / 3", actual);
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);
for (int i = -12; i < -2; ++i) {
assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);     
this.randomGenerator = randomGenerator;
1.2277994232462e-5, 6.1695393904409e-6, 4.1198585298293e-6,
public double getInterceptStdErr() {
RotationOrder[] EulerOrders = {
for (int i = 0; i < correlated.length; ++i) {
public double getOmega() {
assertEquals( "Geometric mean not expected", 5.755931, 
public void testPowZero() {
b.setElement(1, 1, 1.0 + epsilon);
PolynomialFunctionNewtonForm p;
a.setElement(0, 1, 1.0);
suite.setName("MathUtils Tests");
MatrixUtils.createBigMatrix(testData));
double h2 = next.getX()    - current.getX();
public void addValue(double v)  {
StatUtils.variance(values) == 0);
u.addValue(twoF);
class FFPIterator
w = negInfNegInf.multiply(oneNaN);
public UnivariateRealSolverFactoryImpl() {
b = res.remainder;
public void setX(double x) {
new Fraction(1, Integer.MIN_VALUE);
TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
fail("null is not a valid descriptive statistics class");
assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);
u.addObject(new Bar());
RandomDataImpl rd = new RandomDataImpl();
int m = matrix.getColumnDimension();
private void testRegularizedGamma(double expected, double a, double x) {
p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));
public void subtractFromSelf(Interval i) {
ret = getMean() - getStandardDeviation();
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
double d[][] = new double[data.length][data[0].length];
assertTrue(bos.size () < 120500);
Vector3D v = new Vector3D(-4, 2, 2);
(Double.toString(x))
for (int i = 0; i < densityTestPoints.length; i++) {
+ k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j]
private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
public static Object serializeAndRecover(Object o){
public void testParseNan() {
return new SwitchingFunction[0];
eDA.getElements(),
return numeratorFormat;
public class GaussLegendreIntegratorTest
private final SampledFunction function;
hNew = optimalStep[optimalIter];
public NumberFormat getRealFormat() {
hNew = hInt;
boolean good = true;
public MappableArray(int dimension) {
checkMatrix(m2, new BilinearPattern(1.0, 0.01));
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
double scaling_coefficient = 1.0 / Math.sqrt(n);
asDouble(mInv.operate(asBigDecimal(testVector))),
SummaryStatistics s = null;
return covariance;
assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));
return q0;
TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     
p2 = new Polynomial.Rational(2l, 3l, -1l);
assertEquals(30.01f,  MathUtils.round(30.005f, 2), 0.0f);
for (int i=0;i<ncols;i++) {
public RationalNumber multiply(BigInteger l) {
new Interval(50, 60)
double[][] data = decompMatrix.getData();
if (d > 1) {
public void testFormatNumber() {
for (int i = 0; i < points.length; ++i) {
values = new double[] { one };
return new Sum();      
private Complex infInf = new Complex(inf, inf);
public static final RotationOrder ZYZ =
checkPolynomial(p2, "5.0 x");
String actual = ComplexFormat.formatComplex(c); 
b = Math.min(b + 1.0, upperBound);
assertEquals("chi-square p-value", 0.002512096, testStatistic.chiSquareTest(expected1, observed1), 1E-9);
protected double imaginary;
jacobian[i][j] = 1;
double scaling_coefficient = 1.0 / f.length;
checkPolynomial(new Hermite(5), "120 x - 160 x^3 + 32 x^5");
sum += jacobian[index] * residuals[i];
if (! newCoeff.isInteger()) {
3.489539, 26.12448, 20.09024, 17.53455,
double[] expected1 = { 485, 541, 82, 61, 37 };
integrator.integrate(pb,
ret = false;
double dy2 = v2y - u2.getY();
private ArrayList binStats = null;
float nextFloat();
assertTrue(mapper.getDataArray().length == 3);
if (numberOfSuccesses > populationSize) {
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
return (a.length == 2) && a[0].isZero() && a[1].isOne();
return new ProperFractionFormat(f);
Object[] arguments = { new Integer(6), new Integer(4) };
public class MaxIterationsExceededException extends ConvergenceException {
public double value(double x) throws MathException {
double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };
public void testAsin() {
TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);
coeff[k][l] = 1.0 / (ratio * ratio - 1.0);
public ResizableDoubleArrayTest(String name) {
f.multiply(null);
assertTrue(realNaN.equals(complexNaN));
for (int i = 0; i < random.length; ++i) {
public void testKepler()
private double[][] m1 = {{1}};
assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);
public interface StatisticalSummary {
this.mu = mu;
double q3q3  = q3 * q3;
public abstract class AbstractCurveFitter
public void testNan() {
public Evaluation evaluate(int i) {
fail("Expecting NumberFormatException");
assertEquals(0d, max.getResult(), 0);
public void testNoSetOutsideOfUpperTriangle() {
new LinearMeasurement(new double[] { 1.0, -1.0 },
setResult(s, i);
protected ThirdMoment moment = null;
assertEquals(w.imaginary, 1, 0);
public static final RotationOrder YXZ =
assertTrue(maxError < 0.003);
private void setFunction(UnivariateRealFunction function) {
getPropertyName()))
throw new RuntimeException(ex);   // should never happen
DefaultValue(Number n) {
BigMatrix lower =new BigMatrixImpl(lowerData);
dv = Complex.ZERO;
if (t > 0) {
public Double getX() {
assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));
pv = coefficients[j].add(z.multiply(pv));
return m1;
public boolean equals(Object other) {
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);
suite.setName("ValueServer Tests");
Complex z = Complex.NaN.conjugate();
int ip5 = i + 5;
q1 = inv * (ort[1][2] - ort[2][1]);
F = C.subtract(D.multiply(Complex.I));
public IntegratorException(String specifier, String[] parts) {
sum2 = x * x;
assertTrue(l2 instanceof LowerTriangularMatrix);
this.absoluteAccuracy = defaultAbsoluteAccuracy;
if (o instanceof Number || o instanceof String) {
return measuredValue;
public HarmonicFitter(int maxIterations, double convergence,
statistic.hashCode(), statistic2.hashCode());
throw new ParseException("Unparseable complex number: \"" + source +
assertEquals(0.5, first.doubleValue(), 0.0);
Random randomizer = new Random(64925784252l);
"Standard Deviation of n = 0 set should be NaN",
public void testParseNegativeReal() {
return factory.newDefaultSolver(f).solve(x0, x1);
out[row] = data[row][col];
return new ThreeEighthesStepInterpolator(this);
!hex.equals(randomData.nextSecureHexString(40)));
if (f.value(min) == 0.0) { return min; }
public void writeExternal(ObjectOutput out)
public long getCount(long v) {
long[] tooShortObs = { 0 };
double c[] = { 2.0 };
sum.increment(-2d);
"the expansion factor.  This would lead to a never " +
StatUtils.geometricMean(test), Double.MIN_VALUE);
assertEquals(2, c.getDenominator());
private final long n;
0.40105813754155, 0.51615351875793, 0.53952222690842,
LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *
mean              = new double[dimension];
assertEquals("one count", 3 ,  f.getCount("one"));
assertEquals(null, expected, actual, delta);
return new ChiSquaredDistributionImpl(5.0);
assertEquals(6.0, p[5].getEstimate(), 1.0e-10);
protected void setDistribution(IntegerDistribution distribution) {
super(buildMessage(pattern, arguments, Locale.US));
checkMatrix(l2, new BilinearPattern(1.0, 0.01));
s.append('^');
return binStats;
for (boolean loop = true; loop; ) {
return 2 * Math.acos(-q0);
public void setOrthoTolerance(double orthoTolerance) {
return "12.0";
while ((i > 0) && (a[i] == 0)) {
public ThreeEighthesIntegrator(double step) {
assertNotNull(cf);
double tmp2 = Math.exp(tmp1);
true, false, 1, true, false, 1, false,
Object obj = v;
String actual = complexFormatJ.format(c); 
polynomials[index].value(x - knots[index]), spline.value(x), tolerance);
"We just inserted 1024 rolling elements, num elements should still be 6",
TestSuite suite = new TestSuite("org.spaceroots.mantissa.linalg"); 
double[] y = (double[]) y0.clone();
long[] observed3 = {10, 0, 12, 10, 15};
assertClose("inverse multiply",mInv.preMultiply(m),
result = result * 31 + MathUtils.hash(getSum());
fail("arguments too short, IllegalArgumentException expected");
o,
assertEquals(N >> 1, result[2], tolerance);
return result < n ? result : n - 1;
void increment(double d);
ret = -getMean() * Math.log(1.0 - p);
integ.setStepHandler(new StepNormalizer(range / 10.5,
double corr10 = o[1][0] - m[1][0];
yb = yb * b + coeffs[i] / (i + 1);
SwitchState state = (SwitchState) iter.next();
assertTrue(handler.getLastError() < 2.0e-7);
f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);
newA[i] = a[i] - p.a[i];
u.setWindowSize(1234);
public void setUp() { 
return (x >= 0L) ? 1L : -1L;
+ coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
regression.addData(data[i][1], data[i][0]);
super(false, c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);
addValue(new Long(v));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
assertTrue(sin.value(result[0]) < 0);
freqTable = new TreeMap(comparator);
kurt = (coefficientOne * accum3) - termTwo;
jacobian[k * cols + pk] = diagR[pk];
if (c < (1.0e-10 * u1u1 * u3u3)) {
private double   step;
this.propertyGetter = "get" + string.substring(0,1).toUpperCase() + string.substring(1);
double dt3 = time - tMin;
this.yMidDots = yMidDots;
pb    = null;
protected void verifyBracketing(double lower, double upper, 
int[] n16 = { 4, 6, 8, 10, 12 };
l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)).subtract(ckm1.multiply(b4k)));
private int nbSteps;
1.05262639322589
long nextLong();
public class TestUtils {
p = new PolynomialFunctionLagrangeForm(x, y);
TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);
Math.atan2(-(v1.getZ()), v1.getX()),
if (mean <= 0) {
u.addValue(1.0);
if (im < 0.0) {
if (curElt > maxElt) {
new EstimatedParameter("p3", 0),
public double getB(int n, double x) {
f1 = new Fraction(2, 7);
double[] roots23 = {
long halfSampleSize = smallSampleSize / 2; 
f1 = new Fraction(1,32768*3);
public TestProblem3(double e) {
return (chiSquareTest(counts) < alpha);
assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);
private static final short PS = (short)1;
decomp[row][col] = sum/decomp[col][col]; 
this.weight        = weight;
assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),
assertEquals(3, da.getElement(1), 0);
setResult(initial, 0);
u.getVariance(), Double.MIN_VALUE);
public void testReciprocal() {
String hex = Integer.toHexString(c.intValue() + 128);
public BinomialDistributionTest(String name) {
public void testLinearFunction() throws MathException {
private static final double e1_01 =         116092271.0 / 8848465920.0;
double lower = sorted[intPos - 1];
protected void setErrorScale(double[] errorScale) {
return number;
while (s >=1 ) { 
private double inf = Double.POSITIVE_INFINITY;
assertTrue(m instanceof LowerTriangularMatrix);
public void setNumberOfSuccesses(int num) {
return value.shortValue();
fail("solving a liniar equitation with a missing matrix should fail"); 
throw new InvalidMatrixException("matrix is singular");
return fittedCoefficients;
return new TDistributionImpl(5.0);
private static final double[] v = {
olds = 0;
for (int k = 0; k < kMax; ++k) {
maxColSum = Math.max(maxColSum, sum);
RealMatrix copy();
v1 = (double[]) interpolator.v1.clone();
throw new MatrixIndexException("illegal row argument");
suite.setName("SumLog Tests");
long bits = Double.doubleToLongBits(value);
currentDegree = 0;
return 0;  // v is comparable, but less than first value
double   x01 = parameters[0].getEstimate();
suite.addTest(IntervalTest.suite());
public void setInterpolationControl(boolean useInterpolationError,
TestSuite suite= new TestSuite("org.spaceroots.mantissa"); 
function = new SinFunction();
UnivariateRealSolver solver = new NewtonSolver(f);
double s = u.getStandardDeviation();
return next < function.size();
public void testRemoveTransformer(){
return b;
public void testNextDigestFail() throws Exception {
for (int k = 0; k < n19.length; ++k) {
public HelicalValleyFunction(double[] startParams,
starts    = 1;
assertEquals(6, coefficients.length);
double r = 1;
int numberOfSuccesses, int sampleSize);
double[] grad             = new double[parameters.length];
public MinTest(String name) {
0.5 * m);
throw new FunctionException("boom");
public abstract boolean isIdentity();
assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));
private static final long serialVersionUID = 8223009086481006892L;
throw new NotARotationMatrixException("the closest orthogonal matrix"
public GeneralSquareMatrix buildMatrix(int order,
Mean m = new Mean(m4);
q2 = coeff * axis.getY();
private static final long serialVersionUID = -628275471717968182L;
void setMaximalIterationCount(int count);
for (int i = 0; i < sa.length; ++i) {
ComplexUtils.polar2Complex(nan, nan));     
8.06225774829855, 6.70820393249937), false);
public FractionFormat(NumberFormat numeratorFormat,
assertTrue(bos.size () < 701000);
coefficients   = new EstimatedParameter[n];
Matrix d2 = d1.duplicate();
TestUtils.assertEquals(new Complex(inf, pi / 2),
double y[] = { 0.0, 0.5, 0.0 };
assertEquals(4d, testDa.getElement(2), 0);   
return (Math.abs(real) * Math.sqrt(1 + q*q));
.21743961811521264320e-3,
GeneralMatrix m = new GeneralMatrix(3, 4);
Matrix transposed = d.getTranspose();
public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver,
DynaProperty[] props = new DynaProperty[] {
public void testDimensionCheck() {
Number re = parseNumber(source, getRealFormat(), pos);
assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), 
protected GeometricMean geoMean = null;
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);
jMax   = i;
private double[] zDDot;
public PoissonDistributionImpl(double p) {
derivative = f.derivative();
for (int i = 0; i < inverse.getRows(); ++i) {
outBuffer.append("Value \t Freq. \t Pct. \t Cum Pct. \n");
assertSame(expected.getReal(), actual.getReal());
first       = null;
public class TrapezoidIntegrator
tmp = lu[max][i];
ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
if (permutations == null) {
Double.POSITIVE_INFINITY, 1.0e-6 * step);
verifyDataSet(f);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
double val = 0.0d;
return parameters;
private static class APSProblem25 extends TestProblem {
double theoreticalStartCost,
check(new Interval(-10.0, 10.0), new Interval(-10.0, 10.0), 0.0,
checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 3l, 2l),
double time = pT + (k * (cT - pT)) / 20;
a = buildProblem2().a;
assertEquals(0.0, c[0], tolerance);
public double[] preMultiply(double[] v) throws IllegalArgumentException {
return new TestSuite(ArrayMapperTest.class);
RealMatrixImpl pdMatrix = 
public void testLogGammaNegative() {
return populationSize;
0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,
public NonNullRangeTest(String name) {
asDouble(m.solve(asBigDecimal(testVector))),
fail("wrong exception caught");
public void testSimpleWithDecimalsTrunc() {
line = in.readLine();
return (new BigDecimal
new GeneralMatrix(0, 2);
return new PolynomialFraction((Polynomial.Rational) p.negate(), q);
for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {
s.selfAddWAAt(2.0, a4);
assertEquals(39.25,MathUtils.round(xx, 2), 0.0);
"Mean of n = 0 set should be NaN",
protected NonNullRange getRangeForRow(int i) {
public static BigMatrix createRowBigMatrix(double[] rowData) {
if ((rows != s.rows) || (columns != s.columns)) {
assertEquals(arguments.length, ex.getArguments().length);
for (int j = 0; j < residual.getColumns(); ++j) {
assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
theta += pi /12;
specialValues = new double[] {1d, 1d, Double.NaN, 
VectorialCovariance covStat = new VectorialCovariance(vertices[0].length);
public void testConstructorPatternArguments(){
assertTrue(Math.abs(sampler.samplePointAt(12).y[0] + 1.0) < 1.0e-10);
randomData = new RandomDataImpl(testGenerator);
public static ComplexFormat getInstance(Locale locale) {
public class NelderMead
double tmp =
void setProbabilityOfSuccess(double p);
testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);
return contractionCriteria;
int temp = permutation[max];
"maximal number of evaluations exceeded ({0})" },
double[][] r = ret.getDataRef();
public void setWindowSize(int windowSize) {
private URL valuesFileURL = null;
+ " - 3391858621221953912598660 x^34"
while ((index <= iMax)
if (reflectedCost <= expandedCost) {
+ m[1].getResidual() * m[1].getPartial(p[1]));
assertTrue(Math.abs(scalar1.getValue() - 0.0) < 1.0e-10);
m.subtract(new RealMatrixImpl(testData2));
d *= (x[i] - x[j]);
return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
s.selfAddWAAt(3.0, a3);
qr = matrix.getData();
f += n * n / (d * d * d);
-tmp2,
ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);
assertEquals(0, MathUtils.log(0, 10), 0);
return (PointCostPair[]) minima.clone();
return (inf <= x) && (x <= sup);
implements UnivariateRealFunction {
protected double[][] rowMatrix = {{1,2,3}};
setFinalConditions(20.0);
assertEquals(4, testDa.getInternalLength());  // 0,x,x,x
SecondMoment moment = (SecondMoment) getUnivariateStatistic();
if (n == 0) {
-10.2718482369638,      9.07411364383733,
fail("insufficient data, IllegalArgumentException expected");
Vector3D v1 = new Vector3D(1, 2, 3);
integrator.integrate(1, -1);
var = 0.0;
protected synchronized void expand() {
assertEquals(10.4, sample.getMax(), 1.0e-12);
for (int i = 0; i < 10000; ++i) {
lower = new LowerTriangularMatrix(rows, lowerData);
super(translate(message), cause);
s.append(' ');
return new TestSuite(VectorialCovarianceTest.class);
assertTrue(handler.getMaximalError() < 5.0e-6);
double[][] m = new double[3][];
y[1] = (sin >= 0) ? cos : -cos;
double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };
tmp4 *= tmp4;
("bad value for maximumIterations: " + maximumIterations);
return new ComplexFormat(f);
public abstract double[] makeCumulativeTestValues();
res.append(data[i][j]);
double fac1 = 0.5 * j * (j - 1);
if (object instanceof SummaryStatistics == false) {
this.starts    = starts;
private static final long serialVersionUID = 7318440192750283659L;
protected AbstractCurveFitter(EstimatedParameter[] coefficients,
int index = i;
f = new Fraction(50, 75);
protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();
res = Polynomial.Rational.euclidianDivision(a, b);
if false, the check will be skipped
public class RandomAdaptor extends Random implements RandomGenerator {
0.78513038704d,  0.99716023388d, 0.999999998077 };
for (int j = 0; j < m1.getColumns(); ++j) {
public class PolynomialRationalTest
implements Distribution, Serializable {
return valueAt(x);
this(new RationalNumber(a1), new RationalNumber(a0));
private static double k14_13 =             -4149.0 / 500000.0;
+ eta * v4[i])));
protected DirectSearchOptimizer() {
private double denominatorDegreesOfFreedom;
Arrays.fill(a, 0, degree, RationalNumber.ZERO);
public void tearDown() {
public FDistributionImpl(double numeratorDegreesOfFreedom,
this.b         = b;
public Variance() {
ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);
solver.setMaximalIterationCount(newValue);
public Osborne1Function(double[] startParams,
double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);
char ret = 0;
previous = current;
cf.setImaginaryCharacter("");
implements ContinuousDistribution, Serializable {
x1 = xm;
public double getZ() {
Complex x = new Complex(1, 1);
double temp = (i + 1) / 5.0;
BigMatrix m2 = new BigMatrixImpl(testDataString);
assertTrue(Double.isNaN(max.getResult()));
result += ((Long) iterator.next()).longValue();
private static final long serialVersionUID = -8113110433795298072L;
currentState      = null;
int oMn2 = oMn * oMn;
assertEquals("4x3 R size", qr.getR().getColumnDimension(), 3);
assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), 
public String getImaginaryCharacter() {
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];
public final void finalizeStep()
return tTest.t(mu, sampleStats);
private double sumSq = 18;
n = list.size();
assertEquals(p.getDegree(), 2);
assertEquals(4.0, p[3].getEstimate(), 1.0e-10);
2018918.04462367, 0.217310402539845e-4,
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
assertEquals(5d, testDa.getElement(2), 0);   
fail("Expecting IllegalArgumentException - double 0's");
assertTrue(Math.abs(d12) < 6.0e-6);
private final double q2;
return nextIndex < measurements.length;
new PolynomialFunction(new double[] {2d, 1d, 1d}),
assertEquals(1, product.getResult(), 0);
jacobian[i] = new double[] {
yDotK     = null;
double actualCdf1 = dist.upperCumulativeProbability(x);
public void setMaxGrowth(double maxGrowth) {
minJ = Math.min(minJ, range.begin);
2815.43839161816, 292.954288244866,
new RationalNumber(a0));
Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);
s = (SummaryStatistics) u;
fail( "Setting number of elements to negative should've thrown an exception");
res.append("}");
distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]), 
21,
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
if (x < 0 || x > getNumberOfTrials()) {
y[2] = -sinE / (1 - e * cosE);
double d[] = new double[data.length];
assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);
for (int l = 1; l < e.length; ++l) {
public Double(double a3, double a2, double a1, double a0) {
if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {
assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
public interface ConvergenceChecker {
DefaultValue(long l) {
out[i] = data[i][col];
public static void assertEquals(double expected, double actual, double delta) {
for (int i = 0; i < n; ++i)
m = new BigMatrixImpl(luData);
double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };
pb2.getFinalTime(), new double[pb2.getDimension()]);
public void testTransformObject(){
a.setElement(0, 3,   4.0);
double maxStep = pb.getFinalTime() - pb.getInitialTime();
setSingleStart();
"org.apache.commons.math.analysis.FirstOrderIntegratorFactoryImpl");
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double t = Math.abs(t(m1, m2, v1, v2, n1, n2));
l.add(a11);
public double[] operate(double[] v) throws IllegalArgumentException {
this.resultComputed = false;
public void testSmallSamples() {
public void testSingleton() {
triangularMatrix.multiply(triangularMatrix.transpose());
columns = m.columns;
public TrapezoidIntegratorSampler(SampledFunctionIterator iter)
fHigh  = fb;
assertTrue(minStep < 8.2e-3);
public void testNewBrentSolverValid() {
double h1 = (maxInv2 < 1.0e-15)
setTemperature( temperature );
public ThreeEighthesStepInterpolatorTest(String name) {
grad[j] = measurements[i].getPartial(parameters[j]);
private class PointModel extends WeightedMeasurement {
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
public abstract boolean isOne();
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);
throws DerivativeException, IntegratorException,
double integrate(double min, double max) throws ConvergenceException, 
public static boolean isPowerOf2(long n) {
- ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2])
if (simplex[i].cost > pointCostPair.cost) {
assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());
checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(3l, 4l)),
DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,
public double getPartial(EstimatedParameter parameter) {
dx2 * dy3 - dy2 * dx3);
assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);
public void testSetSubMatrix() throws Exception {
public TTestTest(String name) {
protected int windowSize = DescriptiveStatistics.INFINITE_WINDOW;
xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));
protected void sortMeasurements() {
assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);
< 0.04);
double[] interpolatedY = cm.getInterpolatedState ();
implements IntegerDistribution, Serializable {
assertTrue(Math.abs(sampler.samplePointAt(10).x    - 0.990) < 1.0e-10);
verifyDensities();
throw new IllegalArgumentException(msg);
b2 = new DomainObject(4);
b3 = new DomainObject(2);
for (int k=i+1; k<x.length; k++) 
return tTest.t(sample1, sample2);
assertEquals(3.0f, testDa.getContractionCriteria(), 0);
public static DecompositionFactory newInstance(){
public class HypergeometricDistributionImpl extends AbstractIntegerDistribution
sum -= lu[row][i] * lu[i][col];
private void loadStats(String resource, Object u) throws Exception {
assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);
return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);
eye = MatrixUtils.createRealIdentityMatrix(4);
this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());
int nCol = this.getColumnDimension();
private LinearProblem buildProblem2()
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
return bracket( function, initial, lowerBound, upperBound,
public abstract class ContinuedFraction implements Serializable {
if (test(values, begin, length)) {
int iterationCount = 0;
if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
public void testIncreasingTolerance()
public class BisectionSolver extends UnivariateRealSolverImpl {
sumYY += dy * dy * (double) n / (double) (n + 1.0);
Complex B = z[i].add(A);
private DifferentiableUnivariateRealFunction function;
f[j+k] = f[j+k].add(z);
regression.addData(infData2);
p1 = new EstimatedParameter("p1", 1.0);
double x[] =
f = new Frequency();
assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);
private void setSingleStart() {
assertTrue(val > 0 && val < 4);
public ProductTest(String name) {
public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {
assertEquals("significance", 4.596e-07,
private double[] b;
byte[] randomBytes = new byte[(len / 2) + 1];
checkPolynomial(new Chebyshev(1), "x");
public byte byteValue(Evaluation argument) throws EvaluationException {
summaries.clear();
assertEquals(-47, f.getNumerator());
data[indexU] = factor * a[j];
public class TransformerMap implements NumberTransformer, Serializable {
public void testMax() {
double[][] outData = new double[nRows][nCols];
x2 = xm; y2 = ym;
for (int i = 0; i < errfac.length; ++i) {
double actualCdf = dist.cumulativeProbability(x);
testStatistic.tTest(sampleStats1, sampleStats2, 0.2));
StatUtils.percentile(x, .25);
for (j = n-i; j > 0; j--) {
public static float round(float x, int scale, int roundingMethod) {
return Math.exp(
calls = problem.calls;
fail("zero length requested -- expecting IllegalArgumentException");
checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(2l, 5l)),
assertEquals("chi-square p-value", 0.0462835770603,
assertTrue("variance should be zero (n = 1)", 
private void determineLMDirection(double[] qy, double[] diag,
return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };
public void computeBinStats(double min, double delta)
double[] out = new double[y.length];
double y = coeffs[coeffs.length - 1];
RealMatrix mRows20Cols123 = new RealMatrixImpl(subRows20Cols123);
obs1 = (double) observed1[i];
public void printStackTrace(PrintWriter out) {
public void testInvert() {
checkValue(f, "3/2");
double actualPdf = dist.probability(x);
public class MeanTest extends StorelessUnivariateStatisticAbstractTest{
double min, max, result[], tolerance = 1E-12; int N = 9;
copy.intersectSelf(i2);
private static double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;
public NotPositiveDefiniteMatrixException() {
assertTrue(Math.abs(b3.getElement(1) - 0.5) < 1.0e-10);
protected void setDensityTestValues(double[] densityTestValues) {
p = (Polynomial.Rational) p.negate();
int bytesOut = 0;
RealMatrix covariance = covStat.getResult();
if ((targetIter > 1)
public abstract class Matrix
m.add(m2);
determineLMParameter(oldRes, delta, diag, work1, work2, work3);
public class UniformRandomGeneratorTest
class ThreeEighthesStepInterpolator
outBuffer.append(nf.format(getPct(value)));
circle.addPoint(points[i][0], points[i][1]);
private TestProblemAbstract problem;
return '.';
u.getStandardDeviation() == 0.0);
this.testInstance = testInstance;
Complex expected = new Complex(1.2323, -1.4343);
public class TTestImpl implements TTest  {
int maxIterations) 
return distribution;
public String getName();
var = evaluate(values, m, begin, length);
double[] y = { Double.NaN };
public class ComplexUtilsTest extends TestCase {
public class EnhancedSimpsonIntegratorSampler
double absAi = Math.abs(a[i]);
"The min element should be 1.0",
+ " + 5929294332103310025 x^8"
s = t[i][i];
public void setQuantile(final double p) {
f[i] = parameters[i].getEstimate() - t;
sum.increment(Double.POSITIVE_INFINITY);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;
public ClassicalRungeKuttaIntegratorTest(String name) {
this.standardDeviation = (double[]) standardDeviation.clone();
private Complex infNegInf = new Complex(inf, negInf);
Polynomial.Rational Pk2 = (Polynomial.Rational) Pk1.getDerivative();
if ((dot < -threshold) || (dot > threshold)) {
public int getDegree() {
++index1;
String outMsg = "outer message";
FourthMoment m4 = new FourthMoment();
return "org/apache/commons/math/stat/data/Lottery.txt";
entryTolerance);
factory.newSecantSolver(null);
private void checkUnsolvableProblem(Estimator estimator,
assertEquals(6, da.getElement(2), 0);   
ret = (m * (b - m) * x) /
return chiSquareTest.chiSquareTest(expected, observed);
testStatistic.tTest(sample1, tooShortObs, .01);
setFinalConditions(2 * t0 - t1);
if (d != null) {
public static double solve(UnivariateRealFunction f, double x0, double x1)
protected String getResourceName() {
return multiply(1 / s);
public void testIteration()
public int[] getMinIndices() {
+ " below diagonal of a"
checkValue(p.getEstimate(), 0.0);
UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); 
protected void assertClose(String msg, double[] m, double[] n,
fi.close();
fail("zero mean -- expecting IllegalArgumentException");
double[] test1 = {5,4,3,2,1};
public PolynomialFunction polynomialDerivative() {
BigDecimal getDeterminant() throws InvalidMatrixException;
!TestUtils.tTest(sampleStats1, sampleStats2, 0.1));
throw new IllegalArgumentException("degrees of freedom must be positive.");
return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, 
public double inverseCumulativeProbability(double p) {
+ " - 265365894974690562152100 x^38"
return (double[]) max.clone();
public class SymetricalMatrixTest
E = t + d;
double[] nullArray = null;
public class TTestTest extends TestCase {
assertEquals("freq sum, empty table", 0, f.getSumFreq());
assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);
assertTrue(Double.isNaN(z.abs()));
throws ConvergenceException, FunctionEvaluationException {
while ((t & 1) == 0) { // while t is even..
9,
m = new RealMatrixImpl(bigSingular); // singular
public void testDeterminant() {
for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {
11.8,
return new Fraction(-numerator, denominator);
p = (Polynomial.Rational) p.multiply(lcm);
"-2/3");
f.addValue(new Long(1));
public GeneralSquareMatrix(GeneralSquareMatrix s) {
"nombre maximal d''\u00e9valuations d\u00e9pass\u00e9 ({0})" },
x[0] = 0.5 * (f[0] + f[N]);
if (firstTime) {
assertEquals(1.5, coefficients[1], tolerance);
setTolerance(1E-4);
public void testSetElementAndSymetricalElement() {
mean =
count = 0;
public void testLocalMaximumForward() {
assertEquals("3x3 nonsingular Q'Q = I", 0, norm, normTolerance);
StatUtils.sumLog(x);
b[i][rank] = e;
throw new IllegalArgumentException("length cannot be negative");
public APSProblem27(int n, double a, double b, double expectedRoot) {
x1 = x3; x2 = x;
switch (roundingMethod) {
q3 = 0.0;
public void testRegularizedBetaPositiveNanPositive() {
++j;
return (homoscedasticTTest(sample1, sample2) < alpha);
public static DerivativeOperatorFactory newInstance() {
NonNullRange range = getRangeForColumn(i);
assertTrue(nbSteps < 150);
MathConfigurationException ex = new MathConfigurationException();
protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};
checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(2l, 3l)),
for (int j = 0; j < cols; ++j) {
new InputStreamReader(
if (o1 == null) {
-1477884375.0 / 485066827.0},
public class NelderMeadTest
public class ChiSquareFactoryTest extends ChiSquareTestTest {
u = DescriptiveStatistics.newInstance(ListUnivariateImpl.class);
RealMatrix m4 = new RealMatrixImpl(d4);
assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 0.990) < 1.0e-10);
y1 = y; y2 = y3;
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);
StatUtils.sumSq(x, 0, 4);
double c = x[1] - 2 * x[2];
double actual = Gamma.logGamma(x);
ratio         = yDot0[j] / scale[j];
dz1 * dx3 - dx1 * dz3,
public ArrayMapperTest(String name) {
testDecompose(m2, "Decomposing matrix m2");
new Complex(0.1, 0.0),
public abstract boolean isZero();
double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();
m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +
fail ("expecting IllegalArgumentException");
TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);
double a[] = { 4.0, 3.0, 2.0 };
if (theoreticalStartCost > 20.0) {
assertEquals(expected, actual, 0);
double d12 = m2[1][2] - m3[1][2];
return (Math.abs(u) + Math.abs(v));
return map.put(key, transformer);
"begin + length > values.length");
public void testTransformDouble() throws Exception {
empiricalDistribution = new EmpiricalDistributionImpl(binCount);
mapper.manageMappable(b3);
assertTrue(Math.abs(d10) < 6.0e-6);
20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};
assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));
public double[] getInitialState() {
String expected = "-1 / 2";
double[] newA = new double[highLength];
new RealMatrixImpl(lowerTriangularMatrix);
protected double normTolerance = 10E-14;
UnivariateRealFunction f = new SinFunction();
randomData.nextLong(4,3);
fk[k][0] = yDot0;
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
double getBeta();
for (int i = 0; i < y0.length; ++i) {
TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));
return pendingEventTime;
return tTest(meanDifference, 0, 
assertEquals( 0.0, f.value( 5.0), tolerance );
public void testInterpolateLinearDegenerateTwoSegment()
assertEquals(-13085, f.getNumerator());
resultData[i][j] = e;
public double getA(int n, double x) {
nextColumn = i;
+ i
public static final Complex ONE = new Complex(1.0, 0.0);
case CONSTANT_MODE: return mu;
protected UnivariateRealSolverFactory() {
s.setElement
checkValue(f, "1/2");
class NonNullRange
if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
min = 0.0; max = 2.0 * Math.PI;
if (!isNonNegative(observed1) || !isNonNegative(observed2)) {
Complex subarray[] = new Complex[n-i+1];
if (p == p1) {
double getStandardDeviation();
a = new double[] { value };
NonNullRange range = b.getRangeForRow(i);
return propertyName;
Complex actual = (Complex)complexFormat.parseObject(source); 
assertClose("inverse^2",m,m.inverse().inverse(),10E-12);
assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);
assertEquals(nf, properFormat.getDenominatorFormat());
if (needUpdate) {
public class StepProblem
double convergent = (double)p2 / (double)q2;
assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);
A = q * (y2 - (1 + q) * y1 + q * y0);
return sumsq.getResult();
if ((i + 1) < minima.length) {
protected BigMatrix getLUMatrix() throws InvalidMatrixException {
MathUtils.factorial(21);
jacobian[index] = lmDir[j];
ret = -1;
all.add(points[i]);
q2 = inv * (ort[0][1] + ort[1][0]);
fillBinStats(in);
MathUtils.equals(stat.getMax(), this.getMax()) && 
getUpperDomain(m, k)
TestUtils.assertEquals(Complex.ZERO, 
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
return getResiduals()[index];
return tTest.pairedT(sample1, sample2);
var = (accum - (accum2 * accum2 / len)) / len;
public Complex[] inversetransform2(
index += columns;
protected double[]             theoreticalMinParams;
public Polynomial negate() {
assertEquals(MathUtils.binomialCoefficient(34,17),
public DivisionResult(Rational quotient, Rational remainder) {
"Variance of n = 1 set should be zero",
double[] y, double[][] yDotK, boolean forward) {
testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);
BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix
this.maxOrder = 18;
v[1][i] = h * yDotK[0][i] - v[0][i];
int numberOfTrials, double probabilityOfSuccess);
+ m.rows + 'x' + m.columns
for (int i = begin; i < begin + length; i++) {
out[i] = getNext();
RationalNumber[] a = newQ.getCoefficients();
this.z = z;
return new TestSuite(BasicSampledFunctionIteratorTest.class);
assertEquals(0, new Polynomial.Rational(0l, 0l, 5l).getDegree());
System.arraycopy(knots, 0, out, 0, n + 1);
return new Vector3D(-inverse * z, 0, inverse * x);
stat.increment(points[i]);
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
assertEquals(2, p.getDegree());
StatUtils.product(x, 0, 4);
double d13 = tMax - tMin;
return -0.859;
public void testNonInversible() throws EstimationException {
"14/3");
public Double(double c, int degree) {
return 1 - distribution.cumulativeProbability(chiSquare(counts));
optimalStep[k]     = Math.abs(filterStep(h * fac, true));
for (int i = 0; i < testArray.length; i++) {
assertEquals(-2.0, z.getImaginary(), 1.0e-5);
assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());
return Math.sqrt(variance.evaluate(values));
double soMt      = s * (1 - theta);
assertEquals(m, m1);
lastTime = nextTime;
public void testPaired() throws Exception {
protected BigDecimal[][] bigRowMatrix = 
private long binomialCoefficient(int n, int k) {
for (int k = 0; k < problems.length; ++k) {
private void checkValue(double value, double expected) {
new EstimatedParameter("p0", 0)
public abstract class AdaptiveStepsizeIntegrator
private static final long serialVersionUID = 1460986908574398008L;  
MathUtils.binomialCoefficientLog(n, k),10E-12);
return new double[] {0.03468084d ,0.09370091d, 0.1433137d,
assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
if (a.length != c.length + 1) {
for (int iter = 0; iter < maxIter; ++iter) {
v1.setBiasCorrected(false);
private static final long serialVersionUID = 3750401068561053681L;
assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);
throw new IllegalStateException("distribution not loaded");
assertTrue(nbSteps < 400);
return new double[] {
double b = z.getImaginary();
private static final long serialVersionUID = -794133890636181115L;
solver2.resetRelativeAccuracy();
assertTrue(Double.isNaN(product.getResult()));
sum = sum.add(data[i][col].multiply(v[i]));
new GeneralSquareMatrix(0);
map.removeTransformer(TransformerMapTest.class);
for (int i = 0; i < u.getRows(); ++i) {
Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) }
intervals.add(i2);
this.scalAbsoluteTolerance = 0;
double e = inverse * c[ii][ir];
double v = 0;
max = s.max;
Complex G = null;
bp[i][j] -= bp[col][j] * lu[i][col];
Complex y = new Complex(5.0, 6.0);
stat.increment(smallSamples[i][j]);
public void testAdaptor() {
return internalArray.length;
"  Endpoints: [" + min + "," + max + "]" + 
public DormandPrince853StepInterpolator() {
public EvaluationException(String message) {
private double partial(EstimatedParameter p) {
public MultiDirectional(double khi, double gamma) {
(new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});
double[] work1   = new double[cols];
inf = a;
checkValue(new RationalNumber(307692l, 999999l), "4/13");
private void checkValue(RationalNumber f, String reference) {
assertEquals(4, da.getNumElements());
this(getDefaultNumberFormat());
TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);
if (mu >= 0) {
value = defaultTransformer.transform(o);
return delta;
Complex expected = new Complex(1.44831, 0.158997);
public Variance(boolean isBiasCorrected, SecondMoment m2) {
regression.getSlopeConfidenceInterval(),1E-8);
Object obj1 = null;
return (NumberTransformer) map.get(key);
long[] observed = new long[16];
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||
currentTime      = t;
checkSolve(p, result);
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
boolean b3, boolean b4, int i2,
public void setSeed(long seed) {
sumLog.increment(value);
|| (Math.abs(previous - current) > (current * steadyStateThreshold)
assertEquals("4x3 Q size", qr.getQ().getRowDimension(), 4);
assertEquals(0, new Polynomial.Double(5.0).getDegree());
assertEquals(1, c.getDenominator());
return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);
return new FourthMoment();
public class WeightedMeasurementTest
boolean stop = false;
Object object = new Object();
optimalIter = k - 1;
PolynomialFraction product =
public void testQRColumnsPermutation() throws EstimationException {
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
fail("0 mean supplied -- IllegalArgumentException expected");
!hex.equals(randomData.nextSecureHexString(40))); 
boolean flag = false;
public PolynomialFitter(PolynomialCoefficient[] coefficients,
public double getBeta() {
+ polynoms[3][i] * oneMinusTheta));
sumXY += dx * dy * (double) n / (double) (n + 1.0);
assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);
public static final class Bar {
("sample size must be > 0");
assertEquals(big, MathUtils.addAndCheck(big, 0));
(stats.getMean(),stats.getStandardDeviation());
assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);
randomData.reSeedSecure(1000);
return (x >= ZS) ? PS : NS;
if ((empiricalDistribution == null) ||
private double omega2;
setInitialCapacity(initialCapacity);
assertTrue(stack2.indexOf("MathConfigurationException") != -1);
public static final Fraction ONE = new Fraction(1, 1);
qr = new QRDecompositionImpl(matrix);
return 8;
new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },
WeightedMeasurement[] wm = problem.getMeasurements();
new EstimatedParameter("p3", 2),
private RandomAdaptor() { }
private static final double e7 =     -1.0 / 40.0;
super(15, buildArray(3, x0), theoreticalStartCost,
checkValue(new PolynomialFraction(1l, -2l), "-1/2");
0.257819926636811, 0.257829976764542
assertClose("identity multiply",identity.preMultiply(mInv),
testStatistic.t(mu, sampleStats), 10E-10);
public void setBeta(double beta) {
Polynomial.Rational Tk0 = new Chebyshev(k);
public RationalNumber divide(RationalNumber r) {
x+=0.25;
assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);
n          = 0;
pendingEvent      = false;
exp = -1.0 / getOrder();
Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),
return (SquareMatrix) solve((Matrix) b, epsilon);
0.0,
if (expansionMode != MULTIPLICATIVE_MODE && 
assertTrue(bos.size () > 700000);
public double evaluate(double x, double epsilon) throws MathException {
return Math.min(
MathUtils.binomialCoefficientDouble(4,5);
this.rows    = rows;
protected double[] y0;
protected long n = 0;
public void testInverseCumulativeProbabilityExtremes() throws Exception {
assertTrue(m instanceof DiagonalMatrix);
return polynomialSplineDerivative();
if (parsePosition.getIndex() == 0) {
1.0 / 2.0
protected double[] testArray = {0, 1, 2, 3, 4, 5};
this.wholeFormat = format;
return unscaled;
public abstract class ContinuousDistributionAbstractTest extends TestCase {
public void testBoundaries()
assertEquals("percentile " + i,
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
extends SquareMatrix {
z = w.divide(w);
h = switchesHandler.getEventTime() - currentT;
String expected = "1 + 1i";
assertEquals(2, p.getRowDimension());
assertEquals("total count",0,f.getSumFreq());
stats.addValue(empiricalDistribution2.getNextValue());
String source = "10";
int nCols = subMatrix[0].length;
first = state;
points  = new ArrayList();
testDecompose(m6, "Decomposing matrix m6");
assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
public Rational(RationalNumber[] a) {
public void testTransformers(){
assertEquals(0, new Polynomial.Rational(0l, 0l).getDegree());
return new TestSuite(UpperTriangularMatrixTest.class);
int nextInt();
double[] emptyArray = new double[] {};
fail("wrong exception type caught: " + e.getClass().getName());
out.writeDouble(yDotK[k][i]);
Polynomial.Rational Hk1g1 = Hk1.multiply(g1);
f = f1.divide(f2);
"the closest orthogonal matrix has a negative determinant {0}" },
return min;
System.arraycopy(yTmp, 0, y, 0, y0.length);
double getDeterminant();
if (n <= 0) {
private double nan = Double.NaN;
public void testSubMatrix() {
den = -den;
+ " lead to convergence",
if (i > 1) {
public double chiSquareTest(long[][] counts)
error2        += ratio2 * ratio2;
private NormalDistribution normal;
sum2 += s * s;
public static UnivariateRealFunction backwardDifferenceDerivative(UnivariateRealFunction function, double delta) {
double[] x = asDouble(m.operate(asBigDecimal(testVector)));
NonNullRange r1 = new NonNullRange(-4, 8);
mean[i] = sum[i] / n;
add(points[i]);
double accum = 0.0;
public int[] makeInverseCumulativeTestValues() {
min[i]        = x[i];
Matrix m2 = m1.getTranspose();
public double transform(final Object o) throws MathException {
checkPolynomial(p, "3/4 - 1/6 x + 2/5 x^2");
improperFormat.setNumeratorFormat(nf);
assertEquals("mean", mean, u.getMean(), tolerance);
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);
this.moment = m3;
protected Min min = null;
return MatrixFactory.buildMatrix(columns, rows, resultData,
double halfStep = step / 2.0;
double[] single = {1.0};
for (int i = n - 1; i  > 0; i--) {
public ThirdMoment() {
RandomGenerator ran = getRan();
int nRows = this.getRowDimension();
if (num == Integer.MIN_VALUE ||
assertTrue(Math.abs(pair.x    - 0.1 * i) < 1.0e-10);
public void testGcd() {
return calls;
good = false;
double[] result = new double[n - 1];
denominator = dplus.abs() > dminus.abs() ? dplus : dminus;
return new Complex(r * Math.cos(theta), r * Math.sin(theta));
public CorrelatedRandomVectorGenerator(double[] mean,
return (double) getCumFreq(v) / (double) getSumFreq();        
new EstimatedParameter[] { p[0], p[1] },
assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);
2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0
public void addValue(char v) {
double[] a = p.getCoefficients();
public float floatValue(Evaluation argument) throws EvaluationException {
public ChiSquareTestImpl(ChiSquaredDistribution x) {
public MathException(String msg) {
sampleStats2.getVariance(), (double) sampleStats1.getN(), 
even.add(points[i]);
double v1x   = coeff * v1.getX();
data[indexL] = data[indexU];
u.addValue(twoL);
this.pattern   = null;
public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)
public void testTwoSets() throws EstimationException {
this.handler = handler;
MathUtils.equals(stat.getSum(), this.getSum()) &&
return getPct(new Long(v));       
public double g(double t, double[] y) {
testStatistic.tTest(0d, oneSidedPStats, 95);
protected double getMaximumAbsoluteError() {
list[i] = temp;
.15808870322491248884e-3,
for (int k = 0; k <= currentDegree; ++k) {
new BigMatrixImpl(testData2);
p1.setEstimate(oldP1);
c[j] = tc * w;
outBuffer.append(nf.format(getCumPct(value)));
private double y;
double[] out = new double[coefficients.length];
private final double q3;
b += ((Math.abs(d) > tolS) ? d : (xm > 0.0 ? tolS : -tolS));
a     = Math.sqrt(c1 / c2);
double p = fd.cumulativeProbability(.999);
assertNotNull(s);
private NormalizedRandomGenerator generator;
m.setSubMatrix(detData2,1,1);
float sign = indicator(x);
if (parameter == parameters[j]) {
private static double b_12 =         137909.0 / 3084480.0;
1,  2,  3,  4,  5,  6,  7,  8,  9,  10,
DiagonalMatrix d = new DiagonalMatrix(4);
for (int i = 0; i < special.length; ++i) {
double[] roots19 = {
in.defaultReadObject();
public void setInterpolatedTime(double time)
work[++index1] -= factor * work[++index2];
public static final int UNIFORM_MODE = 2;
minimalIterationCount = defaultMinimalIterationCount;
this.maxCostEval = maxCostEval;
Matrix m3 = m1.mul(m2);
double[][] testData3x3NonSingular = { 
u.clear();
public static double geometricMean(final double[] values) {
public class ExhaustedSampleException
double[] out = new double[v.length];
"result too large to represent in a long integer");
IntervalsList il =
assertFalse(testStatistic.test(testArray, 0, 0));
public class MonitoredFunction implements UnivariateRealFunction {
StatUtils.sum(values, 2, 2),
minStep   = Math.abs(step);
return evaluate(x, DEFAULT_EPSILON, maxIterations);
public PascalDistributionImpl(int r, double p) {
private double exp;
public ExponentialDistributionImpl(double mean) {
public void testUpdateObjects() {
return 7;
s[i] = f.value(min + i * h);
for (int i=0;i<smallSampleSize;i++) {
HashSet sampSet = new HashSet();
double tmp = x + g + .5;
tstDoubleGen(0.1);
xNormSqr += qr[row][minor]*qr[row][minor];
assertEquals(2.1, distribution.getMean(), 0);
solver.solve(1, -1);
public Evaluation evaluate(double d) {
assertEquals("max",max,u.getMax(),tolerance);
new Complex(-1.10502525316942, -4.88492424049175),
double[] getRow(int row) throws MatrixIndexException;
A = 0.5 * (f[i] + f[N-i]);
this.data    = (data == null) ? null : (double[]) data.clone();
if (n > 2) {
assertTrue(sampler.getDimension() == 2);
D = f[i+2].subtract(f[i+3]);
return new GeneralMatrix(this);
protected Mean mean = null;
td.cumulativeProbability(.01);
private final double z;
RationalNumber r = (RationalNumber) o;
double step =  (current.x - previous.x);
double expected = 1.0;
double[][] data = new double[1][nCols];
String inMsg = "inner message";
protected Complex[] fft(Complex data[]) throws MathException,
a.setElement(2, 3,   8.0);
h = getMinStep();
setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, 
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),
outBuffer.append("DescriptiveStatistics:\n");
throw new ArithmeticException
rescale(y, y, scale);
Math.atan2(v2.getZ(), -v2.getY())
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
public void checkLegendre(Legendre p, long denominator, String reference) {
p2 = (a1 * p1) + p0;
double   x5 = parameters[4].getEstimate();
double d = x[0] - x[3];
protected int defaultMaximalIterationCount;
assertEquals(1, f.getCallsCount());
suite.addTest(MappableScalarTest.suite());
(StorelessUnivariateStatistic) getUnivariateStatistic();
assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    
u.addObject("14.2");
public void testVectorTwoPairs() {
return new BigMatrixImpl(lu);
public FirstOrderIntegrator newEulerIntegrator(double step) {
densityTestValues = makeDensityTestValues();
protected SumOfSquares sumsq = null;
"-1/12");
accum2 += dev;
public class CostException
for (Iterator iter = domainObjects.iterator(); iter.hasNext();) {
FirstOrderIntegrator integ = new GillIntegrator(0.3);
suite.setName("EmpiricalDistribution Tests");
std.increment(1d);
Fraction c = improperFormat.parse(source);
private double minStep;
return 2d * (1.0 - distribution.cumulativeProbability(
(-4521408.0 + 1137963.0 * sqrt6) / 2937500.0,
double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};
return 2.0 * x * Math.exp(-n) - 2.0 *Math.exp(-n * x) + 1.0;
public void test4() {
value -= data[index1] * resultData[index2];
return scaleArray(fft(f, true), scaling_coefficient);
public void testMinpackLinearRank1ZeroColsAndRows()
assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);
val < vs.getMu() + 100*vs.getSigma());
protected RealMatrix getIdentity(int dimension) {
public void testPrintStackTrace() {
assertEquals(neginf, z.conjugate().imaginary, 0);
throw new ArrayIndexOutOfBoundsException("cannot separately set"
public void testSqrtRealPositive() {
public abstract TTest createTTest();
super.setUp();
prod *= parameters[k].getEstimate();
protected double evaluateCost(double[] x)
Math.atan2(v2.getY(), v2.getZ())
y = new Complex(0.0 + Double.MIN_VALUE, 0.0);
public ChiSquareDistributionTest(String name) {
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
assertEquals( 0.0, f.value( 2.0), tolerance );
- dist.normalApproximateProbability(89);
BigInteger lcm = p.getDenominatorsLCM();
public class MaxIterationsExceededExceptionTest extends TestCase {
j < Math.min(a.length, i + 1);
private static final long serialVersionUID = -6773236347582113490L;
public boolean tTest(double[] sample1, double[] sample2,
std =
assertTrue(function.checkTheoreticalMinParams());
Complex x = new Complex(0.0, 0.0);
this.mode = mode;
double[] a1 = { 2.0, 4.0, 8.0, 16.0 };
private static final double a75 =    11.0 /   84.0;
coeffs0[i] = 2.0 * max * (random.nextDouble() - 0.5);
double [] y = interpolator.getInterpolatedState();
copy.subtractFromSelf(list2);
String msg = "should not be able to parse '10 / a'.";
double getRelativeAccuracy();
m.getRangeForRow(i));
return new Vector3D(inverse * y, -inverse * x, 0);
if (qr[minor][minor] > 0) a = -a;
dev = obs1/weight - obs2 * weight;
16.5302162063499, 0.0,
throw new ArithmeticException(
public Matrix duplicate() {
return a * Math.cos(omega * x + phi);
public interface RandomData {
for (int i = coeffs0.length - 2; i >= 0; --i) {
IOException, ClassNotFoundException {
setInverseCumulativeTestValues(new int[] {2, 2});
private double[] coeffs0;
protected double[][] testDataInv = 
public void add(SwitchingFunction function,
double[] range = new double[2];
result = solver.solve(0.55, 1.45);
public void testDivision() {
for (int k = maxDegree; k < degree; ++k) {
assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   
this.numerator = num;
return scaleArray(F, 0.5);
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(2l, 3l)),
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
6,
String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
if (b.length != nRows) {
return cy.getEstimate();
public abstract Evaluation evaluate(EvaluationContext context)
private static final long serialVersionUID = 1619940313389547244L;
z = 1.0; expected = 4.0; result = p.value(z);
extends ListResourceBundle {
protected int expansionMode = MULTIPLICATIVE_MODE;
for (int j=0; j<nCols;j++) {
("invalid row or column index selection");          
private TestUtils() {
private static final long serialVersionUID = -6587513359895466954L;
v2 = (double[]) interpolator.v2.clone();
while (!foundLimit) {
optimalIter = 2;
RealMatrix a              = new RealMatrixImpl(parameters.length, parameters.length);
private final double coeffJ;
protected double estimateError(double[][] yDotK,
if (isNaN() || rhs.isNaN()) {
public void testIntersection() {
b1.setElement(0,  0.0);
for (int i = 0; i < p.length; i++) {
assertEquals(inf, z.real, 0);
StatUtils.sum(values, 1, 2),
public FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step) {
suite.addTest(DiagonalMatrixTest.suite()); 
root = b;
protected RungeKuttaFehlbergIntegrator(boolean fsal,
for (int i = 0; i < (m - 2); ++i) {
suite.setName("UnivariateRealSolver Tests");
assertTrue(bos.size () < 87000);
Assert.fail(msg + " Unable to find" + x);
double sum;
double fac = stepControl2 / Math.pow(error / stepControl1, exp);
if (! p.isBound()) {
checkMatrix(u1, new BilinearPattern(5, -0.6));
lowLength, newA, lowLength, highLength - lowLength);
public void subtractFromSelf(IntervalsList list) {
productsSums = new double[dimension * (dimension + 1) / 2];
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)
minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },
double x, double epsilon) {
double tmp2 = Math.sqrt(tmpSquare);
public static Complex asin(Complex z) {
x = new double[] {one, two, two, three};
private PointCostPair[] minima;
private double orderControl1;
a0 = a1;
return evaluate(values, start, length, quantile);
yb = yb * b + coeffs1[i] / (i + 1);
d = 1;
sum = new Sum();
("permutation k exceeds n");
Bins are: <br/>
public class DormandPrince54StepInterpolatorTest
fail("zero length -- IllegalArgumentException expected");
private int    u;
MathException ex = new MathException(cause);
TestUtils.checkSerializedEquality(statistic);
moment = new ThirdMoment();
if (currentDegree > 3) {
m [2][1] = 2.0 * (q2q3 - q0q1);
public void testAngularSeparation() {
3.7578103559958e-5, 3.6472865219959e-5, 3.5430783356532e-5,
if (g0Positive ^ (gb >= 0)) {
public TTestFactoryTest(String name) {
printStackTrace(pw);
if (object == this ) {
private static class APSProblem24 extends TestProblem {
+ b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);
assertEquals("sum", sum, StatUtils.sum(values), tolerance);
new EstimatedParameter[] { p[0] },
public class StepNormalizerTest
integ.setStepHandler(handler);
result = result * 31 + MathUtils.hash(getSumsq());
double   secondLargest = simplex[n-1].cost;
private class MinpackMeasurement extends WeightedMeasurement {
BigDecimal getNorm();
EnhancedSimpsonIntegratorSampler sampler =
0.017535837721129,
ret = ret * 31 + nCols;
double delta = x1 - x0;
public static double pairedT(double[] sample1, double[] sample2)
minima[i] = simplex[0];
+ " with negative or null dimension");
public void testSetElementArbitraryExpansion() {
protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };
protected void evaluateSimplex()
- coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]
return (tTest(sampleStats1, sampleStats2) < alpha);
checkVector(r.getAxis(), Vector3D.plusJ);
this(new RationalNumber(a2),
tstGetSortedValues(test3);
res.append("{");
int nextInt(int lower, int upper);
double c = p1 / q1;
public void setStabilityCheck(boolean performTest,
GeneralMatrix m = new GeneralMatrix(rows, columns);
double q2 = a * q1 + b * q0;
double  scaledH    = h * factor;
h = getMaxStep();
LinearMeasurement[] m = new LinearMeasurement[] {
assertEquals(w.real, 4.0, 0);
0.0 },
public double getAbsoluteAccuracy() {
function = null;
NormalizedRandomGenerator generator) {
public static final BigDecimal[] asBigDecimal(double [] data) {
super(11, startParams, theoreticalStartCost,
private static final long serialVersionUID = 5728716329662425188L;  
Vector3D v1 = applyTo(Vector3D.plusK);
public class CorrelatedRandomVectorGenerator
assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));
suite.setName("BivariateRegression Tests");
if (y != y0) {
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
ret = this.isNaN();
throw new DimensionMismatchException(mean.length, order);
public VectorialMean(int dimension) {
setDistribution(new HypergeometricDistributionImpl(5,3,5));
public class MinTest extends StorelessUnivariateStatisticAbstractTest{
assertEquals(0d, mean.getResult(), 0);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public double t(StatisticalSummary sampleStats1, 
public void testChiSquareDataSetsComparisonBadCounts()
out.writeDouble(yDotKLast[2][i]);
if (b1 < 0) {
patientList.add( p1 );
protected void computeCoefficients() {
public static boolean tTest(double mu, StatisticalSummary sampleStats,
root = new RealMatrixImpl(order, rank);
private EstimatedParameter p2;
+ " matrix to a "
private Double x = new Double(1.0);
assertEquals( 1.0, MathUtils.indicator( 0.0 ), delta ) ;
this.scalAbsoluteTolerance = scalAbsoluteTolerance;
double p = Math.exp(-mean);
this.paramsAccuracy = paramsAccuracy;
public void testProduct() {
- theta * (v[1][i]
x = p.x;
integ.integrate(pb,
assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
double x0, x1, x2, x, oldx, y0, y1, y2, y;
assertEquals(0.0, result[N-1].getReal(), tolerance);
Matrix m2 = m1.duplicate();
1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, 
private boolean firstCall = true;
public void testInterpolateLinear() throws Exception {
m = new BigMatrixImpl(testDataMinus);
return new GammaDistributionImpl(alpha, beta);
out.writeDouble(yDotKLast[1][i]);
parity = -parity;
public static double meanDifference(final double[] sample1, final double[] sample2)
errorScale = (double[]) problem.errorScale.clone();
double[][] lowerData = new double[n][n];
for( int i = 0; i < testArray.length; i++) {
TestUtils.chiSquare(tooShortEx, tooShortObs);
for (int j = currentDegree - 1; j > 3; --j) {
new BigMatrixImpl(testData2).solve(bs);
return fft(data, false);
ret = getDegreesOfFreedom() * .5;
assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));
public interface WeibullDistribution extends ContinuousDistribution {
intervals.add(new Interval(a, b));
assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));
++resultIndex;
protected Complex[] fft(double f[], boolean isInverse) throws
distribution.inverseCumulativeProbability(1d - alpha / 2d);
b.setElement(0, 0, 1.0 + epsilon * epsilon);
checkPolynomial(p, "45 - 10 x + 24 x^2");
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
assertEquals("max", max, StatUtils.max(values), tolerance);
TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);
s.setElementAndSymetricalElement(1, 2, 3.4);
991.261822123701), false);
currentState      = (double[]) interpolator.currentState.clone();
double[] pY = previous.y;
checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),
1.366, 1.191, 1.112, 1.013, 0.991,
package org.apache.commons.math.geometry;
for (int k = 0; k < n25.length; ++k) {
extends Polynomial.Rational {
yDotK [i] = new double[y0.length];
0.0147639634910978,   0.146342330145992,
public int getColumnDimension() {
private double pendingEventTime;
Object value = iter.next();
assertEquals(0.0, regression.getSignificance(), 1.0e-5);
for (i = 0; i < N; i += 4) {
suite.addTest(CorrelatedRandomVectorGeneratorTest.suite()); 
return correlated;
public ValueServer(RandomData randomData) {
-Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0) },
this.right = right;
setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});
private double stepControl4;
problems.add(new APSProblem21(n21[k], 0.0, 1.0, roots21[k]));
assertEquals(all.getMax(), even.getMax(), 1.0e-12);
public final class FastSineTransformerTest extends TestCase {
return max.evaluate(values);
if (degree > maxDegree) {
new BigMatrixImpl(bigColMatrix));
class ClassicalRungeKuttaStepInterpolator
public Matrix getTranspose() {
assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);
+ oneMinusTheta * (polynoms[2][i] * theta
implements ExponentialDistribution, Serializable {
TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for " 
BigMatrix mRow3 = new BigMatrixImpl(subRow3);
q2 = inv * k.getY();
double   minStep, double maxStep,
int len = upperBounds.length;
private static class VariableHandler implements StepHandler {
int[] permutation = ((BigMatrixImpl) matrix).getPermutation();
protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};
if (x < 0 || x == Integer.MAX_VALUE) {
double u1z = u1.getZ();
6.9314718055995e-3
assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;
"matrice non d\u00e9finie positive" },
public class EstimationException
checkPolynomial(new Hermite(4), "12 - 48 x^2 + 16 x^4");
public PolynomialFraction add(PolynomialFraction f) {
private static final long serialVersionUID = -486669213837396921L;
q2 = inv * (ort[2][1] + ort[1][2]);
delta = x1 - x0;
public abstract double t(double mu, StatisticalSummary sampleStats)
assertTrue(solver.findRoot(p, new Checker(tol), 1000,
double   x09 = parameters[8].getEstimate();
super(order);
MathUtils.mulAndCheck(denominator/d1, 
double bspl  = yp0 - ydiff;
UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));
public class GammaDistributionTest extends ContinuousDistributionAbstractTest {
for (int i = 5; i < 10; ++i) {
public class CardanEulerSingularityException
diff = sample1[i] - sample2[i];
public abstract FirstOrderIntegrator newMidpointIntegrator(double step);
public static double percentile(final double[] values, final double p) {
secRan.nextBytes(randomBytes);
newA[i] = -a[i];
VectorialCovariance stat = new VectorialCovariance(2);
assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);
Percentile percentile = new Percentile(5);
Math.atan2(-(v1.getX()), v1.getY()),
public double getRoot() {
return cx.getEstimate();
public static boolean tTest(double[] sample1, double[] sample2, double alpha)
public abstract RealMatrix getQ();
12.0),
if (c[ii][ii] > c[isi][isi]) {
private static class APSProblem22 extends TestProblem {
return getPct(new Long(v));         
tc = new double[n];
suite.addTest(IntervalsListTest.suite());
g0Positive = (g0 >= 0);
omega             = Double.NaN;
resultData[resultIndex++] = 0.0;
for (int k = 0; k < rows; ++k) {
double scalAbsoluteTolerance = 6.0e-4;
minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },
sum    += b[l] * yDotK[l][j];
return new MessageFormat(translate(specifier)).format(parts);
0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,
quantile = p;
checkMatrix(l, new BilinearPattern(1.0, 0.1));
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
resultData[resultIndex] = data[resultIndex] - m.data[resultIndex];
newA[i] = 0.0;
public void testSolveBadParameters() throws MathException {
testDecompose(m5, "Decomposing matrix m5");
cf.format(object);
minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,
Vector3D v2 = k.multiply(Math.cos(1.2)).add(i.multiply(Math.sin(1.2)));
checkValue(new RationalNumber(0l, 500l), "0");
new Polynomial.Rational(2l, 10l, 12l)),
inverseCumulativeTestValues = null;   
t.addValue(3d);
RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);
public static String formatFraction(Fraction f) {
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
iev = ! iev;
double obs1 = 0.0d;
protected List list;
Math.atan2(v2.getX(), -v2.getZ())
throws ExhaustedSampleException, FunctionException;
throw new IllegalStateException("No result available");
for (int j = 0; j < samp.length; j++) {
public class ConvergenceException extends MathException {
if (pos >= n) {
public double getLastError() {
" Unable to find " + ComplexFormat.formatComplex(z));
double[] sum = new double[f.getDimension()];
test(values, begin, length);
int n = 5;
private static double k14_06 =                 0.0                       - b_06;
56.0,
jacobian[i][j] = (i + 1) * (j + 1);
if (useInterpolationError) {
1.0e-10),
s1 = new StandardDeviation(false, m);
tb += h;
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
public StatisticalSummary getSummary() {
toAppendTo.append(value);
MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);
double[] bi = bData[i];
setDelta(h);
this.measurements =
double begin, double step, int n) {
double[]   y    =   { 1.0, 3.0, -4.0 };
return -Double.MAX_VALUE;
public BigMatrix add(BigMatrix m) throws IllegalArgumentException {
1.00082107321386,    -2.61773107084722,
protected static void parseAndIgnoreWhitespace(
this.maximalIterationCount = defaultMaximalIterationCount;
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
public float floatValue() {
public ClassicalRungeKuttaIntegrator(double step) {
public abstract AdaptiveStepsizeIntegrator newHighamHall54Integrator(
u.setWindowSize(2);
out.writeDouble(currentState[i]);
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(stringRow),
assertEquals(add.getSup(), ia.getSup(), 1.0e-10);
public double getMu() {
assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);
iterationCount += this.iterationCount;
assertEquals(7.0, x[0].getEstimate(), 1.0e-10);
assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);
testRegularizedGamma(0.632120558828558, 1.0, 1.0);
if (yInitial * yMin < 0) {
assertClose("get row",m.getRow(0),testDataRow1,entryTolerance);
resetDerivatives = true;
for (int i = startRow; i <= endRow; i++) {
return (n * x - 1.0) / ((n - 1) * x);
assertTrue(m instanceof GeneralMatrix);
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
assertEquals("two sample homoscedastic t stat", 0.73096310086, 
public BigMatrixImpl(int rowDimension, int columnDimension) {
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
if ( !isValidCoordinate( 0, col ) ) {
private Beta() {
checkPolynomial(new Hermite(3), "-12 x + 8 x^3");
--bIndex;
public ScalarSampleStatistics() {
fail("Expecting ArithmeticException");
double[] vecAbsoluteTolerance,
public double getNorm() {
accum3 /= Math.pow(stdDev, 4.0d);
return Math.abs(mulAndCheck(a / gcd(a, b), b));
throws MathException
super("not positive definite matrix", new Object[0]);
long[] observed2 = {15, 10, 10, 15, 5};
String source = "(Infinity) + (Infinity)i";
public void testBounds() {
if (interpolator.v1 == null) {
complexFormat = ComplexFormat.getInstance(getLocale());
for (int i = 0; i < a.length; ++i) {
public interface DiscreteDistribution extends Distribution {
setResult(x1, i);
setPopulationSize(populationSize);
if (d1==1) {
checkAngle(angles[1], alpha2);
Matrix b = new GeneralMatrix(3, 1);
if ((Math.abs(xm) < tolS) || (Math.abs(fb) < Double.MIN_VALUE)) {
checkMatrix(new DiagonalMatrix(5, 2.7), 2.7);
return (n == 0) ? 0 : (sum / n);
tmp1 = (x2 >= 0) ? 0.25 : -0.25;
5d * Math.PI / 6d,
if (p.isZero()) {
(Math.abs(y0) <= Math.abs(y1))) {
regression.addData(3, 3);
private double[] v2;
coefficients[0]  = new EstimatedParameter("a", 2.0 * Math.PI);
if (numerator==Integer.MIN_VALUE ||
suite.setName("Kurtosis  Tests");
private double m4Det = 18.0d;
super("Maximal number of iterations ({0}) exceeded",
double a, double b, double expectedRoot) {
t.clear();
return standardDeviation;
eDA3.addElement( i );
circle.addPoint( 35.0,  15.0);
public class StatisticalSummaryValues implements Serializable, 
sup = b;
RationalNumber[] newA = new RationalNumber[a.length + p.a.length - 1];
protected DistributionFactory getDistributionFactory() {
throw new IllegalArgumentException("dimension mismatch");
1.2388385788997e-6
public class MessagesResources_fr
perm = randomData.nextPermutation(2,3);
private double sigma;
protected static double TOO_SMALL = 10E-12;
testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);
if (sd <= 0.0) {
while (x0 < x1) {
return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,
final double b, double epsilon, int maxIterations) throws MathException
public SumOfSquares() {
assertEquals(Integer.MIN_VALUE+1, f.getNumerator());
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());
assertFalse(m.equals(null));
TestUtils.tTest(mu, sampleStats), 10E-10);
getUnivariateStatistic().evaluate(testArray),
m1 = new BigMatrixImpl(new String[][] {{"2.00"}});
protected double kurt = 2.377191264804700;
int k = begin + length;
return buf.toString();
double sumLog = Double.NaN;
public synchronized double getElement(int index) {
public static final double[] asDouble(BigDecimal[] data) {
MatrixUtils.createColumnRealMatrix(null);  // null
result = transformer.inversetransform2(x2);
double sqrt = Math.sqrt(c[ir][ir]);
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
double r = random.nextDouble();
return new PoissonDistributionImpl(lambda);
sum = mval[col][col];
ComplexUtils.exp(iPi), 10e-12);
return this.sum;
double termTwo =
assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);
private NumberFormat denominatorFormat;
new PolynomialFunction(new double[] {0d, 1d, 1d}), 
return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.5) < 1.0e-10);
rank = k;
checkLaguerre(new Laguerre(6),  720l,
CostFunction wrong =
protected int findKnot(double[] knots, double x) {
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
transformers.putTransformer(Foo.class, new NumberTransformer() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
this.n      = n;
d12 = (y2 - y1) / (x2 - x1);
"Erreur d''\u00e9valuation pour l''argument {0}" },
public void testMinpackBrownAlmostLinear()
public static short sign(final short x) {
return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);
this.valuesFileURL = new URL(url);
public static Matrix buildMatrix(int rows, int columns, double[] data,
MathUtils.factorialDouble(i),Double.MIN_VALUE);
x21 = o[2][1];
public void setElement(int i, int j, double value) {
double[] y = { 8915.102, 8919.302, 8923.502 };
yTmp[i] = y0[i];
actual = improperFormat.format(c);
return new Complex(Math.log(z.abs()),
Polynomial.Rational Tk2g2 = Tk2.multiply(g2);
case BigDecimal.ROUND_HALF_DOWN : {
return ((Number) result).doubleValue();
private double[] cumulativeTestPoints;
return (Math.exp(x) - Math.exp(-x)) / 2.0;
return Math.asin(z / getNorm());
assertTrue(imaginaryNaN.equals(complexNaN));
double ypk = lmDir[pk] / diagR[pk];
m.getTrace();
? scalRelativeTolerance
assertTrue(Math.abs(result.getElement(i, 1) - (rows - i)) < 1.0e-10);
SymetricalMatrix s = new SymetricalMatrix(5);
double   x10 = parameters[9].getEstimate();
return new EulerIntegrator(step);
public Iterator valuesIterator() {
public class ComplexTest extends TestCase {
protected double[][] singular = { {2d,3d}, {2d,3d} };
verifyInverseCumulativeProbabilities();     
testLogBeta(Double.NaN, Double.NaN, 2.0);
integ.addSwitchingFunction(functions[l],
return Double.longBitsToDouble(sign |
public APSProblem23(int n, double a, double b, double expectedRoot) {
public double getArgument() {
private void checkEquals(Interval[] sa, IntervalsList sb) {
return homoscedasticT(StatUtils.mean(sample1), StatUtils.mean(sample2),
mapper.manageMappable(b2);
double prev   = interpolator.getPreviousTime();
public class MatrixFactory {
Complex expected = new Complex(4.08033, -2.94094);
assertEquals(1.5,f.value(1.5), interpolationTolerance);
a.setElement(3, 0,   0.0);
private double phi;
super("dimension mismatch {0} != {1}",
q2 = (a / b * q1) + q0;
suite.addTest(UncorrelatedRandomVectorGeneratorTest.suite()); 
return i * i + j * j;
assertTrue( "Variance of n = 1 set should be zero", 
int bRows  = b.getRows();
protected double               paramsAccuracy;
public double getInterpolatedTime();
this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;
public short shortValue() {
TestUtils.t(mu, observed), 10E-10);
public class Beta implements Serializable {
int divisorDegree   = divisor.getDegree();
"row and column dimensions must be postive");
public int getNumberOfSuccesses() {
private final String name;
public abstract double t(double mu, double[] observed)
sum2 = s.sum2;
integ.setStepHandler(new VariableStepHandler());
RungeKuttaStepInterpolator prototype,
integ.integrate(pb1,
package org.spaceroots.mantissa.roots;
RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },
double upperBound = getDomainUpperBound(p);
double result = Math.sqrt(getRSquare());
while (iterator.hasNext())  {
return solve(new DiagonalMatrix (columns), epsilon);
return testInstance.theoretical();
setScale(beta);
private static final double e1_08 =     1230164450203.0 / 739113984000.0;
RealMatrix transpose();
return getDenominatorDegreesOfFreedom() /
current   = next;
assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);
return (x == 0) ? 0 : (x > 0) ? 1 : -1;
assertFalse(x == y);
assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);
public void testSquare() {
public class ResizableDoubleArray implements DoubleArray, Serializable {
public MantissaException(String message, Throwable cause) {
NonNullRange r2 = new NonNullRange(3, 12);
new EstimatedParameter("p1", 1)
instance = (SummaryStatistics) dc.newInstance(
protected double[][] subRows00Cols33 = {{4}};
if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {
double scaling_coefficient = 1.0 / Math.sqrt(f.length);
checkValue(p1.getEstimate(), 1.0);
solver.setMaximalIterationCount(1000);
this.y = a1 * u1.y + a2 * u2.y;
for (int i = 1; i < N; i++) {
implements FirstOrderDifferentialEquations, SwitchingFunction {
this.transformer = transformer;
private int denominator;
min.clear();
return Math.exp(x) - 1.0;
assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));
return getCount(new Long(v));
p2 = p2.subtract(p1);
String oneString = (String) one[0];
implements FirstOrderDifferentialEquations, Cloneable {
public MaxTest(String name) {
SecondMoment m = new SecondMoment();
public void testSwitchingFunctions()
assertEquals(result, 0, solver.getAbsoluteAccuracy());
public void testAddAndCheck() {
public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {
public double getSlopeConfidenceInterval() throws MathException {
double[] testArray = {Double.NaN, Double.POSITIVE_INFINITY, 
public FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step) {
public class FunctionEvaluationException extends MathException  {
private RotationOrder(String name,
min = -Math.PI; max = Math.PI;
12.5,
public Rotation(RotationOrder order,
result = solver.solve(0.85, 1.25);
if (a[a.length - 1].isNegative()) {
Fraction c = new Fraction(10, -21);
yDotKLast[2][i] = in.readDouble();
return m2;
private static final double normTolerance = 10e-14;
fail("Expecting MathException - bad abscissas array");
32.0),
double upper = sorted[intPos];
Complex rhs = (Complex)other;
(new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});
protected void verifySequence(double lower, double initial, double upper) {
100000., 100000.);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
String str = null;
return measuredValue - getTheoreticalValue();
final int length, final double p) {
public BigMatrixImpl(BigDecimal[] v) {
public void setNumeratorFormat(NumberFormat format) {
private AbstractCurveFitter.FitMeasurement previous;
coefficients[i] = 0.0;
private int mode = 5;
F[1] = 0.5 * y[0].getReal();
double coefficients[] = new double[4];
measurements = new ArrayList();
double s;
protected double[][] testDataPlusInv = 
PolynomialFunction polynomials[] = new PolynomialFunction[n];
((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));
super(numeratorFormat, denominatorFormat);
public Double(double a2, double a1, double a0) {
public ExponentialDistributionTest(String name) {
double[] testArray = 
int nRows = v.length;
yMidDots[l+1][i] *= h;
RationalNumber[] newA = new RationalNumber[a.length - 1];
f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());
value = d * d;
mapper.updateObjects(data);
dimension  = -1;
Integer input = new Integer(1);
private static final double e1 =     71.0 / 57600.0;
public void shift() {
target = new double[]{y[2], 1d, 0d, 0d};
throw new ArithmeticException("null norm");
+ " lower triangular matrix");
void setAlpha(double alpha);
l1.selfSub(l2);
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
List getBinStats();
double[][] outData = out.getDataRef();
assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));
public RationalNumber divide(long l) {
protected UnivariateRealFunction f;
33.0),
for (int k=0; k<i; k++) 
new Interval( -6.0, -4.0),
for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {
public void testSkewAndKurtosis() {
checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(2l, 3l)),
public int inverseCumulativeProbability(final double p) throws MathException {
omegaCount = n;
private static class LinearProblem implements EstimationProblem {
if (expansionFactor <= 1.0) {
public Rotation() {
public void testEvaluation() throws Exception {   
SquareMatrix a, inverse;
MathException image = (MathException) TestUtils.serializeAndRecover(ex);
sampleStats2.getMean(), sampleStats1.getVariance(),
double minStep        = 0;
7.6685951221853e-6
UpperTriangularMatrix u = buildMatrix(rows, new ElementPattern() {
protected double defaultFunctionValueAccuracy;
double delta = 0.0 ;
z = 4.0; expected = 360.0; result = p.value(z);
return Double.MIN_VALUE * getGamma().getBeta();
double gamma = 0;
protected double[][] subRow0 = {{1,2,3,4}};
default :
assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));
stat.incrementAll(testArray);
" initial=" + initial + " upperBound=" + upperBound);
this.moment = m1;
public MappableArray(double[] array) {
testRegularizedGamma(0.0, 1.0, 0.0);
f[i] = A.add(B);
double relTolerance = 1.0e-20;
solver.setRelativeAccuracy(expected);
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
public void testRangeStepAdjust()
Math.abs(expected.abs() * solver.getRelativeAccuracy()));
DiagonalMatrix d1 = new DiagonalMatrix(6, -8.8);
public void testHighDegree() {
if (jdkSupportsNesting) {
checkValue(f, "1/120");
solver.resetMaximalIterationCount();
public void setPropertyName(final String string) {
public double[] computeTheoreticalState(double t) {
toAppendTo.append(" + ");
int[] domain = getDomain(n, m, k);
c = new NaturalComparator();
public void setLeftOperand(Evaluation left) {
return Math.sqrt(criterion / wm.length);
public RationalNumber(BigInteger numerator, BigInteger denominator) {
public class TDistributionImpl
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
public void setScale(double beta) {
testDa.addElement(2d); // x,x
package org.spaceroots.mantissa.functions.vectorial;
assertEquals(2.0, p[1].getEstimate(), 1.0e-10);
public interface FixedStepHandler {
private double[] v3;
if (c == 0.0) {
double[] values = {35d, 23d, 42d};
for (j = 0; j < n-i; j++) {
public boolean wasLastSeen() {
f2 = new Fraction(1,3);
double mu = distribution.getMean();
Complex complexNaN = Complex.NaN;
v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i]
context.doubleValue(argument),
checkVector(v1, new Vector3D(-2, 0, 2));
v4 = (double[]) interpolator.v4.clone();
this.defaultMinimalIterationCount = 3;
public void initCoeff(int i, double c) {
public void testProductAndGeometricMean() throws Exception {
private static class APSProblem23 extends TestProblem {
public abstract class UnivariateRealSolverFactory {
public void testSerialization()
MathUtils.indicator(b) * t);
return multiply((double) l);
assertNotNull(minima[0]);
public void testPercentiles() {
work[j] = 0;
public void addValue(double value) {
public void testEqualsNull() {
private boolean isValidCoordinate(int row, int col) {
s = fb / fa;
inv.data[index] = 1.0 / data[index];
for (int i = 0; i < observed.length; i++) {
public Matrix add(Matrix m) {
public void testPositiveInfinity() {
public EulerStepInterpolator() {
double z = u.getZ();
private static UnivariateStatistic sumSq = new SumOfSquares();
assertEquals( -4.5, f.value( -1.0), tolerance );
unif = rand.nextDouble();
int ret = 0;
setInverseCumulativeTestPoints(new double[] {0, 1});
new EnhancedSimpsonIntegratorSampler(iter);
public interface GammaDistribution extends ContinuousDistribution {
TestUtils.t(mu, tooShortObs);
public StorelessUnivariateStatisticAbstractTest(String name) {
assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));
if (a >= 0.0) {
optimalIter = Math.min(k, sequence.length - 2);
result = argument * result + coefficients[j];
TestUtils.assertSame(Complex.NaN,
currentState[i] = in.readDouble();
public void testNoDependency() throws EstimationException {
11426454.595762, 6.99887517242903,
return new EstimatedParameter[] { cx, cy };
public class DormandPrince853Integrator
public EstimatedParameter[] getUnboundParameters();
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());
public double getQ1() {
private static final long serialVersionUID = -7414806622114810487L;
new RationalNumber(0l),
return safety;
assertEquals(0, new Polynomial.Double(0.0, 5.0).getDegree());
sum[i] += s.sum[i];
public interface UnivariateRealInterpolator {
absoluteAccuracy = defaultAbsoluteAccuracy;
public void setDegreesOfFreedom(double degreesOfFreedom) {
public abstract double getMin();
public int getRows() {
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
observed1, observed2);
variance.increment(d);
delta = Math.min(delta, lmNorm);
public static double cosh(double x) {
new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),
suite.addTest(LegendreTest.suite());
this.coefficients = coefficients;
assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);
s.append(qString);
statistic.increment(1d);
NumberFormat nf = NumberFormat.getInstance(locale);
if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {
u.addObject(new Double(19.8));
public void testParseNegative() {
double   x3 = parameters[2].getEstimate();
checkValue(f, "2");
if (nRows == 0) {
StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();
iMin = index;
BigDecimal det = (parity == 1) ? ONE : ONE.negate();
problems.add(new APSProblem23(n23[k], 0.0, 1.0, roots23[k]));
return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);
assertTrue(maxError < 1.6e-10);
public boolean isSingular() {
sumXY = 0d;
public Matrix sub(Matrix m) {
t = SummaryStatistics.newInstance();
String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";
setTolerance(4e-6);
setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
private static UnivariateStatistic sum = new Sum();
mapper.manageMappable(scalar2);
protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};
this.f = f;
new BufferedReader(new InputStreamReader(url.openStream()));
if (m.length != n.length) {
yb = coeffs1[coeffs1.length - 1] / coeffs1.length;
min = s.min;
public class UnivariateRealFunctionUtilsTest extends TestCase {
double[][] decomp = new double[numRows][numCols];       
: vecRelativeTolerance[0]))
c[j] = c[j-1] - c[j] * x[i];
m.operate(testVector);
"observed, expected array lengths incorrect");
public static Complex sqrt1z(Complex z) {
if (o instanceof Number) {
int d1 = MathUtils.gcd(denominator, fraction.denominator);
"observed counts must be non-negative");
public class EulerIntegratorTest
if (costE < costR) {
loop = ++rank < order;
private double coefficients[];
if (filePointer == null) {
public final double x;
int endIndex = pos.getIndex();
int populationSize, int numberOfSuccesses, int sampleSize) {
assertEquals(1.0, coefficients[5], tolerance);
String expected = "0 - 1" + getDecimalCharacter() + "43i";
double pdf = data[i][1];
int maximumIterations) throws ConvergenceException, 
assertEquals(10, MathUtils.gcd(-a, -b));
setSampleSize(sampleSize);
StatisticalSummary sampleStats2, double alpha)
for (int k = 0; k < 7; ++k) {
throw new IllegalStateException
checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),
0.500000665371116,  0.733671406187302,
maxError  = 0;
assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);
return ZERO;
Iterator iter = freqTable.keySet().iterator();
newSize = (int) Math.ceil(internalArray.length * expansionFactor);
public String nextSecureHexString(int len) {
if (num.intValue() < 0) {
public static Test suite() {
String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
denominator = x[j+i] - x[j];
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);
protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};
UnivariateRealInterpolator i = new SplineInterpolator();
return imaginaryCharacter;
for (int i = 0; i < cumulativeTestPoints.length; i++) {
f = new Fraction(-50, 75);
double mu,
initialStep = -1.0;
double[] a1 = array1.getArray();
assertEquals(points.length, stat.getN());
for (int k = 0; k < sum.length; ++k) {
assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);
protected void verifyCumulativeProbabilities() throws Exception {
private static class DomainObject implements ArraySliceMappable {
-0.153069523352176e-4, 0.999789703958371,
double x09 = parameters[8].getEstimate();
double d22 = m2[2][2] - m3[2][2];
assertNull(ex.getMessage());
f = new Fraction(0, 3);
-1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}
out[row] = sum;
private double m1Det = 1.0d;
assertTrue("testData2 is not square",!m2.isSquare());
s = 0.5 * (s + sum * spacing);
beta        = new double[cols];
swap[rank] = i;
"minimal step size ({0}) reached, integration needs {1}" },
p = p.negate();
double error;
return (chiSquareTestDataSetsComparison(observed1, observed2) < alpha);
throw new MatrixIndexException(
return new NonNullRange (i, columns);
out.writeDouble(currentTime);
this.u = u;
super(a, b, expectedRoot);
return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, 
return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,
long[] unMatchedObs = { 0, 1, 2, 3 };
assertEquals("Q1",1,u.getPercentile(25),10E-12);
double   smallest      = simplex[0].cost;
double direct = distribution.cumulativeProbability(lower, upper);
x1 = x1 + delta;
assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,
public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;
boolean forward) {
TestUtils.chiSquareTest(counts, 0);
if (begin < 0) {
sortMeasurements();
assertTrue(r3.end   == 8);
assertEquals(-5.0, sample.getMin(), 1.0e-12);
nextIndex = 2;
c1 = d01 + (x1 - x0) * d012;
if (denominator.signum() == 0) {
divdiff[i] = y[i];      // initialization
int n = source.length();
s1.setBiasCorrected(false);
public void testSinhNaN() {
(x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||
PolynomialFunctionLagrangeForm(double x[], double y[]) throws
public long getCumFreq(long v) {
Vector3D v1 = applyTo(Vector3D.plusJ);
public double[] integrate(SampledFunctionIterator iter)
double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;
vs.setMode(ValueServer.EXPONENTIAL_MODE);
assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);
jacobian[i][j] = dx * (j - temp);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
int[] nextPermutation(int n, int k);
mapper.manageMappable(array3);
minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);
fail("Expecting IllegalArgumentException - bad input array length");
public void testTanhNull() {
double mu = 100.0;
private static class LinearFullRankFunction extends MinpackFunction {
double u3y  = u3.getY();
public static final Fraction ZERO = new Fraction(0, 1);
return 2;
public void testAlpha() {
public void computeSecondDerivatives(double t, double[] y, double[] yDot,
regression.addData(infData);
minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },
public void testNextSecureInt() {
regression.getSlopeStdErr(), 1E-10);
for (int i = 0; i < d.getRows(); ++i) {
SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();  
return (f.value(x + h) - f.value(x - h)) / h2;
assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));
TestUtils.assertEquals(two, StatUtils.max(x), tolerance);
double b1 = getSlope();
assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);
super("a" + degree, 0.0);
Complex y[] = transformer.transform(x);
centroid[j] *= scaling;
return handler;
assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);
public void setSecureAlgorithm(String algorithm, String provider)
assertTrue(r3.begin == 3);
replaceWorstPoint(new PointCostPair(xC, costC));
ComplexUtils.polar2Complex(r, theta), 10e-12);
assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);
s.addValue(Double.parseDouble(line.trim()));
u.addValue(1d);
throw new ArithmeticException("overflow: subtract");
RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);
-734375.0/4826304.0,
public double getPartial(EstimatedParameter p) {
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
public EstimatedParameter(String name,
return new TestSuite(MappableScalarTest.class);
public DerivativeException(String specifier, String[] parts) {
case '/' :
q0 = inv * (ort[0][1] - ort[1][0]);
new double[] {  4.0,  0.0, 1.0, 2.0 });
return alpha;
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));
public final class BigMatrixImplTest extends TestCase {
public void testParseZeroImaginary() {
"l''\u00e9chantillon ne contient que {0} points" },
assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);
assertEquals(6.0, coefficients[1], tolerance);
for (int j = 0; j < n; j++) {
x1 = x; y1 = y;
double tmp = (i + 1) / 10.0;
final TestProblem3 pb = new TestProblem3(0.9);
double dx = x - xbar;
public class DistributionFactoryImpl extends DistributionFactory {
max.increment(testArray[1]);
protected double getB(int n, double x) {
h                 = Double.NaN;
for (i = 0; i < N; i++) {
scalar3.setValue(20.0);
hexString = randomData.nextHexString(100);
return coefficients[2].getEstimate();
hs.add(c[i][0]);
new EstimatedParameter("p1", 6),
public void testGridTooFat() throws Exception {
public MessagesResources_fr() {
public RationalNumber add(BigInteger l) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
assertTrue(Math.abs(pair.x    - 1.2) < 1.0e-10);
verifyDecomposition(m, lu);
.84418223983852743293e-4,
public void setMedian(double median) {
super(f, 32);
gotIt = false;
throw new ArithmeticException("overflow: mul");
public double evaluate(final double[] values, final double p) {
return Double.NaN; //not enough variation in x
BigDecimal[][] detData3 = 
public void testSubKO() {
public interface CostFunction {
public class GraggBulirschStoerIntegrator
distribution.setDegreesOfFreedom(n - 2);
for (int j = 0; j < result.getColumns(); ++j) {
a.setElement(1, 1, 1.0);
private double convergence;
this.defaultFunctionValueAccuracy = 1E-15;
"dimensions mismatch: ODE problem has dimension {0},"
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);
if (den == null) {
public void setInitialStepSize(double initialStepSize) {
public EulerIntegratorTest(String name) {
return interpolatedTime;
1.0 / fraction.evaluate(x, epsilon, maxIterations);
sumOfLogs.increment(d);
if (((Interval) iterator.next()).contains(x)) {
public void testNorm() {
public void testErf3291() throws MathException {
double t2 = t * t;
assertEquals(52451, f.getNumerator());
int stages = c.length + 1;
this.forward      = forward;
double[] test = null;
assertEquals("5 choose " + i, bcoef5[i], 
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);
null);
double yMin = f.value(min);
int big = Integer.MAX_VALUE;
new ComputableFunctionSampler(new Function(0.0, 1.0),
if (!isSequence(lower, initial, upper)) {
for (int i = 0; i < d.getRows (); ++i) {
if (moment.n == 0) {
assertEquals(1, new Polynomial.Rational(0l, 3l, 5l).getDegree());
double coeff3    = c23  * tPq;
checkMatrix(m3, new ComplexPattern(m1.getColumns()));
assertTrue(Math.abs(sampler.samplePointAt(6).y[1]  + 1.0) < 1.0e-10);
public void testBound() {
u2.addValue(three);
y[i] = c;
m4.increment(testArray[i]);
return "Variable";
double sum = an; // partial sum
if ((firstTime || lastStep) && (error <= 1.0)) {
public UpperTriangularMatrix(int order, double[] data) {
RealMatrixImpl m1 = (RealMatrixImpl) m.copy();
suite.setName("RandomData Tests");
BufferedReader reader = new BufferedReader(new StringReader(s));
int randInt = nextInt();
StatUtils.variance(diff), tolerance);
"Variance of n = 0 set should be NaN",
public void testIndicatorDouble() {
public void test5() {
u.setWindowSize(test.length);
LinearProblem problem = new LinearProblem(m);
public long getN() {
URL url = getClass().getResource("testData.txt");
return cumulativeProbability((int) Math.floor(x));  
public DataAdapter getAdapter(Object in) {
public static RealMatrix createRowRealMatrix(double[] rowData) {
assertEquals("one sample t stat", 3.86485535541, 
private RungeKuttaStepInterpolator prototype;
assertTrue(d2.getRows() == d1.getRows());
public MappableScalar() {
data[i] = 0.0;
double[] yDot1      = null;
assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);
public double[] getCenters() {
private static final double d6 =      69997945.0 /     29380423.0;
("Not enough knot values -- spline partition must have at least 2 points.");
private Complex zeroNaN = new Complex(0, nan);
lastState = null;
if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {
return values;
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
double diag = data[i * (columns + 1)];
EstimatedParameter[] p = {
return percentile.evaluate(values,p);
fail("Expecting IllegalArgumentException for beta = 0");
public void testConstants() throws MathException {
assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);
for (int i = n-1; i >= 0; i--) {
public GraggBulirschStoerIntegratorTest(String name) {
assertTrue(lastSeen);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testExtremeValues() throws Exception {
GeneralMatrix x = new GeneralMatrix(4, 1);
statistic.hashCode() != statistic2.hashCode());
public void testAddKO() {
return new ThirdMoment();
0.66874030497642, 0.76472449133173, 0.81776543395794,
fail("Expecting IllegalArgumentException");
assertEquals("empty stats should have the same hashcode", 
protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {
if (fsal) {
tolerance = Math.max(solver.getAbsoluteAccuracy(),
f[m - 1] = -1;
public void testParseProperNegative() {
public void testPow() {
public ChebyquadFunction(int n, int m, double factor,
this.copyIn(d);
return arguments;
public static String translate(String s) {
private MappableScalar scalar2;
return (a.length == 1) && (a[0] == 0);
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
out.writeDouble(previousTime);
public void testExpm1Function() throws MathException {
double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};
return new TestSuite(BrentSolverTest.class);
new Interval[0]);
sampler.samplePointAt(10);
distribution.setShape(expected);
PrintStream ps2 = new PrintStream(baos2);
0.708, 0.633, 0.668, 0.645, 0.632,
jacNorm     = new double[cols];
work1[j] = 0;
c[i] = x[i];
assertEquals(m.hashCode(), m1.hashCode());
this.moment = m2;
assertFraction(-1, 2, new Fraction(-1, 2));
double maxCheckInterval, double convergence) {
double tmp1;
double q2q3  = q2 * q3;
int n = c.length;
checkMatrix(a.mul(inverse), new IdentityPattern());
result = solver.solve(0.3, 0.7);
assertTrue(d.isZero());
private PolynomialFunction polynomials[] = null;
index[i] = i;
public void testPowNaNBase() {
("Function values at endpoints do not have different signs." +
image.printStackTrace(ps2);
assertEquals(f.degree(), 5);
public class GraggBulirschStoerStepInterpolatorTest
public boolean tTest( double mu, StatisticalSummary sampleStats,
assertEquals(4d, sumSq.getResult(), 0);
private static final long serialVersionUID = 5207170686914959073L;
if (!FastFourierTransformer.isPowerOf2(N)) {
target = new double[]{y[1], 0d, -3d, 2d};
UnivariateRealFunction f = getFunction();
windowSize < list.size())
UnivariateRealSolver solver = factory.newBisectionSolver(function);
assertEquals(1, MathUtils.gcd( a,  c));
public double expectedValue() {
public void setNormal(NormalDistribution value) {
for (int k = j; k < solvedCols; ++k) {
BigMatrix mRow0 = new BigMatrixImpl(subRow0);
private double a[], c[];
= (AbstractCurveFitter.FitMeasurement) measurements[i];
return getSumSquaredErrors() / (double) (n - 2);
&& (preRed <= 2.2204e-16)
if (variance < 10E-20) {
assertTrue("gaussian value close enough to mean",
sumsq.clear();
double s1 = p.exactIntegration(-5.0, 15.0);
sum  = s.sum;
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
public void testLoad() throws Exception {
public abstract class ComplexFormatAbstractTest extends TestCase {
+ k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j]
if (norm2 > ak2) {
MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);
return loaded;
format.setWholeFormat(nf);
AbstractCurveFitter.FitMeasurement m2
estimator.estimate(this);
boolean firstTime        = true;
if (forward) {
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
private double[][] m3 = {{1, 0, 0}, 
for (int i = 0; i < 100; i+=5) { // make sure no convergence exception
p = p.divide(gcd);
StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);
public class ThreeEighthesIntegratorTest
public void testTwoSampleTHeterscedastic() throws Exception {
private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {
0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};
integ.setStepHandler(new ContinuousOutputModel());
public static double chiSquare(double[] expected, long[] observed)
String[][] data = new String[1][nCols];
da = new ResizableDoubleArray(-1);
GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));
checkPolynomial(new Polynomial.Double(3.0,  0.0, 1.0),
double x = MathUtils.binomialCoefficientDouble(1030,515);
private static final long serialVersionUID = -1390328069787882608L;
coefficients[i] = new PolynomialCoefficient(i);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
s.append(" + ");
if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {
Polynomial.Rational g0 = new Polynomial.Rational(2l * k);
double criterion = 0.0;
if (expansionMode == MULTIPLICATIVE_MODE) {
double getResult();
private double one = 1;
if (x <= upperBounds[i]) {
data[index] += u.data[index];
assertEquals(0, first.compareTo(third));
SimpleRegression reg = new SimpleRegression();
(new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});
double[] operate(double[] v) throws IllegalArgumentException;
public void testAdHocData() throws MathException {
if (x < 0.0) {
if (in[i] <= 0) {
public final class MixedListUnivariateImplTest extends TestCase {
means[i].increment(v[i]);
public double getEstimate() {
public double[] transform(double f[]) throws MathException,
Complex expected = new Complex(1.23, 1.43);
public PolynomialFitter(int degree,
assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );
return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double
new LinearMeasurement(new double[] { -1.0, 1.0 },
return new TestSuite(HighamHall54IntegratorTest.class);
public void testTheory() {
return f;
checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(-3l, 4l)),
public ClassicalRungeKuttaStepInterpolatorTest(String name) {
a = new double[] { a0 };
double dev = 0.0;
TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);
if (imaginary == 0.0) {
public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {
accum += Math.pow((values[i] - m), 2.0);
verifyEquality(u, t);
x10 = o[1][0];
minpackTest(new BrownAlmostLinearFunction(30, 0.5,
TestProblem1 pb2 = (TestProblem1) pb1.clone();
int nCols = d[0].length;
permutation = new int[cols];
values[1] = 2.0 * values[0];
public FastCosineTransformer() {
double[] errorScale = problem.getErrorScale();
double[] yTmp)
double root = UnivariateRealSolverUtils.solve(rootFindingFunction,
public StepProblem(double rateBefore, double rateAfter,
return Math.exp(MathUtils.binomialCoefficientLog(m, x) +
public static Complex[] scaleArray(Complex f[], double d) {
public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {
RandomData rd = new RandomDataImpl();
value = transformer.transform(list.get(calcIndex));
q2 = (a1 * q1) + q0;
if (s.min[i] < min[i]) {
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);
return new Complex(real + rhs.getReal(),
19220.7589790951, 0.217310402518509e-4,
newStep = true;
fail("got " + result + ", should have caught an exception");
double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))
Double.isNaN( u.getMean() ) );
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
private RealMatrixImpl root;
assertRelativelyEquals(null, expected, actual, relativeError);
root = xHigh;
return "0";
data = new BigDecimal[nRows][1];
public SumLogTest(String name) {
4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625
F[0] = y[0].getReal();
summary = s.getSummary();
Complex expected = new Complex(-1.2323, 1.4343);
assertTrue(solver instanceof BrentSolver);
z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /
private long factorial(int n) {
r = new Rotation(Vector3D.plusJ, Math.PI);
+ k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j]
double e;
yDotK[k] = new double[dimension];
public static BigMatrix createBigMatrix(String[][] data) {
protected int iterationCount;
new Interval(-0.9, -0.8),
integ.setStepHandler(new VariableHandler());
public void checkLaguerre(Laguerre p, long denominator, String reference) {
luDecompose();
return tTest( StatUtils.mean(sample), mu, StatUtils.variance(sample),
SwitchingFunction[] functions = pb.getSwitchingFunctions();
this.b          = b;
x1 = 0.5 * (x0 + x2); y1 = f.value(x1);
Comparator c = freqTable.comparator();
7.0,
fail("insufficient data to compute t statistic, IllegalArgumentException expected");
throw new IllegalArgumentException("vector has wrong length");
public void testTanInf() {
checkValue(f.multiply(new PolynomialFraction(9l,4l)), "3/2");
private static final double e1_07 =         -69799717.0 / 140793660.0;
private static final boolean JDK_SUPPORTS_NESTED;
assertEquals("4x3 Q'Q = I", 0, norm, normTolerance);
protected double relativeAccuracy;
VectorialValuedPair previous = next;
z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));
if (den.intValue() < 0) {
Polynomial.Rational d = Hk0g0.add(Hk1g1.add(Hk2g2));
double min, max, result[], tolerance = 1E-12; int N = 1 << 8;
testRegularizedGamma(Double.NaN, -1.5, 1.0);
transformers.putTransformer(Bar.class, new NumberTransformer() {
ret = getMedian();
if (firstCall) {
public void resetState(double t, double[] y);
public APSProblem22(int n, double a, double b, double expectedRoot) {
if (this.getColumnDimension() != m.getColumnDimension() ||
public void testDegenerate1() throws Exception {
minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },
public void testInference() throws Exception {
assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
674256.040605213, 0.047829593911544,
product.simplify();
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
checkValue(new PolynomialFraction(2l, 3l).add(new PolynomialFraction(3l, 4l)),
protected double[] preMultTest = {8,12,33};
return dimension2;
for (int i=0; i<x.length; i++) {
q2 = q1 + (b / a * q0);
xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
f[i+j+k] = f[j+k].subtract(z);
MatrixUtils.createColumnBigMatrix(new double[] {});  // empty
double cdf1 = data[i][3];
TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);
public AbstractUnivariateStatisticTest(String name) {
assertEquals(x[i], result[i].getReal(), tolerance);
"The initial capacity supplied: " + initialCapacity +
private double lmPar;
regression.getMeanSquareError(), 10E-10);
super(65, startParams, theoreticalStartCost,
fail("expecting ArithmeticException but got: " + f.toString());
protected double coefficientTolerance = 1E-6;
distribution.setAlpha(0d);
4.10440307655564,    -3.14361222178686,
return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;
double oneMinusTheta = 1.0 - theta;
public abstract Evaluation evaluate(long l);
double fraction = unscaled - Math.floor(unscaled);
"Unable to convert {0} to fraction after {1} iterations",
mean       = null;
protected int startIndex = 0;
assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);
int i2 = randomizer.nextInt(size);
assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);
for (int i = k, index = kDiag; i < rows; ++i, index += cols) {
suite.addTest(org.spaceroots.mantissa.fitting.AllTests.suite()); 
return beta;
assertTrue(Math.abs(sampler.samplePointAt(6).getX()  - 0.5) < 1.0e-10);
testRegularizedBeta(0.75, 0.5, 1.0, 2.0);
TestUtils.assertEquals(Complex.ONE, 
void setDenominatorDegreesOfFreedom(double degreesOfFreedom);
m.preMultiply(asBigDecimal(testVector));
public void setLastSeen(boolean lastSeen) {
public SumTest(String name) {
ga = gb;
this.initialStep = -1.0;
case EXPONENTIAL_MODE: return getNextExponential();
new Interval(  1.0,  1.2) });
if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
inputArray = in;
this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;
outBuffer.append("standard deviation: " + getStandardDeviation() + "\n");
error = 0;
-0.89680510749204
q0 = inv * (ort[1][2] - ort[2][1]);
protected SquareMatrix(int order) {
double expected = 0.995;
byte hash[] = alg.digest();
H = G2.subtract(d2v.divide(pv));
double[] constants = {1, -2, 1};
value = randomData.nextInt(0,3);
public StepHandler getStepHandler() {
double xHigh, double fHigh) {
y = y * x + coeffs[i];
throw new IllegalArgumentException ("function is null.");
checkContractExpand(getContractionCriteria(), expansionFactor);
double[] a2 = { 3.0, 9.0, 27.0, 81.0 };
Random random = new Random(86343623467878363l);
public double getQ3() {
assertTrue(Math.abs(pair2.getX() - 1.2) < 1.0e-10);
return new RationalNumber(p.add(q.multiply(l)), q);
3624883.342907764, TestUtils.chiSquare(exp, obs), 1E-9);
m,entryTolerance);
public static class Rational extends Polynomial {
return Math.pow(x, ((PolynomialCoefficient) p).degree);
double[] yTmp    = new double[y0.length];
Double.isNaN(u.getVariance() ) );
this.switchTime = switchTime;
m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},
setRecurrenceCoefficients(k);
private static class APSProblem19 extends TestProblem {
double stage(double min, double max, int n) throws
Complex y[] = {
private static class Function
c[n] = 0d;
double[][] newPols = new double[maxDegree + 1][];
for (int col = 0; col < this.getColumnDimension(); col++) {
random.setSeed(100);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
return weight;
new Object[] { new Double(value), new Integer(maxIterations) });
assertTrue(Math.abs(b1.getElement(0) - 0.0) < 1.0e-10);
public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {
VectorialValuedPair previous = current;
double c23       = soMt * (1 + 2 * theta);
this.scalRelativeTolerance = scalRelativeTolerance;
bDecrementData[j][0] = weight * residual * grad[j];
public NelderMeadTest(String name) {
public interface PoissonDistribution extends IntegerDistribution {
ret = format( new Fraction(((Number)obj).doubleValue()),
double stdDev = Math.sqrt(variance.getResult());
tab[1] = -3.2;
public VectorialMeanTest(String name) {
assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));
"1/3");
checkPolynomial(p2, "-4 + 2 x");
public void testParameters() throws Exception {
double n = 23.5;
assertFalse(exceptionExpected);
return new DefaultValue(d);
m = new RealMatrixImpl(bigSingular);
int n = xSmallest.length;
private static double k16_15 =     -290468882375.0 / 31741908048.0;
values      = new double[2];
public void testMinpackBrownDennis()
x03 * (temp - x10) * (temp - x10) * tmp3,
assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);
assertTrue( 0.0 < regression.getSignificance()
return this.sumLog;
if (v.length != nRows) {
double x, 
this.numeratorFormat = format;
numberOfTrials = trials;
public NumberFormat getImaginaryFormat() {
double x = u.getX();
result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);
if (nearest < 0.5*(n-i+1)) {
.36899182659531622704e-5,
pendingEventTime = root;
private static final long serialVersionUID = 467695563268795689L;
return new CauchyDistributionImpl(1.2, 2.1);
assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);
case '-' :
double t = 2.0 / m;
protected UnivariateRealFunction getFunction() {
return coefficients[0].getEstimate();
throw new IllegalArgumentException("function can not be null.");
double oldDelta = delta;
getLowerDomain(n, m, k),
sampleSize = size;
double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);
-.26190838401581408670e-4,
assertTrue(minStep < (1.0 / 100.0));
public static double variance(final double[] values, final double mean, 
private static class APSProblems15To17 extends TestProblem {
private void check(IntervalsList l1, IntervalsList l2, double x,
double inv = 0.25 / q0;
new double[] {
NumberFormat nf = NumberFormat.getPercentInstance();
protected double               theoreticalMinCost;
private final double y;
assertEquals(skew ,s.getResult(),tolerance);
public int getMode() {
private static void setup(UnivariateRealFunction f) {
double[] permData = new double[b.data.length];
public WeibullDistribution createWeibullDistribution(
public class FractionFormat extends Format implements Serializable {
yDDotOnScale += ratio * ratio;
assertTrue(Math.abs(sampler.samplePointAt(6).getY()  + 0.5) < 1.0e-10);
int len = c.size();
this.propertyName = string;
return sigma * rand.nextGaussian() + mu;
protected void assertClose(String msg, RealMatrix m, RealMatrix n,
fraction.denominator/d2));
m [1][0] = 2.0 * (q1q2 - q0q3);
double u = randomData.nextUniform(0.99, 1);
return new TestSuite(HarmonicFitterTest.class);
TestSuite suite = new TestSuite("org.spaceroots.mantissa.quadrature.vectorial"); 
public Polynomial divide(RationalNumber r) {
setFunction(function);
+ m[1].getResidual() * m[1].getPartial(p[2])
transformer.transform(f, -1, 1, 64);
for (int i = col + 1; i < nCol; i++) {
binCount - 1);
a = buildProblem3().a;
test3 = stats.getValues();  
private void testGetDeterminant(double[][] lowerTriangularMatrix, 
4.68629150101524, -4.15826451958632, 4.0 };
if (!Double.isNaN(values[i])) {
public interface RootsFinder {
public CauchyDistributionImpl(double median, double s){
checkValue(new RationalNumber(1l, 2l),  "1/2");
public abstract void increment(final double d);
return weightedRoots.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
private static double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;
randomData.nextSecureInt(4,3);
denominator *= -1;
FunctionEvaluationException {    
"realFormat can not be null.");
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
this.b = b;
double[] y0 = { Math.sin(a), Math.cos(a) };
extends GeneralSquareMatrix {
denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;
this.theoreticalMinParams = theoreticalMinParams;
variance.setBiasCorrected(isBiasCorrected);
private final Throwable rootCause;
private double[] sum;
fail("Failed to detect unsorted arguments.");
public void testChiSquareDataSetsComparisonEqualCounts()
package org.apache.commons.math.function;
if (xm == x0) {
g0 = function.g(t0, y0);
return randomData.nextExponential(mu);
BigMatrix scalarMultiply(BigDecimal d);
double[] lowerData = new double[rows * columns];
FractionFormat properFormat = null;
protected int numElements = 0;
assertEquals("RealMatrixImpl{}",
double[] out = new double[nrows];
super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);
Math.abs(getSlope()) / getSlopeStdErr()));
if (stats.getN() > 0) {
p.getA(), p.valueAt(p.getA()),
assertNotNull(solver);
sum.increment(1d);
protected TTest testStatistic = new TTestImpl();
generator = null;
setCostAccuracy(7.0e-3);
RealMatrix inverse() throws InvalidMatrixException;
return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),
public void testClasses(){
private static final long serialVersionUID = -7179861704951334960L;
optimalStep     = new double[size];
weight = Math.sqrt((double) countSum1 / (double) countSum2);
solver.getDeterminant();
assertEquals("spline function evaluation failed for x=" + x, 
Double pi = new Double(Math.PI);
double val = 0.0;
addValue(new Character(v));
public void testSinFunction2() throws MathException {
assertEquals("Rows03Cols12", mRows03Cols12,
throws NotPositiveDefiniteMatrixException,
scale[i] = scalAbsoluteTolerance;
num = Math.abs(num);
checkLaguerre(new Laguerre(1), 1l, "1 - x");
out.print("Caused by: ");
31.0)
testi = rd.nextPermutation(10,5);
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
new Object[] {
20,  21,  22,  23,  24,  25,  26,  27,  28,   29,
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));
for (int i = 0; i < u.length; i++) {
o[0] = new double[3];
testStatistic.t(sampleStats1, sampleStats2), 1E-10);
numberOfSuccesses, sampleSize);
public double cumulativeProbability(double x) throws MathException{
v1.z * v2.x - v1.x * v2.z,
setDistribution(new NormalDistributionImpl(0, 0.1));
double inv = 1.0 / (c + c);
setDistribution(new NormalDistributionImpl(0, 1));
solver = new NewtonSolver(f);
public synchronized void contract() {
public static long factorial(final int n) {
double u1x = u1.getX();
Math.asin(v2.getY()),
assertTrue(Math.abs(pair.y[0] + 0.1 * i) < 1.0e-10);
if (begin + length > values.length) {
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());
public void testHighPercentile(){
public int getNumberOfTrials() {
a.setElement(0, 1,   1.0);
assertTrue("Variance of n = 0 set should be NaN",
hNew = Math.min(Math.abs(h), optimalStep[targetIter]);
assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );
public GammaTest(String name) {
y0 = (double[]) problem.y0.clone();
r = new Rotation(u1, u2, u1.negate(), u2.negate());
public MathException(String pattern, Object[] arguments) {
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);
new Interval(-10.0, 12.0), new Interval(9.0, 10.0));
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
sum        = (double[]) x.clone();
assertEquals(3, c.length);
private static final long serialVersionUID = -1341109412864309526L;
Complex c[] = new Complex[coefficients.length];
delta = p / p1;
evaluateSimplex();
this.remainder = remainder;
TestUtils.assertEquals("Inconsistent cumulative probabilities for (" 
assertTrue(inverse instanceof DiagonalMatrix);
setTolerance(5e-6);
61211252.2338581, 292.954306151134,
protected Mean stat;
jacobian[i][n - 1] = 0;
return new Complex((real * q + imaginary) / denominator,
outBuffer.append(getCount(value));
LinearProblem p;
assertEquals(4, testDa.getInternalLength());  // x,x,x,0 
lmPar = 0;
boolean needsNormalization) {
array[start] = value;
int inverseCumulativeProbability(double p) throws MathException;
Complex realNaN = new Complex(Double.NaN, 0.0);
return Math.sqrt(variance.getResult());
assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));
TestSuite suite = new TestSuite(TTestFactoryTest.class);
permutation[row] = row;
if (fp > 0) {
Complex z = solve(c, initial);
assertEquals(expectedDenominator, actual.getDenominator());
-0.0157247019712586, 1.01243490925658,
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.3e-2);
checkValue(new PolynomialFraction(12l), "12");
det = det.multiply(lu[i][i]);
public abstract void setWindowSize(int windowSize);
return 0.5 + (Math.atan((x - median) / scale) / Math.PI);
7.0);
private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;
protected void doFinalize()
assertTrue(pb.getCalls() < 2800);
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testSetQuantile() {
return new Complex(real - rhs.getReal(),
x[0] = 0.0;
distribution.setDegreesOfFreedom(4d);
Complex z = new Complex(3.0, Double.NaN);
assertEquals("two sample heteroscedastic p value", 0.128839369622, 
(empiricalDistribution.getSampleStats().getMean(),
this.t0 = t0;
colSum[col] += (double) counts[row][col];
max        = (double[]) x.clone();
public FunctionEvaluationException(double argument) {
assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);
setWindowSize(window);
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
q3 = inv * k.getZ();
private static class JennrichSampsonFunction extends MinpackFunction {
public static final int REPLAY_MODE = 1;
error = Math.sqrt(error / y0.length);
Rotation r = new Rotation(u, v);
eDA.getNumElements());
System.arraycopy(interpolator.getInterpolatedState(), 0,
assertTrue(Double.isNaN(product.getResult())); 
public KeplerHandler(TestProblem3 pb) {
Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(3l, 4l)),
fail("Failed to detect data set array with different sizes.");
public Matrix              b;
return eDA.getNumElements();
private static class Checker implements ConvergenceChecker {
public void testBeta() {
double   x02 = parameters[1].getEstimate();
public double getMean();
0.99999999999999709182,
public ChiSquareTest createChiSquareTest() { 
public void testMinpackKowalikOsborne()
public HarmonicFitter(Estimator estimator) {
sum += (i + 1) * parameters[i].getEstimate();
public void incrementAll(double[] values, int begin, int length) {
LinearProblem problem =
return t(meanDifference, 0,  
if (x <= 0.0) {
lmDir[permutation[i]] -= ypk * jacobian[index];
long nextSecureLong(long lower, long upper);
public class GeneralMatrix
final TestProblem3 pb  = new TestProblem3(0.9);
public static double[] sample(
if (p <= 0) {
rg.setSeed(17399225432l);
double corr = 0;
fail("null is not a valid data array.");
public void testNISTExample() {
assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))
public abstract FirstOrderIntegrator newClassicalRungeKuttaIntegrator(double step);
xbar = x;
for (int i = 0; i < copiedArray.length; i++) {
assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);
assertEquals("min", min, StatUtils.min(values), tolerance);
if (Math.abs(c) < Math.abs(d)) {
criterion += wm[i].getWeight() * residual * residual;
assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
new Double(initial), new Double(lowerBound), new Double(upperBound),
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);
r = (1L << (2 * j)) -1;
public static double regularizedBeta(double x, double a, double b)
coefficients[0].setEstimate(guesser.getA());
pointCostPair     = tmp;
assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);
return Math.log((double)n);
public double getMaxStep() {
double f2 = f.value(upper);
int maxIter,
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
-r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),
Polynomial.Rational p = new Polynomial.Rational(4l, 6l, -3l);
jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };
p = BigInteger.ZERO;
super(false, c, a, b, new HighamHall54StepInterpolator(),
for (int i = 0; i < v.length; ++i) {
return getUpperDomain(getSampleSize(), getNumberOfSuccesses());
assertTrue(! p1.isBound());
++nbSteps;
super.verifyIterationCount();
assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);
void load(File file) throws IOException;
int result = 31 + MathUtils.hash(getMax());
private UpperTriangularMatrix upper;
a = 1.2;
private static final double e2_08 =       -1674902723.0 / 288716400.0;
if (rhs.isInfinite() && !isInfinite()) {
private long twoL = 2;
private static final double DEFAULT_EPSILON = 10e-9;
double x[] = { 0.0, 0.5, 1.0, 1.5 };
double dz3 = v3z - u3z;
public abstract NormalDistribution 
public KeplerStepHandler(TestProblem3 pb) {
private double[] v1;
String source = "(NaN) + (NaN)i";
public void testResetRelativeAccuracy(){
v[k] = new double[dimension];
StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);
assertEquals(-5, c.getNumerator());
f.addValue(threeI);
if (minima[i] == null) {
gotIt = true;
testDecompose(m4, "Decomposing matrix m4");
coefficients[1] = b[i];
double[] tab = new double[2];
if (a[0] == 0.0) {
table[0] = currentY;
public void testNaNs() {
int    jMax   = k;
inputStream.close();
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
double min = 0.0, max = 2 * Math.PI;
tmpVec    = residuals;
work1[pj] *= diag[pj] / dxNorm; 
double[] newA = new double[a.length];
assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;
BufferedReader in = null;
double min = Double.NaN;
public static UnivariateRealFunction forwardDifferenceDerivative(UnivariateRealFunction function, double delta) {
public GeometricMean() {
private static final long serialVersionUID = -7606628156644194170L;
dxNorm += s * s;
double akk   = jacobian[kDiag];
double r = 0;
relativeAccuracy = accuracy;
public static Complex sin(Complex z) {
1.0 / 6.0, (2.0 - sqrt2) / 6.0, (2.0 + sqrt2) / 6.0, 1.0 / 6.0
public void testMultiplication() {
public double getDuplicateAbscissa() {
return scaleArray(fft(f, false), scaling_coefficient);
public void testInterpolateLinearDegenerateThreeSegment()
public void testQOrthogonal() {
transformer.transform(f, -1, 1, 1);
map.put(parameters[j], null);
private double[][] copyOut() {
assertTrue(Math.abs(b2.getElement(1) - 0.3) < 1.0e-10);
sumSq.increment(1);
jacobianEvaluations = 0;
fb = fc;
CostFunction powell =
compareValue = vs.getNext();
Fraction other = (Fraction)object;
return getCenterDistance() - getRadius();
while ((i >= 0) && (curr.x < mI.x)) {
0.375410049244025, 1.93584654543108,
double dx3 = v3x - u3x;
d.solve(b, 1.0e-10);
true, false, 1, false, false, 2, false,
double[][] vertices,
s = ort[2][2] - ort[0][0] - ort[1][1];
int      resultIndex   = 0;
if (fo != null) {
public SquareMatrix solve(SquareMatrix b, double epsilon)
while (j < minJ) {
assertEquals("SSR", 4255954.13232369,
assertEquals(8.0, z.getReal(), 1.0e-5);
return sqrt(Complex.ONE.subtract(z.multiply(z)));
randomData.nextExponential(-1);
DescriptiveStatistics u = new ListUnivariateImpl( externalList ); 
public class BigMatrixImpl implements BigMatrix, Serializable {
Matrix permB = MatrixFactory.buildMatrix(b.getRows(), bCols, permData);
while (j++ < i) {
assertTrue(u instanceof DescriptiveStatisticsImpl);
Object[] arguments = { new Double(0.0) };
densityTestValues = null;
Object[] result = new Object[k];
public double[] getMean() {
RealMatrix pdMatrix = 
for (int i = rows - 1; i >= 0; --i) {
implements UnivariateStatistic, Serializable {
m = new RealMatrixImpl(testData);
public abstract double expectedValue();
public GaussianRandomGeneratorTest(String name) {
public interface NormalDistribution extends ContinuousDistribution {
switchesHandler.add(function, maxCheckInterval, convergence);
for (int j =0; j < smallSamples[i].length; j++) {
(double) sampleStats2.getN());
if (windowSize < 1) {
public void reSeedSecure() {
assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());
this.cx = new EstimatedParameter("cx", cx);
for (int j = 0; j < transposed.getColumns(); ++j) {
for (int row=col+1; row<numRows; row++) {
private static class MyMeasurement
functions.add(new SwitchState(function, maxCheckInterval, convergence));
public WatsonFunction(int n, double x0,
checkValue(t,
return new HypergeometricDistributionImpl(populationSize,
skew.increment(1d);
result = transformer.inversetransform(y);
new EstimatedParameter("p1", 0),
package org.apache.commons.math.linear;
assertEquals(x[i], result[i], tolerance);
public void setMinimalIterationCount(int count) {
public void addValue(Object v) {
this.denominator = q2;
Math.sin(phi));
xTab[i1] = xTab[i2];
private double[] y1;
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
this.maxCheckInterval = maxCheckInterval;
private static UnivariateStatistic max = new Max();
(double) sample1.length, (double) sample2.length);
new Interval(30, 40),
checkValue(new PolynomialFraction(1l, 2l),  "1/2");
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);
TestUtils.homoscedasticTTest(sample1, sample2, 0.49));
double dev = cachedNormalDeviate;
return intervals.isEmpty();
f = new RationalNumber(120l).invert();
System.arraycopy(yDot1, 0, yDot0, 0, y0.length);
uRef = u2;
checkVector(axis, Vector3D.plusK);
measurements = problem.getMeasurements();
MathUtils.equals(stat.getVariance(),this.getVariance()));
MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null
- Math.sin(4.0);
double[][] jacobian = new double[m][];
vRef = v2;
double inv = 1.0 / diag;
private static final long serialVersionUID = -1490493298938282440L;
assertTrue(true);
public void testChiSquareLargeTestStatistic() throws Exception {
0.134575665392506
public CostException(Throwable rootCause) {
case BigDecimal.ROUND_CEILING :
public void testContainsClass(){
Complex denominator = null;
double r = cost / previousCost;
public Fraction(double value) throws FractionConversionException {
double a = z.getReal();
ret = Beta.regularizedBeta((n * x) / (m + n * x),
suite.setName("RandomAdaptor Tests");
AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;
public static final int CONSTANT_MODE = 5;
outBuffer.append(hex);
return root;
return Math.sqrt (x * x + y * y + z * z);
return transform2(f);
if (j == 40) {
assertEquals( 0.0, f.value( -0.5), tolerance );
+ Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);
simplex[i] = new PointCostPair(pair.point, evaluateCost(pair.point));
estimator.estimate(function);
public abstract class UnivariateRealIntegratorImpl implements
for (int i = 0; i < scale.length; ++i) {
Vector3D v2 = applyInverseTo(Vector3D.plusK);
checkValue(new PolynomialFraction(0l, 500l), "0");
public class ClassicalRungeKuttaIntegratorTest
coefficients[2] = c[i];
for (int i = 0; i < last.length; ++i) {
public abstract FirstOrderIntegrator newEulerIntegrator(double step);
m.setSubMatrix(testData,1,-1);
fail("Expecting IllegalArgumentException - no bracketing");
double reflectedCost = evaluateNewSimplex(original, 1.0);
double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };
public Object removeTransformer(Class key) {
b.setElement(i, 0, rows - i);
covStat.increment(vertices[i]);
upper            = null;
double coeff1 = 0;
public double getElement(int index) {
mf.setLocale(locale);
double tmp1 = x2 / temp;
BigDecimal[] out = new BigDecimal[nCols];
this.x = new double[x.length];
double temp = 10.0 * i;
public int getCostEvaluations() {
m = new RealMatrixImpl(singular);
assertTrue(exceptionOccurred);
return maxStep;
sumsq.increment(value);
Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);
public class TTestFactoryTest extends TTestTest {
ComplexFormat cf = new ComplexFormat();
VectorialCovariance stat = new VectorialCovariance(points[0].length);
SummaryStatistics stats =
checkVector(u, r.applyTo(r.applyInverseTo(u)));
Complex newc = c[n-i];
this.realFormat = realFormat;
assertEquals("Rows02Cols13", mRows02Cols13,
Vector3D v2 = new Vector3D(3, 1, -1);
gamma += jacobian[index] * y[i];
checkVector(v, new Vector3D(3, 6, 9));
public abstract class DoubleArrayAbstractTest extends TestCase {
assertEquals("three frequency count",0,f.getCount(3));
assertEquals(expected, m);  
public static final class Foo {
public class DuplicateSampleAbscissaExceptionTest extends TestCase {
public boolean evaluateStep(StepInterpolator interpolator) {
assertTrue(Math.abs(s.getElement(2, 1) - 3.4) < 1.0e-10);
TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));
return Double.isNaN(real) || Double.isNaN(imaginary);        
public void testNegate() {
return (EstimatedParameter[]) parameters.toArray(new EstimatedParameter[parameters.size()]);
degreesOfFreedom = df(v1, v2, n1, n2);
"Mean of n = 1 set should be value of single item n1",
double temp= 2 * div * s2;
int ret = 7;
double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2])
UnivariateRealFunction f = new QuinticFunction();
fitter = null;
double d = x - i * i;
private Double temperature;
public DefaultContext() {
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)
m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;
"sample size must be non-negative.");
FastFourierTransformer transformer = new FastFourierTransformer();
if (Math.abs(a0 - value) < epsilon) {
public void testDenominatorFormat() {
public void testElements() {
binomialCoefficient(n - 1, k);
minpackTest(new BrownAlmostLinearFunction(10, 0.5,
public static double sumLog(final double[] values, final int begin,
assertFalse("instances based on different data should be different", 
double denominator = c * q + d;
public abstract class RetryTestCase extends TestCase {
this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);
assertEquals(sa[i].getInf(), ib.getInf(), 1.0e-10);
public static void checkSerializedEquality(Object object) {
else { // make sure top coding not reversed
this.maxStep     = maxStep;
return 1.0 - distribution.cumulativeProbability(
public LinearProblem(LinearMeasurement[] measurements) {
public void testPercentile() {
0.0824105765758334,
lowerData[i][j] = new BigDecimal(0);
d[i] = y[i];
: new RationalNumber(newP, newQ);
if (real == 0.0) {
++index;
gamma += jacobian[index] * jacobian[index + dkp];
? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));
TestSuite suite = new TestSuite(MaxTest.class);
double subStep  = step / n;
assertTrue(bos.size () > 86000);
return (p.compareTo(r.p) == 0) && (q.compareTo(r.q) == 0);
assertEquals("3x3 R size", qr.getR().getColumnDimension(), 3);
Polynomial.Rational d = Lk0g0.add(Lk1g1.add(Lk2g2));
Math.atan2(v2.getX(), v2.getY())
double[] y1, double[] y1Dot,
assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);
public Vector3D negate() {
this.stabilityReduction = stabilityReduction;
implements ChiSquaredDistribution, Serializable  {
protected double partialerror(double x[], double z) throws
return tTest. tTest(sampleStats1, sampleStats2, alpha);
Math.min(sampleStats1.getN(), sampleStats2.getN()) < 2)) {
public double getCumPct(Object v) {
last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);
"dimensions incompatibles {0} != {1}" },
private static final double[] b = {
return (largest.cost - smallest.cost) < threshold;
public void testSerialization() {
sb.append(')');
createNormalDistribution(double mean, double sd);
private int locatePoint(double time, StepInterpolator interval) {
double[] standardDeviation,
zDDot          = new double[dimension];
int q2 = 1;
assertEquals(-1, second.compareTo(first));
previousRejected = true;
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
for (int i = 0; i < data.length; ++i) {
p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));
public void testNumeratorFormat() {
return numberOfSuccesses;
b  = c;
double scaling_coefficient = Math.sqrt(2.0 / n);
return sampleStats;
boolean lastStep  = false;
assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), 
double[] v = this.getValues();
ret = ((x + .5) * Math.log(tmp)) - tmp +
private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {
public static double varianceDifference(final double[] sample1, final double[] sample2, 
public void testRangeStepNoAdjust()
checkLegendre(new Legendre(2),  2l, "-1 + 3 x^2");
double orderControl1, double orderControl2) {
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
double mean = variance.moment.m1;
TestUtils.chiSquareTest = chiSquareTest;
u2.addValue(two);
firstTime = false;
estimator.setMaxCostEval(100 * (function.getN() + 1));
Integer.toString(m.length),
345.223634624144
super.printStackTrace(out);
sumSq += dev * dev / expected[i];
public static void verifyDataSet(Object o[]) throws IllegalArgumentException {
boolean foundLimit = false;
RealMatrix mRows23Cols00 = new RealMatrixImpl(subRows23Cols00);
public class PercentileTest extends UnivariateStatisticAbstractTest{
return new TestSuite(PolynomialFitterTest.class);
assertEquals(n + " choose " + k,(double) binomialCoefficient(n, k), 
public FractionConversionException(double value, int maxIterations) {
Complex expected = new Complex(1.60944, 0.927295);
int numberOfSucceses = 101;
return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);
assertTrue(count < 800);
BigMatrix m = new BigMatrixImpl(testData);
public Complex(double real, double imaginary) {
double curr   = interpolator.getCurrentTime();
assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);
double n0 = length;
return transform2(f, min, max, n);
setProbabilityOfSuccess(p);
lowerData[i][j] = 0d;
public void testPowInf() {
+ theta * (v[2][i]
assertEquals(-2, f.getNumerator());
protected double mean = Double.NaN;
package org.spaceroots.mantissa.quadrature;
public class IntervalTest
FirstOrderIntegrator integ =
m[0] = new double[3];
assertEquals("Integer 1 count", 2, f.getCount(1));
cumulativeTestPoints = makeCumulativeTestPoints();
public RationalNumber invert() {
public static double variance(final double[] values) {
internalArray = new double[this.initialCapacity];
private double stepControl1;
assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);
if ((k < targetIter)
-Math.asin(v2.getY()),
public void testExpNull() {
public void testPlusMinus() {
public RealMatrix getR()
public abstract double getMax();
assertTrue(bos.size () < 99000);
for (int i = 0; i < estimatedMean.length; ++i) {
double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)
double yb = coeffs[coeffs.length - 1] / coeffs.length;
public Evaluation evaluate(long l) {
n    = s.n;
super(u);
protected abstract double getB(int n, double x);
-18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},
imaginary + rhs.getImaginary());
public double getCurrentTime() {
private class DataAdapterFactory{
assertTrue(handler.getMaximalError() > 0.05);
for (int k = 0; k < v.length; ++k) {
fail("Can not have 0.0 scale.");
long sumFreq = f.getSumFreq();
if (optimalIter <= k) {
for (int i = 0; i < test3.length; i++) {
public TestProblem4(TestProblem4 problem) {
double[] tmpVec = residuals;
extends UnivariateRealFunction {
protected BigDecimal[][] bigColMatrix = 
public BigMatrixImpl(double[][] d) {
m3 = 0.0;
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.backwardDifferenceDerivative(function, 1.0e-5);
return upper.solve(lower.solve(permB, epsilon), epsilon);
assertTrue(new Legendre().isOne());
boolean b1, boolean b2, boolean b3,
0.78513038703d,  0.99716023388d, 0.999999998077 };
mI = null;
throws FunctionException;
throw new IllegalArgumentException("propagation direction mismatch");
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),
public static RealMatrix createRealMatrix(double[][] data) {
private static final double e2_11 =         171414593.0 / 851261400.0;
public void testAsinNaN() {
0.428, 0.292, 0.162, 0.098, 0.054
package org.apache.commons.math.distribution;
for (int k = 1; k < size; ++k) {
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
d2v = Complex.ZERO;
Circle circle = new Circle(-12, -12);
public void testLogBetaNanPositive() {
assertTrue("reflexive, non-null", statistic.equals(statistic));
package org.apache.commons.math.transform;
UnivariateRealSolverFactory.class,
assertEquals(8, dme.getDimension2());
a.setElement(1, 1,  3.0);
scalar2.setValue(10.0);
public class Legendre
11.4127817857886,
0.5,                0.583953092107402,
double nextDouble();
return (nextAction == SwitchingFunction.RESET_STATE)
package org.apache.commons.math.stat.descriptive.summary;
public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{
x1 = min; y1 = f.value(x1);
assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.990) < 1.0e-10);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
fail("an IllegalArgumentException was expected");
return Complex.I.negate().multiply(log(z.add(
float factor = (float)Math.pow(10.0f, scale) * sign;
x3
int getIterationCount();
double x0 = startValue;
DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);
double oneMinusThetaH = currentTime - interpolatedTime;
29.828227326505,  41.906116195289,  55.953595800143, 71.985665586588,
1.00082104729164,    -2.61773101573645,
assertEquals(1, new Polynomial.Rational(3l, 5l).getDegree());
2.0,
public UnivariateRealFunction evaluate(UnivariateRealFunction f) throws MathException;
minpackTest(new LinearFullRankFunction(10, 5, 1.0,
protected double m1;
min_dist = dist;
if (threshold == 0) {
assertEquals(m.getEntry(i, j), 0d, 0);
Double.toString(Math.abs(t - t0))
assertTrue(bos.size () < 83000);
ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);
return mean;
tab[0] = -8.4;
if (number != null) {
if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
Fraction ret = super.parse(source, pos);
private BufferedReader inputStream;
TestUtils.tTest(mu, observed), 10E-10);
public double getElement(int i) {
return moment.m1;
private double kurtosis = 0.5;
y = string;
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
for (int j = 0; j < m.getColumns(); ++j) {
x22 = o[2][2];
if (n  != sample2.length || n < 1) {
derivative = ((DifferentiableUnivariateRealFunction) f).derivative();
void setFunctionValueAccuracy(double accuracy);
public double getAmplitude() {
f1 = f1.add(f1);
newQ.negate())
private boolean finalized;
new BigMatrixImpl(1, 0);
< 1.0e-10);
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions.vectorial"); 
public byte byteValue() {
assertEquals(oldValue, solver.getMaximalIterationCount());
setup(f);
if (d[row].length != nCols) {
cost = previousCost;
assertEquals("sum",sum,u.getSum(),tolerance);
r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),
"720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4"
for (int k=0; k<col; k++) 
public double doubleValue() {
"\u00c9chec de convergence" },
int p0 = 1;
decompose(covariance, small);
u.setWindowSize(110);
MathConfigurationException ex = new MathConfigurationException(cause);
private Integer age;
evenPermutations = true;
RationalNumber denominator) {
protected EstimatedParameter[] coefficients;
double ratio1  = errSum1 / tol;
MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged
a.setElement(2, 2,  -2.0);
new double[][] {
double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};
moment = new FirstMoment();
protected int[] getInverseCumulativeTestValues() {
BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;
Complex z = new Complex(0, inf);
unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);
private int sign;
Frequency f = new Frequency();
tooShortStats.addValue(0d);
assertEquals(1L, f.getCount('a'));
public void testSolveNoRoot() throws MathException {
value = 0;
Complex N = new Complex((double)n, 0.0);
("matrix must be initialized to perfom this method");
reject = true;
public SwitchingFunctionsHandler() {
public Rotation(double q0, double q1, double q2, double q3,
public class AbstractUnivariateStatisticTest extends TestCase {
sampleStats.addValue(val);
public Matrix(int rows, int columns, double[] data) {
class SwitchState implements Serializable {
public void testRegularizedBetaPositivePositiveNan() {
double prev = interpolator.getPreviousTime();
yDot[0][2] = (y[2] - y0[2]) / dt;
assertTrue(estimator.getRMS(problem) < initialCost);
double[] val = new double[5];
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
public void testIllegalArguments() throws MathException {
return new VectorialValuedPair(point.x,
implements Estimator, Serializable {
BigMatrix m = (BigMatrix) object;
double getNorm();
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
super(degree, generator);
theoreticalMinCost, theoreticalMinParams);
for (int i = 0; i < 10; i++) {
k = new Vector3D(dy2 * dz3 - dz2 * dy3,
upperBounds[binCount-1] = 1.0d;
public static Complex acos(Complex z) {
while (j++ < columns) {
public void testFill() throws Exception {
private static abstract class MinpackFunction implements EstimationProblem {
private static final long serialVersionUID = -1011428905656140431L;
factory = (UnivariateRealSolverFactory) dc.newInstance(
checkLegendre(new Legendre(40), 274877906944l,
(-3457480.0 + 960905.0 * sqrt6) / 551636.0,
assertEquals(10, dist.getPopulationSize());
return SwitchingFunction.STOP;
yMidDots[j] = new double[y0.length];
measurements.add(new FitMeasurement(weight, x, y));
public void testSqrtPolar() {
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);
public boolean reset(double t, double[] y) {
kurtosis = 0.0;
return new RationalNumber(p.subtract(q.multiply(l)), q);
return natural;
this.cumulativeTestPoints = cumulativeTestPoints;
protected double var = 10.00235930735931d;
minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);
= (GraggBulirschStoerStepInterpolator) interpolator;
public static Test suite() { 
private double numeratorDegreesOfFreedom;
double cost = Math.cos(t);
private double delta;
private static final long serialVersionUID = 6762799934117390438L;
new RationalNumber(2l),
double xval[] = { 0.0, 1.0, 0.5 };
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
NonNullRange range = b.getRangeForRow(permutations[i]);
(RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());
Vector3D v2 = applyInverseTo(Vector3D.plusI);
assertTrue(solver instanceof NewtonSolver);
TestUtils.homoscedasticT(sample1, sample2), 10E-11);
double[][] decomp = decompMatrix.getData();
int calls = pb.getCalls();
return divide(new RationalNumber(i));
int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;
public void updateObjects() {
double expA = Math.exp(z.getReal());
assertEquals(10, MathUtils.gcd( a, -b));
updateJacobian();
return res;
empiricalDistribution.getNextValue();
public Complex[] transform2(Complex f[]) throws MathException,
public void setNumericalZero(double numericalZero) {
assertFalse(zero.equals(new Double(0)));
private static final long serialVersionUID = -3961477041290915687L;    
4.0),
return prod.evaluate(values, begin, length);
return (int) (nextDouble() * Integer.MAX_VALUE);
double[] s0 = integrator.integrate(p, -5.0, 15.0);
while (j >= minJ) {
double yMax = f.value(max);
double coeff2 = oneMinusThetaH * (1.0 + theta);
this.theoreticalMinCost   = theoreticalMinCost;
unequalCounts = (countSum1 != countSum2);
public NewtonSolver(DifferentiableUnivariateRealFunction f) {
assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);
expected[i] = (double)smallSampleSize*100/(double)16;
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
throw new IllegalArgumentException("Input table must have at least two rows");
while (i < maximalIterationCount) {
costEvaluations     = 0;
q1 = -w.getX();
Polynomial.Rational Pk1g1 = Pk1.multiply(g1);
checkConstant(random);
coefficients[2]  = new EstimatedParameter("phi", 0.0);
assertEquals(0.5, result[N-1].getImaginary(), tolerance);
private static final long serialVersionUID = -324954393137577531L;
UnivariateRealSolver solver = new LaguerreSolver(f);
public RealMatrix transpose() {
int n = coefficients.length - 1;
remainderDegree = remainder.getDegree();
assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));
sum  = 0;
interpolatedState = new double[dimension];
for (int j = range.begin; j < range.end; ++j) {
outData[row][col] = data[row][col] + d;
((a + (2 * m) - 1) * (a + (2 * m)));
protected DoubleArray da = null;
g0                = Double.NaN;
return new BrentSolver(f);
public TestProblem3(TestProblem3 problem) {
Math.acos(v2.getZ()),
public APSProblem1(double a, double b, double expectedRoot) {
BigMatrix m = new BigMatrixImpl(subTestData);
boolean chiSquareTest(long[][] counts, double alpha) 
assertEquals( "chi-square test statistic", 9.67444662263,
new EstimatedParameter("p2", 2),
555073.354173069, 292.954270581415,
private transient WeightedMeasurementTest testInstance;
double min, max, expected, result, tolerance;
double tolerance = 0.1;
int j         = 0;
lowerData[index]   = 1.0;
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
private double stepControl3;
return minima[0];
public void testRegularizedBetaPositiveZeroPositive() {
TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);
public TestProblem5() {
public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
RationalNumber absAi = RationalNumber.abs(a[i]);
assertFraction(10, 21, b.abs());
Complex result = parse(source, parsePosition);
for (int k = 0; k <= n; k++) {
assertEquals("3x3 Q size", qr.getQ().getRowDimension(), 3);
double tolerance) {
0.14652511111d, 0.195366814813d, 0.195366814813, 
return Math.sqrt((n * sum2 - sum * sum) / (n * (n - 1)));
0.979430303349862, 0.979430303349862,
resultData[resultIndex] = data[resultIndex] + m.data[resultIndex];
m.getRangeForColumn(j));
assertEquals(0, MathUtils.gcd(0, 0));
double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, 
public Fraction abs() {
public void manageMappable(ArraySliceMappable object) {
public static double dotProduct(Vector3D v1, Vector3D v2) {
protected abstract Locale getLocale();
assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);
public boolean containsClass(Class key) {
if (unequalCounts) {
max        = null;
x2 = x > x1 ? x2 : x1;
for (int i = 0; i < inputArray.length; i++) {
interpolatedState[i] = polynoms[0][i]
new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },
throw new IllegalArgumentException("Incorrect row dimension");
public int getSampleSize() {
Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);
assertEquals(3.5f, testDa.getContractionCriteria(), 0);
buildSimplex(generator);
assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);
this.transformer = new NumberTransformer() {
return c.length;
public double getElement(int i, int j) {
implements Serializable{
upperData[i][j] = lu.getEntry(i, j);
assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );
if (numerator==0) {
public abstract double partial(double x, EstimatedParameter p);
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
for (double y = -0.9; y < 0.9; y += 0.2) {
return isAdd ? fraction : fraction.negate();
boolean b1, boolean b2, int i1,
testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, 
assertEquals(5, p.degree());
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
private static final long serialVersionUID = -6049535144225908344L;
public static BigMatrix createBigIdentityMatrix(int dimension) {
assertTrue(Math.abs(sampler.samplePointAt(12).x    - 1.0) < 1.0e-10);
public void testTan() {
this.cumulativeTestValues = cumulativeTestValues;
private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, 
if ((k > 2)
(n+1) * (n+1) - 1.0e-9,
BigMatrixImpl m = new BigMatrixImpl(testData);
Complex z, double epsilon) {
public class DormandPrince853IntegratorTest
standardDeviation = sd;
("Bad mode: " + mode);
public void testCos() {
fHigh  = fc;
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);
assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);
assertEquals( 0.0, f.value( -3.0), tolerance );
correlated[i] = mean[i];
if ((row > 0)||(column > 0)) throw new MatrixIndexException
return (int[]) minIndices.clone();
return data[0].length;
double t = Math.sqrt((Math.abs(a) + z.abs()) / 2.0);
da.addElement( 1.0 );
private static double k14_10 =          57799439.0 / 377055000.0         - b_10;
target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};
private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },
double[] angles = r.getAngles(CardanOrders[i]);
"population size");
return t(StatUtils.mean(sample1), StatUtils.mean(sample2),
sumSq = 0.0;
Rotation r2 = new Rotation(order.getA2(), alpha2);
assertClose("inverse-transpose",m.inverse().transpose(),
double actual = Beta.regularizedBeta(x, a, b);
return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);
max[i]        = x[i];
public abstract class AbstractStepInterpolator
while (sampler.hasNext()) {
return v1 * s;      
Polynomial.Rational Hk2 = (Polynomial.Rational) Hk1.getDerivative();
public HypergeometricDistribution createHypergeometricDistribution(
assertTrue(! iter.hasNext());
assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);
RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
for (int i = 0; i < nSum; i++) {
long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);
double cos = Math.cos(t + a);
minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
for (i = 4; i < N; i <<= 1) {
super(rows, columns, data);
this.safety = 0.9;
distribution.setDegreesOfFreedom((double) observed1.length - 1);
double m0 = -q0;
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
long[] observed1 = {10, 12, 12, 10, 15};
return getInstance().format( c );
v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i]
assertFalse("non-null compared to null", u.equals(t));
testStatistic.t(mu, emptyStats);
((ResizableDoubleArray)da).setExpansionMode(-1);
return coefficients.length - 1;
(6.0 + sqrt6) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,
double t = readBaseExternal(in);
protected int minimalIterationCount;
"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible" },
det *= lu[i][i];
while (x >= 0) {
public class HighamHall54StepInterpolatorTest
rows    = m.rows;
protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};
public void testAddArray() {
endColumn - startColumn+1);
long cumFreq = 0;
double tmp = 0;
while (! lastStep) {
protected double[] errorScale;
long mantissa = bits & 0x000fffffffffffffL;
assertTrue("non-null, compared to null", !statistic.equals(statistic2));
public double[] solve(RealMatrix m, double[] c) 
public interface RealMatrix {
ResizableDoubleArray.ADDITIVE_MODE);
private double x[], y[];
int index = j * cols + permutation[j];
return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));
double[] getUpperBounds();
if (whole != 0) {
f[i+3] = omegaCount > 0 ? E : F;
diag[j] = Math.max(diag[j], jacNorm[j]);
double[] pY = point.y;
double coeff4     = s * (1 + theta + fourTheta2);
if (successes < 0) {
sumLog += Math.log(values[i]);
TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);
public void setRealFormat(NumberFormat realFormat) {
public Rotation(double[][] m, double threshold)
Math.cos(a) * MathUtils.sinh(b));
assertEquals("std err intercept",4.17718672,
assertFalse(m.equals(new BigMatrixImpl(bigSingular)));
public ArrayDataAdapter(double[] in){
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
ra.getNumElements());
TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",
public double evaluate(final double[] values, final double mean) {
private double theoretical() {
Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);
public static double[] scaleArray(double f[], double d) {
if (mantissa == 0x000fffffffffffffL) {
getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,
return lastError;
int dimension = in.readInt();
return previousTime;
assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertClose("identity multiply",m2.multiply(identity),
x3 = 0.5 * (x1 + x2);
verifyDensities();     
public GillIntegratorTest(String name) {
Fraction second = new Fraction(3, 2);
public BinomialDistribution createBinomialDistribution(
private double m2Det = 2.0d;                                 
private int[] cumulativeTestPoints;
0.00001);
Number whole = getWholeFormat().parse(source, pos);
G2 = G.multiply(G);
TestUtils.tTest(sample1, tooShortObs);
lowerBound, upperBound);
currentDegree = mu + 4;
r.applyInverseTo(r.applyTo(u));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
jacobian[k * cols + pk] = cos * rkk + sin * lmDiag[k];
protected double[] internalArray;
suite.setName("Sum Tests");
assertFraction(-1, 2, new Fraction(-0.5));
public double t(double[] sample1, double[] sample2)
outBuffer.append("sum of squares: " + getSumsq() + "\n");
solver.resetFunctionValueAccuracy();
minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },
F[i] = B.subtract(C.multiply(D));
return eDA.getElement(index);
array [start + i] = data [data.length - 1 - i];
public static float sign(final float x) {
public class AbstractRandomGeneratorTest extends RandomDataTest {
private Evaluation left;
private RandomVectorGenerator generator;
RealMatrixImpl m2 = new RealMatrixImpl(testData2);
public void testLogBetaZeroPositive() {
return maxError;
assertEquals("sum", sum, u.getSum(), tolerance);
assertNotNull(ex.getMessage());
public void testIsSingular() {
2.0)
public class SplineInterpolator implements UnivariateRealInterpolator {
double y1 = f.value(x1);
return f.cost(x);
return this.secondMoment;
assertEquals( -1L, MathUtils.indicator( -2L ) ) ;
public void testSignByte() {
u = n / 20.0;
assertFraction(1, 2, new Fraction(2, 4));
r = new Rotation(Vector3D.plusK, Math.PI);
assertEquals(b, MathUtils.lcm(1, b));
double[] x = m.operate(testVector);
nf.setMaximumFractionDigits(2);
randomData = new RandomDataImpl();
return new EulerStepInterpolator(this);
double nextGaussian();
double target[] = {y[0], 1d, 0d, 0d};
double dpj = diag[pj];
public ComplexFormat(NumberFormat format) {
throws ExhaustedSampleException, FunctionException {
private double tolerance = 1E-4;
public class MatrixIndexException extends RuntimeException {
if (n < 3) {
new BigMatrixImpl(bigRowMatrix));
MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns
for (int i=0; i<data.length; i++) {
public void testSqrtImaginaryZero() {
setInverseCumulativeTestValues(getCumulativeTestPoints());
min = -Math.PI; max = Math.PI * (N+1) / (N-1);
int defaultMaximalIterationCount) throws IllegalArgumentException {
Iterator iterator = freqTable.values().iterator();
public class RandomDataImpl implements RandomData, Serializable {
double minStep   = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
if ((Math.abs(e) < tolS) || (Math.abs(fa) <= Math.abs(fb))) {
target = 0;
da.addElement(42.0);
assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},
next = vs.getNext();
double ym = f.value(xm);
double e = c * (n * sum2[k] - sum[i] * sum[j]);
double c = Math.exp (t0 - t);
protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};
m.preMultiply(new RealMatrixImpl(bigSingular));
RealMatrix x = new RealMatrixImpl(solver.solve(c));
for (int i = 0; i < col; i++) {
n * r1.getQ2(), n * r1.getQ3(),
public float nextFloat() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
private static final double e2_10 =           -734375.0 / 4826304.0;
public void testSignInt() {
assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));
new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },
1.0
if (location < 0) {
suite.setName("QRDecompositionImpl Tests");
public void testTwoSampleTHomoscedastic() throws Exception {
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),
assertEquals("4x3 R size", qr.getR().getRowDimension(), 4);
return max.getResult();
public void setValue (double value) {
"  Endpoints: [" + lower + "," + upper + "]" + 
MatrixFactory.buildMatrix(0, 2, null, 1, 1);
assertEquals(3.75, p.evaluate(d), 1.0e-5);
verifySequence(min, startValue, max);
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
this.windowSize = windowSize;
checkArray(counts);
sampleStats.getN());
return value;
setParRelativeTolerance(1.0e-10);
long kP1 = k + 1;
for (int l = 0; l < sequence[k]; ++l) {
for (int i = 1; i < x.length - 2; i++) {
SimpleRegression regression = new SimpleRegression();
Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);
runner.doRun(CholeskySolverTest.suite());
public void testsinhNull() {
FunctionEvaluationException {
z = negInfInf.divide(Complex.ONE);
assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
double x20 = m[2][0];
for (int i = 0; i < interpolatedY.length; ++i) {
new PolynomialSplineFunction(new double[] {0}, polynomials);
checkValue(f1, "0");
double omega = coefficients[1].getEstimate();
return p.signum() < 0;
currentT += h;
new RealMatrixImpl(testData2).getDeterminant();
public SquareMatrix getInverse(double epsilon)
MatrixUtils.createRealMatrix(null);  // null
assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);
Complex dminus = G.subtract(ComplexUtils.sqrt(delta));
if (Math.abs(yMax) <= functionValueAccuracy) {
double   largest       = simplex[n].cost;
for (int i = 0; i < c.getRowDimension(); ++i) {
freqTable = new TreeMap();
assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],
for (int i = 0; i <= degree; ++i) {
public class GeneralSquareMatrix
++upperElements;
NumberFormat old = format.getWholeFormat();
GeneralMatrix b = new GeneralMatrix(6, 3);
void incrementAll(double[] values, int start, int length);
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
double minStep   = 0;
double getResult() throws IllegalStateException;
for (i = 0; i <= n; i++) {
double scalRelativeTolerance = scalAbsoluteTolerance;
if (denominator.equals(new Complex(0.0, 0.0))) {
if (Double.isInfinite(p2) || Double.isInfinite(q2)) {
private static final long serialVersionUID = -2083829252075519221L;
ageU.getMean(), 0.001 );
assertTrue(handler.getLastError() < 2.0e-13);
this(new TDistributionImpl(1.0));
new DormandPrince853StepInterpolator(),
checkPolynomial(p1, "2 - 7 x");
public void testFormatImproperNegative() {
double sigma = 0.1d + Math.random();
if (a3 != 0) {
if (c < (1.0e-10 * u1u1 * u2u2)) {
double[] out = new double[length];
scale = standardDeviation[i] * standardDeviation[i];
assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);     
-0.232991545843829,  1.26042932089163,
protected DistributionFactory() {
if (c.compare(v, freqTable.firstKey()) < 0) {
assertEquals(1, f.getDenominator());
public class PolynomialFractionTest
9, 12.3 };
LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {
implements SampledFunction {
TestProblem3 pb = new TestProblem3(0.9);
assertEquals(Integer.MIN_VALUE+2, f.getNumerator());
public class TestBean {
Complex z = new Complex(3, 4);
assertEquals("three pct",0.5,f.getPct(threeL),tolerance);
return Math.sqrt(dx * dx + dy * dy);
public class GaussianRandomGenerator implements NormalizedRandomGenerator {
"org.apache.commons.math.stat.inference.TestFactoryImpl");
double dx2 = v2x - u2.getX();
simplex = new PointCostPair[n + 1];
assertTrue( "Mean of n = 1 set should be value of single item n1",
double t0 = interpolator.getPreviousTime();
double[] roots20 = {
unscaled = Math.floor(unscaled);
u.addObject("12.5");
mapper.manageMappable(scalar1);
assertTrue(Math.abs(h) < minStep);
new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },
Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),
double[] roots2To11 = {
newStep = false;
double degreesOfFreedom = 0;
min = 0; max = 0.5; expected = 11.0/768;
accum3 += Math.pow((values[i] - mean), 4.0);
protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{
foundLimit = false;
product.increment(Double.POSITIVE_INFINITY);
checkLaguerre(new Laguerre(3), 6l, "6 - 18 x + 9 x^2 - x^3");
return densityTestPoints;
private int[] densityTestPoints;
p.setQuantile(50);
data[index] += s.data[index];
this.scale = scale;
protected int[] getCumulativeTestPoints() {
BeanTransformer b = new BeanTransformer(name);
public class Sqrt implements Evaluation, Serializable {
double corr12 = o[1][2] - m[1][2];
private final String pattern;
for (int i=1; i < cumulativeTestPoints.length; i++) {
return new TestSuite(GillIntegratorTest.class);
double divdiff[], a[], denominator;
private void initializeArrays() {
double j2  = -v[i] * x1 / tmp;
firstIteration = false;
s = ort[0][0] - ort[1][1] - ort[2][2];
Double.MIN_VALUE);
public class VectorialCovarianceTest
error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];
regression.getSlopeConfidenceInterval(1);
public void testCreateBigMatrix() {
throw new IllegalArgumentException("Dataset x values must be strictly increasing.");
if (n >= maxIterations) {
+ (p - 1) * (2 * p - 1) / 300.0);
MathException ex = new MathException(pattern, arguments, cause);
assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));
coefficientsComputed = true;
return getCumFreq(((Integer) v).longValue());
public void testLogGammaZero() {
boolean isLast)
if (f[0] != 0.0) {
public APSProblem19(int n, double a, double b, double expectedRoot) {
public abstract class SquareMatrix
public void setFunctionValueAccuracy(double accuracy) {
begin         = range[0];
public RationalNumber add(long l) {
FunctionEvaluationException ex = new FunctionEvaluationException(0.0);
if (dot < ((2.0e-15 - 1.0) * normProduct)) {
public interface ContinuousDistribution extends Distribution {
public void testPerfectNegative() throws Exception {
simplex[0] = original[0];
public double homoscedasticT(double[] sample1, double[] sample2)
f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);
int nextColumn = -1;
return (Math.exp(x) + Math.exp(-x)) / 2.0;
for (int j = startColumn; j <= endColumn; j++) {
double expected = 0.999;
public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {
assertEquals( "The number of elements should now be 1001, it isn't", 
private DummyFitter fitter;
throws SingularMatrixException {
assertEquals( 3.0, sample.getMean(), 1.0e-12);
ConvergenceException ex = new ConvergenceException();
x = spline.value(-1.5);
public void doSort() {
for (int i = k + 1; i < solvedCols; ++i) {
private static final String methodName = "Dormand-Prince 5(4)";
-.21026444172410488319e-3,
private static UnivariateRealSolverFactory factory = null;
double expected = (i == j) ? value : 0.0;
public double evaluate(final double[] values)  {
this.getGeometricMean()) &&
public Complex[] inversetransform(Complex f[]) throws MathException,
Iterator iterB = sb.getIntervals().iterator();
int k    = r.begin;
assertEquals(1, first.compareTo(second));
11, 12, 13, 14, 15, 16, 17, 18, 19,  20,
d012 = (d12 - d01) / (x2 - x0);
suite.setName("Frequency Tests");
protected URL url = null; 
return discarded;
assertTrue(new Hermite().isOne());
this.vecRelativeTolerance  = null;
if ((rows != l.rows) || (columns != l.columns)) {
implements SampledFunctionIterator, Serializable {
distribution.setMedian(expected);
System.arraycopy(
6.313752, 3.077684});
assertEquals(bounds[99], 1.0, 10e-12);
extends TestProblemAbstract {
setPropertyName(propertyName);
public void testSqrt1z() {
r0 = r1;
public void setBound(boolean bound) {
verifyInterpolationArray(x, y);
if (x >= 0.0) {
NonNullRange r1 = new NonNullRange(2, 7);
PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];
return random;
size += object.getStateDimension();
private Complex negInfNaN = new Complex(negInf, nan);
public void testCreateBigIdentityMatrix() {
f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());
mean = new double[order];
ComplexUtils.tan(null); 
d  = b - a;
private static final long serialVersionUID = -893367988717182601L;
y0 = x < x1 ? y0 : y1;
if (denominator < 0) {
throws ArrayIndexOutOfBoundsException, FunctionException;
statistic.increment(testArray[i]);
loadStats("data/PiDigits.txt", u);
assertEquals( "Geometric mean not expected", 2.213364, 
this.px = px;
ret = getMean();
double corr00 = o[0][0] - m[0][0];
int j     = 0;
double[] value = f.valueAt(midPoint + halfStep * weightedRoots[j][1]);
checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));
assertEquals(1234, u.getWindowSize());
statistic.hashCode(), statistic2.hashCode()); 
fail("arrays have different lengths, IllegalArgumentException expected");
public static double t(double mu, double[] observed)
double cumPct = 
private static Variance variance = new Variance();
private EstimatedParameter p1;
private double[][] yDotKLast;
new RealMatrixImpl(colMatrix));
pos.setErrorIndex(startIndex);
protected PolynomialFunction dp = 
RationalNumber f = new RationalNumber(2l, 4l).invert();
ra.addElement(1.0);
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
-29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2
public void testConstructorMessage(){
public SkewnessTest(String name) {
0.239171018813509,  0.398885290346268,
vs.setMu(2);
private void rescale(double[] y1, double[] y2, double[] scale) {
public AdaptiveStepsizeIntegrator newHighamHall54Integrator(double minStep,
public UnivariateStatistic getUnivariateStatistic() {  
new EstimatedParameter[] { x[0], x[1] },
q0 = 1.0;
double x = MathUtils.factorialDouble(test);
public void addToSelf(Interval i) {
4427.0,  3820.0,  3307.0,  2872.0                  
max = (max > values[i]) ? max : values[i];
v1 = v1.subtract(v2);
moment = new FourthMoment();
return map.values();
f= new Fraction(-Integer.MAX_VALUE, 1);
matrix = new RealMatrixImpl(testData3x4);
for (int i = 0; i < nRows; i++) {
checkPolynomial(new Chebyshev(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6");
double[] sample1 = {1d, 3d};
double[] x = new double[decomp.length];
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
return randomGenerator.nextDouble();
protected double tolerance = 10E-12;
System.arraycopy(c, 0, this.c, 0, c.length);
public void testSetNumberOfElements() {
assertFalse(m.equals(mt));
toAppendTo.append('(');
if (n <= 0 ) {
public final class SimpsonIntegratorTest extends TestCase {
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
suite.setName("StatUtil Tests");
case 0 :
private double khi;
public class FirstMoment extends AbstractStorelessUnivariateStatistic 
private       boolean ignored;
return newBrentSolver(f);
iterateSimplex();
if (a == 0.0 && b == 0.0) {
h                 = interpolator.h;
f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];
int idx  = i * columns + k;
double expected = 1.0e-2; 
BigMatrix getColumnMatrix(int column) throws MatrixIndexException;
implements ArraySliceMappable {
sequence[k] = 2 * (k + 1); 
ret =
File tmp = null;
double h     = 0;
verifySame(dist, dist2);
assertEquals(f.degree(), 1);
assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);
public BigMatrixImpl() {
protected IntegerDistribution getDistribution() {
assertEquals(137.0, p[1].getEstimate(), 1.0e-8);
double x2, double y2)
double theta2 = theta * theta;
double stdDev = Double.NaN;
work1[pj] = s;
return new TestSuite(VectorialMeanTest.class);
public Skewness(final ThirdMoment m3) {
ya = ya * a + coeffs0[i] / (i + 1);
checkValue(f1.subtract(f1), "0");
return makeCumulativeTestPoints();
double denominatorDegreesOfFreedom) {
protected double tolerance = 1.0e-12;
BigMatrix bs = new BigMatrixImpl(bigSingular);
35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0
return ((Comparable)o1).compareTo(o2);
0.17171914751951,   0.13825715505682,   3.4657359020854e-2,
private int[]                 permutations;
f = new Fraction(Integer.MIN_VALUE, 1);
return name;
BigInteger w = t.divide(BigInteger.valueOf(d2));
TestUtils.chiSquare(counts), 1E-9);
assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);
protected double[] fst(double f[]) throws MathException,
TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);
private static double b_10 =        -734375.0 / 4826304.0;
protected void setInitialConditions(double t0, double[] y0) {
private double   max;
public LegendreTest(String name) {
assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);
costPerStep[k] = costPerStep[k-1] + sequence[k];
throw new ExhaustedSampleException(function.size());
double fcMean = 0.0;
private synchronized void expandTo(int size) {
StatUtils.max(da.getElements()),
private static final long serialVersionUID = 6751309484392813623L;
int c = 77;
+ e.getMessage(),
solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); 
suite.addTest(BrentSolverTest.suite());
Matrix m = MatrixFactory.buildMatrix(3, 4, null, 0, 0);
assertFalse(map.containsClass(TransformerMapTest.class));
assertEquals( 3.0, f.value( 1.5), tolerance );
assertTrue("non-empty stat should have different hashcode from empty stat",
jacobian[i][j] = i * (j + 1);
implements BinomialDistribution, Serializable {
polynoms[2][i] = aspl;
double yOnScale2 = 0;
suite.addTest (org.spaceroots.mantissa.quadrature.vectorial.AllTests.suite ());
public FFPIterator(AbstractCurveFitter.FitMeasurement[] measurements) {
double[][] bData = b.getDataRef();
if (this.getColumnDimension() != m.getRowDimension()) {
String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";
public void testEqualsTrue() {
assertEquals(sigma, s1.getResult(), 1E-14);
public void add(double[] points) {
Complex z = new Complex(-3.0, 4);
this.x = a * u.x;
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);
if (Math.abs(dx) <= tolerance) {
return tTest.homoscedasticT(sampleStats1, sampleStats2);
return 2 * dimension;
int pj = permutation[j];
Fraction rhs = (Fraction)other;
|| ((! forward) && (currentT + h < t))) {
private DomainObject b3;
work3[pj] = s;
assertTrue(m1.getRows() == m2.getColumns());
0.183747831178711, 0.0806471004038253,
NumberTransformer expected = new DefaultTransformer();
public class Interval {
SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();    
0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,
public void setElement(int i, double value) {
public VectorialValuedPair samplePointAt(int index)
double[] test4 = {1,2,3,4,100};
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
private static final long serialVersionUID = 7910082423686662133L;
RealMatrix expected = MatrixUtils.createRealMatrix
("Invalid iteration limits: min=" + minimalIterationCount +
assertEquals(var,v.getResult(),tolerance);
for (int j = 0; j < l.getColumns(); ++j) {
private boolean coefficientsComputed;
public static FractionFormat getImproperInstance() {
permutations[i] = i;
gamma *= betak;
Polynomial.Rational Lk2g2 = Lk2.multiply(g2);
specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, 
data[index] -= m.data[index];
minpackTest(new WatsonFunction(12, 0.0,
if (u instanceof DescriptiveStatistics) {
private static final long serialVersionUID = -555440800213416949L;
double a3, Vector3D u3) {
sum += jacobian[index] * work1[permutation[i]];
ByteArrayOutputStream bos = new ByteArrayOutputStream();
TestProblemAbstract pb = new TestProblem5();
fail("Expecting IllegalStateException");
assertClose("inverse multiply",mInv.multiply(m),
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
private static class Osborne2Function extends MinpackFunction {
assertEquals("1 count", 3, f.getCount(1));
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
m.setSubMatrix(testData,1,1);
if (knots.length - 1 != polynomials.length) {
assertTrue(Double.isNaN(mean.getResult()));
public void testConstructorDouble() {
public static ComplexFormat getInstance() {
public abstract class AbstractIntegerDistribution extends AbstractDistribution
previousEventTime = Double.NaN;
solver.setFunctionValueAccuracy(expected);
public MathException() {
Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
5.47722557505166, 0.00118311459212420,
VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);
assertEquals(expected, matrix);   
double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };
8.8,
assertTrue(m.getColumns() == 4);
public BeanListUnivariateImpl(List list, String propertyName) {
package org.apache.commons.math.function.simple;
double dz1 = v1z - u1.getZ();
private double[] yTmp;
v1.x * v2.y - v1.y * v2.x);
double normProduct = u.getNorm() * v.getNorm();
double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))
Matrix result;
implements RandomVectorGenerator {
double step = Math.abs(interpolator.getCurrentTime()
newA[i] = RationalNumber.ZERO;
fail("IllegalArgumentException");
ComplexUtils.pow(Complex.ONE, null); 
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));
setResult(z.getReal(), iterationCount);
maximalIterationCount = defaultMaximalIterationCount;
public double value(double x) throws FunctionEvaluationException {
public void testLargeDegreesOfFreedom() throws Exception {
return expansionMode;
return 37 * (37 * 17 + getNumerator()) + getDenominator();
-13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,
m = new BigMatrixImpl(testData2);
resultData[resultIndex] = data[index];
private static double c16    = 7.0 / 9.0;
new EstimatedParameter("p1", 1),
void setElement(int index, double value);
double[][] bp = new double[nRowB][nColB];
assertTrue(p2.isBound());
public UnivariateRealSolver newBisectionSolver(UnivariateRealFunction f) {
public PolynomialFraction(long l) {
a = b;
if (denominator == 0l) {
public void testMinpackOsborne1()
Fraction threeFourths = new Fraction(3, 4);
binUpperBounds[0] = min + delta;
((a > lowerBound) || (b < upperBound)));
assertTrue(result.getRows() == b.getRows());
sumSq += (((double) counts[row][col] - expected) * 
return new TestSuite(DiagonalMatrixTest.class);
double[] mean = stat.getResult();
public void testMin() {
6.0/7.0, 1.0, 1.0
setDistribution(new ChiSquaredDistributionImpl(0.1d));
this.parRelativeTolerance = parRelativeTolerance;
int a0 = (int)Math.floor(r0);
public synchronized double[] getElements() {
assertTrue(Math.abs(result.getElement(i, 2) - 0.0)        < 1.0e-10);
return r / points.size();
sumY += y;
return fft(f, false);
new EstimatedParameter("p0", 0),
Complex expected = new Complex(-6.58066, -7.58155);
assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);
for (int i = 0; i < transposed.getRows(); ++i){
2.34369463894115
delta = (xNorm == 0)
return (long)doubleValue();
protected int largeSampleSize = 10000;
public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,
return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
private double lastError;
f.addValue(obj1);
outData[row][col] = data[row][col] - m.getEntry(row, col);
assertTrue(Math.abs(d00) < 6.0e-6);
public UnivariateStatistic getUnivariateStatistic() {        
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
this.fsal       = fsal;
public Object clone() {
if ((Math.abs(actRed) <= 2.2204e-16)
assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-13);
double coefficients[] = { -1.0, 4.0 };
Complex expected = new Complex(Double.NaN, Double.NaN);
StatUtils.sum(values, 2, 3);
double x[] = { 0.0, -1.0, 0.5 };
private SummaryStatistics summaries;
Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);
public void testAngular() {
Vector3D v1 = new Vector3D(2, -1, 4);
double getProbabilityOfSuccess();
if (maximalIterationCount > 32) {
public void reinitialize(FirstOrderDifferentialEquations equations,
problems.add(new APSProblems15To17(n16[k], 1.0, 0.0, 5.0, 1.0));
checkMatrix(m3, new BilinearPattern(101, 0));
assertEquals("r", -0.94663767742, regression.getR(), 1E-10);
sample.add(points[i]);
0.032052192917937,
"The Poisson mean must be positive");
assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());
implements Serializable {
assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);
public double[] getInterpolatedState() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public static double logBeta(double a, double b) {
in = null;
h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0
public class EstimatedParameter
return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);
public IntervalsList(Interval i) {
(empiricalDistribution.getSampleStats().getStandardDeviation(),
public void testLocalMaximumBackward() {
private void testProbability(double x, double a, double b, double expected) throws Exception {
TestUtils.chiSquare(counts3);
public UnivariateRealFunction derivative() {
d = xm;
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());
public final class DescriptiveStatisticsTest extends TestCase {
return Math.pow(getMean(), x) / 
z = z.subtract(N.divide(denominator));
private String imaginaryCharacter;
return new TestSuite(ChebyshevTest.class);
checkValue(new RationalNumber(999999l, 307692l), "13/4");
double[] solution = coefficients.solve(constants);
TestUtils.tTest(sampleStats1, (SummaryStatistics) null);
if ( !isValidCoordinate( row, 0 ) ) {
for (int j = 0; j < hexString.length(); j++) {
public void testAddValue() {
this.prototype = prototype;
public abstract double getMean();
assertTrue(Math.abs(d11) < 6.0e-6);
("std dev", 1.0173699343977738, stats.getStandardDeviation(), 
public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {
permutation[col] = temp;
new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);
URL url = vs.getValuesFileURL();
protected boolean isSequence(double start, double mid, double end) {
double c3 = sx2 * sy2 - sxy * sxy;
public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,
return lower + (int) (sec.nextDouble() * (upper - lower + 1));
assertTrue(Double.isNaN(MathUtils.log(-1, 1)));
assertClose("scalar add",new BigMatrixImpl(testDataPlus2),
new PolynomialFraction(p.multiply(f.p), q.multiply(f.q));
TestUtils.assertEquals(expected, actualP, 10e-15);
testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);     
return Math.cos(omega * x + phi);
assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);
if (denominator == 0.0) {
assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);
h = t - currentT;
assertEquals("mean", StatUtils.mean(values), u2.getMean(), tolerance);
test++;
u.getStandardDeviation() == 0);
return suite;
private boolean useInterpolationError;
public static double geometricMean(final double[] values, final int begin,
double  hNew             = 0;
assertEquals(0.0,f.value(0.0), interpolationTolerance);
copy.addToSelf(list2);
if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
"Matrix must have at least one column."); 
assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);
if (p < 0.0 || p > 1.0) {
++rank;
tolerance = Math.abs(expected * integrator.getRelativeAccuracy());
double dx = 1;
public void testGridTooFine() throws Exception {
if (incMoment) {
Double.toString(Math.abs(h))
Double input = new Double(expected);
foundLimit = true;
public void testN0andN1Conditions() throws Exception {
private static UnivariateStatistic sumLog = new SumOfLogs();
firstGuessNeeded = true;
double h1 = current.x - previous.x;
assertEquals("Column1", mColumn1, 
public RealMatrix getRootMatrix() {
testStatistic.test(nullArray, 0, 1);  // null array
assertTrue(solver.getIterationCount() <= 5);
assertEquals(2.5d, percentile.evaluate(specialValues), 0);
x00 = o[0][0];
return (i == j) ? 2.0 : 1.0;
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },
assertEquals(1.4,f.value(1.4), interpolationTolerance);
TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);
assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);
public MathConfigurationException() {
getSampleSize());
return dimension1;
public void selfAdd(SquareMatrix s) {
m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); 
dist = Math.abs(z - x[i]);
private long n;
Polynomial.Rational Pk2g2 = Pk2.multiply(g2);
std = Double.NaN;
private boolean denseOutput;
StepInterpolator si = (StepInterpolator) steps.get(index);
double v2[] = vs.fill(3);
if (mean < 0.0)  {
public EmpiricalDistributionTest(String name) {
assertFraction(1, 2, new Fraction(1, 2));
remainder = remainder.subtract(monomial.multiply(divisor));
assertEquals(big, MathUtils.subAndCheck(big, 0));
for (int k = rank - 1; k >= 0; --k) {
public void testIntValue() {
assertEquals(expected, MathUtils.sinh(x), 1.0e-5);
protected AbstractStepInterpolator(double[] y, boolean forward) {
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
assertTrue(Math.abs(m2.getDeterminant(1.0e-10) + 0.9999999) < 1.0e-10);
private MatrixFactory() {
x.setElement(0, 1, epsilon);
assertEquals(0.0, ex.getArgument(), 0);
double compareValue = 0.0d;
package org.apache.commons.math.random;
double max = Double.NaN;
return new Max();
private static boolean isStrictlyIncreasing(double[] x) {
if (x < domain[0]) {
p2 = null;
public double getDelta() {
a.setElement(0, 2,   0.0);
public void load(double[] in) {
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
findBin(min, inputArray[i], delta));
public class MultiDirectionalTest
Complex c = new Complex(Double.NaN, Double.NaN);
case ConvergenceChecker.LOW :
if (object instanceof BigMatrixImpl == false) {
"aucun des {0} points de d\u00e9part n''aboutit \u00e0 une convergence"  },
double maxColSum = 0;
throw new ArrayIndexOutOfBoundsException();
interpolator.setInterpolatedTime(0.5*(prev + curr));
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
u.addValue( 1.0 );
public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
public double getSumsq() {
throw new IllegalArgumentException("hole between time ranges");
double q2q2  = q2 * q2;
this.q3 = q3;
public void testVectorialProducts() {
public double cumulativeProbability(int x) throws MathException {
testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.forwardDifferenceDerivative(function, 1.0e-5);
private double[] lmDir;
for (int i = 0; i < da.getNumElements(); i++) {
double[][] subMatrixData = subMatrix.getDataRef();
BigInteger newQ = q.multiply(r.p);
protected double[] getResiduals() {
public void selfSub(UpperTriangularMatrix u) {
ra = new ResizableDoubleArray();
setBeta(beta);
System.arraycopy(data[i], 0, out[i], 0, data[i].length);
error1        += ratio1 * ratio1;
private String propertyName = null;
public abstract boolean homoscedasticTTest(
while (iter.hasNext()) {
dk = 1.0;
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
dz2 * dx3 - dx2 * dz3,
public Complex conjugate() {
alg = MessageDigest.getInstance("SHA-1");
for (int k = 0; k < 12; ++k) {
intervals = new ArrayList();
public Polynomial multiply(RationalNumber r) {
return value.byteValue();
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);
work1[i] += jacobian[index] * dirJ;
fail("Can not have negative beta.");
fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
hNew = filterStep(scaledH, nextIsLast);
assertEquals(loop.getStandardDeviation(), direct.getStandardDeviation(),
while (j < range.begin) {
if (observed1[i] == 0 && observed2[i] == 0) {
double n = 2.0 * i - 5.0;
super("Convergence failed", new Object[0]);
TestUtils.tTest = tTest;
private static class HarmonicFunction {
Rotation r = new Rotation(EulerOrders[i],
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
public long getCumFreq(Object v) {
public abstract double apply(UnivariateStatistic stat);
int tmp            = permutations[k];
public static double t(double[] sample1, double[] sample2)
0.0
assertEquals(0, new Polynomial.Double(0.0, 0.0, 0.0).getDegree());
result = result * 31 + MathUtils.hash(getGeometricMean());
return new Vector3D(a * x, a * y, a * z);
t[0][0] = qtrap.stage(min, max, 0);
"pas minimal ({0}) atteint, l''int\u00e9gration n\u00e9cessite {1}" },
b.setElement(1, 0, -9.0);
assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);
double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };
u.hashCode() != t.hashCode());
public void testWindowing() {
public DiagonalMatrix(int order, double[] data) {
public class ConvergenceExceptionTest extends TestCase {
assertEquals(5, c.getNumerator());
assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);
return (double) getCount(v) / (double) getSumFreq();        
checkVector(v2.add(v1), new Vector3D(-5, -2, 1));
x20 = o[2][0];
closeReplayFile();
System.arraycopy(internalArray, 0, array, start, internalArray.length);
public PolynomialFraction subtract(PolynomialFraction f) {
protected FirstMoment stat;
transformer.transform(f, -1, 1, 0);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);
ContinuedFraction fraction = new ContinuedFraction() {
ComplexUtils.log(infInf), 10e-12);
public void testFormatZero() {
out.writeInt(currentDegree);
double v2, double n1, double n2)  {
private void qrDecomposition() {
public MidpointIntegratorTest(String name) {
ComplexUtils.log(negInfOne), 10e-12);
Complex c = new Complex(30.233, 0);
assertTrue(f.toString().equals(reference));
public SymetricalMatrix buildMatrix(int order,
private static double center(double a, double ref) {
array3 = new MappableArray(new double[3]);
public Rotation applyInverseTo(Rotation r) {
+ " integration needs {1}",
public void printStackTrace() {
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
assertEquals( f.value( 0.0), c[0], tolerance );
Polynomial.Rational a = p;
jacobian[i] = new double[n];
private static final long serialVersionUID = -6337346779577272307L;
while (x0 != x1) {
this.y = a * u.y;
if (num == null) {
ret = -((a + m) * (a + b + m) * x) /
if (! a[i].isZero()) {
sin = cos * tan;
return sumXY / sumXX;
protected double[] testVector2 = {1,2,3,4};
m = new RealMatrixImpl(detData2);
checkValue(new RationalNumber(1l, 6l).subtract(new RationalNumber(2l, 6l)),
scalar2 = null;
BigDecimal bd[] = new BigDecimal[v.length];
public class CholeskySolver {
return evaluate(a, c, z);
da.getElement(56),
void setScale(double beta);
long[] observed = {0,0,0,0,0,0,0,0,0,0};
F[1] = 0.5 * (f[0] - f[1]);
p0 = p1;
double c = 1.0 / (n * (n - 1));
throw new ArrayIndexOutOfBoundsException("cannot set elements"
handler.handleStep(interpolator, lastStep);
Polynom fitted = new Polynom(fitter.fit());
TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);
private static final long serialVersionUID = 3592505328858227281L;
int kDiag = k * cols + pk;
double diff[] = {0d, -1d, -1d, 2d};
public boolean isBound() {
min = 0.0; max = 2.0; expected = 0.5;
RealMatrix n = new RealMatrixImpl(matrixData2);
assertEquals(2d, testDa.getElement(1), 0);
public static double min(final double[] values) {
return unknownDistributionChiSquareTest;
private static final long serialVersionUID = -3187229691615380125L;
public class BrentSolver extends UnivariateRealSolverImpl {
96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,
void setMinimalIterationCount(int count);
private void checkValue(PolynomialFraction f, String reference) {
assertEquals("Row0", mRow0, 
public abstract double[] getValues();
Long count =  (Long) freqTable.get(v);
public void testRegularizedBetaPositivePositiveZero() {
public void testCompose() {
return randomGenerator.nextInt(n);
);
p1 = new Polynomial.Double(2.0, -4.0, 1.0);
assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), 
+ de.getMessage());
if (a1 != 0) {
ComplexUtils.exp(null); 
int x0, int x1, int dx, int n, int m, int k)
Serializable {
m4 = 0.0;
q2 = inv * (ort[2][0] - ort[0][2]);
public void testRUpperTriangular() {
actual = Erf.erf(-x);
u.getVariance() == 0);
public void testAsinInf() {
return res.toString();
return tolerance;
v2 = 2 * nextDouble() - 1; 
return geometricMean.evaluate(values, begin, length);
testStatistic.chiSquareDataSetsComparison(
for (int i = 0, index = pj; i <= j; ++i, index += cols) {
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.415) < 1.0e-10);
assertEquals(0.0, result[1].getReal(), tolerance);
setPropertyName(property);
assertEquals( "Number of elements should be 11", 11, da.getNumElements());
return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) /
assertEquals(
q3 = inv * (ort[2][1] + ort[1][2]);
if (this.isSingular()) { // side effect: compute LU decomp
setAge( age );
private double median = 0;
return resetDerivatives;
for (int i = coeffs.length - 2; i >= 0; --i) {
public class BasicSampledFunctionIterator
costPerTimeUnit[0] = 0;
int      lowerElements = 0;
public double getScale() {
private final double q0;
double x06 = parameters[5].getEstimate();
VectorialMean meanStat = new VectorialMean(mean.length);
private static final long serialVersionUID = 4962041891152128524L;
public void testTanhNaN() {
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
double transform(Object o) throws MathException;
public NormalDistributionTest(String arg0) {
assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
minStep = 0;
ret = getAlpha() * getBeta();
r[row][col] = qr[row][col];
double[][] covData = covariance.getDataRef();
factory.newNewtonSolver(null);
private StringBuffer formatDouble(double value, NumberFormat format,
assertEquals("1 count", 3, f.getCount(new Integer(1)));
m.getRowMatrix(4);
public Evaluation evaluate(EvaluationContext context) throws EvaluationException {
public CertifiedDataTest(String name) {
return forward;
q3 = composed.q3;
public class LevenbergMarquardtEstimator implements Serializable, Estimator {
public Vector3D getA1() {
return n * (a - n);
assertTrue("Std should be zero (n = 1)", 
coeff1 += work1[j] * work1[j];
q3 = inv * (ort[0][2] + ort[2][0]);
secRand.setSeed(seed);
return in.readDouble();
public void selfAddWAAt(double w, double[] a) {
return oPoMn4 * x - oMnx2 * oMnx2;
("largest n for factorialDouble = " + (test - 1) );
ComplexFormat complexFormatJ = null;
protected double std = Math.sqrt(var);
public class NevilleInterpolator implements UnivariateRealInterpolator,
public abstract void setNumberOfSuccesses(int num);
public double getMinStep() {
public double getDegreesOfFreedom() {
data[index] -= u.data[index];
int i = a.length - 1;
checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));
return new Median();
RealMatrix lu = m.getLUMatrix();
ComplexUtils.polar2Complex(-1, 0);
return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;
throw new MatrixIndexException("matrix dimension mismatch");
double threshold = normProduct * 0.9999;
u = rand.nextDouble();
public void testMulMKO() {
public static Interval add(Interval i1, Interval i2) {
internalArray = new double[dimension];
return new ForwardDifferenceDerivative(function, h);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
double   x07 = parameters[6].getEstimate();
public AdaptiveStepsizeIntegrator newDormandPrince54Integrator(double minStep,
RationalNumber ck     = (RationalNumber) l.get(startK);
if (isNaN()) {
private static double c14    = 1.0 / 10.0;
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
yDot[i] = -y[i];
!testStatistic.tTest(sampleStats1, sampleStats2, 0.1));
eDA.addElement(v);
public void testInvalidDimensions() {
assertTrue("cleared stats should be equal", statistic.equals(statistic2));
for (int k = 0; k < cols; ++k) {
d.setElement(3, 3, 0.0);
public void testSelfAddWAAt() {
0.122430604321144,
assertTrue(Math.abs(pair2.y[1] - pair1.y[1]) < 1.0e-10);
return (chiSquareTest(expected, observed) < alpha);
binStats.clear();
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
public void load(File file) throws IOException {
public synchronized void setElement(int index, double value) {
double sum2 = 0d;
suite.addTest (org.spaceroots.mantissa.quadrature.scalar.AllTests.suite ());
int defaultMaximalIterationCount,
for (int j = r.begin, index = i * columns + r.begin; j < r.end; ++j) {
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
interpolator = rki;
if (n++ == 0) {
public void setContractionCriteria(float contractionCriteria) {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j]
suite.setName("Mixed List Tests");
if (qr[minor][minor] != 0.0) {
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
for (j = n-2; j >= 0; j--) {
assertTrue(Double.isNaN(skew.getResult()));
exponent | (mantissa - 1));
return x * x - Math.pow(1 - x, n);
if (!this.isSquare()) {
private double[] productsSums;
eye = MatrixUtils.createRealIdentityMatrix(3);
public void testCoshNull() {
if (j < i) {
for (int i = 0; i < p.length; ++i) {
this.c = new double[c.length];
min = 3.0; max = 6.0; expected = 4.0;
for (int j = 0; j < p.getDimension(); ++j) {
long[][] counts4 = {{40, 22, 43}};
return (isSequence(min, z.getReal(), max)) &&
assertTrue(maxError < 5.0e-11);
Interval copy = new Interval(i1);
public class NormalDistributionImpl extends AbstractContinuousDistribution 
assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
assertEquals(1, c.getNumerator());
return new Complex(MathUtils.sinh(a) * Math.cos(b),
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Vector3D v2 = new Vector3D(-2, 0, 2);
String source = "1 2 / 3";
54980371265625.0/176692375811392.0,
asDouble(m.operate(asBigDecimal(testVector)));
maximalIterationCount);
protected SumOfLogs stat;
assertEquals(0.5f, first.floatValue(), 0.0f);
checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(-5l, 2l)),
checkValue(p2.getEstimate(), 2.0);
PoissonDistribution dist = new PoissonDistributionImpl(100);
double   x2 = parameters[1].getEstimate();
fail("bad sample for set size = 1, sample size = 1");
if (Math.abs(x1 - x0) <= absoluteAccuracy) {
checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(2l, 5l)),
if (this == other) { 
Double.toString(parRelativeTolerance)
3.6171081789041e-3, 4.1087291849640e-4, 2.5989575892908e-5,
RationalNumber[] a = new RationalNumber[degree + 1];
assertEquals(d1.getSampleStats(), d2.getSampleStats());
sampleStats2.addValue(sample2[i]);
double s = 1;
if (i < n) {
sumLog = 0.0;
TestUtils.t(mu, (SummaryStatistics) null);
Random randomizer = new Random(1248788532l);
index       = 0;
private static ResourceBundle cachedResources = null;
x + 1.0,
-1718875.0 / 39484.0,                      58000000.0 / 602131.0,
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
private int    maxIterations;
trace += data[i][i];
public double getMeasuredValue() {
protected double[] vecAbsoluteTolerance;
protected double[] col = {0,4,6};
setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
return (float)doubleValue();
fitter.addWeightedPair(1.0, x,
double[] values = new double[0];
private double[] inverseCumulativeTestPoints;
double y[] = { 0.0, 20.1093579685034, -9.65685424949238,
return array;
protected double knotTolerance = 1E-12;
"trop petite tol\u00e9rance relative sur les param\u00e8tres ({0}), aucune am\u00e9lioration de la solution approximative n''est possible" },
private int[] permutation;
private BigInteger q;
protected double getInitialDomain(double p) {
this.bound = bound;
for (i = 1; i < n; i++) {
public double solve(double min, double max, double initial)
public double transform(Object o) throws MathException{
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
Set set = map.keySet();
public abstract void setPopulationSize(int size);
this.omega = omega;
ckm1   = (RationalNumber) l.get(startKm1 + i);
protected double getDelta() {
BigMatrixImpl m = new BigMatrixImpl(singular);
TestUtils.assertEquals("Incorrect cumulative probability value returned for " 
TestUtils.tTest(sample1, sample2, .95);
h = (h < 0) ? -minStep : minStep;
BasicSampledFunctionIterator iter =
ComplexUtils.polar2Complex(inf, negInf));
protected SquareMatrix(int order, double[] data) {
public void testSolveNull() throws MathException {
newA[i] = a[i].multiply(r);
public void testTransform() throws Exception {
this(0.0, 1.0);
int sampleSize = 895;
if (index >= numElements) {
Math.max(minReduction,
public void testAtanInf() {
m.setIgnored(true);
m1 = Double.NaN;
"-1/6");
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
temp = 1;
StatisticalSummary sampleStats2,
this.steadyStateThreshold = steadyStateThreshold;
f2 = new Fraction(-1,5);
return polynomialDerivative();
GammaDistribution distribution = (GammaDistribution) getDistribution();
setScale(s);
outBuffer.append("std dev: " + getStandardDeviation() + "\n");
ComplexUtils.acos(null); 
assertFraction(7, 6, b.add(a));
public class VectorialSampleStatistics {
for (int i = 0; i < R.getRowDimension(); i++)
public BigDecimal getTrace() throws IllegalArgumentException {
double c[] = { 4.0, 3.0, 2.0, 1.0 };
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);
double next = 0.0;
old = improperFormat.getDenominatorFormat();
double dRdY = 0;
t.transform(null);
if (realFormat == null) {
private double[] inverseCumulativeTestValues;
double h) {
double temp = i / 10.0;
double[][] resultData = result.getDataRef();
BigDecimal[][] lowerData = new BigDecimal[n][n];
double q0q3  = q0 * q3;
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});
fail("wrong exception caught: " + e.getMessage());
tmp1 = tmp2;
assertFraction(4, 9, b.multiply(b));
public void selfSub(Matrix m) {
solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});
public double getTolerance() {
public double cumulativeProbability(double x) throws MathException {
public Complex[] inversetransform2(double f[]) throws MathException,
String expected = "(Infinity) + (Infinity)i";
value = 2;
Complex y2[] = y;
private boolean isRectangular(long[][] in) {
f = new PolynomialFraction(307692l, 999999l);
double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };
checkMatrix(l1, new BilinearPattern(5, -0.6));
double steadyStateThreshold, double epsilon) {
this.prototype  = prototype;
if (in[i].length != in[0].length) {
p.valueAt(x) + 0.1 * randomizer.nextGaussian());
double chiSquare(double[] expected, long[] observed) 
TestProblem1 pb     = new TestProblem1();
assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
x02 = o[0][2];
for (int i = 1; i < n; i++) {
public void testDoubleLoad() throws Exception {
assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +
f[m - 2] = x1;
+ " sum of squares is possible",
public void testParseInvalidDenominator() {
public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {
assertTrue(val > 0);
this.pattern   = getMessage();
public void testRoundFloat() {
private static class ConstantGenerator implements RandomGenerator {
public BigDecimal getNorm() {
public void testConsistency() throws Exception {
RealMatrix m = new RealMatrixImpl(testData);
ArrayList list = new ArrayList();
for (double z = -0.9; z < 0.9; z += 0.2) {
if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {
public void mapStateToArray(int start, double[] array);
TestSuite suite = new TestSuite(SimpleRegressionTest.class);
TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);
if (filePointer != null) {
return fct(data);
m.getColumnMatrix(-1);
line = reader.readLine(); // no more elements
fp = dxNorm - delta;
public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {
fail("wrong length for sorted values array");
dx =1;
rawGenerator);
return new DistributionFactoryImpl();
if (n + omegaCount == 0) {
return new RealMatrixImpl(this.copyOut());
new Object[] { e.getMessage() }, e);
protected double mean = 12.40454545454550;
public DescriptiveStatisticsImpl(int window) {
fail("unexpected exception");
for (Iterator iter = functions.iterator(); iter.hasNext();) {
minpackTest(new BrownDennisFunction(20,
rd.reSeed();
actual = improperFormat.format(c); 
private int rank;
double corr22 = o[2][2] - m[2][2];
public void testToString(){
NumberFormat nf = NumberFormat.getNumberInstance(locale);
throw new IllegalArgumentException("Invalid rounding method.");
q = (Polynomial.Rational) q.negate();
public Object[] getArguments() {
return new Complex(real, -imaginary);
public double chiSquare(double[] expected, long[] observed)
measurements.set(i + 1, mI);
outBuffer.append("SummaryStatistics:\n");
if (denseOutput && ! reject) {
yDot[0] =  y[1];
private static final double d3 =  -10690763975.0 /   1880347072.0;
return Math.sin(x) - 0.5;
setTolerance(1E-6);
Matrix u2 = u1.duplicate();
public double evaluate(double x, double epsilon, int maxIterations)
return new TestSuite(GaussLegendreIntegratorTest.class);
Double.NEGATIVE_INFINITY};
ComplexUtils.sin(null); 
private double omega;
public static final RotationOrder YZY =
assertTrue("summaries based on same data should be equal", t.equals(u));
p1 = null;
errSum += e[l] * yDotK[l][j];
private double[] internalData;
TestSuite suite = new TestSuite(RandomAdaptorTest.class);
int getNumElements();
s.append('/');
("Interpolation array cannot be empty.");
RealMatrix covariance, double small,
double[] test2 = {5,2,1,0,4,3};
-1.51373320452707,   0.99299901922322
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);
if (pendingEvent) {
norm = matrix.transpose().multiply(matrix).subtract(eye)
void resetRelativeAccuracy();
assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());
public class PoissonDistributionTest extends IntegerDistributionAbstractTest {
public GeometricMeanTest(String name) {
normal = value;
if (switchesHandler.evaluateStep(interpolator)) {
result = transformer.transform2(y2);
private static double k16_14 =      157882067000.0 / 53564469831.0;
v3 = (double[]) interpolator.v3.clone();
public MathException(Throwable rootCause) {
901.268527953801
empiricalDistribution2 = new EmpiricalDistributionImpl(1001);           
assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);
errfac = new double[maxDegree - 4];
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
getNumberOfTrials() - x);
value = Double.NaN;
public abstract double homoscedasticT(
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
y1Diag[k] = new double[y0.length];
b2.setElement(1, 30.0);
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
copy.addToSelf(i);
assertFraction(15, 1, new Fraction(15.0000000000001));
private static final double twoPi = 2.0 * Math.PI;
public GraggBulirschStoerStepInterpolator() {
public void testGeneral() {
xNorm = 0;
public BigDecimal[] getRow(int row) throws MatrixIndexException {
assertEquals(1.0,  a[2], 1.0e-12);
for (int i = 0; i < newPols.length; ++i) {
"Exception de conversion dans une transformation : {0}" },
5.755931,
f.addValue(new Long(2));
double d  = b - a;
private static final long serialVersionUID = -8231831954703408316L;  
assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );
Complex z = x.negate();
final int begin, final int length) {
return 0;
return empiricalDistribution.getNextValue();
throw new IllegalArgumentException("Poisson mean must be > 0");
newA[i] += a[j] * p.a[i-j];
public DormandPrince54IntegratorTest(String name) {
private static final double a73 =   125.0 /  192.0;
vecAbsoluteTolerance, vecRelativeTolerance);
new TrapezoidIntegratorSampler(iter);
costPerTimeUnit = new double[size];
RationalNumber[] newA = new RationalNumber[highLength];
result = solver.solve(0.05, 0.95);
assertTrue("expecting infinite factorial value",
double [] getRowAsDoubleArray(int row) throws MatrixIndexException;
return getCumFreq(new Character(v));         
new double[] {  4.0,  0.0, 1.0, 2.0 },
private void updateResidualsAndCost() {
minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },
double[] expected = {500,500};
int q0 = 0;
+ " upper triangular matrix");
return solveAll(c, z);
assertFraction(0, 1, new Fraction(0, -1));
setMultiStart(starts, generator);
+ k.getY() * (u1z * u2x - u1x * u2z)
public class FastCosineTransformer implements Serializable {
TestUtils.t(sampleStats1, sampleStats2), 1E-10);
assertTrue((! solvable) && (degree > 0));
sum    += 0.5
public void testResetMaximalIterationCount(){
private static final long serialVersionUID = -6337346779577272306L;
30,  31,  32,  33,  34,  35,  36,  37,  38,   39, 40,
return result;   // v is not comparable
assertTrue(Math.abs(residual.getElement(i, j)) < 1.0e-10);
private double orderControl2;
xTab[i2] = xTmp;
f1 = f1.subtract(f1);
mean              = new double[] {0.0, 1.0, -3.0, 2.3};
assertTrue(m.hashCode() != mt.hashCode());
public double getResult() {
NumberFormat f = getDefaultNumberFormat(locale);
if (nextAction == SwitchingFunction.RESET_STATE) {
a.setElement(3, 1,  -3.0);
public MatrixUtils() {
public VectorialValuedPair nextSamplePoint()
double costR = evaluateCost(xR);
bs.solve(bs);
this.orderControl1 = orderControl1;
protected abstract double getDomainUpperBound(double p);
public Interval getInterval(int i) {
new EstimatedParameter("p5", 0)
this.q2 = q2;
public abstract BinomialDistribution createBinomialDistribution(
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
hNew   = Math.abs(filterStep(h * stabilityReduction, false));
if ((sampleStats == null) || (sampleStats.getN() < 2)) {
testLogGamma(Double.NaN, Double.NaN);
+ " et le vecteur d''\u00e9tat ({1})" },
return new double[] { 0d, 0.0183156388887d,  0.073262555555d,
u.getVariance() == 0);  
super(false, c, a, b, new GillStepInterpolator(), step);
assertEquals(150, MathUtils.lcm(a, b));
public EulerIntegrator(double step) {
return t(sampleStats1.getMean(), sampleStats2.getMean(), 
double fl = Math.floor(x);
int pk = permutation[k];
double s = getNorm();
yDotKLast[0][i] = in.readDouble();
Matrix m2 = buildMatrix(m1.getRows(),
randomData.nextSecureLong(4,3);
++callsCount;
if (length == 1) {
double qtbpj = 0;
double[] data = new double [7];
int size = b1.getStateDimension();
public APSProblem25(int n, double a, double b, double expectedRoot) {
return tTest. tTest(mu, sampleStats, alpha);
public static NonNullRange intersection(NonNullRange first,
double[] errorScale = { 1.0, 1.0 };
public static double sign(final double x) {
tmp3 = tmp4;
GeneralMatrix m2 = new GeneralMatrix(m1);
assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));
public void testAddNaN() {
double d20 = m2[2][0] - m3[2][0];
r = new Rotation();
private void checkAngle(double a1, double a2) {
5.1669892394942e-5, 4.9603096699145e-5, 4.7695285287639e-5,
countSum1 += observed1[i];
public boolean tTest(double mu, double[] sample, double alpha)
public void add(double[][] points) {
double x = fd.inverseCumulativeProbability(p);
public double chiSquare(long[][] counts) throws IllegalArgumentException {
assertTrue("Mean of n = 0 set should be NaN", 
bd[i] = new BigDecimal(b[i]);
TestProblem p = problems[i];
public void tearOff() {
this.starts    = 1;
public void testSetStandardDeviation() throws Exception {
public Vector3D normalize() {
private static final long serialVersionUID = -506293526695298279L;
max = row;
checkPolynomial(p, "-5 + 3 x + x^2");
fail("n = k = 0, expecting IllegalArgumentException");
if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {
public void testEquals() {
new RationalNumber(-1l, kP1),
return new Complex(imaginary/d, -real/c);
return new RationalNumber(p.multiply(l), q);
public double[] makeDensityTestValues() {
double sum  = -(n + 1);
ComplexUtils.polar2Complex(1, pi/2), 10e-12);
String pattern = "Evaluation failed for argument = {0}";
private double u;
assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);
Fraction c = new Fraction(1, 2);
public void selfSub(SquareMatrix s) {
private static double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;
m.evaluate(values);  // side effect is to add values
secondMoment.clear();
sum += data[row][i] * m.getEntry(i, col);
throws MathException {
return values[begin]; // always return single value for n = 1
numElements = index + 1;
public void testSetScale() {
public static final RationalNumber ONE  = new RationalNumber(1l);
assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);
assertTrue("identity nonsingular",!m.isSingular());
for (int k = 0; k < n27.length; ++k) {
r += i;
extrapolate(l2, j, diagonal, yMidDots[l+1]);
new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },
public static Interval intersection(Interval i1, Interval i2) {
+ m[2].getResidual() * m[2].getPartial(p[0]));
f = f.subtract(Fraction.ONE.negate());
public IntervalsList(double a, double b) {
result = solver.solve2(min, max);
private static double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;
cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());
public class GaussianRandomGeneratorTest
randomData.nextSecureHexString(0);
new double[] { 0.5 }, new double[] { 1.5 });
public int getSize() {
public void setAge(Integer age) {
ratio         = (yDot1[j] - yDot0[j]) / scale[j];
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
public void testNextInt() {
(118.0 - 23.0 * sqrt6) / 1024.0, -9.0 / 512.0},
public UnivariateRealFunctionProxy(UnivariateRealFunction function) {
result = solver.solve(0.85, 5);
char bChar = 'b';
public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,
while (!found && i < values.length) {
return (stdDev);
for (int i = j + 1; i < nSing; ++i) {
f1 = new Fraction(-1, 13*13*2*2);
public void testRegularizedBetaPositivePositivePositive() {
-Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0) },
UnivariateRealSolver solver = factory.newNewtonSolver(function);
f= new Fraction(Integer.MIN_VALUE, 1);
-tmp * Math.exp(-tmp * x1),
public class GeneralSquareMatrixTest
assertEquals(0.0, optimum.cost, 3.0e-5);
String qString = q.toString();
double newValue = 1.0e-2;
Matrix inverse = d.getInverse(1.0e-10);
assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);
fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");
Percentile p = new Percentile(75);
double x08 = parameters[7].getEstimate();
solver.resetAbsoluteAccuracy();
if ((smallest <= costR) && (costR < secondLargest)) {
if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {
return sup - inf;
TestProblem3 pb  = new TestProblem3(0.9);
1.0 + epsilon * epsilon),
public void testCosNaN() {
for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {
+ getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1)
x = isSequence(x0, xplus, x2) ? xplus : xminus;
new EstimatedParameter("p5", 5)
for (int k = 1; k < stages; ++k) {
double h2 = next.x    - current.x;
double solve(double min, double max) throws ConvergenceException, 
RealMatrix b              = new RealMatrixImpl(parameters.length, 1);
for (int i = 0; i < wm.length; ++i) {
public MathException(String msg, Throwable rootCause) {
-32977797.7841797,
s = (4 * qtrap.stage(min, max, 1) - qtrap.stage(min, max, 0)) / 3.0;
(double) sample1.length);
UnivariateRealFunction f = new Expm1Function();
y1, yDot1,
if ((observed == null) || (observed.length < 2)) {
double a[], c[];
double ya = yb;
private static final long serialVersionUID = -3349935121172596109L;
nbStep = Math.max(1l, Math.abs(Math.round((t - currentT) / step)));
assertTrue(Math.abs(d12) > 4.0e-7);
super(isCardan ? "Cardan angles singularity" : "Euler angles singularity", new Object[0]);
testGenerator.nextInt(-1);
public void setStepsizeControl(double stepControl1, double stepControl2,
protected double max = 21d;
protected double skew = 1.437423729196190;
return getNumberOfTrials();
index = high;
y[0] * y[0], y[1] * y[1]             
sampler.samplePointAt(-1);
-2 * x03 * x07 * (temp - x10) * tmp3,
return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};
private static double b_11 =      171414593.0 / 851261400.0;
public abstract int getWindowSize();
throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);
public RationalNumber[] getCoefficients(int degree) {
assertEquals( "Mean age unexpected", 33.333,
randomData.nextUniform(3,3);
double cost2 = ((PointCostPair) o2).cost;
upperData[index++] = 0.0;
int getRowDimension();
assertTrue(inverse instanceof UpperTriangularMatrix);
throw new IllegalArgumentException("cannot substract a "
public HighamHall54StepInterpolatorTest(String name) {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
interpolator.setInterpolatedTime(interpolator.getCurrentTime());
Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14), 
assertFalse(m.equals(m1));
throw new IllegalArgumentException("must have n >= 0 for n!");
return new Mean();
RandomData randomData = new RandomDataImpl();
TestUtils.assertEquals(new Complex(inf, pi / 4),
this.threshold = threshold;
public Complex parse(String source, ParsePosition pos) {
if ( ! tryStep(equations, currentT, y, h, k, scale, fk[k],
private double[][] v;
public void testLowerTriangular() {
assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);
protected double t1;
if ((startIndex + numElements) > internalArray.length) {
"Cannot convert given object to a fraction.");
if (startRow < 0 || startRow > endRow || endRow > data.length ||
0.500, 0.423, 0.395, 0.375, 0.372,
if (n < maxIterations && Math.abs(convergent - value) > epsilon) {
c[0] *= (-x[i]);
assertEquals("cleared stats should have thashcode of empty stat", 
public class GeometricMean extends AbstractStorelessUnivariateStatistic {
if (nSing > 0) {
if (((initial - min) * (max -initial)) < 0) {
assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;
this.z = a1 * u1.z + a2 * u2.z;
public class Subtract implements Evaluation, Serializable {
this.z = Math.sin(delta);
double convergence) {
if (i == 0) {
double cumulativeProbability(int x) throws MathException;
assertEquals(nf, cf.getRealFormat());
return new Fraction(num.intValue(), 1);
public void testDiscard() {
public double nextDouble() {
public TTest createTTest() {       
toAppendTo.append(' ');
for (int iter = 1; iter < numIter + 1; iter++) {
long q2 = 2 *  q1;
this.defaultMaximalIterationCount = defaultMaximalIterationCount;
return new TestSuite(FirstOrderConverterTest.class);
if (Math.abs(delta) > tolerance) {
toAppendTo.append(getImaginaryCharacter());
String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";
public ConvergenceException() {
(double) (length - 1));
if (N == 2) {
Complex expected = new Complex(3.853738, -27.01681);
this.rateAfter  = rateAfter;
public abstract int intValue(Evaluation argument) throws EvaluationException ;
assertTrue(Math.abs(sampler.samplePointAt(11).y[0] + 0.913) < 1.0e-10);
u.getGeometricMean(),
public Double multiply(Double p) {
f = new PolynomialFraction(0l, 4l);
if (iev) {
long[] observed = new long[4];
assertFalse(x.equals(this));
for (int j = 0; j < testArray.length; j ++) {
if (costR < largest) {
boolean firstStepAlreadyComputed = false;
assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));
new Interval[] { new Interval(-2.0,  0.0),
double alpha = 0;
Vector3D axis = r.getAxis();
public RealMatrix inverse() throws InvalidMatrixException {
for (int col = 0; col < nCol; col++) {
assertEquals(kurt,k.getResult(),tolerance);
public ClassicalRungeKuttaStepInterpolator() {
sum1 += (diff - meanDifference) *(diff - meanDifference);
public void testReunion() {
assertEquals( 7.0, f.value( -1.5), tolerance );
if (paru == 0) {
checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(5l, 2l)),
newA[i] = a[i] * r;
coefficients = new double[n+1];
2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,
if (i > 0)
Complex x = new Complex(3.0, 4.0);
public static Test suite ()
Integer.toString(starts)
public Variance(final SecondMoment m2) {
for (int i = 1; i < in.length; i++) {
f = new Frequency(String.CASE_INSENSITIVE_ORDER);
public class SymetricalMatrix
protected Complex altPolar(double r, double theta) {
sum.increment(value);
double s = diag[pj] * lmDir[pj];
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
public TDistributionImpl(double degreesOfFreedom) {
assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);
fitter.addWeightedPair(1.0, 100.0 - x, 0.0);
double tmp1 = i + 1;
double s2 =0;
min = -0.4; max = 0.2; expected = 0.0;
Complex expected = new Complex(-13.12878, -15.20078);
assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );
b.setElement(i, 0, i + 1.0);
String source, ParsePosition pos)
UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));
Math.max(first.end, second.end));
assertEquals(nf, improperFormat.getNumeratorFormat());
previousTime      = Double.NaN;
this.coeffJ = coeffJ;
-85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,
new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},
ra.addElementRolling(i);
assertEquals("total count", 0, u.getN(), tolerance);
double fmin;
if (values == null) {
throws MathException, IllegalArgumentException {
Fraction b = new Fraction(-10, 21);
private Complex nanZero = new Complex(nan, 0);
double f1  = 1 - e * Math.cos(E);
boolean solvable) {
double[][] points = new double[][] {
assertEquals(new RationalNumber(1l), a[2]);
return new DefaultValue(i);
private static final long serialVersionUID = 4122929125438624648L;
if ((z.subtract(oldz)).abs() <= tolerance) {
double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;
public void testAddOK() {
value = a[i] + (z - c[i]) * value;
moment.clear();
lowerData[i][j] = lu.getEntry(i, j);
public double cost(double[] x) {
assertTrue(Math.abs(d.getElement(i, j) - expected) < 1.0e-10);
int n = vertices.length - 1;
super(degree + 1, estimator);
public LowerTriangularMatrix(LowerTriangularMatrix l) {
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
private static final long serialVersionUID = 4016396219767783678L;
sum += jacobian[i * cols + pj] * work[i];
index2 += bCols;
private static final String methodName = "3/8";
suite.addTest(PolynomialDoubleTest.suite());
1E-10);
if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {
throw new IllegalArgumentException("state vector dimension mismatch");
return new LowerTriangularMatrix(rows, data);
assertEquals(expectedNumerator, actual.getNumerator());
throw new CostException("{0}", new Object[] { "oops"});
private void testSolve(double[][] lowerTriangularMatrix, String message)  {
MathUtils.mulAndCheck(big, 2);
matrix = new RealMatrixImpl(testData3x3Singular);
16370.0, 13720.0, 11540.0,  9744.0,
checkAngle(r.getAngle(), Math.PI);
public void testWholeFormat() {
public static double min(final double[] values, final int begin,
public class DiagonalMatrixTest
assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);
assertTrue(new Laguerre().isOne());
return Integer.MAX_VALUE;
if ((absAi - 1) != 0) {
private void verifySummary(StatisticalSummary s) {
public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{
private double[][] polynoms;
fail("IllegalArgumentException expected");
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public int compareTo(Object object) {
12.2,
public static int lcm(int a, int b) {
super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));
public void testLogBetaPositivePositive() {
if (n % 2 == 0) { // even
this.minReduction = minReduction;
public WeightedMeasurement[] getMeasurements() {
if (!loaded) {
private static final long serialVersionUID = -8722683066277473450L;
if (b.getRows () != rows) {
throws EstimationException {
private double py;
pos.setIndex(pos.getIndex() - 1);
public double probability(double x) {
z = 0.0; expected = 0.0; result = p.value(z);
super("Evaluation failed for argument = {0}",
inverse.simplify();
public abstract IntegerDistribution makeDistribution();
if (testGenerator.nextBoolean()) {
public CauchyDistribution createCauchyDistribution(
max = new Max();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
distribution.inverseCumulativeProbability(2);
public static final RotationOrder XZX =
public static final int CONTINUE = 3;
private void reduce() {
u.addValue(test4[i]);
assertTrue(l2.isConnex()     ^ (!b3));
numElements -= i;
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
int bIndex = i * bCols + minJ;
return new TestProblem1(this);
pendingEvent = true;
public void testExpInf() {
public UnivariateStatistic getUnivariateStatistic() {   
testStatistic.tTest(0d, oneSidedP, 95);
cf.setImaginaryCharacter(null);
if (isInfinite()) {
return super.clone();
assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));
public void testInteraction() {
return (cy.getEstimate() - py) / getCenterDistance();
for (i = 0; i < np; i++) {
data[index] -= l.data[index];
public void testAddElementRolling() {
return z;
new Vector3D(m3[0][0], m3[1][0], m3[2][0]));
-0.0157249615083782, 1.01243488232965,
double tmp = v[i] * (v[i] + x3) + x4;
PointCostPair[] original = simplex;
private static class DummyEquations
this.forward      = true;
protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {
assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);
(-1324889724104.0 - 318801444819.0 * sqrt6) / 626556937500.0,
x1 = 0.5 * (x0 + x2);
3624883.342907764, testStatistic.chiSquare(exp, obs), 1E-9);
public RandomDataTest(String name) {
return -1;
0.118088726698392e19, 1.88424820499347,
public double solve(double min, double max) throws MaxIterationsExceededException, 
public double tTest(double[] sample1, double[] sample2)
TestSuite suite = new TestSuite(SumTest.class);
minpackTest(new Osborne2Function(new double[] {
private static class ChebyquadFunction extends MinpackFunction {
long countSum2 = 0;
EstimatedParameter[]  parameters   = problem.getUnboundParameters();
protected double secondMoment = 210.04954545454547d;
public static IntervalsList add(IntervalsList list, Interval i) {
new double[] { 0.9817314924684 }), false);
a = computeDividedDifference(x, y);
return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());
if (acceptSmall) {
public abstract UnivariateRealSolver newBrentSolver(
f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);
h[i] = x[i + 1] - x[i];
minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,
return (
if (! lastStep) {
super(1.0, setPoint);
out.writeDouble(yDotKLast[0][i]);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);
if (locatePoint(time, sMax) >= 0) {
setMaxCostEval(1000);
return (n > 0) && ((n & (n - 1)) == 0);
public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{
assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);
public void setOrderControl(int maxOrder,
double inv = 0.25 / q1;
assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);
assertEquals(1d, percentile.evaluate(singletonArray), 0);
assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);
private void checkConstant(Random random) {
Fraction f = null;
TestSuite suite = new TestSuite("org.spaceroots.mantissa.algebra"); 
double[] sum = null;
value *= d;
expected = MatrixUtils.createRealMatrix
checkMatrix(m1, new BilinearPattern(3, -0.02));
return new StandardDeviation();
public double getEntry(int row, int column)
dynaBean.set(propertyName, new Double(v));
n = degree() + 1;
assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);
TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);
MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null
this.mean = p;
in = new BufferedReader(new FileReader(file));
public void addSwitchingFunction(SwitchingFunction function,
f[i+1] = omegaCount < 0 ? E : F;
!testStatistic.homoscedasticTTest(sample1, sample2, 0.48));
checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));
private double rateAfter;
public RationalNumber(long numerator, long denominator) {
distribution.setDegreesOfFreedom(n - 1);
double coeff1 = oneMinusThetaH * theta;
return cumulativeTestPoints;
theta -= pi / 6;
package org.apache.commons.math.estimation;
0.123052801046931,
double dt2 = time - tMed;
private Gamma() {
int resultIndex     = 0;
coeff           = new double[size][];
public void testSetMaximalIterationCount(){
yEnd[i]       = yTmp[i] + subStep2 * f[j][i];
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
fail("an exception should have been thrown");
fail("expecting IllegalArgumentException for alpha = 1");
double scaling_coefficient = 2.0 / (f.length - 1);
determineLMDirection(qy, work1, work2, work3);
public class ArgumentOutsideDomainExceptionTest extends TestCase {
protected ContinuousDistribution getDistribution() {
double[] preMultiply(double[] v) throws IllegalArgumentException;
int getNumberOfTrials();
private int numberOfTrials;
m2.setSubMatrix(testData,1,0);
assertTrue(Math.abs(m3tm3) < 1.0e-10);
protected long n;
public class BeanTransformer implements NumberTransformer {
circle.addPoint( 50.0,  -6.0);
private double safety;
public void testNegativeReal() {
interpolator.storeTime(t0);
for (int i = 0; i < 1000; i ++) {
nf = NumberFormat.getInstance();
SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {
Polynomial.Rational g0 = new Polynomial.Rational(k * (k + 1));
m.solve(testVector),normTolerance);
result = solver.solve(0.85, 1.75);
assertTrue(pb.getCalls() < 2900);
x = new double[] {};
public void addValue(Integer v) {
assertEquals( "Geometric mean not expected", 
throws EstimationException;
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
testDecompose(m1, "Decomposing matrix m1");
private static final long serialVersionUID = -4210522025715687648L;
private double root;
public void testCopy() {
return new Fraction(denominator, numerator);
public void selfSub(LowerTriangularMatrix l) {
for (int i = k + 1; i <= n; i++) {
new HarmonicCoefficientsGuesser((FitMeasurement[]) getMeasurements());
public double getB() {
String pString = p.toString();
polynomials[i].value(0), spline.value(knots[i]), tolerance);
private double x;
private VitalStats vitalStats;
f[i] += tmp2;
val = testGenerator.nextFloat();
0.0, 1.0
public void testSqrt1zNull() {
f.addValue(aString);    
assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);     
b2.setElement(0, 40.0);
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
y = new double[y0.length];
public Vector3D applyInverseTo(Vector3D u) {
f = new RationalNumber(307692l, 999999l);
double out[][] = new double[m][n];
: (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
"1.0 + 3.0 x^2");
return Math.floor(Math.exp(factorialLog(n)) + 0.5);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
public void testSimpleNoDecimals() {
int dimension = interpolator.currentState.length;
float val = 0;
public interface Estimator {
new FixedStepHandler() {
double v3x  = v3.getX();
public void setSafety(double safety) {
return multiply(new RationalNumber(l));
assertTrue(ex.getMessage().indexOf("0") > 0);
("lower endpoint must be less than or equal to upper endpoint");
if (hex.length() == 1)  {
PolynomialSplineFunction spline = 
public NonNullRange(int begin, int end)
private static double[] buildChebyquadArray(int n, double factor) {
new Complex(-1.10502525316942, 4.88492424049175),
new RationalNumber(k * 2l));
protected double defaultAbsoluteAccuracy;
assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);  
res[0] = -x;
testRegularizedBeta(0.0, 0.0, 1.0, 2.0);
return -u;
public interface StepHandler {
for (Iterator iterator = list.intervals.iterator(); iterator.hasNext();) {
double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);
checkValue(p.getEstimate(), e);
- m.getTheoreticalValue()) < 0.04);
formatDouble(re, getRealFormat(), toAppendTo, pos);
public int compare(Object o1, Object o2) {
for (int j = 0; j < d.getColumns(); ++j) {
&& (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {
class TestProblemFactory {
return new Vector3D(x - v.x, y - v.y, z - v.z);
void setBeta(double beta);
regression.getInterceptStdErr(),1E-8);
private void guessPhi()
yDotKLast[0] = new double[dimension];
if (adjustStep) {
assertTrue(optimum.cost > 0.01);
if (val < q1) {
public void testNumericalZero() {
public HarmonicCoefficientsGuesser(AbstractCurveFitter.FitMeasurement[] measurements) {
int resultIndex     = bRows * bCols - 1;
s.append("-");
setRealFormat(realFormat);
if ( !isValidCoordinate( row, 0)) {
protected AbstractStepInterpolator() {
assertEquals(0, new Polynomial.Rational(0l).getDegree());
public Stop() {
computeOmega(isInverse ? -N : N);
RealMatrix m = (RealMatrix) object;
throw new IllegalArgumentException("cannot get element ("
integrator.setMinimalIterationCount(5);
double[] vertex = generator.nextVector();
public static void setChiSquareTest(ChiSquareTest chiSquareTest) {
MathUtils.factorial(-1);
Math.sin(lambda) * Math.cos(phi),
public void testAtanNull() {
public SumSqTest(String name) {
public void testLogBetaPositiveNan() {
new LinearProblem(new LinearMeasurement[] {
return Double.MAX_VALUE;
public void testLargeMeanCumulativeProbability() {
public void setOperand(Evaluation argument) {
new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);
public long longValue() {
public void testGetVectors() {
public void testNewSecantSolverValid() {
for (int i = 0; i < 5; i++) {
mean.increment(Double.POSITIVE_INFINITY);
RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;
if (! forward) {
private static class ComplexPattern implements ElementPattern {
public void linearEstimate(EstimationProblem problem)
this.b2k = b2k;
ComplexUtils.log(negInfNegInf), 10e-12);
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
fail("Expecting IllegalArgumentException - bad iteration limits");
double dx  = 1.0;
url.openStream()));
public class ContinuousOutputModelTest
"une matrice {0}x{1} ne peut pas \u00eatre une matrice de rotation" },
i--;
checkPolynomial(new Hermite(1), "2 x");
assertFraction(1, 3, new Fraction(1.0 / 3.0));
for (int k = 0; k < n; ++k) {
public class WeibullDistributionImpl extends AbstractContinuousDistribution
private static double[][] d = {
public int intValue(Evaluation argument) throws EvaluationException {
RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);
private static final double a72 =   500.0 / 1113.0;
assertFalse("different n's should make instances not equal", u.equals(t));
ComplexUtils.polar2Complex(1, negInf));
newSize = internalArray.length + Math.round(expansionFactor);
throw new IOException(e.getMessage());
m[2] = new double[3];
private double b;
checkUnsolvableProblem(new GaussNewtonEstimator(10, 1.0e-7, 1.0e-7,
public void setTransformer(NumberTransformer transformer) {
double b)
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.002));
int kMax = in.readInt();
public IntervalsList(IntervalsList list) {
n         = (int) Math.ceil((range[1] - range[0]) / step);
+ " no further reduction in the"
public ThreeEighthesIntegratorTest(String name) {
1.05262638516774
assertEquals("Row3", mRow3, 
assertTrue(l1.isEmpty()      ^ (!b2));
this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;
qtbpj = -sin * work[k] + cos * qtbpj;
coeffs[1],
public void addToSelf(IntervalsList list) {
if (mu > 1) {
for (int j=0; j<lowerTriangularMatrix[0].length; j++) 
dx *= div;
getWholeFormat().format(whole, toAppendTo, pos);
solver.decompose(new RealMatrixImpl(m7));
double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));
double tmp1 = Math.exp(-x05 * temp);
assertEquals(d1.isLoaded(), d2.isLoaded());
int n = x.length - 1;   
coefficients[3] = d[i];
double degreesOfFreedom);
if (mv1.length != mv1.length  ||
new Interval[] { new Interval(-2.0, -1.0),
ScalarSampleStatistics loop   = new ScalarSampleStatistics();
protected abstract int getDomainUpperBound(double p);
assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);
protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {
for (int j = 0; j < currentState.length; ++j) {
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
x[N >> 1] = 2.0 * f[N >> 1];
m.getSubMatrix(2 , 3 , 0, 0));
protected void runTest() throws Throwable {
complexFormatJ = ComplexFormat.getInstance(getLocale());
da.setElement(9, 10.0);
switch (checker.converged(xLow, fLow, xHigh, fHigh)) {
public PolynomialFraction(long numerator, long denominator) {
System.arraycopy(y, 0, this.y, 0, y.length);
yDot[1] = y[3];
double[] unMatchedEx = { 1, 1, 2 };
private final double variance;
return Math.min(k, m);
assertEquals(0, random.nextInt(1));
++index) {
public void testRoundDouble() {
assertEquals(3.0f, testDa.getExpansionFactor(), 0);
assertEquals("one frequency count",3,f.getCount(1));
for (int j = 0; j < nColB; j++) {
assertTrue("testData nonsingular",!m.isSingular());
protected AbstractContinuousDistribution() {
public final double[] y;
mapper.manageMappable(array1);
ret = Beta.regularizedBeta(getProbabilityOfSuccess(),
return functionValueAccuracy;
assertEquals("number of observations", 53, regression.getN());
Complex expected = new Complex(2, 1);
private int findBin(double min, double value, double delta) {
MathUtils.binomialCoefficient(67,34);
DescriptiveStatistics heartU = new BeanListUnivariateImpl( patientList,
public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,
if ((y1 > 0) == (y2 > 0)) {
double ta = t0;
res = res*res;
c = new double[n];
new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },
return fst(f);
public ForwardDifferenceDerivative(UnivariateRealFunction function, double h) {
return new RationalNumber(p.multiply(r.q).subtract(r.p.multiply(q)),
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
return divide(new RationalNumber(l));
statistic2.increment(Double.POSITIVE_INFINITY);
return new TestSuite(NelderMeadTest.class);
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return chiSquareTest.chiSquare(counts);
newIntervals.add(i);
return this.median;
public void testSpecialValues() {
public void testParseInvalid() {
private double var = 0.666666666666666666667;
throw new IllegalArgumentException("Illegal expansionMode setting.");  
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
if (state.evaluateStep(interpolator)) {
assertFraction(1, 1, b.divide(b));
initialTime = interpolator.getPreviousTime();
public UpperTriangularMatrixTest(String name) {
TestSuite suite = new TestSuite("org.spaceroots.mantissa.utilities"); 
public void setRightOperand(Evaluation right) {
RealMatrixImpl matrix = (RealMatrixImpl) MatrixUtils.createRealMatrix
mean.increment(0d);
ConvergenceChecker checker,
"selected row and column index arrays must be non-empty");
if (getN() > 1) {
Matrix result = b.duplicate();
double scalAbsoluteTolerance = 1.0e-15;
public static double homoscedasticT(double[] sample1, double[] sample2)
public void setZ(Double double1) {
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();
if (costC <= costR) {
if (beta <= 0.0) {
public boolean findRoot(ComputableFunction function,
BigDecimal out[][] = new BigDecimal[m][n];
int nCols = rowData.length;
finalTime = ((StepInterpolator) steps.get(index)).getCurrentTime();
public DormandPrince853IntegratorTest(String name) {
lastSeen = true;
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
if (r.p.signum() == 0) {
public AbstractRandomGenerator() {
rank = solvedCols;
f.addValue("oNe");
distribution.setMean(mu);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
String[][] data = new String[nRows][1];
"The max element should be 2.0",
index = iMin;
u.setWindowSize(10);
assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);
for (int j = 0; j < lmDir.length; ++j) {
this.step = step;
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
Complex expected = new Complex(-27.03495, -3.851153);
int iDiag = k * cols + permutation[i];
return getCount(new Character(v));
ScalarValuedPair pair2 = new ScalarValuedPair(pair1);
assertEquals(0, new Polynomial.Double(0.0).getDegree());
public Evaluation evaluate(EvaluationContext context) {
public void testLongValue() {
minima         = null;
value = 0d;
public APSProblem21(int n, double a, double b, double expectedRoot) {
return p;
if (count != null) {
assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);
return new ScalarValuedPair(x, -x);
("Statistics constructed from external moments cannot be cleared");
for (int i = 0; i < 100; ++i) {
assertTrue(p.isBound());
private static final long serialVersionUID = -942772950698439883L;
if (o == null) {
if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null
double[] yDDot)
TestSuite suite = new TestSuite(ChiSquareFactoryTest.class);
int i, j, n = degree();
da.addElement(1);
public void testNewBisectionSolverValid() {
public void addObject(Object o) {
this.columns = columns;
private final Object[] arguments;
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
public void testCoshNaN() {
return rows;
for (int i = 2; i <= n; i++) {
TrapezoidIntegratorSampler sampler = new TrapezoidIntegratorSampler(iter);
assertEquals(stack, stack2);
double relTolerance   = 1.0e-8;
public double getSlopeConfidenceInterval(double alpha)
public class PolynomialFraction implements Serializable {
return new CenterDifferenceDerivative(function, h);
assertTrue(Math.abs(sampler.samplePointAt(11).x    - 0.913) < 1.0e-10);
MathUtils.sinh(a) * Math.sin(b));
ScalarValuedPair previous = next;
estimatedCovariance.getEntry(i, j),
stop = true;
return newDormandPrince853Integrator(minStep, maxStep,
private TDistribution distribution;
y[0] = Math.abs(sin);
y = y * x + a[i].doubleValue();
m.setSubMatrix(detData3,0,0);
d.setElement(i, j, 2.7);
assertEquals( "Max heart rate unexpected", 120.0, 
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
public void testDeterminant() {       
return sum.getResult();
fail("zero length supplied -- IllegalArgumentException expected");
this.y = new double[y.length];
ComplexUtils.sqrt(null); 
private double px;
while (pm > p) {
private   boolean bound;
fail("Expecting IllegalArgumentException for 0 mean");
public double cumulativeProbability(int x) {
assertTrue(maxError < 7.0e-10);
assertNotNull(ex.getMessage(Locale.FRENCH));
double y2 = y0;
14.6628782986152), false);
public Matrix mul(double a) {
public class RombergIntegrator extends UnivariateRealIntegratorImpl {
+ e4 * yDotK[3][j] +  e5 * yDotK[4][j]
String name = iter.next().toString();
q0 = 0.5 * Math.sqrt(s + 1.0);
+ m3[i][1] * m3[j][1]
return lower + dif * (upper - lower);
boolean unequalCounts = false;
checkEquals(new Interval[] {
double oldValue = solver.getFunctionValueAccuracy();
setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,
ConvergenceException ex = new ConvergenceException(pattern, arguments);
sum = sum - decomp[k][i]*x[k];        
public StandardDeviationTest(String name) {
data = new double [size];
StringBuffer ret = null;
return (internalArray.length - numElements) > contractionCriteria;
new Complex(-2.6, 2.7),
ret = 0.5;
omega = new Complex[Math.abs(n)];
return getCount(((Integer) v).longValue());
fittedCoefficients[i] = coefficients[i].getEstimate();
data[index] += m.data[index];
ret = 1.0 - 0.5 * t;
if (this != object) { 
return ComplexUtils.exp(Complex.I.multiply
double t0, double[] y0, double t, double[] y)
public GaussLegendreIntegrator(int minPoints, double rawStep) {
double d12 = tMax - tMed;
int[] n17 = { 8, 10, 12, 14 };
assertEquals(zero.hashCode(), zero2.hashCode());
pending   = false;
boolean lastSeen;
private int scale = 64;
MatrixUtils.createRowBigMatrix(new double[] {});  // empty
public double getInterpolatedTime() {
sum  += x;
public Circle(double cx, double cy) {
assertEquals("min", min, u.getMin(), tolerance);
sb.append('(');
testValue(0.504, 4.0, 1.0, .0018);
return x.length - 1;
if (first == null) {
super.clear();
u.setElement(i, j, i + 0.1 * j);
public void testQuinticFunction2() throws MathException {
DataAdapter da = new ArrayDataAdapter(in);
if (numRows != numCols) 
test3[i], test2[i-6],0.0);
private RandomGenerator getRan() {
if ((targetIter > 1) && ! previousRejected) {
private double maxGrowth;
public abstract long longValue(Evaluation argument) throws EvaluationException ;
public void testDecreasingSteps()
double[] newA = new double[a.length - 1];
min = m;
mapper.manageMappable(array2);
new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)
public AbstractDifferenceDerivative(UnivariateRealFunction function, double h) {
u         = (n + 1) * 500;
setLastSeen(true);
return chiSquareTest. chiSquareTest(counts, alpha);
observed[findPerm(p,perm)]++;
public ResizableDoubleArray(int initialCapacity, float expansionFactor,
q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());
double[] tempArray = new double[size];
throw new IntegratorException("too small integration interval: length = {0}",
23.0),
+ " + 26876802183334044115405 x^40");
private static double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;
public final class StatUtils {
randomGenerator.setSeed(seed);
"unable to guess a first estimate" },
public double evaluate(final double[] values, final double mean)  {
jacobian[i][0] = 0;
Rational divisor) {
public double getResult() throws IllegalStateException {
return ((DefaultValue)argument.evaluate(this)).doubleValue();
if (object instanceof StatisticalSummaryValues == false) {
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);
int d2 = MathUtils.gcd(fraction.numerator, denominator);
assertTrue(Math.abs(s.getDeterminant(1.0e-10) - 782.846532) < 1.0e-10);
if (a[i] < 0) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
double d21 = m2[2][1] - m3[2][1];
0.42247770964124,   0.30669941048320,   0.22370545765466,
TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);
assertTrue(Double.isNaN(kurt.getResult()));
public void testSumLog() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{
checkMatrix(m1, new BilinearPattern(-99, 0.02));
double u2x = u2.getX();
for (int i = 0; i < randomBytes.length; i++) {
private static class DummyFitter
private SwitchingFunction function;
Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},
double tmp4 = x2 * tmp2 + x3 * tmp3;
return new Complex(Math.sin(a) * MathUtils.cosh(b),
double e = polynoms[currentDegree][i] / scale[i];
F[2*i] = -y[i].getImaginary();
public double pairedT(double[] sample1, double[] sample2)
double sxz = 0.0;
assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));
buildSimplex(vertices);
double q0q1  = q0 * q1;
return densityTestValues;
public class DefaultContext implements EvaluationContext {
double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;
double absTolerance = Math.pow(10.0, i);
assertEquals(1.0, optimum.point[0], 0.01);
if (contractionCriteria <= 1.0) {
E = C.add(D.multiply(Complex.I));
"The element at the 56th index should be 56",
x = new double[] {nan, two, three};
implements PoissonDistribution, Serializable {
rank = 0;
double setPoint) {
parseNextCharacter(source, pos);
assertEquals(sigma, s1.getResult(), 1E-14);     
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.5) < 1.0e-10);
suite.addTest(ChebyshevTest.suite());
int iterations = randomData.nextInt(100, 1000);
fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());
checkMatrix(inverse, new ElementPattern() {
result = result * 31 + MathUtils.hash(getN());
map.clear();
assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);
splitLU(lu, lowerData, upperData);
double j1  = -v[i] * (v[i] + x2) / tmp;
assertFraction(1, 3, b.multiply(a));
String msg = "Cannot discard a negative number of elements.";
double inverse  = 1 / Math.sqrt(x * x + y * y);
public double getPercentile(double p) {
for (int j = 1; j <= k; ++j) {
int[] swap  = new int[order];
protected UnivariateRealFunction sin = new SinFunction();
newQ = (Polynomial.Rational) newQ.negate();
return new GraggBulirschStoerIntegrator(minStep, maxStep,
public Matrix solve(Matrix b, double epsilon)
n    = 0;
public static TTest getTTest() {
public Double getHeartRate() {
Rational remainder = dividend;
Iterator it = f.valuesIterator();
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
p2 = new EstimatedParameter("p2", 2.0);
assertEquals(2, f.getDenominator());
summaries = SummaryStatistics.newInstance();
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);
public double getPct(Object v) {
CostException, ConvergenceException {
w = new Complex(1, inf);
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
fail("testing numericalZero");
System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
assertFalse((one.equals(zero) ||zero.equals(one)));
MathUtils.mulAndCheck(denominator, fraction.denominator));
throw new FunctionException("outside of range");
ScalarValuedPair previous = current;
return new NonNullRange(0, rows);
public void testNullEmpty() {
public double getSumSquaredErrors() {
lastStep = forward ? (nextT >= t) : (nextT <= t);
StatUtils.varianceDifference(sample1, sample2, meanDifference), 
public double evaluate(final double[] values,final int begin, 
for (int k = 0; k < n28.length; ++k) {
private static class APSProblem18 extends TestProblem {
Polynomial.Rational tmp = a;
public static void assertEquals(String msg, double expected, double actual, double delta) {
for (int i = 1; i < (N >> 1); i++) {
case 0:
testStatistic.chiSquare(expected,observed) < 27.88);  
public static final int LOW  = 1;
+   eta * (v[3][i]
jdkSupportsNesting = true;
double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])
-3.077684, 0.0, 318.3088, 31.82052, 12.70620,
permutations[jMax] = tmp;
public void testMinpackWatson()
double s         = oneMinusThetaH / 6.0;
x[N >> 1] = f[N >> 1];
double fb = f1;
previousY = currentY;
coeffs1 = new double[degree + 1];
+ u.getStandardDeviation(),
public Polynomial divide(BigInteger i) {
MatrixUtils.createBigMatrix(testDataPlus2).getData();
min = x;
+ d[k][9]  * yDotKLast[0][i]
secRand = new SecureRandom();
checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 0l, -1l),
public void testNextExponential() {
+ d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);
u1.selfSub(u2);
public abstract double homoscedasticTTest(
new Interval(-10.0, 10.0), new Interval(-4.0, 5.0));
assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );
Vector3D u1 = new Vector3D(3, 0, 0);
assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));
public void testString() {
super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));
if (val < 0.25) {
covariance, 1.0e-12 * covariance.getNorm(),
TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));
assertEquals( "Added value ["+i+"] not equal", 
evaluations = 0;
MathUtils.equals(stat.getSumsq(),this.getSumsq()) &&
return (double[]) a.clone();
new LinearMeasurement(new double[] { 1.0 },
"expanded internal storage array would immediately " +
return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);
public void testUnsorted()
+ " + 6516550296251767619752905 x^32"
private static final long serialVersionUID = -9106690005598356403L;
public double getMedian() {
step          = (range[1] - range[0]) / (n - 1);
return ',';
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
delta = (x0 - x1) / (1 - y0 / y1);
SummaryStatistics u = SummaryStatistics.newInstance();
return -a * Math.sin(omega * x + phi);
rand = new JDKRandomGenerator();
return slope * slope * sumXX;
return Math.abs(foundRoot - expectedRoot) <= tol;
public class MantissaException
public void testOneSampleTTest() throws Exception {
throws CostException, ConvergenceException {
String hex = randomData.nextSecureHexString(40);
public PolynomialFraction divide(PolynomialFraction f) {
public final class PolynomialFunctionNewtonFormTest extends TestCase {
assertEquals( "mean not expected", 1.0, 
public BigInteger getDenominator() {
return tTest.tTest(mu, sample);
assertTrue(ratio > 0.02);
boolean gotIt;
f.addValue(2);
variance.clear();
x = new double[N];
public abstract class StorelessUnivariateStatisticAbstractTest
new double[] { 250.0, 50.0, -50.0, -10.0 },
double x = Math.abs((expected - actual) / expected);
double coeff1    = soMt * (1 - fourTheta);
for (int k = 0; k < d.length; ++k) {
if (instance == null) {
long[] bcoef6 = {1,6,15,20,15,6,1};
interpolator.storeTime(0);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
int N = f.length - 1;
int[] n28 = {
private double[] mean;
checkMatrix(d2, 4.3);
if (interpolator.currentState != null) {
Fraction f = f1.add(f2);
return var;
public CauchyDistributionImpl(){
oldx = Double.POSITIVE_INFINITY;
int maxIterations) throws MathException
double inverse = 1 / Math.sqrt(squaredSine);
(vecRelativeTolerance == null)
public void setParRelativeTolerance(double parRelativeTolerance) {
return omega;
for (int i = 0; i < b.getRows(); ++i) {
private double inf;
assertEquals(sigma, distribution.getStandardDeviation(), 0);
assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));
public void decompose(RealMatrix m) 
while (j < rows) {
return new Double(o.toString()).doubleValue();
endColumn > data[0].length ) {
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
Complex z = w.divide(x);
-14.0758803129393,
private static UnivariateStatistic min = new Min();
assertFalse(Double.isNaN(mean.getResult()));
u.addObject(new Float(14.1));
public void testExpNaN() {
assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);
for (int i = 0; i < CardanOrders.length; ++i) {
if ((k == 1) || (k == n - 1)) {
m.getRowAsDoubleArray(10);
double h2 = getDelta();
0.0, new double[pb.getDimension()+10],
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
private boolean pendingEvent;
return nextDouble() <= 0.5;
UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);
public double value(int i, int j) {
StatUtils.mean(values) == one);
return new TestSuite(LaguerreTest.class);
l.solve(b, 1.0e-10);
public static String translate(String specifier, String[] parts) {
new Percentile(0);
public class SplineInterpolatorTest extends TestCase {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
int k = 0;
private int[] getNatural(int n) {
assertEquals(Integer.MIN_VALUE, f.getNumerator());
bp[col][j] /= lu[col][col];
double[] expected = {halfSampleSize, halfSampleSize};
assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));
super.writeExternal(out);
DefaultValue() {
return iter.hasNext ();
throw new IllegalArgumentException("cannot multiply a "
class DormandPrince853StepInterpolator
private double[] z;
sum = sum - decomp[i][k]*x[k];
assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);
for (int k = 0; k < n24.length; ++k) {
assertEquals(10.0, dist.getMean(), 0.0);
double error = handler.getMaximalError();
ProperFractionFormat format = (ProperFractionFormat)properFormat;
return fst(data);
assertTrue("instances with same data should be equal", t.equals(u));
double dy = y - ybar;
oldX[pj] = parameters[pj].getEstimate();
m.multiply(new BigMatrixImpl(bigSingular));
polynoms[3][i] = bspl;
spacing = (max - min) / np; // spacing between adjacent new points
Arrays.sort(sort);
assertEquals(5, da.getElement(1), 0);
costPerStep[0] = sequence[0] + 1;
loadData();
coefficients[n-1] += t * tc[n-1];
(new RealMatrixImpl(testData2)).luDecompose();
if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {
return apply(new Kurtosis());
private double[][] orthogonalizeMatrix(double[][] m, double threshold)
checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");
return geometricMean.evaluate(values);
public double homoscedasticTTest(StatisticalSummary sampleStats1, 
public Polynomial multiply(double r) {
next = iter.nextSamplePoint();
DiagonalMatrix d = new DiagonalMatrix(k, 2.0);
p1 = p1.subtract(p2);
MathUtils.equals(stat.getMean(),this.getMean()) &&
public class ExponentialDistributionImpl extends AbstractContinuousDistribution
coefficients[0] = a[i] - c[i] * coefficients[0];
-19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},
public SingularMatrixException() {
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {
if (decompMatrix == null) {
TestSuite suite = new TestSuite(PercentileTest.class);
double[] xTab = new double[size];
public static class VariableStepHandler implements StepHandler {
long[] bcoef5 = {1,5,10,10,5,1};
return Double.NaN; //not enough data 
public void testHashCode() {
obj1 = new Integer(1);
2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,
public class ClassicalRungeKuttaIntegrator
suite.setName("Certified Tests");
-Math.asin(v2.getX()),
Polynomial.Rational Pk0g0 = Pk0.multiply(g0);
u.getVariance() != 0.0);
public void testSqrtNull() {
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.495) < 1.0e-10);
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
public long getCumFreq(char v) {
return new Rational(newA);
return new TestProblem2(this);
+ fac1 * polynoms[j+2][i]
int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);
return evaluate(values, 0, values.length, p);
public void testNoDenseOutput()
numerator /= d;
double[] resultData    = new double[columns * rows];
assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);
c[j] = newc;
for (int i = 0; i < root.length; i++) {
assertTrue(msg,m.subtract(n).getNorm() < tolerance);
implements SecondOrderDifferentialEquations {
public VectorialCovarianceTest(String name) {
private static final long serialVersionUID = 1368582688313212821L;
u.getStandardDeviation() != 0.0);
int nCols = in[0].length;
public double getEventTime() {
array1 = null;
double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;
("Interpolation requires at least two points.");
private static final long serialVersionUID = -197266611942032237L;
if (tmp != null) {
return round(x, scale, BigDecimal.ROUND_HALF_UP);
public LinearProblem(GeneralSquareMatrix a, Matrix x, Matrix b) {
p = Polynomial.Rational.euclidianDivision(p, b).quotient;
testDa.addElementRolling(4d);
assertEquals(sigma, s1.evaluate(values), 1E-14);
this.denominatorFormat = format;
assertTrue(result.getColumns() == b.getColumns());
b2.setElement(2, 20.0);
double[][] sumEntries = mPlusMInv.getData();
minIndices = (int[])    s.minIndices.clone();
return new Double(new double[] { 0.0 });
"singularit\u00e9 d''angles d''Euler" },
public TTestImpl() {
public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) 
t.addValue(4d);
assertTrue(regression.getSlope() < 0.0);   
private static final long serialVersionUID = -8352658048349159782L;
double[][] bDecrementData = bDecrement.getDataRef();
assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 0.990) < 1.0e-10);
checkPolynomial(p2, "-4.0 + 2.0 x");
public void setRecurrenceCoefficients(int k) {
private SummaryStatistics emptyStats = SummaryStatistics.newInstance();  
if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {
for (Iterator iterator = intervals.iterator(); iterator.hasNext();) {
-Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },
assertEquals("Rows31Cols31", mRows31Cols31,
public double getAlpha() {
public void testfirstDerivativeComparison() throws MathException {
assertEquals("testData column dimension",3,m.getColumnDimension());
n++;
implements SampledFunction, Serializable {
protected double sum = 272.90d;
public URL getValuesFileURL() {
private static double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;
result = solver.solve(0.6, 7.0, 1.0);
observed1, observed2, 0.4));
public double evaluate(final double[] values) {
return absoluteAccuracy;
assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);
max.increment(testArray[2]);
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
double paru = gNorm / delta;
public void testSetPropertyName(){
logSum -= Math.log((double)i);
" final a value={5}, final b value={6}, f(a)={7}, f(b)={8}",
assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);
assertEquals(0, random.nextInt());
private Map map = null;
(int) Math.floor(0.5 - 0.6 * log10R)));
String source = "-1" + getDecimalCharacter() + "2323";
if (interpolator.isForward()) {
return tTest. homoscedasticTTest(sample1, sample2, alpha);
public double nextUniform(double lower, double upper) {
.multiply(BigInteger.valueOf(denominator/d1));
double inv = 0.25 / q2;
return 1.0;
private ValueServer vs = new ValueServer();
assertTrue(m2.getRows() == m1.getRows());
public void testNullDenominator() {
if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {
yMidDots[0] = new double[y0.length];
public static double max(final double[] values) {
public ScalarValuedPair samplePointAt(int i)
int gcd = MathUtils.gcd(numerator, denominator);
public abstract RealMatrix getR();
double[] yTmpDot = new double[y0.length];
standardDeviation = new double[dimension];
protected Percentile stat;
m.scalarAdd(2d),entryTolerance);
x[i] = A + B;
"contained in this array.";
public PolynomialCoefficient(int degree) {
extends Exception {
public double getWeight() {
m = matrix.getRowDimension();
assertTrue(count > 700);
System.arraycopy(y, 0, out, 0, y.length);
private int rows;
Complex z = ComplexUtils.polar2Complex(r, theta);
m = new BigMatrixImpl(bigSingular); // singular
private static final long serialVersionUID = 3322454535052136809L;
public TestProblem1(TestProblem1 problem) {
if (((SwitchState) iter.next()).reset(t, y)) {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
a.setElement(0, 0,   2.0);
double c[] = { 4.0 };
assertTrue(count > 60);
protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {
result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);
return new DefaultValue(s);
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
this(list, null);
assertEquals( (short)1, MathUtils.indicator( (short)0 ) ) ;
return tTest.tTest(mu, sampleStats);
for (int j = 0; j < in[i].length; j++) {
check(new Interval(-10.0, 10.0), new Interval(9.0, 12.0), 50.0,
double prevM2 = m2;
LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();
lu = null;
RealMatrix mRows03Cols123 = new RealMatrixImpl(subRows03Cols123);
if (pv.abs() <= functionValueAccuracy) {
assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);
public final double cost;
public double[] getArray () {
6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};
f.invert();
private double[] min;
if (k == 1) {
EstimatedParameter p1 = new EstimatedParameter("p1", 1.0);
for (int i = 1; i < binCount-1; i++) {
if (fl == x) {
return (Interval) intervals.get(i);
return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);
private static final long serialVersionUID = 5318837237354354107L;
sum2 += x * x;
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,
if (minimalIterationCount == 1) {
xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));
for (int i = 0; i < binCount; i++) {
3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 
public class EnhancedSimpsonIntegrator
RealMatrixImpl result = new RealMatrixImpl(dimension, dimension);
public double[] getInterpolatedState();
return lower + (long) (sec.nextDouble() * (upper - lower + 1));
da.setElement(3, 7.0);
return new Rational();
q0 = q1;
double sum = 0.0;
return (long) (nextDouble() * Long.MAX_VALUE);
private String y = "1.0";
yDot[2] = -invR3  * y[0];
public static double sinh(double x) {
assertEquals(1.61803399, gr, 10e-9);
assertEquals(4, da.getElement(0), 0);
list.add(bean);
TestUtils.chiSquareTest(expected1, observed1, 95);
private static final long serialVersionUID = -1868088725461221010L;
Complex y = new Complex(3.0, 4.0);
assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);
interpolator.setInterpolatedTime(0.1);
assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);
public void testSetImaginaryFormatNull() {
PolynomialFunction f = new PolynomialFunction( f_coeff );
public static double regularizedGammaQ(double a, double x)
DiagonalMatrix d = new DiagonalMatrix(6);
s.append("x");
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
BeanTransformer b = new BeanTransformer("y");
double h = (max - min) / n;
return data [i];
assertEquals(0, new Polynomial.Rational(0l, 0l, 0l).getDegree());
double yb = coeffs0[coeffs0.length - 1] / coeffs0.length;
fail("Expecting IllegalArgumentException - mismatch input arrays");
Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance);
public BigInteger getNumerator() {
class TestProblem4
assertEquals(4d, distribution.getBeta(), 0);
public int converged (double xLow, double fLow,
mean.increment(-2d);
public NotARotationMatrixException(String specifier, String[] parts) {
return tTest.tTest(sample1, sample2);
integ.setStepHandler(new InterpolatingStepHandler());
double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));
double t, double[] y, double[] yDot)
ret = (Double.doubleToRawLongBits(real) ==
if ((sampleStats1 == null) || (sampleStats2 == null ||
assertClose("lu decomposition does not work", permuted,
unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
fail("expecting ArithmeticException");  //should overflow
UnivariateRealFunction function = new SinFunction();
assertFraction(0, 1, new Fraction(0.00000000000001));
- Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);
data[indexL]  = data[indexU];
while (res.remainder.getDegree() != 0) {
inf = Math.max(inf, i.inf);
t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;
HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);
throws ArrayIndexOutOfBoundsException, FunctionException {
Vector3D u = new Vector3D(x, y, z);
new PolynomialFunction(new double[] {1d, 2d});
f1.divide(f2);
public MatrixIndexException() {
3.4446594929961e-5, 3.3515605877800e-5, 3.2633616249437e-5,
private static final double e6 =     22.0 / 525.0;
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);
if (obj instanceof Complex) {
v[k]  = new double[dimension];
private int sampleSize;
extends TestProblem1 {
public void testTransformString() throws Exception {
checkMatrix(s, new ElementPattern() {
2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);
optimum =
public void testGetReducedFraction() {
if (((nRows + row) > this.getRowDimension()) ||
public UncorrelatedRandomVectorGenerator(int dimension,
assertEquals(0, MathUtils.nextAfter( Double.MIN_VALUE, -1), 0);
protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},
Double.toString(orthoTolerance)
public DiagonalMatrix(int order) {
while (i <= maximalIterationCount) {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
public abstract double pairedT(double[] sample1, double[] sample2)
direct.add(points);
t /= 2; // cast out twos
long[] observed5 = {10, 10, 12, 10, 15};
public void testErf2807() throws MathException {
public class DormandPrince54IntegratorTest
double[] test = {5,4,3,2,1};
protected Kurtosis stat;
return new double[][] { { -20 * x1, 10 }, { -1, 0 } };
m.toString());
ratio = (preRed == 0) ? 0 : (actRed / preRed);
return addSub(fraction, false /* subtract */);
firstStepAlreadyComputed = true;
a.setElement(2, 1, -9.0);
protected double percentile5 = 8.29d;
assertEquals(15, f.getDenominator());
return (sumY - slope * sumX) / ((double) n);
double s = bbt.getEntry(i, j);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
UpperTriangularMatrix u = buildMatrix(5, new ElementPattern() {
+ coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];
regression.getSumSquaredErrors(),10E-9);
public SimpleRegressionTest(String name) {
1.0, new double[pb.getDimension()+10]);
assertEquals(d1.getBinStats(), d2.getBinStats());
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);
TestBean target = new TestBean();
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
td.cumulativeProbability(.1);
public double[] inversetransform2(double f[]) throws MathException,
double ti = temp * tmp2 - tmp1;
updateArray(internalData);
for (int i = 0; i < row; i++) {
super.setElement(j, i, value);
complexFormatJ.setImaginaryCharacter("j");
resultComputed = true;
double scaling = 1.0 / n;
assertEquals(3.0, z.getReal(), 1.0e-5);
public double abs() {
if (mean.length != order) {
public void nextBytes(byte[] bytes) {
GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));
public static double evaluate(double x[], double y[], double z) throws
case BigDecimal.ROUND_HALF_EVEN : {
B = f[i+2].add(f[i+3]);
double[] y0 = { 1.0, 0.1 };
setInitialConditions(0.0, y0);
public static double regularizedBeta(double x, double a, double b,
selectedColumns.length);
public VectorialValuedPairTest(String name) {
"Exception de conversion dans une transformation, l''objet est nul" },
sum[k] += weightedRoots[j][0] * value[k];
boolean lastStep         = false;
this.minStep     = minStep;
public EstimatedParameter[] getAllParameters();
public double estimateError(double[] scale) {
if (Double.isInfinite(x)) {
empiricalDistribution.load(valuesFileURL);
if (object instanceof AbstractStorelessUnivariateStatistic == false) {
public void testAcos() {
double   omegaX = omega * point.x;
f[i] *= dx;
public void setAbsoluteAccuracy(double accuracy) {
public void testGeometricMean() throws Exception {
public ArgumentOutsideDomainException(double argument, double lower, double upper) {
private static final double d0 =  -12715105075.0 /  11282082432.0;
int mu = 2 * k - mudif + 3;
pb.getInitialTime(), pb.getInitialState(),
double dot = dotProduct(v1, v2);
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
public Complex[] transform(Complex f[]) throws MathException,
SymetricalMatrix m = new SymetricalMatrix(order);
inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();
5.069831575018909,10E-7);
+ k.getZ() * (u1x * u3y - u1y * u3x);
public double[] transform2(double f[]) throws MathException,
return evaluate(values, 0, values.length);
if (permutations == null)
return new RationalNumber(p, q.multiply(l));
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
final int begin, final int length)  {
TestProblemHandler handler = new TestProblemHandler(pb);
if (fraction > 0.5) {
public static double[] bracket(UnivariateRealFunction function, 
assertTrue(u.toString().indexOf("NaN") > 0);  
assertEquals(loop.getMean(), direct.getMean(), 1.0e-12);
public interface ArraySliceMappable {
protected double scalRelativeTolerance;
public void integrate(FirstOrderDifferentialEquations equations,
minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },
value = 3;
p = i;
c = properFormat.parse(source);
double lowerBound = getDomainLowerBound(p);
public Variance(boolean isBiasCorrected) {
public void testScalarProduct() {
class DormandPrince54StepInterpolator
1.0e-10, 1.0e-10);
0.73, 0.96, 1.34, 2.10, 4.39
"Matrix must have at least one row."); 
public double tTest(double mu, double[] sample)
checkMatrix (m2, new BilinearPattern(1.0, 0.01));
WeibullDistribution distribution = (WeibullDistribution) getDistribution();
scalar3 = new MappableScalar(-3);
tstGetSortedValues(test1);
0x000fffffffffffffL);
BigInteger newP = p.multiply(r.q);
assertEquals(1.5, u.getMean(), tolerance);
double[] scale, double[][] f,
for (int row = 0; row < m.getRowDimension(); row++) {
found = true; 
double minStep = 1.25;
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
protected RationalNumber[] a;
for (int j = 0; j < n; ++j) {
private EstimatedParameter cy;
setFinalConditions(4.0);
double[] scale = new double[y0.length];
double ph2 = yp1 - yp0;
public EvaluationException(Throwable cause) {
z = 0.5; expected = f.value(z); result = p.value(z);
if (((Math.abs(actRed) <= costRelativeTolerance)
checkMatrix(l1, new BilinearPattern(1, 0.2));
res[0] = yb * b - ya * a;
assertEquals(1.0, StatUtils.variance(sample), 0.01);
++count;
private CorrelatedRandomVectorGenerator generator;
double[] tempArray = new double[newSize];
double prevM3 = m3;
return (int)((r * upper) + ((1.0 - r) * lower) + r);
fail("Expecting ConvergenceException");
("Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}",
public Double(long a3, long a2, long a1, long a0) {
BisectionSolver solver = new BisectionSolver(f);
if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {
this(new RationalNumber(value));
public SymetricalMatrix(double w, double[] a) {
private static final long serialVersionUID = -7658917278956100597L;
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); 
public void testMinMax() {
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
return new DivisionResult(quotient, remainder);
checkValue(f.divide(new PolynomialFraction(4l,9l)), "3/2");
ListUnivariateImpl u =
x = 0;
protected void setRecurrenceCoefficients(RationalNumber b2k,
min = -1.0; max = 2.0; expected = 0.0;
public int getJacobianEvaluations() {
TestUtils.assertEquals(new Complex(inf, -pi / 2),
public GeneralMatrixTest(String name) {
assertFalse("different n's should make instances not equal", t.equals(u));
assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);
decompose(m);
double q, A, B, C, delta, denominator, tolerance;
public double getRegressionSumSquares() {
public static UnivariateRealFunction centerDifferenceDerivative(UnivariateRealFunction function, double delta) {
throws MathException;
double[][] m3 = r.getMatrix();
byte[] randomBytes = new byte[40];
ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
double newValue = 1.0e-2;    
d01 = (y1 - y0) / (x1 - x0);
if (c[ir][ir] < small) {
return getGamma().getAlpha() * 2.0;
double dx = x / 10.0;
assertFraction(0, 1, b.subtract(b));
double r2 = y1 / y2;
b2 = null;
return q.compareTo(BigInteger.ONE) == 0;
n = x.length;
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
boolean isLoaded();
throws CardanEulerSingularityException {
public GeneralSquareMatrix(int order) {
private boolean isNonNegative(long[][] in) {
fc = fa;
checkValue(new RationalNumber(17l, 3l).add(new RationalNumber(-17l, 3l)),
if (time > interval.getPreviousTime()) {
binStats = new ArrayList();
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));
public static String formatComplex( Complex c ) {
assertEquals(0L, first.longValue());
public void testConstructorNaN() {
StatUtils.varianceDifference(sample1, small, meanDifference);
public ListUnivariateImplTest(String name) {
assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);  
RotationOrder[] CardanOrders = {
BigDecimal[] getColumn(int col) throws MatrixIndexException;
list.add(new Double(v));
this.denominatorDegreesOfFreedom = degreesOfFreedom;
double tan = lmDiag[k] / rkk;
double p, q, r, s;
public GeneralMatrix(int rows, int columns, double[] data) {
public double[][] getMatrix() {
double d00 = m2[0][0] - m3[0][0];
Double.MIN_VALUE); 
public void testEmptyTable() {
if (isRootOK(min, max, root[i])) {
if (test(values, begin, length) && length > 2 ){
checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(-2l, 3l)),
public void addWeightedPair(double weight, double x, double y) {
assertClose("identity multiply",m.multiply(identity),
VitalStats vs3 = new VitalStats( new Double(90.0), 
public static final int GAUSSIAN_MODE = 4;
return false;
double  maxError         = Double.MAX_VALUE;
assertEquals(1.5, p.evaluate(d), 1.0e-5);
sampleStats1.getVariance(), sampleStats2.getVariance(), 
Vector3D v1 = new Vector3D(2, 1, -4);
double df = ((double) counts.length -1) * ((double) counts[0].length - 1);
checkLaguerre(new Laguerre(2), 2l, "2 - 4 x + x^2");
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
assertEquals("3x4 Q size", qr.getQ().getRowDimension(), 3);
int optimalIter;
double dx1 = v1x - u1.getX();
test3[i], test1[i],0.0);
DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);
printStackTrace(System.err);
return (int)m;
optimalIter = k-1;
public abstract  class DecompositionFactory {
SummaryStatistics t = null;
public Rational(RationalNumber value) {
covData[j][i] = s;
public double evaluate(double x, int maxIterations) throws MathException {
tstGen(0.1);
public MathUtilsTest(String name) {
0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};
this.value = value;
public int getExpansionMode() {
minpackTest(new ChebyquadFunction(9, 9, 1.0,
assertEquals(5, da.getElement(2), 0);
double tmp1 = i  + 1;
if (size < 0) {
extends AbstractContinuousDistribution
assertEquals("3x3 singular A = QR", 0, norm, normTolerance);
assertTrue(Math.abs(value - reference) < 1.0e-10);
private static final long serialVersionUID = 7320613236731409847L;
yDot[0][1] = (y[1] - y0[1]) / dt;
private double cost;
public class Divide implements Evaluation, Serializable {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
assertEquals(95.1981, p.evaluate(d), 1.0e-4);
private boolean g0Positive;
assertEquals(reference, p.toString());
BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);
suite.addTest(PolynomialFitterTest.suite());
value = randomData.nextSecureLong(0,3);
lmPar = Math.max(parl, lmPar + correction);
assertEquals(m.getEntry(i, j), 1d, 0);
x2 = x; y2 = y;
lcm = q.getDenominatorsLCM();
F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);
private double a;
return new Variance(secondMoment).getResult();
fail("sorted values out of sequence");
-164464906.857771
public void testAlefeldPotraShi()
assertEquals( 1.0F, MathUtils.indicator( 0.0F ), delta ) ;
shuffle(index, n - k);
return new RealMatrixImpl(data);
protected double var = 10.00235930735930;
double tmp1 = 1;
verifyInputArray(a, c);
this.vitalStats = vitalStats;
sum = sum + lanczos[0];
private void checkArray(long[][] in) throws IllegalArgumentException {
public Complex add(Complex rhs) {   
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
public Percentile() {
work[k] = temp;
s.selfAddWAAt(1.0, a1);
testStatistic.chiSquare(expected,observed) < 10.83);  
return Integer.MAX_VALUE; 
return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);
System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
for (int i = 0; i < N; i++) {
TestSuite suite = new TestSuite(QRDecompositionImplTest.class);
assertTrue(stack2.indexOf(inMsg) != -1);
return new TestSuite(VectorialValuedPairTest.class);
if (! a3.isZero()) {
public void testScale() {
assertEquals("summaries based on same data should have same hashcodes", 
private static DummyStepHandler instance = null;
double[][] ort = orthogonalizeMatrix(m, threshold);
protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};
private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {
+ k.getY() * (u2z * u3x - u2x * u3z)
assertTrue(
x0 = min; y0 = f.value(x0);
public EmpiricalDistributionImpl(int binCount) {
return lcm;
m = new RealMatrixImpl(luData);
newA[i] = a[i].add(p.a[i]);
permData[i * bCols + j] = b.data[permutations[i] * bCols + j];
Interval ib = new Interval(i1);
public void testAxisAngle() {
return new Complex(0.0, 0.0);
0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};
return q2;
fail ("Expecting MatrixIndexException");
fitter = new DummyFitter();
private static class Polynom {
u.getGeometricMean(), Double.MIN_VALUE);
double x21 = m[2][1];
assertEquals( "chi-square test statistic", 
assertFraction(0, 1, new Fraction(0, 2));
protected AbstractDistribution() {
double getEntryAsDouble(int row, int column) throws MatrixIndexException;
Math.sqrt(24.2)), false);
1270.9838708654), false);
double epsilon = 1.0e-7;
for (int i = 4; i < 10; ++i) {
this.valuesFileURL = url;
public double getCumPct(long v) {
for (int j=0;j<d[i].length;j++)
freqTable.put(obj, new Long(count.longValue() + 1));
testDa.getElement(-1);
Object[] cSamp = randomData.nextSample(cPop,2);
assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);
"probability of success must be between 0.0 and 1.0, inclusive.");
StatisticalSummary {
observed[1]++;
d[row][col] = row == col ? 1d : 0d;
return new RandomAdaptor(randomGenerator);
freqTable.clear();
FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,
public FirstOrderConverterTest(String name) {
y1 = f.value(x1);
private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
if (sorted.length != test.length) {
patientList.add( p3 );
private static final double e1_12 =           -137909.0 / 6168960.0;
return sorted[0];
"Elements cannot be retrieved from a negative array index";
public void testDegenerateFullSample() throws Exception {
double[] tempArray = new double[numElements + 1];
new ChiSquareTestImpl();
assertEquals(1, MathUtils.gcd(-a, -c));
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
private double initialTime;
(nCols + column > this.getColumnDimension()))
MathException cause = new MathConfigurationException(inMsg, new Object[0]);
assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); 
public interface SwitchingFunction extends Serializable {
q1 *= inv;
double expected = (i < j) ? 0.0 : (j + 0.1 * i);
throw new RuntimeException();
public Complex[] transform(
result = solver.solve(0.6, 7.0, 0.61);
integ = null;
private static final double[] y = {
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
f2 = new Fraction(1,3).negate();
double[] internalArray;
assertTrue(maxStep > 1.7);
assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));
polynoms[j+4][i] = 16 * (yMidDots[j][i]
lmPar /= tmp;
lmDir[j] = diagR[pj];
public String heresFoo() {
assertEquals("max", max, u.getMax(), tolerance);
checkValue(new RationalNumber(1l, 6l).add(new RationalNumber(2l, 6l)),
assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));
if ((perm.length != 1) || (perm[0] != 0)){
resetTables(yMidDots.length + 4);
if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {
return new ExponentialDistributionImpl(5.0);
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
protected void checkIdentityBigMatrix(BigMatrix m) {
public static void assertRelativelyEquals(double expected, double actual,
public void testNextPermutation() {
if (sign == -1) {
m.getSubMatrix(1,0,2,2);
final double[] values, final int begin, final int length) {
result = -result;
c = improperFormat.parse(source);
parameters[pj].setEstimate(oldX[pj]);
super(maxIterations,
assertTrue(p.multiply(denominator).toString().equals(reference));
ComplexUtils.polar2Complex(0, 1), 10e-12);
Long value = (Long) freqTable.get(v);
sum += cP * previous.getY() + cC * current.getY() + cN * next.getY();
polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);
package org.spaceroots.mantissa.linalg;
Random randomizer = new Random(86757343594l);
"1/2");
double determinant,
private ArrayList l;
m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);
assertTrue(m.isIgnored());
Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);
-4.54137546533666,     1.01201188830857
public Object[] nextSample(Collection c, int k) {
cols        = parameters.length;
Object[] sets = new Object[10]; // 2-sets from 5
private float two = 2;
public void testMultiply() {
assertSame(nf, cf.getImaginaryFormat());
getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),
(isAdd ? MathUtils.addAndCheck(uvp, upv) : 
return (f.value(x) - f.value(x - h)) / h;
newP = (Polynomial.Rational) newP.negate();
< 1.0e-12);
Math.sqrt(context.doubleValue(argument)));
package org.apache.commons.math.special;
PolynomialFunction p[] = new PolynomialFunction[n];
Fraction zero  = new Fraction(0,1);
Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);
checkValue(new RationalNumber(-1l, -2l), "1/2");
return new TestSuite(PolynomialRationalTest.class);
double value = Double.parseDouble(line);
+ " cannot be a rotation matrix",
for (int i = 0; i < (m - 1); ++i) {
computeOmega(isInverse ? -2*N : 2*N);
public abstract class AbstractContinuousDistribution
private static final long serialVersionUID = -5127043442851795719L;
h = -h;
((ResizableDoubleArray) da).setNumElements(1024);
this(coefficients,
return function.getDimension();
if (state.getEventTime() < first.getEventTime()) {
return new TestSuite(DormandPrince853IntegratorTest.class);
Complex z = x.divide(y);
assertTrue(handler.getLastError() < 2.0e-4);
diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];
assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);
public void testDivide() {
728675.473768287,
ConstantGenerator generator = new ConstantGenerator();
assertTrue(realNaN.equals(imaginaryNaN));
public static Complex sqrt(Complex z) {
public static boolean pairedTTest(double[] sample1, double[] sample2,
return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
int index = pos.getIndex();
double r = 1.0d;
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
sumX = 0d;
fo.close();
filePointer.close();
+ b4 * yDotK[4][i] + b5 * yDotK[5][i];
if (trans != null) {
for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {
-0.000563932208347327, 0.347820540486998,
return skew;
return intervals.size();
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
int    kDiag = k * cols + pk;
ignored            = false;
public double cost(double[] x) throws CostException {
public DomainObject(int size) {
assertEquals(50.19f,  MathUtils.round(50.185f, 2), 0.0f);
array[i] = (i + 1) * inv;
public class MappableArrayTest
assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 1.0) < 1.0e-10);
boolean exceptionOccurred = false;
assertEquals(-1.0, coefficients[4], tolerance);
StatUtils.mean(x, 0, 4);
TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);
private static final long serialVersionUID = -6576285612589783992L;
z = 0;
checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(-2l, 5l)),
s.append(java.lang.Double.toString(absAi));
Variance v = new Variance(m4);
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
assertEquals( f.value( -123.5), c[0], tolerance );
assertEquals("3" + getDecimalCharacter() + "14", text);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
private int nextAction;
int index2 = j;
ComplexUtils.pow(null, Complex.ONE); 
checkPolynomial(new Chebyshev(0), "1");
switch (c) {
public class ContinuousOutputModel
int p1 = a0;
new Interval(-10.0, 12.0), new Interval(11.0, 11.0));
verifyDataSet(data);
assertTrue(Math.abs(b2.getElement(0) - 0.4) < 1.0e-10);
Double.toString(costRelativeTolerance)
assertFalse(x.hashCode()==y.hashCode());
public void testTanh() {
return new TestSuite(HighamHall54StepInterpolatorTest.class);
if (! reject) {
ret = getMedian() + getScale();
v = Math.pow(n, u);
Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);
return m.multiply(this);
return realFormat;
int rowCount = this.getRowDimension();
result = dist.normalApproximateProbability(10200)
-1.46468676748716, 0.0128675339110439,
uRef.getX() * q2 - uRef.getY() * q1);
return this.percentile95;
public class FunctionEvaluationExceptionTest extends TestCase {
if (((Interval) iterator.next()).contains(i)) {
0.997754216442807, 0.997754216442807,
public void testBigStep()
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
public double getMean() {
xNorm  += xk * xk;
14.136097974741747174,
UnivariateRealIntegrator integrator = new RombergIntegrator(f);
assertTrue(Double.isNaN(z.imaginary));
private static class MeyerFunction extends MinpackFunction {
errfac = null;
double[] roots28 = {
public UpperTriangularMatrix(int order) {
return Gamma.regularizedGammaQ((double)x + 1, mean, 
checkMatrix(s1, new ElementPattern() {
assertEquals(result, 1.0, solver.getAbsoluteAccuracy());
SampledFunctionIterator sampler =
MathException ex = new MathException(pattern, arguments);
public void testAddInfinite() {
public class FirstOrderConverterTest
double rik = jacobian[i * cols + pk];
public NormalDistribution createNormalDistribution() {
public static final int EXPONENTIAL_MODE = 3;
return new NonNullRange(Math.max(first.begin, second.begin),
c[ij][ii] = f;
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
dist.inverseCumulativeProbability(p);
min = 0; max = Math.PI; expected = 2;
return getRegressionSumSquares(getSlope());
public final class RombergIntegratorTest extends TestCase {
double x, spacing, sum = 0;
resultData[j][i] = e;
regression.getRSquare(), 10E-12);
+ e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
public double getIntercept() {
assertEquals(-17 - 2*13*2, f.getNumerator());
public String getMessage(Locale locale) {
l = new ArrayList();
public double getPct(char v) {
Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);
return RESET_DERIVATIVES;
resetTables(degree);
da.addElement(2);
-Math.sqrt ((35.0 + 2.0 * Math.sqrt (70.0)) / 63.0) },
assertFraction(1, 1, a.add(a));
throws MatrixIndexException {
public abstract void computeBinStats(double min, double delta)
assertEquals(4, da.getElement(1), 0);
TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);
m.preMultiply(testVector);
if ((startIndex + i) > internalArray.length) {
return this.var;
public double integrate(ComputableFunction f, double a, double b)
assertEquals("3x4 Q size", qr.getQ().getColumnDimension(), 3);
solver.setAbsoluteAccuracy(newValue);
testStatistic.tTest(sample1, tooShortObs);
tolerance = Math.abs(derivativebound * partialerror(x, z));
public final class StatisticalSummaryValuesTest extends TestCase {
if (hex.length() == 1) {
LaguerreSolver solver = new LaguerreSolver(f);
GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,
assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));    
min = -5.0; max = -2.5; expected = -3.0;
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
createHypergeometricDistribution(int populationSize,
double[][] upperData = new double[n][n];
int startK = (maxDegree - 1) * maxDegree / 2;
x = x2 - 2.0 * C * (x2 - x1) / denominator;
double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / ((double) length))) /
public void testCompareTo() {
geoMean.increment(value);
stack = baos.toString();
if (trials < 0) {
public Complex[] solveAll(double coefficients[], double initial) throws
private static final long serialVersionUID = -8178734905303459453L;  
f.subtract(null);
assertEquals(inf, z.conjugate().imaginary, 0);
private static final long serialVersionUID = -3833485397404128220L;
private double[][] m7 = {{1, 2, 3}, 
u.addObject("12.2");
public BeanListUnivariateImpl(){
private UnivariateRealSolverFactory factory;
double m = mean.evaluate(values, begin, length);
double inv = 0.25 / q3;
ScalarValuedPair pair1 = new ScalarValuedPair(1.2, -8.4);
0.990d, 0.975d, 0.950d, 0.900d,1}; 
("sample size exceeds collection size");
super(y, forward);
3.0),
return maxGrowth;
u.addValue(3d);
throw new IllegalArgumentException("mean must be positive.");
assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));
Double.MIN_VALUE, Double.MAX_VALUE};
if (costC < largest) {
if (degreesOfFreedom <= 0.0) {
return Double.valueOf(str).doubleValue();
currentTime       = Double.NaN;
public void testLocalMaximumCentered() {
m2.scalarMultiply(-1d).add(m),entryTolerance);        
public static double sum(final double[] values) {
parameters[i] = new EstimatedParameter("p" + i, startParams[i]);
private static final long serialVersionUID = -2154780004193976271L;
optimalIter = k;
private Complex negInfNegInf = new Complex(neginf, neginf);
GammaDistribution distribution = new GammaDistributionImpl( a, b );
public class DummyStepHandler
if (i % 2 == 0) {
private double sum2;
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
this.sum = sum;
assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);
? Math.max(1.0e-6, 0.001 * Math.abs(h))
extends DirectSearchOptimizer {
-18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,
StatUtils.meanDifference(sample1, small);
public double getNextValue() throws IllegalStateException {
vs.setMode(1000);
private static final long serialVersionUID = 3405465123320678216L;
Polynomial.Rational p = new Polynomial.Rational(new RationalNumber(2l, 5l),
Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) }
public static int gcd(int u, int v) {
assertTrue(new Polynomial.Rational().isZero());
for (int index = 0; index < order * order; index += order + 1) {
assertEquals("std err intercept", 0.232818234301152,
this.denominatorFormat = denominatorFormat;
a.setElement(1, 0, 1.0);
protected final void setResult(double result, int iterationCount) {
public void testWithInitialCapacity() {
dist.setPopulationSize(10);
assertEquals(0, statistic.getN());
if (!coefficientsComputed) {
++costEvaluations;
throw ex;
distribution.setBeta(0d);
public void testCostExceptions() throws ConvergenceException {
"trop petite tol\u00e9rance sur l''orthogonalit\u00e9 ({0}), la solution est orthogonale \u00e0 la jacobienne" },
double getMedian();
res.append("RealMatrixImpl{");
super((rootCause == null ? null : rootCause.getMessage()));
v2 = new double[interpolatedState.length];
new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); 
protected double nDev;
double delta = (max - min)/(new Double(binCount)).doubleValue();
assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), 
private long oneL = 1;
Number num = getNumeratorFormat().parse(source, pos);
Matrix inverse = u.getInverse(1.0e-10);
return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
c  = a;
f2 = new Fraction(2, 7);
a = new double [n];
A = f[i].add(f[i+1]);
stdDev = 0.0;
+ " - 9104813935044723209570256 x^30"
++j) {
public IntervalsList() {
suite.setName("Variance Tests");
assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);
if (firstIteration) {
public Complex[] inversetransform(double f[]) throws MathException,
public long getSumFreq() {
public void addData(double[][] data) {
F[0] = 0.0;
double j4  = j3 / v[i];
protected void assertClose(String msg, BigMatrix m, BigMatrix n,
return (o2 == null) ? 0 : +1;
initialNorm += ratio * ratio;
return new FirstOrderIntegratorFactoryImpl();
private boolean forward;
double ak2 = Double.NEGATIVE_INFINITY;
checkValue(fInverse, "13/4");
1.3, 0.65, 0.65, 0.7, 0.6,
super(rows, columns);
private static final short NS = (short)-1;
if (dpj != 0) {
double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };
Random randomizer = new Random(53882150042l);
sum  += parameters[j].getEstimate();
EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true);
public void testRegularizedGammaZeroPositive() {
x2 = x0;
public void testSingular()
ran.nextBytes(randomBytes);
if (internalData != null) {
countSum2 += observed2[i];   
double v1v1 = Vector3D.dotProduct(v1, v1);
sum [k] *= halfStep;
public void testAdd1000() {
private double[][] d5 = new double[][] {{30},{70}};
public class ErfTest extends TestCase {
0.0147639629786217,   0.146342334818836,
MathUtils.binomialCoefficientLog(n, k));
nf.setMaximumFractionDigits(0);
protected int calls;
ret = getMean() + getStandardDeviation();
1.0 - Beta.regularizedBeta(
6.232056007d, 7.497630467d, 10.51154969d};
public void testMoreEstimatedParametersUnsorted() throws EstimationException {
double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])
return new BinomialDistributionImpl(10,0.70);
new DormandPrince54Integrator(minStep, maxStep,
TestUtils.assertEquals(expected, actual, 10e-15);
public class FastFourierTransformer implements Serializable {
b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;
double mi = theoreticalMinParams[i];
dp.value(0), dSpline.value(knots[i]), tolerance);
assertEquals(x2[i], result[i].getReal(), tolerance);
public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;
+ d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i]
double ratio2  = errSum2 / tol;
if (x < min || x > max) {
q = -q;
return sumDifference(sample1, sample2) / (double) sample1.length;
public static BigMatrix createColumnBigMatrix(String[] columnData) {
problems.add(new APSProblem20(n20[k], 0.0, 1.0, roots20[k]));
return "Subtract";
BigMatrix permuted = permuteRows(matrix, permutation);
public RealMatrix copy() {
solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); 
throw new ExhaustedSampleException(measurements.length);
for (int i = 0; i < result.length; i++) {
protected double tTest(double m1, double m2, double v1, double v2, 
assertTrue(exceptionExpected);
root[i] = solve(subarray, initial);
private static final long serialVersionUID = -3485529955529426875L; 
double ratio;
result = transformer.transform(f, min, max, N);
assertTrue(handler.getMaximalError() < 1.0e-7);
ResizableDoubleArray testDa = new ResizableDoubleArray(2);
m2.setSubMatrix(testData,0,1);
gamma *= beta[pk];
return new VectorialValuedPair (x, function.valueAt(x));
double threshold = 0.6 * getNorm();
if (! q.isOne()) {
checkValue(new PolynomialFraction(1l, 2l).subtract(new PolynomialFraction(1l, 6l)),
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
q0 = Vector3D.dotProduct(vRef, k) / (c + c);
DiscoverClass dc = new DiscoverClass();
return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
for (int index = 0; index < work.length; ++index) {
public class MathException extends Exception {
public class RealMatrixImpl implements RealMatrix, Serializable {
PoissonDistribution dist = new PoissonDistributionImpl(1.0);
new EstimatedParameter("p0", 7),
NoSuchAlgorithmException {
package org.spaceroots.mantissa.quadrature.scalar;
double step) {
hs = new HashSet();
for (int l = 0; l < functions.length; ++l) {
if (! initialized) {
public class PolynomialFitterTest
+ " in {0} iterations",
+ " - 9763073770369381232400 x^14"
("overflow: numerator too large after multiply");
int[] testi = null;
public class LewTest extends CertifiedDataAbstractTest {
double p;
throws EvaluationException {
assertTrue(Math.abs(pair2.getY() - pair1.getY()) < 1.0e-10);
public double[] makeCumulativeTestValues() {
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
for (int i = 0; i < 6; i++) {
firstStepAlreadyComputed = false;
for (int i = 0; i < in.length; i ++) {
public GraggBulirschStoerStepInterpolatorTest(String name) {
suite.addTest(GeneralMatrixTest.suite()); 
System.arraycopy(polynomials, 0, p, 0, n);
throw new InvalidMatrixException("Matrix is singular.");
public Double(double value) {
verifyIterationCount();
double[][] y1Diag = new double[sequence.length-1][];
MathConfigurationException ex = new MathConfigurationException(pattern, arguments);
public final class BisectionSolverTest extends TestCase {
return MatrixFactory.buildMatrix(rows, m.columns, resultData,
assertEquals(-7.0, c[3], tolerance);
public void testErf2576() throws MathException {
int startIndex = pos.getIndex();
private int omegaCount = 0;
checkVector(r.getAxis(), new Vector3D(s, s, s));
assertEquals(1.5,
TestSuite suite= new TestSuite("org.spaceroots.mantissa.fitting"); 
dimension = s.dimension;
mapper.manageMappable(scalar3);
ret = 0.5 * t;
ConvergenceChecker checker)
return new DormandPrince54Integrator(minStep, maxStep,
PointCostPair[] reflected = simplex;
public void testNaN() {
return new NonNullRange(j, rows);
for (int j = Math.max(0, i + 1 - p.a.length);
setMean(mean);
Math.atan2(v2.getY(), -v2.getX())
TestUtils.tTest(sample1, sample2, 0.2));
assertTrue(Math.abs(l.getDeterminant(1.0e-10) - Math.pow(2.0, l.getRows()))
private ArrayList functions;
Complex expected = new Complex(1.41421, 1.41421);
if (k == 0) {
EstimatedParameter[] parameters = measurements[i].getParameters();
this(INFINITE_WINDOW);
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 1);
public class ScalarValuedPair
return new Fraction
da.addElement(2.0);
if (((Interval) iterator.next()).intersects(i)) {
public static boolean homoscedasticTTest(double[] sample1, double[] sample2,
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void resetMinimalIterationCount() {
new EstimatedParameter[] { p[0], p[2] },
f = f.reciprocal();
public StreamDataAdapter(BufferedReader in){
"must be a positive integer";
? new PolynomialFraction((Polynomial.Rational) q.negate(),
private static final double sqrt5  = Math.sqrt( 5.0);
for (int j = n-i-1; j >= 0; j--) {
Integer c = new Integer(randomBytes[i]);
public void testComposeInverse() {
public void testDifferentials() {
RealMatrix p = m.multiply(n);
assertTrue(maxStep > (1.0 / 2.0));
private static final long serialVersionUID = -8091216485095130416L; 
return new TestSuite(EulerIntegratorTest.class);
denominator /= d;
assertEquals(-1, c.getNumerator());
m.setSubMatrix(detData3,1,1);
assertTrue(Double.isNaN(moment.getResult()));
setDegreesOfFreedom(df);
assertEquals(96.07590211815305, circle.getX(),      1.0e-10);
int iMax = steps.size() - 1;
double s = ort[0][0] + ort[1][1] + ort[2][2];
return q1;
double expected[] = { 0.0, 3.26197262739567, 0.0,
public class CauchyDistributionImpl extends AbstractContinuousDistribution 
double c2 = sxy * sxz - sx2 * syz;
BufferedReader in = new BufferedReader(new FileReader(file));
assertTrue(i1.contains(x)    ^ (!b1));
public BigDecimal[] operate(double[] v) throws IllegalArgumentException {
this.tolerance = tolerance;
4.0, accuracy);
public class FirstOrderConverter
public interface UnivariateRealFunction {
double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };
old = improperFormat.getNumeratorFormat();
TestSuite suite = new TestSuite(ChiSquareTestTest.class);
String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";
public void testDivideNaN() {
String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";
public class PolynomialDoubleTest
a.setElement(1, 0,  2.0);
BeanListUnivariateImpl u = new BeanListUnivariateImpl(null);
public void testFormatNegative() {
assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));
return (x >= 0.0) ? 1.0 : -1.0;
private double m3Det = 6.0d;
setMinReduction(0.2);
public static FractionFormat getProperInstance(Locale locale) {
areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));
private double initialStepBoundFactor;
public static double tTest(double mu, double[] sample)
private double[] costPerTimeUnit;
q2 = -w.getY();
NumberFormat imaginaryFormat) {
if ((forward && (currentT + h > t))
n = 0;
public void incrementAll(double[] values) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
protected double[][] colMatrix = {{0},{4},{6}};
LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {
m2 += ((double) n - 1) * dev * nDev;
public void testTestPositive() {
public void addPoint(double px, double py) {
ai.finalizeStep();
double x01 = m[0][1];
f[i] += 1.0 / (i * (i + 2));
vs.setSigma(1);
min.increment(testArray[1]);
return getSlopeConfidenceInterval(0.05d);
public void testAlreadySorted() {
return (i == j) ? 1.0 : ((i == j - 1) ? -1.0 : 0.0);
if ( !isValidCoordinate( 0, column)) {
m = new RealMatrixImpl(testData2);
for (int i = 0; i < coeffs.length; ++i) {
protected DoubleArray ra = null;
if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {
protected Sum sum = null;
vs.setMode(ValueServer.GAUSSIAN_MODE);
outBuffer.append('\n');
assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);
public ProperFractionFormat(NumberFormat format) {
ResourceBundle.getBundle("org.apache.commons.math.MessagesResources", locale);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
replaceWorstPoint(new PointCostPair(xR, costR));
criterion      += measurements[i].getWeight() * residual * residual;
Complex w = new Complex(neginf, inf);
public Polynom(int degree, Random random, double max) {
public void setUp() {
throw new IllegalArgumentException("Input table must have at least two columns");
result = si.readObject();
m = new BigMatrixImpl(testData2);  // not square
"2.0 x + 3.0 x^2");
checkValue(new RationalNumber(7l, 3l).subtract(new RationalNumber(-7l, 3l)),
double y = pY[0] - p0Y[0];
public class LaguerreSolver extends UnivariateRealSolverImpl {
f = f1.add(f2);
public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {
4.10440313943354,    -3.14361226236241,
b2.setElement(3, 10.0);
new Interval( -2.0,  3.0) },
double step  = (b - a) / n;
return new ScalarValuedPair(current.getX(), sum);
double s1 = 0;
synchronized (this) {
while ((! remainder.isZero()) && (remainderDegree >= divisorDegree)) {
sumSq.increment(Double.NaN);
public abstract int[] makeInverseCumulativeTestValues();
public void testMatrix()
sumXX = 0d;
RandomGenerator rand = getRan();
assertContains(null, values, z, epsilon);      
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
patientList = new ArrayList();
public UnivariateRealSolver newBrentSolver(UnivariateRealFunction f) {
private double lu[][] = null;
public Complex[] inversetransform(
WeightedMeasurement m = measurements[i];
1E-12, Integer.MAX_VALUE);
public void testIntegerValues() {
simplex[i] = new PointCostPair(xTransformed, Double.NaN);
void setNumberOfSuccesses(int successes);
("upper bound must be > lower bound");
da.addElement(1212.0);
protected int[] getDensityTestPoints() {
stats.addValue(val);
public interface Decomposer {
protected double               theoreticalStartCost;
Polynomial.Rational d = Pk0g0.add(Pk1g1.add(Pk2g2));
public void testLinear() throws MathException {
public int nextInt(int lower, int upper) {
this(order, 1.0);
this.gamma = g;
result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);
b = b.add(bDecrement);
integrator.setMinimalIterationCount(10);
y[0] =  1.0;
double scalAbsoluteTolerance = 1.0e-4;
assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);
1.42367074157994e-11,
setAlpha(alpha);
assertEquals(1.0, StatUtils.variance(sample), 0.02);
public BigMatrix transpose() {
ScalarSampleStatistics even = new ScalarSampleStatistics();
Matrix copy = duplicate();
public class RandomDataTest extends RetryTestCase {
result = solver.solve(-0.3, 0.45);
public abstract class SummaryStatistics implements StatisticalSummary, Serializable {
public class GillIntegratorTest
assertTrue(Math.abs(s0 - s1) < 1.0e-12 * (1.0 + Math.abs(s0)));
public abstract double getSumsq();
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);
assertEquals(1.0, c[2], tolerance);
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
public AdaptiveStepsizeIntegrator newDormandPrince853Integrator(
testStatistic.tTest(sample1, sample2, .95);
Math.min(first.end, second.end));
value = n;
numElements = 0;
public ResizableDoubleArray(int initialCapacity) {
public DiagonalMatrix(int order, double value) {
return new Complex(Math.abs(b) / (2.0 * t),
buf.append(' ');
TestUtils.t(mu, emptyStats);
ret = true;
"Standard deviation must be positive.");
upperBounds[0] =
private static final long serialVersionUID = 7853080602731012102L;
for (Iterator iterator = list2.intervals.iterator(); iterator.hasNext();) {
private static final long serialVersionUID = -4386278658288500627L;
public MeanTest(String name) {
formatDouble(im, getImaginaryFormat(), toAppendTo, pos);
increment(values[i]);
ret = getAlpha() * getBeta() * .5;
assertTrue(bos.size () < 159000);
double relativeError) {
"1/12");
current   = measurements[0];
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
RandomVectorGenerator generator)
for (int i = 0; i < smallSampleSize; i++) {
public NumberFormat getNumeratorFormat() {
return -u * (1 << k); // gcd is u*2^k
int[] natural = new int[n];
private EmpiricalDistribution empiricalDistribution = null;
y[0] = cosE - e;
ybar = y;
double temp = 5.0 * (i + 1) + 45.0 + x3;
testProbability(10.011, 1.0, 2.0, .9933);
this.rootCause = rootCause;
public StandardDeviation(boolean isBiasCorrected) {
for (int i = 0; i < sum.length; ++i) {
assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
iter.nextSamplePoint();
decompMatrix = new RealMatrixImpl(decomp);
throw new IllegalArgumentException("The fraction must not be null");
addData(data[i][0], data[i][1]);
Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);
FirstOrderIntegratorFactory.newInstance();
t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);
private int maxIter;
public void testMinpackBox3Dimensional()
MathUtils.hash(data[row][col]);
return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));
public RombergIntegrator(UnivariateRealFunction f) {
double x02 = m[0][2];
public void updateArray(double[] data) {
public double getRMS(EstimationProblem problem) {
assertEquals(1.0, p[0].getEstimate(), 1.0e-10);
if (det < 0.0) {
BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);
new Double(98.6) );
assertEquals("4x3 A = QR", 0, norm, normTolerance);
suite.setName("ChiSquareTestFactory Tests");
double d01, d12, d012, c1, delta, xplus, xminus, tolerance;
new HarmonicFitter(new LevenbergMarquardtEstimator());
assertTrue(m.getRows() == 3);
u.addObject("11.3");
da.getNumElements());
double accum2 = 0.0;
public FunctionOperator getCenteredDifferenceDerivativeOperator(){
assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(testDataLU), normTolerance);
if (problem.y0 == null) {
double[] standardDeviation = new double[vertexA.length];
double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;
if (interpolator.polynoms == null) {
int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);
public void testPcts() {
long getN();
for (int l = 0; l < dimension; ++l) {
assertEquals(BigInteger.valueOf(60l), lcm);
boolean ret;
if (minPoints <= 2) {
indexL += columns;
public void setDistribution(ChiSquaredDistribution value) {
public void testCorr() {
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
Polynomial.Rational Lk0 = new Laguerre(k);
if (time < interval.getPreviousTime()) {
DescriptiveStatistics.newInstance((Class)null);
public int degree() {
Double.isNaN(u.getPercentile(50)));
return MatrixFactory.buildMatrix(bRows, bCols, resultData,
m.getColumnAsDoubleArray(-1);
return -1.0;
assertTrue(Math.abs(b2.getElement(3) - 0.1) < 1.0e-10);
assertEquals(10, MathUtils.gcd( a,  b));
double x = UnivariateRealSolverUtils.solve(sin, 1.0,
private int[] permutation = null;
return new BigMatrixImpl(data);
+ l.rows + 'x' + l.columns
return new BigMatrixImpl(outData);
next      = measurements[1];
IllegalArgumentException {
double getDenominatorDegreesOfFreedom();
assertEquals(2, pInverse.getColumnDimension());
minpackTest(new BrownAlmostLinearFunction(10, 50.0,
((ResizableDoubleArray)da).discardFrontElements( 10000 );
public void testSolveAccuracySin() throws MathException {
new BigMatrixImpl(stringRowMatrix));
1.0 / 2.0, 1.0 / 2.0, 1.0
7d * Math.PI / 6d,
val = Double.parseDouble(str);
for (int j = n -1; j >=0; j--) {
public Fraction divide(Fraction fraction) {
return new SymetricalMatrix(this);
a = new RationalNumber[] { RationalNumber.ZERO };
if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {
dev = obs1 - obs2;
ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
for (int j=0; j<mv1[0].length; j++) 
double relTolerance   = 1.0e-6;
public TestProblemHandler(TestProblemAbstract problem) {
if (n == omegaCount) { return; }
private static final long serialVersionUID = -4056541384141349722L;
"1.0 - 2.0 x + 3.0 x^2");
Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);
u.getGeometricMean() == one);
public class SimpleEstimationProblem implements EstimationProblem {
return (x >= ZB) ? PB : NB;
q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());
1.7690120078154e-6, 1.5481615698859e-6, 1.3763345366022e-6,
for (int i = coefficients.length - 2; i >= 0; --i) {
b.setElement(0, 0,  2.0);
new Vector3D(m3[0][2], m3[1][2], m3[2][2]));
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.415) < 1.0e-10);
numElements);
public void testDegenerateInverseCumulativeProbability() throws Exception {
jacobian[n - 1][j] = prod / temp;
result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);
olds = t[0][0];
lastStep = false;
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
checkPolynomial(new Polynomial.Rational(3l,  2l, 0l), "2 x + 3 x^2");
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
"impossible de rendre la matrice orthogonale en {0} it\u00e9rations" },
int n = coefficients.length;
if (secRand == null) {
randomGenerator.nextBytes(bytes);
double x00 = m[0][0];
public void selfAdd(LowerTriangularMatrix l) {
double y[] = { 0.0, 0.5, 1.0, 1.5 };
vs.resetReplayFile();
if (whole == null) {
GeneralMatrix b = new GeneralMatrix(4, 1);
((ResizableDoubleArray)da).setExpansionMode(
protected Variance stat;
12.1,
private int oneI = 1;
StatUtils.geometricMean(test);
checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(3l, 4l)),
public static final RotationOrder ZYX =
private double[] sum2;
double mean = new Mean().evaluate(v);
this(imaginaryCharacter, getDefaultNumberFormat());
permutation[max] = permutation[col];
max  = min;
flag = false;
assertEquals("overflow: subtract", ex.getMessage());
public void testPublicAttributes() {
private double negInf = Double.NEGATIVE_INFINITY;
for (int col = minor+1; col < n; col++) {
Assert.assertEquals(a[i], b[i], tolerance);
return exp(x.multiply(log(y)));
xbar += dx / (double) (n + 1.0);
double u2y = u2.getY();
Polynomial.Rational g2 = new Polynomial.Rational(1l, 0l);
return variance.evaluate(values, mean, begin, length);    
yDot[1] = -y[0];
descriptives = null;
value = b.transform(target);
checkLegendre(new Legendre(4),  8l, "3 - 30 x^2 + 35 x^4");
double d[] = new double[n];
ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, 
public PolynomialFraction(RationalNumber r) {
checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),
v1 = 2 * nextDouble() - 1; 
private double   begin;
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return false; // so the matrix is not singular
sampleStats.addValue(observed[i]);
assertFraction(-1, 3, new Fraction(-1.0 / 3.0));
public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);
chiSquareDataSetsComparison(observed1, observed2));
assertEquals(3.0,  a[1], 1.0e-12);
int[] perm = randomData.nextPermutation(3,3);
sum += (v[i] - mean) * (v[i] - mean); 
protected abstract double getA(int n, double x);
throw new MathException("Conversion Exception in Transformation, Object is null", new Object[0]);
return apply(new Skewness());
for (int i = 0; i <= n; ++i) {
verifyInverseCumulativeProbabilities();
public final class RotationOrder {
public class NotPositiveDefiniteMatrixException extends MathException {
if (numerator >= 0) {
ex.printStackTrace(pw);
public Fraction reciprocal() {
GeneralMatrix b = new GeneralMatrix(l.getRows(), 3);
DescriptiveStatistics u = DescriptiveStatistics.newInstance();
setRecurrenceCoefficients(new RationalNumber(2 * k + 1, kP1),
Rotation r = new Rotation(CardanOrders[i],
for (int l = 1; l < k; ++l) {
assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);
sum[i] += x[i];
yDotK = null;
double[] expected = {10, 10, 10};
u = SummaryStatistics.newInstance();
public Vector3D add(Vector3D v) {
void load(URL url) throws IOException;
throw new ParseException("Unparseable fraction number: \"" +
Complex expected = new Complex(-1.860893, 11.83677);
product.increment(1);
private static final byte  PB = (byte)1;
interpolator.storeTime(currentT);
f= f.invert();
public interface SampledFunctionIntegrator {
regression.addData(1, 4);
private Evaluation argument;
this.t0   = t0;
a[0] = divdiff[0];
double yDotOnScale2 = 0;
y = y * t + coeffs[i];
u.addValue(test[i]);
throws MaxIterationsExceededException, FunctionEvaluationException {
this(new GaussNewtonEstimator(maxIterations, convergence,
assertTrue(pb.getCalls() < 2150);
System.arraycopy(y, dimension, zDot, 0, dimension);
outBuffer.append('\t');
public void testSqrtRealZero() {
assertEquals("MSE", 0.782864662630069,
data [i] = i * 0.1;
assertClose("lu decomposition does not work", permuted, lower.multiply(upper), normTolerance);
public double solve(double min, double max) throws MaxIterationsExceededException,
buf.append(Double.toString(data[index]));
interpolator.setInterpolatedTime(interp);
0.937564021037838, 0.00739249260904843,
verifyBracketing(min, max, p);
yTmp[i]       = middle;
StatisticalSummary sampleStats1,
private static final long serialVersionUID = 6222990762865980424L;
checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(-2l, 5l)),
private static class APSProblem1 extends TestProblem {
double[] y0 = {0.0, 1.0, -2.0};
public class RandomAdaptorTest extends RandomDataTest {
public boolean isConnex() {
implements DifferentiableUnivariateRealFunction, Serializable {
public void testMedian() {
return first != null;
public abstract double getVariance();
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
double variance = moment.m2 / (double) (moment.n - 1);
g0Positive        = increasing;
this.function         = function;
return new TestSuite(ThreeEighthesIntegratorTest.class);
newIntervals.add(local);
return (int)s;
line = line.trim();
double   x08 = parameters[7].getEstimate();
double q = c / d;
public void mapStateToArray(int start, double[] array) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
private static class KeplerStepHandler implements StepHandler {
private UnivariateRealFunctionUtils() {
public void testZeroImaginary() {
z[0] = 0d;
double[] coeffs = fitter.fit();
("largest n for binomialCoefficientD = " + (test - 1) );
20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, 
(double)sampleStats.getN();
private static final long serialVersionUID = -7619974756160279127L;
"number of successes must be less than or equal to " +
return s.toString();
return chiSquareTest.chiSquare(expected, observed);
return min.getResult();
public void addObject(Object bean) {
double value = 0.0;
public void testMinpackOsborne2()
32.1115837449572), false);
new EstimatedParameter("p2", 0)
private RationalNumber b4k;
public Vector3D getA3() {
private abstract class DataAdapter{
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, 
protected void verifyConsistency(PolynomialSplineFunction f, double x[]) 
sum    += (current.getX() - previous.getX()) * previous.getY();
heartU.getMean(), 0.001 );
for (int l = 0; l < y0.length; ++l) {
11d * Math.PI / 6d,
double temp = i + 1;
min = -4.0; max = -1.0; expected = -3.0;
Complex actual = (Complex)complexFormatJ.parseObject(source); 
assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));
assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);
return !isNaN() && 
public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
(n * (n + 1) * moment.m4 -
private Complex oneNegInf = new Complex(1, neginf);
protected Max max = null;
fail("got " + inverse + ", should have caught an exception");
GeneralMatrix x = new GeneralMatrix(2, 2);
assertTrue(i1.intersects(i2) ^ (!b3));
return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);
HALF_LOG_2_PI + Math.log(sum / x);
assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     
return new TDistributionImpl(degreesOfFreedom);
assertFraction(1, 2, new Fraction(0.5));
os += m.getEntry(i, j) + " ";
public UpperTriangularMatrix(UpperTriangularMatrix u) {
if (! pending) {
MathException ex = new MathException(outMsg, new Object[0], cause);
assertEquals(1.2346, MathUtils.round(x, 4), 0.0);
u.addObject("12.3");
return nextAction == SwitchingFunction.STOP;
public Vector3DTest(String name) {
assertTrue(!MathUtils.equals(testArray[j], testArray[i]));
pos.setIndex(index);
BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;
+ k.getY() * (u1z * u3x - u1x * u3z)
checkPolynomial(new Hermite(0), "1");
return (i == j) ? 1.0 : ((i == j + 1) ? -1.0 : 0.0);
correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *
return variance;
da.setElement(10, 10.0);
interpolatedTime = time;
int    iterations = 0;
RandomVectorGenerator generator,
assertTrue(!MathUtils.equals(testArray[i], testArray[j]));
throw new MathException("Exception in Transformation: " + e.getMessage(), e);
double root = solver.solve(ta, tb);
distribution.setStandardDeviation(0);
public class TestRandomGenerator extends AbstractRandomGenerator {
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions"); 
return new RationalNumber(p.negate(), q);
b1 = new DomainObject(1);
rd2.nextSecureLong(1,2);
public void setSubMatrix(double[][] subMatrix, int row, int column) 
return f.value(x);
public MatrixUtilsTest(String name) {
public SwitchingFunction[] getSwitchingFunctions() {
return criterion;
public boolean checkResult(double foundRoot, double tol) {
rootFindingFunction, getInitialDomain(p),
assertTrue(testStatistic.test(testArray, 0, i));
int target = 0;
assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);
public final class SimpleRegressionTest extends TestCase {
assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);
long[] observed = {0,0};
double y[] = { 0.0, 4.0, 4.0, 2.5 };
coeffs[i] = 0.0;
assertEquals(39.24,MathUtils.round(39.245, 2, 
currentY  = nextY;
setNumberOfSuccesses(r);
public UnivariateRealSolver newSecantSolver(UnivariateRealFunction f) {
public GillStepInterpolator(GillStepInterpolator interpolator) {
public class Kurtosis extends AbstractStorelessUnivariateStatistic  {
FieldPosition pos) {
assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);
checkValue(new RationalNumber(-3l, 4l).add(new RationalNumber(4l, 5l)),
min = values[begin];
public MantissaException(String message) {
public void testMinpackLinearFullRank()
return new double[]{a, b};
y1       = null;
new ComputableFunctionSampler(new Function(0.0, 1.0), range, 11);
public void setVitalStats(VitalStats vitalStats) {
assertTrue(Math.abs(pair2.y[0] - pair1.y[0]) < 1.0e-10);
if (firstGuessNeeded) {
new TestProblem5()
protected TestProblem(double a, double b, double expectedRoot) {
this.safety = safety;
public void testNegativeInfinity() {
+ " solution is orthogonal to the jacobian",
: new PolynomialFraction(q, p);
throw new IllegalArgumentException();
means = new Mean[dimension];
res *= data[i][i];
public final class DividedDifferenceInterpolatorTest extends TestCase {
UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);
new double[] { 0.2, 0.2 },
public Chebyshev() {
9765624.00089211, 0.0,
return new TestSuite(ScalarValuedPairTest.class);
Assert.assertEquals(msg, expected, actual, delta);
assertTrue(Double.isNaN(std.getResult()));
if (unequalCounts) { // apply weights
testStatistic = TestUtils.getUnknownDistributionChiSquareTest();
for (double e = 0.0; e < 10.0; e += 0.5) {
v = randomData.nextExponential(1);
result += getCount(nextValue);
out[i] = data[row][i].doubleValue();
assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));
testRegularizedGamma(Double.NaN, 1.0, Double.NaN);
dist.setMean(10000);
String msg = "Cannot discard more elements than are" +
public MullerSolver(UnivariateRealFunction f) {
10.0 * (tmp2 - 1),
for (int j=0; j < nCols; j++) {
-10.2718482410813,      9.07411364688464,
for (int i = 1; i <= n; ++i) {
this.defaultRelativeAccuracy = 1E-6;
int counter = 0;
return map.containsValue(value);
extrapolate(0, k, y1Diag, y1);
throws Exception;
SecureRandom sec = getSecRan();
assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);
numerator *= -1;
new EstimatedParameter("p1", 2),
intervals = new ArrayList(list.intervals.size());
coeffs = new double[degree + 1];
checkValue(new RationalNumber(-12l), "-12");
new Polynomial.Rational(RationalNumber.ONE));
h = hNew;
private static class Box3DimensionalFunction extends MinpackFunction {
if (knots[i] > x) {
public abstract void clear();
return new GeneralSquareMatrix(rows, data);
int max = col; // permutation row
public void testInterpolationAtBounds()
return new TestSuite(MatrixFactoryTest.class);
double absTolerance   = 1.0e-6;
Fraction c = new Fraction(-1, 2);
throw new IllegalArgumentException("start position cannot be negative");
double target[] = {y[0], 1.002676d, 0d, -0.17415829d};
checkValue(new RationalNumber(12l), "12");
return new TestSuite(DormandPrince54IntegratorTest.class);
BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException;
assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);
return getGamma().cumulativeProbability(x);
5.9051305594220e-5, 5.6367155339937e-5, 5.3916409455592e-5,
u1.selfAdd(u2);
double[] data = new double [mapper.getDataArray().length];
new TestProblem1(),
protected abstract NonNullRange getRangeForColumn(int j);
assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));
calcIndex = (list.size() - windowSize) + index;
String pattern, Object[] arguments) {
this.z = a * u.z;
public double getMin() {
public void testInitialGuess() throws MathException {
assertEquals(30.65f,  MathUtils.round(30.645f, 2), 0.0f);
double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
if (rank == solvedCols) {
public class PointCostPair {
public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,
FileOutputStream fo = null;
diagonal[k] = new double[y0.length];
public void testSimplification() {
while (j < columns) {
VectorialMean stat = new VectorialMean(points[0].length);
public double getCumPct(int v) {
public abstract double getElement(int index);
return new Complex(re.doubleValue(), im.doubleValue() * sign);
long[][] counts5 = {{40}, {40}, {30}, {10}};
new PolynomialFitter(degree, new LevenbergMarquardtEstimator());
public void reinitializeBegin(double t0, double[] y0) {
1.0e-12);
private void buildSimplex(RandomVectorGenerator generator) {
if (i >= minimalIterationCount) {
LowerTriangularMatrix l = buildMatrix(7, new BilinearPattern(1.0, 0.1));
StatUtils.percentile(x, 0, 4, 0.25);
result[i] = index[n - i - 1];
public SymetricalMatrix(int order) {
double ph3 = 6 * (bspl - aspl);
public static double round(double x, int scale, int roundingMethod) {
new GeneralMatrix(2, 3).add(new GeneralMatrix(3, 2));
double ratio = ((double) sequence[k]) / sequence[k-l-1];
int i = j - 1;
assertTrue("reflexive", u.equals(u));
double dplus = B + Math.sqrt(delta);
maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
super("Abscissa {0} is duplicated at both indices {1} and {2}",
BigMatrix m = new BigMatrixImpl(bigSingular);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
fail("bad permutation for n = 1, sample k = 1");
n = windowSize;
public void testInterpolationInside()
double   theoreticalStartCost,
verifyConsistency((PolynomialSplineFunction) f, x);
public void testIndicatorFloat() {
if ((alpha <= 0) || (alpha > 0.5)) {
protected double interpolatedTime;
assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;
super(1.0, 0.0);
protected void verifyInterval(double lower, double upper) {
return randomData.nextGaussian(mu, sigma);
for (int j = 0; j < u.getColumns(); ++j) {
assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);
double[] random = new double[mean.length]; 
pb = new TestProblem3(0.9);
private double[] c;
protected TestFactory() {
if (samp[j] != p[i][j]) {
double[] sample3 = {5d, 7d, 8d, 10d};
double ratio  = h * errSum / tol;
assertEquals("std", std, u.getStandardDeviation(), tolerance);
assertTrue(Math.abs(result.getElement(i, j) - p.x.getElement(i, j))
int sign = 0;
public void testEstimate() {
double b2 = 2.0 * z.getImaginary();
if (((SwitchState) iter.next()).stop()) {
Vector3D uRef = u1;
z = 0.0; expected = f.value(z); result = p.value(z);
BigMatrix expected = MatrixUtils.createBigMatrix
rand.setSeed(System.currentTimeMillis());
TestUtils.tTest(mu, (SummaryStatistics) null);
x0 = x < x1 ? x0 : x1;
+ theta * (v[4][i]
denominator==Integer.MIN_VALUE) {
return (inf <= i.inf) && (i.sup <= sup);
private static final long serialVersionUID = 4104157279605906956L;
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
throw new IllegalArgumentException("bad significance level: " + alpha);
IntervalsList copy = new IntervalsList(list);
if (imaginaryFormat == null) {
public abstract class UnivariateRealFunctionProxy
assertEquals( f.value( -1.0), c[0], tolerance );
public double solve(double min, double max, double initial) throws
private int size;
class GraggBulirschStoerStepInterpolator
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j]
DataAdapterFactory aFactory = new DataAdapterFactory();
double previousFP = fp;
suite.addTest(LaguerreTest.suite());
return parameters.length;
relativeAccuracy = defaultRelativeAccuracy;
public double homoscedasticT(StatisticalSummary sampleStats1, 
return intervals.isEmpty()
double dy1 = v1y - u1.getY();
new GaussNewtonEstimator(maxIterations, convergence,
data [i] = value;
implements HypergeometricDistribution, Serializable 
5.0,
polynomials[i + 1].derivative().value(0), 0.5); 
public void testAbsInfinite() {
checkMatrix(transposed, 3.4);
this.n        = n;
private static final long serialVersionUID = 1984971194738974867L;
return t0;
double dy = interpolatedY[1] - theoreticalY[1];
return "org/apache/commons/math/stat/data/Lew.txt";
t1 = problem.t1;
public class DerivativeOperatorFactory {
public static void verifyDataSet(double d[]) throws IllegalArgumentException {
m.selfMul(2.5);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
TestRunner runner = new TestRunner();
super("singular matrix");
new IntervalsList (new Interval(10, 20), new Interval(50, 60));
"observed counts must be non-negative and expected counts must be postive");
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
private FFPIterator ffpIterator;
mean.increment(1d);
171414593.0/851261400.0, 137909.0/3084480.0}
long val = 0;
public static boolean tTest(StatisticalSummary sampleStats1,
return (i == j) ? 1.0 : 0.0;
double[] errorScale = { 1.0 };
assertTrue(m.hashCode() != m1.hashCode());
checkVector(v3, new Vector3D(3, -10, -1));
Fraction a = new Fraction(1, 2);
int a1 = (int)Math.floor(r1);
checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),
PrintWriter pw = new PrintWriter(ps, true);
sum += weightedRoots[j][0]
double meanDifference)  throws IllegalArgumentException {
assertEquals("3x4 R size", qr.getR().getColumnDimension(), 4);
int nRows = counts.length;
x.setElement(1, 0, 1.0 - epsilon);
return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, 
Complex F[] = new Complex[f.length];
public void testRegularizedBetaPositivePositiveNegative() {
int referenceCallsCount = f.getCallsCount();
if (j > 0)
assertEquals("max",max,u2.getMax(),tolerance);
public double pairedTTest(double[] sample1, double[] sample2)
return -mean * Math.log(unif);
private static final double SQRT3 = Math.sqrt(3.0);
public abstract AdaptiveStepsizeIntegrator newDormandPrince54Integrator(
public double getEntryAsDouble(int row, int column) throws MatrixIndexException {
int n = 100;
return det;
BigMatrix mInv = new BigMatrixImpl(testDataInv);
public double getPartialRadiusX() {
x11 = o[1][1];
fail("Expecting ArrayIndexOutOfBoundsException for negative index");
1.00000d, 1d};
minimalIterationCount = count;
oldz = new Complex(Double.POSITIVE_INFINITY,
protected float expansionFactor = 2.0f;
TestUtils.assertEquals(12, StatUtils.product(x), tolerance);
verifyInterpolation(f, x, y);
testStatistic.t(mu, tooShortObs);
(-4521408.0 - 1137963.0 * sqrt6) / 2937500.0,
+ (dt1 * dt2 * d12) * iMin)
protected DummyStepInterpolator(DummyStepInterpolator interpolator) {
StatUtils.variance(sample2), (double) sample1.length, 
((double)((SummaryStatistics)binStats.get(i)).getN())/
protected NumberTransformer transformer;
testLogGamma(Double.NaN, 0.0);
for (int i = 0; i < x.length; i++) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
protected void computeCoefficients() throws ArithmeticException {
fail("Expecting InvalidMatrixException");
return getAllParameters();
public boolean evaluateStep(final StepInterpolator interpolator) {
public void testSerialization() throws MathException {
fail("zero sigma -- IllegalArgumentException expected");
f = null;
UnivariateRealIntegrator, Serializable {
String source = "(-Infinity) - (Infinity)i";
setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
public class NotARotationMatrixException
expansionMode != ADDITIVE_MODE) {
NormalizedRandomGenerator generator)
return denominatorDegreesOfFreedom;
private DescriptiveStatistics descriptives;
RealMatrix coefficients = new RealMatrixImpl(coefficientsData);
VectorialValuedPair point = sampler.nextSamplePoint();
return solve(initial, yInitial, max, yMax, initial, yInitial);
normal.setStandardDeviation(Math.sqrt(p));
public int getDenominator() {
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
double ssto = getTotalSumSquares();
public GeneralSquareMatrix a;
b.setElement(0, 0, 10.08);
setInterpolationControl(true, -1);
minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },
if (startIndex == endIndex) {
interpolatedState = new double[y.length];
double gk = grad[k];
for (int i = 0; i < nCols; i++) {
Polynomial.Rational Tk0g0 = Tk0.multiply(g0);
int isi = index[swap[i]];
for (int i = 1; i < 1000; i++) {
double t0, double[] y0,
assertEquals(inter.getSup(), Interval.intersection(i1, i2).getSup(), 1.0e-10);
public class Variable implements Evaluation, Serializable {
return isBiasCorrected;
public double inverseCumulativeProbability(final double p) 
public RealMatrix add(RealMatrix m) throws IllegalArgumentException {
double coeff23   = s * (( fourTheta - 2) * theta - 2);
m = N / (i<<1);
assertEquals(0,f.value(0), interpolationTolerance);
return out;  
data[0] = 0.0;
UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());
pendingEvent     = false;
return instance;
return error;
private static class BilinearPattern implements ElementPattern {
sumOfLogs.clear();
if (s.min < min) {
if (lastState == null) {
empiricalDistribution2 = new EmpiricalDistributionImpl(1);           
suite.setName("Product Tests");
improperFormat.setDenominatorFormat(nf);
assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));
public class FDistributionTest extends ContinuousDistributionAbstractTest {
FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));
this.maxIterations = maxIterations;
this.mudif = 4;
protected double[] testArray =
public SymetricalMatrix(int order, double[] data) {
public static RationalNumber abs(RationalNumber r) {
public void handleStep(StepInterpolator interpolator, boolean isLast) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
extends AdaptiveStepsizeIntegrator {
public RealMatrixImpl(double[] v) {
public int[] getMaxIndices() {
return (DescriptiveStatistics)cls.newInstance();
public GaussianRandomGenerator(RandomGenerator generator) {
for (int i = 0; i < m.getRowDimension(); i++) {
assertTrue("chi-square test result", 
RationalNumber a01, RationalNumber a11) {
4.10440301427286,    -3.14361218602503,
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
this.delta = h;
private Complex infNaN = new Complex(inf, nan);
"The index specified: " + index +
initialStep = initialStepSize;
double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;
return value.floatValue();
boolean needUpdate = false;
"Euler angles singularity" },
observed[0] = -1;
1.0,
fa = fb;
simplex = reflected;
assertEquals(1, f.getNumerator());
public void testAddReducingLastHole() {
throws DerivativeException, IntegratorException;
public static int hash(double value) {
Fraction f = f1.divide(f2);
double x = Math.random();
if ((p > 100) || (p <= 0)) {
Vector3D  k = v1.normalize();
m.getSubMatrix(-1,1,2,2);
public void testUpperTriangular() {
int current = next++;
list.addToSelf(intersection(list1, (Interval) iterator.next()));
public void append(ContinuousOutputModel model) {
protected void setInitialCapacity(int initialCapacity) {
public RealMatrixImpl getDecomposition() {
cPop.add(Integer.toString(i));
int n = lu.getRowDimension();
public class PoissonDistributionImpl extends AbstractIntegerDistribution
private static final long serialVersionUID = -107804074496313322L;
double xk = dk * parameters[k].getEstimate();
assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); 
u2.clear();
empiricalDistribution.load(url);   
testGetDeterminant(m3, m3Det, "Calculating determinant of m3");
public MyMeasurement(double weight, double measuredValue,
return new ClassicalRungeKuttaStepInterpolator(this);
private ScalarValuedPair current;
assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);
assertTrue(Math.abs(pair.y[1] + 0.2 * i) < 1.0e-10);
throw new ArithmeticException("overflow: can't negate");
if (p.signum() == 0) {
public interface ComputableFunction extends Serializable {
public void testRegularizedBetaZeroPositivePositive() {
14.2,
m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); 
yTmp = new double[dimension];
assertEquals(values[i], z, epsilon);
for (int i = 2; i < 10; ++i) {
public PolynomialFraction(Polynomial.Rational p) {
UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);
MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);
sum = ZERO;
fi = new FileInputStream(tmp);
u.addValue( 2.0 );
return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,
((ResizableDoubleArray) da).setNumElements( 3 );
tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);
assertEquals(inter.getInf(), ib.getInf(), 1.0e-10);
m.getTrace().doubleValue();
public void testTestNegative() {
1269109.29043834, 0.00118311459212384,
this.functionValueAccuracy = defaultFunctionValueAccuracy;
Interval ia = new Interval(i1);
double yval[] = { 0.0, 1.0, 2.0 };
Complex y = new Complex(5, 6);
assertEquals(3, da.getNumElements());
assertEquals(1.0, u.getMean(), tolerance);
public class PascalDistributionTest extends IntegerDistributionAbstractTest {
protected boolean isRootOK(double min, double max, Complex z) {
double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);
private double rho;
double[] y0, double[] y1,
public double getTotalSumSquares() {
d.addValue(Double.parseDouble(line.trim()));
return (internalArray);
double y[] = { 2.0 };
double cost1 = ((PointCostPair) o1).cost;
public List getBinStats() {
LowerTriangularMatrix l = buildMatrix(5, new ElementPattern() {
assertEquals(a.length, 3);
oldRes    = tmpVec;
0.238103305554d, 0.433470120367d, 0.62883693518,
f.addValue(3);
int getRoundingMode();
assertFraction(-1, 2, new Fraction(1, -2));
public abstract Evaluation evaluate(float f);
if (b < c) {
public void setValuesFileURL(String url) throws MalformedURLException {
return Double.NaN;
int minJ            = columns;
double exp = 1.0 / (2 * k + 1);
public static double indicator(final double x) {
assertTrue(Math.abs(error) > 0.1);
public PointModel(double px, double py) {
assertEquals(nf, format.getWholeFormat());
outData[col][row] = data[row][col];
if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
+ e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j]
+ k.getZ() * (u1x * u2y - u1y * u2x);
Math.atan2(-(v2.getY()), v2.getX())
this(DEFAULT_IMAGINARY_CHARACTER, format);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public class QRDecompositionImplTest extends TestCase {
public interface NormalizedRandomGenerator {
public void testNewBrentSolverNull() {
return denominatorFormat;
odd.add(points[i]);
xHigh  = c;
0.136053221150517
double x = 1.960 / Math.sqrt(2.0);
sum2 += s.sum2;
return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);
assertSame(nf, cf.getRealFormat());
toAppendTo.append(" - ");
public BeanListUnivariateImplTest(String name) {
private double currentY;
"dimension mismatch {0} != {1}" },
Max max = new Max();
result = solver.solve(3, 4);
+ " + 9566652323054238154983240 x^28"
double q0q0  = q0 * q0;
iterationCount = i;
public static double solve(UnivariateRealFunction f, double x0, double x1,
BigMatrixImpl mt = (BigMatrixImpl) m.transpose();
assertEquals(1.25, p.evaluate(d), 1.0e-5);
public ResizableDoubleArray(int initialCapacity, float expansionFactor) {
default: throw new IllegalStateException
this.rate = rate;
double target[] = {y[0], 1.5d, 0d, -2d};
result = solver.solve(-0.2, 0.2);
return new UnivariateRealSolverFactoryImpl();
equations.computeDerivatives(t, yEnd, f[j+1]);
xHigh  = b;
public static long sign(final long x) {
protected String[] stringRow = {"1", "2", "3"};
public void testParseSimpleNoDecimals() {
setInverseCumulativeTestPoints(getCumulativeTestValues());
value += Math.log(d);
private RandomGenerator rand = null;
assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);
F[0] = new Complex(f[0], 0.0);
return new TestSuite(ScalarSampleStatisticsTest.class);
double a = Math.min(getInf(), i.getInf());
reg.addData(x[i], y[i]);
assertTrue("singular",m.isSingular());
protected double std = Double.NaN;
throw new EstimationException("cost relative tolerance is too small ({0}),"
a.setElement(0, 1, -3.0);
new PolynomialFraction(1l, 0l);
if ((Math.abs(oldDelta) < tolerance) ||
double temp = vj.getEstimate();
public void setImaginaryFormat(NumberFormat imaginaryFormat) {
Complex N1 = new Complex((double)(n-1), 0.0);
&& (preRed <= costRelativeTolerance)
assertEquals(Integer.MAX_VALUE, f.getNumerator());
public EvaluationException(String message, Throwable cause) {
WeightedMeasurement[] measurements = fitter.getMeasurements();
TestSuite suite = new TestSuite("org.spaceroots.mantissa.functions.scalar"); 
assertTrue(Arrays.equals(knots, spline.getKnots()));
assertEquals(2, p.degree());
return errorScale;
this.e = e;
private NumberTransformer defaultTransformer = null;
public ChiSquareFactoryTest(String name) {
vs.setMode(ValueServer.REPLAY_MODE);
public static double regularizedGammaP(double a, double x)
jacNorm[k] = Math.sqrt(norm2);
new ComputableFunctionSampler(new Function (0.0, 1.0), range, 11);
public class MessagesResources
public interface UnivariateStatistic {
public void testMinpackMeyer()
list.addToSelf(new Interval(-6.0, -4.0));
new EstimatedParameter("p2", 5),
assertTrue("exponential deviate postive", v > 0);
public FirstOrderIntegrator newMidpointIntegrator(double step) {
if (d < value || Double.isNaN(value)) {
if (Math.abs(fc) < Math.abs(fb)) {
double[] out = new double[x.length];
public void testSmallLastStep()
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
assertTrue("Variance of n = 0 set should be NaN", 
throw new ConvergenceException(
new EstimatedParameter("p2", 0),
assertEquals(add.getSup(), Interval.add(i1, i2).getSup(), 1.0e-10);
assertEquals(all.getStandardDeviation(), even.getStandardDeviation(),
System.arraycopy(data[row], 0, out, 0, ncols);
data = new double[nRows][nCols];
double[] c = { 2.5 };
public class ComplexFormatTest extends ComplexFormatAbstractTest {
new double[] { 1.0, 0.0, 0.0 });
0.5 * n,
int[] n21 = { 2, 5, 10, 15, 20 };
assertEquals(sa[i].getSup(), ib.getSup(), 1.0e-10);
HashSet hs = new HashSet();
Math.atan2(v1.getY(), v1.getX()),
private BigDecimal data[][] = null;
double q = real / imaginary;
return Locale.getDefault();
double[][] m4 = { { 1.0,  0.0,  0.0 },
lastState, 0, lastState.length);
double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());
public class ArrayMapperTest
return CenterDifferenceDerivative.decorate(function, delta);
Patient p2 = new Patient( vs2, new Integer( 23 ) );
assertTrue(Math.abs(d01) < 6.0e-6);
list1.addToSelf(new Interval(-1.2, 0.0));
min[i]        = s.min[i];
res.append("BigMatrixImpl{");
m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);
4168216.89130846, 792.917871779501,
TestSuite suite = new TestSuite(RealMatrixImplTest.class);
int emptyHash = statistic.hashCode();
q2 = 0;
true, false, false,
assertTrue("stats with different n's should have different hashcodes",
for (int i = 0, index = pj; i < j; ++i, index += cols) {
sampler.samplePointAt(2);
1000,
b = tmp;
Math.atan2(v1.getY(), -v1.getZ()),
permutation[k] = k;
extrapolate(0, j, diagonal, yMidDots[0]);
C = Math.cos(i * Math.PI / N) * (f[i] - f[N-i]);
public double getPreviousTime() {
public Vector3D getAxis() {
return this.min;
assertEquals( "predict(0)",  -0.262323073774029,
"Argument {0} hors du domaine [{1} ; {2}]" },
private double sumXY = 0d;
"degrees of freedom must be positive.");
double inverse = 1 / sqrt;
return (Math.abs(imaginary) * Math.sqrt(1 + q*q));
cost = 0;
if (n == 1) {
for (int j = 0; j < weightedRoots.length; ++j) {
assertEquals(expected, u.getPropertyName());
public class SecondMoment extends FirstMoment implements Serializable {
for (int i = 0; i < d1.getRows(); ++i) {
MathUtils.binomialCoefficient(6,i));
public class ScalarValuedPairTest
public void testProbabilities() throws Exception {
return new HypergeometricDistributionImpl(10,5, 5);
public class LevenbergMarquardtEstimatorTest
private Complex negInfOne = new Complex(negInf, 1);
+ m3[i][2] * m3[j][2];
public int getPopulationSize() {
assertTrue("testData is square",m.isSquare());
public class Power implements Evaluation, Serializable {
Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);
Double value = new Double(valueString);
private double begin;
assertTrue(p.toString().equals(reference));
private double max;
matrix = new RealMatrixImpl(testData4x3);
return getEntry(row,column).doubleValue();
flag = true;
public MixedListUnivariateImplTest(String name) {
public double cumulativeProbability(double x0, double x1)
return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 
double sample1[] = {1d, 2d, 3d, 4d};
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
return 0.0d;
scalAbsoluteTolerance, scalRelativeTolerance);
String stack = baos.toString();
loop = false;
assertEquals(i1, l1.getIntervals().size());
assertTrue(m1.x <= m2.x);
this(p, new Polynomial.Rational(1l));
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
Rotation r3 = r2.applyInverseTo(r1);
private double[][] m5 = {{ 1,  0,  0,  0,  0}, 
+ " matrix from a "
intervals.add(i1);
int lowLength  = Math.min(a.length, p.a.length);
String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";
extends EstimatedParameter {
hs.add("one");
assertEquals(0.4,f.value(0.4), interpolationTolerance);
z = new Complex(1, nan);
yDotKLast = null;
TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
if (first < second) {
2479159.0 / 157936.0,                    -18750000.0 / 602131.0,
private double sum;
cos = 1.0 / Math.sqrt(1.0 + tan * tan);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
for (int index = iDiag; index < jacobian.length; index += cols) {
"34461632205"
protected boolean incMoment;
protected SwitchingFunctionsHandler switchesHandler;
public InvalidMatrixException(String message) {
a = new RationalNumber[] { a0, a1, a2, a3 };
GeneralSquareMatrix m2 = buildProblem2().a;
this.expansionFactor = expansionFactor;
double[] bounds = empiricalDistribution2.getUpperBounds();
solver.solve(new double[] {1,2,3});
double x = mean * 2.0;
public ListUnivariateImpl(){
protected EmpiricalDistribution empiricalDistribution2 = null;
so.writeObject(o);
Fraction second = new Fraction(1, 3);
this.n = startParams.length;
protected double[] getInverseCumulativeTestValues() {
new EstimatedParameter[] { p[0], p[1], p[3] },
f.addValue(new Integer(-1));
0.606, 0.602, 0.626, 0.651, 0.724,
public FourthMomentTest(String name) {
public WeibullDistributionTest(String arg0) {
finalTime = ai.getCurrentTime();
for (int i = list.length - 1 ; i >= end; i--) {
double c = polynoms[currentDegree][i];
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
throw new NotPositiveDefiniteMatrixException();
throw new IllegalArgumentException("Input table must be rectangular");
public void setDistribution(TDistribution value) {
int highLength = Math.max(a.length, p.a.length);
this.p = p;
public abstract Decomposer newDecomposer();
if (p > 0.0) {
1.05262640378759
long q3 = 3 * q1;
-165125654.0 / 3796875.0},
for (int i = 0; i < knots.length; i++) {
public void reSeed() {
boolean processed    = false;
private double[] zDot;
TestSuite suite = new TestSuite(GeometricMeanTest.class);
int newValue = 10000;
double accuracy = 1.0e-6;
this.costRelativeTolerance = costRelativeTolerance;
private EstimatedParameter cx;
fail("Solving matrix m3[3x3], v[4]"); 
m = new BigMatrixImpl(new String[][] {{"2.0"}});
if (x.length != y.length) {
nextTime = lastTime + h;
residuals = oldRes;
assertEquals(-expected[i], result[i], tolerance);
private int maxOrder;
setDistribution(new PascalDistributionImpl(5,0.0d));
assertTrue(gotIt);
Polynomial.DivisionResult res = Polynomial.Rational.euclidianDivision(p, q);
sum = mval[row][col];
4.5928793239949e-5, 4.4288479195665e-5, 4.2761290257883e-5,
if (norm == 0) {
x1 + 10 * x2,
throw new MathException("InvocationTargetException in Transformation: " + e.getMessage(), e);
double sin = Math.sin(t + a);
p2 = new Polynomial.Double(-2.0, 3.0, -1.0);
if (numerator == 0 || fraction.numerator == 0) {
q0 = Math.cos (halfAngle);
public double getPreviousTime();
for (int i = 0; i < parameters.length; ++i) {
public static double[] bracket(UnivariateRealFunction function,
public BigDecimal[][] getData() {
double getNextValue() throws IllegalStateException;
+ lower + "," + upper + ")", diff, direct, tolerance);
assertEquals("total count",0,u2.getN(),tolerance);
public MedianTest(String name) {
for (int i = 0; i < order; ++i) {
private final double coeffI;
double r0 = value;
function.resetState(t, y);
x12 = o[1][2];
assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);
assertEquals( 1L, MathUtils.indicator( 0L ) ) ;
assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),
if (fm * fmin > 0.0) {
p = -p;
public abstract class FirstOrderIntegratorFactory {
resetTables(interpolator.currentDegree);
public class FastSineTransformer implements Serializable {
upper            = new UpperTriangularMatrix(s.upper);
return new ScalarValuedPair(next.getX(), sum);
assertEquals(1, second.intValue());
double maxStep, double scalAbsoluteTolerance,
RealMatrix solve(RealMatrix b);
DescriptiveStatistics.class,
public static double t(double mu, StatisticalSummary sampleStats)
public GraggBulirschStoerStepInterpolator
protected NonNullRange getRangeForColumn(int j) {
double t, oldt;
r = new Rotation(m5, 1.0e-7);
-1.475884, 0.0, 5.89343, 3.36493, 2.570582,
double[] oldRes  = new double[rows];
public class ClassicalRungeKuttaStepInterpolatorTest
double minStep      = 0;
summaries.addValue(value);
public static long binomialCoefficient(final int n, final int k) {
q2 *= inv;
distribution.cumulativeProbability(1, 0);
double xTmp = xTab[i1];
BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
public static DescriptiveStatistics newInstance() {
assertTrue(m2 instanceof GeneralMatrix);
public interface SampledFunctionIterator {
for (int i = 0;  i < d1.getUpperBounds().length; i++) {
testStatistic.tTest(mu, tooShortStats);
assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);
public abstract int getNumberOfSuccesses();
Decomposition decompose(RealMatrix matrix);
for (int col = nCol - 1; col >= 0; col--) {
5.67534206273052
observed3, observed4);
implements SampledFunctionIntegrator {
product *= values[i];
package org.apache.commons.math.util;
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public interface ElementPattern {
UnivariateRealInterpolator interpolator = new NevilleInterpolator();
double costC = evaluateCost(xC);
public abstract double getPartial(EstimatedParameter parameter);
dimension);
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
BasicDynaClass dynaClass = new BasicDynaClass(null, null, props);
for (int l = 1; l < stages; ++l) {
int num = fraction.getNumerator();
begin = range.begin;
protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};
public double getResidual() {
y1 = y3; y2 = y;
1.0, 1.0, 1.0, 1.0, 1.0,
public PolynomialFitter(int degree, Estimator estimator) {
da = new ResizableDoubleArray(2, 2.0f, 1.5f);
public ArrayMapper() {
Kurtosis kurt = new Kurtosis();
private double  minStep;
public void testMinpackLinearRank1()
m2 = 0.0;
solver.setAbsoluteAccuracy(absoluteAccuracy);
private List intervals;
return i;
y0 = y1;
if (ratio <= 0.25) {
certifiedValues = null;
return new PolynomialFraction(p.multiply(f.q).subtract(f.p.multiply(q)),
q = (Polynomial.Rational) q.multiply(lcm);
this((double) a1, (double) a0);
return (x >= 0) ? 1 : -1;
assertTrue(Double.isNaN(min.getResult()));
public void testPremultiply() {
setSubMatrix(in,0,0);
float defaultContractionCriteria = 2.5f;
fail("bad mode, expecting IllegalStateException");
return new PolynomialSplineFunction(x, polynomials);
if (getInterpolatedState().length != model.getInterpolatedState().length) {
new Object[] { new Double(argument) });
private double skewness = 0;
("The first element is not zero: " + f[0]);
1024, ((ResizableDoubleArray) da).getInternalLength());
public EstimatedParameter[] getParameters() {
norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();
return pool;
public void setRoundingMode(int roundingMode) {
RealMatrix m = new RealMatrixImpl(testData); 
return new double[][] {
private double[] standardDeviation;
for (int j = 0; j < data[0].length; j++) {
Q[minor][minor] = 1;
public void testMismatch() {
tmp1 += 0.5;
writeBaseExternal(out);
public SummaryStatisticsImpl() {
return (sum1 - (sum2 * sum2 / (double) n)) / (double) (n - 1);
double alpha)
double d = upper.getDeterminant(epsilon);
for (int i = 2; i <= n - k; i++) {
System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);
UnivariateRealFunction f2 = new SinFunction();
private static class Bounce implements SwitchingFunction {
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
((ResizableDoubleArray)da).discardFrontElements(-1);
package org.apache.commons.math.stat.regression;
double dx = 1.0 / n;
public int nextSecureInt(int lower, int upper) {
double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());
p = BigInteger.valueOf(l);
for (int j = 1; j < n; ++j) {
setOrderControl(-1, -1, -1);
return !(row < 0 || row >= nRows || col < 0 || col >= nCols);
o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);
public RetryTestCase() {
b.setElement(2, 0, 42.57);
+ coeff1  * yDotK[0][i]
fail("sample size > set size, expecting IllegalArgumentException");
boolean gotIt = false;
-12.9593152353742, 8.0, -5.78585076868676,
TestUtils.assertEquals("summary value for " + name + " is incorrect.",
package org.apache.commons.math.stat.descriptive;
distribution.setDenominatorDegreesOfFreedom(0d);
int bigNeg = Integer.MIN_VALUE;
TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);
k = N >> 1;
da.addElement(21.0);
distribution.setDegreesOfFreedom(df);
assertTrue(Math.abs(sampler.samplePointAt(12).getY() + 1.0) < 1.0e-10);
int whole = num / den;
(exponent - 0x0010000000000000L) |
if (!data[row][col].equals(m.getEntry(row, col))) {
public static double mean(final double[] values) {
super.testAddElementRolling();
setDistribution(new HypergeometricDistributionImpl(5,0,3));
public class HighamHall54IntegratorTest
public StandardDeviation() {
polynoms = null;
public double partial(double x, EstimatedParameter p) {
float contractionCriteria) {
if (v.length != sums.length) {
setResult(yMin, 0);
public void testNoReset() {
if (newStep) {
yDotK = new double[interpolator.yDotK.length][];
double min = -1.0, max = 1.0;
public void testLogGammaPositive() {
private EstimatedParameter[] parameters;
int iMed = (iMin + iMax) / 2;
public SplineInterpolatorTest(String name) {
assertTrue(solver.getIterationCount() <= 13);
updateResidualsAndCost();
mapper.updateArray();
resultData[resultIndex++] = value;
public MantissaException() {
numIterations++ ;
public void testQuadratic() throws MathException {
this(new RationalNumber(a3),
public double getKurtosis() {
public AbstractCurveFitterTest(String name) {
Matrix inverse = l.getInverse(1.0e-10);
private static final long serialVersionUID = -8866263034920607152L;
double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, 
public class UnivariateRealSolverUtils {
for (int j = (l + 1) / 2; j <= k; ++j) {
checkVector(r.applyTo(Vector3D.plusI),
for (int i = 0; i < 1000; ++i) {
assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);
assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());
stats = SummaryStatistics.newInstance();
double sumSq = 0.0d;
assertTrue(Math.abs(pair2.getY() + 8.4) < 1.0e-10);
public WeightedMeasurement[] getMeasurements();
throw new IllegalArgumentException("cannot set element ("
public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{
DefaultValue(float f) {
public DimensionMismatchException(int dimension1, int dimension2) {
public void testMinpackFreudensteinRoth()
public class ComputableFunctionSamplerTest
double temp = cos * work[k] + sin * qtbpj;
double A, B, C, F1, x[], F[] = new double[f.length];
implements SampledFunctionIterator {
forward = (interpolator.getCurrentTime() >= lastTime);
if (i < 0 || i >= rows || j < 0 || j >= columns) {
private double tolerance;
if (format == null) {
fail("expecting IllegalArgumentException for getPercentile(120)");
this.a1   = a1;
return (a.length == 1) && ((a[0] - 1.0) == 0);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
f = new Fraction(-15, 47);
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);
return (int)(bits ^ (bits >>> 32));
suite.setName("AbstractUnivariateStatistic Tests");
public static DistributionFactory newInstance() {
private void verifyQuantiles() throws Exception {
out.writeInt(yDotK.length);
this.y1       = y1;
double e  = d;
polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);
int nRowB = b.getRowDimension();
public ResizableDoubleArray() {
protected EstimatedParameter[] parameters;
list.addToSelf(new Interval(-0.85, 1.2));
public static final int NONE = 0;
assertEquals( 265.5312, f.value( 12.34), tolerance );
public BeanTransformer(final String property) {
assertTrue(estimator.getJacobianEvaluations() < 10);
f = f.negate();
public int[] makeDensityTestPoints() {
parameters   = problem.getUnboundParameters();
problems.add(new APSProblems15To17(n15[k], 0.2, 0.0, 5.0, roots15[k]));
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
return (SummaryStatistics)cls.newInstance();
double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;
int i, j, n;
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
sumY = 0d;
TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);
if (i != j) {
double[] wggRow = wggData[k];
new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);
public UpperTriangularMatrix buildMatrix(int order,
assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     
double p1 = getA(0, x);
++x0;
fail("Expecting IllegalArgumentException for null array");
public void setCallsCount(int callsCount) {
regression.getIntercept(),10E-12);
minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },
previousRejected = false;
eDA = new ResizableDoubleArray();
FitMeasurement mI = (FitMeasurement) measurements.get(i);
minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },
accum3 += Math.pow(values[i] - m, 3.0d);
for (int n = 1; n < 10; n++) {
private static final long serialVersionUID = 1455885104381976115L;
-158946167.205518,
return o;
public void testUnstableDerivative()
assertEquals(y[i].getReal(), result[i].getReal(), tolerance);
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
BigMatrix m4 = new BigMatrixImpl(d4);
FDistribution distribution = (FDistribution) getDistribution();
calls     = 0;
public BeanTransformer() {
TestUtils.t(sample1, tooShortObs);
char aChar = 'a';
fail("Can not have negative alpha.");
return new Complex(re.doubleValue(), 0.0);
setVitalStats( vitalStats );
+ " out of diagonal in a"
double u2u2 = Vector3D.dotProduct(u2, u2);
if (availableOrder < order) {
double nextExponential(double mean);
polynoms      = null;
private static final long serialVersionUID = 5387476316105068340L;
public double getVariance() {
work[permutations[i] * columns + k] = factor;
return inverse;
assertEquals(10, minima.length);
randomData.nextUniform(4,3);
"age" );
public final class PolynomialFunctionTest extends TestCase {
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
--j;
intervals = newIntervals;
public SecondMomentTest(String name) {
h             = in.readDouble();
"Sum not expected",
circle.addPoint( 30.0,  68.0);
public static long indicator(final long x) {
if (rowDimension <=0 || columnDimension <=0) {
resultData[resultIndex] = 0.0;
assertFraction(4, 3, b.divide(a));
-0.896827913731509
r[row][row] = rDiag[row];
resultData[resultIndex] = value;
double akk = jacobian[index];
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
points = new double[] {1.0, 4.2, -5, 4.0, 2.9, 10.4, 0.0, 4.1, 4.2, 4.2};
suite.addTest(PolynomialFractionTest.suite());
this.problem = problem;
e  = d;
testStatistic.chiSquare(unMatchedEx, unMatchedObs);
public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {
double s = q1 * x + q2 * y + q3 * z;
double actual = distribution.inverseCumulativeProbability(p);
return a - twoPi * Math.floor((a + Math.PI - ref) / twoPi);
new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),
for (int i = lowLength; i < highLength; ++i) {
Interval add, Interval inter) {
long n = 0;
0.955794653864217
o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);
double[] y,
("probability argument must be between 0 and 1 (inclusive)");
public NormalDistributionImpl(double mean, double sd){
throw new MaxIterationsExceededException(maxIterations,
private static final long serialVersionUID = -1296043746617791564L;    
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
private int binCount = 1000;
return F;
public void setDenominatorFormat(NumberFormat format) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
if (maximalIterationCount > 64) {
assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);
boolean previousRejected = false;
private static class APSProblem27 extends TestProblem {
assertTrue(handler.getMaximalError() > 0.005);
assertTrue(Math.abs(value - expected) < 1.0e-10);
double ti   = Math.sin(temp);
public abstract UnivariateRealSolver newSecantSolver(
protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};
lastStep = forward ? (currentT >= t) : (currentT <= t);
double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);
double[][] d = out.getDataRef();
public Fraction multiply(Fraction fraction) {
tc[n-1] = c[n];     // actually c[n] = 1
RealMatrix mRows31Cols31 = new RealMatrixImpl(subRows31Cols31);
private double evaluateNewSimplex(PointCostPair[] original, double coeff)
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
public static Complex tanh(Complex z) {
public class JDKRandomGenerator extends Random implements RandomGenerator {
max.clear();
0.23561910847106,   0.416046907892598,
double xK = diag[k] * parameters[k].getEstimate();
return new FDistributionImpl(numeratorDegreesOfFreedom,
if (v1 == null) {
double tmp = work1[pj];
BigDecimal[][] out = new BigDecimal[1][ncols]; 
assertEquals("total count",0,u2.getN(),tolerance);    
assertFalse(testStatistic.test(singletonArray, 0, 0));
private double[] lastState;
public void testSqrtNaN() {
int k = -1;
public interface SecondOrderDifferentialEquations {
public interface EstimationProblem {
F[2*N-i] = F[i].conjugate();
throw new EstimationException("sample must contain at least {0} points",
return solve(min, yMin, max, yMax, min, yMin);
new double[] { 2500.0, 500.0, -500.0, -100.0 },
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
j += k;
double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)
return (double[]) internalData.clone();
sums[i] += v[i];
m.getColumnMatrix(1));
if (sigma <= 0) {
public void testMomentSmallSamples() {
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public void testExamples() {
public void testMoreEstimatedParametersSimple() throws EstimationException {
abstract public double cumulativeProbability(int x) throws MathException;
handler.handleStep(lastTime, lastState, true);
setQuantile(p);
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);
return (EstimatedParameter[]) unbound.toArray(new EstimatedParameter[unbound.size()]);
TestUtils.assertEquals(1.0, value, 1.0e-2);
MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns
public void testMultiply2() { 
checkEquals(inter, IntervalsList.intersection(l1, l2));
if (Math.abs(yInitial) <= functionValueAccuracy) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();
double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());
IntervalsList list = new IntervalsList(new Interval(-10.0, -8.0));
minpackTest(new ChebyquadFunction(1, 8, 1.0,
checkAngle(angles[0], alpha1);
assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));
long[] observed4 = {15, 0, 10, 15, 5};
public class LotteryTest extends CertifiedDataAbstractTest {
outBuffer.append("skewness: " + getSkewness() + "\n");
da.clear();
public void setStepHandler (StepHandler handler);
void resetFunctionValueAccuracy();
protected double h;
if (obj instanceof Fraction) {
checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),
size = object.getStateDimension();
assertTrue(reg.getSumSquaredErrors() >= 0.0);
public void setRate(double rate) {
private static double k14_07 =      139418837528.0 / 549975234375.0      - b_07;
d[i][j] = new BigDecimal(data[i][j]);
Math.atan2(-(v2.getX()), v2.getZ())
0.0, 0.1, 11);
this(value, 1.0e-5, 100);
12.3 };
8261.0,  7030.0,  6005.0,  5147.0,
assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 1.980) < 1.0e-10);
package org.apache.commons.math.complex;
assertTrue(Math.abs(pair.y[1] + 3.2) < 1.0e-10);
public void testVariance() {
checkPolynomial(new Polynomial.Double(0.0),
5.0, 2.23606797749979), false);
private static double[] lanczos =
public Fraction(int num, int den) {
previousCalls = calls;
public double getLastTime() {
return new ScalarValuedPair(0.0, 0.0);
y[1] = -y[1];
maxElt = curElt;
data = new BigDecimal[rowDimension][columnDimension];
setStandardDeviation(sd);
public static Complex exp(Complex z) {
double dt = 1.0;
"Geometric mean not expected",
public GammaDistributionImpl(double alpha, double beta) {
for (int k = 0; k <= 20; ++k) {
while (unif == 0.0d) {
public static Complex log(Complex z) {
testStatistic.t(sampleStats1, tooShortStats);
TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);
return Integer.MAX_VALUE - 1;
ret = -ret;
private static final long serialVersionUID = -9111962718267217978L;  
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
covariance = new SymetricalMatrix(dimension);
for (int j = 1; j <= k - l2; ++j) {
q = q.divide(gcd);
return multiply(fraction.reciprocal());
newA[i] = a[i] + p.a[i];
u.addValue(test2[i]);
assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));
for (int a = 1; a < 10; ++a) {
double error1 = 0;
return (f.value(x + h) - f.value(x)) / h;
sum2       = null;
return value.intValue();
double[] x = null;
public int getCallsCount() {
fm = f.value(m);
double mean);
public static final RotationOrder XZY =
private void tstDoubleGen(double tolerance)throws Exception {
emptyHash, statistic2.hashCode());
-13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,
hexString = randomData.nextSecureHexString(1);
double sy2 = 0.0;
if (v.length != this.getColumnDimension()) {
for (int countdown = 10; countdown >= 0; --countdown) {
testStatistic.tTest(sample1, sample2, 0.2));
public GammaDistributionTest(String name) {
protected RealMatrix getLUMatrix() throws InvalidMatrixException {
this.orderControl2 = orderControl2;
TestFactory.class,
protected double[][] nullMatrix = null;
checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));
Math.atan2(v2.getZ(), v2.getX())
PolynomialFunction g = new PolynomialFunction( g_coeff );
private static final String methodName = "midpoint";
protected double kurt = 2.377191264804700d;
e.printStackTrace();
result = transformer.transform2(y);
Complex z = Complex.NaN.negate();
return Math.sin(x);
return logSum;
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
checkValue(new PolynomialFraction(-1l, 2l), "-1/2");
if (!isPowerOf2(d.length)) {
public Matrix              x;
protected double skew = 1.437423729196190d;
BigMatrixImpl m1 = (BigMatrixImpl) m.copy();
new EstimatedParameter("p4", 2),
"sample size must be less than or equal to population size");
public Vector3D orthogonal() {
"== numElements would satisfy the contraction criteria";
public RealMatrix scalarAdd(double d) {
assertTrue(Math.abs(d21) < 6.0e-6);
public abstract class AbstractStorelessUnivariateStatistic
assertEquals(50.19d,  MathUtils.round(50.185d, 2), 0.0d);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);
currentY  = current.getMeasuredValue();
TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);
protected Min stat;
Double.doubleToRawLongBits(rhs.getReal())) &&
for (int j = 0; j < solvedCols; ++j) {
if (steps.size() == 0) {
return generator.nextGaussian();
public UnivariateRealFunction interpolate(double xval[], double yval[])
double[] oldX    = new double[cols];
checkValue(m.getResidual(), 0.1);
public void intersectSelf(Interval i) {
assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 2.7e-3);
private static double b_09 = 54980371265625.0 / 176692375811392.0;
public void testRedundantSolvable() {
startIndex = pos.getIndex();
u.addValue( 3.0 );
expandTo(startIndex + i);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
double a = getA(n, x);
public double getX() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {
n += s.n;
public void testParseProper() {
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);
yDotKLast = new double[3][];
B = 0.5 * (f[i] - f[N-i]);
stats.addValue(empiricalDistribution.getNextValue());
return t - 12.0;
private static final long serialVersionUID = -5071329620086891960L;
double[] yDot0   = new double[y0.length];
public Double(long a1, long a0) {
int[] result = new int[k];
da.addElementRolling(4);
long[] observed1 = {10, 12, 12, 10};
an = an * (x / (a + n));
AdaptiveStepsizeIntegrator integrator =
StatUtils.sum(values, -1, 2);
assertEquals(0.0, optimum.point[3], 0.07);
double x5 = parameters[4].getEstimate();
private PointCostPair minimizes(CostFunction f, int maxEvaluations,
protected double  estimate;
double len = (double) length;            
qTy(residuals);
for (int i = 0; i < k; ++i) {
public VectorialSampleStatistics() {
numerator/=2; denominator/=2;
result = solver.solve(0.2, 0.6);
min = -50.0; max = 100.0; expected = 0.0;
BigMatrix mt = new BigMatrixImpl(testData2T);
TestUtils.assertEquals(Complex.ONE,
double absTolerance = 1.0e-20;
public CardanEulerSingularityException(boolean isCardan) {
? ConvergenceChecker.LOW
double[] resultData    = new double[rows * columns];
public boolean isInteger() {
0.16994993465202, 0.0,
PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);
c[i] = coefficients[i];
assertEquals(1934917632, f.getDenominator());
assertEquals(150, MathUtils.lcm(-a, b));
assertEquals(0, MathUtils.lcm(a, 0));
new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },
public void testNext() throws Exception {
Complex c = new Complex(1, 1);
for (int i=0; i<smallSampleSize; i++) {
fitter.doSort();
public final class SummaryStatisticsImplTest extends TestCase {
Object[] objects = c.toArray();
newA[i - 1] = a[i] * i;
minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},
public JennrichSampsonFunction(int m, double[] startParams,
assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());
private double[] upperBounds = null;
int numIterations = 0 ;
assertTrue(Math.abs(a1[0] - 0.0) < 1.0e-10);
AbstractStepInterpolator ai = (AbstractStepInterpolator) iter.next();
return apply(new Sum());
da.addElementRolling(3);
final double[] values,
bytes[bytesOut++] = (byte) randInt;
private static final long serialVersionUID = 8175301560126132666L;
suite.setName("SumSq Tests");
"Argument {0} outside domain [{1} ; {2}]",
TestUtils.tTest(sample1, tooShortObs, .01);
if (y1 == 0.0) { return min; }
public double chiSquareTest(double[] expected, long[] observed)
PointCostPair largest  = simplex[simplex.length - 1];
double step)
(AbstractCurveFitter.FitMeasurement[]) measurements.clone();
if (!binStats.isEmpty()) {
14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,
double maxStep, double[] vecAbsoluteTolerance,
public void testArrayIndexConditions() throws Exception {
new VectorialCovariance(8).increment(new double[5]);
b.setElement(1, 0, 2.0);
for (int index = 0; index < columns * columns; index += columns + 1) {
p2 = p1 + (b / a * p0);
assertTrue(Math.abs(b3.getElement(0) - 0.6) < 1.0e-10);
assertTrue("two sample homoscedastic t-test accept", 
public class StepNormalizer
if (u > 0) {
checkMatrix(d2, -8.8);
testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);
if (v < 2) cumFreq++;
protected double df(double v1, double v2, double n1, double n2) {
fail("malformed test URL");
getDenominatorFormat().format(den, toAppendTo,
public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {
return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0
for (int i = 0; i < rank; ++i) {
public double getGeometricMean() {
protected double getTolerance() {
checkValue(new RationalNumber(4l, 5l).add(new RationalNumber(-3l, 4l)),
this.numeratorFormat = numeratorFormat;
public void testGetRealFormat() {
fail("Expecting MathException");
Percentile percentile = new Percentile(10);
RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);
sign = 1;
assertEquals(1.5, c[1], tolerance);
public int getOrder() {
assertTrue(Math.abs(pair2.y[0] + 8.4)        < 1.0e-10);
a.setElement(0, 1,  2.0);
Polynomial.Rational denominator) {
super(msg, rootCause);
public boolean tTest(StatisticalSummary sampleStats1,
11.4130046614746,
new Complex(21.9, 0.0),
public void testNewNewtonSolverValid() {
for (int i = 0; i < smallSamples.length; i++) {
6.0),
ConvergenceException ex = new ConvergenceException(cause);
double x1;
denominator /= gcd;
case ConvergenceChecker.HIGH :
0.764380891528940,  0.800509327690119,
int iMin = 0;
MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);
ret = 0.0;
assertTrue("empty stats should be equal", statistic.equals(statistic2));
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkPolynomial(p, "-5.0 + 3.0 x + x^2");
RealMatrix estimatedCovariance = covStat.getResult();
public BardFunction(double x0,
double rms = estimator.getRMS(circle);
Math.min(sample1.length, sample2.length) < 2)) {
17, 19, 21, 23, 25,
double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };
public BrentSolver() {
Complex dplus = G.add(ComplexUtils.sqrt(delta));
return (start < mid) && (mid < end);
double current    = 0.0;
assertTrue(count > 850);
assertEquals( "Max age unexpected", 42.0,
TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);
TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);
long[] observed = {10, 9, 11};
Polynomial.Rational newP = p.multiply(f.q);
TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);
protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {
while (++i < 11) {
this.imaginaryFormat = imaginaryFormat;
distribution.setScale(-1.0);
-296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,
regression.getSlopeStdErr(), 1E-8);
"satisfy the criteria for contraction";
means[i] = new Mean();
public double getMaximalError() {
new DynaProperty(propertyName, Double.class)
new org.apache.commons.math.distribution.FDistributionImpl(
residuals   = new double[rows];
public class NonNullRangeTest
distribution.setMean(0);
checkPolynomial(new Chebyshev(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7");
private CostFunction f;
for (j = i; j > 0; j--) {
delta = c1 * c1 - 4 * y1 * d012;
extends AbstractDistribution
Interval local = (Interval) iterator.next();
protected double product = 628096400563833396009676.9200400128d;
c[i] = new Complex(coefficients[i], 0.0);
private double xbar = 0;
Complex initial = new Complex(0.5 * (min + max), 0.0);
x = double1;
guessAOmega();
assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);
randomData.reSeed(1000);
return solve(MatrixUtils.createRealIdentityMatrix
assertEquals("-5 / 3", actual);
public MidpointStepInterpolator() {
return "Power";
public void testSolveSin() throws MathException {     
public void testGetMean() {
if (fireException) {
throws ConvergenceException, FunctionEvaluationException;
private static final long serialVersionUID = 4118372414238930270L;
assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));
MidpointIntegrator integ = new MidpointIntegrator(step);
VectorialValuedPair point = iter.nextSamplePoint();
value *= inv;
assertEquals(result, 0, 1E-8);
return inverseCumulativeTestPoints;
public NelderMead(double rho, double khi, double gamma, double sigma) {
simplify();
public HighamHall54Integrator(double minStep, double maxStep,
assertEquals(maximum, Math.PI / 2.0, 1.0e-5);
return new BinomialDistributionImpl(numberOfTrials,
return this;
scalar3 = null;
assertEquals( 0.0, f.value( 0.5), tolerance );
for (int j = 0; j < 6; j++) {
1.0),
protected double getDomainUpperBound(double p) {
public void setMean(double p);
yTab[i1] = yTab[i2];
public abstract double[] makeCumulativeTestPoints();
void resetAbsoluteAccuracy();
previous  = current;
return lastSeen;
double corr21 = o[2][1] - m[2][1];
assertEquals(0.0, optimum.cost, 5.0e-5);
public static Complex sinh(Complex z) {
if (fa * fb >= 0.0 ) {
assertTrue("chi-square test -- will fail about 1 in 1000 times",
double unif = rand.nextDouble();
double[] errorScale = { 1.0, 0.0 };
private static final double tPq = 2 + Math.sqrt(2.0);
public class DormandPrince853StepInterpolatorTest
for (int i = 0; i < l.getRows(); ++i) {
if (performTest && (j <= maxChecks) && (k < maxIter)) {
assertTrue(solver.getIterationCount() <= 6);
public GeneralMatrix(Matrix m) {
class HighamHall54StepInterpolator
min = 0.75; max = 1.5; expected = 1.0;
assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);
for( int i = 0; i < 10; i++ ) {
return list;
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());
public double getCurrentTime();
double theoreticalMinCost,
double nan = Double.NaN;
void resetMaximalIterationCount();
assertEquals(1.0,f.value(1.0), interpolationTolerance);
lastError = error;
o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);
minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },
UnivariateRealSolver solver = new MullerSolver(f);
tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime());
throw new ArithmeticException("overflow: too large to negate");
public PolynomialFunction[] getPolynomials() {
"Divergence de fraction continue \u00e0 l''infini pour la valeur {0}" },
for (int i = lanczos.length - 1; i > 0; --i) {
assertTrue(Math.abs(sampler.samplePointAt(10).x    - 1.0) < 1.0e-10);
sxz += x * z;
distribution.setScale(expected);
protected void verifyDensities() throws Exception {
0.0, new double[] { 1.0, 10.0, 1.0 });
return tTest.homoscedasticTTest(sample1, sample2);
public Rational add(Rational p) {
throw new IllegalArgumentException("matrix is not square"); 
if (data == null) {
return getProperInstance(Locale.getDefault());
startK += k;
double[][] yDot = { { 1.0, 2.0, -2.0 } };
50.0), false);
assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());
public void setExpansionFactor(float expansionFactor) {
private int[] costPerStep;
private static double b_08 =    -1674902723.0 / 288716400.0;
if (i > 5) {
forward     = interpolator.isForward();
productsSums[k++] += v[i] * v[j];
for (int i = 0; i < n; i++) {
protected double[] dataArray = null;
UnivariateRealSolver solver = factory.newDefaultSolver(f);
if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)
(double) sample2.length);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
public void testSelfAdd() {
return new NonNullRange(0, columns);
TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));
public double homoscedasticTTest(double[] sample1, double[] sample2)
return new Fraction(numerator, denominator);
for (int k = 0; k < n15.length; ++k) {
LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);
if(x < domain[0] || x > domain[1]){
public void testParseNegativeImaginary() {
interpolator.setInterpolatedTime(lastTime);
29.9590617016037,
public String getY() {
public Complex solve(Complex coefficients[], Complex initial) throws
bound     = false;
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
return degreesOfFreedom;
public void testSimplistic() throws DimensionMismatchException {
case DIGEST_MODE: return getNextDigest();
public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {
suite.setName("DescriptiveStatistics Tests");
assertTrue(Math.abs(d21) > 4.0e-7);
public UnivariateRealFunction derivative();
public double valueAt(double x)
public GeneralSquareMatrix(int order, double[] data) {
this.convergence      = Math.abs(convergence);
Fraction f2 = Fraction.ZERO;
return (means.length == 0) ? 0 : means[0].getN();
assertNull(b.getPropertyName());
Complex z = x.subtract(Complex.NaN);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void reSeedSecure(long seed) {
private LowerTriangularMatrix lower;
public void testLargeMeanInverseCumulativeProbability() {
new ListUnivariateImpl(new ArrayList(), transformers);
f= new Fraction(Integer.MAX_VALUE, 1);
public class SumTest extends StorelessUnivariateStatisticAbstractTest{
protected int getDomainUpperBound(double p) {
RealMatrix upper = new RealMatrixImpl(upperData);
double norm = matrix.transpose().multiply(matrix).subtract(eye)
m.preMultiply(new BigMatrixImpl(bigSingular));
doComputeDerivatives(t, y, yDot);
f1 = new Fraction(1, -Integer.MAX_VALUE);
protected int windowSize;
NonNullRange r = new NonNullRange(2, 7);
for (int k = 0; k < n20.length; ++k) {
private static final byte  NB = (byte)-1;
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
double error = Math.abs(interpolatedY[i] - theoreticalY[i]);
assertEquals(10.0, z.getImaginary(), 1.0e-5);
private static final long serialVersionUID = -4703139035737911735L;
assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));
assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);
setContractionCriteria(expansionFactor +0.5f);
double m;
double[] getColumn(int col) throws MatrixIndexException;
double p2 = a * p1 + b * p0;
double scalRelativeTolerance) {
double[] test3 = stats.getValues();
return gamma;
double x[] = { 0.0, 0.5, 1.0 };
if (v instanceof Integer) {
this.begin = begin;
RationalNumber newCoeff = a[i].multiply(lcm);
double[] x = new double[] {9474.94326071674, 2080107.8865462579};
System.arraycopy(knots, 0, this.knots, 0, n + 1);
public Equations(int n, double omega) {
return (tTest(mu, sampleStats) < alpha);
private static final long serialVersionUID = -5108854841843722536L;
double b = Math.max(getSup(), i.getSup());
moment.increment(1d);
assertEquals(mean,m.getResult(),tolerance);
BeanTransformer b = new BeanTransformer("x");
extends UnivariateStatisticAbstractTest {
if (getSumFreq() == 0) {
corr  = f0 * f12 / (f1 * f12 - f0 * f2);
sx2 += x * x;
public BigDecimal[] getColumn(int col) throws MatrixIndexException {
checkAngle(r.getAngle(), 0);
assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);
new LaguerreSolver(f2);
this.vecAbsoluteTolerance  = null;
private MappableArray array1;
minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },
double cT = interpolator.getCurrentTime();
assertEquals(3, coefficients.length);
assertTrue(!m.isIgnored());
public static double logGamma(double x) {
private static final long serialVersionUID = 2259286184268533249L;
percentile.setQuantile(100); // OK
outBuffer.append("mean: " + getMean() + "\n");
public double nextGaussian() {
public double getNumericalZero() {
public DescriptiveStatisticsImpl() {
setInverseCumulativeTestValues(new int[] {-1, -1});
assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);
public void testPolar2ComplexIllegalModulus() {
ObjectInputStream     ois = new ObjectInputStream(bis);
double expected = (i <= j) ? pattern.value(i, j) : 0.0;
if (d > value || Double.isNaN(value)) {
new Interval(10, 20),
for (int i = 0; i < newA.length; ++i) {
mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);
empiricalDistribution = new EmpiricalDistributionImpl();
private int      n;
expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));
double interpError = gbsInterpolator.estimateError(scale);
y1Dot    = null;
protected void addMeasurement(WeightedMeasurement m) {
assertTrue(maxStep > (1.0 / 4.2));
this(list, new DefaultTransformer());
new EstimatedParameter("p3", 3),
ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
Polynomial.Rational g1 = new Polynomial.Rational(-1l, 0l);
double fn = 0;
RealMatrix c = stat.getResult();
minpackTest(new ChebyquadFunction(10, 10, 1.0,
nextAction        = SwitchingFunction.CONTINUE;
public abstract class WeightedMeasurement implements Serializable {
2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899
super(translate(specifier, parts), cause);
assertTrue(MathUtils.equals(testArray[i], testArray[j]));
double x = 3.0;
assertTrue(Double.isNaN(sum.getResult())); 
double oMnx  = 1 - n * x;
MatrixUtils.createBigMatrix(stringColMatrix));
result = result * 31 + MathUtils.hash(getMin());
assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);     
maxStep   = minStep;
Arrays.sort(simplex, pointCostPairComparator);
public Rational() {
if (Double.isNaN(d) || Double.isInfinite(d)) {
testLogBeta(Double.NaN, 1.0, Double.NaN);
double h = getDelta();
this.estimator     = estimator;
public class IntegratorException
for (int i = rank; i < order; ++i) {
sums         = new double[dimension];
largest = sum.abs();
if (moment.n <= 3 || variance < 10E-20) {
return cumulativeTestValues;
assertTrue(regression.getSumSquaredErrors() >= 0.0);
public void testOneSet() throws EstimationException {
return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));
StatisticalSummary sampleStats,
return Math.sqrt(variance.evaluate(values, mean));
new EstimatedParameter("p5", 2)
10.0 * (x3 - 10 * tmp1),
ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);
suite.addTest(UpperTriangularMatrixTest.suite()); 
assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);
this.stepControl2 = stepControl2;
private static final long serialVersionUID = 4165537490327432186L;
public abstract class RungeKuttaIntegrator
return ((DefaultValue)argument.evaluate(this)).longValue();
public PolynomialFraction(RationalNumber numerator,
return dRdX / points.size();
BigInteger upv = BigInteger.valueOf(fraction.numerator)
private double n = 4;
double oldValue = solver.getAbsoluteAccuracy();
numberOfSuccesses = successes;
this.stepControl2 = 0.94;
polynoms = newPols;
private double[] y0Dot;
p1 = new Polynomial.Rational(1l, 0l);
assertEquals(expected, distribution.getShape(), 0.0);
double[] xSmallest = simplex[0].point;
public boolean stop() {
Polynomial.Rational g0 = new Polynomial.Rational(k * k);
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);
public Rotation revert() {
assertEquals(all.getMean(), even.getMean(), 1.0e-12);
BigDecimal getTrace();
guessPhi();
assertFraction(0, 1, new Fraction(0, 1));
testStatistic.chiSquare(tooShortEx, tooShortObs);
public void testMeanAndCovariance() throws DimensionMismatchException {
super(f, 64);
(-3457480.0 - 960905.0 * sqrt6) / 551636.0,
protected Median stat;
public void testSignShort() {
BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
public ContinuousDistribution makeDistribution() {
private ScalarValuedPair next;
int oMn  = 1 - n;
public MidpointStepInterpolatorTest(String name) {
double f12 = f1 + f1;
private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest = 
27, 29, 31, 33
assertTrue("expecting infinite binomial coefficient",
checkMatrix(m2, new BilinearPattern(2.5, 0.025));
d = p / q;
private UncorrelatedRandomVectorGenerator generator;
x = min + Math.random() * (max - min);
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(col),
String message, Throwable cause) {
public SwitchState(SwitchingFunction function,
return apply(new Mean());
BigDecimal getEntry(int row, int column) throws MatrixIndexException;
public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{
assertTrue(Double.isNaN(sum.getResult()));
return imaginaryFormat;
if (length == 0) {
assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));
Polynom p = new Polynom(degree);
throw new IllegalArgumentException("Function can not be null.");
for (int i = 1; i < 100; i++) {
double pm;
public String nextHexString(int len) {
assertTrue(Math.abs(sampler.samplePointAt(11).getX() - 0.913) < 1.0e-10);
checkValue(new PolynomialFraction(17l, 3l).add(new PolynomialFraction(-17l, 3l)),
int index1 = i * columns;
private Double heartrate;
public IntervalsList(Interval i1, Interval i2) {
public class AllTests
if (x[i]  >= x[i + 1]) {
if (Math.abs(fn1 - fn) <= threshold)
assertClose("inverse",mInv,m.inverse(),normTolerance);
-0.232991722387673,  1.26043101102818,
checkPolynomial(res.quotient,  "10/9 + 4/3 x");
checkPolynomial(p, "-2.5 + 1.5 x + 0.5 x^2");
RealVector solve(RealVector b);
double[] result = interpolator.getInterpolatedState();
2.213364,
TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);
public int getMaximalIterationCount() {
public static final Complex I = new Complex(0.0, 1.0);
assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);
public RiddersSolver(UnivariateRealFunction f) {
for (int col = 0; col < nColB; col++) {
assertEquals( "variance not expected", 0.0, 
public Rational multiply(Rational p) {
-0.156731500244233,    1.05281515825593,
newA[i - 1] = a[i].multiply(i);
public static void assertEquals(double a[], double b[], double tolerance) {
optimalIter = k - 2;
public void testNegativeImaginary() {
return normal.cumulativeProbability(x + 0.5);
public void testPopulationSize() {
int availableOrder = integrator.getEvaluationsPerStep();
for (int k = 1; k < 10; ++k) {
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);
final double range = pb.getFinalTime() - pb.getInitialTime();
public class Erf implements Serializable {
f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)
public abstract FirstOrderIntegrator newDefaultFixedStepsizeIntegrator(double step);
public interface IntegerDistribution extends DiscreteDistribution {
private static double k14_01 =       13481885573.0 / 240030000000.0      - b_01;
internalData  = null;
f.addValue(oneI);
this.name = name;
public ThirdMomentTest(String name) {
public void testNextLong() {
public double getPct(int v) {
double[] sample2,
new Complex(-2.09497474683058, -1.91507575950825)};
geoMean.clear();
s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j]
public void testSelfSub() {
public double getTheoreticalValue() {
public void testClear(){
first = null;
public Rational(RationalNumber a3, RationalNumber a2,
this.pattern   = msg;
public interface Distribution {
"There should be 6 elements in the eda",
if (Double.isNaN(x)) {
assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,
public class BrentSolverTest
assertFalse("wrong type", u.equals(new Double(0)));
public PolynomialSplineFunction polynomialSplineDerivative() {
public void testZero() {
int upperElements   = 0;
public void testAtan() {
pb1.getFinalTime(), new double[pb1.getDimension()]);
throw new DuplicateSampleAbscissaException(x[i], i, i+j);
assertEquals("Rows20Cols123", mRows20Cols123,
(getDenominatorDegreesOfFreedom() - 2.0);
private boolean increasing;
protected boolean test(
data[indexU] += factor * a[i];
mean = null;
double v2x    = alpha * v1x + beta * v2.getX();
private UnivariateRealSolverUtils() {
return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;
public StepHandler getStepHandler();
public abstract double tTest(
throw new IllegalArgumentException("length must be positive");
LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();
public static IntervalsList intersection(IntervalsList list1, IntervalsList list2) {
public StatisticalSummaryValues(double mean, double variance, long n,
assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());
double data[] = FastFourierTransformer.sample(f, min, max, n);
y[i] = f.value(x[i]);
distribution.cumulativeProbability
double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };
Fraction f2 = new Fraction(1,59049);
distribution.setShape(-1.0);
if (nRows != nCols) {
fail("insufficient data to perform t test, IllegalArgumentException expected");
assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);
work1[pj] /= work2[j];
public static final RotationOrder YZX =
double tmp2 = 2 * parameters[j].getEstimate() - 1;
interpolator.storeTime(1);
protected double min = 8.2d;
regression.addData(1, 3);
data[i][j] = new BigDecimal(in[i][j]);
m [0][2] = 2.0 * (q1q3 - q0q2);
AbstractCurveFitter.FitMeasurement m1
public class LowerTriangularMatrix
NonNullRange range = result.getRangeForRow(i);
if (windowSize != INFINITE_WINDOW) {
public class DiagonalMatrix
return sort;
currentDegree = degree;
filePointer = new BufferedReader(new InputStreamReader(valuesFileURL.openStream()));
q = q.negate();
double maxCheckInterval,
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
dev = ((double) observed[i] - expected[i]);
public void testUnderlyingException()
public void setInitialStepBoundFactor(double initialStepBoundFactor) {
minima = new PointCostPair[starts];
double chiSquare(long[][] counts) 
private static final long serialVersionUID = 1063884352586457076L;
m = new BigMatrixImpl(singular);
double degreesOfFreedom = (double) (n1 + n2 - 2);
public int size();
return solve(c);
even.add(odd);
copy.selfMul(a);
return MatrixUtils.createRealIdentityMatrix(dimension);
public EulerStepInterpolatorTest(String name) {
x.setElement(1, 0,  4.0);
("Identical abscissas cause division by zero.");
public void selfMul(double a) {
"-17/12");
StandardDeviation std = new StandardDeviation();
public void testFirstPolynomials() {
assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(stringCol),
private double[] normalized;
public class GeneralMatrixTest
public LowerTriangularMatrix buildMatrix(int order,
public interface FunctionOperator {
Complex imaginaryNaN = new Complex(0.0, Double.NaN);
assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.495) < 1.0e-10);
public final ArraySliceMappable object;
assertEquals(expected, actual);
pos.setIndex(initialIndex);
if (knots.length < 2) {
new Polynomial.Rational(new RationalNumber(denominator)));
public DormandPrince54StepInterpolatorTest(String name) {
setInitialStepBoundFactor(100.0);
m = new RealMatrixImpl(testDataMinus);
TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);
assertEquals(result, 0.5, 1E-6);
public static void setChiSquareTest(TTest tTest) {
fail("Can not have negative scale.");
checkAngle(angles[2], alpha3);
minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },
TestSuite suite = new TestSuite(KurtosisTest.class);
intervals.add(i);
value = new Long(l);
public void testFactorialFail() {
for (int i = polynoms.length; i < newPols.length; ++i) {
double[] vecRelativeTolerance) {
assertEquals(3, c.getDenominator());
GeneralSquareMatrix m = new GeneralSquareMatrix(order);
q2 = composed.q2;
GeneralMatrix b = new GeneralMatrix(3, 1);
double tmp2 = 15 - i;
product.increment(Double.NaN);
value = randomData.nextSecureInt(0,3);
int j = 0;
ya = ya * a + coeffs[i] / (i + 1);
if (sum.abs().compareTo(largest) == 1) {
GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);
fail("Expecting IllegalArgumentException - non-bracketing");
assertEquals(0d, moment.getResult(), 0);
errfac[i] = 1.0 / (ip5 * ip5);
return tTest;
return estimate;
protected double nDevSq;
ret = c;
6181.34634628659,
while (costEvaluations < maxCostEval) {
return new SecantSolver(f);
for (int i = 0; i < 10; ++i) {
UnivariateRealFunction f, double min, double max, int n)
package org.apache.commons.math.optimization;
this.power = power;
-tmp1,
if (rowDimension <= 0 || columnDimension <= 0) {
public class DormandPrince54Integrator
testStatistic.chiSquare(counts), 1E-9);
for(int i = 0; i < 6; i++){
public void testNewInstanceClassNull() {
array2 = new MappableArray(new double[2]);
u = 1.0 / n;
return new DiagonalMatrix(this);
public double getSafety() {
assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
if (contractionCritera < expansionFactor) {
for (double phi = -1.55; phi < 1.55; phi += 0.2) {
return getCumPct(new Long(v));       
return new TestProblem3(this);
super.storeTime(t);
implements StepInterpolator, Cloneable {
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
interpolatedState = (double[]) interpolator.interpolatedState.clone();
public static float round(float x, int scale) {
UpperTriangularMatrix u = buildMatrix(7, new BilinearPattern(1.0, 0.1));
Polynomial.Rational Hk0g0 = Hk0.multiply(g0);
if (denominator.isZero()) {
assertEquals("total count",0,u.getN(),tolerance);    
double[][] out = new double[nRows][1]; 
super( name );
Locale.setDefault(defaultLocal);
double d02 = m2[0][2] - m3[0][2];
private static final double e2_07 =          66578432.0 / 35198415.0;
"invalid row or column index selection");                   
public void testMulAndCheck() {
this.roundingMode = roundingMode;
fail("got " + r + ", should have caught an exception");
assertTrue(inverse instanceof LowerTriangularMatrix);
implements CauchyDistribution, Serializable {
evenPermutations = s.evenPermutations;
assertEquals(0, estimator.getRMS(problem), 1.0e-10);
f[i] = i * sum - 1;
super(true, c, a, b,
s = 0.5 * (max - min) * (f.value(min) + f.value(max));
assertEquals( -9.0, f.value( -2.5), tolerance );
assertEquals(0, dJ1, 1.0e-10);
return sup;
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);
public void stepAccepted(double t, double[] y) {
double tmp3 = 0;
String hexString = randomData.nextSecureHexString(3);
for (int i = 0; i < size; ++i) {
public static int sign(final int x) {
protected static void verifyInputArray(double a[], double c[]) throws
|| (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))
String s = f.toString();
da.addElement(62.0);
return new GammaDistributionImpl(4d, 2d);
setRate(rateBefore);
return fct(f);
assertTrue(Math.abs(sampler.samplePointAt(6).x     - 0.5) < 1.0e-10);
public void testInconsistentEquations() throws EstimationException {
data = new double[rowDimension][columnDimension];
public WeightedMeasurement(double weight, double measuredValue) {
double[][] testData4x3 = { 
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.495) < 1.0e-10);
public void testBadEndpoints() throws Exception {
if (covariance == null) {
"  Values: [" + y0 + "," + y1 + "]");       
x = new double[] {one, two, nan};
public long nextLong(long lower, long upper) {
ret = -Double.MAX_VALUE;
throw new IllegalArgumentException("alpha must be positive");
return (tTest(sample1, sample2) < alpha);
public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,
return new CauchyDistributionImpl(median, scale);
data[row][col].hashCode();
return solve(min, yMin, initial, yInitial, min, yMin);
assertEquals(add.getInf(), ia.getInf(), 1.0e-10);
setStabilityCheck(true, -1, -1, -1);
u.addObject("11");
double sinE = Math.sin(E);
public void setNumberOfSuccesses(int successes) {
assertEquals(0L, f.getCount('a'));
currentT, y, yDot0, yTmp, yTmpDot);
public void testLUDecomposition() throws Exception {
t = (v - u) / 2;
getMax(), getMin(), getSum());
public void setEstimate(double estimate) {
BigMatrix lu = m.getLUMatrix();
minpackTest(new WatsonFunction(9, 0.0,
if ( i > 0) {
double x03 = parameters[2].getEstimate();
assertEquals("spline derivative evaluation failed for x=" + x,
UnivariateRealSolver solver = new BisectionSolver(f);
public void testCosNull() {
private static final long serialVersionUID = 5188298269533339922L;
double tmp = b;
descriptives = DescriptiveStatistics.newInstance();
protected abstract double estimateError(double[][] yDotK,
assertTrue(ex.getMessage().indexOf("1,000,000") > 0);
yTmp      = null;
TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);
return x0;        
double previous   = 0.0;
assertEquals(b, MathUtils.gcd( 0,  b));
new RationalNumber(1l),
return sumLog.evaluate(values);
b.setElement(3, 0,  2.0);
public void testGetSortedValues() {
this.t1 = t1;
result = integrator.integrate(min, max);
double[] xSmallest = original[0].point;
double x04 = parameters[3].getEstimate();
this.rand = rand;
private PolynomialFunction p;
assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertEquals(testArray.length, statistic.getN());
("At least 3 datapoints are required to compute a spline interpolant");
BigDecimal[] getRow(int row) throws MatrixIndexException;
public CorrelatedRandomVectorGenerator(RealMatrix covariance, double small,
return oPoMn2 * x - v * v;
checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), "1 - 2 x + 3 x^2");
public abstract Matrix solve(Matrix b, double epsilon)
public void testSin() {
verifySame(empiricalDistribution2, dist2);
checkValue(new RationalNumber(1l, 2l).subtract(new RationalNumber(1l, 6l)),
assertEquals(-7.0, coefficients[3], tolerance);
x1 = x2;
da.getNumElements(), 1001);
u.addValue(-1.0);
assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);
while (k++ < r.end) {
double fc = fa;
if (Math.abs(data[index]) < epsilon) {
sum2       = (double[]) s.sum2.clone();
public APSProblem24(int n, double a, double b, double expectedRoot) {
return t(sampleStats.getMean(), mu, sampleStats.getVariance(),
BigMatrix transpose();
public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {
double coeff2 = lmPar * lmNorm * lmNorm / pc2;
Double.isInfinite(x));
RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
private static final long serialVersionUID = -3583240427587318654L;
assertEquals(i2, l2.getIntervals().size());
public void selfAdd(UpperTriangularMatrix u) {
return NaN;
protected double               costAccuracy;
return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),
domainObjects.add(new ArrayMapperEntry(object, 0));
public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {
q.multiply(r.q));
("Number of samples not power of 2, consider padding for fix.");
maxIndices = null;
public RationalNumber(BigInteger i) {
double a = x[0] + 10 * x[1];
double firstDataValue = 4.038625496201205;
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);
private int getUpperDomain(int m, int k){
return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)
MathUtils.mulAndCheck(bigNeg, 2);
maxError = 0;
if (countSum1 * countSum2 == 0) {
String line = in.readLine();
int n = line.indexOf('=');
assertEquals(0.0, optimum.point[2], 0.07);
assertEquals(0, testDa.getNumElements());
public class MathExceptionTest extends TestCase {
new EstimatedParameter[] { p[1], p[2], p[3] },
assertEquals(expected[i], result[i], tolerance);
verifyInterval(min, max);
protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};
class MidpointStepInterpolator
if (len <= 0) {
assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
for (int j = nSing - 1; j >= 0; --j) {
super();
setInverseCumulativeTestValues(new int[] {4, 4});
public class Equals implements Evaluation, Serializable {
public KurtosisTest(String name) {
? Double.NaN : ((Interval) intervals.get(0)).getInf();
TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);     
public static double sumLog(final double[] values) {
assertEquals(0, dJ2, 1.0e-10);
y2 = x > x1 ? y2 : y1;
public void setImaginaryCharacter(String imaginaryCharacter) {
0.192948328597594,
VitalStats vs2 = new VitalStats( new Double(70.0), 
assertTrue(Math.abs(m3.getDeterminant(1.0e-10) - 0.0) < 1.0e-10);
double getTrace();
public void testToString() {
int dimension = currentState.length;
int midx = k * m.columns + j;
f = new Fraction(4, 3);
double r3 = y1 / y0;
public final class EmpiricalDistributionTest extends RetryTestCase {
for (int i = rank + 1; i < order; ++i) {
for (int i = 1; i < 10; ++i) {
public ChiSquareTestTest(String name) {
public double[] nextVector();
Matrix m3 = m1.sub(m2);
public FreudensteinRothFunction(double[] startParams,
assertTrue(maxError < 2.7e-6);
double[] sample1 ={2, 4, 6, 8, 10, 97};
throws IOException {
public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{
data = new double[rows * columns];
assertEquals(populationVariance(values), v1.getResult(), 1E-14);
upper = new UpperTriangularMatrix(rows, upperData);
double scale;
void resetMinimalIterationCount();
this.variance = variance;
double x[], y[], z, expected, result, tolerance;
sum[i] += halfDx * (pY[i] + cY[i]);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
MatrixUtils.createRealIdentityMatrix(0);
if (c[index[i]][index[i]] < -small) {
assertEquals(MathUtils.binomialCoefficient(0, 0), 1);
public double getRadius() {
currentTime   = in.readDouble();
assertTrue("two sample heteroscedastic t-test reject", 
targetIter = optimalIter;
u.setPropertyName(expected);
this(new ChiSquaredDistributionImpl(1.0));
double r1 = y0 / y2;
super(50.0);
sum.increment(0d);
boolean b5, Interval[] add, Interval[] inter) {
nm.minimizes(powell, 200, new ValueChecker(1.0e-3),
f2 = new Fraction(1,5);
if (mu > 0) {
assertEquals(3.0, u.getMean(), tolerance);
assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);
intervals.add(new Interval(Math.min(i1.getInf(), i2.getInf()),
dist.setMean(mean);
public static UnivariateRealSolverFactory newInstance() {
public static IntervalsList add(IntervalsList list1, IntervalsList list2) {
double m3tm3 = m3[i][0] * m3[j][0]
protected void setUp() throws Exception {
g0 = function.g(t, y);
throw new MaxIterationsExceededException(maximalIterationCount);
oldDelta = x2 - x1;
nextTime  += h;
f.addValue(aChar);
distribution.setScale(0.0);
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
private final double max;
double n = (double) length;
private static final long serialVersionUID = 3807046732154081146L;
assertEquals(2.5, u.getMean(), tolerance);
public int getRoundingMode() {
assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);
throw new IllegalArgumentException("upper bound must be positive");
checkPolynomial(p1, "2.0 - 7.0 x");
assertEquals(w.imaginary, inf, 0);
fail("negative length supplied -- IllegalArgumentException expected");
double epsilon) throws MathException
if (internalData == null) {
public RealMatrixImplTest(String name) {
double x[] = { 0.0, 3.0 };
min.increment(testArray[0]);
public WeibullDistributionImpl(double alpha, double beta){
public void setElementAndSymetricalElement(int i, int j, double value) {
assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);
o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);
private RandomData randomData = new RandomDataImpl();
return Math.PI - Math.asin(v3.getNorm() / normProduct);
testGetDeterminant(m1, m1Det, "Calculating determinant of m1");
return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,
public void test0Choose0() {
double[] lmDiag, double[] work) {
result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);
public Fraction parse(String source, ParsePosition pos) {
min        = (double[]) s.min.clone();
coefficients = new double[n];
public int hashCode() {
int n = matrix.getRowDimension();
assertEquals(1.0, f.getCumPct('e'), 0.0);
for (int j = n-1; j >= 0; j--) {
83.476044467848, 0.0,
RationalNumber[] a = q.getCoefficients();
super(s);
public FunctionException(Throwable cause) {
private double maxError;
for (i = n-1; i >= 0; i--) {
public double getStandardDeviation() {
Math.atan2(v1.getZ(), v1.getY()),
return new ExponentialDistributionImpl(mean);
return new GillStepInterpolator(this);
v         = null;
root = xLow;
yTmp[j] = currentState[j] + h * s;
int nextSecureInt(int lower, int upper);
Locale defaultLocal = Locale.getDefault();
return Math.sin(x) - x / 2;
TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);
return Math.abs(foundRoot) <= 0.03768;
Complex expected = new Complex(0.633984, 2.30551);
(2, Integer.MIN_VALUE).getNumerator(),-1);
double[][] wggData        = wGradGradT.getDataRef();
return elementArray;
public void testMeanAndCorrelation() throws DimensionMismatchException {
double corr20 = o[2][0] - m[2][0];
double   x06 = parameters[5].getEstimate();
StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
return new VectorialValuedPair(0.0, new double[] { 0, 1 });
permutations = new int[rows];
stat.clear();
public static final int ADDITIVE_MODE = 1;
throws NotPositiveDefiniteMatrixException, DimensionMismatchException {
xNorm = Math.sqrt(xNorm);
sum [i] += halfDx * (pY[i] + cY[i]);
RealMatrix bMatrix = new RealMatrixImpl(b);
private int[] getDomain(int n, int m, int k){
private static final double e4 =     71.0 / 1920.0;
f1 = new Fraction(0, 5);
.divide(new Complex(2.0, 0.0));
fLow   = fc;
public double getRMS(EstimationProblem problem);
+ " ({0}), no further improvement in"
for (int i = 0; i < 16; i++) {
public double getSkewness() {
34780.0, 28610.0, 23650.0, 19630.0,
assertEquals("one pct",0.25,f.getPct(1),tolerance);
public BrownAlmostLinearFunction(int m, double factor,
private int mudif;
Math.sqrt ((15.0 - 2.0 * Math.sqrt (30.0)) / 35.0) },
private static double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;
throw new MathException("NoSuchMethodException in Transformation: " + e.getMessage(), e);
double aspl  = ydiff - yp1;
suite.addTest(org.spaceroots.mantissa.algebra.AllTests.suite()); 
TestSuite suite = new TestSuite(MatrixUtilsTest.class);
TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());
private double gamma;
accum2 += (values[i] - m);
public void testParseNegativeBoth() {
scalar1 = null;
return points.size();
sum += data[i][col] * v[i];
setTolerance(1e-12);
unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
rand.setSeed(seed);
assertEquals(inter.getSup(), ib.getSup(), 1.0e-10);
a = new double[] { 0.0 };
private double[] y1Dot;
public double tTest(double mu, StatisticalSummary sampleStats)
public void testConsistency() {
double cosDelta = Math.cos(delta);
public abstract NormalDistribution createNormalDistribution();
assertTrue("empty instances should be equal", u.equals(t));
private void dumpMatrix(RealMatrix m) {
int middleIndex = fk[l2].length / 2;
double d = 0;
dxNorm = Math.sqrt(dxNorm);
RationalNumber a1, RationalNumber a0) {
assertEquals("std",std,u.getStandardDeviation(),tolerance);
int expected = 100;
p = numerator;
return new VectorialValuedPair (current.x, (double[]) sum.clone());
public double getExpectedRoot() {
BufferedReader in = 
for (int i = 0; i < this.getRowDimension(); i++) {
o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);
throw new EstimationException(e);
pm = cumulativeProbability(xm);
public Fraction negate() {
public static void assertEquals(Complex expected, Complex actual, double delta) {
testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);
mapper = new ArrayMapper();
double[] sample1 = {1d, 3d, 5d, 7d};
public class UpperTriangularMatrix
("largest n for factorial = " + (test - 1) );
"singularit\u00e9 d''angles de Cardan" },
private Fraction addSub(Fraction fraction, boolean isAdd) {
private static class ValueChecker implements ConvergenceChecker {
copy.intersectSelf(i);
Complex expected = new Complex(0.0, -1.4343);
protected String[] stringCol = {"0","4","6"};
assertEquals("two frequency count",1,f.getCount(2));
3.0, 5.0, 7.0, 2.0, 4.5, 5.5
0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));
throw new ConvergenceException
TestUtils.assertEquals(Complex.ONE.negate(), 
oldx = x;
return new MidpointIntegrator(step);
qr[row][col] -= alpha*qr[row][minor];
private static ChiSquareTest chiSquareTest = 
ComplexUtils.log(negInfInf), 10e-12);
return apply(new Percentile(p));
this.isBiasCorrected = isBiasCorrected;      
BufferedReader in =
for (int i = 0; i < simplex.length; ++i) {
public void setPopulationSize(int size) {
finalized = interpolator.finalized;
public class Fraction extends Number implements Comparable {
(k == 0) ? y1 : y1Diag[k-1],
int N = f.length;
private static class APSProblems12To14 extends TestProblem {
public double probability(int x) {
public class ContinuedFractionTest extends TestCase {
public Max() {
for (int row = 1; row < nRows; row++) {
if (Math.abs(y) <= functionValueAccuracy) {
assertTrue("empirical distribution property", 
public void testParseSimpleWithDecimalsTrunc() {
assertClose("inverse-operate",
"Number of elements should be equal to 1000 after adding 1000 values",
|| (delta <= parRelativeTolerance * xNorm)) {
p2 = p1.add(p1);
int lowerElements   = 0;
double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;
double x02 = parameters[1].getEstimate();
"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible" },
if (i > j) {
GraggBulirschStoerIntegrator integ =
assertTrue(Math.abs(sampler.samplePointAt(6).y[0]  + 0.5) < 1.0e-10);
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
DescriptiveStatisticsImpl.class);
assertEquals(expected, MathUtils.cosh(x), 1.0e-5);
public double[] makeCumulativeTestPoints() {
UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); 
+ rows + 'x' + columns
double r = p2 / q2;
public void setMean(double mean) {
if (in[i][j] < 0) {
double interp = ((10 - a) * prev + a * curr) / 10;
public MathConfigurationException(String pattern, Object[] arguments) {
PolynomialFraction f = new PolynomialFraction(2l, 4l);
assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
public Box3DimensionalFunction(int m, double[] startParams,
t4 = t4 * t4;
5.47722557505166, 0.0478295939097601,
public double value(double v) throws ArgumentOutsideDomainException {
TransformerMap map = new TransformerMap();
vs.setMode(ValueServer.DIGEST_MODE);
public Fraction(double value, double epsilon, int maxIterations)
y[0] = coeffs0[coeffs0.length - 1];
u.getMean() == one);
if (in != null) {
public void testMinpackPowellSingular()
throw new ArithmeticException("overflow: gcd is 2^31");
private double step;
freq.addValue(value);  
public void testParsePositiveInfinity() {
z = 4.5; expected = 2.75; result = p.value(z);
public Vector3D multiply(double a) {
Polynomial.Rational Lk1g1 = Lk1.multiply(g1);
Complex c[] = new Complex[N];
public Double getZ() {
rowSum[row] += (double) counts[row][col];
return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
WeightedMeasurement wm = measurements[i];
NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);
for (int degree = 0; degree < 10; ++degree) {
assertEquals(3, f.getDenominator());
public abstract void computeStats() throws Exception;
yDotKLast[2] = new double[dimension];
d.setElement(i, j, -1.3);
assertEquals("Rows00Cols33", mRows00Cols33, 
return Double.POSITIVE_INFINITY;
lmNorm  += s * s;
l.add(a01);
private boolean               evenPermutations;
this.callsCount = callsCount;
SummaryStatistics tooShortStats = null;  
min_dist = Double.POSITIVE_INFINITY;
double diff = 0d;
return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,
public void testEqualsRealDifference() {
double m = getDenominatorDegreesOfFreedom();
this.stepControl3 = 0.02;
+ inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], 
Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);
b.setElement(2, 0,  2.0);
this.expectedRoot = expectedRoot;
-0.000563932210324959, 0.347820540503588,
Math.exp(-i - 1) - Math.exp(-tmp)
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
public ListUnivariateImpl(List list) {
((a + (2 * m)) * (a + (2 * m) + 1.0));
double t =
public MultiDirectionalTest(String name) {
public double evaluate(final double[] values, final int begin, final int length) {
if (r.begin < r.end) {
if ((row < 0) || (column < 0)){
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;
UnivariateRealSolver solver = factory.newBrentSolver(function);
RiemannIntegratorSampler sampler = new RiemannIntegratorSampler(iter);
double sxy = 0.0;
checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(5l, 2l)),
public Polynomial.Rational getDenominator() {
interpolatedState[i] = currentState[i]
remainder.a[remainderDegree].divide(divisor.a[divisorDegree]);
ComplexUtils.polar2Complex(0, -1), 10e-12);
assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);
assertEquals("total count",3,u2.getN(),tolerance);
assertEquals(2d, testDa.getElement(0), 0);
super.addSwitchingFunction(function, maxCheckInterval, convergence);
protected abstract double getInitialDomain(double p);
this.arguments = arguments;
p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0));
if (((2.0 * p) < (3.0 * xm * q - Math.abs(tolS * q)))
return new UpperTriangularMatrix(rows, data);
assertEquals("exponential cumulative distribution",
Math.pow(1.0 - getProbabilityOfSuccess(),
c[i] = y[i];
binomialCoefficient(34,17));
throw new EstimationException("parameters relative tolerance is too small"
assertTrue("different seeds", 
int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
public String heresBar() {
return Math.sqrt(error / y0.length);
System.arraycopy(y, 0,         z,    0, dimension);
testValue(15.501, 4.0, 2.0, .9499);
private static final double d4 =  701980252875.0 / 199316789632.0;
currentDegree = -1;
(empiricalDistribution.getBinStats().size() == 0)) {
throws MatrixIndexException;
s = (4 * t - oldt) / 3.0;
random[i] = mean[i] + standardDeviation[i] * generator.nextNormalizedDouble();
public void testTransformNoSuchMethod(){
assertTrue("summaries based on same data should be equal", u.equals(t));
String text = cf.format(pi);
double q1q2  = q1 * q2;
public RandomAdaptor(RandomGenerator randomGenerator) {
tc = x[j] - z;
public double valueAt(double x) {
problems.add(new APSProblem22(n22[k], 0.0, 1.0, roots22[k]));
da.getElement( 760 ), Double.MIN_VALUE );
Locale.setDefault(getLocale());
Matrix m2 = buildMatrix(m1.getColumns(), 4, new BilinearPattern(2, -1));
t.transform(input);
double[] sorted = new double[length];
assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);
protected int initialCapacity = 16;
public void testLCM() {
protected SecondMoment stat;
+ " matrix");
double convergence);
+ " elements out of diagonal"
public Function(double min, double max) {
double x4 = parameters[3].getEstimate();
sampleStats = SummaryStatistics.newInstance();
FirstOrderIntegratorFactory.class,
lastTime = cT;
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
private static class PowellSingularFunction extends MinpackFunction {
protected void checkContractExpand(
"Nombre maximal d''it\u00e9rations ({0}) d\u00e9pass\u00e9" },
Complex expected = new Complex(-6.54812, -7.61923);
lastStep = true;
testDa.getExpansionMode());
checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));
protected double tTest(double m, double mu, double v, double n)
setErrorScale(errorScale);
public RandomDataImpl() {
checkValue(new PolynomialFraction(999999l, 307692l), "13/4");
private static final long serialVersionUID = 4380655778005469702L;
protected void setDistribution(ContinuousDistribution distribution) {
new RationalNumber(1l)) {
double[][] out = new double[nRows][this.getColumnDimension()];
int    n        = sequence[k];
public double getSup() {
public class Gamma implements Serializable {
+ b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i]
while (j < range.end) {
protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};
this.dimension1 = dimension1;
public Integer getAge() {
protected void writeBaseExternal(ObjectOutput out)
public static IntervalsList subtract(IntervalsList list, Interval i) {
sum        = null;
private BigDecimal lu[][] = null;
return dRdY / points.size();
for (int i = 0; i < 600; i++) {
(new BigMatrixImpl(testData2)).luDecompose();
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
a.setElement(2, 1,   1.0);
public long getCount(int v) {
double[] xTransformed = new double[n];
public StandardDeviation(final SecondMoment m2) {
assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);
"  Values: [" + f.value(lower) + "," + f.value(upper) + "]");       
return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;
Complex.I.multiply(sqrt1z(z)))));       
public DummyFitter() {
assertEquals(10, c.getNumerator());
int[] n23 = { 1, 5, 10, 15, 20 };
q1 = 0.0;
"Nombre d''it\u00e9rations = {0}, it\u00e9rations maximum = {1}, valeur initiale = {2}," +
public class HighamHall54Integrator
v = new double[7][];
TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);
regression.addData(- ((double) i) / (n - 1), i);
public void testDifferentImaginaryChar() {
public static FirstOrderIntegratorFactory newInstance() {
w = new Complex(inf, inf);
maximalIterationCount = count;
yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];
return copyOut();
if (f instanceof PolynomialFunction) {
assertEquals(y[i], result[i], tolerance);
+ i + ", " + j + ") from a "
double s  = jacNorm[pj];
public RiemannIntegratorSampler(SampledFunctionIterator iter)
new BigMatrixImpl(testData2).getDeterminant().doubleValue();
int nRows = d.length;
binUpperBounds[i] = binUpperBounds[i-1] + delta;
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
protected PolynomialFunction[] polynomials = {
sum = 0;
+ " + 1197358103913226000200 x^12"
return new TestSuite(GaussianRandomGeneratorTest.class);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
RandomVectorGenerator rvg =
UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);
randomData.nextGaussian(0,0);
double gap = model.getInitialTime() - current;
private Complex omega[] = new Complex[0];
public IntegerDistribution makeDistribution() {
while (it.hasNext()) {
public void testReversed() {
return getSumFreq();    // v is comparable, but greater than the last value
q1 = inv * k.getX();
assertEquals(0.0, optimum.point[1], 0.07);
"\"", parsePosition.getErrorIndex());
private float twoF = 2;
if (im == null) {
private static class Equations
if (parameters[i] == parameter) {
private int evaluations;
if (initialStep > 0) {
if (local.intersects(i)) {
public void addValue(double v) {
if (i == j) {
a = new double[degree + 1];
f = f.add(Fraction.ONE); // should overflow
return true;
result = expr.getValue();
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
suite.addTest(org.spaceroots.mantissa.quadrature.AllTests.suite()); 
public BigMatrixImpl(String[][] d) {
if(size <= 0){
public EstimationException(String specifier, String[] parts) {
new GillIntegrator(0.01).integrate(pb,
private double[] residuals;
assertEquals(-1, dist.inverseCumulativeProbability(0d));
assertEquals("count, empty table", 0, f.getCount(0));
throws CostException {
"l''\u00e9chantillon doit contenir au moins {0} points" },
double[] upperData = new double[rows * columns];
package org.spaceroots.mantissa.random;
double[] yDDot) {
firstCall = false;
double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j]
total += (double) counts[row][col];
BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);
public boolean checkTheoreticalStartCost(double rms) {
throw new EstimationException("orthogonality tolerance is too small ({0}),"
assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);
public void testCoshInf() {  
return phi;
double[] a = { 1.0, 2.0, 3.0 };
public double exactIntegration(double a, double b)
ret = 1.0 - Math.exp(-x / getMean());
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
Complex w = x.add(z);
areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));
public RationalNumberTest(String name) {
assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);
public void setX(Double double1) {
double b = getB(n, x);
public void testIllegalArguments() throws Exception {
Complex.I.multiply(z))));       
-0.0157251901386677, 1.01243485860105,
- coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
f1 = new Fraction(Integer.MAX_VALUE - 1, 1);
package org.apache.commons.math.analysis;
protected SumOfSquares stat;
assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );
double minStep, double maxStep,
Mean mean = new Mean();
public VariableHandler() {
(exponent + 0x0010000000000000L));
PolynomialFraction fInverse = f.invert();
if (pending) {
mInv,entryTolerance);
double[] a1 = { 1.0, 2.0, 3.0 };
controlArray[i],
TestUtils.assertEquals(altPolar(r, theta), 
x04 * (temp - x11) * (temp - x11) * tmp4,
super(m, startParams, theoreticalStartCost,
System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);
return fft(f);
super(10, new LevenbergMarquardtEstimator());
public void testMultiplyNaN() {
public LinearRank1Function(int m, int n, double x0,
private BigDecimal[][] copyOut() {
public double getLength() {
v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i]
new UncorrelatedRandomVectorGenerator(new double[] { 0.9, 1.1 },
super(false, c, a, b, new ThreeEighthesStepInterpolator(), step);
equations.computeDerivatives(currentT, y, yDotK[0]);
long[] obs = new long[] {
int start = degree * (degree + 1) / 2;
target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};
return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);
protected final int columns;
distribution.setBeta(4d);
assertEquals("Rows23Cols00", mRows23Cols00, 
target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};
return evaluate(x, y, z);
1, 1642738l);
public void setGamma(GammaDistribution g) {
2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,
double small[] = {1d, 4d};
double[] startParams,
public void testCoordinates() {
if (bytesOut == bytes.length) {
public void testMinpackJennrichSampson()
return -x;
SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);
double c[] = new double[n + 1];
0.19554762353657, 0.16492095727644
return (m1 - m2) / Math.sqrt(pooledVariance * (1d / n1 + 1d / n2));
super(3, startParams, theoreticalStartCost, 0.0,
checkLegendre(new Legendre(1),  1l, "x");
return divide(BigInteger.valueOf(l));
assertTrue(handler.getMaximalError() > 0.2);
public void add(ScalarSampleStatistics s) {
this.function = function;
int size = 100;
private static final long serialVersionUID = 7590601995477504318L;
0.398883667870681,  0.601116332129320,
nf.setParseIntegerOnly(true);
public Collection transformers() {
max = m;
+ d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i]
assertTrue(Math.abs(m1.getDeterminant(1.0e-10) - 6.0) < 1.0e-10);
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
suite.setName("TestStatistic Tests");
throws DerivativeException {
suite.addTest(GaussianRandomGeneratorTest.suite()); 
protected abstract int getDomainLowerBound(double p);
min = 3.0; max = 4.0; expected = Math.PI;
assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);
private static final long serialVersionUID = 5775845068390259552L;
assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));
double j3  = j1 * j2;
UpperTriangularMatrix u = new UpperTriangularMatrix(4);
MathException, IllegalArgumentException {
return new TestSuite(ComputableFunctionSamplerTest.class);
private static final long serialVersionUID = 1768555336266158242L;
private static ResourceBundle resources
list.add( new Double(one));
UnivariateRealSolverUtils.solve(null, 0.0, 4.0);
double factor   = w * a[i];
value = 1;
public void testParse() {
p.evaluate(d, 0, d.length, 101.0);
assertTrue(Math.abs(scalar3.getValue() - 0.2) < 1.0e-10);
double factor = Math.pow(0.5 * sequence[l2], l);
public class VitalStats {
m1 = m2 = 0.0;
private double[] max;
"The contraction criteria must be a number larger " +
ya = yb;
double[][] yDotK = new double[stages][];
double u3x  = u3.getX();
public ScalarSampleStatisticsTest(String name) {
StatUtils.max(ra.getElements()),
double[] res = new double[2];
public GeneralMatrix(int rows, int columns) {
throw new IllegalArgumentException("matrix dimension mismatch"); 
2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,
protected abstract void setRecurrenceCoefficients(int k);
assertNull(minima[minima.length - 1]);
double theoreticalMinCost) {
fail("Expecting illegalArgumentException");
public void testSmallError()
ComplexUtils.polar2Complex(1, 0), 10e-12);
this.a            = a;
setResult(s, 1);
1.0e-10);
minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
private static final long serialVersionUID = -1316089546353786411L;
public static RealMatrix createRealIdentityMatrix(int dimension) {
double[] y = point.y;
implements FDistribution, Serializable  {
double v2v2 = Vector3D.dotProduct(v2, v2);
densityTestPoints = null;
19.8,
setCostRelativeTolerance(1.0e-10);
for (double x = -1.0; x < 1.0; x += 0.01) {
u.addObject("8.8");
DescriptiveStatistics u = DescriptiveStatistics.newInstance(); 
private void tstGetSortedValues(double[] test) {
xNorm    += xK * xK;
protected SecondMoment secondMoment = null;
double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);
2.97937007555202,
u = -u;
testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);
assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
return (int[]) maxIndices.clone();
assertEquals(compareValue,firstDataValue,tolerance);
tstGen(0.1);    
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
public FirstMoment() {
public double getSignificance() throws MathException {
"17/12");
assertTrue(estimator.getCostEvaluations() < 10);
TestUtils.tTest(0d, oneSidedPStats, 95);
TestUtils.t(mu, emptyObs);
0.833291216194063,  0.940379732824644
public interface BinomialDistribution extends IntegerDistribution {
public void doComputeDerivatives(double t, double[] y, double[] yDot) {
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
private static final String methodName = "classical Runge-Kutta";
public interface RandomVectorGenerator {
numerator = -numerator;
checkPolynomial(new Hermite(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6");
result = transformer.transform(x);
MessageFormat mf = new MessageFormat(translate(pattern, locale));
private static String translate(String s, Locale locale) {
u.hashCode(), t.hashCode());   
public double nextNormalizedDouble();
assertTrue(solver instanceof SecantSolver);
assertTrue(Math.abs(s.getElement(1, 2) - 3.4) < 1.0e-10);
MathUtils.factorial(test);
assertTrue(upperTail < 1.0d);
for (int col = 0; col < columnCount; col++) {
public double value(double x) throws FunctionEvaluationException;
public abstract double getGeometricMean();
private static class NaturalComparator implements Comparator {
assertEquals("N",n,u.getN(),tolerance);
randomData.nextPoisson(0);
expected = new Complex(0.0, 2.0);
System.arraycopy(coefficients, 0, out, 0, coefficients.length);
if (lcm.compareTo(BigInteger.ONE) != 0) {
public BeanListUnivariateImpl(List list) {
double[][] mval = m.getData();
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
asDouble(m.solve(asBigDecimal(testVector2)));
TestSuite suite = new TestSuite(ProductTest.class);
u.solve(b, 1.0e-10);
public static double sumDifference(final double[] sample1, final double[] sample2)
(Double.isInfinite(real) || Double.isInfinite(imaginary));        
b3 = null;
omega2 = omega * omega;
public void resetAbsoluteAccuracy() {
yTmp)) {
public int getDimension2() {
public Complex[] transform2(double f[]) throws MathException,
public double normalApproximateProbability(int x) throws MathException {
c = polynoms[j][i] + c * theta05 / (j - 3);
assertTrue(m instanceof UpperTriangularMatrix);
Matrix residual = p.a.mul(result).sub(p.b);
while (j >= maxJ) {
assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );
TestSuite suite = new TestSuite(ValueServerTest.class);
private static final long serialVersionUID = -38038050983108802L;
ret = median + scale * Math.tan(Math.PI * (p - .5));
h = -maxStep;
public void testGetDeterminant() {
int nrows = this.getRowDimension();
public static final RotationOrder ZXZ =
pos);
coefficients = p.getCoefficients();
private DummyStepHandler() {
if (k > 0) {
public static void assertSame(double expected, double actual) {
public void testReplay() throws Exception {
new PolynomialSplineFunction(knots, polynomials);
double oldP1 = p1.getEstimate();
x += spacing;
double iLagrange = (  (dt2 * dt3 * d23) * iMax
public final class PolynomialFunctionLagrangeFormTest extends TestCase {
LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();
this.min = min;
for (int i = 0; i < interpolatedState.length; ++i) {
CostFunction rosenbrock =
assertTrue(testStatistic.test(singletonArray, 0, 1));
private Complex infOne = new Complex(inf, 1);
public abstract class AbstractUnivariateStatistic
assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(bigRow),
String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1); 
public double getRelativeAccuracy() {
private ArrayMapper mapper;
assertEquals("mean", mean, StatUtils.mean(values), tolerance);
--resultIndex;
public abstract Evaluation evaluate(byte b);
2,  3,  4,  5,  6,
testStatistic.t(0d, oneSidedP), 10E-10);
double[] mean              = new double[vertexA.length];
double kurt = Double.NaN;   
NonNullRange r2 = new NonNullRange(r1);
RealMatrixImpl m = new RealMatrixImpl(testData);
m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);
dist.setPopulationSize(-1);
for(int i = 0; i < test2.length; i++){
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
return Math.abs(real);
"whole format can not be null.");
protected List measurements;
public void testPolar2Complex() {
(empiricalDistribution2.getSampleStats().getStandardDeviation(),
a = Math.max(a - 1.0, lowerBound);
if (c.isZero() || degree < 0) {
public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {
for(int i = 6; i < 12; i++){
protected static double[] computeDividedDifference(double x[], double y[])
public final class FastFourierTransformerTest extends TestCase {
public void add(double[] x) {
assertEquals(populationVariance(values), v1.getResult(), 1E-14);     
protected double interpolationTolerance = 1E-2;
out[row] = solution[row][0];
TestSuite suite = new TestSuite("org.spaceroots.mantissa.roots"); 
double c1 = sy2 * sxz - sxy * syz;
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
assertNull(ce.getCause());
FieldPosition pos)
stat.increment(new double[] { 1.0, -1.0});
relativeError = Math.abs(r / c - 1.0);
weightedRoots = new double[][] {
work[index] = data[index];
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);
vs.setMode(ValueServer.UNIFORM_MODE);
public double getRSquare() {
target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};
int populationSize = 26896;
assertEquals
improperFormat.parse(source);
private double   min;
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
private static final long serialVersionUID = 2400399048702758814L;
for (int i = 0; i < coefficients.length; ++i) {
return binCount;
checkMatrix(m2, new ElementPattern() {
estimator.setOrthoTolerance(2.22044604926e-16);
initializeArrays();
assertEquals(-5.0, a[0], 1.0e-12);
observed[i] = f.getCount(hex[i]);
assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
Complex z = x.conjugate();
assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE,  1), 0);
result = transformer.inversetransform2(x);
m4 = Double.NaN;
return context.evaluate(
public static class Double extends Polynomial {
public Fraction subtract(Fraction fraction) {
p = dx * r3;
public Complex multiply(Complex rhs) {
public ChiSquaredDistributionImpl(double df) {
public VitalStats(Double heartrate, Double temperature) {
this.gamma = 0.5;
suite.setName("MatrixUtils Tests");
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testDegenerateNoFailures() throws Exception {
0.0596202671753563, 0.166708783805937,
double[] yMiddle, double[] yEnd,
assertTrue(m2 instanceof GeneralSquareMatrix);
pos.setEndIndex(0);
for (double x = 0.0; x < 10.0; x += 0.1) {
SymetricalMatrix s = new SymetricalMatrix(3);
assertTrue(! exceptionOccurred);
4.387374d, 3.107512d};
return new TestSuite(HermiteTest.class);
URL resourceURL = getClass().getClassLoader().getResource(getResourceName());
private TestProblemFactory() {
public double initializeStep(FirstOrderDifferentialEquations equations,
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),
return x[0] * (1 - x[0]);
public PolynomialFraction() {
("Iteration upper limit out of [0, 64] range: " +
assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);
public void testProductAndGeometricMean() throws Exception {            
return randomGenerator.nextLong();
StatisticalSummary summary = u.getSummary();
firstGuessNeeded = false;
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
("Polynomial degree must be positive: degree=" + n);
System.arraycopy(a, 0, out, 0, a.length);
assertFraction(1, 4, a.multiply(a));
public interface PascalDistribution extends IntegerDistribution {
swap[rank] = rank;
double coeff2    = c23  * tMq;
new RationalNumber(2l)) {
PolynomialFunctionLagrangeForm p;
public Interval(double a, double b) {
assertFraction(17, 100, new Fraction(17.0 / 100.0));
public Polynom(int degree) {
public class Add implements Evaluation, Serializable {
public class ComputableFunctionSampler
this.a = new RationalNumber[i + 1];
assertEquals(b, MathUtils.gcd( 0, -b));
this.index = index;
x0 += dx;
check(new Interval(-10.0, 10.0), new Interval(11.0, 12.0), 2.5,
public abstract double evaluate(final double[] values, final int begin, final int length);
if (den <= 0.0) {
public abstract UnivariateRealSolver newDefaultSolver(
assertTrue("nextInt range",(value >= 0) && (value <= 3));
double oldDelta = x2 - x1;
private static final long serialVersionUID = -4965972841162580234L;
assertEquals(big, MathUtils.mulAndCheck(big, 1));
ia.addToSelf(i2);
public static void main(String[] args) {
checkPolynomial(new Chebyshev(5), "5 x - 20 x^3 + 16 x^5");
double[][] m1 = { { 0.0, 1.0, 0.0 },
throw new IllegalArgumentException("x is out of range");
return new Vector3D(v1.y * v2.z - v1.z * v2.y,
new Double(96.4) );
public Matrix mul(Matrix m) {
throw new CardanEulerSingularityException(false);
max  = x;
--index1;
public double getMinReduction() {
sum = x[i];
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
y0[0] = Math.sin(omega * t0);
this.iterationCount = iterationCount;
" borne inf\u00e9rieure = {3}, borne sup\u00e9rieure = {4}," +
if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||
solver.setAbsoluteAccuracy(convergence);
double d[][] = new double[nRows][nCols];
public FirstOrderIntegrator newGillIntegrator(double step) {
Rotation r3 = new Rotation(order.getA3(), alpha3);
int d1 = MathUtils.gcd(numerator, fraction.denominator);
public final Rational remainder;
int i = 1;
-0.153071334849279e-4, 0.999789703941234,
double x = begin + index * step;
public int getColumns() {
public void testClear() {
return Double.parseDouble(((Bar) o).heresBar());
private static final short ZS = (short)0;
lmDir[permutation[j]] = work[j];
GeneralMatrix x = new GeneralMatrix(3, 1);
for (int k = 0; k < n22.length; ++k) {
assertEquals(msg, ex.getMessage());
assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);
public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {
if ((n == k) || (k == 0)) {
private static String buildMessage(String pattern, Object[] arguments, Locale locale) {
public BigDecimal getEntry(int row, int column)
public MantissaException(String specifier, String[] parts) {
public boolean equals(Object o) {
geoMean = new GeometricMean();
return (tTest(mu, sample) < alpha);
public void testTransformInvalidType() throws Exception {
alg.update(randomBytes);
new Interval( 1.0,  3.0) },
p1 = 1.0 - r3;
assertTrue("tighter means wider",
RealMatrix scalarMultiply(double d);
steps = new ArrayList();
coefficients[1]  = new EstimatedParameter("omega", 0.0);
loadStats("data/NumAcc1.txt", u);
maxColSum = maxColSum.max(sum);
da.setElement(-2, 3);
public void testConfig() throws NoSuchProviderException, 
+ k.getZ() * (u2x * u3y - u2y * u3x);
internalArray[startIndex + index] = value;
public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {
Complex c = new Complex(1.2323, 1.4343);
double[] a3 = { 1.2, -3.0, 2.1 };
return new ThreeEighthesIntegrator(step);
return new TestSuite(MinpackTest.class);
private static class DP54SmallLastHandler implements StepHandler {
return startIndex;
public void testIndicatorShort() {
Variance v1 = new Variance();
tolerance);
fail("permutation not found");
private void loadData() throws IOException {
this.alpha = alpha;
1.0e-12 * covariance.getNorm(),
"incompatibilit\u00e9 de dimensions entre le probl\u00e8me ODE ({0}),"
m = new RealMatrixImpl(testData2);  // not square
public class InvalidMatrixExceptionTest extends TestCase {
return this.probability((int) x);
if ((sample == null) || (sample.length < 2)) {
DiagonalMatrix d = new DiagonalMatrix(5, 3.4);
0.9765625e17, 0.0,
public abstract class DistributionFactory {
List list = new ArrayList();
public class RationalNumberTest
points = new double[][] {
int workIndex = permutations[i] * columns;
iMax = index;
return super.inverseCumulativeProbability(p);
private double  minStep = 0;
public class DefaultTransformer implements NumberTransformer, Serializable {
Assert.assertTrue("" + actual + " is not NaN.",
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
rd.nextLong(1,2);
min = -2.0; max = 2.0; expected = -1.0;
double[] xR       = new double[n];
private static final long serialVersionUID = 2824226005990582538L;   
y[1] = Math.sqrt(1 - e * e) * sinE;
return outBuffer.toString().substring(0, len);
lmPar               = 0;
rd.reSeed(100);
Vector3D u2 = new Vector3D(0, 5, 0);
for (int row = 0; row < dimension; row++) {
HashMap map = new HashMap();
private int[] sequence;
error = estimateError(yDotK, y, yTmp, h);
54980371265625.0/176692375811392.0, -734375.0/4826304.0,
return iterationCount;
assertFraction(2, 5, new Fraction(0.40000000000001));
return new TestSuite(MidpointIntegratorTest.class);
assertEquals(2.0, c[2], tolerance);
double dirDer = -(coeff1 + coeff2);
((SwitchState) iter.next()).reinitializeBegin(t0, y);
sets[i] = hs;
public InvalidMatrixException() {
pos.setIndex(endIndex);
private ArrayList steps;
assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));
return MatrixFactory.buildMatrix(rows, columns, resultData,
n = matrix.getColumnDimension();
return 3 * p1.getEstimate() - p2.getEstimate();
for (int row = 0; row < nRows; row++) {
assertEquals(2.0, coefficients[2], tolerance);
String source = "-1 2 / 3";
assertTrue(f.getCallsCount() > referenceCallsCount);
public void testPerfect() throws Exception {
this.a         = a;
double sumSq = Double.NaN;
double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;
currentState.length);
return Math.abs(imaginary);
factory = (TestFactory) dc.newInstance(
f[i+2] = A.subtract(B);
assertEquals("total count",4,u.getN(),tolerance);
public static double factorialDouble(final int n) {
if (u * v == 0) {
pendingEventTime = Double.NaN;
copiedArray,
tolS = 2 * epsilon * Math.abs(b);
assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);
implements StepHandler {
m.getSubMatrix(0 , 1 , 2, 3));   
abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);
public double solve(double min, double max) throws ConvergenceException, 
out[col] = sum;
public abstract AdaptiveStepsizeIntegrator newGraggBulirschStoerIntegrator(
rows        = measurements.length;
StorelessUnivariateStatistic statistic2 = null;
s = Math.sqrt(-2 * Math.log(s) / s);   
this.knots = new double[n + 1];
+ e6 * yDotK[5][j] +  e7 * yDotK[6][j];
assertTrue(p1.subtract(p1).isZero());
handler.handleStep(lastTime, lastState, false);
fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));
int i = 0;
i = -i - 2;
public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {
result = solver.solve(0.6, 7.0);
t[i][0] = qtrap.stage(min, max, i);
public static double binomialCoefficientLog(final int n, final int k) {
"Continued fraction convergents failed to converge for value {0}",
cachedNormalDeviate = v2 * s;
private double[] data;
return denominator;
if (rootCause != null && JDK_SUPPORTS_NESTED == false) {
int i1 = randomizer.nextInt(size);
private static final long serialVersionUID = -3845586908418844111L;
public static double log(double base, double x) {
public void setMaxCostEval(int maxCostEval) {
double coefficients[] = p.getCoefficients();
public MantissaException(String specifier, String[] parts, Throwable cause) {
double[][] getData();
double y = u.getY();
assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);        
densityTestPoints = makeDensityTestPoints();
double maxError = 0.0;
double out[] = new double[n + 1];
assertTrue(regression.getSlope() > 0.0);
public static double chiSquareTest(long[][] counts)
double total = 0.0d;
getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));
double[] correlated = new double[mean.length];
double inverseCumulativeProbability(double p) throws MathException;
Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);
q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));
if (nSing < solvedCols) {
assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
double midpoint = (lower + upper)/2d;
public static TestFactory newInstance() {
c = new double[x.length-1];
assertTrue(! p.isBound());
assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);
if (isBiasCorrected) {
if (Math.abs(a - c) < epsilon * Math.max(Math.abs(a), Math.abs(c))) {
protected double populationStandardDeviation(double[] v) {
BeanTransformer b = new BeanTransformer("z");
return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);
assertEquals(2, coefficients.length);
+ coeff4  * yDotK[3][i];
o[1] = new double[3];
public class CenterDifferenceDerivative extends AbstractDifferenceDerivative {
public double[] getAngles(RotationOrder order)
double[] colSum = new double[nCols];
if (fraction >= 0.5) {
public ValueServerTest(String name) {
public boolean equals(Object object) {
private final Vector3D a2;
true);
public abstract ContinuousDistribution makeDistribution();
(Number) PropertyUtils.getProperty(
double alpha) throws IllegalArgumentException, MathException {
root = Double.NaN;
("Iteration upper limit out of [0, 32] range: " +
-2 * x02 * x06 * (temp - x09) * tmp2,
private static final long serialVersionUID = -626730818244969716L;
return variance.evaluate(values);
TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;
protected int defaultMinimalIterationCount;
data = new double[nRows][1];
for (int k = 0, n = 1; n <= 10; ++n) {
double getEntry(int row, int column) throws MatrixIndexException;
assertEquals( "geometric mean not expected", 1.0, 
double[] v = generator.nextVector();
for (int index = k; index < jacobian.length; index += cols) {
public Object parseObject(String source, ParsePosition pos) {
public APSProblems15To17(int n, double u,
public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,
ya = ya * a + coeffs1[i] / (i + 1);
assertEquals("slope std err", 1.07260253,
public TransformerMap() {
public MantissaException(Throwable cause) {
sum[i] += step * pY[i];
protected RungeKuttaIntegrator(boolean fsal,
private static final String DEFAULT_IMAGINARY_CHARACTER = "i";
int starts)
14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,
Circle circle = new Circle(98.680, 47.345);
public double[] makeInverseCumulativeTestPoints() {
fitter.addWeightedPair(1.0, xTab[i], yTab[i]);
array2 = null;
BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);
this.mean = (double[]) mean.clone();
if (a <= b) {
Complex G2 = null;
m.getSubMatrix(1,0,2,4);
double newValue = 1.0e-2;        
getProbabilityOfSuccess(),
mapper.manageMappable(b1);
assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);
private Complex negInfZero = new Complex(negInf, 0);
u.addValue(2d);
TestSuite suite= new TestSuite ("org.spaceroots.mantissa.quadrature"); 
private void readObject(java.io.ObjectInputStream in)
this.imaginaryCharacter = imaginaryCharacter;
-0.156731504091375,    1.05281517718031,
public abstract void setSampleSize(int size);
LowerTriangularMatrix m = new LowerTriangularMatrix(order);
return p + ((q.compareTo(BigInteger.ONE) == 0) ? "" : ("/" + q));
double[] out = new double[a.length];
double phi   = coefficients[2].getEstimate();
assertEquals(0, new Polynomial.Double(0.0, 0.0).getDegree());
new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },
Rotation r = new Rotation(m1, 1.0e-7);
f.addValue(int1);
a                 = Double.NaN;
protected double dev;
NumberFormat denominatorFormat)
checkPolynomial(new Chebyshev(3), "-3 x + 4 x^3");
r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),
throw new IllegalArgumentException("invalid quantile value: " + p);
AbstractStepInterpolator interpolator;
private void resetTables(int maxDegree) {
assertEquals(3d, distribution.getAlpha(), 0);
TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);
double curElt = Math.abs(work[permutations[i] * columns + k]);
nDev = dev / n0;
prod *= parameters[j].getEstimate();
f.valueAt(x) + 0.01 * randomizer.nextGaussian());
-0.49191381609762019978,
assertEquals(3d, testDa.getElement(0), 0);
protected static void verifyInterpolationArray(double x[], double y[]) throws
public abstract Evaluation evaluate(short s);
ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();
testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);
public class FirstOrderIntegratorFactoryImpl extends
for (int col = 0; col < nCols; col++) {
public double evaluate( final double[] values, final int start, final int length) {
if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
public void reSeed(long seed) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
yDotKLast    = new double[3][];
public static BigMatrix createColumnBigMatrix(double[] columnData) {
assertFalse(zero.equals(nullFraction));
testStatistic.tTest(mu, tooShortObs);
ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
ret = Gamma.logGamma(a) + Gamma.logGamma(b) -
interpolator.setInterpolatedTime(t);
if (! pendingEvent) {
public void testConversion() {
0.0, new double[pb.getDimension()]);
tmp * Math.exp(-tmp * x2),
int nRows = subMatrix.length;
private static final String methodName = "Gragg-Bulirsch-Stoer";
Fraction one = new Fraction(1,1);
expected = -expected;
"Cannot format given object as a fraction");
assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);
if (set.equals(sampSet)) {                 
double fp = dxNorm - delta;
assertTrue(maxError < 1.0e-9);
private BufferedReader filePointer = null;
public ScalarValuedPair(double x, double y) {
-126493.0 / 1421424.0,                    98350000.0 / 5419179.0,
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
("lower bound must be < upper bound");
double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());
double upper = 20d;
setMultiStart(starts, rvg);
MathUtils.subAndCheck(big, -1);
y2 = y0;
ScalarSampleStatistics direct = new ScalarSampleStatistics();
double x07 = parameters[6].getEstimate();
double h[] = new double[n];
assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );
m.getRowMatrix(3));
public RealMatrixImpl() {
public abstract ExponentialDistribution createExponentialDistribution(
boolean forward = (t > t0);
private double initialStep;
checkValue(new RationalNumber(1l, -2l), "-1/2");
String outerMsg = "org.apache.commons.math.MathException: outer message";
double[] sample = new double[10000];
System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);
int size = maxOrder / 2;
clearResult();
assertEquals(3, da.getElement(0), 0);
assertEquals(2.0, p[0].getEstimate(), 1.0e-10);
regression.addData(((double) i) / (n - 1), random.nextDouble());
private static final long serialVersionUID = 4963578633786538912L;
-1.0),
incMoment = true;
(x3 - x1) / Math.sqrt(delta);
Matrix result = l.solve(b, 1.0e-10);
f[m - 1] = x2 - x1 * x1 - 1;
public ContinuousOutputModel() {
public Hermite() {
ScalarValuedPair current  = iter.nextSamplePoint();
public static final RotationOrder XYZ =
((double)((SummaryStatistics)binStats.get(0)).getN())/
value += data[idx++] * m.data[midx];
"," + upper + "]");
ak2        = norm2;
private static final long serialVersionUID = -3239549463135430361L;
ret = this;
return lower + u * (upper - lower);
if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||
m.scalarAdd(new BigDecimal(2d)),entryTolerance);
minpackTest(new WatsonFunction(6, 10.0,
RandomGenerator rg = new JDKRandomGenerator();
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));
private int n;
new Object[] { new Integer(maxIterations) });
sqrt5 * (x3 - x4),
double x = -1;
ComplexUtils.log(oneInf), 10e-12);
internalArray[i] = 0;
OrthogonalPolynomial Tk = new Chebyshev(k);
throw new InvalidMatrixException("matrix is not square");
target = new double[]{y[1], 1d, 0d, 0d};
Double.NaN, Double.POSITIVE_INFINITY};
new UncorrelatedRandomVectorGenerator(mean, standardDeviation, urg);
StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
simplex[0] = new PointCostPair(vertex, Double.NaN);
double h  = (t1 - t0) / n;
return ((DefaultValue)argument.evaluate(this)).floatValue();
f.addValue(hexString.substring(j,j+1));
return cachedResources.getString(s);
assertEquals(Integer.MAX_VALUE-1, f.getNumerator());
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return tTest(sampleStats.getMean(), mu, sampleStats.getVariance(),
da.addElement(122.0);
for (int i = 1; i < x.length; ++i) {
public void testCopyFunctions() {
System.out.println("Start");
new VectorialMean(8).increment(new double[5]);
double det = parity;
loop   = false;
protected BigDecimal[] bigRow = 
this.getRowDimension() != m.getRowDimension()) {
.33994649984811888699e-4,
factor = Math.pow(0.5 * sequence[j + l2], l);
private static final double e2_01 =           -364463.0 / 1920240.0;
x += absoluteAccuracy;
Complex z = new Complex(3.0, 4.0);
pb2.getInitialTime(), pb2.getInitialState(),
public DP54SmallLastHandler(double minStep) {
startIndex = 0;
sum = sum + an;
private static final long serialVersionUID = 3256541562455482289L;
setResult(root[i].getReal(), iterationCount);
this.numericalZero = numericalZero;
Double.isNaN(StatUtils.variance(values)));
assertFraction(0, 1, a.subtract(a));
public PolynomialFraction multiply(PolynomialFraction f) {
public static double chiSquareTest(double[] expected, long[] observed)
if (h < getMinStep()) {
instance = new DummyStepHandler();
protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };
assertEquals(expectedValue(), statistic.getResult(), getTolerance());
solver2.setRelativeAccuracy(newValue);
copiedArray[i] = getElement(i);
return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]);
return (pattern == null) ? null : buildMessage(pattern, arguments, locale);
VectorialMean stat = new VectorialMean(2);
public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{
int xm = x0 + (x1 - x0) / 2;
implements NormalDistribution, Serializable {
public double integrate(SampledFunctionIterator iter)
double max = sampleStats.getMax();
assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);
m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  
TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);
assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);
assertEquals(result, solver.getResult(), 0);
assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);
fail("Expecting IllegalArgumentException - vanishing counts");
fail ("Expecting IllegalArgumentException");
assertEquals("N",s.getN(),u.getN());
kurtosis =
return new FirstMoment();
public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {
testStatistic.tTest(sampleStats1, tooShortStats, .01);
for (int i = a.length - 1; i >= 0; --i) {
return Math.sqrt(criterion / n);
eDA.addElementRolling(v);
distribution.cumulativeProbability(cumulativeTestPoints[i]), 
testStatistic.t(mu, (double[]) null);
public class ProductTest extends StorelessUnivariateStatisticAbstractTest{
assertEquals(0, new Polynomial.Rational(0l, 5l).getDegree());
dxNorm = 0;
rDiag[minor] = a;
protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{
private Polynomial.Rational q;
assertEquals(-3.0, c[0], tolerance);
suite.addTest(SymetricalMatrixTest.suite()); 
assertEquals("t statistic",  -2.81976445346,
0.990d, 0.975d, 0.950d, 0.900d}; 
double expected;
this.lastSeen = lastSeen;
StringBuffer res = new StringBuffer();
alpha /= rDiag[minor]*qr[minor][minor];
public double getInitialTime() {
void setSeed(long seed);
s.append(Integer.toString(i));
double determinant = data[0];
double[] theoreticalMinParams) {
public static FractionFormat getImproperInstance(Locale locale) {
System.arraycopy(array, start, internalArray, 0, internalArray.length);
TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);
RealMatrix scalarAdd(double d);
if (x < knots[0] || x >= knots[knots.length -1]) {
assertTrue(Double.isNaN(w.real));
v1 = new Variance(false, m);
setNumberOfTrials(trials);
this.orthoTolerance = orthoTolerance;
return (MathUtils.equals(stat.getGeometricMean(), 
public Object[][] getContents() {
public void testAdd() {
domainObjects = new ArrayList();
public void testRegularizedGammaPositiveNegative() {
public Vector3D applyTo(Vector3D u) {
assertTrue(lowerTail < 0.00001);
public int getM() {
if (stats.getStandardDeviation() > 0) {  // more than one obs
System.arraycopy(permutation, 0, out, 0, permutation.length);
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
BigDecimal bd[] = new BigDecimal[b.length];
assertTrue(i1.contains(i2)   ^ (!b2));
suite.addTest(NonNullRangeTest.suite()); 
public void testSimpleWithDecimals() {
public boolean contains(Interval i) {
assertEquals("foo pct",0,f.getPct("foo"),tolerance);
FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));
double[] work3   = new double[cols];
public abstract void addValue(double v);
if (rank == 0) {
testStatistic.tTest(sampleStats1, tooShortStats);
assertEquals(result, 0.5, solver.getAbsoluteAccuracy());
super(order, data);
assertEquals("min",min,u2.getMin(),tolerance);
public void testNextBoolean() {
return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);
testStatistic.t(sample1, tooShortObs);
String pattern, Object[] arguments,
result[i] = objects[index[i]];
super(m, buildArray(n, x0),
if (c.length < 1) {
new ComputableFunctionSampler(new ExceptionGeneratingFunction(),
public void testSetImaginaryCharacterNull() {
private AbstractCurveFitter.FitMeasurement current;
double actual = Beta.logBeta(a, b);
assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);     
f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);
public double getCenterDistance() {
suite.setName("TTestFactory Tests");
return windowSize;
public static double homoscedasticT(StatisticalSummary sampleStats1,
public static final Vector3D minusK = new Vector3D(0, 0, -1);
m.setElement(i, j, pattern.value(i, j));
double[] table = new double[2];
.floor(unscaled) / 2.0)) { // even
super.runTest();
double den = error1 + 0.01 * error2;
public EvaluationException() {
return this.std;
assertEquals("r-square", 0.999993745883712,
private int count;
public void testNorris() {
result = randomData.nextUniform(lower,upper);
if (alpha >= 1 || alpha <= 0) {
b.setElement(0, 0,  6.12);
assertTrue(minStep < (1.0 / 450.0));
public IntervalTest(String name) {
assertEquals(expected.getReal(), actual.getReal(), delta);
Math.atan2(v1.getZ(), -v1.getX()),
0.14, 0.18, 0.22, 0.25, 0.29,
"observed counts must not both be zero");
private NumberFormat wholeFormat;
ret = format( (Fraction)obj, toAppendTo, pos);
if (k > n) {
double dif = pos - fpos;
BrentSolver solver     = new BrentSolver();
assertEquals(-9.0, z.getReal(), 1.0e-5);
private int nextIndex;
double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);
public long nextLong() {
if (error > ratio * ratio) {
public abstract double nextDouble();  
assertEquals(expected.getImaginary(), actual.getImaginary(), delta);
private double finalTime;
double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
testDa.getElement(4);
public void testBadParameters() throws MathException {
public StepNormalizerTest(String name) {
private static final long serialVersionUID = -3004689053607543335L;
&& (Math.abs(current) > convergence)));
super(order, order, data);
integ.setInitialStepSize(1.7);
int targetIter = Math.max(1,
inf = 0;
public void testTanhCritical() {
public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {
public static Random createAdaptor(RandomGenerator randomGenerator) {
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
"Input data comes from the" + " unsupported source");
: ConvergenceChecker.NONE;
Complex z = x.multiply(Complex.NaN);
assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);
sumSq.increment(2d);
expandTo(startIndex + (index + 1));
minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },
assertEquals(1.0, c[5], tolerance);
return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);
return new TestSuite(StepNormalizerTest.class);
minpackTest(new WatsonFunction(12, 10.0,
checkPolynomial(new Polynomial.Rational(0l), "0");
minpackTest(new ChebyquadFunction(1, 8, 100.0,
throws DuplicateSampleAbscissaException {
double prod = 1;
int columnCount = this.getColumnDimension();
return t(StatUtils.mean(observed), mu, StatUtils.variance(observed),
public abstract PoissonDistribution 
return copiedArray;
if (rows == columns) {
new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },
cf.setImaginaryFormat(null);
private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;
measurements.set(i + 1, curr);
xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
equations.computeSecondDerivatives(t, z, zDot, zDDot);
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;
public void testDuplicate() {
--i;
v2 = new Vector3D(v2x, v2y, v2z);
public UniformRandomGenerator(RandomGenerator generator) {
private static NumberFormat getDefaultNumberFormat(Locale locale) {
int getNumberOfSuccesses();
double x = 3.291 / Math.sqrt(2.0);
return jacobianEvaluations;
double tmp2 = x3 + ti   * x4 - Math.cos(temp);
return new DefaultValue(l);
return new FractionFormat(f);
moment = new SecondMoment();
+ " + 3847870979902950 x^4"
1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0
double b  = x1;
c[0] = 1.0;
PolynomialFraction result = new PolynomialFraction(newP, newQ);
return new TestSuite(DormandPrince853StepInterpolatorTest.class);
new RationalNumber(-1l, 6l),
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
Complex c = new Complex(-1.2323, 1.4343);
lu[row][col] = sum;
(p < Math.abs(0.5 * e * q))) {
z = w.divide(x);
protected BigMatrix getIdentity(int dimension) {
if (index < low) {
properFormat.setNumeratorFormat(old);
lmDir[pj] = -lmDir[pj];
double nextGaussian(double mu, double sigma);
return new Skewness();
assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);
this.q1 = q1;
index[swap[rank]] = tmp;
return new LinearProblem(a, x, b);
public BigInteger getDenominatorsLCM() {
abstract class RungeKuttaStepInterpolator
double interp = ((100 - a) * prev + a * curr) / 100;
assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);
double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;
testStatistic.t(mu, emptyObs);
double ga = g0;
return addSub(fraction, true /* add */);
Polynomial.Rational Lk1 = (Polynomial.Rational) Lk0.getDerivative();
assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.415) < 1.0e-10);
oldt = stage(min, max, 0);
RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
TrapezoidIntegratorSampler sampler =
public class MaxTest extends StorelessUnivariateStatisticAbstractTest{
private void copyIn(double[][] in) {
private double min;
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);
return (a.length == 2) && (a[0] == 0) && ((a[1] - 1.0) == 0);
empiricalDistribution2 = new EmpiricalDistributionImpl(100);
assertEquals(new BigMatrixImpl(stringColMatrix), 
double pos = p * (n + 1) / 100;
assertTrue(stack.indexOf(innerMsg) > 0);
meanStat.increment(vertices[i]);
checkValue(new RationalNumber(-1l, 2l), "-1/2");
jacobian[m - 2]    = new double[n];
+ k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j]
double yp1   = h * y1Dot[i];
super(m, buildArray(m, factor), theoreticalStartCost,
public class PolynomialSplineFunction 
setCumulativeTestPoints(new double[] {-2, 0});
public PolynomialFraction(BigInteger i) {
float expansionFactor) {
double value = b.data[bIndex];
Complex delta = null;
protected static NumberFormat getDefaultNumberFormat() {
throw new IllegalArgumentException("Gaussian std dev must be > 0");
for (int i = k + 1; i < rows; ++i) {
if (k == 31) {
mean[i]              = 0.5 * (vertexA[i] + vertexB[i]);
public class HermiteTest
case '+' :
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
assertTrue(l1.contains(x)    ^ (!b5));
ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());
return (inf <= i.sup) && (i.inf <= sup);
protected static double evaluate(double[] coefficients, double argument) {
new BigMatrixImpl(rowMatrix));
kurt.increment(1d);
simplex[i] = new PointCostPair(vertex, Double.NaN);
assertEquals("empty hash code", emptyHash, t.hashCode());
testProbability(15.501, 4.0, 2.0, .9499);
return "Divide";
private static final long serialVersionUID = -1058849527738180243L;
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
covariance = null;
return Math.exp(x);
public int nextInt() {
costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];
public void testIdentity() {
public abstract double getTheoreticalValue();
Math.asin(v2.getZ()),
observed1, observed2, 0.12));
assertEquals( 3.920034013457876, sample.getStandardDeviation(),
oPoMn4   = 1 + oMn2 * oMn2;
return new TestSuite(PolynomialDoubleTest.class);
public void testFormatImproper() {
boolean jdkSupportsNesting = false;
+ e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
GeneralSquareMatrix m1 = buildProblem1().a;
public abstract class CoefficientsGenerator {
public static TestProblem[] getAPSProblems() {
return NumberFormat.getAvailableLocales();
double getFunctionValueAccuracy();
new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),
assertEquals(-3.0, z.getReal(), 1.0e-5);
assertTrue(r1.end   == r1.end);
assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);
Complex c = new Complex(232.222, -342.33);
assertFraction(-317, 100, new Fraction(-317.0 / 100.0));
checkMatrix (l2, new BilinearPattern(1.0, 0.01));
MathUtils.binomialCoefficientLog(n - m, k - x) -
if (x < min) {
public void setScale(int scale) {
return new BigMatrixImpl(out);
assertTrue(map.containsClass(TransformerMapTest.class));
p = (Polynomial.Rational) p.divide(q.getCoefficients()[0]);
check(new Interval(-10.0, 10.0), new Interval(-4.0, 5.0), 0.0,
int n = getImaginaryCharacter().length();
return new Vector3D(-x, -y, -z);
yMidDots = null;
-9.0),
(MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),
assertEquals("BigMatrixImpl{}",
fail("Can not have 0.0 beta.");
a = a.add(wGradGradT);
public void tearDown() 
assertEquals("var", var, u.getVariance(), tolerance);
int calcIndex = index;
return getInstance(Locale.getDefault());
for (int i = 0; i < observed1.length; i++) {
public double getReal() {
testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);
this.cy = new EstimatedParameter("cy", cy);
Random random = new Random(347588535632l);
private Random random = new Random();
sumLog.clear();
int numberOfSuccesses, int sampleSize) {
double tmpSquare = x1 * x1 + x2 * x2;
return value.longValue();
public void testCreateColumnBigMatrix() {
factory = (FirstOrderIntegratorFactory) dc.newInstance(
for (int k = 0; k < size; ++k) {
protected double m2;
return valuesFileURL;
assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));
for (int i = 0; i < selectedRows.length; i++) {
public RationalNumber() {
m.getColumn(-1);
return 1.02 * (i + 1) * (j + 1);
dimension  = x.length;
public void testConjugate() {
int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);
for (int i = 0; i < result.length; ++i) {
double maxStep = pb1.getFinalTime() - pb1.getInitialTime();
return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, 
public void testRootMatrix() {
assertFraction(4, 3, b.add(b));
public static class DivisionResult {
polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);
assertEquals(30.65d,  MathUtils.round(30.645d, 2), 0.0d);
for (int i = 0; i < 5000; ++i) {
TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);
if (maximumIterations <= 0)  {
private AbstractCurveFitter.FitMeasurement next;
public abstract double getDeterminant(double epsilon);
double   x05 = parameters[4].getEstimate();
while ((str = in.readLine()) != null) {
public static double nextAfter(double d, double direction) {
double[][] o = new double[3][];
public FunctionEvaluationException(double argument, String message) {
checkMatrix(u, new BilinearPattern(1.0, 0.1));
assertEquals(expected, map.getTransformer(TransformerMapTest.class));
protected StandardDeviation stat;
double x01 = parameters[0].getEstimate();
x = new double[] {nan, nan, nan};
return (MathUtils.equals(stat.getMax(), this.getMax()) && 
VectorialValuedPair p0 = sampler.nextSamplePoint();
public void testSignLong() {
public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {
(x2 - 2 * x3) * (x2 - 2 * x3),
private static final long serialVersionUID = 107049519551235069L;
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);
double midPoint = a + halfStep;
double delta;
private int[] inverseCumulativeTestValues;
public void testAddFail() {
testStatistic.t(mu, tooShortStats);
protected double thirdMoment = 868.0906859504136;
private GammaDistribution gamma;
private static double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;
public double getAngle() {
private final Vector3D a1;
public void testStats() {
RealMatrixImpl ret = new RealMatrixImpl(m,n);
+   eta * (v[5][i]
assertEquals(-2.0, z.getReal(), 1.0e-5);
observed1, observed2, 0.13));
protected double[] interpolatedState;
transformer.transform(f, 1, -1, 64);
this.stepControl4 = stepControl4;
m.setSubMatrix(testDataPlus2,0,0);      
public interface Compilable {
0.990d, 0.975d, 0.950d, 0.900d, 1}; 
f = f1.divide(f1);  
rd = new RandomDataImpl();
public UnivariateRealFunction interpolate(double x[], double y[]) throws
Double.POSITIVE_INFINITY);
if (i > 4) {
coefficients[0] = y[i];
double[] work2   = new double[cols];
private int callsCount;
k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,
ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();
suite.addTest(org.spaceroots.mantissa.linalg.AllTests.suite()); 
void clear();
summariesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());
cos   = sin * cotan;
public void testInterpolateSin() throws Exception {
ComplexUtils.log(oneNegInf), 10e-12);
double s2  = 0.0;
setContractionCriteria(contractionCriteria);
ret = Double.POSITIVE_INFINITY;
checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(2l, 5l)),
generator  = null;
private interface ElementPattern {
public VitalStats getVitalStats() {
public double apply(UnivariateStatistic stat) {
System.arraycopy(rowData, 0, data[0], 0, nCols);
max  = s.max;
v += factors[i] * parameters[i].getEstimate();
this.stabilityReduction = 0.5;
lower.multiply(upper), normTolerance);
public void testSinhInf() {
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );
for (int j =0; j < 11; j++) {
new EstimatedParameter[] { p[4], p[5] },
return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,
mean *= 10.0;
if (a.getDegree() < b.getDegree()) {
public class RiemannIntegratorSampler
public class ThreeEighthesStepInterpolatorTest
this.generator = generator;
assertEquals(0, random.nextFloat(), 0);
private static final long serialVersionUID = -246712922500792332L;
UnivariateRealFunction f) throws FunctionEvaluationException {
"matrice singuli\u00e8re" },
assertTrue(p2.getName().equals("p2"));
public void testTransformInteger() throws Exception {
DuplicateSampleAbscissaException {
ra.addElementRolling(2.0);
assertTrue(u > 0.99 && u < 1);
Integer.toString(maxCostEval)
c[i+1] = 1;
for (int i = 0; i < columns; ++i) {
assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());
work1[pj] = sPar * diag[pj];
sum = sampler.nextSamplePoint().getY();
return Math.sqrt(
if (Math.abs(h) < minStep) {
int[] n22 = { 1, 2, 4, 5, 8, 15, 20 };
for (int i=x.length-1; i>=0; i--) {
assertNull(line);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));
10,
public class ChiSquareTestTest extends TestCase {
map.putTransformer(TransformerMapTest.class, expected);
private int three = 3;
new GaussianRandomGenerator(rg));
public void testSqrtInf() {
double tmp1 = twoPi * tmpSquare;
PolynomialFunction f = new PolynomialFunction( c );
private double nextY;
if (error > maxError) {
UnivariateRealFunction f);
assertEquals(150, MathUtils.lcm(a, -b));
setMaxGrowth(10.0);
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
public BigMatrixImplTest(String name) {
fail("vectors not same length");
out *= (z - x[i]) / (i + 1);
if (mantissa == 0L) {
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public ChiSquareTestImpl() {
upperBounds[i] = upperBounds[i-1] +
protected int                  n;
double costE = evaluateCost(xE);
private class ArrayDataAdapter extends DataAdapter{
double sum = a[k-1][0] * yDotK[0][j];
C = f[i].subtract(f[i+1]);
return Math.sqrt(getMeanSquareError() / sumXX);
double dirJ = lmDir[pj];
checkLegendre(new Legendre(0),  1l, "1");
-tmp3,
public RotationTest(String name) {
fn  = fn1;
data[indexU] += factor * a[j];
0.885, 0.831, 0.847, 0.786, 0.725,
double fm;
new MidpointIntegrator(0.01).integrate(pb,
return new Vector3D(x + v.x, y + v.y, z + v.z);
equations = null;
new Polynomial.Rational(2l, 2l)),
this(new ArrayList());
list2.addToSelf(new Interval(1.0, 3.0));
public int getMinimalIterationCount() {
sign = -1;
"expansion would ensue as an internalArray.length " +
f.addValue(randomData.nextPoisson(4.0d));
double chiSquareTest(double[] expected, long[] observed) 
public static double tTest(double[] sample1, double[] sample2)
public void testDensities() throws Exception {
n            = 0;
private static class KowalikOsborneFunction extends MinpackFunction {
testLogBeta(Double.NaN, 0.0, 2.0);
double product = Double.NaN;
public class HarmonicFitter
sum        = (double[]) s.sum.clone();
double x[] = { 1.0 };
assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;
0.806908362156733,  0.956846335141266
this.orderControl1 = 0.8;
ret = Double.NEGATIVE_INFINITY;
double u1y = u1.getY();
assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
assertTrue(m1.getColumns() == m2.getRows());
protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };
wggRow[l] =  weight * gk * grad[l];
testStatistic.chiSquare(expected,observed) < 37.70);    
this(i, BigInteger.ONE);
public class TransformerMapTest extends TestCase {
RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;
public void testIncrementation() throws Exception {
DefaultValue(int i) {
return numerator;
for (int i = 0; i < polynoms.length; ++i) {
public void addValue(int v) {
Polynomial.Double p = new Polynomial.Double(r);
sum += 0.5 * (current.getX() - previous.getX()) * (previous.getY() + current.getY());
assertEquals(3, generator.getRank());
Assert.assertTrue(msg, Double.isNaN(actual));
int dimension = sums.length;
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
m [1][2] = 2.0 * (q2q3 + q0q1);
setRate(rateAfter);
setInterpolatedTime(t);
assertNotNull(c);
private long n = 0;
f = f.divide(new RationalNumber(4l,9l));
public MappableScalar(double value) {
return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;
y0Dot    = null;
assertTrue(Math.abs(a3[0] - 0.6) < 1.0e-10);
new EstimatedParameter[] { p[0], p[1], p[2] },
public void testNoSetOutsideOfDiagonal() {
polynoms[0][i] = currentState[i];
return new StreamDataAdapter(inputStream);
suite.setName("RealMatrixImpl Tests");
0.5 * getDegreesOfFreedom(),
return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);
Matrix l2 = l1.duplicate();
if (i-- != 0) {
protected void tearDown() throws Exception {
assertEquals(6, c.length);
protected boolean incMoment = true;
for (int i = 0; i < sample2.length; i++) {
dataArray[i] = ((Double)iter.next()).doubleValue();
q0 = 1;
assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
: ConvergenceChecker.HIGH)
double[] expected = {100,100,100,100,100,100};
public void testTanCritical() {
a       = generator.getCoefficients(degree);
assertEquals( "chi-square test statistic", 16.4131070362, testStatistic.chiSquare(expected1, observed1), 1E-10);
testDecompose(m3, "Decomposing matrix m3");
double[]   refMean = new double[] { 1.78, 1.62,  3.12};
forward       = in.readBoolean();
public DoubleArrayAbstractTest(String name) {
protected void setDensityTestPoints(int[] densityTestPoints) {
assertTrue(Double.isNaN(percentile.evaluate(specialValues)));
setDistribution(t);
test4 = new double[6];
new EstimatedParameter[] { x[1] },
double minStep, double maxStep, double[] vecAbsoluteTolerance,
this.ignored       = ignored;
public BigMatrixImpl(BigDecimal[][] d) {
BigDecimal[] out = new BigDecimal[v.length];
assertEquals(all.size(), even.size());
12,
return makeDensityTestPoints();
Complex expected = new Complex(1, 2);
private static final long serialVersionUID = 4350328622456299819L;
a.setElement(0, 0,  1.0);
assertTrue(transposed instanceof DiagonalMatrix);
if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {
throw new CostException(new RuntimeException("oops"));
jacobian[m - 1]   = new double[n];
public NormalDistributionImpl(){
super(pattern, arguments);
for (int i = 1; i < k; ++i) {
public static double percentile(final double[] values, final int begin, 
protected double[][] yDotK;
sumOfLogs.evaluate(values, begin, length) / (double) length);
for (int j = 0; j < y0.length; ++j) {
minpackTest(new LinearFullRankFunction(50, 5, 1.0,
assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);       
ra.addElement(0.5);
TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);
ret = super.inverseCumulativeProbability(p);
pm = cumulativeProbability(x0);
return sum.evaluate(values);
Vector3D v = new Vector3D(1, 2, 3);
int n = vertex.length;
ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));
inf     = Math.min(local.getInf(), i.getInf());
private Estimator estimator;
x0 = xm;
assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);
getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);
nextAction = SwitchingFunction.CONTINUE;
minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,
double d01 = m2[0][1] - m3[0][1];
pending   = true;
assertEquals(0, first.compareTo(first));
testDa = new ResizableDoubleArray(2, 3.0f);
this.q0 = q0;
public Min() {
Complex root[] = new Complex[n];
skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;
private boolean lastSeen;
public void testConjugateInfiinite() {
return new DefaultValue(b);
VitalStats vs1 = new VitalStats( new Double(120.0), 
public void testNewSecantSolverNull() {
z = -0.5; expected = f.value(z); result = p.value(z);
vectorsInitialized = false;
return sorted[length - 1];
return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
int indexL = indexU;
assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
da.addElement(4.0);
verifySummary(summary);
return new StatisticalSummaryValues(getMean(), getVariance(), getN(),
public void testIndicatorLong() {
this.n   = n;
v /= 2;
public StatisticalSummary getSampleStats() {
if (!bisect) {
true, true, true,
ArrayList problems = new ArrayList();
void nextBytes(byte[] bytes);
assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-13);
a.setElement(1, 3,  -7.0);
int index1 = (i + 1) * columns - 1;
public long longValue(Evaluation argument) throws EvaluationException {
new LinearMeasurement(new double[] { 2.0, 1.0 },
Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);
private void testLogBeta(double expected, double a, double b) {
new BufferedReader(
d[i] = new BigDecimal(data[i]);
if (reject) {
if (i > 0) {
private static double k15_09 =                 0.0                       - b_09;
testLogBeta(Double.NaN, 1.0, 0.0);
System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);
public abstract class DirectSearchOptimizer {
double expected = 1.0e-2;
public TDistributionTest(String name) {
-.16431810653676389022e-3,
0.156293451851d, 0.00529247667642d, 8.27746364655e-09};
u.addValue(one);
assertEquals( Double.MIN_VALUE, MathUtils.nextAfter(0,  1), 0);
private double t0;
public StepNormalizer(double h, FixedStepHandler handler) {
+ theta * (v[6][i])))))));
u.addValue(0.0);
private static class LinearRank1Function extends MinpackFunction {
NumberTransformer trans = getTransformer(o.getClass());
ComplexUtils.polar2Complex(1, -pi/2), 10e-12);
assertFraction(1, 6, b.subtract(a));
integrator.integrate(-1, 1);
public double upperCumulativeProbability(int x) {
public Patient() {
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);
assertEquals(3.0, p[2].getEstimate(), 1.0e-10);
assertEquals(mean[i], estimatedMean[i], 0.07);
-r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),
public interface RandomGenerator {
double result = 0;
value = new Float(f);
suite.setName("Median  Tests");
public void testIndicatorInt() {
double min, max, tolerance = 1E-12;
oldz = z;
double alpha  = coeffU - beta * coeffV;
assertTrue(maxError > 0.001);
ck     = (RationalNumber) l.get(startK + k);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
private double maxError = 0;
public final class NewtonSolverTest extends TestCase {
delta = B * B - 4 * A * C;
UnivariateRealFunction rootFindingFunction =
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
assertEquals("two sample heteroscedastic t stat", 1.60371728768, 
"intervalle d''int\u00e9gration trop petit : {0}" },
double sum2, parl = 0;
return 1.0e-5;
int length = list.size();
Polynomial.Rational g2 = new Polynomial.Rational(1l);
assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);
DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);
checkConstant(randomAdaptor); 
public void testBinIndexOverflow() throws Exception {
private synchronized boolean shouldContract() {
"invalid row or column index selection");
emptyHash, statistic.hashCode());
this.randomData = randomData;
private void testLocalMaximum(UnivariateRealFunction derivative) {
int result = 31 + MathUtils.hash(getGeometricMean());
throw new IllegalArgumentException("Value not comparable to existing values.");
TestSuite suite = new TestSuite("org.spaceroots.mantissa.random"); 
p1 = new Polynomial.Rational(2l, -4l, 1l);
a  = b;
coefficients[1].setEstimate(guesser.getOmega());
public void checkValue(double value, double reference) {
implements ComputableFunctionIntegrator {
171414593.0/851261400.0,
+ corr10 * corr10 + corr11 * corr11 + corr12 * corr12
UnivariateRealFunction derivative = UnivariateRealFunctionUtils.centerDifferenceDerivative(function, 1.0e-5);
return sumLog;
protected double[] nullDoubleArray = null;
public void selfSub(SymetricalMatrix s) {
public long getCumFreq(int v) {
work[j]  = qy[j];
Math.PI / 2d,
distribution.setNumeratorDegreesOfFreedom(4d);
public void testpowNull() {
public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{
assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);
double x = MathUtils.binomialCoefficientDouble(test, test / 2);
DefaultTransformer t = new DefaultTransformer();
assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);
assertFraction(7, 6, a.add(b));
this.y0Dot    = y0Dot;
throw new InvalidMatrixException("LU decomposition requires that the matrix be square.");
u.getClass().getDeclaredMethod(
public class FractionFormatTest extends TestCase {
assertClose("transpose",mt,m.transpose(),normTolerance);
checkMatrix(m2, new BilinearPattern(0.01, 1.0));
public FirstOrderIntegrator newThreeEighthesIntegrator(double step) {
if (!isNonNegative(in)) {
protected void addParameter(EstimatedParameter p) {
StatUtils.varianceDifference(sample1, sample2, meanDifference),
paru = Math.min(paru, lmPar);
setImaginaryCharacter(imaginaryCharacter);
public void clear() {
class F2FP2Iterator
if (forward ^ model.forward) {
public void add(double x) {
private Polynomial.Rational p;
return sum;
throw new ArithmeticException("The denominator must not be zero");
private int oPoMn4;
assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );
String expected = "(-Infinity) - (Infinity)i";
return new RationalNumber(p.multiply(r.p), q.multiply(r.q));
char c = parseNextCharacter(source, pos);
super(nameOfTest);
double n = 0.0; // current element index
new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);
assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);
Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);
public CholeskySolver() {
if (i < 0) {
assertEquals("var",var,u2.getVariance(),tolerance);
for (int j = 0; j < i; j++)
nearest--;
return homoscedasticTTest(sampleStats1.getMean(),
protected FirstOrderDifferentialEquations equations;
new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
assertEquals(f.derivative().value(0), 0, tolerance);
assertEquals(false, random.nextBoolean());
return "Add";
UnivariateRealFunction f,
public class UniformRandomGenerator implements NormalizedRandomGenerator {
for (int i = 1; i <= 20; ++i) {
f = f1.divide(f1.reciprocal());  // should overflow
private NumberFormat imaginaryFormat;
protected double t(double m, double mu, double v, double n) {
return yHigh;
newPols[i] = new double[currentState.length];
fail("Expection MathException");
public DummyStepInterpolator() {
this.y0   = (double[]) y0.clone(); 
yMidDots    = new double[1][];
incMoment = false;
1.00000000000002, 1.00000000000002,
public void testIndicatorByte() {
simplex[i] = new PointCostPair(x, Double.NaN);
if (subMatrix[r].length != nCols) {
z              = new double[dimension];
String actual = complexFormat.format(c); 
throw new IntegratorException("dimensions mismatch: "
("Exponential mean must be >= 0");
if (starts < 2) {
if (index % columns == 0) {
public void testAddition() {
public void testFactiorialLimits() {
public void testValues() throws Exception {
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
for (int i = 0; i < extra; i++) {
assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);
randomData.setSecureAlgorithm("SHA1PRNG","SUN");
private void computeLUFactorization(double epsilon)
11.4124844654993,
UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);  
return (x >= 0.0F) ? 1.0F : -1.0F;
Arrays.fill(array, x);
private static double c15    = 1.0 / 5.0;
this.densityTestValues = densityTestValues;
this.a          = a;
public Vector3D() {
return inverseCumulativeTestValues;
public void setY(String string) {
= new EnhancedSimpsonIntegratorSampler(iter);
if (order == RotationOrder.XYZ) {
System.arraycopy(interpolator.polynoms[i], 0,
checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),
Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);
int l2 = l / 2;
return (cx.getEstimate() - px) / getCenterDistance();
assertTrue(l2.isEmpty()      ^ (!b4));
return (Math.abs(xHigh - xLow) <= tolerance)
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
double norm = axis.getNorm();
public class DefaultTransformerTest extends TestCase {
MathUtils.equals(stat.getN(), this.getN()));
f[0] = data[0];
nDevSq = Double.NaN;
+ "ODE problem has dimension {0}"
f.addValue(oneL);
assertTrue(Math.abs(a3[2] - 0.8) < 1.0e-10);
extends MantissaException {
double cumulativeProbability(int x0, int x1) throws MathException;
return result[0].doubleValue()
package org.spaceroots.mantissa.functions.scalar;
double[][] data = {
List newIntervals = new ArrayList();
double previousError = Double.NaN;
calls      = 0;
return minReduction;
statistic.increment(Double.POSITIVE_INFINITY);
if (Float.isNaN(x)) {
public static Complex tan(Complex z) {
Vector3D vRef = v1;
data[indexU] = factor * a[i];
for (int i = 0; i < theoreticalMinParams.length; ++i) {
new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },
public RationalNumber(long l) {
m = new BigMatrixImpl(detData);
12432.833948863, 6.9988751744895,
assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    
assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.002));
AbstractStepInterpolator interpolator = null;
double[] c, double[][] a, double[] b,
result[i - 1] = (double) i * coefficients[i];
sumOfLogs = new SumOfLogs();
if (interpolator.currentState == null) {
protected double getA(int n, double x) {
public void testEqualsSame() {
public static int mulAndCheck(int x, int y) {
fail("Expecting ArrayIndexOutOfBoundsException");
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
private double[] optimalStep;
double s[] = new double[n];
checkLaguerre(new Laguerre(5),  120l,
testGetDeterminant(m4, m4Det, "Calculating determinant of m4");
assertEquals(1.0, p[2].getEstimate(), 1.0e-10);
super("sample contains only {0} elements",
double y0 = f.value(x0);
+ theta * (v3[i]
public void setPropertyName(String propertyName) {
private static final String methodName = "Higham-Hall 5(4)";
int nCols = m.getColumnDimension();
dev = d - m1;
mapper  = null;
FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);
TestUtils.tTest(0d, oneSidedP, 95);
assertEquals(1, p1.getDegree());
"2/3");
private void findFactorialLimits() {
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
this.pb = pb;
regression.addData(1, 2);
protected UnivariateRealSolverImpl(
package org.apache.commons.math.stat.descriptive.rank;
private int roundingMode = BigDecimal.ROUND_HALF_UP;
setMedian(median);
v1 = v1.add(v2);
double[] out = new double[c.length];
TestSuite suite = new TestSuite(SumSqTest.class);
assertTrue("Std should not be zero (n = 2)", 
for (int col = 0; col < m.getColumnDimension(); col++) {
double oldP2 = p2.getEstimate();
return currentTime;
private ArrayList measurements;
sampleStats1.getVariance(), sampleStats2.getVariance(),
double[] a4 = { 0.4, 0.1, 3.1 };
assertNotSame(nf, cf.getImaginaryFormat());
for (int minor = 0; minor < Math.min(m, n); minor++) {
assertEquals("min", StatUtils.min(values), u2.getMin(), tolerance);
public double tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)
return add(BigInteger.valueOf(l));
0.975d, 0.990d, 0.999d};
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
double[] values = new double[] { one, two, two, three };
lmNorm = Math.sqrt(lmNorm);
x0 = xm; y0 = ym;
outBuffer.append(value);
return wholeFormat;
checkMatrix(d, 2.7);
private static final long serialVersionUID = -7173012970400285826L;
-11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,
internalArray = new double[initialCapacity];
int[] n20 = { 5, 10, 20 };
public void updateObjects(double[] data) {
public DescriptiveStatisticsTest(String name) {
StatUtils.sum(values, 0, 2),
loadStats("data/Mavro.txt", u);
GeneralSquareMatrix a = new GeneralSquareMatrix(2);
return new ScalarValuedPair(x, function.valueAt(x));
assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);
public void setRelativeAccuracy(double accuracy) {
double sample2[] = {1d, 3d, 4d, 2d};
public synchronized void discardFrontElements(int i) {
y = (double[]) problem.y.clone();
public NumberTransformer getTransformer(Class key) {
int n = num.intValue();
LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));
testStatistic.chiSquare(counts4);
TestProblem1 pb  = new TestProblem1();
(SummaryStatistics) binStats.get(findBin(min, val, delta));
public Rotation(Vector3D axis, double angle) {
checkMatrix (x, new ElementPattern() {
assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);
Complex c = new Complex(0.0, -1.4343);
assertTrue("same seeds",
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
StandardDeviation s1 = new StandardDeviation();
RealMatrixImpl b = new RealMatrixImpl(4, 3);
RealMatrix mRows03Cols12 = new RealMatrixImpl(subRows03Cols12);
System.arraycopy(a, 0, this.a, 0, a.length);
return new Complex(-real, -imaginary);
return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);
return new Complex(expA *  Math.cos(b), expA * Math.sin(b));
if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {
formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);
setFinalConditions(15);
if (lower >= upper) {
da = new ResizableDoubleArray();
Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);
numElements = i;
"trop petite tol\u00e9rance relative sur le co\u00fbt ({0}), aucune r\u00e9duction de la somme des carr\u00e9s n''est possible" },
assertEquals( "chi-square test statistic", 16.4131070362, TestUtils.chiSquare(expected1, observed1), 1E-10);
return new TestSuite(DormandPrince54StepInterpolatorTest.class);
(1, -1).getNumerator(), -1);
this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;
-1.51372776706575,   0.99299573426328
setDegreesOfFreedom(degreesOfFreedom);
public TestUtilsTest(String name) {
testStatistic.tTest(mu, sampleStats), 10E-10);
double  currentT         = t0;
double f = 0;
private static final long serialVersionUID = -436928820673516179L;
if (y1 == 0.0) { return max; }
if (decompMatrix.getColumnDimension() != c.length) 
this.equations = equations;
tmp = File.createTempFile("test",".ser");
int temp = list[target];
public class ArgumentOutsideDomainException extends FunctionEvaluationException {
public abstract double tTest(double[] sample1, double[] sample2)
double v3z  = v3.getZ();
if ((x >= -threshold) && (x <= threshold)) {
m1.selfSub(m2);
assertEquals(0, solver.getIterationCount());
Gamma.logGamma(a + b);
Polynomial.Rational Pk1 = (Polynomial.Rational) Pk0.getDerivative();
assertEquals("R lower triangle", R.getEntry(i, j), 0,
package org.apache.commons.math.stat.data;
eDA2.addElement( i );
u.addObject("11.8");
double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};
public void testQuaternion() {
private static class InterpolatingStepHandler implements StepHandler {
double[][] testData3x3Singular = { 
int n = sb.length();
private static final double DEFAULT_EPSILON = 10e-15;
public ProperFractionFormat(NumberFormat wholeFormat,
new GeneralSquareMatrix(-3, null);
assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
currentT, y, yDotK[0], yTmp, yDotK[1]);
throw new SingularMatrixException();
Complex z = new Complex(1,1);
public void testDivideInfinite() {
public double getInf() {
public void updateArray() {
return data[row][column];
Number number = format.parse(source, pos);
min = 0.0; max = 1.0; expected = 0.25;
+ k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];
m.getSubMatrix(new int[] {0}, new int[] {4});
x.setElement(1, 1, 1.0);
GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);
polynoms[i], 0, dimension);
x = x3 - correction;                // correction != 0
new Integer(dimension1), new Integer(dimension2)
return imaginary;
exceptionOccurred = false;
checkValue(new PolynomialFraction(4l, 5l).add(new PolynomialFraction(-3l, 4l)),
public void testSubOK() {
private static final double e5 = -17253.0 / 339200.0;
0.0728915102882945,
public interface EmpiricalDistribution {
-11.59125141003, 13.2024883984741,
return evaluate(x, epsilon, Integer.MAX_VALUE);
forward   = interpolator.forward;
Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),
sum += jacobian[index] * qy[i];
private int n = 0;
if (result < midpoint) {
return data[i * columns + j];
public void testTranspose() {
regression.addData(((double) i) / (n - 1), i);
a = new RationalNumber[] { a0, a1, a2 };
private void fillBinStats(Object in) throws IOException {
outData[row][col] = data[row][col] * d;
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
Integer.toString(maxIterations)
while ((i > 0) && (a[i].isZero())) {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
MathUtils.binomialCoefficientLog(4,5);
a.setElement(3, 3,  -1.0);
bi[j] = 1.0 + 0.1 * ++counter;
if (denominator != 0) {
private static final String methodName = "Euler";
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
double[] h_coeff = { -4.0, 6.0 };
sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);
q1 = inv * (ort[0][2] + ort[2][0]);
"a {0}x{1} matrix cannot be a rotation matrix" },
"(1 + x)/(6 + 2 x)");
1.0)
PointCostPair[] minima = nm.getMinima();
public EstimatedParameterTest(String name) {
Vector3D v1 = applyTo(Vector3D.plusI);
checkValue(new RationalNumber(2l, 3l).add(new RationalNumber(3l, 4l)),
this.imaginary = imaginary;
private SecondOrderDifferentialEquations equations;
.46523628927048575665e-4,
if (N == 1) {       // trivial case
assertEquals(0, dJ0, 1.0e-10);
public class MidpointIntegratorTest
target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};
return new double[] { 0d,  0.018315638889d, 0.0915781944437d, 
assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);
this.sigma = sigma;
double error = dx * dx + dy * dy;
+ k15_14 * yDotKLast[0][j];
WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);
protected double filterStep(double h, boolean acceptSmall)
1.7328679513999e-2, 1.1552453009332e-2, 8.6643397569993e-3,
range, 0.083, true);
assertEquals(0d, std.getResult(), 0);
randInt = randInt >> 8;
ComplexFormat cf = new ComplexFormat(nf);
z = 2.5; expected = 22.0; result = p.value(z);
public Set classes() {
public interface CauchyDistribution extends ContinuousDistribution {
return columns;
private double getIntercept(double slope) {
public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {
protected void tearDown() throws Exception {      
"la matrice orthogonale la plus proche a un d\u00e9terminant n\u00e9gatif {0}" },
Complex expected = new Complex(1.0, -2.0);
Double.isNaN(u.getVariance()));
public FunctionOperator getDefaultDerivativeOperator() {
&& (costPerTimeUnit[targetIter-1]
r = (Polynomial.Rational) r.multiply(new RationalNumber(1l, 2l));
double[] fittedCoefficients = new double[coefficients.length];
private Mean[] means;
public MathException(String pattern, Object[] arguments, Throwable rootCause) {
throw new DuplicateSampleAbscissaException(x[j], j, j+i);
if (i < j) {
return iter.getDimension();
private void computeUpToDegree(int degree) {
assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;
public class BasicSampledFunctionIteratorTest
solver.solve(2, 3);
List externalList = new ArrayList();
private static final double sqrt10 = Math.sqrt(10.0);
public abstract double[] makeDensityTestValues();
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
MathUtils.equals(stat.getMin(),this.getMin()) &&
private static final long serialVersionUID = -1360952845582206770L;
this(df, new GammaDistributionImpl(df / 2.0, 2.0));
0.01));
public void testDecompose() {
Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
new RationalNumber(a2),
ScalarSampleStatistics odd  = new ScalarSampleStatistics();
double cdf = data[i][2];
public void increment(double[] v) throws DimensionMismatchException {
public interface DoubleArray {
private double neginf = Double.NEGATIVE_INFINITY;
double x1 = max;
this.factors = factors;
this(imaginaryCharacter, format, (NumberFormat)format.clone());
q3 = -w.getZ();
double xNormSqr = 0;
-0.403688070279258, 0.236665033746463
list1.addToSelf(list);
-844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,
super(rootCause);
hexString = randomData.nextSecureHexString(0);
"vitalStats.heartRate" );       
double epsilon, 
String source = "-1 / 2";
factory = UnivariateRealSolverFactory.newInstance();
i = -1;
if (!isPowerOf2(o.length)) {
testStatistic.test(testArray, 0, 7);  // end past end
double scaling_coefficient = 2.0 / (n - 1);
public int getScale() {
assertTrue(Math.abs(pair2.getX() - pair1.getX()) < 1.0e-10);
new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },
improperFormat = FractionFormat.getImproperInstance(getLocale());
void setShape(double alpha);
double t0, double[] y0, double step, int k,
if (d1.isLoaded()) {
System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,
setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, 
v[k] = new double[interpolatedState.length];
public double value(int i, int j);
protected abstract void computeInterpolatedState(double theta,
public abstract class IntegerDistributionAbstractTest extends TestCase {
x[i] = min + i * (max - min) / n;
public boolean checkTheoreticalMinParams() {
21, 22, 23, 24, 25, 26, 27, 28, 29,  30,
if (a[i] != 0) {
private int index;
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
setResult(x3, i);
lu[col][i] = tmp;
NonNullRange r3 = NonNullRange.intersection(r1, r2);
private static double k16_11 =                 0.0                       - b_11;
assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);
public Polynomial multiply(long l) {
parseAndIgnoreWhitespace(source, pos);
14.9,
return x;          
assertTrue(sampler.size() == 13);
factory.newBrentSolver(null);
return (first == null) ? Double.NaN : first.getEventTime();
BigDecimal largest = ZERO;
LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));
testSolve(m4, "Solving matrix m4");
MatrixIndexException ex = new MatrixIndexException(msg);
private double sumXX = 0d;
assertEquals(points.length, sample.size());
public void testRegularizedBetaNegativePositivePositive() {
assertFraction(1, 1, a.divide(a));
switchesHandler.stepAccepted(currentT, y);
public abstract double tTest(double mu, StatisticalSummary sampleStats)
double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);
data[row][0] = v[row];
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / d);
throw new MatrixIndexException("illegal column argument");
checkPolynomial(new Chebyshev(2), "-1 + 2 x^2");
copy.addToSelf(i2);
yTab[i2] = yTmp;
FitMeasurement prec = curr;
TestProblem1 pb = new TestProblem1();
rg.setSeed(64453353l);
double gNorm = Math.sqrt(sum2);
"denominator format can not be null.");
if (x == Integer.MAX_VALUE) {
regression.addData(corrData);
extends RungeKuttaIntegrator {
public void testDoubleValue() {
equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);
u.addValue(5.0);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
TestSuite suite = new TestSuite(MinTest.class);
scalar1 = new MappableScalar();
minStep = step;
assertSame(Fraction.ZERO, f);
public ScalarValuedPair nextSamplePoint()
throw new ArithmeticException("The fraction to divide by must not be zero");
public MinpackMeasurement(int index) {
return factors[i];
return getMean();
GraggBulirschStoerStepInterpolator gbsInterpolator
++jacobianEvaluations;
public APSProblems12To14(int n, double a, double b, double expectedRoot) {
LinearProblem problem = new LinearProblem(new LinearMeasurement[] {
return (q.signum() < 0) ? new RationalNumber(q.negate(), p.negate())
Skewness s= new Skewness(m4);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
for (int i = j + 1; i < solvedCols; ++i) {
+ " has a negative determinant {0}",
public abstract String getName();
checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), "-2 x + 3 x^2");
String line = reader.readLine(); // header line
private static final long serialVersionUID = -8198306839874267863L;
k = new Vector3D(dy1 * dz3 - dz1 * dy3,
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
this.coefficients = new double[c.length];
suite.addTest(BasicSampledFunctionIteratorTest.suite());
outBuffer.append("median: " + getPercentile(50) + "\n");
int roundingMethod) {
BigDecimal maxColSum = ZERO;
u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);
double residual = measurements[i].getResidual();
Complex expected = new Complex(0.0, 1.73205);
return new NonNullRange(0, i + 1);
assertTrue(Math.abs(measurements[i].getMeasuredValue()
assertTrue(r3.end   == 12);
public static final int DIGEST_MODE = 0;
int[] n19 = { 1, 2, 3, 4, 5, 20, 40, 60, 80, 100 };
public interface FirstOrderIntegrator {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
Boolean input = Boolean.TRUE;
secRand.setSeed(System.currentTimeMillis());
assertTrue(l1.isConnex()     ^ (!b1));
assertEquals("3x4 A = QR", 0, norm, normTolerance);
public void computeDistribution() throws IOException {
p.evaluate(d, 0, d.length, -1.0);
for (int j = 0; j < parameters.length; ++j) {
this.a = a;
double[] c = { -2.0, -3.0, 2.0 };
assertEquals(n + " choose " + k, binomialCoefficient(n, k), 
int sampleSize = 789;
assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);
double x1, double y1,
logSum += Math.log((double)i);
private void copyIn(String[][] in) {
DiagonalMatrix d2 = new DiagonalMatrix(d1);
minIndices = null;
for (int k = 0; k < yDotKLast.length; ++k) {
public void testSignFloat() {
assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);
public boolean converged (PointCostPair[] simplex);
-0.403417362841545, 0.236771143410386
int[] permutation = ((RealMatrixImpl) matrix).getPermutation();
empiricalDistribution2.getNextValue();
fail("Expecting IllegalArgumentException - negative count");
if ((one.length != 1) || !oneString.equals("one")){
public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
if (error > lastError) {
+ " - 207785032914759300 x^6"
public int converged (double xLow, double fLow, double xHigh, double fHigh);
lower            = null;
private RationalNumber b3k;
u.addObject(new Long(21));
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
protected double[] a;
public interface SecondOrderIntegrator {
assertEquals( f.value( 3.0), c[0], tolerance );
double weight = 0.0;
Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,
if (hexString.length() != 3) {
f[i] *= d;
private static class BardFunction extends MinpackFunction {
Percentile percentile = new Percentile(50);
ParsePosition parsePosition = new ParsePosition(0);
assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.5e-2);
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
MathUtils.binomialCoefficient(n, k));
double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);
assertClose("identity multiply",m.preMultiply(identity),
Fraction a = new Fraction(10, 21);
fk[k]    = new double[sequence[k] + 1][];
public void testSerialization() throws Exception {
public FrequencyTest(String name) {
RationalNumber c =
+ k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j]
super(translate(message));
u.addValue(3.0);
return n * x * Math.exp(-x);
private double[] diagR;
f1 = new Fraction(Integer.MAX_VALUE, 1);
if (source.substring(startIndex, endIndex).compareTo(
public interface TDistribution extends ContinuousDistribution {
Variance variance = new Variance();
public GillStepInterpolator() {
assertTrue(maxError < 1.54e-10);
if (v < knots[0] || v > knots[n]) {
if (Math.abs(diag) < epsilon) {
public class Laguerre
m.setSubMatrix(matrix.getData(),1,1);
sum2 = 0;
public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {
if (in.length < 2) {
Min min = new Min();
assertFalse(Double.isNaN(kurt.getResult()));      
throw new IllegalArgumentException("must have n > 0 for n!");
public boolean requiresDenseOutput();
ComputableFunctionSampler sampler =
expected = new Complex(-1.0, 0.0);
private static final double a74 = -2187.0 / 6784.0;
int nCols = this.getColumnDimension();
implements StorelessUnivariateStatistic, Serializable {
double v2y    = alpha * v1y + beta * v2.getY();
o[2] = new double[3];
q3 = inv * (ort[0][1] - ort[1][0]);
assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);
private double previousY;
return outBuffer.toString();
private static final long serialVersionUID = 2784465764798260919L;  
new double[] {  3.0, -1.0, 0.0, 1.0 },
double n0 = (double) n;
int n = getPopulationSize();
throws IOException, ClassNotFoundException {
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);
double[] vertexA, double[] vertexB)
return parse(source, pos);
assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));
-595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,
public void testAtanNaN() {
if (initialCapacity > 0) {
super.readExternal(in);
public FDistribution createFDistribution(
3.1796856858426e-5, 3.1001935436965e-5, 3.0245790670210e-5,
GeneralSquareMatrix m = new GeneralSquareMatrix(3);
double p = 0.1;
randomData.reSeedSecure();
result = solver.solve(-0.1, 0.3);
out[row][0] = data[row][column];
if (stat instanceof SecondMoment) {
hs.add(c[i][1]);
private int maxIterations;
x1 = x1 - 0.5 * tolerance;
assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);
return new BigMatrixImpl(this.copyOut());
assertTrue(mapper.getDataArray().length == size);
new GraggBulirschStoerIntegrator(minStep, maxStep,
m.getRow(10);
UniformRandomGenerator generator = new UniformRandomGenerator(rg);
public class Median extends Percentile implements Serializable {
Double.isNaN(u.getMean()));
if (rand == null) {
int index1 = permutations[i] * columns + k;
return (float) nextDouble();
m.setSubMatrix(null,1,1);
2.213364, u.getGeometricMean(), 0.00001 );
for (int j = i + 1; j < columns; ++j) {
this.b3k = b3k;
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
suite.setName("AbstractRandomGenerator Tests");
public MidpointIntegrator(double step) {
m3 = m2 = m1 = 0.0;
double c[] = { 1.0, -2.0 };
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public LinearFullRankFunction(int m, int n, double x0,
stats.addValue(test1[i]);
2.0),
TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);
public void testEqualsNaN() {
assertEquals(nf, properFormat.getNumeratorFormat());
protected double currentTime;
public void setMode(int mode) {
protected static double[] buildArray(int n, double x) {
return new PolynomialFraction(p.multiply(f.q).add(f.p.multiply(q)),
public class DerivativeOperatorFactoryTest extends TestCase {
empiricalDistribution = new EmpiricalDistributionImpl(100);
public class ChiSquaredDistributionImpl
boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||
setImaginaryFormat(imaginaryFormat);
generator =
computeUpToDegree(degree);
double   x04 = parameters[3].getEstimate();
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
return i -1;
public static double factorialLog(final int n) {
x = new Complex(neginf, 0);
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
sMax.setInterpolatedTime(time);
"InvocationTargetException in Transformation: "
double pow = Math.pow(stepControl3, exp);
c = source.charAt(index++);
double  nextT      = currentT + scaledH;
y0 = null;
1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0
public LevenbergMarquardtEstimator() {
for (int i = 1; i < a.length; ++i) {
new PolynomialFunctionLagrangeForm(x, y);
for (long i = 0; ! lastStep; ++i) {
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);
TestUtils.chiSquare(counts6);
vs.setValuesFileURL(url); 
assertEquals("singular determinant",0,m.getDeterminant(),0);
super(false, c, a, b, new MidpointStepInterpolator(), step);
? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
BigDecimal input = new BigDecimal("1.0");
double minStep, double maxStep, double scalAbsoluteTolerance,
public int getEvaluationsPerStep() {
for (int index = columns + 1; index < columns * columns; index += columns + 1) {
TestSuite suite = new TestSuite(MeanTest.class);
f1 = new Fraction(Integer.MIN_VALUE, 5);
lmDiag[i] = -sin * rik + cos * lmDiag[i];
p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);
new double[] { 0.5 }), false);
assertEquals(covariance.getEntry(i, j),
public DerivativeOperatorFactoryTest(String arg0) {
-43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,
DifferentiableUnivariateRealFunction f = new SinFunction();
fk[j][m][i] -= fk[j][m-2][i];
return roundingMode;
private double sum = 8;
return new ChiSquareTestImpl();
q1 = inv * (ort[0][1] + ort[1][0]);
if (!isPositive(expected) || !isNonNegative(observed)) {
assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
return Math.cos(x);
assertEquals("6 choose " + i, bcoef6[i], 
checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(-5l, 2l)),
int nRows = getRowDimension();
if (p instanceof PolynomialCoefficient) {
testGetDeterminant(m2, m2Det, "Calculating determinant of m2");
for (int i = 0; i < coefficients.length; i++) {
context.doubleValue(left) - context.doubleValue(right)
public interface UnknownDistributionChiSquareTest extends ChiSquareTest {
public double getPhase() {
tooShortStats = SummaryStatistics.newInstance();
int[] n25 = {
public class FitMeasurement
checkValue(f1, "4/3");
ret = Double.NaN;
coefficientsComputed = false;
double ret = probability(n, m, k, x0);
assertEquals(bounds.length, 100);
assertTrue(Math.abs(a3[1] - 0.7) < 1.0e-10);
ta = tb;
Expression expr = new Expression(o, propertyGetter, new Object[0]);
double[][] b = new double[order][order];
targetIter = k;
public void testNextSecureLong() {
checkLaguerre(new Laguerre(0), 1l, "1");
public void testLogNaN() {
v2 = null;
" is larger than the current number of elements";
public SumOfLogs() {
new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },
if (parameter == cx) {
TestProblem[] problems = TestProblem.getAPSProblems();
setNumberOfSuccesses(numberOfSuccesses);
fail("bad expected count, IllegalArgumentException expected");
interpolator.setInterpolatedTime(tb);
System.arraycopy(data[row], 0, out[0], 0, ncols);
package org.apache.commons.math.ode;
for (int i = 0, index = pk; i < k; ++i, index += cols) {
assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,
return new LowerTriangularMatrix(this);
public PascalDistributionTest(String name) {
public Complex divide(Complex rhs) {
--x0;
UpperTriangularMatrix u = buildMatrix(4, new ElementPattern() {
assertEquals(d1.getBinCount(), d2.getBinCount());
public Sum() {
double h = h2 * .5;
public abstract double doubleValue(Evaluation argument) throws EvaluationException ;
double c[], z, expected, result, tolerance = 1E-12;
return +1;
assertEquals(0.0, result[i].getReal(), tolerance);
public double solve2(double min, double max) throws MaxIterationsExceededException, 
Arrays.fill(f, n, m, -t);
private double beta;
assertTrue(optimum.cost > 0.015);
num = -num;
computeOmega(-f.length);    // pass negative argument
String aString = "a";
for (int i = 0; i < bData.length; ++i) {
throws SingularMatrixException;
protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])  
public void testInverse() {
private static final double e1_10 =         464500805.0 / 1389975552.0;
double errSum = e[0] * yDotK[0][j];
if ((sample1 == null) || (sample2 == null ||
double mu[] = new double[n];
public void testGoldenRatio(){
integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);
double val = vs.getNext();
private void setDelta(double h) {
return  (n0 * moment.m3) /
BigDecimal d[] = new BigDecimal[data.length];
if (p < .5) {
assertEquals(38.0, z.getImaginary(), 1.0e-5);
tstGetSortedValues(test2);
sum.increment(Double.NEGATIVE_INFINITY);
private double sup;
this.cost = cost;
double[][] data = new double[nRows][1];
improperFormat.setNumeratorFormat(old);
if (divider == 0.0) {
+ d[k][11] * yDotKLast[2][i]);
private final double  measuredValue;
public void testNextHex() {
throws IllegalArgumentException, MathException {
public FractionFormat(NumberFormat format) {
public double getQ0() {
ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -
interpolator.setInterpolatedTime(interpolator.getPreviousTime());
lu = this.getData();
sigma = empiricalDistribution.getSampleStats().getStandardDeviation();
for (int i = 0; i < result.getRows(); ++i) {
f1 = new Fraction(3,327680);
double coefficients[] = { -3.0, 5.0, 2.0 };
private void shuffle(int[] list, int end) {
(x == x1);
if ((expected.length < 2) || (expected.length != observed.length)) {
y = y * x + coefficients[i].getEstimate();
MatrixUtils.createRowRealMatrix(null);  // null
ret = new Double(value);
protected ThirdMoment stat;
assertTrue(d2.getColumns() == d1.getColumns());
("Complex modulus must not be negative");
public static double logBeta(double a, double b, double epsilon,
RealMatrix dX = a.solve(b);
int ir = index[rank];
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
public GeneralSquareMatrixTest(String name) {
Kurtosis k = new Kurtosis(m4);
return a;
if (y0 == 0.0) { return min; }
Complex expected = new Complex(1.00071, 0.00490826);
return min.evaluate(values, begin, length);
return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, 
new RationalNumber(a1),
public double getDeterminant() throws InvalidMatrixException {
f[0] = data[0].add(data[1]);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double v = randomData.nextUniform(0,1);
c = new double[n+1];
public void testNormalApproximateProbability() throws Exception {
double evaluate(double[] values);
throws NotPositiveDefiniteMatrixException {
result = p.a.solve(p.b, 1.0e-10);
return new TestSuite(GeneralSquareMatrixTest.class);
public class BinomialDistributionTest extends IntegerDistributionAbstractTest {
obs2 = (double) observed2[i];
public double[] exactIntegration(double a, double b)
if(i % 5 == 0)
source = "2 2 / -3";
public static double homoscedasticTTest(double[] sample1, double[] sample2)
"Matrix is not positiv definit");
-0.153070644166722e-4, 0.999789703934597,
vs.setValuesFileURL("http://www.apache.org");
public void testBeforeEnd()
"number of successes must be non-negative.");
public class ScalarSampleStatisticsTest
return new RationalNumber(p.multiply(r.q).add(r.p.multiply(q)),
y0         = null;
public abstract Evaluation evaluate(int i);
public RealMatrixImpl(int rowDimension, int columnDimension) {
EstimatedParameter[] p = new EstimatedParameter[] {
double eta = oneMinusThetaH / h;
z.abs() <= functionValueAccuracy);
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
Vector3D v2 = new Vector3D(-3, -2, -1);
private static final long serialVersionUID = -7391954140799812791L;
return solve(min, initial);
outData[row][col] = sum;
public FourthMoment() {
return sumSq.evaluate(values);
-4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,
(new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),
if (error > 1.0) {
if (Math.abs(y2) < Math.abs(y1)) {
public static final Complex ZERO = new Complex(0.0, 0.0);
public TestFactoryImpl() {
j = 0;
public class MatrixUtils {
private StatUtils() {
protected PointCostPair[] simplex;
return new TestSuite(IntervalsListTest.class);
return inv;
public Vector3D(double a, Vector3D u) {
new Complex(-2.6, -2.7),
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
public final class BeanListUnivariateImplTest extends TestCase {
vs.setMu(0);
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
if (sorted[i] > sorted[i+1]) {
public static boolean chiSquareTest(double[] expected, long[] observed,
return new TestSuite(EstimatedParameterTest.class);
String innerMsg = "Caused by: " + 
double b = 1.0 - x[0];
public double evaluate(
suite.addTest(VectorialSampleStatisticsTest.suite());
assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));
assertTrue(Math.abs(d02) < 6.0e-6);
public class MatrixIndexExceptionTest extends TestCase {
outBuffer.append("geometric mean: " + getGeometricMean() + "\n");
y[1] = coeffs1 [coeffs1.length - 1];
public void testGetRowMatrix() {
hexString = randomData.nextHexString(1);
MatrixUtils.createBigMatrix(nullMatrix);  // null
return new TestSuite(LowerTriangularMatrixTest.class);
double median, double scale)
TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); 
m = n / 2.0;
public int getIterationCount() throws IllegalStateException {
return scaleArray(fft(data, false), scaling_coefficient);
public class AllTests {
sup = Math.max(Math.min(sup, i.sup), inf);
public void testGetStandardDeviation() {
protected double[] currentState;
return expectedRoot;
checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(-2l, 5l)),
assertTrue(maxError < 2.4e-10);
private boolean isNonNegative(long[] in) {
protected int maximalIterationCount;
double fn1;
list.clear();
public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {
value = y[nearest];
boolean bound) {
empiricalDistribution2.load(dataArray);   
protected double homoscedasticTTest(double m1, double m2, double v1,
private int jacobianEvaluations;
assertEquals(1000000, ex.getMaxIterations());
public synchronized void clear() {
testStatistic.chiSquare(counts5);
assertNotNull(u);
if (data != null) {
assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);
assertTrue(handler.getMaximalError() < 4.0e-12);
checkValue(m.getMeasuredValue(), theoretical() + 0.1);
assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);
solver.setRelativeAccuracy(newValue);
BigDecimal[][] data = new BigDecimal[nRows][1];
for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {
fail("negative mean supplied -- IllegalArgumentException expected");
assertEquals(1.23f, MathUtils.round(x, 2), 0.0);
x01 = o[0][1];
pair1.y);
startIndex += 1;
value = array[start];
BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);
System.out.println(os);
if (error <= 1.0) {
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
StatUtils.min(x, 0, 4);
y[1] = y[1] * t + coeffs1[i];
if ((Math.abs(fp) <= 0.1 * delta)
private void copyIn(BigDecimal[][] in) {
return new double[0];
double g = 0;
new RealMatrixImpl(rowMatrix));
"oberved1, observed2 array lengths incorrect");
distribution.setDenominatorDegreesOfFreedom(4d);
integrator.setMaximalIterationCount(4);
Polynomial.Rational Lk0g0 = Lk0.multiply(g0);
ObjectOutputStream    oos = new ObjectOutputStream(bos);
public QRDecompositionImpl(RealMatrix matrix) {
test = 10;
assertEquals(i + "! ",Math.log((double)factorial(i)),
double lower = -1d;
private int m;
public RationalNumber multiply(long l) {
public boolean isIdentity() {
assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);
protected double percentile95 = 20.82d;
return MatrixUtils.createBigIdentityMatrix(dimension);
/ (d12 * d23 * d13);
11,
ComplexUtils.cos(null); 
public final int offset;
public class MappableScalar
s.append(absAi.toString());
RealMatrixImpl ret = new RealMatrixImpl(m,m);
class EulerStepInterpolator
HarmonicFitter fitter =
this(format, (NumberFormat)format.clone());
public DescriptiveStatisticsImplTest(String name) {
polynoms[k][l] = in.readDouble();
Math.acos(v2.getX()),
if (i >= j) {
return apply(new SumOfSquares());
assertTrue("two sample heteroscedastic t-test accept", 
assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));
if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {
public void testQuintic() throws MathException {
public void testDivideNaNInf() {  
sum2       = new double[dimension * (dimension + 1) / 2];
public class UnivariateRealSolverFactoryImplTest extends TestCase {
public Legendre() {
return d;
assertEquals(new RealMatrixImpl(testData), 
assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));
double tmp1 = Math.exp(-temp * x4);
z = negInfNegInf.divide(oneNaN);
public RealMatrix scalarMultiply(double d) {
public static final RationalNumber ZERO = new RationalNumber(0l);
checkMatrix(u2, new BilinearPattern(1.0, 0.1));
super(weight, measuredValue);
protected double t(double m1, double m2,  double v1, double v2, double n1,
ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
return new TestSuite(NonNullRangeTest.class);
assertTrue(bos.size () > 158000);
current = iter.nextSamplePoint();
functionValueAccuracy = defaultFunctionValueAccuracy;
double normProduct = v1.getNorm() * v2.getNorm();
super(0, generator);
double[] resultData = new double[rows * m.columns];
0.00560963647102661,
new EstimatedParameter("p3", 4)
assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);
double getDegreesOfFreedom();
assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);
dev = values[i] - mean;
long[] observed2 = {5, 15, 14, 10};    
private final double q1;
public static boolean tTest(double mu, double[] sample, double alpha)
if (numerator==Integer.MIN_VALUE) {
public abstract double getStandardDeviation();
sum  = x;
public double evaluate(final double[] values, final int begin, 
public abstract ChiSquaredDistribution createChiSquareDistribution(
previousTime      = interpolator.previousTime;
private static final long serialVersionUID = -3561898582944940550L;
assertEquals("chi-square p-value", 0.002512096, TestUtils.chiSquareTest(expected1, observed1), 1E-9);
throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);
if (x.length < 2 || y.length < 2) {
return chiSquareTest;
public FDistributionTest(String name) {
int d = MathUtils.gcd(numerator, denominator);
return solve(initial, max);
double inv = factor / (n + 1);
private ArrayList points;
if (y0 * y1 >= 0) {
interpolatedState = null;
double fourTheta2 = 4 * theta * theta;
private static final long serialVersionUID = 1708010296707839488L;
private MathUtils() {
cachedNormalDeviate = Double.NaN;
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
for (int k = 0; k < yDotK.length; ++k) {
h                = currentTime - previousTime;
protected FourthMoment moment;
return new NormalDistributionImpl(2.1, 1.4);
testStatistic.t(mu, (SummaryStatistics) null);
private static class BrownAlmostLinearFunction extends MinpackFunction {
return moment.m2 / ((double) moment.n);
return m;
res[1] = yb * b - ya * a;
public void testRegularizedBetaNanPositivePositive() {
private double threshold;
integ.integrate(pb2,
suite.addTest(MatrixFactoryTest.suite());
-Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) },
case -1 :
Object object2 = serializeAndRecover(object);
HashSet set = (HashSet) u[i];
integrator.setMaximalIterationCount(99);
public Rational(long a2, long a1, long a0) {
double[][] mv2 = m2.getData();
public static double evaluate(double a[], double c[], double z) throws
int initialIndex = pos.getIndex();
public double getA() {
double corr01 = o[0][1] - m[0][1];
assertFalse(map.containsTransformer(expected));
protected double getDomainLowerBound(double p) {
RealMatrix m = new RealMatrixImpl(id);
new BigDecimal(2)}});
private boolean firstTime;
StatUtils.variance(sample1), StatUtils.variance(sample2),
public Rational(long value) {
double scalAbsoluteTolerance = Math.pow(10.0, i);
assertTrue(handler.wasLastSeen());
if (re == null) {
public interface ExponentialDistribution extends ContinuousDistribution {
StatisticalSummaryValues t = null;
public void testLogBetaPositiveNegative() {
0.979430303349862, 1.20569696650138
return this.kurt;
double switchTime) {
polynoms[i] = new double[dimension];
"Scale must be positive.");
assertTrue(solver.getIterationCount() <= 11);
return functions.isEmpty();
protected int getDomainLowerBound(double p) {
int[] index = nextPermutation(len, k);
lastState = (double[]) state.clone();
throws java.lang.Exception {
double x2 = parameters[1].getEstimate();
return 0.0;
new Complex(-2.09497474683058, 1.91507575950825),
public void testStats() {	
assertTrue(MathUtils.equals(testArray[j], testArray[i]));
rki.reinitialize(equations, yTmp, yDotK, forward);
nSing = j;
for (int i = 0; i < a.length; i++) {
diagR[pk]        = alpha;
return new Mean(secondMoment).getResult();
setParamsAccuracy(5.0e-3);
Assert.assertEquals(msg, 0.0, x, relativeError);
mean = new double[] { 0.0, 1.0, -3.0, 2.3};
private double[] cumulativeTestValues;
return nf;
one = randomData.nextSample(hs,2);
public double getPct(long v) {
if (previousRejected) {
return new TestSuite(GraggBulirschStoerIntegratorTest.class);
public void testLogBetaPositiveZero() {
sum /= diag[pj];
double u3z  = u3.getZ();
double tmp4 = 2;
throws Exception{
int numberOfTrials, double probabilityOfSuccess) {
(SummaryStatistics) binStats.get(
public String getPattern() {
double[] values = { 1.0, 2.0, 3.0, 4.0 };
public static IntervalsList subtract(IntervalsList list1, IntervalsList list2) {
String hexString = randomData.nextHexString(3);
assertEquals(100, percentile.getQuantile(), 0);      
Complex A, B, C, D, E, F, z, f[] = new Complex[N];
public boolean hasNext();
double scaling_coefficient = Math.sqrt(2.0 / f.length);
assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);
public void testInverse()
class ArrayMapperEntry {
for (int j = 0; j < covariance.getColumnDimension(); ++j) {
data[row][0] = columnData[row];
lu[row][col] /= lu[col][col];
problems.add(new APSProblems12To14( -40, -9.0, 31.0, 0.0));
Object[] one = randomData.nextSample(hs,1);
this.heartrate = heartrate;
throws IllegalArgumentException;
index = findKnot(knots, x);
public double[] getInterpolatingPoints() {
stdDev = Math.sqrt(getVariance());
protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};
f[n - 1] = prod - 1;
UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);
MatrixUtils.createRowRealMatrix(new double[] {});  // empty
for (double x = -0.9; x < 0.9; x += 0.2) {
public class TestUtils  {
double f = c[ii][ij] - e * b[j][rank];
double[] roots22 = {
Assert.assertEquals(msg, actual, expected, relativeError);
assertTrue(Math.abs(b2.getElement(2) - 0.2) < 1.0e-10);
factory = new UnivariateRealSolverFactoryImpl();
this.n = n;
return (WeightedMeasurement[]) measurements.toArray(new WeightedMeasurement[measurements.size()]);
private void guessAOmega()
private RandomGenerator generator;
if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {
lmDir       = new double[cols];
i++;
public abstract int[] makeDensityTestPoints();
coeffs[i] = c;
public class VectorialValuedPair
protected double sumLog = 54.7969806116451507d;
if (n > 1) {
l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)));
assertTrue(Math.abs(sampler.samplePointAt(11).y[1] + 1.826) < 1.0e-10);
a[i] = r.a[i].doubleValue();
setResult(yMax, 0);
double evaluate(double[] values, int begin, int length);
assertTrue(sampler.size() == 12);
protected Object getProperty(Object bean, String name) throws Exception{
suite.setName("Mean  Tests");
double   x4 = parameters[3].getEstimate();
public void testEqualsImaginaryDifference() {
optimalIter = Math.min(k+1, sequence.length - 2);
("Invalid interval, initial value parameters:  lower=" + 
assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);
min.increment(value);
assertTrue(m.getColumns() == 3);
return tTest.tTest(sampleStats1, sampleStats2);
d.setElement(i, i, i + 1);
testStatistic.test(testArray, 0, -1);  // length negative
public EstimatedParameter[] getAllParameters() {
public ConvergenceException(String msg, Throwable rootCause) {
public void testQuinticZero() throws MathException {
suite.setName("UnivariateRealInterpolator Tests");
public void testTanNaN() {
public int eventOccurred(double t, double[] y) {
public void testParseProperInvalidMinus() {
double q0 = 0.0;
BigMatrix m = new BigMatrixImpl(id);
assertEquals(2.0, MathUtils.log(2,4), 0);
long value = 0;
private static final long serialVersionUID = -865524111506042509L;
double s          = oneMinusThetaH / 8.0;
value = randomData.nextLong(0,3);
public class BeanTransformerTest extends TestCase {
assertEquals(0.0, StatUtils.mean(sample), 0.07);
public static final RotationOrder XYX =
private static final double e2_06 =           3399327.0 / 763840.0;
for (int i = 0; i < k; i++) {
public void computeCoefficients(int mu, double h) {
m.multiply(new RealMatrixImpl(bigSingular));
yTmp = null;
new Interval(-12.0, 10.0), new Interval(-10.0, -10.0));
double pdDeterminant = determinant * determinant;
initialized = false;
double criterion = evaluateCriterion(problem);
return new TestSuite(PolynomialFractionTest.class);
subtractFromSelf((Interval) iterator.next());
this.y = (double[]) y.clone();
public void testTanhInf() {
double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));
public int getRank() {
return SwitchingFunction.RESET_STATE;
index = iMax;
for (j = 0; j < N; j += i<<1) {
public void testNextAfter() {
y1 = y2;
if (c == 0.0 && d == 0.0) {
public float getExpansionFactor() {
double criterion = 0;
certifiedValues.clear();
double value = a[n];
if ((q0 < -0.1) || (q0 > 0.1)) {
if (yInitial * yMax < 0) {
public static final int RESET_DERIVATIVES = 2;
public void testNewNewtonSolverNull() {
omega[i-1].getReal() * cost + omega[i-1].getImaginary() * sint,
public double getR() {
mu = empiricalDistribution.getSampleStats().getMean();
this.sigma = 0.5;
public int size() {
private double m5Det = 2700.0d;
public double[] getColumn(int col) throws MatrixIndexException {
if (fp <= 0.1 * delta) {
public void testRandom() {
double y = coefficients[coefficients.length - 1].getEstimate();
System.arraycopy(x, 0, this.x, 0, x.length);
public static Fraction getReducedFraction(int numerator, int denominator) {
return decompMatrix;
= (AbstractCurveFitter.FitMeasurement) measurements[i-1];
public class Max extends AbstractStorelessUnivariateStatistic {
public int getDimension() {
unscaled = Math.ceil(unscaled);
u.getPercentile(0);
BigDecimal[][] out = new BigDecimal[nRows][1]; 
throws EvaluationException;
for (int i = 0; i < dimension; ++i) {
TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    
if (maxDegree <= 4) {
checkValue(f, "4/13");
private int[] maxIndices;
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
long result = Math.round(binomialCoefficientDouble(n, k));
yDDotOnScale = Math.sqrt(yDDotOnScale) / h;
f = f1.add(f2); // should overflow
!TestUtils.tTest(sample1, sample2, 0.1));
public void testGetValues() {
polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);
suite.addTest(VectorialValuedPairTest.suite()); 
TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));
public Fraction parse(String source) throws ParseException {
while (j < r.begin) {
createPoissonDistribution(double lambda);
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
for (int i=0;i<d.length;i++) {
TestSuite suite = new TestSuite(StatUtilsTest.class);
Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);
TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);
rd2.reSeedSecure(2000);
new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});
return new TestSuite(IntervalTest.class);
long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };
observed[0]++;
public double cost(double[] x) throws CostException;
trace = trace.add(data[i][i]);
assertTrue(nbSteps < 520);
return new int[]{
double dev = 0.0d;
double coeff = Math.sqrt (u1u1 / v1v1);
checkMatrix(m3, new BilinearPattern(-99, 0.02));
checkLegendre(new Legendre(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7");
f = new RationalNumber(0l, 4l);
public double t(double mu, StatisticalSummary sampleStats)
public ComputableFunctionSampler(ComputableFunction function,
residuals[i] = Math.sqrt(wm.getWeight()) * residual;
int q1 = 1;
double[] expected = new double[16];
assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);
u.addObject("8.2");
double y[] = { -3.0, -6.0, 0.0 };
double fa;
public ListUnivariateImpl(List list, NumberTransformer transformer) {
test4[j] = (double) testi[j];
return Math.abs(h) * error1 / Math.sqrt(y0.length * den);
checkValue(new PolynomialFraction(-3l, 4l).add(new PolynomialFraction(4l, 5l)),
double r1 = 1.0 / (r0 - a0);
return new PolynomialFunction(p.getCoefficients());
double   x03 = parameters[2].getEstimate();
lowerData[i][j] = 1d;
private LinearMeasurement[] measurements;
public HighamHall54StepInterpolator() {
double preRed = coeff1 + 2 * coeff2;
PolynomialFraction f1 = new PolynomialFraction(4l, 6l);
x1 = x; x2 = x3;
throw new MathException(
sum = sum.add(data[row][col].abs());
Vector3D u = new Vector3D(3, 2, 1);
public void testGetSummary() {  
Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);
double[] yTmp = new double[y0.length];
return median;
b1 = null;
double[] p0Y = p0.y;
double v1y   = coeff * v1.getY();
0.591, 0.559, 0.597, 0.625, 0.739,
assertEquals(2, c.length);
UnivariateRealFunction f = i.interpolate(x, y);
super(16, startParams, theoreticalStartCost,
sum = sum - decomp[col][k]*decomp[row][k];
public void handleStep(StepInterpolator interpolator,
this.stepControl4 = 4.0;
return (x - 1.0) * Math.exp(-n * x) + Math.pow(x, n);
BigMatrix upper = new BigMatrixImpl(upperData);
if (s.length() > 0) {
assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);
public ComplexFormat(NumberFormat realFormat,
public double cumulativeProbability(double x) {
public CorrelatedRandomVectorGeneratorTest(String name) {
public UncorrelatedRandomVectorGenerator(double[] mean,
assertTrue(p1.getName().equals("p1"));
double absoluteAccuracy) throws ConvergenceException, 
BigDecimal[][] testDataPlus3 = 
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
public PercentileTest(String name) {
dx = 1.0 / div;
perm = randomData.nextPermutation(0,0);
si.setInterpolatedTime(time);
Rotation composed = r1.applyTo(r2.applyTo(r3));
for (int i = 0; i < hash.length; i++) {
< orderControl1 * costPerTimeUnit[targetIter])) {
return (EstimatedParameter[]) coefficients.clone();
this.ignored = ignored;
public static final Vector3D zero   = new Vector3D(0, 0, 0);
assertTrue(bos.size () > 34000);
StatisticalSummary sampleStats2)
boolean isSquare();
private LinearProblem buildProblem1() {
public void reset();
private Evaluation right;
min = -Math.PI/3; max = 0; expected = -0.5;
throws CostException, ConvergenceException, NotPositiveDefiniteMatrixException {
double d = MathUtils.cosh(a2) + Math.cos(b2);
- (dt1 * dt3 * d13) * iMed
result[i] = means[i].getResult();
A = Math.sin(i * Math.PI / N) * (f[i] + f[N-i]);
public SymetricalMatrix(SymetricalMatrix s) {
public double[] getDataArray() {
if (next >= function.size()) {
UnivariateStatistic stat = getUnivariateStatistic();
this.mean              = (double[]) mean.clone();
double[] state = interpolator.getInterpolatedState();
Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);
return (long)((r * upper) + ((1.0 - r) * lower) + r);
Complex z = new Complex(inf, 0);
private ComplexUtils() {
public double getMeanSquareError() {
if (normProduct < 1.0e-15) {
return DistributionFactory.newInstance();
ScalarValuedPair pair = new ScalarValuedPair(1.2, -8.4);
tstDoubleGen(5);           
assertEquals(2L, f.getCumFreq('b'));
checkVector(r.applyTo(Vector3D.plusJ),
if (good)  {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
double actual = Erf.erf(0.0);
TestUtils.tTest(sampleStats1, sampleStats2, .95);
TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);
return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};
if (hexString.length() != 1) {
public int getStateDimension();
0.840666673867645,
sum += f.value(x);
private static final long serialVersionUID = 5647178478658937642L;
private double[] coeffs;
if (contractedCost < originalCost) {
assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;
public void testTanNull() {
testStatistic.t(mu, observed), 10E-10);
u.addValue(4d);
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
r += ((PointModel) iterator.next()).getCenterDistance();
private final double sum;
case GAUSSIAN_MODE: return getNextGaussian();
Complex z = x.divide(Complex.NaN);
assertTrue(map.transformers().contains(expected));
public interface StepInterpolator
BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);
public static final int HIGH = 2;
private static final long serialVersionUID = 1356097180027801200L;
double tolerance = Math.max(relativeAccuracy * z.abs(),
roots2To11[k++]));
checkValue(new PolynomialFraction(1l, 6l).subtract(new PolynomialFraction(2l, 6l)),
"-2.0 x + 3.0 x^2");
return relativeAccuracy;
m1.setElementAndSymetricalElement(i, j, -1.0);
return lastTime;
return new RealMatrixImpl(lu);
value = new Double(d);
implements TDistribution, Serializable  {
MatrixUtils.createColumnRealMatrix(new double[] {});  // empty
protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };
assertClose("inverse-operate",mInv.operate(testVector),
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),
private static class LinearProblem {
double a3, Vector3D u3, double a4, Vector3D u4) {
0.196513862833975, 0.0593032355046727,
assertEquals(m, m);
private double  maxStep;
protected abstract double[] getResiduals();
ret = format( new Complex(((Number)obj).doubleValue(), 0.0),
if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {
protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};
fail("Expecting ClassCastException");
tc[j] = c[j+1] + tc[j+1] * x[i];
double dy = py - cy.getEstimate();
0.633661261602859, 0.599428560991695,
Double.NaN};
public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {
throw new ConvergenceException();
assertEquals(0, new Polynomial.Double(0.0, 0.0, 5.0).getDegree());
public void testLog() {
outBuffer.append("kurtosis: " + getKurtosis() + "\n");
for (int row = col + 1; row < nRows; row++) {
this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;
public final class FastCosineTransformerTest extends TestCase {
if (Math.abs(oldDelta) <
f2 = Fraction.ONE;
private static final double e1_06 =          -1871647.0 / 1527680.0;
public MeyerFunction(double[] startParams,
z = 2.0; expected = -1.0; result = p.value(z);
public static SummaryStatistics newInstance() {
public double[] getResult() {
target = nextInt(0, i);
int i = Arrays.binarySearch(knots, v);
double trace = data[0][0];
secRand = SecureRandom.getInstance(algorithm, provider);
String stack2 = baos2.toString();
expectedValue(),
double absTolerance   = 1.0e-8;
String expected = "(NaN) + (NaN)i";
assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",
long[] observed2 = {15, 10, 10, 15, 5};    
TestSuite suite = new TestSuite(SplineInterpolatorTest.class);
public double getPartialDiX() {
double getScale();
fo = new FileOutputStream(tmp);
int n = sample1.length;
protected double[] getCumulativeTestPoints() {
Complex z = x.add(y);
suite.addTest(org.spaceroots.mantissa.roots.AllTests.suite()); 
for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {
fail("permutation k > n, expecting IllegalArgumentException");
public synchronized int getWindowSize() {
sum = new double[iter.getDimension()];
internalData = new double [size];
for (int i = 1; i< binCount - 1; i++) {
.doubleValue();
public Rotation applyTo(Rotation r) {
Math.log((double) binomialCoefficient(n, k)), 
return toAppendTo;
public void testScalarAdd() {
public void testNextSecureHex() {
PointCostPair optimum =
public AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
double u1u1 = Vector3D.dotProduct(u1, u1);
public void intersectSelf(IntervalsList list) {
for (int i = 0; i < testArray.length; i++){
int[] out = new int[permutation.length];
private static double k15_10 =                 0.0                       - b_10;
checkContractExpand(contractionCriteria, getExpansionFactor());
Polynomial.Rational b = q;
+ " does not match",
regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
boolean forward, int order, double[] scale,
DifferentiableUnivariateRealFunction f = new QuinticFunction();
properFormat.parse(source);
MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);
verifyQuantiles();
a.setElement(1, 1,  1.0);
if (theoreticalMinParams != null) {
sumSq += (dev * dev) / (obs1 + obs2);
int[] n27 = {
x = new double[] {two};
private static double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
statistic2.clear();
public boolean isBiasCorrected() {
ck     = (RationalNumber) l.get(startK + i);
-Math.asin(v2.getZ()),
public void setWholeFormat(NumberFormat format) {
public synchronized void setWindowSize(int windowSize) {
this.dimension2 = dimension2;
assertEquals(0, random.nextLong());
public double[][] getData() {
public double getPartialRadiusY() {
assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);
y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);
f = f.add(f);
TestUtils.chiSquare(unMatchedEx, unMatchedObs);
this(new Polynomial.Rational(numerator),
if (switchesHandler.reset(currentT, y) && ! lastStep) {
public void testPolar2ComplexNaN() {
throw new RuntimeException("unexpected DerivativeException caught: "
private double mean;
extends WeightedMeasurement {
begin         = range [0];
Polynomial.Rational newQ = q.multiply(f.p);
double xbar = u.getMean();
factory.newGraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);
testStatistic.homoscedasticTTest(sample1, sample2, 0.49));
this.useInterpolationError = useInterpolationError;
BigMatrix inverse() throws InvalidMatrixException;
return percentile.evaluate(values, begin, length, p);
return new TestSuite(LegendreTest.class);
filePointer = null;
rootCause.printStackTrace(out);
private static double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
return new TestSuite(AbstractCurveFitterTest.class);
fail("Calculating determinant of missing matrix should fail"); 
private IntegerDistribution distribution;
double h;
double  h         = (t - t0) / nbStep;
assertEquals(values[i], x, epsilon);
0.999999999999121
m [2][0] = 2.0 * (q1q3 + q0q2);
public static double angle(Vector3D v1, Vector3D v2) {
permutations[k]    = permutations[jMax];
assertTrue(p1.add(p2).isZero());
assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));
this.scalRelativeTolerance = 0;
public interface TTest {
String nextHexString(int len);
index2 -= bCols;
guesser.guess();
public abstract Polynomial multiply(long l);
sum[i] = 0.0;
matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),
buildSimplex(vertexA, vertexB);
super(translate(specifier, parts));
sum [i] += cP * pY[i] + cC * cY[i] + cN * nY[i];
assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);
private double[] beta;
new LinearMeasurement(new double[] {  1.0, 1.0 },
double xx = 39.0;
min = -0.9; max = -0.2; expected = -0.5;
Math.max(i1.getSup(), i2.getSup())));
return new Complex(real/c, imaginary/c);
u.addValue( testArray[i]);
return new TestProblem4(this);
for (int i=0;i<nrows;i++) {
double nextTime;
public static final double[][] asDouble(BigDecimal[][] data) {
private double costRelativeTolerance;
return y[0];
TestUtils.assertEquals(Complex.I.negate(), 
Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 0);
Integer.MAX_VALUE ) ;
defaultTransformer = new DefaultTransformer();
q0 *= inv;
double mu = Math.random();
this.binCount = binCount;
TestUtils.assertEquals(two, StatUtils.product(x), tolerance);
assertTrue(new Chebyshev().isOne());
double  sup          = Double.NaN;
if (Math.abs(real) < Math.abs(imaginary)) {
public void testNextAfterSpecialCases() {
public void testCertifiedValues() {
simplex[i] = new PointCostPair(generator.nextVector(), Double.NaN);
return Math.max(0, m - (n - k));
private static final double a70 =    35.0 /  384.0;
p.value(0.0);
ComplexUtils.sinh(null); 
linearEstimate(problem);
m.getColumnMatrix(4);
TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);
double getShape();
descriptives.addValue(value);
diag[k-j-1][i] = diag[k-j][i]
public BasicSampledFunctionIteratorTest(String name) {
public void testFormat() {
package org.apache.commons.math.stat.univariate;
public EstimatedParameter(EstimatedParameter parameter) {
checkVector(r.getAxis(), new Vector3D(0, 0, -1));
abstract public double[] computeTheoreticalState(double t);
new LinearMeasurement(new double[] { 1.0, 1.0 },
for (int j = i; j < m.getColumns(); ++j) {
Polynomial.Rational Hk2g2 = Hk2.multiply(g2);
public DormandPrince54StepInterpolator() {
testGetDeterminant(m5, m5Det, "Calculating determinant of m5");
return tTest.t(sampleStats1, sampleStats2);
private static final long serialVersionUID = 4763990447117157611L;
int test = 10;
TestUtils.checkSerializedEquality(u); 
private int threeI=3;
super(false, c, a, b, new EulerStepInterpolator(), step);
return new GeometricMean();
u = -t;
"matrice non d\u00e9finie positive" }
loaded = true;
4.0)
double re = complex.getReal();
1.1330366534715,
assertTrue("empty instances should be equal", t.equals(u));
public void testMean() {
R = new QRDecompositionImpl(matrix).getR();
v4 = null;
int index = 0;
assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
assertEquals("sum",sum,u2.getSum(),tolerance);
if (object instanceof RealMatrixImpl == false) {
new BigMatrixImpl(colMatrix));
int numberOfSuccesses, double probabilityOfSuccess) {
throw new IllegalArgumentException
double x[] = { 1.0, 2.0, 3.0, 4.0 };
new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },
private static final long serialVersionUID = -5593383832225844641L;    
assertTrue(iter.hasNext());
private double min = 1;
6433.12578950026, 0.0478295939096951,
m.getRowMatrix(-1);
m1 = 0.0;
double previousCost = cost;
fail("Expecting IllegalArgumentException for sd = 0");
ArrayList unbound = new ArrayList(parameters.size());
boolean isSingular();
sum += Math.abs(data[row][col]);
if (x.length < 1) {
suite.addTest(LowerTriangularMatrixTest.suite()); 
private MappableScalar scalar1;
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
return (a.length == 1) && a[0].isOne();
double result[], tolerance = 1E-12;
this.minimalIterationCount = defaultMinimalIterationCount;
double[] xE = new double[n];
public double[] inversetransform2(
assertTrue(bos.size () > 119500);
if (minima[0] == null) {
y0[1] = omega * Math.cos(omega * t0);
equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);
if (n > 0) {
double actual = getDistribution().cumulativeProbability(0.25, 0.75);
StatisticalSummary summary = s.getSummary();
public void testNextDigest() throws Exception{
if (hexString.length() != 100) {
public void add(VectorialSampleStatistics s) {
sum += a[k-1][l] * yDotK[l][j];
a = new RationalNumber[] { a0 };
PointCostPair smallest = simplex[0];
for (int index = i * (columns + 1); index < (i + 1) * columns; ++index) {
TestUtils.tTest(sample1, sample2), 1E-10);
public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {
scale = standardDeviation[i] * standardDeviation[j];
private double parRelativeTolerance;
public class UncorrelatedRandomVectorGenerator
throw new IllegalStateException("Digest not initialized");
package org.spaceroots.mantissa.quadrature.vectorial;
private double innerCumulativeProbability(
return bound;
return ((DefaultValue)argument.evaluate(this)).intValue();
WeightedMeasurement[] measurements = problem.getMeasurements();
this.left = left;
maxError = Math.max(4 * error, 1.0);
z = f[i+j+k].multiply(omega[k*m]);
regression.getRegressionSumSquares(), 10E-9);
while (n < maxIterations && relativeError > epsilon) {
public double[] getRow(int row) throws MatrixIndexException {
public RealMatrix getResult() {
assertEquals("probability for " + x, expected, actual, 10e-4);
double[] elementArray = new double[numElements];
lcm = lcm.multiply(newCoeff.getDenominator());
assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);
m = new BigMatrixImpl(detData2);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
-0.660266001396382e-8, 1.00000164411833,
12088.127069307, 0.00118311459212513,
testStatistic.chiSquareTest(expected, observed, .01);
if (yMin * yMax >= 0) {
double[] vecRelativeTolerance);
+ ", state vector has dimension {1}",
public static SummaryStatistics newInstance(Class cls) throws 
checkPolynomial(p2, "x^" + i);
String line = null;
double actual = distribution.cumulativeProbability(x);
FirstOrderIntegratorFactory factory = null;
assertEquals("hash code", u.hashCode(), t.hashCode());
new BufferedReader(new InputStreamReader(
assertFalse(x.equals(null));
public FirstMomentTest(String name) {
void setNumberOfTrials(int trials);
double E = t;
testSolve(m3, "Solving matrix m3");
binStats.add(i,stats);
if ( !isValidCoordinate(0, col) ) {
m.getSubMatrix(new int[] {}, new int[] {0});
int index2 = (bRows - 1) * bCols + j;
public ChiSquaredDistribution createChiSquareDistribution(
ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);
public boolean chiSquareTest(long[][] counts, double alpha)
private long threeL = 3;
var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
UnivariateRealSolver solver = new RiddersSolver(f);
return rand;
super(d);
public class ArrayMapper {
double actual = Erf.erf(x);
index = low;
t = qtrap.stage(min, max, i);
if (pos < 1) {
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));
fail("Expecting IllegalArgumentException for alpha = 0");
DescriptiveStatistics u = new ListUnivariateImpl( list );
private static final long serialVersionUID = -2136672307739067002L;
Q[minor][minor]=1;
public void testCircleFittingBadInit() throws EstimationException {
assertTrue(Double.isNaN(sumSq.getResult()));
if (vecAbsoluteTolerance == null) {
z = 6.0; expected = 5.0; result = p.value(z);
public PoissonDistribution  createPoissonDistribution(double lambda) {
bd[i] = new BigDecimal(v[i]);
result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);
MathUtils.factorialLog(i),10E-12);
return (TestProblem[]) problems.toArray(new TestProblem[problems.size()]);
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);
private static class Osborne1Function extends MinpackFunction {
System.arraycopy(a, 0, this.a, 0, i + 1);
return ForwardDifferenceDerivative.decorate(function, delta);
MathUtils.binomialCoefficient(5,i));
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
v1 = new double[interpolatedState.length];
public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {
for (int i = 0; i < factors.length; ++i) {
handler = DummyStepHandler.getInstance();
setLastSeen(false);
public void setMaximalIterationCount(int count) {
assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);
public double solve(double min, double max, double startValue)
checkPolynomial(p1, "-x");
public class PascalDistributionImpl extends AbstractIntegerDistribution
protected void iterateSimplex()
f.addValue(1);
assertTrue(message, 
for (int index = kDiag; index < jacobian.length; index += cols) {
minIndices = new int[dimension];
public void testCumulativeProbabilityExtremes() throws Exception {
assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
public LowerTriangularMatrix(int order) {
assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());
convergence, epsilon));
return (double[]) internalArray.clone();
double x0 = min;
da.addElement(5);
+ " state vector has dimension {1}",
TestUtils.checkSerializedEquality(u);
public MatrixFactoryTest(String name) {
u.addValue(two);
TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));
NumberFormat numeratorFormat,
result = count.longValue();
(a[a.length - 1].isNegative())
public List getIntervals() {
SummaryStatistics instance = null;
if (x[0] < 0) {
checkValue(m.getWeight(), 3.0);
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);
assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));
return new TestSuite(MultiDirectionalTest.class);
return Locale.FRENCH;
throw new MatrixIndexException("matrix entry does not exist");
public void checkMatrix(Matrix d, double value) {
f = f.multiply(new RationalNumber(9l,4l));
next          = 0;
checkValue(t, pb.getInitialTime());
StatUtils.varianceDifference(single, single, meanDifference);
integ.setStepHandler(DummyStepHandler.getInstance());
"singular matrix" },
"too small integration interval: length = {0}" },
testStatistic.chiSquareTest(counts), 1E-9);       
public Osborne2Function(double[] startParams,
private boolean fireException = false;
return new SumOfSquares();
int x1 = getDomainUpperBound(p);
return new VectorialValuedPair(next.x, (double[]) sum.clone());
this((double) a2, (double) a1, (double) a0);
public void testNegateNaN() {
double t0, double[] y0, double[] yDot0,
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
double dx = px - cx.getEstimate();
return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / d);
int location = locatePoint(time, si);
public static void assertRelativelyEquals(String msg, double expected,
BigDecimal sum = ZERO;
return cumulativeProbability(x) - p;
public long getCount(Object v) {
for (int index = i * b.columns + range.begin;
double f0  = d - f2;
protected double median = 12d;
new Double(a), new Double(b), new Double(fa), new Double(fb) });
assertTrue(Math.abs(d20) < 6.0e-6);
int i, j, n, nearest = 0;
return new Kurtosis();
assertEquals("slope std err", 0.011448491,
return prod.evaluate(values);
protected static double[] differentiate(double[] coefficients) {
forward     = model.forward;
assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);
covariance = new RealMatrixImpl(mean.length, mean.length);
checkPolynomial(new Polynomial.Rational(3l,  2l, 1l), "1 + 2 x + 3 x^2");
if (a[i].isNegative()) {
d2v = d2v.multiply(new Complex(2.0, 0.0));
double[] expected = {100,100,100,100,100,100,100,100,100,100};
private static final long serialVersionUID = 4019938025047800455L;
Sum sum = new Sum();
"24 - 96 x + 72 x^2 - 16 x^3 + x^4");
throw new MathException(ex);
private static final long serialVersionUID = 1884346552569300794L;
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
assertTrue(solver.getIterationCount() <= 9);
assertEquals("3x4 Q'Q = I", 0, norm, normTolerance);
next      = measurements[nextIndex++];
minpackTest(new LinearRank1Function(50, 5, 1.0,
m.getRowMatrix(0));
BigMatrix scalarAdd(BigDecimal d);
double[] resultData = new double[bRows * bCols];
public abstract class TestProblem implements ComputableFunction {
a = new RationalNumber[degree + 1];
public void testNewInstanceClassValid() {
private double[] jacNorm;
ComplexUtils.asin(null); 
-Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0) },
return new Double();
assertTrue(referenceCallsCount >= 13);
public class SingularMatrixException
private double switchTime;
callsCount = 0;
assertEquals(1.23, MathUtils.round(x, 2), 0.0);
0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d, 
p = new PolynomialFunctionNewtonForm(a, c);
public double getY() {
b.setElement(1, 0, 10.26);
for( int i = 0; i < iterations; i++) {
suite.setName("CholeskySolver Tests");
findBinomialLimits();
0.62380651896161));
double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2); 
suite.addTest(HarmonicFitterTest.suite());
new Interval[] { new Interval(-10.0, -8.0),
double maxElt = Math.abs(work[permutations[k] * columns + k]);
public final int begin;
protected void setTolerance(double tolerance) {
double[] sorted = u.getSortedValues();
System.arraycopy(coefficients,0, out, 0, coefficients.length);
lmPar = Math.max(2.2251e-308, 0.001 * paru);
while (j < r.end) {
currentState      = y;
private double knots[];
public Polynomial getDerivative() {
0.9772499, 0.9986501, 0.9999683,  0.9999997});
simplex[n] = pointCostPair;
private double expectedRoot;
for (int j = 0; j < b.getColumnDimension(); ++j) {
public class UnivariateRealFunctionUtils {
for (int l = 0; l < parameters.length; ++l) {
assertEquals(0.0, optimum.cost, 2.0e-4);
double n = (double) moment.n;
return this.skew;
double[] centroid = new double[n];
interpolator = new DummyStepInterpolator(yTmp, forward);
if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {
s.setElement(i, j, 0.5);
if (unscaled != Math.floor(unscaled)) {
hNew = filterStep(h * factor, false);
double s, olds, t, oldt;
double[] y = new double[2];
assertNotSame(nf, cf.getRealFormat());
RealMatrix m = new RealMatrixImpl(subTestData);
if (f.value(initial) == 0.0) { return initial; }
FirstOrderIntegrator integ = new MidpointIntegrator(step);
if ((startIndex + (numElements + 1)) > internalArray.length) {
for (int j = 1; j < k; ++j) {
Complex c = new Complex(1.23, 1.43);
return (internalArray.length / ((float) numElements)) > contractionCriteria;
double fourTheta = 4 * theta;
public abstract double pairedTTest(double[] sample1, double[] sample2)
RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;
a.setElement(2, 0,   4.0);
new Interval[] { new Interval( -0.9, -0.8),
protected final double[] data;
public double[] solve(double[] c) 
p1 = -p1;
throw new IllegalArgumentException("Function is not polynomial.");
return new NormalDistributionImpl();
public Median() {
derivativePolynomials[i] = polynomials[i].polynomialDerivative();
public double nextExponential(double mean)  {
RationalNumber fInverse = f.invert();
public void testLogInf() {
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
while (line != null) {
private static class RosenbrockFunction extends MinpackFunction {
covData[i][j] = s;
sample.length);
public void setIgnored(boolean ignored) {
return Double.MIN_VALUE;
assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);   
public Complex[] inversetransform2(Complex f[]) throws MathException,
a.setElement(2, 0, -3.0);
double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);
public void testSinNull() {
-0.232991922761641,  1.26043292929555,
public void testCreateRowRealMatrix() {
double dminus = B - Math.sqrt(delta);
assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);
case BigDecimal.ROUND_UP :
new Vector3D(m3[0][1], m3[1][1], m3[2][1]));
private VectorialValuedPair next;
d[j] = td * w;
public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {
return sampleSize;
public BigMatrix scalarAdd(BigDecimal d) {
public static BigMatrix createBigMatrix(BigDecimal[][] data) {
double[] test3 = {1};
double data[] = sample(f, min, max, n);
n         = (int) Math.floor((range[1] - range[0]) / step);
protected double functionValueAccuracy;
g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];
public RetryTestCase(String arg0) {
public class Complex implements Serializable  {
finalized         = false;
return m3;
private Number parseNumber(String source, double value, ParsePosition pos) {
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
4.1335913915954e-5, 4.0002497338020e-5, 3.8752419296207e-5,
public void setTemperature(Double temperature) {
Integer.toString(i - 1)
double scalRelativeTolerance = 1.0e-15;
min = -20.0; max = 10.0; expected = 0.0;
assertEquals(-4.0, c[0], tolerance);
GeneralSquareMatrix a = new GeneralSquareMatrix(4);
meanStat.increment(v);
absTolerance, relTolerance);
++order;
return variance.isBiasCorrected();
Math.sqrt ((35.0 - 2.0 * Math.sqrt (70.0)) / 63.0) },
fail("Solving matrix m6"); 
if (a != 0.0) {
BilinearPattern pattern) {
Fraction.getReducedFraction(1, 0);
PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();
public EstimatedParameter(String name, double firstEstimate) {
throw new ArithmeticException("divide by zero");
if (in instanceof BufferedReader) {
G = dv.divide(pv);
return null; // gulp FIXME? -- this *should* never fail.
checkValue(new PolynomialFraction(307692l, 999999l), "4/13");
public static Matrix buildMatrix(int rows, int columns, double[] data) {
m.transpose().inverse(),normTolerance);
UniformRandomGenerator urg = new UniformRandomGenerator(rg);
Matrix m3 = m1.add(m2);
assertTrue(Math.abs(a2[0] - 0.4) < 1.0e-10);
return SQRT3 * (2 * generator.nextDouble() - 1.0);
assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);
"Abscisse {0} dupliqu\u00e9e aux indices {1} et {2}" },
public void testAcosNull() {
public final class MullerSolverTest extends TestCase {
private double max = 3;
public DormandPrince853StepInterpolatorTest(String name) {
return solver.solve(x0, x1);
new CholeskySolver();
public boolean homoscedasticTTest(double[] sample1, double[] sample2,
public void testSetAlpha() {
fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02
values[1] = -2.0 * x;
protected void computeInterpolatedState(double theta,
protected void setCumulativeTestValues(double[] cumulativeTestValues) {
s = v1 * v1 + v2 * v2;
int callsWithoutDenseOutput = pb1.getCalls();
suite.setName("Min  Tests");
if (curr.x < prec.x) {
public class MidpointStepInterpolatorTest
|| (nextAction == SwitchingFunction.RESET_DERIVATIVES);
steps.add(ai.clone());
while (p < 1.0) {
this.numerator = a0;
for (int i = 0; i < m; ++i) {
FirstOrderIntegratorFactory {
public class GaussLegendreIntegrator
for (int j = 0; j < 3; ++j) {
Rotation r3 = r2.applyTo(r1);
v1.incrementAll(values);
private static final long serialVersionUID = 2401296428283614780L;
return apply(new Variance());
if ((mudif <= 0) || (mudif >= 7)) {
"impossible de trouver une premi\u00e8re estim\u00e9e" },
max[i]        = s.max[i];
PolynomialFraction inverse =
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
this.n = knots.length -1;
double ratio = ((double) sequence [k] * sequence[k+1])
while (j < maxJ) {
public double nextGaussian(double mu, double sigma) {
double expected = 10.06766;
this.minStep = minStep;
buf.append(separator);
this.orderControl2 = 0.9;
public TTestImpl(TDistribution t) {
for (int i = 0; i < n; ++i) {
public class BeanListUnivariateImpl extends ListUnivariateImpl implements Serializable {
fail("not positive definite matrix");
return getPct(new Character(v));         
while (bytesOut < bytes.length) {
public void testLogBetaNegativePositive() {
suite.setName("Max  Tests");
public static Complex polar2Complex(double r, double theta) {
"aucun des {0} points de d\u00e9part n''aboutit \u00e0 une convergence"  }
DataAdapter da = aFactory.getAdapter(in);
0.27550804099948,   0.13775402049974,   1.0305283778156e-2,
r = new Rotation(m2, 1.0e-12);
assertEquals(0, new Polynomial.Rational(5l).getDegree());
Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0) }
dist.setMean(10.0);
public abstract AdaptiveStepsizeIntegrator newDefaultAdaptiveStepsizeIntegrator(
int order = covariance.getRowDimension();
0.191262653354071,
BigDecimal.ROUND_DOWN), 0.0);
assertEquals(expected, m);   
real * rhs.imaginary + imaginary * rhs.real);
public void testCircleFitting() throws EstimationException {
("permutation k must be > 0");
delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing
public void testCosh() {
"observed counts cannot all be 0"); 
assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);
result = solver.solve(min, max);
if (dk == 0) {
public interface EvaluationContext {
private static final long serialVersionUID = 4696264881688589546L;
public Complex[] solveAll(Complex coefficients[], Complex initial) throws
eDA.discardFrontElements(eDA.getNumElements() - windowSize);
l.add(a00);
public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{
throw new IllegalArgumentException("cannot add a "
suite.addTest(org.spaceroots.mantissa.functions.scalar.AllTests.suite()); 
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private static Percentile percentile = new Percentile();
int maxIter, int maxChecks,
safety * Math.pow(error, exp)));
public abstract int getSampleSize();
double alpha, double beta)
private TreeMap freqTable = null;
15.50731, 13.36157};
double lmNorm = 0;
format.setWholeFormat(old);
equations.computeDerivatives(t, yEnd, f[1]);
sumSq += values[i] * values[i];
coefficients[2].setEstimate(guesser.getPhi());
if (a[0].isZero()) {
F1 += C;
r = fb / fc;
lmPar *= 0.5;
assertEquals(n + " choose " + k,
if (q.getDegree() == 0) {
sum2[k++] = x[i] * x[j];
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
public int getIterationCount() {
assertTrue("two sample homoscedastic t-test reject", 
private static final long serialVersionUID = -370076995648386763L;    
public Skewness() {
MathUtils.factorialLog(-1);
assertEquals("nonsingular  R test 2",-1d,m.getDeterminant(),normTolerance);
double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);
if (n == -1) {
PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);
public void test1PercentError()
setDistribution(new BinomialDistributionImpl(5,0.0d));
assertEquals(a, MathUtils.gcd(-a,  0));
assertEquals(7, f.getDenominator());
double p0 = 1.0;
double vi = parameters[i].getEstimate();
double y[] = { 172.0, -105.096569476353, 27.3137084989848,
public boolean isEmpty() {
double s = work1[permutation[j]];
assertEquals(inf, z.imaginary, 0);
TestUtils.assertEquals(two, StatUtils.min(x), tolerance);
double[] array = new double[n];
long result = 1;
Rotation r = new Rotation(u1, u2, v1, v2);
Beta.regularizedBeta(
boolean firstTime = true;
double cosE = Math.cos(E);
SecureRandom secRan = getSecRan();
StatUtils.sumLog(x, 0, 4);
return Double.NEGATIVE_INFINITY;
NonNullRange second) {
checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),
this.inverseCumulativeTestValues = inverseCumulativeTestValues;
sequence[k] = 4 * k + 2;
assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);
private double mean = 0;
for (int k = 0; k < interpolator.yDotK.length; ++k) {
u.addValue(5d);
public abstract double[] makeInverseCumulativeTestPoints();
testLogBeta(-0.693147180559945, 1.0, 2.0);
new PolynomialFunction(new double[] {4d, 1d, 1d})
assertEquals("5 / 3", actual);
BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;
q1 = composed.q1;
public double evaluate(final double[] values, final double mean,
extends AbstractCurveFitter {
secondMoment = new SecondMoment();
variance = new Variance(m2);
assertEquals((RealMatrixImpl) MatrixUtils.createColumnRealMatrix(col),
public double nextNormalizedDouble() {
"1/20");
ArrayMapperEntry entry = (ArrayMapperEntry) iter.next();
assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));
double x11 = parameters[10].getEstimate();
- dist.normalApproximateProbability(9899);
public double getDenominatorDegreesOfFreedom() {
throw new IllegalArgumentException("matrix is not square");
if (Math.abs(max - min) <= absoluteAccuracy) {
assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);
return Locale.US;
for (int i = 1; i < this.getRowDimension(); i++) {
double minStep = 0;
return randomData.nextUniform(0, 2 * mu);
jacobian    = new double[rows * cols];
norm2 += aki * aki;
-11.5902596937374, 13.2020628854665,
Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
testStatistic.tTest(mu, observed), 10E-10);
estimator.estimate(circle);
nearest = i;
double corr11 = o[1][1] - m[1][1];
max.increment(testArray[0]);
return BackwardDifferenceDerivative.decorate(function, delta);
double[] testArray = da.getElements();
assertTrue(Math.abs(d22) < 6.0e-6);
public GillStepInterpolatorTest(String name) {
check(list1, list2, 2.5,
public void testEqualsClass() {
minpackTest(new ChebyquadFunction(8, 8, 1.0,
standardDeviation = null;
assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
RationalNumber b4k) {
contract();
2 * targetIter + 1, scale,
private double maxStep;
return new HighamHall54StepInterpolator(this);
public MappableArrayTest(String name) {
+ e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j]
public NonNullRange getRangeForRow(int i) {
"The testArray values should equal the controlArray values, index i: "
public synchronized double[] getValues() {
protected FirstMoment moment;
public IntegerDistributionAbstractTest(String name) {
14.1,
public boolean isOne() {
assertEquals(expected, solver.getMaximalIterationCount());
assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);     
double x = begin + i * step;
if (v > 0) {
testStatistic.chiSquare(expected,observed) < 10.828);    
MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged
midPoint += step;
String expected = "1 + 1j";
double numeratorDegreesOfFreedom,
new EstimatedParameter[] { p[4], p[3] },
return tTest.tTest(sample1, sample2, alpha);
double[] roots21 = {
assertTrue(mapper.getDataArray().length == 9);
package org.apache.commons.math.analysis.derivative;
NonNullRange r3 = NonNullRange.reunion(r1, r2);
public void testOperate() {
return getPartialDiX() - getPartialRadiusX();
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
byte[] bytes = new byte[] {0};
implements EstimationProblem, Serializable {
"pas de convergence apr\u00e8s {0} it\u00e9rations" },
double sx2 = 0.0;
double theta = 0;
List    newIntervals = new ArrayList();
void addElement(double value);
EulerIntegrator integ = new EulerIntegrator(step);
double initialCost = estimator.getRMS(problem);
double r = rand.nextDouble();
suite.addTest(UniformRandomGeneratorTest.suite()); 
public RationalNumber multiply(RationalNumber r) {
assertEquals("3x3 Q size", qr.getQ().getColumnDimension(), 3);
data[index] = value;
"imaginaryCharacter must be a non-empty string.");
FractionFormat improperFormat = null;
Complex expected = new Complex(1, 1);
testDa.addElement(3d); // x,x,x,0 -- expanded
q = Polynomial.Rational.euclidianDivision(q, b).quotient;
public static double sum(final double[] values, final int begin, 
f.addValue('d');
public void setUp() {     
public void testIgnored() {
5.98642305066196, -4.0, 2.67271455167720,
if ((sequence == null) || (sequence.length != size)) {
double scalRelativeTolerance = 6.0e-4;
checkPolynomial(p2, "5 x");
if (qString.indexOf(' ') > 0) {
(double) sampleStats1.getN(), (double) sampleStats2.getN());
232921.0, 437665.75
public interface Evaluation {
protected void verifyInverseCumulativeProbabilities() throws Exception {
assertTrue(solver.getIterationCount() <= 15);
checkVector(u, r.applyInverseTo(r.applyTo(u)));
System.arraycopy(c, 0, out, 0, c.length);
MaxIterationsExceededException, FunctionEvaluationException {
public interface FirstOrderDifferentialEquations {
u.addValue(three);
2.015048, 1.475884};
double betak = 1.0 / (ak2 - akk * alpha);
double[][] c = covariance.getData();
public APSProblem26(double a, double b, double expectedRoot) {
public void testConjugateNaN() {
statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();
public double getValue () {
(Math.abs(z.getImaginary()) <= tolerance ||
public Complex negate() {
public ComplexPattern(int p) {
0.990d, 0.975d, 0.950d, 0.900d, 1};     
e = problem.e;
protected double homoscedasticT(double m1, double m2,  double v1,
double u1u2   = Vector3D.dotProduct(u1, u2);
public void testEuclidianDivision() {
int bCols  = b.getColumns();
for (int i = 0; i < s.getRows(); ++i) {
return Math.log(x)/Math.log(base);
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
public class TDistributionTest extends ContinuousDistributionAbstractTest {
FastCosineTransformer transformer = new FastCosineTransformer();
assertEquals("spline function evaluation failed for knot=" + knots[i],
value = testGenerator.nextInt(4);
0.0, 0.099, 11);
array3 = null;
double u = rand.nextDouble();
addValue(new Long(v.longValue()));
observed1, observed2), 1E-6);
fail("Expecting IllegalArgumentException - bad function");
private static UnivariateStatistic mean = new Mean();
14.5,
0.0221227011813076
assertTrue(count < 150);
source = "1 / -2";
fail(e.getMessage());
if (! vectorsInitialized) {
if (s == 0) {
String msg = "message";
double[][] out = new double[1][ncols]; 
Polynomial.Rational Tk1g1 = Tk1.multiply(g1);
private double getNextUniform() {
if (!reject) {
private Complex nanNegInf = new Complex(nan, negInf);
return tTest.t(mu, observed);
int n = 0;
setGamma(g);
r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),
implements PascalDistribution, Serializable {
public ThreeEighthesStepInterpolator() {
fail("permutation k = n = 0, expecting IllegalArgumentException");
Matrix x = s.solve(b, 1.0e-10);
data    = new double[rows * columns];
for (int j =0; j < m.getColumnDimension(); j++) {
public abstract FDistribution createFDistribution(
return m4;
public SecantSolver(UnivariateRealFunction f) {
public class BackwardDifferenceDerivative extends AbstractDifferenceDerivative {
x1 = x0 - (f.value(x0) / derivative.value(x0));
return new DormandPrince54StepInterpolator(this);
for (boolean loop = true; loop;) {
fail("negative population size.  IllegalArgumentException expected");
lowerData[i][j] = new BigDecimal(1);
return ret;
137909.0/3084480.0,
lowerData[index]   = 0.0;
suite.addTest(ComputableFunctionSamplerTest.suite()); 
if (l.signum() == 0) {
dx1 * dy2 - dy1 * dx2);
Method meth = bean.getClass().getMethod(prop, new Class[0]);
expected = new Complex(0.0, -2.0);
public Bounce() {
if (p == 0) {
return new ArrayDataAdapter(inputArray);
new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },
assertNull(ex.getMessage(Locale.FRENCH));
p2.setEstimate(oldP2);
return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};
u.setElement(3, 3, 0.0);
assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.5) < 1.0e-10);
check(list1, list2, -1.1,
Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial
public abstract Evaluation evaluate(double d);
randomData.nextInt(4,3);
t1         = 0;
private static final long serialVersionUID = -1284328672006328516L;
double getMean();
if (problem.errorScale == null) {
private static final long serialVersionUID = -744904084649890769L;
WeightedMeasurementTest testInstance) {
fb = function.valueAt(b);
((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria
ObjectInputStream si = new ObjectInputStream(fi);  
for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {
public void testParseInteger() {
double threshold = costAccuracy * (1.0 + theoreticalMinCost);
switch (k - targetIter) {
assertEquals(result, 1.0, 1E-6);
solver = new BisectionSolver(f);
assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);
public Vector3D add(double factor, Vector3D v) {
double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));
f[i] = data[j];
double coeff = 1.0 / (2.0 * q0 * normProduct);
yDotKLast[1][i] = in.readDouble();
omega[i] = omega[i].conjugate();
oPoMn2 = 1 + oMn * oMn;
double[] cY = current.y;
protected Mean testStatistic = new Mean();
Double descriptivesValue = (Double)this.getProperty(descriptives, name);
int remainderDegree = remainder.getDegree();
p2 = new Polynomial.Rational(-2l, 3l, -1l);
private double probabilityOfSuccess;
throw new IllegalArgumentException("All entries in input 2-way table must be non-negative");
assertTrue(Math.abs(d20) > 4.0e-7);
System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);
public void testStaticFormatComplex() {
int previousCalls = Integer.MAX_VALUE;
throw new DimensionMismatchException(v.length, sums.length);
DiagonalMatrix d = new DiagonalMatrix(k);
public PolynomialFraction invert() {
double xm = 0.5 * (c - b);
BigMatrix m1 = new BigMatrixImpl(testData);
min.increment(testArray[3]);
public Product() {
double c[], tc[], d, t;
work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;
newA[i] = -p.a[i];
double d23 = tMed - tMin;
StringBuffer outBuffer = new StringBuffer();
oldc = c[j];
q0 = inv * (ort[2][0] - ort[0][2]);
float delta = 0.0F ;
new BigMatrixImpl(stringColMatrix));   
assertEquals(5, u.getN());
public void setMinReduction(double minReduction) {
assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);
protected Locale getLocale() {
distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);
public void testChiSquareZeroCount() throws Exception {
assertTrue(estimator.getCostEvaluations() < 15);
extends RungeKuttaFehlbergIntegrator {
setWholeFormat(wholeFormat);
addObject(dynaBean);
if (isLast) {
cost = Math.sqrt(cost);
index = steps.size() - 1;
if (dot >= 0) {
Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);
double middle = yEnd[i];
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
return (x / 1.5 + Math.sin(x) - 1.0) * u;
u.addObject(new Integer(12));
s1.incrementAll(values);
MathUtils.factorialDouble(x) * Math.exp(-mean);
throw new InvalidMatrixException("incorrect dimensions");
public QRDecompositionImplTest(String name) {
interpolator.storeTime(t0 + dt);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
double dot = Vector3D.dotProduct(u, v);
boolean reject = false;
sum = sampler.nextSamplePoint().y;
u.addValue(10);
assertEquals("var", StatUtils.variance(values), u2.getVariance(), tolerance);   
String pattern = "a {0}x{1} matrix cannot be a rotation matrix";
throw new ArrayIndexOutOfBoundsException(msg);
public abstract ChiSquareTest createChiSquareTest();  
protected DummyStepInterpolator(double[] y, boolean forward) {
i.interpolate(xval, yval);
(this.getRowDimension()));
public ConvergenceException(String pattern, Object[] arguments) {
Random random = new Random(1);
public void testCopyConstructor() {
testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);
fail("incorrect length for generated string");
min  = Double.NaN;
double x10 = parameters[9].getEstimate();
protected double m3;
return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),
TestProblem4 pb = new TestProblem4();
format.format(value, toAppendTo, pos);
return moment.m2 / ((double) moment.n - 1d);
int newSize = 0;
return kurt;
return ret;        
Arrays.sort(sorted);
protected SummaryStatistics u = null;
assertFraction(-17, 100, new Fraction(17.0 / -100.0));
float contractionCritera,
return Float.NaN;
dimension      = equations.getDimension();
private static UnivariateStatistic prod = new Product();
interpolatedState[i] += t4 * c;
xLow   = b;
assertEquals(3.0, x[1].getEstimate(), 1.0e-10);
throws DerivativeException, IntegratorException  {
measurements[i] = new MinpackMeasurement(i);
out[i][j] = matrix.getEntry(permutation[i], j);
setExpansionMode(expansionMode);
for (int j = 0; j < testi.length; j++) {
expand();
UpperTriangularMatrix m = new UpperTriangularMatrix (order);
public double[][] getDataAsDoubleArray() {
private double sumX = 0d;
public KowalikOsborneFunction(double[] startParams,
double scalRelativeTolerance = 1.0e-4;
f = new QuinticFunction();
while (iMax - iMin > 5) {
public class HarmonicCoefficientsGuesser
protected double geoMean = 12.070589161633011d;
this.name  = name;
+ " + 888315281771246239250340 x^20"
if (p.value(max) == 0.0) { return max; }
assertTrue(nbSteps < 80);
int nCols = getColumnDimension();
private Complex negInfInf = new Complex(neginf, inf);
return tTest.homoscedasticTTest(sampleStats1, sampleStats2);
int numCols = m.getColumnDimension();
checkMatrix(m1, new BilinearPattern(-1, 0.04));
this.gamma = gamma;
public Rational(long a1, long a0) {
assertTrue(ratio < 2.4);
f.addValue('b');
for (int i = 0; i < problems.length; ++i) {
extends TestCase {
-1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2
Fraction c = new Fraction(0, 1);
double maximum = UnivariateRealSolverUtils.solve(derivative, Math.PI / 3.0, Math.PI * 2.0 / 3.0);
assertEquals(0.820070051552, result, 1E-10);
protected MinpackFunction(int m,
public static final RotationOrder ZXY =
protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   
sampler.samplePointAt(8);
public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {
public double[] getKnots() {
ret = 1;
package org.spaceroots.mantissa.utilities;
public int getN() {
RealMatrixImpl mt = (RealMatrixImpl) m.transpose();
mapper = null;
public double getFinalTime() {
&& (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {
inputStream = in;
double[] work = new double[rows * columns];
assertEquals("var", var, StatUtils.variance(values), tolerance);
++indexU;
public MathConfigurationException(String message, Throwable cause) {
u.getVariance() == 0.0);
coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];
private class StreamDataAdapter extends DataAdapter{
assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), 
return minimizes(f, maxEvaluations, checker);
newA[i] = a[i].negate();
this.mean = mean;
long[] observed = new long[2];
f2 = new Fraction(1,59049);
if (numerator == 0) {
HashSet cPop = new HashSet();  //{0,1,2,3,4}
ret = probability(n, m, k, x);
protected double m4;
F[0] = 0.5 * (f[0] + f[1]);
for (int row = minor; row < m; row++) {
IntervalsList list1 = new IntervalsList(-2.0, -1.0);
(double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);
return -a * x * Math.sin(omega * x + phi);
sum += values[i];
double div = (i + 1) / 29.0;
0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};
TestSuite suite = new TestSuite(VarianceTest.class);
return map.keySet();
throws CostException;
throw new IllegalArgumentException("Number of samples not positive.");
sxy += x * y;
estimate   = firstEstimate;
double solve(double min, double max, double startValue)
for (int i = 0; i < measurements.length; ++i) {
assertEquals(0.5, f.getCumPct('b'), 0.0);
if (Double.doubleToLongBits(data[row][col]) != 
Double.toString(minStep),
return this.sumSq;
fail("negative mean -- expecting IllegalArgumentException");
jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };
StringBuffer toAppendTo, FieldPosition pos) {
double n2)  {
public SimpleRegression(TDistribution t) {
case REPLAY_MODE: return getNextReplay();
RealMatrix pInverse = p.inverse(); 
double yInitial = f.value(initial);
result = interpolator.getInterpolatedState();
assertEquals(expected, distribution.getMedian(), 0.0);
boolean pending      = false;
public static DivisionResult euclidianDivision(Rational dividend,
+ " + 4819022625419112503443050 x^24"
for (int row = 0; row < nRowB; row++) {
regression.getSignificance(),1E-8);    
private DomainObject b1;
assertEquals( "Mean heart rate unexpected", 93.333, 
return new Complex(MathUtils.cosh(a) * Math.cos(b),
public APSProblems2To11(double a, double b, double expectedRoot) {
- theta * (v2[i]
protected float contractionCriteria = 2.5f;
return apply(new Max());
if (Math.abs(y1) > Math.abs(y0)) {
public double getSlopeStdErr() {
-r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),
double a[] = { 2.0, 1.5 };
public abstract void readExternal(ObjectInput in)
while (n < 1000 * mean) {
double[] vertex = new double[n];
int nCols = counts[0].length;
certifiedValues.put(name, value);
fail( "You can't discard more elements than the array contains");
public class QuinticFunction implements DifferentiableUnivariateRealFunction, Serializable {
if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {
lmDir[permutation[j]] = qy[j];
return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 
private static final long serialVersionUID = -1859103913610458563L;
e = d;
int numIter = (len / 40) + 1;
testStatistic.t(sample1, sample2), 1E-10);
fail("Expecting IllegalArgumentException - bad interval");
jacobian[i * cols + pk] = temp;
LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));
"unable to orthogonalize matrix in {0} iterations" },
return Math.sqrt(sum / (double) v.length);
assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());
return makeCumulativeTestValues();
m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;
assertEquals(inf, z.abs(), 0);     
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
checkLegendre(new Legendre(5),  8l, "15 x - 70 x^3 + 63 x^5");
0.990d, 0.975d, 0.950d, 0.900d};
public static final int RESET_STATE = 1;
private int getLowerDomain(int n, int m, int k) {
q2 = 0.0;
("Number of polynomial interpolants must match the number of segments.");
0.990d, 0.975d, 0.950d, 0.900d, 1d}; 
maxStep = 0;
new PolynomialFraction(1l, 2l).divide(new PolynomialFraction(0l));
public synchronized void setNumElements(int i) {
if (den < 0) {
numElements++;
result = solver.solve(0.6, 7.0, 0.0);
double q1q1  = q1 * q1;
diagR       = new double[cols];
b.setElement(0, 1, 1.0 + epsilon * epsilon);
private void check(Interval i1, Interval i2, double x,
natural[i] = i;
Patient p3 = new Patient( vs3, new Integer( 42 ) );
UnivariateRealFunction dSpline = spline.derivative();
public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)
public void computeDerivatives(double t, double[] y, double[] yDot)
sup = i.sup;
protected double[] getDensityTestValues() {
double[] sample2 = {4d, 5d};        
return new VectorialValuedPair(current.x, table);
public TestProblem3() {
public class RiddersSolver extends UnivariateRealSolverImpl {
accum += dev * dev;
return (5*x*x-3.75)*x*x+0.25;
GeneralMatrix b = new GeneralMatrix(2, 2);
assertTrue(d2 instanceof DiagonalMatrix);
return apply(new Min());
assertEquals("max", StatUtils.max(values), u2.getMax(), tolerance);
double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());
if (s > -0.19) {
setResult(m, i);
testStatistic.chiSquareTestDataSetsComparison(
public ComplexFormat(String imaginaryCharacter) {
ret = Double.MAX_VALUE;
ScalarSampleStatistics all  = new ScalarSampleStatistics();
return (numElements);
u.setWindowSize(1);
outData[row][col] = data[row][col].add(d);
new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 0.099, 11);
assertEquals(defaultMode, testDa.getExpansionMode());
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
scale = new double[y0.length];
Patient p1 = new Patient( vs1, new Integer( 35 ) );
private double[] sums;
public static double product(final double[] values, final int begin,
-Math.sqrt ((15.0 + 2.0 * Math.sqrt (30.0)) / 35.0) },
5.0)
FirstOrderIntegrator integ = new GillIntegrator(step);
summaries = null;
if (Math.abs(y3) <= functionValueAccuracy) {
private double steadyStateThreshold;
assertEquals("nonsingular R test 1",-2d,m.getDeterminant(),normTolerance);
System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);
correlated[i] += root.getEntry(i, j) * normalized[j];
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
if (l.signum() > 0) {
decompMatrix = null;
f = f.subtract(Fraction.ONE);
assertEquals(0.0, result[i], tolerance);
-.98374475304879564677e-4,
int w = whole.intValue();
assertTrue(Math.abs(error) < 1.0e-5);
throw new MaxIterationsExceededException(maxIterations);
double v1z   = coeff * v1.getZ();
VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);
public void testExp() {
return "14.9";
throw new RuntimeException("No bin selected");
if (!Double.isNaN(cachedNormalDeviate)) {
return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
private static final byte  ZB = (byte)0;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
data[indexU] -= s.data[indexU];
checkValue(new RationalNumber(1l, 2l).multiply(new RationalNumber(0l)),
for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {
BeanTransformer b = new BeanTransformer();
p2 = (a / b * p1) + p0;
assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);
t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);
public double[] getMin() {
public void testGetEntry() {
q3 = 0;
double fsMean = 0.0;
Fraction c = properFormat.parse(source);
assertTrue("different n's should make hashcodes different", 
System.arraycopy(y1, 0, y, 0, y0.length);
int nRows = columnData.length;
double scalAbsoluteTolerance = 1.0e-9;
Arrays.fill(standardDeviation, 1.0);
void load(double[] dataArray);
Math.atan2(v1.getX(), -v1.getY()),
String source = "a";
checkValue(new PolynomialFraction(-1l, -2l), "1/2");
double s = 1 / Math.sqrt(3);
for (int k = 0; k < solvedCols; ++k) {
+ d[k][10] * yDotKLast[1][i]
return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(), 
public NormalDistribution createNormalDistribution(double mean, double sd) {
double y[] = { -4.0, 0.5 };
public TestProblem2() {
? ((Math.abs(fLow) <= Math.abs(fHigh))
if (maxDegree < 0) {
BigMatrixImpl outMat = new BigMatrixImpl(bp);
sum2[k] += s.sum2[k];
testLogBeta(Double.NaN, 1.0, -2.0);
assertEquals(.999, x, 1.0e-5);
int ij = index[j];
