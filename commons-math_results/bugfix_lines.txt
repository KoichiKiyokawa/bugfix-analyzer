if ((u1u1 < 1.0e-15) || (u2u2 < 1.0e-15)
|| (v1v1 < 1.0e-15) || (v2v2 < 1.0e-15))
if (c < (1.0e-10 * u1u1 * u2u2)) {
double u3u3 = u1u1 * u2u2 - u1u2 * u1u2;
if (c < (1.0e-10 * u1u1 * u3u3)) {
if (c < (1.0e-10 * u2u2 * u3u3)) {
if (normProduct < 1.0e-15) {
if (squaredSine < 1.0e-12) {
} else {
double inverse = -1 / Math.sqrt(squaredSine);
return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);
} else {
return 2 * Math.acos(q0);
double x00 = m[0][0];
double x01 = m[0][1];
double x02 = m[0][2];
double x10 = m[1][0];
double x11 = m[1][1];
double x12 = m[1][2];
double x20 = m[2][0];
double x21 = m[2][1];
double x22 = m[2][2];
double[][] o = new double[3][];
o[0] = new double[3];
o[1] = new double[3];
o[2] = new double[3];
double mx00 = m[0][0] * x00 + m[1][0] * x10 + m[2][0] * x20;
double mx10 = m[0][1] * x00 + m[1][1] * x10 + m[2][1] * x20;
double mx20 = m[0][2] * x00 + m[1][2] * x10 + m[2][2] * x20;
double mx01 = m[0][0] * x01 + m[1][0] * x11 + m[2][0] * x21;
double mx11 = m[0][1] * x01 + m[1][1] * x11 + m[2][1] * x21;
double mx21 = m[0][2] * x01 + m[1][2] * x11 + m[2][2] * x21;
double mx02 = m[0][0] * x02 + m[1][0] * x12 + m[2][0] * x22;
double mx12 = m[0][1] * x02 + m[1][1] * x12 + m[2][1] * x22;
double mx22 = m[0][2] * x02 + m[1][2] * x12 + m[2][2] * x22;
o[0][0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m[0][0]);
o[0][1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m[0][1]);
o[0][2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m[0][2]);
o[1][0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m[1][0]);
o[1][1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m[1][1]);
o[1][2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m[1][2]);
o[2][0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m[2][0]);
o[2][1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m[2][1]);
o[2][2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m[2][2]);
double corr00 = o[0][0] - m[0][0];
double corr01 = o[0][1] - m[0][1];
double corr02 = o[0][2] - m[0][2];
double corr10 = o[1][0] - m[1][0];
double corr11 = o[1][1] - m[1][1];
double corr12 = o[1][2] - m[1][2];
double corr20 = o[2][0] - m[2][0];
double corr21 = o[2][1] - m[2][1];
double corr22 = o[2][2] - m[2][2];
+ corr10 * corr10 + corr11 * corr11 + corr12 * corr12
+ corr20 * corr20 + corr21 * corr21 + corr22 * corr22;
x00 = o[0][0];
x01 = o[0][1];
x02 = o[0][2];
x10 = o[1][0];
x11 = o[1][1];
x12 = o[1][2];
x20 = o[2][0];
x21 = o[2][1];
x22 = o[2][2];implements StepHandler {
protected DummyStepInterpolator(DummyStepInterpolator interpolator) {
super(interpolator);throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " initial state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " final state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y.length)
throw new IntegratorException("dimensions mismatch: state vector has dimension {0},"
+ " absolute tolerance vector has dimension {1}",
new String[] {
Integer.toString(y0.length),
Integer.toString(vecAbsoluteTolerance.length)
throw new IntegratorException("dimensions mismatch: state vector has dimension {0},"
+ " relative tolerance vector has dimension {1}",
new String[] {
Integer.toString(y0.length),
Integer.toString(vecRelativeTolerance.length)
new String[] {
Double.toString(Math.abs(t - t0))
});
double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))
? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));
double h1 = (maxInv2 < 1.0e-15)
? Math.max(1.0e-6, 0.001 * Math.abs(h))
: Math.pow(0.01 / maxInv2, 1.0 / order);
throw new IntegratorException("minimal step size ({0}) reached,"
+ " integration needs {1}",
new String[] {
Double.toString(minStep),
Double.toString(Math.abs(h))
public IntegratorException(String specifier, String[] parts) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " initial state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y0.length)
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0},"
+ " final state vector has dimension {1}",
new String[] {
Integer.toString(equations.getDimension()),
Integer.toString(y.length)
new String[] {
Double.toString(Math.abs(t - t0))
});new String[] {
Integer.toString(maxCostEval)
});t.addValue(1d);public NotARotationMatrixException(String specifier, String[] parts) {
new String[] {
new String[] {
new String[] {public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[] vertexA, double[] vertexB)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[] vertexA, double[] vertexB,
int starts, long seed)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
double[][] vertices,
int starts, long seed)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator)
return minimizes(f, maxEvaluations, checker);
public PointCostPair minimizes(CostFunction f, int maxEvaluations,
ConvergenceChecker checker,
RandomVectorGenerator generator,
int starts)
return minimizes(f, maxEvaluations, checker);
private PointCostPair minimizes(CostFunction f, int maxEvaluations,
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
new MultiDirectional(1.9, 0.4).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
{ -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }
});
new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 });
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { -0.5 }, new double[] { 0.5 });
new NelderMead(0.9, 1.9, 0.4, 0.6).minimizes(wrong, 10, new ValueChecker(1.0e-3),
new double[] { 0.5 }, new double[] { 1.5 });
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
{ -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 }
}, 1, 5384353l);
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),
new double[][] {
{ -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 }
}, 10, 1642738l);
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);
nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);
nm.minimizes(powell, 200, new ValueChecker(1.0e-3),
new double[] {  3.0, -1.0, 0.0, 1.0 },
new double[] {  4.0,  0.0, 1.0, 2.0 },
1, 1642738l);private ArrayList steps;
private ArrayList functions;
private ArrayList binStats = null;final int cols = problem.getAllParameters().length;
int p = problem.getAllParameters().length;
double[] errors = new double[problem.getAllParameters().length];return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())
&& MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())
&& MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),private static final long serialVersionUID = -2193260774031645876L;
private static final long serialVersionUID = 5261476508226103366L;
private static final long serialVersionUID = 1428666635974829194L;
if (yMin * yMax >= 0) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");       
return solve(min, yMin, max, yMax, min, yMin);
return new UnivariateRealSolverFactoryImpl();
private final double imaginary;
private final double real;
parameters   = new ArrayList<EstimatedParameter>();
measurements = new ArrayList<WeightedMeasurement>();
List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());
for (EstimatedParameter p : parameters) {
private final List<EstimatedParameter> parameters;
private final List<WeightedMeasurement> measurements;
public class Fraction extends Number implements Comparable<Fraction> {
private static final long serialVersionUID = -5731055832688548463L;
public int compareTo(Fraction object) {
double second = object.doubleValue();
private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);
private static final long serialVersionUID = 3728473373420246054L;
private static final double TOO_SMALL = 10E-12;
switchesHandler.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);
public Collection<SwitchState> getSwitchingFunctions() {
return switchesHandler.getSwitchingFunctions();
public void clearSwitchingFunctions() {
switchesHandler.clearSwitchingFunctions();
steps = new ArrayList<StepInterpolator>();
for (StepInterpolator interpolator : model.steps) {
steps.add(interpolator.copy());
steps.add(interpolator.copy());
finalTime = interpolator.getCurrentTime();
return steps.get(index).getInterpolatedTime();
StepInterpolator sMin = steps.get(iMin);
StepInterpolator sMax = steps.get(iMax);
StepInterpolator si = steps.get(index);
StepInterpolator sMed = steps.get(iMed);
while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {
steps.get(index).setInterpolatedTime(time);
return steps.get(index).getInterpolatedState();
private List<StepInterpolator> steps;
private static final long serialVersionUID = -1417964919405031606L;
public Collection<SwitchState> getSwitchingFunctions();
public void clearSwitchingFunctions();
switchesHandler.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);
public Collection<SwitchState> getSwitchingFunctions() {
return switchesHandler.getSwitchingFunctions();
public void clearSwitchingFunctions() {
switchesHandler.clearSwitchingFunctions();
package org.apache.commons.math.ode;
public class SwitchException extends MathException {
private static final long serialVersionUID = -3662133702316614545L;
public SwitchException(String specifier, Object[] parts) {
super(specifier, parts);
public SwitchException(Throwable cause) {
super(cause);
private static final long serialVersionUID = -7307007422156119622L;
throws SwitchException {
throws DerivativeException, SwitchException, ConvergenceException {
} catch (SwitchException e) {
throw new FunctionEvaluationException(t, e);
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
} else if ((cause != null) && (cause instanceof SwitchException)) {
throw (SwitchException) cause;
throw new SwitchException(e);
public void stepAccepted(double t, double[] y) throws SwitchException {
public boolean reset(double t, double[] y) throws SwitchException {
public double g(double t, double[] y) throws SwitchException;
public int eventOccurred(double t, double[] y) throws SwitchException;
public void resetState(double t, double[] y) throws SwitchException;
functions   = new ArrayList<SwitchState>();
public void addSwitchingFunction(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
public Collection<SwitchState> getSwitchingFunctions() {
return Collections.unmodifiableCollection(functions);
public void clearSwitchingFunctions() {
functions.clear();
for (SwitchState state : functions) {
state.reinitializeBegin(t0, y);
for (SwitchState state : functions) {
} catch (SwitchException se) {
throw new IntegratorException(se);
for (SwitchState state : functions) {
state.stepAccepted(t, y);
} catch (SwitchException se) {
throw new IntegratorException(se);
for (SwitchState state : functions) {
if (state.stop()) {
public boolean reset(double t, double[] y) throws IntegratorException {
boolean resetDerivatives = false;
for (SwitchState state : functions) {
if (state.reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
} catch (SwitchException se) {
throw new IntegratorException(se);
private List<SwitchState> functions;
private static Comparator<PointCostPair> pointCostPairComparator =
new Comparator<PointCostPair>() {
public int compare(PointCostPair o1, PointCostPair o2) {
return (o1.getCost() < o2.getCost()) ? -1 : ((o1 == o2) ? 0 : +1);
List<SummaryStatistics> getBinStats();
private static final long serialVersionUID = 5729073523949762654L;
private List<SummaryStatistics> binStats = null;
binStats = new ArrayList<SummaryStatistics>();
binStats = new ArrayList<SummaryStatistics>();
SummaryStatistics stats = binStats.get(findBin(min, val, delta));
binStats.get(findBin(min, inputArray[i], delta));
((double) binStats.get(0).getN()) / (double) sampleStats.getN();
((double) binStats.get(i).getN()) / (double) sampleStats.getN();
SummaryStatistics stats = binStats.get(i);
public List<SummaryStatistics> getBinStats() {
Object[] nextSample(Collection<?> c, int k);
public Object[] nextSample(Collection<?> c, int k) {
private static final long serialVersionUID = 4133067267405273064L;
private static final long serialVersionUID = -2021321786743555871L;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&
MathUtils.equals(stat.getMax(), this.getMax()) &&
MathUtils.equals(stat.getMean(), this.getMean()) &&
MathUtils.equals(stat.getMin(), this.getMin()) &&
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&
MathUtils.equals(stat.getVariance(),
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
private AnovaStats anovaStats(Collection<double[]> categoryData)
for (double[] array : categoryData) {
for (double[] data : categoryData) {
public static double oneWayAnovaFValue(Collection<double[]> categoryData)
public static double oneWayAnovaPValue(Collection<double[]> categoryData)
public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegression implements
MultipleLinearRegression {
protected RealMatrix X;
protected RealMatrix Y;
protected void addYSampleData(double[] y) {
this.Y = new RealMatrixImpl(y);
protected void addXSampleData(double[][] x) {
this.X = new RealMatrixImpl(x);
protected void validateSampleData(double[][] x, double[] y) {
if (x == null) {
throw new IllegalArgumentException("The regressors matrix x cannot be null.");
if (y == null) {
throw new IllegalArgumentException("The regressand vector y cannot be null.");
if (x.length != y.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the regressand vector y");
protected void validateCovarianceData(double[][] x, double[][] covariance) {
if (covariance == null) {
throw new IllegalArgumentException("Covariance matrix cannot be null.");
if (x.length != covariance.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the covariance matrix columns");
if (covariance.length > 0 && covariance.length != covariance[0].length) {
throw new IllegalArgumentException("The covariance matrix must be square");
public double[] estimateRegressionParameters() {
RealMatrix b = calculateBeta();
return b.getColumn(0);
public double[] estimateResiduals() {
RealMatrix b = calculateBeta();
RealMatrix e = Y.subtract(X.multiply(b));
return e.getColumn(0);
public double[][] estimateRegressionParametersVariance() {
return calculateBetaVariance().getData();
public double estimateRegressandVariance() {
return calculateYVariance();
protected abstract RealMatrix calculateBeta();
protected abstract RealMatrix calculateBetaVariance();
protected abstract double calculateYVariance();
protected RealMatrix calculateResiduals() {
RealMatrix b = calculateBeta();
return Y.subtract(X.multiply(b));
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
private RealMatrix Omega;
public void addData(double[] y, double[][] x, double[][] covariance) {
validateSampleData(x, y);
addYSampleData(y);
addXSampleData(x);
validateCovarianceData(x, covariance);
addCovarianceData(covariance);
protected void addCovarianceData(double[][] omega){
this.Omega = new RealMatrixImpl(omega);
protected RealMatrix calculateBeta() {
RealMatrix OI = Omega.inverse();
RealMatrix XT = X.transpose();
RealMatrix XTOIX = XT.multiply(OI).multiply(X);
return XTOIX.inverse().multiply(XT).multiply(OI).multiply(Y);
protected RealMatrix calculateBetaVariance() {
RealMatrix XTOIX = X.transpose().multiply(Omega.inverse()).multiply(X);
return XTOIX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse =  u.transpose().multiply(Omega.inverse()).multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
package org.apache.commons.math.stat.regression;
public interface MultipleLinearRegression {
void addData(double[] y, double[][] x, double[][] covariance);
double[] estimateRegressionParameters();
double[][] estimateRegressionParametersVariance();
double[] estimateResiduals();
double estimateRegressandVariance();
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
public void addData(double[] y, double[][] x, double[][] covariance) {
validateSampleData(x, y);
addYSampleData(y);
addXSampleData(x);
protected RealMatrix calculateBeta() {
RealMatrix XTX = X.transpose().multiply(X);
return XTX.inverse().multiply(X.transpose()).multiply(Y);
protected RealMatrix calculateBetaVariance() {
RealMatrix XTX = X.transpose().multiply(X);
return XTX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse = u.transpose().multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
private static final long serialVersionUID = 4605318041528645258L;
private Map<Class<?>, NumberTransformer> map = null;
map = new HashMap<Class<?>, NumberTransformer>();
public boolean containsClass(Class<?> key) {
public NumberTransformer getTransformer(Class<?> key) {
public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {
public NumberTransformer removeTransformer(Class<?> key) {
public Set<Class<?>> classes() {
public Collection<NumberTransformer> transformers() {
assertEquals(w.getReal(), 4.0, 0);
assertTrue(Double.isNaN(w.getImaginary()));
assertEquals(w.getImaginary(), 1, 0);
assertEquals(inf, w.getReal(), 0);
assertTrue(Double.isNaN(x.add(z).getReal()));
assertEquals(neginf, z.conjugate().getImaginary(), 0);
assertEquals(inf, z.conjugate().getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(inf, z.getReal(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertTrue(Double.isNaN(w.getReal()));
assertTrue(Double.isNaN(w.getImaginary()));  
return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
for (EstimatedParameter p : set) {
addParameter(p);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
set.add(parameters[j]);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
private static class QuadraticProblem extends SimpleEstimationProblem {
assertEquals(functions.length, integ.getSwitchingFunctions().size());
integ.clearSwitchingFunctions();
assertEquals(0, integ.getSwitchingFunctions().size());
assertEquals(functions.length, integ.getSwitchingFunctions().size());
integ.clearSwitchingFunctions();
assertEquals(0, integ.getSwitchingFunctions().size());
assertEquals(functions.length, integ.getSwitchingFunctions().size());
integ.clearSwitchingFunctions();
assertEquals(0, integ.getSwitchingFunctions().size());
assertEquals(functions.length, integ.getSwitchingFunctions().size());
integ.clearSwitchingFunctions();
assertEquals(0, integ.getSwitchingFunctions().size());
assertEquals(functions.length, integ.getSwitchingFunctions().size());
integ.clearSwitchingFunctions();
assertEquals(0, integ.getSwitchingFunctions().size());
public double g(double t, double[] y) throws SwitchException {
throw new SwitchException("Evaluation failed for argument = {0}",
new Object[] { new Double(t) });
ArrayList<Double> list = new ArrayList<Double>();
for (Double data : list) {
dataArray[i] = data.doubleValue();
HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}
HashSet<Object> hs = new HashSet<Object>();
HashSet<Object> hs = new HashSet<Object>();
hs = new HashSet<Object>();
HashSet<Object> set = (HashSet<Object>) u[i];
HashSet<Object> sampSet = new HashSet<Object>();
private Map<String, Double> certifiedValues;
certifiedValues = new HashMap<String, Double>();
for (String name : certifiedValues.keySet()) {
public class DescriptiveStatisticsTest extends TestCase {
protected List<Object> list;
this(new ArrayList<Object>());
public ListUnivariateImpl(List<Object> list) {
public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {
List<Object> externalList = new ArrayList<Object>();
List<Object> list = new ArrayList<Object>();
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());
List<Object> externalList = new ArrayList<Object>();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
new ListUnivariateImpl(new ArrayList<Object>(), transformers);
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
public class SummaryStatisticsTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsTest(String name) {
super(name);
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> emptyContents = new ArrayList<double[]>();
List<double[]> tooFew = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
private List<double[]> classes = new ArrayList<double[]>();
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegressionTest {
protected MultipleLinearRegression regression;
public void setUp(){
regression = createRegression();
protected abstract MultipleLinearRegression createRegression();
protected abstract int getNumberOfRegressors();
protected abstract int getSampleSize();
public void canEstimateRegressionParameters(){
double[] beta = regression.estimateRegressionParameters();        
assertEquals(getNumberOfRegressors(), beta.length);
public void canEstimateResiduals(){
double[] e = regression.estimateResiduals();
assertEquals(getSampleSize(), e.length);
public void canEstimateRegressionParametersVariance(){
double[][] variance = regression.estimateRegressionParametersVariance();
assertEquals(getNumberOfRegressors(), variance.length);
public void canEstimateRegressandVariance(){
double variance = regression.estimateRegressandVariance();
assertTrue(variance > 0.0);
}   
public void cannotAddXSampleData() {
regression.addData(new double[]{}, null, null);
public void cannotAddNullYSampleData() {
regression.addData(null, new double[][]{}, null);
public void cannotAddSampleDataWithSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[1][];
x[0] = new double[]{1.0, 0};
regression.addData(y, x, null);
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
private double[][] omega;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
omega = new double[6][];
omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};
omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};
omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};
omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};
omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};
omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};
super.setUp();
public void cannotAddNullCovarianceData() {
regression.addData(new double[]{}, new double[][]{}, null);
public void cannotAddCovarianceDataWithSampleSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[1][];
omega[0] = new double[]{1.0, 0};
regression.addData(y, x, omega);
public void cannotAddCovarianceDataThatIsNotSquare() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[3][];
omega[0] = new double[]{1.0, 0};
omega[1] = new double[]{0, 1.0};
omega[2] = new double[]{0, 2.0};
regression.addData(y, x, omega);
protected MultipleLinearRegression createRegression() {
MultipleLinearRegression regression = new GLSMultipleLinearRegression();
regression.addData(y, x, omega);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
super.setUp();
protected MultipleLinearRegression createRegression() {
MultipleLinearRegression regression = new OLSMultipleLinearRegression();
regression.addData(y, x, null);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
private static final long serialVersionUID = -7619974756160279127L;
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
double ret = Double.NaN;
double sign = yMin * yMax;
if (sign > 0) {
if (Math.abs(yMin) <= functionValueAccuracy) {
setResult(min, 0);
ret = min;
} else if (Math.abs(yMax) <= functionValueAccuracy) {
setResult(max, 0);
ret = max;
} else {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");
} else if (sign < 0){
ret = solve(min, yMin, max, yMax, min, yMin);
} else {
if (yMin == 0.0) {
ret = min;
} else {
ret = max;
return ret;
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
} catch(Throwable t) {
return new UnivariateRealSolverFactoryImpl();
return factory;
protected double imaginary;
protected double real;
public static Complex acos(Complex z) {
return z.acos();
public static Complex asin(Complex z) {
return z.asin();
public static Complex atan(Complex z) {
return z.atan();
public static Complex cos(Complex z) {
return z.cos();
public static Complex cosh(Complex z) {
return z.cosh();
public static Complex exp(Complex z) {
return z.exp();
public static Complex log(Complex z) {
return z.log();
public static Complex pow(Complex y, Complex x) {
return y.pow(x);
public static Complex sin(Complex z) {
return z.sin();
public static Complex sinh(Complex z) {
return z.sinh();
public static Complex sqrt(Complex z) {
return z.sqrt();
public static Complex sqrt1z(Complex z) {
return z.sqrt1z();
public static Complex tan(Complex z) {
return z.tan();
public static Complex tanh(Complex z) {
return z.tanh();
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
}    
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
parameters   = new ArrayList();
measurements = new ArrayList();
List unbound = new ArrayList(parameters.size());
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
private final List parameters;
private final List measurements;
public class Fraction extends Number implements Comparable {
private static final long serialVersionUID = -8958519416450949235L;
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
protected static double TOO_SMALL = 10E-12;
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
steps = new ArrayList();
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
steps.add(((AbstractStepInterpolator) iter.next()).copy());
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
steps.add(ai.copy());
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
while ((index <= iMax) &&
(locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private List steps;
private static final long serialVersionUID = 2259286184268533249L;
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
private static final long serialVersionUID = -7307007422156119622L;
throws FunctionEvaluationException {
throws DerivativeException, FunctionEvaluationException, ConvergenceException {
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
throw e;
public void stepAccepted(double t, double[] y)
throws FunctionEvaluationException {
public boolean reset(double t, double[] y) {
public double g(double t, double[] y) throws FunctionEvaluationException;
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
functions   = new ArrayList();
public void add(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private List functions;
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
double cost1 = ((PointCostPair) o1).getCost();
double cost2 = ((PointCostPair) o2).getCost();
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
private List binStats = null;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
public Object[] nextSample(Collection c, int k) {
private static final long serialVersionUID = -2734185686570407433L;
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
} catch(Throwable t) {
return new DescriptiveStatisticsImpl();
return factory;
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
private static final long serialVersionUID = -6467796944112488424L;
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
super(window);
public void clear() {
super.clear();
private static final long serialVersionUID = -3346512372447011854L;
public static SummaryStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
instance = (SummaryStatistics)dc.newInstance(SummaryStatistics.class, "org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl");
} catch (Throwable t) {
return new SummaryStatisticsImpl();
return instance;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())
&& MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())
&& MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
private static final long serialVersionUID = 8528794411480425963L;
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
private AnovaStats anovaStats(Collection categoryData)
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] array;
array = (double[])iterator.next();
} catch (ClassCastException ex) {
throw new IllegalArgumentException(
"ANOVA: categoryData contains non-double[] elements.");
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] data = (double[])iterator.next();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
} catch(Throwable t) {
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
public static double oneWayAnovaFValue(Collection categoryData)
public static double oneWayAnovaPValue(Collection categoryData)
public static boolean oneWayAnovaTest(Collection categoryData, double alpha)
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public void testRootEndpoints() throws Exception {
UnivariateRealFunction f = new SinFunction();
UnivariateRealSolver solver = new BrentSolver(f);
double result = solver.solve(Math.PI, 4);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
result = solver.solve(3, Math.PI);
assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
} 
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
} 
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
} 
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
}       
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
HashSet set = new HashSet();
for (Iterator iterator = set.iterator(); iterator.hasNext();) {
addParameter((EstimatedParameter) iterator.next());
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
public class QuadraticProblem extends SimpleEstimationProblem {
public double g(double t, double[] y) throws FunctionEvaluationException {
throw new FunctionEvaluationException(t);
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
private Map certifiedValues;
certifiedValues = new HashMap();
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
package org.apache.commons.math.stat.descriptive;
public abstract class DescriptiveStatisticsAbstractTest extends TestCase {
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
public DescriptiveStatisticsAbstractTest(String name) {
super(name);
protected abstract DescriptiveStatistics createDescriptiveStatistics();
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
DescriptiveStatistics stats = createDescriptiveStatistics();
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
}     
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
}     
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}    
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
}  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}  
}     
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
}        
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
} catch (NullPointerException ex) {
} catch (Exception ex) {
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
} catch (InstantiationException ex) {
fail();
} catch (IllegalAccessException ex) {
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
} catch (IllegalArgumentException ex) {
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
} catch (IllegalArgumentException ex) {
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
DescriptiveStatistics u = createDescriptiveStatistics();
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
}       
public void testStats() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
}        
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public final class DescriptiveStatisticsImplTest extends DescriptiveStatisticsAbstractTest {
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
suite.setName("DescriptiveStatisticsImpl Tests");
return suite;
protected DescriptiveStatistics createDescriptiveStatistics() {
return new DescriptiveStatisticsImpl();
public final class DescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
List externalList = new ArrayList();
List list = new ArrayList();
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
package org.apache.commons.math.stat.descriptive;
public abstract class SummaryStatisticsAbstractTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsAbstractTest(String name) {
super(name);
protected abstract SummaryStatistics createSummaryStatistics();
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public final class SummaryStatisticsImplTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
suite.setName("SummaryStatisticsImpl Tests");
return suite;
protected SummaryStatistics createSummaryStatistics() {
return new SummaryStatisticsImpl();
public final class SummaryStatisticsTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsTest(String name) {
super(name);
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsAbstractTest {
private char[] wrongArray = { 'a', 'b', 'c' };
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List wrongContents = new ArrayList();
wrongContents.add(classC);
wrongContents.add(wrongArray);
testStatistic.anovaFValue(wrongContents);
fail("non double[] hash value for key classX, IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
}  
List emptyContents = new ArrayList();
List tooFew = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
private List classes = new ArrayList();public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private static final long serialVersionUID = 8225864499430109352L;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
private static final long serialVersionUID = -5721105387745193385L;
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(new Rotation().getAxis(), Vector3D.plusI);
new Rotation(u, new Vector3D());
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,
new Rotation(u1, u2, new Vector3D(), v2);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
Rotation reference = new Rotation(q0, q1, q2, q3, false);
assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);
checkVector(new Vector3D(2, Vector3D.plusI,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
5, Vector3D.minusJ,
-3, Vector3D.minusK),
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
new Vector3D().normalize();
Vector3D.angle(new Vector3D(), Vector3D.plusI);public DerivativeException(String specifier, String[] parts) {final BigDecimal[] out = new BigDecimal[v.length];
final double[] out = new double[v.length];public Collection<SwitchState> getSwitchingFunctions() {
public Collection<SwitchState> getSwitchingFunctions();
public Collection<SwitchState> getSwitchingFunctions() {
public Collection<SwitchState> getSwitchingFunctions() {
return Collections.unmodifiableCollection(functions);if (yMin * yMax >= 0) {
throw new IllegalArgumentException
("Function values at endpoints do not have different signs." +
"  Endpoints: [" + min + "," + max + "]" + 
"  Values: [" + yMin + "," + yMax + "]");       
return solve(min, yMin, max, yMax, min, yMin);final double fourTheta = 4 * theta;
final double s         = oneMinusThetaH / 6.0;
final double coeff1    = s * ((-fourTheta + 5) * theta - 1);
final double coeff23   = s * (( fourTheta - 2) * theta - 2);
final double coeff4    = s * ((-fourTheta - 1) * theta - 1);
interpolatedState[i] = currentState[i] +
coeff1  * yDotK[0][i] +
coeff23 * (yDotK[1][i] + yDotK[2][i]) +
coeff4  * yDotK[3][i];
v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +
a74 * yDotK[4][i] + a75 * yDotK[5][i]);
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +
d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);
interpolatedState[i] = currentState[i] -
eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +
b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +
b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +
d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +
d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +
d[k][9]  * yDotKLast[0][i] +
d[k][10] * yDotKLast[1][i] +
d[k][11] * yDotKLast[2][i]);
final double eta = oneMinusThetaH / h;
private static final long serialVersionUID = -7179861704951334960L;
final double soMt      = s * (1 - theta);
final double c23       = soMt * (1 + 2 * theta);
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
double t4                  = theta * oneMinusTheta;
t4 = t4 * t4;
interpolatedState[i] = polynoms[0][i] +
theta * (polynoms[1][i] +
oneMinusTheta * (polynoms[2][i] * theta +
polynoms[3][i] * oneMinusTheta));
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
interpolatedState[i] = currentState[i] +
b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +
b4 * yDotK[4][i] + b5 * yDotK[5][i];
final double coeff1 = oneMinusThetaH * theta;
final double coeff2 = oneMinusThetaH * (1.0 + theta);
interpolatedState[i] = currentState[i] +
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
currentState      = y;
interpolatedState = new double[y.length];
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
currentState      = y;
interpolatedState = new double[y.length];
return (double[]) interpolatedState.clone();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
public void handleStep(double t, double[] y, boolean isLast);
private static final long serialVersionUID = -973517244031912577L;
lastTime  = Double.NaN;
lastState = null;
forward   = true;
final double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
handler.handleStep(lastTime, lastState, false);
handler.handleStep(lastTime, lastState, true);
extends TestCase {
extends TestCase {
extends TestCase {
extends TestCase {
throws DerivativeException {
extends TestCase {
extends TestCase {
extends TestCase {
extends TestCase {
extends TestCase {long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
boolean lastStep  = false;
stepSize  = (t - t0) / nbStep;
for (long i = 0; ! lastStep; ++i) {
boolean needUpdate = false;
if (eventsHandlersManager.evaluateStep(interpolator)) {
needUpdate = true;
stepSize = eventsHandlersManager.getEventTime() - stepStart;
eventsHandlersManager.stepAccepted(nextStep, y);
if (eventsHandlersManager.stop()) {
lastStep = true;
} else {
lastStep = (i == (nbStep - 1));
if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {
if (needUpdate) {
nbStep = Math.max(1l, Math.abs(Math.round((t - stepStart) / step)));
stepSize = (t - stepStart) / nbStep;
i = -1;computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);protected double filterStep(final double h, final boolean acceptSmall)
filteredH = (filteredH < 0) ? -minStep : minStep;
} else if (h < -maxStep) {
hNew = filterStep(stepSize * factor, false);
hNew = filterStep(scaledH, nextIsLast);
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter+1] / costPerStep[k],
false);
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter] / costPerStep[k],
false);protected CombinedEventsManager addEndTimeChecker(final double endTime,
Double.POSITIVE_INFINITY, Math.ulp(endTime), 10);
CombinedEventsManager manager = addEndTimeChecker(t, eventsHandlersManager);
CombinedEventsManager manager = addEndTimeChecker(t, eventsHandlersManager);value = Double.valueOf(d);
value = Float.valueOf(f);
value = Integer.valueOf(i);
value = Long.valueOf(l);
dynaBean.set(propertyName, Double.valueOf(v));
VitalStats vs1 = new VitalStats( Double.valueOf(120.0), 
Double.valueOf(96.4) );
Patient p1 = new Patient( vs1, Integer.valueOf( 35 ) );
VitalStats vs2 = new VitalStats( Double.valueOf(70.0), 
Double.valueOf(97.4) );
Patient p2 = new Patient( vs2, Integer.valueOf( 23 ) );
VitalStats vs3 = new VitalStats( Double.valueOf(90.0), 
Double.valueOf(98.6) );
Patient p3 = new Patient( vs3, Integer.valueOf( 42 ) );
new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });
Integer.valueOf(dimension1), Integer.valueOf(dimension2)
new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });
private static final long serialVersionUID = -2193260774031645876L;
new Object[] { Double.valueOf(argument) });
private static final long serialVersionUID = 5261476508226103366L;
private static final long serialVersionUID = 1428666635974829194L;
new Object[] { Integer.valueOf(maxIterations) });
return new UnivariateRealSolverFactoryImpl();
new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),
Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),
Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });
private final double imaginary;
private final double real;
public class ComplexFormat extends CompositeFormat {
private static final long serialVersionUID = -3343698360149467646L;
public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public static String formatComplex(Complex c) {
return getInstance().format(c);
throw new IllegalArgumentException("Cannot format given Object as a Complex");
"\"", parsePosition.getErrorIndex());
if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {
new Object[] { Integer.valueOf(maxCostEval) });
return ((RealMatrixImpl) new RealMatrixImpl(jTj, false).inverse()).getDataRef();
new Object[] { Integer.valueOf(m), Integer.valueOf(p)});
new Object[] { Double.valueOf(costRelativeTolerance) });
new Object[] { Double.valueOf(parRelativeTolerance) });
new Object[] { Double.valueOf(orthoTolerance) });
new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });
parameters   = new ArrayList<EstimatedParameter>();
measurements = new ArrayList<WeightedMeasurement>();
List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());
for (EstimatedParameter p : parameters) {
private final List<EstimatedParameter> parameters;
private final List<WeightedMeasurement> measurements;
public class Fraction extends Number implements Comparable<Fraction> {
private static final long serialVersionUID = -5731055832688548463L;
public int compareTo(Fraction object) {
double second = object.doubleValue();
new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });
new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });
public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);
private static final long serialVersionUID = -2153622329907944313L;
private final double q0;
private final double q1;
private final double q2;
private final double q3;
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
public static double distance(Rotation r1, Rotation r2) {
return r1.applyInverseTo(r2).getAngle();
new RotationOrder("XYZ", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);
new RotationOrder("XZY", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);
new RotationOrder("YXZ", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);
new RotationOrder("YZX", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);
new RotationOrder("ZXY", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);
new RotationOrder("ZYX", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);
new RotationOrder("XYX", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);
new RotationOrder("XZX", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);
new RotationOrder("YXY", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);
new RotationOrder("YZY", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);
new RotationOrder("ZXZ", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);
new RotationOrder("ZYZ", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);
public static final Vector3D ZERO   = new Vector3D(0, 0, 0);
public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);
public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);
public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);
public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);
public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);
public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);
public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);
public static final Vector3D POSITIVE_INFINITY =
new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
public static final Vector3D NEGATIVE_INFINITY =
new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
private static final Vector3DFormat DEFAULT_FORMAT =
Vector3DFormat.getInstance();
private static final long serialVersionUID = 5133268763396045979L;
private final double x;
private final double y;
private final double z;
public double getNormSq() {
return x * x + y * y + z * z;
public boolean isNaN() {
return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        
public boolean isInfinite() {
return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        
public boolean equals(Object other) {
if (this == other) { 
return true;
if (other == null) {
return false;
Vector3D rhs = (Vector3D)other;
if (rhs.isNaN()) {
return this.isNaN();
return (Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(rhs.x)) &&
(Double.doubleToRawLongBits(y) == Double.doubleToRawLongBits(rhs.y)) &&
(Double.doubleToRawLongBits(z) == Double.doubleToRawLongBits(rhs.z)); 
} catch (ClassCastException ex) {
return false;
public int hashCode() {
if (isNaN()) {
return 8;
return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));
public static double distance(Vector3D v1, Vector3D v2) {
final double dx = v2.x - v1.x;
final double dy = v2.y - v1.y;
final double dz = v2.z - v1.z;
return Math.sqrt(dx * dx + dy * dy + dz * dz);
public static double distanceSq(Vector3D v1, Vector3D v2) {
final double dx = v2.x - v1.x;
final double dy = v2.y - v1.y;
final double dz = v2.z - v1.z;
return dx * dx + dy * dy + dz * dz;
public String toString() {
return DEFAULT_FORMAT.format(this);
package org.apache.commons.math.geometry;
public class Vector3DFormat extends CompositeFormat {
private static final long serialVersionUID = -5447606608652576301L;
private static final String DEFAULT_PREFIX = "{";
private static final String DEFAULT_SUFFIX = "}";
private static final String DEFAULT_SEPARATOR = "; ";
private final String prefix;
private final String suffix;
private final String separator;
private final String trimmedPrefix;
private final String trimmedSuffix;
private final String trimmedSeparator;
private NumberFormat format;
public Vector3DFormat() {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());
public Vector3DFormat(final NumberFormat format) {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);
public Vector3DFormat(final String prefix, final String suffix,
final String separator) {
this(prefix, suffix, separator, getDefaultNumberFormat());
public Vector3DFormat(final String prefix, final String suffix,
final String separator, final NumberFormat format) {
this.prefix      = prefix;
this.suffix      = suffix;
this.separator   = separator;
trimmedPrefix    = prefix.trim();
trimmedSuffix    = suffix.trim();
trimmedSeparator = separator.trim();
this.format      = format;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public String getPrefix() {
return prefix;
public String getSuffix() {
return suffix;
public String getSeparator() {
return separator;
public NumberFormat getFormat() {
return format;
public static Vector3DFormat getInstance() {
return getInstance(Locale.getDefault());
public static Vector3DFormat getInstance(final Locale locale) {
return new Vector3DFormat(getDefaultNumberFormat(locale));
public static String formatVector3D(Vector3D v) {
return getInstance().format(v);
public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
toAppendTo.append(prefix);
formatDouble(vector.getX(), format, toAppendTo, pos);
toAppendTo.append(separator);
formatDouble(vector.getY(), format, toAppendTo, pos);
toAppendTo.append(separator);
formatDouble(vector.getZ(), format, toAppendTo, pos);
toAppendTo.append(suffix);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
if (obj instanceof Vector3D) {
return format( (Vector3D)obj, toAppendTo, pos);
throw new IllegalArgumentException("Cannot format given Object as a Vector3D");
public Vector3D parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
Vector3D result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable 3D vector: \"" + source +
"\"", parsePosition.getErrorIndex());
return result;
public Vector3D parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedPrefix, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number x = parseNumber(source, format, pos);
if (x == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number y = parseNumber(source, format, pos);
if (y == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number z = parseNumber(source, format, pos);
if (z == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSuffix, pos)) {
return null;
return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
protected BigDecimal data[][] = null;
protected BigDecimal lu[][] = null;
protected int[] permutation = null;
protected int parity = 1;
private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);
public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
if (copyArray) {
copyIn(d);
} else {
if (d == null) {
throw new NullPointerException();
}   
final int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException("Matrix must have at least one row."); 
final int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException("Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (d[r].length != nCols) {
throw new IllegalArgumentException("All input rows must have the same length.");
}       
data = d;
lu = null;
final int nRows = d.length;
final int nCols = d[0].length;
final int nRows = d.length;
final int nCols = d[0].length;
final int nRows = v.length;
return new BigMatrixImpl(this.copyOut(), false);
return add((BigMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
}  
return new BigMatrixImpl(outData, false);
public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] mRow       = m.data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].add(mRow[col]);
}  
return new BigMatrixImpl(outData, false);
return subtract((BigMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
}  
return new BigMatrixImpl(outData, false);
public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] mRow       = m.data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].subtract(mRow[col]);
}  
return new BigMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].add(d);
return new BigMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].multiply(d);
return new BigMatrixImpl(outData, false);
return multiply((BigMatrixImpl) m);
} catch (ClassCastException cce) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
for (int row = 0; row < nRows; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nSum; i++) {
sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
outDataRow[col] = sum;
return new BigMatrixImpl(outData, false);
public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
BigDecimal sum = ZERO;
sum = sum.add(dataRow[i].multiply(m.data[i][col]));
outDataRow[col] = sum;
}            
return new BigMatrixImpl(outData, false);
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double d[][] = new double[nRows][nCols];
for (int j = 0; j < nCols; j++) {
public BigMatrix getSubMatrix(int startRow, int endRow,
int startColumn, int endColumn)
throws MatrixIndexException {
final BigDecimal[][] subMatrixData =
new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
System.arraycopy(data[i], startColumn,
subMatrixData[i - startRow], 0,
endColumn - startColumn + 1);
return new BigMatrixImpl(subMatrixData, false);
throws MatrixIndexException {
final BigDecimal[][] subMatrixData =
new BigDecimal[selectedRows.length][selectedColumns.length];
final BigDecimal[] subI = subMatrixData[i];
final BigDecimal[] dataSelectedI = data[selectedRows[i]];
subI[j] = dataSelectedI[selectedColumns[j]];
return new BigMatrixImpl(subMatrixData, false);
final int nRows = subMatrix.length;
final int nCols = subMatrix[0].length;
final int ncols = this.getColumnDimension();
final BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out, false);
final int nRows = this.getRowDimension();
final BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out, false);
final int ncols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[ncols];
final int ncols = this.getColumnDimension();
final double[] out = new double[ncols];
final int nRows = this.getRowDimension();
final BigDecimal[] out = new BigDecimal[nRows];
final int nrows = this.getRowDimension();
final double[] out = new double[nrows];
return data[row][column];
} catch (ArrayIndexOutOfBoundsException e) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nCols][nRows];
final BigDecimal[] dataRow = data[row];
outData[col][row] = dataRow[col];
return new BigMatrixImpl(outData, false);
return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[nRows];
final BigDecimal bd[] = new BigDecimal[v.length];
for (int i = 0; i < bd.length; i++) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[nCols];
final int nRows = this.getRowDimension();
final BigMatrix bMatrix = new BigMatrixImpl(b);
final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
final BigDecimal[] out = new BigDecimal[nRows];
final BigDecimal bd[] = new BigDecimal[b.length];
for (int i = 0; i < bd.length; i++) {
final int nCol = this.getColumnDimension();
final int nColB = b.getColumnDimension();
final int nRowB = b.getRowDimension();
final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
final BigDecimal[] bpRow = bp[row];
bpRow[col] = b.getEntry(permutation[row], col);
final BigDecimal[] bpI = bp[i];
final BigDecimal[] luI = lu[i];
bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
final BigDecimal[] bpCol = bp[col];
final BigDecimal luDiag = lu[col][col];
bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
final BigDecimal[] bpI = bp[i];
final BigDecimal[] luI = lu[i];
bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
return new BigMatrixImpl(bp, false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] luRow = lu[row];
sum = luRow[col];
sum = sum.subtract(luRow[i].multiply(lu[i][col]));
luRow[col] = sum;
final BigDecimal[] luRow = lu[row];
sum = luRow[col];
sum = sum.subtract(luRow[i].multiply(lu[i][col]));
luRow[col] = sum;
final BigDecimal luDiag = lu[col][col];
final BigDecimal[] luRow = lu[row];
luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);
if (i > 0) {
if (j > 0) {
final BigMatrix m = (BigMatrix) object;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final BigDecimal[] dataRow = data[row];
if (!dataRow[col].equals(m.getEntry(row, col))) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final BigDecimal[] dataRow = data[row];
dataRow[col].hashCode();
final int[] out = new int[permutation.length];
final int nRows = this.getRowDimension();
final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
final int nRows = in.length;
final int nCols = in[0].length;
final BigDecimal[] dataI = data[i];
final double[] inI = in[i];
for (int j = 0; j < nCols; j++) {
dataI[j] = new BigDecimal(inI[j]);
final int nRows = in.length;
final int nCols = in[0].length;
final BigDecimal[] dataI = data[i];
final String[] inI = in[i];
for (int j = 0; j < nCols; j++) {
dataI[j] = new BigDecimal(inI[j]);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
package org.apache.commons.math.linear;
public interface DecompositionSolver extends Serializable {
double[] solve(double[] b)
throws IllegalArgumentException, InvalidMatrixException;
RealVector solve(RealVector b)
throws IllegalArgumentException, InvalidMatrixException;
RealMatrix solve(RealMatrix b)
throws IllegalArgumentException, InvalidMatrixException;
private static final long serialVersionUID = 3728473373420246054L;
public static RealMatrix createRealMatrix(double[][] data, boolean copyArray) {
return new RealMatrixImpl(data, copyArray);
double[][] d = new double[dimension][dimension];
d[row][row] = 1d;
return new RealMatrixImpl(d, false);
public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {
return new BigMatrixImpl(data, copyArray);
public static RealVector createRealVector(double[] data) {
return new RealVectorImpl(data, true);
final int nCols = rowData.length;
final double[][] data = new double[1][nCols];
return new RealMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
for (int i = 0; i < nCols; ++i) {
data[0][i] = new BigDecimal(rowData[i]);
return new BigMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
for (int i = 0; i < nCols; ++i) {
data[0][i] = new BigDecimal(rowData[i]);
return new BigMatrixImpl(data, false);
final int nRows = columnData.length;
final double[][] data = new double[nRows][1];
return new RealMatrixImpl(data, false);
final int nRows = columnData.length;
final BigDecimal[][] data = new BigDecimal[nRows][1];
data[row][0] = new BigDecimal(columnData[row]);
return new BigMatrixImpl(data, false);
final int nRows = columnData.length;
final BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data, false);
final BigDecimal[][] data = new BigDecimal[nRows][1];
data[row][0] = new BigDecimal(columnData[row]);
return new BigMatrixImpl(data, false);
final BigDecimal[][] d = new BigDecimal[dimension][dimension];
final BigDecimal[] dRow = d[row];
Arrays.fill(dRow, BigMatrixImpl.ZERO);
dRow[row] = BigMatrixImpl.ONE;
return new BigMatrixImpl(d, false);
public interface QRDecomposition extends DecompositionSolver {
RealMatrix getR();
RealMatrix getQ();
RealMatrix getH();
boolean isFullRank();
private static final long serialVersionUID = 3965943878043764074L;
private final double[][] qr;
private final double[] rDiag;
private RealMatrix cachedQ;
private RealMatrix cachedR;
private RealMatrix cachedH;
private final int m;
private final int n;
cachedQ = null;
cachedR = null;
cachedH = null;
final double c = qr[row][minor];
xNormSqr += c * c;
final double a = (qr[minor][minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
for (int col = minor + 1; col < n; col++) {
final double[] qrRow = qr[row];
alpha -= qrRow[col] * qrRow[minor];
alpha /= a * qr[minor][minor];
final double[] qrRow = qr[row];
qrRow[col] -= alpha * qrRow[minor];
public RealMatrix getR() {
if (cachedR == null) {
double[][] r = new double[m][n];
for (int row = Math.min(m,n)-1; row >= 0; row--) {
final double[] rRow = r[row];
rRow[row] = rDiag[row];
System.arraycopy(qr[row], row + 1, rRow, row + 1, n - row - 1);
cachedR = new RealMatrixImpl(r, false);
return cachedR;
public RealMatrix getQ() {
if (cachedQ == null) {
double[][] Q = new double[m][m];
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
cachedQ = new RealMatrixImpl(Q, false);
return cachedQ;
public RealMatrix getH() {
if (cachedH == null) {
double[][] hData = new double[m][n];
for (int i = 0; i < m; ++i) {
for (int j = 0; j < Math.min(i + 1, n); ++j) {
hData[i][j] = qr[i][j] / -rDiag[j];
cachedH = new RealMatrixImpl(hData, false);
return cachedH;
public boolean isFullRank() {
for (double diag : rDiag) {
if (diag == 0) {
return false;
return true;
public double[] solve(double[] b)
throws IllegalArgumentException, InvalidMatrixException {
if (b.length != m) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!isFullRank()) {
throw new InvalidMatrixException("Matrix is rank-deficient");
final double[] x = new double[n];
final double[] y = b.clone();
for (int minor = 0; minor < Math.min(m, n); minor++) {
double dotProduct = 0;
for (int row = minor; row < m; row++) {
dotProduct += y[row] * qr[row][minor];
dotProduct /= rDiag[minor] * qr[minor][minor];
for (int row = minor; row < m; row++) {
y[row] += dotProduct * qr[row][minor];
for (int row = n - 1; row >= 0; --row) {
y[row] /= rDiag[row];
final double yRow = y[row];
x[row] = yRow;
for (int i = 0; i < row; i++) {
y[i] -= yRow * qr[i][row];
return x;
public RealVector solve(RealVector b)
throws IllegalArgumentException, InvalidMatrixException {
return solve((RealVectorImpl) b);
} catch (ClassCastException cce) {
return new RealVectorImpl(solve(b.getData()), false);
public RealVectorImpl solve(RealVectorImpl b)
throws IllegalArgumentException, InvalidMatrixException {
return new RealVectorImpl(solve(b.getDataRef()), false);
public RealMatrix solve(RealMatrix b)
throws IllegalArgumentException, InvalidMatrixException {
if (b.getRowDimension() != m) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!isFullRank()) {
throw new InvalidMatrixException("Matrix is rank-deficient");
final int cols = b.getColumnDimension();
final double[][] xData = new double[n][cols];
final double[] y = new double[b.getRowDimension()];
for (int k = 0; k < cols; ++k) {
for (int j = 0; j < y.length; ++j) {
y[j] = b.getEntry(j, k);
for (int minor = 0; minor < Math.min(m, n); minor++) {
double dotProduct = 0;
for (int row = minor; row < m; row++) {
dotProduct += y[row] * qr[row][minor];
dotProduct /= rDiag[minor] * qr[minor][minor];
for (int row = minor; row < m; row++) {
y[row] += dotProduct * qr[row][minor];
for (int row = n - 1; row >= 0; --row) {
y[row] /= rDiag[row];
final double yRow = y[row];
xData[row][k] = yRow;
for (int i = 0; i < row; i++) {
y[i] -= yRow * qr[i][row];
return new RealMatrixImpl(xData, false);
RealVector getRowVector(int row) throws MatrixIndexException;
RealVector getColumnVector(int column) throws MatrixIndexException;
RealVector operate(RealVector v) throws IllegalArgumentException;
RealVector preMultiply(RealVector v) throws IllegalArgumentException;
RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException;
private static final long serialVersionUID = 4970229902484487012L;
protected double data[][] = null;
protected double lu[][] = null;
protected int[] permutation = null;
protected int parity = 1;
private static final double TOO_SMALL = 10E-12;
copyIn(d);
lu = null;
public RealMatrixImpl(double[][] d, boolean copyArray) {
if (copyArray) {
copyIn(d);
} else {
if (d == null) {
throw new NullPointerException();
}   
final int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException("Matrix must have at least one row."); 
final int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException("Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (d[r].length != nCols) {
throw new IllegalArgumentException("All input rows must have the same length.");
}       
data = d;
final int nRows = v.length;
return new RealMatrixImpl(copyOut(), false);
return add((RealMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col] + m.getEntry(row, col);
}  
return new RealMatrixImpl(outData, false);
public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] mRow       = m.data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] + mRow[col];
return new RealMatrixImpl(outData, false);
return subtract((RealMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col] - m.getEntry(row, col);
}  
return new RealMatrixImpl(outData, false);
public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] mRow       = m.data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] - mRow[col];
}  
return new RealMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] + d;
return new RealMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] * d;
return new RealMatrixImpl(outData, false);
return multiply((RealMatrixImpl) m);
} catch (ClassCastException cce) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final double[][] outData = new double[nRows][nCols];
for (int row = 0; row < nRows; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nSum; i++) {
sum += dataRow[i] * m.getEntry(i, col);
outDataRow[col] = sum;
return new RealMatrixImpl(outData, false);
public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final double[][] outData = new double[nRows][nCols];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
double sum = 0;
sum += dataRow[i] * m.data[i][col];
outDataRow[col] = sum;
}            
return new RealMatrixImpl(outData, false);
public RealMatrix getSubMatrix(int startRow, int endRow,
int startColumn, int endColumn)
throws MatrixIndexException {
endColumn > data[0].length) {
final double[][] subMatrixData =
new double[endRow - startRow + 1][endColumn - startColumn + 1];
System.arraycopy(data[i], startColumn,
subMatrixData[i - startRow], 0,
endColumn - startColumn + 1);
return new RealMatrixImpl(subMatrixData, false);
throws MatrixIndexException {
final double[][] subMatrixData =
new double[selectedRows.length][selectedColumns.length];
final double[] subI = subMatrixData[i];
final double[] dataSelectedI = data[selectedRows[i]];
subI[j] = dataSelectedI[selectedColumns[j]];
} catch (ArrayIndexOutOfBoundsException e) {
return new RealMatrixImpl(subMatrixData, false);
final int nRows = subMatrix.length;
final int nCols = subMatrix[0].length;
final int ncols = this.getColumnDimension();
final double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out, false);
final int nRows = this.getRowDimension();
final double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out, false);
public RealVector getColumnVector(int column) throws MatrixIndexException {
return new RealVectorImpl(getColumn(column), false);
public RealVector getRowVector(int row) throws MatrixIndexException {
return new RealVectorImpl(getRow(row), false);
final int ncols = this.getColumnDimension();
final double[] out = new double[ncols];
final int nRows = this.getRowDimension();
final double[] out = new double[nRows];
return data[row][column];
} catch (ArrayIndexOutOfBoundsException e) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[][] outData = new double[nCols][nRows];
final double[] dataRow = data[row];
outData[col][row] = dataRow[col];
return new RealMatrixImpl(outData, false);
return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
if (v.length != nCols) {
final double[] out = new double[nRows];
final double[] dataRow = data[row];
sum += dataRow[i] * v[i];
public RealVector operate(RealVector v) throws IllegalArgumentException {
return operate((RealVectorImpl) v);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
if (v.getDimension() != nCols) {
throw new IllegalArgumentException("vector has wrong length");
final double[] out = new double[nRows];
for (int row = 0; row < nRows; row++) {
final double[] dataRow = data[row];
double sum = 0;
for (int i = 0; i < nCols; i++) {
sum += dataRow[i] * v.getEntry(i);
out[row] = sum;
return new RealVectorImpl(out, false);
public RealVectorImpl operate(RealVectorImpl v) throws IllegalArgumentException {
return new RealVectorImpl(operate(v.getDataRef()), false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final double[] out = new double[nCols];
public RealVector preMultiply(RealVector v) throws IllegalArgumentException {
return preMultiply((RealVectorImpl) v);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
if (v.getDimension() != nRows) {
throw new IllegalArgumentException("vector has wrong length");
final int nCols = this.getColumnDimension();
final double[] out = new double[nCols];
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nRows; i++) {
sum += data[i][col] * v.getEntry(i);
out[col] = sum;
return new RealVectorImpl(out, false);
RealVectorImpl preMultiply(RealVectorImpl v) throws IllegalArgumentException {
return new RealVectorImpl(preMultiply(v.getDataRef()), false);
final int nRows = this.getRowDimension();
final int nCol  = this.getColumnDimension();
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[nRows];
bp[row] = b[permutation[row]];
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = nCol - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return bp;
public RealVector solve(RealVector b)
throws IllegalArgumentException, InvalidMatrixException {
return solve((RealVectorImpl) b);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
final int nCol  = this.getColumnDimension();
if (b.getDimension() != nRows) {
throw new IllegalArgumentException("constant vector has wrong length");
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[nRows];
for (int row = 0; row < nRows; row++) {
bp[row] = b.getEntry(permutation[row]);
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = nCol - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return new RealVectorImpl(bp, false);
RealVectorImpl solve(RealVectorImpl b)
throws IllegalArgumentException, InvalidMatrixException {
return new RealVectorImpl(solve(b.getDataRef()), false);
final int nCol  = this.getColumnDimension();
final int nColB = b.getColumnDimension();
final int nRowB = b.getRowDimension();
final double[][] bp = new double[nRowB][nColB];
final double[] bpRow = bp[row];
final int pRow = permutation[row];
bpRow[col] = b.getEntry(pRow, col);
final double[] bpCol = bp[col];
final double[] bpI = bp[i];
final double luICol = lu[i][col];
bpI[j] -= bpCol[j] * luICol;
final double[] bpCol = bp[col];
final double luDiag = lu[col][col];
bpCol[j] /= luDiag;
final double[] bpI = bp[i];
final double luICol = lu[i][col];
bpI[j] -= bpCol[j] * luICol;
return new RealMatrixImpl(bp, false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
lu = getData();
final double[] luRow = lu[row];
sum = luRow[col];
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
final double[] luRow = lu[row];
sum = luRow[col];
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
final double luDiag = lu[col][col];
lu[row][col] /= luDiag;
if (i > 0) {
if (j > 0) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[] dataRow = data[row];
if (Double.doubleToLongBits(dataRow[col]) != 
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[] dataRow = data[row];
for (int col = 0; col < nCols; col++) {
MathUtils.hash(dataRow[col]);
final int[] out = new int[permutation.length];
final int nRows = this.getRowDimension();
final double[][] out = new double[nRows][this.getColumnDimension()];
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
package org.apache.commons.math.linear;
public interface RealVector {
RealVector copy();
RealVector add(RealVector v)
throws IllegalArgumentException;
RealVector subtract(RealVector v)
throws IllegalArgumentException;
RealVector mapAdd(double d);
RealVector mapAddToSelf(double d);
RealVector mapSubtract(double d);
RealVector mapSubtractToSelf(double d);
RealVector mapMultiply(double d);
RealVector mapMultiplyToSelf(double d);
RealVector mapDivide(double d);
RealVector mapDivideToSelf(double d);
RealVector mapPow(double d);
RealVector mapPowToSelf(double d);
RealVector mapExp();
RealVector mapExpToSelf();
RealVector mapExpm1();
RealVector mapExpm1ToSelf();
RealVector mapLog();
RealVector mapLogToSelf();
RealVector mapLog10();
RealVector mapLog10ToSelf();
RealVector mapLog1p();
RealVector mapLog1pToSelf();
RealVector mapCosh();
RealVector mapCoshToSelf();
RealVector mapSinh();
RealVector mapSinhToSelf();
RealVector mapTanh();
RealVector mapTanhToSelf();
RealVector mapCos();
RealVector mapCosToSelf();
RealVector mapSin();
RealVector mapSinToSelf();
RealVector mapTan();
RealVector mapTanToSelf();
RealVector mapAcos();
RealVector mapAcosToSelf();
RealVector mapAsin();
RealVector mapAsinToSelf();
RealVector mapAtan();
RealVector mapAtanToSelf();
RealVector mapInv();
RealVector mapInvToSelf();
RealVector mapAbs();
RealVector mapAbsToSelf();
RealVector mapSqrt();
RealVector mapSqrtToSelf();
RealVector mapCbrt();
RealVector mapCbrtToSelf();
RealVector mapCeil();
RealVector mapCeilToSelf();
RealVector mapFloor();
RealVector mapFloorToSelf();
RealVector mapRint();
RealVector mapRintToSelf();
RealVector mapSignum();
RealVector mapSignumToSelf();
RealVector mapUlp();
RealVector mapUlpToSelf();
public RealVector ebeMultiply(RealVector v)
throws IllegalArgumentException;
public RealVector ebeDivide(RealVector v)
throws IllegalArgumentException;
double[] getData();
double dotProduct(RealVector v)
throws IllegalArgumentException;
double getNorm();
double getL1Norm();
double getLInfNorm();
double getDistance(RealVector v)
throws IllegalArgumentException;
double getL1Distance(RealVector v)
throws IllegalArgumentException;
double getLInfDistance(RealVector v)
throws IllegalArgumentException;
RealVector unitVector();
void unitize();
RealVector projection(RealVector v)
throws IllegalArgumentException;
RealMatrix outerProduct(RealVector v)
throws IllegalArgumentException;
double getEntry(int index)
throws MatrixIndexException;
int getDimension();
RealVector append(RealVector v);
RealVector append(double d);
RealVector append(double[] a);
RealVector get(int index, int n)
throws MatrixIndexException;
void set(int index, double value)
throws MatrixIndexException;
void set(int index, RealVector v)
throws MatrixIndexException;
void set(double value);
double[] toArray();
public boolean isNaN();
public boolean isInfinite();
package org.apache.commons.math.linear;
public class RealVectorFormat extends CompositeFormat {
private static final long serialVersionUID = -708767813036157690L;
private static final String DEFAULT_PREFIX = "{";
private static final String DEFAULT_SUFFIX = "}";
private static final String DEFAULT_SEPARATOR = "; ";
private final String prefix;
private final String suffix;
private final String separator;
private final String trimmedPrefix;
private final String trimmedSuffix;
private final String trimmedSeparator;
private NumberFormat format;
public RealVectorFormat() {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());
public RealVectorFormat(final NumberFormat format) {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);
public RealVectorFormat(final String prefix, final String suffix,
final String separator) {
this(prefix, suffix, separator, getDefaultNumberFormat());
public RealVectorFormat(final String prefix, final String suffix,
final String separator, final NumberFormat format) {
this.prefix      = prefix;
this.suffix      = suffix;
this.separator   = separator;
trimmedPrefix    = prefix.trim();
trimmedSuffix    = suffix.trim();
trimmedSeparator = separator.trim();
this.format      = format;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public String getPrefix() {
return prefix;
public String getSuffix() {
return suffix;
public String getSeparator() {
return separator;
public NumberFormat getFormat() {
return format;
public static RealVectorFormat getInstance() {
return getInstance(Locale.getDefault());
public static RealVectorFormat getInstance(final Locale locale) {
return new RealVectorFormat(getDefaultNumberFormat(locale));
public static String formatRealVector(RealVector v) {
return getInstance().format(v);
public StringBuffer format(RealVector vector, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
toAppendTo.append(prefix);
for (int i = 0; i < vector.getDimension(); ++i) {
if (i > 0) {
toAppendTo.append(separator);
formatDouble(vector.getEntry(i), format, toAppendTo, pos);
toAppendTo.append(suffix);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
if (obj instanceof RealVector) {
return format( (RealVector)obj, toAppendTo, pos);
throw new IllegalArgumentException("Cannot format given Object as a RealVector");
public RealVectorImpl parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
RealVectorImpl result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable real vector: \"" + source +
"\"", parsePosition.getErrorIndex());
return result;
public RealVectorImpl parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedPrefix, pos)) {
return null;
List<Number> components = new ArrayList<Number>();
for (boolean loop = true; loop;){
if (!components.isEmpty()) {
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
loop = false;
if (loop) {
parseAndIgnoreWhitespace(source, pos);
Number component = parseNumber(source, format, pos);
if (component != null) {
components.add(component);
} else {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSuffix, pos)) {
return null;
double[] data = new double[components.size()];
for (int i = 0; i < data.length; ++i) {
data[i] = components.get(i).doubleValue();
return new RealVectorImpl(data, false);
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
public class RealVectorImpl implements RealVector, Serializable {
private static final long serialVersionUID = 7838747548772166404L;
private static final RealVectorFormat DEFAULT_FORMAT =
RealVectorFormat.getInstance();
protected double data[];
public RealVectorImpl() {
data = new double[0];
public RealVectorImpl(int size) {
data = new double[size];
public RealVectorImpl(int size, double preset) {
data = new double[size];
Arrays.fill(data, preset);
public RealVectorImpl(double[] d) {
data = d.clone();
public RealVectorImpl(double[] d, boolean copyArray)
throws NullPointerException, IllegalArgumentException {
if (d == null) {
throw new NullPointerException();
}   
if (d.length == 0) {
throw new IllegalArgumentException("Vector must have at least one element."); 
data = copyArray ? d.clone() :  d;
public RealVectorImpl(double[] d, int pos, int size) {
if (d.length < pos + size) {
throw new IllegalArgumentException("Position " + pos + " and size " + size +
" don't fit to the size of the input array " +
d.length);
data = new double[size];
System.arraycopy(d, pos, data, 0, size);
public RealVectorImpl(Double[] d) {
data = new double[d.length];
for (int i = 0; i < d.length; i++) {
data[i] = d[i].doubleValue();
public RealVectorImpl(Double[] d, int pos, int size) {
if (d.length < pos + size) {
throw new IllegalArgumentException("Position " + pos + " and size " + size +
" don't fit to the size of the input array " +
d.length);
data = new double[size];
for (int i = pos; i < pos + size; i++) {
data[i-pos] = d[i].doubleValue();
public RealVectorImpl(RealVector v) {
data = new double[v.getDimension()];
for (int i = 0; i < data.length; ++i) {
data[i] = v.getEntry(i);
public RealVectorImpl(RealVectorImpl v) {
data = v.data.clone();
public RealVectorImpl(RealVectorImpl v, boolean deep) {
data = deep ? v.data.clone() : v.data;
public RealVectorImpl(RealVectorImpl v1, RealVectorImpl v2) {
data = new double[v1.data.length + v2.data.length];
System.arraycopy(v1.data, 0, data, 0, v1.data.length);
System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);
public RealVector copy() {
return new RealVectorImpl(this, true);
public RealVector add(RealVector v)
throws IllegalArgumentException {
return add((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl add(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + v.data[i];
return new RealVectorImpl(out);
public RealVector subtract(RealVector v)
throws IllegalArgumentException {
return subtract((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl subtract(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - v.data[i];
return new RealVectorImpl(out);
public RealVector mapAdd(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + d;
return new RealVectorImpl(out);
public RealVector mapAddToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] + d;
return this;
public RealVector mapSubtract(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - d;
return new RealVectorImpl(out);
public RealVector mapSubtractToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] - d;
return this;
public RealVector mapMultiply(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * d;
return new RealVectorImpl(out);
public RealVector mapMultiplyToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] * d;
return this;
public RealVector mapDivide(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / d;
return new RealVectorImpl(out);
public RealVector mapDivideToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] / d;
return this;
public RealVector mapPow(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.pow(data[i], d);
return new RealVectorImpl(out);
public RealVector mapPowToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = Math.pow(data[i], d);
return this;
public RealVector mapExp() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.exp(data[i]);
return new RealVectorImpl(out);
public RealVector mapExpToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.exp(data[i]);
return this;
public RealVector mapExpm1() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.expm1(data[i]);
return new RealVectorImpl(out);
public RealVector mapExpm1ToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.expm1(data[i]);
return this;
public RealVector mapLog() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log(data[i]);
return new RealVectorImpl(out);
public RealVector mapLogToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log(data[i]);
return this;
public RealVector mapLog10() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log10(data[i]);
return new RealVectorImpl(out);
public RealVector mapLog10ToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log10(data[i]);
return this;
public RealVector mapLog1p() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log1p(data[i]);
return new RealVectorImpl(out);
public RealVector mapLog1pToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log1p(data[i]);
return this;
public RealVector mapCosh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cosh(data[i]);
return new RealVectorImpl(out);
public RealVector mapCoshToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cosh(data[i]);
return this;
public RealVector mapSinh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sinh(data[i]);
return new RealVectorImpl(out);
public RealVector mapSinhToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sinh(data[i]);
return this;
public RealVector mapTanh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.tanh(data[i]);
return new RealVectorImpl(out);
public RealVector mapTanhToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.tanh(data[i]);
return this;
public RealVector mapCos() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cos(data[i]);
return new RealVectorImpl(out);
public RealVector mapCosToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cos(data[i]);
return this;
public RealVector mapSin() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sin(data[i]);
return new RealVectorImpl(out);
public RealVector mapSinToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sin(data[i]);
return this;
public RealVector mapTan() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.tan(data[i]);
return new RealVectorImpl(out);
public RealVector mapTanToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.tan(data[i]);
return this;
public RealVector mapAcos() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.acos(data[i]);
return new RealVectorImpl(out);
public RealVector mapAcosToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.acos(data[i]);
return this;
public RealVector mapAsin() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.asin(data[i]);
return new RealVectorImpl(out);
public RealVector mapAsinToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.asin(data[i]);
return this;
public RealVector mapAtan() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.atan(data[i]);
return new RealVectorImpl(out);
public RealVector mapAtanToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.atan(data[i]);
return this;
public RealVector mapInv() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = 1.0 / data[i];
return new RealVectorImpl(out);
public RealVector mapInvToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = 1.0 / data[i];
return this;
public RealVector mapAbs() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.abs(data[i]);
return new RealVectorImpl(out);
public RealVector mapAbsToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.abs(data[i]);
return this;
public RealVector mapSqrt() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sqrt(data[i]);
return new RealVectorImpl(out);
public RealVector mapSqrtToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sqrt(data[i]);
return this;
public RealVector mapCbrt() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cbrt(data[i]);
return new RealVectorImpl(out);
public RealVector mapCbrtToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cbrt(data[i]);
return this;
public RealVector mapCeil() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.ceil(data[i]);
return new RealVectorImpl(out);
public RealVector mapCeilToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.ceil(data[i]);
return this;
public RealVector mapFloor() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.floor(data[i]);
return new RealVectorImpl(out);
public RealVector mapFloorToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.floor(data[i]);
return this;
public RealVector mapRint() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.rint(data[i]);
return new RealVectorImpl(out);
public RealVector mapRintToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.rint(data[i]);
return this;
public RealVector mapSignum() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.signum(data[i]);
return new RealVectorImpl(out);
public RealVector mapSignumToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.signum(data[i]);
return this;
public RealVector mapUlp() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.ulp(data[i]);
return new RealVectorImpl(out);
public RealVector mapUlpToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.ulp(data[i]);
return this;
public RealVector ebeMultiply(RealVector v)
throws IllegalArgumentException {
return ebeMultiply((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl ebeMultiply(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * v.data[i];
return new RealVectorImpl(out);
public RealVector ebeDivide(RealVector v)
throws IllegalArgumentException {
return ebeDivide((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl ebeDivide(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / v.data[i];
return new RealVectorImpl(out);
public double[] getData() {
return data.clone();
public double[] getDataRef() {
return data;
public double dotProduct(RealVector v)
throws IllegalArgumentException {
return dotProduct((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double dotProduct(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double getNorm() {
double sum = 0;
for (double a : data) {
sum += a * a;
return Math.sqrt(sum);
public double getL1Norm() {
double sum = 0;
for (double a : data) {
sum += Math.abs(a);
return sum;
public double getLInfNorm() {
double max = 0;
for (double a : data) {
max += Math.max(max, Math.abs(a));
return max;
public double getDistance(RealVector v)
throws IllegalArgumentException {
return getDistance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
sum += delta * delta;
return Math.sqrt(sum);
public double getDistance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
sum += delta * delta;
return Math.sqrt(sum);
public double getL1Distance(RealVector v)
throws IllegalArgumentException {
return getL1Distance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
sum += Math.abs(delta);
return sum;
public double getL1Distance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
sum += Math.abs(delta);
return sum;
public double getLInfDistance(RealVector v)
throws IllegalArgumentException {
return getLInfDistance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double max = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
max = Math.max(max, Math.abs(delta));
return max;
public double getLInfDistance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double max = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
max = Math.max(max, Math.abs(delta));
return max;
public RealVector unitVector() throws ArithmeticException {
final double norm = getNorm();
if (norm == 0) {
throw new ArithmeticException("null norm");
return mapDivide(getNorm());
public void unitize() throws ArithmeticException {
final double norm = getNorm();
if (norm == 0) {
throw new ArithmeticException("null norm");
for (int i = 0; i < data.length; i++) {
data[i] /= norm;
public RealVector projection(RealVector v) {
return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
public RealVectorImpl projection(RealVectorImpl v) {
return (RealVectorImpl) v.mapMultiply(dotProduct(v) / v.dotProduct(v));
public RealMatrix outerProduct(RealVector v)
throws IllegalArgumentException {
return outerProduct((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[][] out = new double[data.length][data.length];
for (int i = 0; i < data.length; i++) {
for (int j = 0; j < data.length; j++) {
out[i][j] = data[i] * v.getEntry(j);
return new RealMatrixImpl(out);
public RealMatrixImpl outerProduct(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[][] out = new double[data.length][data.length];
for (int i = 0; i < data.length; i++) {
for (int j = 0; j < data.length; j++) {
out[i][j] = data[i] * v.data[j];
return new RealMatrixImpl(out);
public double getEntry(int index) throws MatrixIndexException {
return data[index];
public int getDimension() {
return data.length;
public RealVector append(RealVector v) {
return append((RealVectorImpl) v);
} catch (ClassCastException cce) {
return new RealVectorImpl(this,new RealVectorImpl(v));
public RealVectorImpl append(RealVectorImpl v) {
return new RealVectorImpl(this, v);
public RealVector append(double in) {
final double[] out = new double[data.length + 1];
System.arraycopy(data, 0, out, 0, data.length);
out[data.length] = in;
return new RealVectorImpl(out);
public RealVector append(double[] in) {
final double[] out = new double[data.length + in.length];
System.arraycopy(data, 0, out, 0, data.length);
System.arraycopy(in, 0, out, data.length, in.length);
return new RealVectorImpl(out);
public RealVector get(int index, int n) {
RealVectorImpl out = new RealVectorImpl(n);
System.arraycopy(data, index, out.data, 0, n);
return out;
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, double value) {
data[index] = value;
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, RealVector v) {
set(index, (RealVectorImpl) v);
} catch (ClassCastException cce) {
for (int i = index; i < index + v.getDimension(); ++i) {
data[i] = v.getEntry(i-index);
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, RealVectorImpl v)
throws MatrixIndexException {
System.arraycopy(v.data, 0, data, index, v.data.length);
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(double value) {
Arrays.fill(data, value);
public double[] toArray(){
return data.clone();
public String toString(){
return DEFAULT_FORMAT.format(this);
public void checkVectorDimensions(RealVector v)
throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
public void checkVectorDimensions(int n)
throws IllegalArgumentException {
if (data.length != n) {
throw new IllegalArgumentException("vector dimension is " + data.length +
", not " + n + " as expected");
public boolean isNaN() {
for (double v : data) {
if (Double.isNaN(v)) {
return true;
return false;
public boolean isInfinite() {
if (isNaN()) {
return false;
for (double v : data) {
if (Double.isInfinite(v)) {
return true;
return false;
public boolean equals(Object other) {
if (this == other) { 
return true;
if (other == null) {
return false;
RealVector rhs = (RealVector) other;
if (data.length != rhs.getDimension()) {
return false;
if (rhs.isNaN()) {
return this.isNaN();
for (int i = 0; i < data.length; ++i) {
if (Double.doubleToRawLongBits(data[i]) !=
Double.doubleToRawLongBits(rhs.getEntry(i))) {
return false;
return true;
} catch (ClassCastException ex) {
return false;
public int hashCode() {
if (isNaN()) {
return 9;
return MathUtils.hash(data);
package org.apache.commons.math.ode;
public abstract class AbstractIntegrator implements FirstOrderIntegrator {
private final String name;
protected Collection<StepHandler> stepHandlers;
protected double stepStart;
protected double stepSize;
protected CombinedEventsManager eventsHandlersManager;
public AbstractIntegrator(final String name) {
this.name = name;
stepHandlers = new ArrayList<StepHandler>();
stepStart = Double.NaN;
stepSize  = Double.NaN;
eventsHandlersManager = new CombinedEventsManager();
public String getName() {
return name;
public void addStepHandler(final StepHandler handler) {
stepHandlers.add(handler);
public Collection<StepHandler> getStepHandlers() {
return Collections.unmodifiableCollection(stepHandlers);
public void clearStepHandlers() {
stepHandlers.clear();
public void addEventHandler(final EventHandler function,
final double maxCheckInterval,
final double convergence,
final int maxIterationCount) {
eventsHandlersManager.addEventHandler(function, maxCheckInterval,
convergence, maxIterationCount);
public Collection<EventHandler> getEventHandlers() {
return eventsHandlersManager.getEventsHandlers();
public void clearEventHandlers() {
eventsHandlersManager.clearEventsHandlers();
protected boolean requiresDenseOutput() {
for (StepHandler handler : stepHandlers) {
if (handler.requiresDenseOutput()) {
return true;
return false;
public double getCurrentStepStart() {
return stepStart;
public double getCurrentSignedStepsize() {
return stepSize;
protected void sanityChecks(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y.length)
});
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
Double.valueOf(Math.abs(t - t0))
});
protected CombinedEventsManager addEndTimeChecker(final double startTime,
final double endTime,
final CombinedEventsManager manager) {
CombinedEventsManager newManager = new CombinedEventsManager();
for (final EventState state : manager.getEventsStates()) {
newManager.addEventHandler(state.getEventHandler(),
state.getMaxCheckInterval(),
state.getConvergence(),
state.getMaxIterationCount());
newManager.addEventHandler(new EndTimeChecker(endTime),
Double.POSITIVE_INFINITY,
Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),
100);
return newManager;
private static class EndTimeChecker implements EventHandler {
private static final long serialVersionUID = -5211782540446301964L;
private final double endTime;
public EndTimeChecker(final double endTime) {
this.endTime = endTime;
public int eventOccurred(double t, double[] y) {
return STOP;
public double g(double t, double[] y) {
return t - endTime;
public void resetState(double t, double[] y) {
steps = new ArrayList<StepInterpolator>();
public void append(final ContinuousOutputModel model)
final StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
final double current  = lastInterpolator.getCurrentTime();
final double previous = lastInterpolator.getPreviousTime();
final double step = current - previous;
final double gap = model.getInitialTime() - current;
for (StepInterpolator interpolator : model.steps) {
steps.add(interpolator.copy());
public void handleStep(final StepInterpolator interpolator, final boolean isLast)
steps.add(interpolator.copy());
finalTime = interpolator.getCurrentTime();
return steps.get(index).getInterpolatedTime();
public void setInterpolatedTime(final double time) {
final StepInterpolator sMin = steps.get(iMin);
final StepInterpolator sMax = steps.get(iMax);
final StepInterpolator si = steps.get(index);
final int location = locatePoint(time, si);
final int iMed = (iMin + iMax) / 2;
final StepInterpolator sMed = steps.get(iMed);
final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
final double d12 = tMax - tMed;
final double d23 = tMed - tMin;
final double d13 = tMax - tMin;
final double dt1 = time - tMax;
final double dt2 = time - tMed;
final double dt3 = time - tMin;
final double iLagrange = ((dt2 * dt3 * d23) * iMax -
(dt1 * dt3 * d13) * iMed +
(dt1 * dt2 * d12) * iMin) /
(d12 * d23 * d13);
final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {
steps.get(index).setInterpolatedTime(time);
return steps.get(index).getInterpolatedState();
private int locatePoint(final double time, final StepInterpolator interval) {
private List<StepInterpolator> steps;
private static final long serialVersionUID = -1417964919405031606L;
public DerivativeException(final String specifier, final Object[] parts) {
public DerivativeException(final Throwable cause) {
private static final long serialVersionUID = -8233657110042144146L;
public FirstOrderConverter (final SecondOrderDifferentialEquations equations) {
public void computeDerivatives(final double t, final double[] y, final double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations extends Serializable {
public interface FirstOrderIntegrator extends ODEIntegrator {
public double integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public IntegratorException(final String specifier, final Object[] parts) {
public IntegratorException(final Throwable cause) {
package org.apache.commons.math.ode;
public interface ODEIntegrator extends Serializable {
String getName();
void addStepHandler(StepHandler handler);
Collection<StepHandler> getStepHandlers();
void clearStepHandlers();
void addEventHandler(EventHandler handler,
double maxCheckInterval,
double convergence,
int maxIterationCount);
Collection<EventHandler> getEventHandlers();
void clearEventHandlers();
double getCurrentStepStart();
double getCurrentSignedStepsize();
public interface SecondOrderIntegrator extends ODEIntegrator {
package org.apache.commons.math.ode.events;
public class CombinedEventsManager implements Serializable {
private static final long serialVersionUID = -4151965151236441261L;
private final List<EventState> states;
private EventState first;
private boolean initialized;
public CombinedEventsManager() {
states      = new ArrayList<EventState>();
first       = null;
initialized = false;
public void addEventHandler(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
states.add(new EventState(handler, maxCheckInterval,
convergence, maxIterationCount));
public Collection<EventHandler> getEventsHandlers() {
final List<EventHandler> list = new ArrayList<EventHandler>();
for (EventState state : states) {
list.add(state.getEventHandler());
return Collections.unmodifiableCollection(list);
public void clearEventsHandlers() {
states.clear();
public Collection<EventState> getEventsStates() {
return states;
public boolean isEmpty() {
return states.isEmpty();
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, IntegratorException {
first = null;
if (states.isEmpty()) {
return false;
if (! initialized) {
final double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
final double [] y = interpolator.getInterpolatedState();
for (EventState state : states) {
state.reinitializeBegin(t0, y);
initialized = true;
for (EventState state : states) {
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
} else {
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
} else {
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
} catch (EventException se) {
throw new IntegratorException(se);
} catch (ConvergenceException ce) {
throw new IntegratorException(ce);
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
public void stepAccepted(final double t, final double[] y)
throws IntegratorException {
for (EventState state : states) {
state.stepAccepted(t, y);
} catch (EventException se) {
throw new IntegratorException(se);
public boolean stop() {
for (EventState state : states) {
if (state.stop()) {
return true;
return false;
public boolean reset(final double t, final double[] y)
throws IntegratorException {
boolean resetDerivatives = false;
for (EventState state : states) {
if (state.reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
} catch (EventException se) {
throw new IntegratorException(se);
package org.apache.commons.math.ode.events;
public class EventException extends MathException {
private static final long serialVersionUID = -898215297400035290L;
public EventException(final String specifier, final Object[] parts) {
super(specifier, parts);
public EventException(final Throwable cause) {
super(cause);
package org.apache.commons.math.ode.events;
public interface EventHandler extends Serializable {
public double g(double t, double[] y) throws EventException;
public int eventOccurred(double t, double[] y) throws EventException;
public void resetState(double t, double[] y) throws EventException;
package org.apache.commons.math.ode.events;
public class EventState implements Serializable {
private static final long serialVersionUID = -216176055159247559L;
private final EventHandler handler;
private final double maxCheckInterval;
private final double convergence;
private final int maxIterationCount;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
public EventState(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
this.handler           = handler;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = EventHandler.CONTINUE;
public EventHandler getEventHandler() {
return handler;
public double getMaxCheckInterval() {
return maxCheckInterval;
public double getConvergence() {
return convergence;
public int getMaxIterationCount() {
return maxIterationCount;
public void reinitializeBegin(final double t0, final double[] y0)
throws EventException {
this.t0 = t0;
g0 = handler.g(t0, y0);
g0Positive = (g0 >= 0);
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, EventException, ConvergenceException {
final double t1 = interpolator.getCurrentTime();
final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
final double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
final double gb = handler.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
final UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(final double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return handler.g(t, interpolator.getInterpolatedState());
} catch (DerivativeException e) {
throw new FunctionEvaluationException(t, e);
} catch (EventException e) {
throw new FunctionEvaluationException(t, e);
});
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(maxIterationCount);
final double root = (ta <= tb) ? solver.solve(ta, tb) : solver.solve(tb, ta);
if (Math.abs(root - ta) <= convergence) {
ta = tb;
ga = gb;
} else if (Double.isNaN(previousEventTime) ||
(Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
} else {
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
} catch (FunctionEvaluationException e) {
final Throwable cause = e.getCause();
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
} else if ((cause != null) && (cause instanceof EventException)) {
throw (EventException) cause;
throw new EventException(e);
public double getEventTime() {
return pendingEventTime;
public void stepAccepted(final double t, final double[] y)
throws EventException {
t0 = t;
g0 = handler.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = handler.eventOccurred(t, y);
} else {
g0Positive = (g0 >= 0);
nextAction = EventHandler.CONTINUE;
public boolean stop() {
return nextAction == EventHandler.STOP;
public boolean reset(final double t, final double[] y)
throws EventException {
if (! pendingEvent) {
return false;
if (nextAction == EventHandler.RESET_STATE) {
handler.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
return (nextAction == EventHandler.RESET_STATE) ||
(nextAction == EventHandler.RESET_DERIVATIVES);
package org.apache.commons.math.ode.nonstiff;
public class AdamsBashforthIntegrator extends MultistepIntegrator {
private static final long serialVersionUID = 1676381657635800870L;
private static final String METHOD_NAME = "Adams-Bashforth";
private final double[] coeffs;
private final double step;
public AdamsBashforthIntegrator(final int order, final double step) {
super(METHOD_NAME, order, new AdamsBashforthStepInterpolator());
int[][] bdArray = computeBackwardDifferencesArray(order);
Fraction[] gamma = computeGammaArray(order);
coeffs = new double[order];
for (int i = 0; i < order; ++i) {
Fraction f = Fraction.ZERO;
for (int j = i; j < order; ++j) {
f = f.add(gamma[j].multiply(new Fraction(bdArray[j][i], 1)));
coeffs[i] = f.doubleValue();
this.step = step;
public double integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[] yTmp = new double[y0.length];
final AdamsBashforthStepInterpolator interpolator =
(AdamsBashforthStepInterpolator) prototype.copy();
interpolator.reinitialize(yTmp, previousT, previousF, forward);
stepStart = t0;
stepSize  = step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
double stopTime =
start(previousF.length, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
interpolator.storeTime(stepStart);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < coeffs.length; ++l) {
sum += coeffs[l] * previousF[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
final boolean truncated;
if (manager.evaluateStep(interpolator)) {
truncated = true;
interpolator.truncateStep(manager.getEventTime());
} else {
truncated = false;
final double nextStep = interpolator.getCurrentTime();
interpolator.setInterpolatedTime(nextStep);
System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (!lastStep) {
if (manager.reset(stepStart, y)) {
stopTime =
start(previousF.length, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
} else {
if (truncated) {
for (int i = 1; i < previousF.length; ++i) {
previousT[i] = stepStart - i * stepSize;
interpolator.setInterpolatedTime(previousT[i]);
System.arraycopy(interpolator.getInterpolatedState(), 0,
previousF[i], 0, y0.length);
} else {
rotatePreviousSteps();
previousT[0] = stepStart;
equations.computeDerivatives(stepStart, y, previousF[0]);
stopTime  = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
public double[] getCoeffs() {
return coeffs.clone();
int[][] bdArray = new int[order][];
bdArray[0] = new int[] { 1 };
for (int i = 1; i < order; ++i) {
bdArray[i] = new int[i + 1];
bdArray[i][0] = 1;
for (int j = 0; j < i - 1; ++j) {
bdArray[i][j + 1] = bdArray[i - 1][j + 1] - bdArray[i - 1][j];
bdArray[i][i] = -bdArray[i - 1][i - 1];
return bdArray;
Fraction[] gammaArray = new Fraction[order];
gammaArray[0] = Fraction.ONE;
for (int i = 1; i < order; ++i) {
Fraction gamma = Fraction.ONE;
for (int j = 1; j <= i; ++j) {
gamma = gamma.subtract(gammaArray[i - j].multiply(new Fraction(1, j + 1)));
gammaArray[i] = gamma;
return gammaArray;
package org.apache.commons.math.ode.nonstiff;
class AdamsBashforthStepInterpolator extends MultistepStepInterpolator {
private static final long serialVersionUID = -7179861704951334960L;
private double[] neville;
private double[] rollback;
private double[] gamma;
private int[][] bdArray;
private double nonTruncatedEnd;
private double nonTruncatedH;
public AdamsBashforthStepInterpolator() {
public AdamsBashforthStepInterpolator(final AdamsBashforthStepInterpolator interpolator) {
super(interpolator);
nonTruncatedEnd = interpolator.nonTruncatedEnd;
nonTruncatedH   = interpolator.nonTruncatedH;
protected StepInterpolator doCopy() {
return new AdamsBashforthStepInterpolator(this);
protected void initializeCoefficients() {
neville  = new double[previousF.length];
rollback = new double[previousF.length];
bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);
Fraction[] fGamma = AdamsBashforthIntegrator.computeGammaArray(previousF.length);
gamma = new double[fGamma.length];
for (int i = 0; i < fGamma.length; ++i) {
gamma[i] = fGamma[i].doubleValue();
public void storeTime(final double t) {
nonTruncatedEnd = t;
nonTruncatedH   = nonTruncatedEnd - previousTime;
super.storeTime(t);
void truncateStep(final double truncatedEndTime) {
currentTime = truncatedEndTime;
h = currentTime - previousTime;
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;
final double theta = (nonTruncatedH == 0) ?
0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;
computeInterpolatedState(theta, oneMinusThetaH);
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {
interpolateDerivatives();
interpolateState(theta);
private void interpolateDerivatives() {
for (int i = 0; i < interpolatedDerivatives.length; ++i) {
for (int k = 0; k < previousF.length; ++k) {
neville[k] = previousF[k][i];
for (int l = 1; l < neville.length; ++l) {
for (int m = neville.length - 1; m >= l; --m) {
final double xm   = previousT[m];
final double xmMl = previousT[m - l];
neville[m] = ((interpolatedTime - xm) * neville[m-1] +
(xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);
interpolatedDerivatives[i] = neville[neville.length - 1];
private void interpolateState(final double theta) {
computeRollback(previousT.length - 1, theta);
for (int j = 0; j < interpolatedState.length; ++j) {
double sum = 0;
for (int l = 0; l < previousT.length; ++l) {
sum += rollback[l] * previousF[l][j];
interpolatedState[j] = currentState[j] - h * sum;
private void computeRollback(final int order, final double theta) {
double product = theta;
rollback[0]  = theta;
for (int i = 1; i < order; ++i) {
product *= (i + theta) / (i + 1);
double g = product;
for (int j = 1; j <= i; ++j) {
g -= rollback[i - j] / (j + 1);
rollback[i] = g;
for (int i = 0; i < order; ++i) {
rollback[i] -= gamma[i];
for (int i = 0; i < order; ++i) {
double f = 0;
for (int j = i; j <= order; ++j) {
f -= rollback[j] * bdArray[j][i];
rollback[i] = f;
public void writeExternal(final ObjectOutput out)
throws IOException {
super.writeExternal(out);
out.writeDouble(nonTruncatedEnd);
public void readExternal(final ObjectInput in)
throws IOException {
nonTruncatedEnd = in.readDouble();
package org.apache.commons.math.ode.nonstiff;
public class AdamsMoultonIntegrator extends MultistepIntegrator {
private static final long serialVersionUID = 4990335331377040417L;
private static final String METHOD_NAME = "Adams-Moulton";
private final double[] predictorCoeffs;
private final double[] correctorCoeffs;
private final double step;
public AdamsMoultonIntegrator(final int order, final double step) {
super(METHOD_NAME, order + 1, new AdamsMoultonStepInterpolator());
int[][] bdArray      = AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);
Fraction[] gamma     = AdamsBashforthIntegrator.computeGammaArray(order);
predictorCoeffs = new double[order];
for (int i = 0; i < order; ++i) {
Fraction fPredictor = Fraction.ZERO;
for (int j = i; j < order; ++j) {
Fraction f = new Fraction(bdArray[j][i], 1);
fPredictor = fPredictor.add(gamma[j].multiply(f));
predictorCoeffs[i] = fPredictor.doubleValue();
Fraction[] gammaStar = computeGammaStarArray(order);
correctorCoeffs = new double[order + 1];
for (int i = 0; i <= order; ++i) {
Fraction fCorrector = Fraction.ZERO;
for (int j = i; j <= order; ++j) {
Fraction f = new Fraction(bdArray[j][i], 1);
fCorrector = fCorrector.add(gammaStar[j].multiply(f));
correctorCoeffs[i] = fCorrector.doubleValue();
this.step = step;
public double integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[] yTmp = new double[y0.length];
final AdamsMoultonStepInterpolator interpolator =
(AdamsMoultonStepInterpolator) prototype.copy();
interpolator.reinitialize(yTmp, previousT, previousF, forward);
stepStart = t0;
stepSize  = step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
double stopTime =
start(previousF.length - 1, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
rotatePreviousSteps();
previousF[0] = new double[y0.length];
interpolator.storeTime(stepStart);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < predictorCoeffs.length; ++l) {
sum += predictorCoeffs[l] * previousF[l+1][j];
yTmp[j] = y[j] + stepSize * sum;
final double stepEnd = stepStart + stepSize;
equations.computeDerivatives(stepEnd, yTmp, previousF[0]);
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < correctorCoeffs.length; ++l) {
sum += correctorCoeffs[l] * previousF[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepEnd);
final boolean truncated;
if (manager.evaluateStep(interpolator)) {
truncated = true;
interpolator.truncateStep(manager.getEventTime());
} else {
truncated = false;
final double nextStep = interpolator.getCurrentTime();
interpolator.setInterpolatedTime(nextStep);
System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (!lastStep) {
if (manager.reset(stepStart, y)) {
stopTime =
start(previousF.length - 1, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
rotatePreviousSteps();
previousF[0] = new double[y0.length];
} else {
if (truncated) {
for (int i = 1; i < previousF.length; ++i) {
previousT[i] = stepStart - i * stepSize;
interpolator.setInterpolatedTime(previousT[i]);
System.arraycopy(interpolator.getInterpolatedState(), 0,
previousF[i], 0, y0.length);
} else {
rotatePreviousSteps();
previousT[0] = stepStart;
equations.computeDerivatives(stepStart, y, previousF[0]);
stopTime  = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
public double[] getPredictorCoeffs() {
return predictorCoeffs.clone();
public double[] getCorrectorCoeffs() {
return correctorCoeffs.clone();
Fraction[] gammaStarArray = new Fraction[order + 1];
gammaStarArray[0] = Fraction.ONE;
for (int i = 1; i <= order; ++i) {
Fraction gammaStar = Fraction.ZERO;
for (int j = 1; j <= i; ++j) {
gammaStar = gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1, j + 1)));
gammaStarArray[i] = gammaStar;
return gammaStarArray;
package org.apache.commons.math.ode.nonstiff;
class AdamsMoultonStepInterpolator extends MultistepStepInterpolator {
private static final long serialVersionUID = 735568489801241899L;
private double[] neville;
private double[] rollback;
private double[] gammaStar;
private int[][] bdArray;
private double nonTruncatedEnd;
private double nonTruncatedH;
public AdamsMoultonStepInterpolator() {
public AdamsMoultonStepInterpolator(final AdamsMoultonStepInterpolator interpolator) {
super(interpolator);
nonTruncatedEnd = interpolator.nonTruncatedEnd;
nonTruncatedH   = interpolator.nonTruncatedH;
protected StepInterpolator doCopy() {
return new AdamsMoultonStepInterpolator(this);
protected void initializeCoefficients() {
neville  = new double[previousF.length];
rollback = new double[previousF.length];
bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);
Fraction[] fGammaStar = AdamsMoultonIntegrator.computeGammaStarArray(previousF.length);
gammaStar = new double[fGammaStar.length];
for (int i = 0; i < fGammaStar.length; ++i) {
gammaStar[i] = fGammaStar[i].doubleValue();
public void storeTime(final double t) {
nonTruncatedEnd = t;
nonTruncatedH   = nonTruncatedEnd - previousTime;
super.storeTime(t);
void truncateStep(final double truncatedEndTime) {
currentTime = truncatedEndTime;
h = currentTime - previousTime;
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;
final double theta = (nonTruncatedH == 0) ?
0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;
computeInterpolatedState(theta, oneMinusThetaH);
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {
interpolateDerivatives();
interpolateState(theta);
private void interpolateDerivatives() {
for (int i = 0; i < interpolatedDerivatives.length; ++i) {
for (int k = 0; k < previousF.length; ++k) {
neville[k] = previousF[k][i];
for (int l = 1; l < neville.length; ++l) {
for (int m = neville.length - 1; m >= l; --m) {
final double xm   = previousT[m];
final double xmMl = previousT[m - l];
neville[m] = ((interpolatedTime - xm) * neville[m-1] +
(xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);
interpolatedDerivatives[i] = neville[neville.length - 1];
private void interpolateState(final double theta) {
computeRollback(previousT.length - 1, theta);
for (int j = 0; j < interpolatedState.length; ++j) {
double sum = 0;
for (int l = 0; l < previousT.length; ++l) {
sum += rollback[l] * previousF[l][j];
interpolatedState[j] = currentState[j] - h * sum;
private void computeRollback(final int order, final double theta) {
double product = theta - 1;
rollback[0]  = theta;
for (int i = 1; i <= order; ++i) {
product *= (i - 1 + theta) / (i + 1);
double gStar = product;
for (int j = 1; j <= i; ++j) {
gStar -= rollback[i - j] / (j + 1);
rollback[i] = gStar;
for (int i = 0; i <= order; ++i) {
rollback[i] -= gammaStar[i];
for (int i = 0; i <= order; ++i) {
double f = 0;
for (int j = i; j <= order; ++j) {
f -= rollback[j] * bdArray[j][i];
rollback[i] = f;
public void writeExternal(final ObjectOutput out)
throws IOException {
super.writeExternal(out);
out.writeDouble(nonTruncatedEnd);
public void readExternal(final ObjectInput in)
throws IOException {
nonTruncatedEnd = in.readDouble();
package org.apache.commons.math.ode.nonstiff;
extends AbstractIntegrator {
public AdaptiveStepsizeIntegrator(final String name,
final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(name);
public AdaptiveStepsizeIntegrator(final String name,
final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(name);
public void setInitialStepSize(final double initialStepSize) {
protected void sanityChecks(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws IntegratorException {
super.sanityChecks(equations, t0, y0, t, y);
Integer.valueOf(y0.length),
Integer.valueOf(vecAbsoluteTolerance.length)
Integer.valueOf(y0.length),
Integer.valueOf(vecRelativeTolerance.length)
public double initializeStep(final FirstOrderDifferentialEquations equations,
final boolean forward, final int order, final double[] scale,
final double t0, final double[] y0, final double[] yDot0,
final double[] y1, final double[] yDot1)
throws DerivativeException {
final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
final double h1 = (maxInv2 < 1.0e-15) ?
Math.max(1.0e-6, 0.001 * Math.abs(h)) :
Math.pow(0.01 / maxInv2, 1.0 / order);
protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)
double filteredH = h;
if (Math.abs(h) < minStep) {
if (acceptSmall) {
filteredH = forward ? minStep : -minStep;
} else {
throw new IntegratorException("minimal step size ({0}) reached," +
" integration needs {1}",
new Object[] {
Double.valueOf(minStep),
Double.valueOf(Math.abs(h))
});
if (filteredH > maxStep) {
filteredH = maxStep;
} else if (filteredH < -maxStep) {
filteredH = -maxStep;
return filteredH;
public abstract double integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 3710070023793519840L;
public ClassicalRungeKuttaIntegrator(final double step) {
super("classical Runge-Kutta", c, a, b,
new ClassicalRungeKuttaStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
private static final long serialVersionUID = -6576285612589783992L;
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(final ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
protected StepInterpolator doCopy() {
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
throws DerivativeException {
final double fourTheta      = 4 * theta;
final double oneMinusTheta  = 1 - theta;
final double oneMinus2Theta = 1 - 2 * theta;
final double s             = oneMinusThetaH / 6.0;
final double coeff1        = s * ((-fourTheta + 5) * theta - 1);
final double coeff23       = s * (( fourTheta - 2) * theta - 2);
final double coeff4        = s * ((-fourTheta - 1) * theta - 1);
final double coeffDot1     = oneMinusTheta * oneMinus2Theta;
final double coeffDot23    = 2 * theta * oneMinusTheta;
final double coeffDot4     = -theta * oneMinus2Theta;
for (int i = 0; i < interpolatedState.length; ++i) {
final double yDot1  = yDotK[0][i];
final double yDot23 = yDotK[1][i] + yDotK[2][i];
final double yDot4  = yDotK[3][i];
interpolatedState[i] =
currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7932553613600031791L;
private static final String METHOD_NAME = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public DormandPrince54Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
e6 * yDotK[5][j] +  e7 * yDotK[6][j];
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode.nonstiff;
public DormandPrince54StepInterpolator(final DormandPrince54StepInterpolator interpolator) {
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
public void storeTime(final double t) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double yDot0 = yDotK[0][i];
final double yDot2 = yDotK[2][i];
final double yDot3 = yDotK[3][i];
final double yDot4 = yDotK[4][i];
final double yDot5 = yDotK[5][i];
final double yDot6 = yDotK[6][i];
v1[i] = a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5;
v2[i] = yDot0 - v1[i];
v3[i] = v1[i] - v2[i] - yDot6;
v4[i] = d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6;
final double eta = 1 - theta;
final double twoTheta = 2 * theta;
final double dot2 = 1 - twoTheta;
final double dot3 = theta * (2 - 3 * theta);
final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));
interpolatedState[i] =
currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -8627142100635188441L;
private static final String METHOD_NAME = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB,
public DormandPrince853Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB,
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +
e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +
e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +
e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +
e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +
e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +
e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio1  = errSum1 / tol;
final double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode.nonstiff;
public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {
final int dimension = interpolator.currentState.length;
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
final int dimension = currentState.length;
public void storeTime(final double t) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double yDot1  = yDotK[0][i];
final double yDot6  = yDotK[5][i];
final double yDot7  = yDotK[6][i];
final double yDot8  = yDotK[7][i];
final double yDot9  = yDotK[8][i];
final double yDot10 = yDotK[9][i];
final double yDot11 = yDotK[10][i];
final double yDot12 = yDotK[11][i];
final double yDot13 = yDotK[12][i];
final double yDot14 = yDotKLast[0][i];
final double yDot15 = yDotKLast[1][i];
final double yDot16 = yDotKLast[2][i];
v[0][i] = b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +
b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +
b_11 * yDot11 + b_12 * yDot12;
v[1][i] = yDot1 - v[0][i];
v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +
d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +
d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +
d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16;
final double eta      = 1 - theta;
final double twoTheta = 2 * theta;
final double theta2   = theta * theta;
final double dot1 = 1 - twoTheta;
final double dot2 = theta * (2 - 3 * theta);
final double dot3 = twoTheta * (1 + theta * (twoTheta -3));
final double dot4 = theta2 * (3 + theta * (5 * theta - 8));
final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));
final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));
interpolatedState[i] = currentState[i] -
oneMinusThetaH * (v[0][i] -
theta * (v[1][i] +
theta * (v[2][i] +
eta * (v[3][i] +
theta * (v[4][i] +
eta * (v[5][i] +
theta * (v[6][i])))))));
interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +
dot3 * v[3][i] + dot4 * v[4][i] +
dot5 * v[5][i] + dot6 * v[6][i];
final double[] yTmp = new double[currentState.length];
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final int dimension = in.readInt();
package org.apache.commons.math.ode.nonstiff;
protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double   minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public void setSafety(final double safety) {
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
final boolean forward = (t > t0);
final int stages = c.length + 1;
final double[][] yDotK = new double[stages][];
final double[] yTmp = new double[y0.length];
if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
stepStart         = t0;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
boolean lastStep = false;
while (!lastStep) {
final double[] scale;
if (manager.evaluateStep(interpolator)) {
hNew = manager.getEventTime() - stepStart;
final double factor =
Math.min(maxGrowth,
Math.max(minReduction, safety * Math.pow(error, exp)));
hNew = filterStep(stepSize * factor, forward, false);
final double nextStep = stepStart + stepSize;
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
if (manager.reset(stepStart, y) && ! lastStep) {
stepSize = filterStep(stepSize, forward, true);
final double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
final double  scaledH    = stepSize * factor;
final double  nextT      = stepStart + scaledH;
final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, forward, nextIsLast);
final double stopTime = stepStart;
return stopTime;
public void setMinReduction(final double minReduction) {
public void setMaxGrowth(final double maxGrowth) {
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 1828811360890387657L;
public EulerIntegrator(final double step) {
super("Euler", c, a, b, new EulerStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7179861704951334960L;
public EulerStepInterpolator(final EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 5566682259665027132L;
public GillIntegrator(final double step) {
super("Gill", c, a, b, new GillStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public GillStepInterpolator(final GillStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double twoTheta  = 2 * theta;
final double fourTheta = 4 * theta;
final double s         = oneMinusThetaH / 6.0;
final double oMt       = 1 - theta;
final double soMt      = s * oMt;
final double c23       = soMt * (1 + twoTheta);
final double coeff1    = soMt * (1 - fourTheta);
final double coeff2    = c23  * tMq;
final double coeff3    = c23  * tPq;
final double coeff4    = s * (1 + theta * (1 + fourTheta));
final double coeffDot1 = theta * (twoTheta - 3) + 1;
final double cDot23    = theta * oMt;
final double coeffDot2 = cDot23  * tMq;
final double coeffDot3 = cDot23  * tPq;
final double coeffDot4 = theta * (twoTheta - 1);
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
final double yDot3 = yDotK[2][i];
final double yDot4 = yDotK[3][i];
interpolatedState[i] =
currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 7364884082146325264L;
private static final String METHOD_NAME = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public void setStabilityCheck(final boolean performTest,
final int maxIter, final int maxChecks,
final double stabilityReduction) {
public void setStepsizeControl(final double stepControl1, final double stepControl2,
final double stepControl3, final double stepControl4) {
public void setOrderControl(final int maxOrder,
final double orderControl1, final double orderControl2) {
public void addStepHandler (final StepHandler handler) {
super.addStepHandler(handler);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public void addEventHandler(final EventHandler function,
final double maxCheckInterval,
final double convergence,
final int maxIterationCount) {
super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
final int size = maxOrder / 2;
final double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(final boolean useInterpolationError,
final int mudif) {
private void rescale(final double[] y1, final double[] y2, final double[] scale) {
final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0, final double step, final int k,
final double[] scale, final double[][] f,
final double[] yMiddle, final double[] yEnd,
final double[] yTmp)
final int    n        = sequence[k];
final double subStep  = step / n;
final double subStep2 = 2 * subStep;
final double middle = yEnd[i];
final double ratio = f[0][l] / scale[l];
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(final int offset, final int k,
final double[][] diag, final double[] last) {
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0, final double t, final double[] y)
final boolean forward = (t > t0);
final double[] yDot0   = new double[y0.length];
final double[] y1      = new double[y0.length];
final double[] yTmp    = new double[y0.length];
final double[] yTmpDot = new double[y0.length];
final double[][] diagonal = new double[sequence.length-1][];
final double[][] y1Diag = new double[sequence.length-1][];
final double[][][] fk  = new double[sequence.length][][];
final double[] scale = new double[y0.length];
final double tol =
final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);
if (denseOutput || (! eventsHandlersManager.isEmpty())) {
for (StepHandler handler : stepHandlers) {
handler.reset();
final double nextT = stepStart + stepSize;
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));
final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));
final double exp = 1.0 / (2 * k + 1);
final double pow = Math.pow(stepControl3, exp);
optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));
final double ratio = ((double) sequence [k] * sequence[k+1]) /
(sequence[0] * sequence[0]);
final double ratio = ((double) sequence[k+1]) / sequence[0];
final int mu = 2 * k - mudif + 3;
final int l2 = l / 2;
final GraggBulirschStoerStepInterpolator gbsInterpolator
final double interpError = gbsInterpolator.estimateError(scale);
if (eventsHandlersManager.evaluateStep(interpolator)) {
hNew = Math.abs(eventsHandlersManager.getEventTime() - stepStart);
final double nextStep = stepStart + stepSize;
eventsHandlersManager.stepAccepted(nextStep, y);
if (eventsHandlersManager.stop()) {
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {
hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],
forward, false);
hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],
forward, false);
return stepStart;
package org.apache.commons.math.ode.nonstiff;
private void resetTables(final int maxDegree) {
final double[][] newPols = new double[maxDegree + 1][];
final int ip5 = i + 5;
final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,
final double[] y1, final double[] y1Dot,
final double[][] yMidDots,
final boolean forward) {
(final GraggBulirschStoerStepInterpolator interpolator) {
final int dimension = currentState.length;
public void computeCoefficients(final int mu, final double h) {
final double yp0   = h * y0Dot[i];
final double yp1   = h * y1Dot[i];
final double ydiff = y1[i] - currentState[i];
final double aspl  = ydiff - yp1;
final double bspl  = yp0 - ydiff;
final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
final double ph1 = ydiff + 0.25 * (aspl - bspl);
final double ph2 = yp1 - yp0;
final double ph3 = 6 * (bspl - aspl);
final double fac1 = 0.5 * j * (j - 1);
final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(final double[] scale) {
final double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final int dimension = currentState.length;
final double oneMinusTheta = 1.0 - theta;
final double theta05       = theta - 0.5;
final double tOmT          = theta * oneMinusTheta;
final double t4            = tOmT * tOmT;
final double t4Dot         = 2 * tOmT * (1 - 2 * theta);
final double dot1          = 1.0 / h;
final double dot2          = theta * (2 - 3 * theta) / h;
final double dot3          = ((3 * theta - 4) * theta + 1) / h;
final double p0 = polynoms[0][i];
final double p1 = polynoms[1][i];
final double p2 = polynoms[2][i];
final double p3 = polynoms[3][i];
interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));
interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;
if (currentDegree > 3) {
double cDot = 0;
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
final double d = 1.0 / (j - 3);
cDot = d * (theta05 * cDot + c);
c = polynoms[j][i] + c * d * theta05;
interpolatedState[i]       += t4 * c;
interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;
if (h == 0) {
System.arraycopy(yMidDots[1], 0, interpolatedDerivatives, 0, dimension);
public void writeExternal(final ObjectOutput out)
final int dimension = currentState.length;
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
final int dimension = currentState.length;
final int degree = in.readInt();
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 1462328766749870097L;
private static final String METHOD_NAME = "Higham-Hall 5(4)";
public HighamHall54Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public HighamHall54Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio  = h * errSum / tol;
package org.apache.commons.math.ode.nonstiff;
public HighamHall54StepInterpolator(final HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double theta2 = theta * theta;
final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));
final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));
final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));
final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));
final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);
final double yDot0 = yDotK[0][i];
final double yDot2 = yDotK[2][i];
final double yDot3 = yDotK[3][i];
final double yDot4 = yDotK[4][i];
final double yDot5 = yDotK[5][i];
interpolatedState[i] =
currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;
interpolatedDerivatives[i] =
bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7690774342890000483L;
public MidpointIntegrator(final double step) {
super("midpoint", c, a, b, new MidpointStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public MidpointStepInterpolator(final MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double coeff1    = oneMinusThetaH * theta;
final double coeff2    = oneMinusThetaH * (1.0 + theta);
final double coeffDot2 = 2 * theta;
final double coeffDot1 = 1 - coeffDot2;
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;
interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;
package org.apache.commons.math.ode.nonstiff;
public abstract class MultistepIntegrator extends AbstractIntegrator {
private FirstOrderIntegrator starter;
protected double[] previousT;
protected double[][] previousF;
private double resetTime;
protected MultistepStepInterpolator prototype;
protected MultistepIntegrator(final String name, final int k,
final MultistepStepInterpolator prototype) {
super(name);
starter = new DormandPrince853Integrator(1.0e-6, 1.0e6, 1.0e-5, 1.0e-6);
previousT = new double[k];
previousF = new double[k][];
this.prototype = prototype;
public ODEIntegrator getStarterIntegrator() {
return starter;
public void setStarterIntegrator(FirstOrderIntegrator starter) {
this.starter = starter;
protected double start(final int n, final double h,
final CombinedEventsManager manager,
final FirstOrderDifferentialEquations equations,
final double t0, final double[] y)
throws DerivativeException, IntegratorException {
Arrays.fill(previousT, Double.NaN);
Arrays.fill(previousF, null);
starter.clearEventHandlers();
for (EventState state : manager.getEventsStates()) {
starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),
state.getMaxCheckInterval(),
state.getConvergence(), state.getMaxIterationCount());
starter.clearStepHandlers();
for (final StepHandler handler : stepHandlers) {
starter.addStepHandler(new FilteringWrapper(handler));
final StoringStepHandler store = new StoringStepHandler(n);
starter.addStepHandler(new StepNormalizer(h, store));
double t = t0;
double stopTime = Double.NaN;
do {
resetTime = Double.NaN;
store.restart();
stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);
if (!Double.isNaN(resetTime)) {
t = resetTime;
} while (!Double.isNaN(resetTime));
starter.clearEventHandlers();
starter.clearStepHandlers();
if (store.getFinalState() != null) {
System.arraycopy(store.getFinalState(), 0, y, 0, y.length);
return stopTime;
protected void rotatePreviousSteps() {
final double[] rolled = previousF[previousT.length - 1];
for (int k = previousF.length - 1; k > 0; --k) {
previousT[k] = previousT[k - 1];
previousF[k] = previousF[k - 1];
previousF[0] = rolled;
private class ResetCheckingWrapper implements EventHandler {
private static final long serialVersionUID = 4922660285376467937L;
private final EventHandler handler;
public ResetCheckingWrapper(final EventHandler handler) {
this.handler = handler;
public int eventOccurred(double t, double[] y) throws EventException {
final int action = handler.eventOccurred(t, y);
if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {
resetTime = t;
return STOP;
return action;
public double g(double t, double[] y) throws EventException {
return handler.g(t, y);
public void resetState(double t, double[] y) throws EventException {
handler.resetState(t, y);
private class FilteringWrapper implements StepHandler {
private static final long serialVersionUID = 4607975253344802232L;
private final StepHandler handler;
public FilteringWrapper(final StepHandler handler) {
this.handler = handler;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
handler.handleStep(interpolator, eventsHandlersManager.stop());
public boolean requiresDenseOutput() {
return handler.requiresDenseOutput();
public void reset() {
handler.reset();
private class StoringStepHandler implements FixedStepHandler {
private static final long serialVersionUID = 4592974435520688797L;
private final int n;
private int count;
private double[] finalState;
public StoringStepHandler(final int n) {
this.n = n;
restart();
public void restart() {
count = 0;
finalState = null;
public double[] getFinalState() {
return finalState;
public void handleStep(final double t, final double[] y, final double[] yDot,
final boolean isLast) {
if (count++ < n) {
previousT[n - count] = t;
previousF[n - count] = yDot.clone();
if (count == n) {
finalState = y.clone();
package org.apache.commons.math.ode.nonstiff;
abstract class MultistepStepInterpolator
extends AbstractStepInterpolator {
protected double[] previousT;
protected double[][] previousF;
protected MultistepStepInterpolator() {
previousT = null;
previousF = null;
public MultistepStepInterpolator(final MultistepStepInterpolator interpolator) {
super(interpolator);
if (interpolator.currentState != null) {
previousT = interpolator.previousT.clone();
previousF = new double[interpolator.previousF.length][];
for (int k = 0; k < interpolator.previousF.length; ++k) {
previousF[k] = interpolator.previousF[k].clone();
initializeCoefficients();
} else {
previousT = null;
previousF = null;
public void reinitialize(final double[] y,
final double[] previousT, final double[][] previousF,
final boolean forward) {
reinitialize(y, forward);
this.previousT = previousT;
this.previousF = previousF;
initializeCoefficients();
protected abstract void initializeCoefficients();
public void writeExternal(final ObjectOutput out)
throws IOException {
writeBaseExternal(out);
out.writeInt(previousT.length);
for (int k = 0; k < previousF.length; ++k) {
out.writeDouble(previousT[k]);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(previousF[k][i]);
public void readExternal(final ObjectInput in)
throws IOException {
final double t = readBaseExternal(in);
final int kMax = in.readInt();
previousT = new double[kMax];
previousF = new double[kMax][];
for (int k = 0; k < kMax; ++k) {
previousT[k] = in.readDouble();
previousF[k] = new double[currentState.length];
for (int i = 0; i < currentState.length; ++i) {
previousF[k][i] = in.readDouble();
initializeCoefficients();
setInterpolatedTime(t);
} catch (DerivativeException e) {
throw new IOException(e.getMessage());
package org.apache.commons.math.ode.nonstiff;
public abstract class RungeKuttaIntegrator extends AbstractIntegrator {
protected RungeKuttaIntegrator(final String name,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double step) {
super(name);
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
final int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
final double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
} else {
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
stepStart = t0;
stepSize  = step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (boolean loop = true; loop;) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
if (manager.evaluateStep(interpolator)) {
stepSize = manager.getEventTime() - stepStart;
} else {
loop = false;
final double nextStep = stepStart + stepSize;
System.arraycopy(yTmp, 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
interpolator.storeTime(nextStep);
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (manager.reset(stepStart, y) && ! lastStep) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
stepSize = step;
final double stopTime = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
package org.apache.commons.math.ode.nonstiff;
public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {
final int dimension = currentState.length;
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
final int kMax = in.readInt();
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -2480984691453028021L;
public ThreeEighthesIntegrator(final double step) {
super("3/8", c, a, b, new ThreeEighthesStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public ThreeEighthesStepInterpolator(final ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
throws DerivativeException {
final double fourTheta2 = 4 * theta * theta;
final double s          = oneMinusThetaH / 8.0;
final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
final double coeff2     = 3 * s * (1 + theta - fourTheta2);
final double coeff3     = 3 * s * (1 + theta);
final double coeff4     = s * (1 + theta + fourTheta2);
final double coeffDot3  = 0.75 * theta;
final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;
final double coeffDot2  = coeffDot3 * (5 - 6 * theta);
final double coeffDot4  = coeffDot3 * (2 * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
final double yDot3 = yDotK[2][i];
final double yDot4 = yDotK[3][i];
interpolatedState[i] =
currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.sampling;
protected double[] interpolatedDerivatives;
previousTime            = Double.NaN;
currentTime             = Double.NaN;
h                       = Double.NaN;
interpolatedTime        = Double.NaN;
currentState            = null;
interpolatedState       = null;
interpolatedDerivatives = null;
finalized               = false;
this.forward            = true;
protected AbstractStepInterpolator(final double[] y, final boolean forward) {
currentState            = y;
interpolatedState       = new double[y.length];
interpolatedDerivatives = new double[y.length];
protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {
currentState            = (double[]) interpolator.currentState.clone();
interpolatedState       = (double[]) interpolator.interpolatedState.clone();
interpolatedDerivatives = (double[]) interpolator.interpolatedDerivatives.clone();
currentState            = null;
interpolatedState       = null;
interpolatedDerivatives = null;
protected void reinitialize(final double[] y, final boolean forward) {
currentState            = y;
interpolatedState       = new double[y.length];
interpolatedDerivatives = new double[y.length];
public void storeTime(final double t) {
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = currentTime - interpolatedTime;
final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;
computeInterpolatedState(theta, oneMinusThetaH);
return interpolatedState;
public double[] getInterpolatedDerivatives() {
return interpolatedDerivatives;
protected void writeBaseExternal(final ObjectOutput out)
protected double readBaseExternal(final ObjectInput in)
final int dimension = in.readInt();
interpolatedTime        = Double.NaN;
interpolatedState       = new double[dimension];
interpolatedDerivatives = new double[dimension];
package org.apache.commons.math.ode.sampling;
public void handleStep(final StepInterpolator interpolator, final boolean isLast) {
package org.apache.commons.math.ode.sampling;
public DummyStepInterpolator(final double[] y, final boolean forward) {
public DummyStepInterpolator(final DummyStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
package org.apache.commons.math.ode.sampling;
public interface FixedStepHandler extends Serializable {
public void handleStep(double t, double[] y, double[] yDot, boolean isLast)
throws DerivativeException;
package org.apache.commons.math.ode.sampling;
public interface StepHandler extends Serializable {
package org.apache.commons.math.ode.sampling;
public double[] getInterpolatedDerivatives();
package org.apache.commons.math.ode.sampling;
public class StepNormalizer implements StepHandler {
private static final long serialVersionUID = -789699939659144654L;
private double h;
private final FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private double[] lastDerivatives;
private boolean forward;
public StepNormalizer(final double h, final FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime        = Double.NaN;
lastState       = null;
lastDerivatives = null;
forward         = true;
public void handleStep(final StepInterpolator interpolator, final boolean isLast)
throws DerivativeException {
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
lastState = interpolator.getInterpolatedState().clone();
lastDerivatives = interpolator.getInterpolatedDerivatives().clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
double nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, lastDerivatives, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,
lastDerivatives, 0, lastDerivatives.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, lastDerivatives, true);
private static Comparator<PointCostPair> pointCostPairComparator =
new Comparator<PointCostPair>() {
public int compare(PointCostPair o1, PointCostPair o2) {
return (o1.getCost() < o2.getCost()) ? -1 : ((o1 == o2) ? 0 : +1);
List<SummaryStatistics> getBinStats();
private static final long serialVersionUID = 5729073523949762654L;
private List<SummaryStatistics> binStats = null;
binStats = new ArrayList<SummaryStatistics>();
binStats = new ArrayList<SummaryStatistics>();
SummaryStatistics stats = binStats.get(findBin(min, val, delta));
val = Double.valueOf(str).doubleValue();
binStats.get(findBin(min, inputArray[i], delta));
double delta = (max - min)/(Double.valueOf(binCount)).doubleValue();
((double) binStats.get(0).getN()) / (double) sampleStats.getN();
((double) binStats.get(i).getN()) / (double) sampleStats.getN();
SummaryStatistics stats = binStats.get(i);
public List<SummaryStatistics> getBinStats() {
Object[] nextSample(Collection<?> c, int k);
Integer c = Integer.valueOf(randomBytes[i]);
Integer c = Integer.valueOf(hash[i]);
public Object[] nextSample(Collection<?> c, int k) {
obj = Long.valueOf(((Integer) v).longValue());
freqTable.put(obj, Long.valueOf(1));
freqTable.put(obj, Long.valueOf(count.longValue() + 1));
addValue(Long.valueOf(v));
addValue(Long.valueOf(v.longValue()));
addValue(Long.valueOf(v));
addValue(Character.valueOf(v));
return getCount(Long.valueOf(v));
return getCount(Long.valueOf(v));
return getCount(Character.valueOf(v));
return getPct(Long.valueOf(v));       
return getPct(Long.valueOf(v));         
return getPct(Character.valueOf(v));         
return getCumFreq(Long.valueOf(v));       
return getCumFreq(Long.valueOf(v));         
return getCumFreq(Character.valueOf(v));         
return getCumPct(Long.valueOf(v));       
return getCumPct(Long.valueOf(v));         
return getCumPct(Character.valueOf(v));         
private static final long serialVersionUID = 4133067267405273064L;
new Object[] {Double.valueOf(p)});
new Object[] {Double.valueOf(50.0d)});
private static final long serialVersionUID = -2021321786743555871L;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&
MathUtils.equals(stat.getMax(), this.getMax()) &&
MathUtils.equals(stat.getMean(), this.getMean()) &&
MathUtils.equals(stat.getMin(), this.getMin()) &&
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&
MathUtils.equals(stat.getVariance(),
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
private AnovaStats anovaStats(Collection<double[]> categoryData)
for (double[] array : categoryData) {
for (double[] data : categoryData) {
public static double oneWayAnovaFValue(Collection<double[]> categoryData)
public static double oneWayAnovaPValue(Collection<double[]> categoryData)
public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegression implements
MultipleLinearRegression {
protected RealMatrix X;
protected RealMatrix Y;
public void newSampleData(double[] data, int nobs, int nvars) {
double[] y = new double[nobs];
double[][] x = new double[nobs][nvars + 1];
int pointer = 0;
for (int i = 0; i < nobs; i++) {
y[i] = data[pointer++];
x[i][0] = 1.0d;
for (int j = 1; j < nvars + 1; j++) {
x[i][j] = data[pointer++];
this.X = new RealMatrixImpl(x);
this.Y = new RealMatrixImpl(y);
protected void newYSampleData(double[] y) {
this.Y = new RealMatrixImpl(y);
protected void newXSampleData(double[][] x) {
this.X = new RealMatrixImpl(x);
protected void validateSampleData(double[][] x, double[] y) {
if (x == null) {
throw new IllegalArgumentException("The regressors matrix x cannot be null.");
if (y == null) {
throw new IllegalArgumentException("The regressand vector y cannot be null.");
if (x.length != y.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the regressand vector y");
protected void validateCovarianceData(double[][] x, double[][] covariance) {
if (covariance == null) {
throw new IllegalArgumentException("Covariance matrix cannot be null.");
if (x.length != covariance.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the covariance matrix columns");
if (covariance.length > 0 && covariance.length != covariance[0].length) {
throw new IllegalArgumentException("The covariance matrix must be square");
public double[] estimateRegressionParameters() {
RealMatrix b = calculateBeta();
return b.getColumn(0);
public double[] estimateResiduals() {
RealMatrix b = calculateBeta();
RealMatrix e = Y.subtract(X.multiply(b));
return e.getColumn(0);
public double[][] estimateRegressionParametersVariance() {
return calculateBetaVariance().getData();
public double estimateRegressandVariance() {
return calculateYVariance();
protected abstract RealMatrix calculateBeta();
protected abstract RealMatrix calculateBetaVariance();
protected abstract double calculateYVariance();
protected RealMatrix calculateResiduals() {
RealMatrix b = calculateBeta();
return Y.subtract(X.multiply(b));
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
private RealMatrix Omega;
public void newSampleData(double[] y, double[][] x, double[][] covariance) {
validateSampleData(x, y);
newYSampleData(y);
newXSampleData(x);
validateCovarianceData(x, covariance);
newCovarianceData(covariance);
protected void newCovarianceData(double[][] omega){
this.Omega = new RealMatrixImpl(omega);
protected RealMatrix calculateBeta() {
RealMatrix OI = Omega.inverse();
RealMatrix XT = X.transpose();
RealMatrix XTOIX = XT.multiply(OI).multiply(X);
return XTOIX.inverse().multiply(XT).multiply(OI).multiply(Y);
protected RealMatrix calculateBetaVariance() {
RealMatrix XTOIX = X.transpose().multiply(Omega.inverse()).multiply(X);
return XTOIX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse =  u.transpose().multiply(Omega.inverse()).multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
package org.apache.commons.math.stat.regression;
public interface MultipleLinearRegression {
double[] estimateRegressionParameters();
double[][] estimateRegressionParametersVariance();
double[] estimateResiduals();
double estimateRegressandVariance();
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
private QRDecomposition qr = null;
public void newSampleData(double[] y, double[][] x) {
validateSampleData(x, y);
newYSampleData(y);
newXSampleData(x);
public void newSampleData(double[] data, int nobs, int nvars) {
super.newSampleData(data, nobs, nvars);
qr = new QRDecompositionImpl(X);
protected void newXSampleData(double[][] x) {
this.X = new RealMatrixImpl(x);
qr = new QRDecompositionImpl(X);
protected RealMatrix calculateBeta() {
return solveUpperTriangular((RealMatrixImpl) qr.getR(),
(RealMatrixImpl) qr.getQ().transpose().multiply(Y));
protected RealMatrix calculateBetaVariance() {
RealMatrix XTX = X.transpose().multiply(X);
return XTX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse = u.transpose().multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
private static RealMatrix solveUpperTriangular(RealMatrixImpl coefficients,
RealMatrixImpl constants) {
if (!isUpperTriangular(coefficients, 1E-12)) {
throw new IllegalArgumentException(
"Coefficients is not upper-triangular");
if (constants.getColumnDimension() != 1) {
throw new IllegalArgumentException(
"Constants not a column matrix.");
int length = coefficients.getColumnDimension();
double[][] cons = constants.getDataRef();
double[][] coef = coefficients.getDataRef();
double x[] = new double[length];
for (int i = 0; i < length; i++) {
int index = length - 1 - i;
double sum = 0;
for (int j = index + 1; j < length; j++) {
sum += coef[index][j] * x[j];
x[index] = (cons[index][0] - sum) / coef[index][index];
} 
return new RealMatrixImpl(x);
private static boolean isUpperTriangular(RealMatrixImpl m, double epsilon) {
double[][] data = m.getDataRef();
int nCols = m.getColumnDimension();
int nRows = m.getRowDimension();
for (int r = 0; r < nRows; r++) {
int bound = Math.min(r, nCols);
for (int c = 0; c < bound; c++) {
if (Math.abs(data[r][c]) > epsilon) {
return false;
return true;
public void removeData(double x, double y) {
if (n > 0) {
double dx = x - xbar;
double dy = y - ybar;
sumXX -= dx * dx * (double) n / (double) (n - 1.0);
sumYY -= dy * dy * (double) n / (double) (n - 1.0);
sumXY -= dx * dy * (double) n / (double) (n - 1.0);
xbar -= dx / (double) (n - 1.0);
ybar -= dy / (double) (n - 1.0);
sumX -= x;
sumY -= y;
n--;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
} 
public void removeData(double[][] data) {
for (int i = 0; i < data.length && n > 0; i++) {
removeData(data[i][0], data[i][1]);
package org.apache.commons.math.util;
public abstract class CompositeFormat extends Format {
protected static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
protected static NumberFormat getDefaultNumberFormat(final Locale locale) {
final NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
protected void parseAndIgnoreWhitespace(final String source,
final ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
protected char parseNextCharacter(final String source,
final ParsePosition pos) {
int index = pos.getIndex();
final int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
} while (Character.isWhitespace(c) && index < n);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(final String source, final double value,
final ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
final int n = sb.length();
final int startIndex = pos.getIndex();
final int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = Double.valueOf(value);
pos.setIndex(endIndex);
return ret;
protected Number parseNumber(final String source, final NumberFormat format,
final ParsePosition pos) {
final int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
final int endIndex = pos.getIndex();
if (startIndex == endIndex) {
final double[] special = {
Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
protected boolean parseFixedstring(final String source, final String expected,
final ParsePosition pos) {
final int startIndex = pos.getIndex();
final int endIndex = startIndex + expected.length();
if ((startIndex >= source.length()) ||
(endIndex > source.length()) ||
(source.substring(startIndex, endIndex).compareTo(expected) != 0)) {
pos.setIndex(startIndex);
pos.setErrorIndex(startIndex);
return false;
pos.setIndex(endIndex);
return true;
protected StringBuffer formatDouble(final double value, final NumberFormat format,
final StringBuffer toAppendTo,
final FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
} else {
format.format(value, toAppendTo, pos);
return toAppendTo;
new Object[] { Double.valueOf(x) });
new Object[] { Double.valueOf(x) });
return Double.valueOf(o.toString()).doubleValue();
private static final long serialVersionUID = 4605318041528645258L;
private Map<Class<?>, NumberTransformer> map = null;
map = new HashMap<Class<?>, NumberTransformer>();
public boolean containsClass(Class<?> key) {
public NumberTransformer getTransformer(Class<?> key) {
public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {
public NumberTransformer removeTransformer(Class<?> key) {
public Set<Class<?>> classes() {
public Collection<NumberTransformer> transformers() {
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(new double[] { 0.0 });
return Double.valueOf(newA);
return Double.valueOf();
return Double.valueOf(newA);
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Double.valueOf(0.0) };
Object[] arguments = { Double.valueOf(0.0) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
new Object[] { Double.valueOf(1234567) });
CompositeFormat complexFormat = null;
CompositeFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = Double.valueOf(Math.PI);
CompositeFormat cf = new ComplexFormat();
assertEquals(w.getReal(), 4.0, 0);
assertTrue(Double.isNaN(w.getImaginary()));
assertEquals(w.getImaginary(), 1, 0);
assertEquals(inf, w.getReal(), 0);
assertTrue(Double.isNaN(x.add(z).getReal()));
assertEquals(neginf, z.conjugate().getImaginary(), 0);
assertEquals(inf, z.conjugate().getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(inf, z.getReal(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertTrue(Double.isNaN(w.getReal()));
assertTrue(Double.isNaN(w.getImaginary()));  
return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
for (EstimatedParameter p : set) {
addParameter(p);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
set.add(parameters[j]);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
private static class QuadraticProblem extends SimpleEstimationProblem {
assertFalse(zero.equals(Double.valueOf(0)));
package org.apache.commons.math.geometry;
public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
Rotation r = Rotation.IDENTITY;
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);
r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);
r = new Rotation(Vector3D.PLUS_J, Math.PI);
checkVector(r.getAxis(), Vector3D.PLUS_J);
checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);
new Rotation(u, Vector3D.ZERO);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);
if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {
checkVector(axis, Vector3D.PLUS_K);
checkVector(axis, Vector3D.MINUS_K);
r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,
new Rotation(u1, u2, Vector3D.ZERO, v2);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_I),
checkVector(r.applyTo(Vector3D.PLUS_J),
checkVector(r.applyTo(Vector3D.PLUS_K),
r = Rotation.IDENTITY;
r = new Rotation(Vector3D.PLUS_K, Math.PI);
assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);
assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);
package org.apache.commons.math.geometry;
public abstract class Vector3DFormatAbstractTest extends TestCase {
Vector3DFormat vector3DFormat = null;
Vector3DFormat vector3DFormatSquare = null;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
vector3DFormat = Vector3DFormat.getInstance(getLocale());
final NumberFormat nf = NumberFormat.getInstance(getLocale());
nf.setMaximumFractionDigits(2);
vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf);
public void testSimpleNoDecimals() {
Vector3D c = new Vector3D(1, 1, 1);
String expected = "{1; 1; 1}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
Vector3D c = new Vector3D(1.23, 1.43, 1.63);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeX() {
Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);
String expected =
"{-1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeY() {
Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; -1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeZ() {
Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; -1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNonDefaultSetting() {
Vector3D c = new Vector3D(1, 1, 1);
String expected = "[1 : 1 : 1]";
String actual = vector3DFormatSquare.format(c); 
assertEquals(expected, actual);
public void testStaticFormatVector3D() {
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
Vector3D c = new Vector3D(232.222, -342.33, 432.444);
String expected =
"{232"    + getDecimalCharacter() +
"22; -342" + getDecimalCharacter() +
"33; 432" + getDecimalCharacter() +
"44}";
String actual = Vector3DFormat.formatVector3D(c); 
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
Vector3D c = Vector3D.NaN;
String expected = "{(NaN); (NaN); (NaN)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testPositiveInfinity() {
Vector3D c = Vector3D.POSITIVE_INFINITY;
String expected = "{(Infinity); (Infinity); (Infinity)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void tesNegativeInfinity() {
Vector3D c = Vector3D.NEGATIVE_INFINITY;
String expected = "{(-Infinity); (-Infinity); (-Infinity)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
String source = "{1; 1; 1}";
Vector3D expected = new Vector3D(1, 1, 1);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseIgnoredWhitespace() {
Vector3D expected = new Vector3D(1, 1, 1);
ParsePosition pos1 = new ParsePosition(0);
String source1 = "{1;1;1}";
assertEquals(expected, vector3DFormat.parseObject(source1, pos1));
assertEquals(source1.length(), pos1.getIndex());
ParsePosition pos2 = new ParsePosition(0);
String source2 = " { 1 ; 1 ; 1 } ";
assertEquals(expected, vector3DFormat.parseObject(source2, pos2));
assertEquals(source2.length() - 1, pos2.getIndex());
public void testParseSimpleWithDecimals() {
String source =
"{1" + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
Vector3D expected = new Vector3D(1.23, 1.43, 1.63);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeX() {
String source =
"{-1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeY() {
String source =
"{1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeZ() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeAll() {
String source =
"{-1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseZeroX() {
String source =
"{0" + getDecimalCharacter() +
"0; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNonDefaultSetting() {
String source =
"[1" + getDecimalCharacter() +
"2323 : 1" + getDecimalCharacter() +
"4343 : 1" + getDecimalCharacter() +
"6333]";
Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNan() {
String source = "{(NaN); (NaN); (NaN)}";
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(Vector3D.NaN, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
String source = "{(Infinity); (Infinity); (Infinity)}";
Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); 
assertEquals(Vector3D.POSITIVE_INFINITY, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeInfinity() {
String source = "{(-Infinity); (-Infinity); (-Infinity)}";
Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); 
assertEquals(Vector3D.NEGATIVE_INFINITY, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
Vector3DFormat cf = new Vector3DFormat(nf);
assertNotNull(cf);
assertEquals(nf, cf.getFormat());
public void testFormatObject() {
CompositeFormat cf = new Vector3DFormat();
Object object = new Object();
cf.format(object);
fail();
} catch (IllegalArgumentException ex) {
public void testForgottenPrefix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("1; 1; 1}", pos));
assertEquals(0, pos.getErrorIndex());
public void testForgottenSeparator() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("{1; 1 1}", pos));
assertEquals(6, pos.getErrorIndex());
public void testForgottenSuffix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos));
assertEquals(8, pos.getErrorIndex());
package org.apache.commons.math.geometry;
public class Vector3DFormatTest extends Vector3DFormatAbstractTest {
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
checkVector(new Vector3D(2, Vector3D.PLUS_I,
-3, Vector3D.MINUS_K),
checkVector(new Vector3D(2, Vector3D.PLUS_I,
5, Vector3D.PLUS_J,
-3, Vector3D.MINUS_K),
checkVector(new Vector3D(2, Vector3D.PLUS_I,
5, Vector3D.PLUS_J,
5, Vector3D.MINUS_J,
-3, Vector3D.MINUS_K),
assertTrue(Math.abs(Vector3D.ZERO.getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);
Vector3D.ZERO.normalize();
Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);
BigMatrixImpl m1 = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());
assertEquals(m2,m1);
BigMatrixImpl m3 = new BigMatrixImpl(testData);
BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);
assertEquals(m4,m3);
BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);
BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);
assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE);
assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE);
BigMatrix mPlusMInv = m.add(mInv);
public void testMath209() {
BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {
{ new BigDecimal(1), new BigDecimal(2) },
{ new BigDecimal(3), new BigDecimal(4) },
{ new BigDecimal(5), new BigDecimal(6) }
}, false);
BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);
assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);
assertEquals(11.0, b[2].doubleValue(), 1.0e-12);
package org.apache.commons.math.linear;
public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
assertEquals(new RealMatrixImpl(testData, false), 
MatrixUtils.createRealMatrix(testData, true));
assertEquals(new RealMatrixImpl(testData, true), 
MatrixUtils.createRealMatrix(testData, false));
assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), 
MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));
assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), 
MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData4x3, false);
matrix = new RealMatrixImpl(testData3x4, false);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
public void testHTrapezoidal() {
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
RealMatrix H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData3x3Singular, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData3x4, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData4x3, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
public void testRank() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
assertTrue(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));
assertFalse(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false));
assertFalse(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false));
assertTrue(qr.isFullRank());
public void testSolveDimensionErrors() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix b = new RealMatrixImpl(new double[2][2]);
qr.solve(b);
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolveRankErrors() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));
RealMatrix b = new RealMatrixImpl(new double[3][2]);
qr.solve(b);
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolve() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix b = new RealMatrixImpl(new double[][] {
{ -102, 12250 }, { 544, 24500 }, { 167, -36750 }
});
RealMatrix xRef = new RealMatrixImpl(new double[][] {
{ 1, 2515 }, { 2, 422 }, { -3, 898 }
});
assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
RealVectorImplTest.RealVectorTestImpl v =
new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));
assertEquals(0,
qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
public void testMatricesValues() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix qRef = new RealMatrixImpl(new double[][] {
{ -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },
{  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },
{   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }
});
RealMatrix rRef = new RealMatrixImpl(new double[][] {
{ -14.0,  -21.0, 14.0 },
{   0.0, -175.0, 70.0 },
{   0.0,    0.0, 35.0 }
});
RealMatrix hRef = new RealMatrixImpl(new double[][] {
{ 26.0 / 14.0, 0.0, 0.0 },
{  6.0 / 14.0, 648.0 / 325.0, 0.0 },
{ -4.0 / 14.0,  36.0 / 325.0, 2.0 }
});
RealMatrix q = qr.getQ();
assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);
RealMatrix r = qr.getR();
assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);
RealMatrix h = qr.getH();
assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);
assertTrue(q == qr.getQ());
assertTrue(r == qr.getR());
assertTrue(h == qr.getH());
RealMatrixImpl m1 = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());
assertEquals(m2,m1);
RealMatrixImpl m3 = new RealMatrixImpl(testData);
RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);
assertEquals(m4,m3);
RealMatrix mPlusMInv = m.add(mInv);
assertClose("inverse-operate", mInv.operate(testVector),
m.solve(testVector), normTolerance);
assertClose("inverse-operate", mInv.operate(testVector),
m.solve(new RealVectorImpl(testVector)).getData(), normTolerance);
assertClose("identity operate", testVector,
m.operate(testVector), entryTolerance);
assertClose("identity operate", testVector,
m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);
public void testMath209() {
RealMatrix a = new RealMatrixImpl(new double[][] {
{ 1, 2 }, { 3, 4 }, { 5, 6 }
}, false);
double[] b = a.operate(new double[] { 1, 1 });
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0], 1.0e-12);
assertEquals( 7.0, b[1], 1.0e-12);
assertEquals(11.0, b[2], 1.0e-12);
assertClose("premultiply", m.preMultiply(testVector),
preMultTest, normTolerance);
assertClose("premultiply", m.preMultiply(new RealVectorImpl(testVector).getData()),
preMultTest, normTolerance);
public void testGetRowVector() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealVector mRow0 = new RealVectorImpl(subRow0[0]);
RealVector mRow3 = new RealVectorImpl(subRow3[0]);
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
m.getRowVector(-1);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
m.getRowVector(4);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
public void testGetColumnVector() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealVector mColumn1 = columnToVector(subColumn1);
RealVector mColumn3 = columnToVector(subColumn3);
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
m.getColumnVector(-1);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
m.getColumnVector(4);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
private RealVector columnToVector(double[][] column) {
double[] data = new double[column.length];
for (int i = 0; i < data.length; ++i) {
data[i] = column[i][0];
return new RealVectorImpl(data, false);
package org.apache.commons.math.linear;
public abstract class RealVectorFormatAbstractTest extends TestCase {
RealVectorFormat realVectorFormat = null;
RealVectorFormat realVectorFormatSquare = null;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
realVectorFormat = RealVectorFormat.getInstance(getLocale());
final NumberFormat nf = NumberFormat.getInstance(getLocale());
nf.setMaximumFractionDigits(2);
realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);
public void testSimpleNoDecimals() {
RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});
String expected = "{1; 1; 1}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeX() {
RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});
String expected =
"{-1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeY() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; -1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeZ() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; -1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNonDefaultSetting() {
RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});
String expected = "[1 : 1 : 1]";
String actual = realVectorFormatSquare.format(c); 
assertEquals(expected, actual);
public void testStaticFormatRealVectorImpl() {
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444});
String expected =
"{232"    + getDecimalCharacter() +
"22; -342" + getDecimalCharacter() +
"33; 432" + getDecimalCharacter() +
"44}";
String actual = RealVectorFormat.formatRealVector(c); 
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN});
String expected = "{(NaN); (NaN); (NaN)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testPositiveInfinity() {
RealVectorImpl c = new RealVectorImpl(new double[] {
Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
});
String expected = "{(Infinity); (Infinity); (Infinity)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void tesNegativeInfinity() {
RealVectorImpl c = new RealVectorImpl(new double[] {
Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY
});
String expected = "{(-Infinity); (-Infinity); (-Infinity)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
String source = "{1; 1; 1}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseIgnoredWhitespace() {
RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});
ParsePosition pos1 = new ParsePosition(0);
String source1 = "{1;1;1}";
assertEquals(expected, realVectorFormat.parseObject(source1, pos1));
assertEquals(source1.length(), pos1.getIndex());
ParsePosition pos2 = new ParsePosition(0);
String source2 = " { 1 ; 1 ; 1 } ";
assertEquals(expected, realVectorFormat.parseObject(source2, pos2));
assertEquals(source2.length() - 1, pos2.getIndex());
public void testParseSimpleWithDecimals() {
String source =
"{1" + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeX() {
String source =
"{-1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeY() {
String source =
"{1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeZ() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeAll() {
String source =
"{-1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseZeroX() {
String source =
"{0" + getDecimalCharacter() +
"0; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNonDefaultSetting() {
String source =
"[1" + getDecimalCharacter() +
"2323 : 1" + getDecimalCharacter() +
"4343 : 1" + getDecimalCharacter() +
"6333]";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNan() {
String source = "{(NaN); (NaN); (NaN)}";
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
String source = "{(Infinity); (Infinity); (Infinity)}";
RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {
Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeInfinity() {
String source = "{(-Infinity); (-Infinity); (-Infinity)}";
RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {
Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY
}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNoComponents() {
realVectorFormat.parseObject("{ }");
} catch (ParseException pe) {
} catch (Exception e) {
fail("wrong exception caught");
public void testParseManyComponents() throws ParseException {
RealVectorImpl parsed =
(RealVectorImpl) realVectorFormat.parseObject("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");
assertEquals(24, parsed.getDimension());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
RealVectorFormat cf = new RealVectorFormat(nf);
assertNotNull(cf);
assertEquals(nf, cf.getFormat());
public void testFormatObject() {
CompositeFormat cf = new RealVectorFormat();
Object object = new Object();
cf.format(object);
fail();
} catch (IllegalArgumentException ex) {
public void testForgottenPrefix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("1; 1; 1}", pos));
assertEquals(0, pos.getErrorIndex());
public void testForgottenSeparator() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("{1; 1 1}", pos));
assertEquals(6, pos.getErrorIndex());
public void testForgottenSuffix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("{1; 1; 1 ", pos));
assertEquals(8, pos.getErrorIndex());
package org.apache.commons.math.linear;
public class RealVectorFormatTest extends RealVectorFormatAbstractTest {
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
public class RealVectorImplTest extends TestCase {
protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};
protected double[] vec1 = {1d, 2d, 3d};
protected double[] vec2 = {4d, 5d, 6d};
protected double[] vec3 = {7d, 8d, 9d};
protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};
protected double[] vec_null = {0d, 0d, 0d};
protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};
protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
public static class RealVectorTestImpl implements RealVector, Serializable {
private static final long serialVersionUID = 8731816072271374422L;
protected double data[];
public RealVectorTestImpl(double[] d) {
data = d.clone();
private UnsupportedOperationException unsupported() {
return new UnsupportedOperationException("Not supported, unneeded for test purposes");
public RealVector copy() {
throw unsupported();
public RealVector add(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector subtract(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector mapAdd(double d) {
throw unsupported();
public RealVector mapAddToSelf(double d) {
throw unsupported();
public RealVector mapSubtract(double d) {
throw unsupported();
public RealVector mapSubtractToSelf(double d) {
throw unsupported();
public RealVector mapMultiply(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * d;
return new RealVectorImpl(out);
public RealVector mapMultiplyToSelf(double d) {
throw unsupported();
public RealVector mapDivide(double d) {
throw unsupported();
public RealVector mapDivideToSelf(double d) {
throw unsupported();
public RealVector mapPow(double d) {
throw unsupported();
public RealVector mapPowToSelf(double d) {
throw unsupported();
public RealVector mapExp() {
throw unsupported();
public RealVector mapExpToSelf() {
throw unsupported();
public RealVector mapExpm1() {
throw unsupported();
public RealVector mapExpm1ToSelf() {
throw unsupported();
public RealVector mapLog() {
throw unsupported();
public RealVector mapLogToSelf() {
throw unsupported();
public RealVector mapLog10() {
throw unsupported();
public RealVector mapLog10ToSelf() {
throw unsupported();
public RealVector mapLog1p() {
throw unsupported();
public RealVector mapLog1pToSelf() {
throw unsupported();
public RealVector mapCosh() {
throw unsupported();
public RealVector mapCoshToSelf() {
throw unsupported();
public RealVector mapSinh() {
throw unsupported();
public RealVector mapSinhToSelf() {
throw unsupported();
public RealVector mapTanh() {
throw unsupported();
public RealVector mapTanhToSelf() {
throw unsupported();
public RealVector mapCos() {
throw unsupported();
public RealVector mapCosToSelf() {
throw unsupported();
public RealVector mapSin() {
throw unsupported();
public RealVector mapSinToSelf() {
throw unsupported();
public RealVector mapTan() {
throw unsupported();
public RealVector mapTanToSelf() {
throw unsupported();
public RealVector mapAcos() {
throw unsupported();
public RealVector mapAcosToSelf() {
throw unsupported();
public RealVector mapAsin() {
throw unsupported();
public RealVector mapAsinToSelf() {
throw unsupported();
public RealVector mapAtan() {
throw unsupported();
public RealVector mapAtanToSelf() {
throw unsupported();
public RealVector mapInv() {
throw unsupported();
public RealVector mapInvToSelf() {
throw unsupported();
public RealVector mapAbs() {
throw unsupported();
public RealVector mapAbsToSelf() {
throw unsupported();
public RealVector mapSqrt() {
throw unsupported();
public RealVector mapSqrtToSelf() {
throw unsupported();
public RealVector mapCbrt() {
throw unsupported();
public RealVector mapCbrtToSelf() {
throw unsupported();
public RealVector mapCeil() {
throw unsupported();
public RealVector mapCeilToSelf() {
throw unsupported();
public RealVector mapFloor() {
throw unsupported();
public RealVector mapFloorToSelf() {
throw unsupported();
public RealVector mapRint() {
throw unsupported();
public RealVector mapRintToSelf() {
throw unsupported();
public RealVector mapSignum() {
throw unsupported();
public RealVector mapSignumToSelf() {
throw unsupported();
public RealVector mapUlp() {
throw unsupported();
public RealVector mapUlpToSelf() {
throw unsupported();
public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double[] getData() {
return data.clone();
public double dotProduct(RealVector v) throws IllegalArgumentException {
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double getNorm() {
throw unsupported();
public double getL1Norm() {
throw unsupported();
public double getLInfNorm() {
throw unsupported();
public double getDistance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getL1Distance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getLInfDistance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector unitVector() {
throw unsupported();
public void unitize() {
throw unsupported();
public RealVector projection(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getEntry(int index) throws MatrixIndexException {
return data[index];
public int getDimension() {
return data.length;
public RealVector append(RealVector v) {
throw unsupported();
public RealVector append(double d) {
throw unsupported();
public RealVector append(double[] a) {
throw unsupported();
public RealVector get(int index, int n) throws MatrixIndexException {
throw unsupported();
public void set(int index, double value) throws MatrixIndexException {
throw unsupported();
public void set(int index, RealVector v) throws MatrixIndexException {
throw unsupported();
public void set(double value) {
throw unsupported();
public double[] toArray() {
throw unsupported();
public boolean isNaN() {
throw unsupported();
public boolean isInfinite() {
throw unsupported();
public static Test suite() {
TestSuite suite = new TestSuite(RealVectorImplTest.class);
suite.setName("RealVectorImpl Tests");
return suite;
public void testConstructors() {
RealVectorImpl v0 = new RealVectorImpl();
assertEquals("testData len", 0, v0.getDimension());
RealVectorImpl v1 = new RealVectorImpl(7);
assertEquals("testData len", 7, v1.getDimension());
assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));
RealVectorImpl v2 = new RealVectorImpl(5, 1.23);
assertEquals("testData len", 5, v2.getDimension());
assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4));
RealVectorImpl v3 = new RealVectorImpl(vec1);
assertEquals("testData len", 3, v3.getDimension());
assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));
RealVectorImpl v4 = new RealVectorImpl(vec4, 3, 2);
assertEquals("testData len", 2, v4.getDimension());
assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));
new RealVectorImpl(vec4, 8, 3);
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVector v5_i = new RealVectorImpl(dvec1);
assertEquals("testData len", 9, v5_i.getDimension());
assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));
RealVectorImpl v5 = new RealVectorImpl(dvec1);
assertEquals("testData len", 9, v5.getDimension());
assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));
RealVectorImpl v6 = new RealVectorImpl(dvec1, 3, 2);
assertEquals("testData len", 2, v6.getDimension());
assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0));
new RealVectorImpl(dvec1, 8, 3);
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v7 = new RealVectorImpl(v1);
assertEquals("testData len", 7, v7.getDimension());
assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));
RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);
RealVectorImpl v7_2 = new RealVectorImpl(v7_i);
assertEquals("testData len", 3, v7_2.getDimension());
assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));
RealVectorImpl v8 = new RealVectorImpl(v1, true);
assertEquals("testData len", 7, v8.getDimension());
assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));
assertNotSame("testData not same object ", v1.data, v8.data);
RealVectorImpl v8_2 = new RealVectorImpl(v1, false);
assertEquals("testData len", 7, v8_2.getDimension());
assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6));
assertEquals("testData same object ", v1.data, v8_2.data);
RealVectorImpl v9 = new RealVectorImpl(v1, v3);
assertEquals("testData len", 10, v9.getDimension());
assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7));
public void testDataInOut() {
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v2 = new RealVectorImpl(vec2);
RealVectorImpl v4 = new RealVectorImpl(vec4);
RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); 
RealVector v_append_1 = v1.append(v2);
assertEquals("testData len", 6, v_append_1.getDimension());
assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));
RealVector v_append_2 = v1.append(2.0);
assertEquals("testData len", 4, v_append_2.getDimension());
assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));
RealVector v_append_3 = v1.append(vec2);
assertEquals("testData len", 6, v_append_3.getDimension());
assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));
RealVector v_append_4 = v1.append(v2_t);
assertEquals("testData len", 6, v_append_4.getDimension());
assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));
RealVector v_copy = v1.copy();
assertEquals("testData len", 3, v_copy.getDimension());
assertNotSame("testData not same object ", v1.data, v_copy.getData());
double[] a_double = v1.toArray();
assertEquals("testData len", 3, a_double.length);
assertNotSame("testData not same object ", v1.data, a_double);
RealVector vout5 = v4.get(3, 3);
assertEquals("testData len", 3, vout5.getDimension());
assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));
v4.get(3, 7);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set1 = (RealVectorImpl) v1.copy();
v_set1.set(1, 11.0);
assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));
v_set1.set(3, 11.0);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set2 = (RealVectorImpl) v4.copy();
v_set2.set(3, v1);
assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));
assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));
v_set2.set(7, v1);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set3 = (RealVectorImpl) v1.copy();
v_set3.set(13.0);
assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));
v_set3.getEntry(23);
fail("ArrayIndexOutOfBoundsException expected");
} catch (ArrayIndexOutOfBoundsException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set4 = (RealVectorImpl) v4.copy();
v_set4.set(3, v2_t);
assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));
assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));
v_set4.set(7, v2_t);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl vout10 = (RealVectorImpl) v1.copy();       
RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy();
assertEquals(vout10, vout10_2);
vout10_2.set(0, 1.1);
assertNotSame(vout10, vout10_2);
public void testMapFunctions() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVector v_mapAdd = v1.mapAdd(2.0d);
double[] result_mapAdd = {3d, 4d, 5d};
assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);
RealVector v_mapAddToSelf = v1.copy();
v_mapAddToSelf.mapAddToSelf(2.0d);
double[] result_mapAddToSelf = {3d, 4d, 5d};
assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);
RealVector v_mapSubtract = v1.mapSubtract(2.0d);
double[] result_mapSubtract = {-1d, 0d, 1d};
assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);
RealVector v_mapSubtractToSelf = v1.copy();
v_mapSubtractToSelf.mapSubtractToSelf(2.0d);
double[] result_mapSubtractToSelf = {-1d, 0d, 1d};
assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);
RealVector v_mapMultiply = v1.mapMultiply(2.0d);
double[] result_mapMultiply = {2d, 4d, 6d};
assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);
RealVector v_mapMultiplyToSelf = v1.copy();
v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);
double[] result_mapMultiplyToSelf = {2d, 4d, 6d};
assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);
RealVector v_mapDivide = v1.mapDivide(2.0d);
double[] result_mapDivide = {.5d, 1d, 1.5d};
assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);
RealVector v_mapDivideToSelf = v1.copy();
v_mapDivideToSelf.mapDivideToSelf(2.0d);
double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};
assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);
RealVector v_mapPow = v1.mapPow(2.0d);
double[] result_mapPow = {1d, 4d, 9d};
assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);
RealVector v_mapPowToSelf = v1.copy();
v_mapPowToSelf.mapPowToSelf(2.0d);
double[] result_mapPowToSelf = {1d, 4d, 9d};
assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);
RealVector v_mapExp = v1.mapExp();
double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};
assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);
RealVector v_mapExpToSelf = v1.copy();
v_mapExpToSelf.mapExpToSelf();
double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};
assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);
RealVector v_mapExpm1 = v1.mapExpm1();
double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};
assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);
RealVector v_mapExpm1ToSelf = v1.copy();
v_mapExpm1ToSelf.mapExpm1ToSelf();
double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};
assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);
RealVector v_mapLog = v1.mapLog();
double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};
assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);
RealVector v_mapLogToSelf = v1.copy();
v_mapLogToSelf.mapLogToSelf();
double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};
assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);
RealVector v_mapLog10 = v1.mapLog10();
double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};
assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);
RealVector v_mapLog10ToSelf = v1.copy();
v_mapLog10ToSelf.mapLog10ToSelf();
double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};
assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);
RealVector v_mapLog1p = v1.mapLog1p();
double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};
assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);
RealVector v_mapLog1pToSelf = v1.copy();
v_mapLog1pToSelf.mapLog1pToSelf();
double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};
assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);
RealVector v_mapCosh = v1.mapCosh();
double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};
assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);
RealVector v_mapCoshToSelf = v1.copy();
v_mapCoshToSelf.mapCoshToSelf();
double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};
assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);
RealVector v_mapSinh = v1.mapSinh();
double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};
assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);
RealVector v_mapSinhToSelf = v1.copy();
v_mapSinhToSelf.mapSinhToSelf();
double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};
assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);
RealVector v_mapTanh = v1.mapTanh();
double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};
assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);
RealVector v_mapTanhToSelf = v1.copy();
v_mapTanhToSelf.mapTanhToSelf();
double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};
assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);
RealVector v_mapCos = v1.mapCos();
double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};
assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);
RealVector v_mapCosToSelf = v1.copy();
v_mapCosToSelf.mapCosToSelf();
double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};
assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);
RealVector v_mapSin = v1.mapSin();
double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};
assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);
RealVector v_mapSinToSelf = v1.copy();
v_mapSinToSelf.mapSinToSelf();
double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};
assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);
RealVector v_mapTan = v1.mapTan();
double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};
assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);
RealVector v_mapTanToSelf = v1.copy();
v_mapTanToSelf.mapTanToSelf();
double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};
assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);
double[] vat_a = {0d, 0.5d, 1.0d};
RealVectorImpl vat = new RealVectorImpl(vat_a);
RealVector v_mapAcos = vat.mapAcos();
double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};
assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);
RealVector v_mapAcosToSelf = vat.copy();
v_mapAcosToSelf.mapAcosToSelf();
double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};
assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);
RealVector v_mapAsin = vat.mapAsin();
double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};
assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);
RealVector v_mapAsinToSelf = vat.copy();
v_mapAsinToSelf.mapAsinToSelf();        
double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};
assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);
RealVector v_mapAtan = vat.mapAtan();
double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};
assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);
RealVector v_mapAtanToSelf = vat.copy();
v_mapAtanToSelf.mapAtanToSelf();
double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};
assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);
RealVector v_mapInv = v1.mapInv();
double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};
assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);
RealVector v_mapInvToSelf = v1.copy();
v_mapInvToSelf.mapInvToSelf();
double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};
assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);
double[] abs_a = {-1.0d, 0.0d, 1.0d};
RealVectorImpl abs_v = new RealVectorImpl(abs_a);
RealVector v_mapAbs = abs_v.mapAbs();
double[] result_mapAbs = {1d,0d,1d};
assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);
RealVector v_mapAbsToSelf = abs_v.copy();
v_mapAbsToSelf.mapAbsToSelf();
double[] result_mapAbsToSelf = {1d,0d,1d};
assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);
RealVector v_mapSqrt = v1.mapSqrt();
double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};
assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);
RealVector v_mapSqrtToSelf = v1.copy();
v_mapSqrtToSelf.mapSqrtToSelf();
double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};
assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);
double[] cbrt_a = {-2.0d, 0.0d, 2.0d};
RealVectorImpl cbrt_v = new RealVectorImpl(cbrt_a);
RealVector v_mapCbrt = cbrt_v.mapCbrt();
double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};
assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);
RealVector v_mapCbrtToSelf = cbrt_v.copy();
v_mapCbrtToSelf.mapCbrtToSelf();
double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};
assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);
double[] ceil_a = {-1.1d, 0.9d, 1.1d};
RealVectorImpl ceil_v = new RealVectorImpl(ceil_a);
RealVector v_mapCeil = ceil_v.mapCeil();
double[] result_mapCeil = {-1d,1d,2d};
assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);
RealVector v_mapCeilToSelf = ceil_v.copy();
v_mapCeilToSelf.mapCeilToSelf();
double[] result_mapCeilToSelf =  {-1d,1d,2d};
assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);
RealVector v_mapFloor = ceil_v.mapFloor();
double[] result_mapFloor = {-2d,0d,1d};
assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);
RealVector v_mapFloorToSelf = ceil_v.copy();
v_mapFloorToSelf.mapFloorToSelf();
double[] result_mapFloorToSelf =  {-2d,0d,1d};
assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);
RealVector v_mapRint = ceil_v.mapRint();
double[] result_mapRint = {-1d,1d,1d};
assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);
RealVector v_mapRintToSelf = ceil_v.copy();
v_mapRintToSelf.mapRintToSelf();
double[] result_mapRintToSelf =  {-1d,1d,1d};
assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);
RealVector v_mapSignum = ceil_v.mapSignum();
double[] result_mapSignum = {-1d,1d,1d};
assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);
RealVector v_mapSignumToSelf = ceil_v.copy();
v_mapSignumToSelf.mapSignumToSelf();
double[] result_mapSignumToSelf =  {-1d,1d,1d};
assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);
RealVector v_mapUlp = ceil_v.mapUlp();
double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};
assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);
RealVector v_mapUlpToSelf = ceil_v.copy();
v_mapUlpToSelf.mapUlpToSelf();
double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};
assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);
public void testBasicFunctions() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v2 = new RealVectorImpl(vec2);
RealVectorImpl v_null = new RealVectorImpl(vec_null);
RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); 
double d_getNorm = v1.getNorm();
assertEquals("compare values  ", 3.7416573867739413,d_getNorm);
double d_getL1Norm = v1.getL1Norm();
assertEquals("compare values  ",6.0, d_getL1Norm);
double d_getLInfNorm = v1.getLInfNorm();
assertEquals("compare values  ",6.0, d_getLInfNorm);
double dist = v1.getDistance(v2);
assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );
double dist_2 = v1.getDistance(v2_t);
assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );
double d_getL1Distance = v1. getL1Distance(v2);
assertEquals("compare values  ",9d, d_getL1Distance );
double d_getL1Distance_2 = v1. getL1Distance(v2_t);
assertEquals("compare values  ",9d, d_getL1Distance_2 );
double d_getLInfDistance = v1. getLInfDistance(v2);
assertEquals("compare values  ",3d, d_getLInfDistance );
double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);
assertEquals("compare values  ",3d, d_getLInfDistance_2 );
RealVectorImpl v_add = v1.add(v2);
double[] result_add = {5d, 7d, 9d};
assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);
RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);
RealVector v_add_i = v1.add(vt2);
double[] result_add_i = {5d, 7d, 9d};
assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);
RealVectorImpl v_subtract = v1.subtract(v2);
double[] result_subtract = {-3d, -3d, -3d};
assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);
RealVector v_subtract_i = v1.subtract(vt2);
double[] result_subtract_i = {-3d, -3d, -3d};
assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);
RealVectorImpl  v_ebeMultiply = v1.ebeMultiply(v2);
double[] result_ebeMultiply = {4d, 10d, 18d};
assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);
RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);
double[] result_ebeMultiply_2 = {4d, 10d, 18d};
assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);
RealVectorImpl  v_ebeDivide = v1.ebeDivide(v2);
double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};
assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);
RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);
double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};
assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);
double dot =  v1.dotProduct(v2);
assertEquals("compare val ",32d, dot);
double dot_2 =  v1.dotProduct(v2_t);
assertEquals("compare val ",32d, dot_2);
RealMatrixImpl m_outerProduct = v1.outerProduct(v2);
assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));
RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);
assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));
RealVector v_unitVector = v1.unitVector();
RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); 
assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);
v_null.unitVector();
fail("Expecting ArithmeticException");
} catch (ArithmeticException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_unitize = (RealVectorImpl)v1.copy();
v_unitize.unitize();
assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);
v_null.unitize();
fail("Expecting ArithmeticException");
} catch (ArithmeticException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_projection = v1.projection(v2);
double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};
assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);
RealVector v_projection_2 = v1.projection(v2_t);
double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};
assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);
}  
public void testMisc() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v4 = new RealVectorImpl(vec4);
RealVector v4_2 = new RealVectorImpl(vec4);
String out1 = v1.toString();
assertTrue("some output ",  out1.length()!=0);
double[] dout1 = v1.copyOut();
assertEquals("testData len", 3, dout1.length);
assertNotSame("testData not same object ", v1.data, dout1);   
v1.checkVectorDimensions(2); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
} 
v1.checkVectorDimensions(v4); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
}        
v1.checkVectorDimensions(v4_2); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
}        
public void testPredicates() {
RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 });
assertFalse(v.isNaN());
v.set(1, Double.NaN);
assertTrue(v.isNaN());
assertFalse(v.isInfinite());
v.set(0, Double.POSITIVE_INFINITY);
assertFalse(v.isInfinite());
v.set(1, 1);
assertTrue(v.isInfinite());
v.set(0, 0);
assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 }));
assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)}));
assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 }));
assertEquals(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode(),
new RealVectorImpl(new double[] { 0, Double.NaN, 2 }).hashCode());
assertTrue(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode() !=
new RealVectorImpl(new double[] { 0, 1, 2 }).hashCode());
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
fail("vectors have different lengths");
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);
integ.addStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();
integ.addStepHandler(cm);
private static final long serialVersionUID = 2472449657345878299L;
public void computeDerivatives(double t, double[] y, double[] dot)
throws DerivativeException {
dot[0] = -y[1];
dot[1] =  y[0];
public int getDimension() {
return 2;
};
integ1.addStepHandler(cm1);
integ2.addStepHandler(cm2);
package org.apache.commons.math.ode.nonstiff;
public class AdamsBashforthIntegratorTest
extends TestCase {
public AdamsBashforthIntegratorTest(String name) {
super(name);
public void testCoefficients() {
double[] coeffs1 = new AdamsBashforthIntegrator(1, 0.01).getCoeffs();
assertEquals(1, coeffs1.length);
assertEquals(1.0, coeffs1[0], 1.0e-16);
double[] coeffs2 = new AdamsBashforthIntegrator(2, 0.01).getCoeffs();
assertEquals(2, coeffs2.length);
assertEquals( 3.0 / 2.0, coeffs2[0], 1.0e-16);
assertEquals(-1.0 / 2.0, coeffs2[1], 1.0e-16);
double[] coeffs3 = new AdamsBashforthIntegrator(3, 0.01).getCoeffs();
assertEquals(3, coeffs3.length);
assertEquals( 23.0 / 12.0, coeffs3[0], 1.0e-16);
assertEquals(-16.0 / 12.0, coeffs3[1], 1.0e-16);
assertEquals(  5.0 / 12.0, coeffs3[2], 1.0e-16);
double[] coeffs4 = new AdamsBashforthIntegrator(4, 0.01).getCoeffs();
assertEquals(4, coeffs4.length);
assertEquals( 55.0 / 24.0, coeffs4[0], 1.0e-16);
assertEquals(-59.0 / 24.0, coeffs4[1], 1.0e-16);
assertEquals( 37.0 / 24.0, coeffs4[2], 1.0e-16);
assertEquals( -9.0 / 24.0, coeffs4[3], 1.0e-16);
double[] coeffs5 = new AdamsBashforthIntegrator(5, 0.01).getCoeffs();
assertEquals(5, coeffs5.length);
assertEquals( 1901.0 / 720.0, coeffs5[0], 1.0e-16);
assertEquals(-2774.0 / 720.0, coeffs5[1], 1.0e-16);
assertEquals( 2616.0 / 720.0, coeffs5[2], 1.0e-16);
assertEquals(-1274.0 / 720.0, coeffs5[3], 1.0e-16);
assertEquals(  251.0 / 720.0, coeffs5[4], 1.0e-16);
double[] coeffs6 = new AdamsBashforthIntegrator(6, 0.01).getCoeffs();
assertEquals(6, coeffs6.length);
assertEquals( 4277.0 / 1440.0, coeffs6[0], 1.0e-16);
assertEquals(-7923.0 / 1440.0, coeffs6[1], 1.0e-16);
assertEquals( 9982.0 / 1440.0, coeffs6[2], 1.0e-16);
assertEquals(-7298.0 / 1440.0, coeffs6[3], 1.0e-16);
assertEquals( 2877.0 / 1440.0, coeffs6[4], 1.0e-16);
assertEquals( -475.0 / 1440.0, coeffs6[5], 1.0e-16);
double[] coeffs7 = new AdamsBashforthIntegrator(7, 0.01).getCoeffs();
assertEquals(7, coeffs7.length);
assertEquals( 198721.0 / 60480.0, coeffs7[0], 1.0e-16);
assertEquals(-447288.0 / 60480.0, coeffs7[1], 1.0e-16);
assertEquals( 705549.0 / 60480.0, coeffs7[2], 1.0e-16);
assertEquals(-688256.0 / 60480.0, coeffs7[3], 1.0e-16);
assertEquals( 407139.0 / 60480.0, coeffs7[4], 1.0e-16);
assertEquals(-134472.0 / 60480.0, coeffs7[5], 1.0e-16);
assertEquals(  19087.0 / 60480.0, coeffs7[6], 1.0e-16);
double[] coeffs8 = new AdamsBashforthIntegrator(8, 0.01).getCoeffs();
assertEquals(8, coeffs8.length);
assertEquals(  434241.0 / 120960.0, coeffs8[0], 1.0e-16);
assertEquals(-1152169.0 / 120960.0, coeffs8[1], 1.0e-16);
assertEquals( 2183877.0 / 120960.0, coeffs8[2], 1.0e-16);
assertEquals(-2664477.0 / 120960.0, coeffs8[3], 1.0e-16);
assertEquals( 2102243.0 / 120960.0, coeffs8[4], 1.0e-16);
assertEquals(-1041723.0 / 120960.0, coeffs8[5], 1.0e-16);
assertEquals(  295767.0 / 120960.0, coeffs8[6], 1.0e-16);
assertEquals(  -36799.0 / 120960.0, coeffs8[7], 1.0e-16);
double[] coeffs9 = new AdamsBashforthIntegrator(9, 0.01).getCoeffs();
assertEquals(9, coeffs9.length);
assertEquals(  14097247.0 / 3628800.0, coeffs9[0], 1.0e-16);
assertEquals( -43125206.0 / 3628800.0, coeffs9[1], 1.0e-16);
assertEquals(  95476786.0 / 3628800.0, coeffs9[2], 1.0e-16);
assertEquals(-139855262.0 / 3628800.0, coeffs9[3], 1.0e-16);
assertEquals( 137968480.0 / 3628800.0, coeffs9[4], 1.0e-16);
assertEquals( -91172642.0 / 3628800.0, coeffs9[5], 1.0e-16);
assertEquals(  38833486.0 / 3628800.0, coeffs9[6], 1.0e-16);
assertEquals(  -9664106.0 / 3628800.0, coeffs9[7], 1.0e-16);
assertEquals(   1070017.0 / 3628800.0, coeffs9[8], 1.0e-16);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new AdamsBashforthIntegrator(3, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
} catch(DerivativeException de) {
fail("wrong exception caught");
} catch(IntegratorException ie) {
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if (i > 6) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-9);
assertTrue(handler.getMaximalValueError() < 3.0e-8);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
assertEquals("Adams-Bashforth", integ.getName());
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.05);
assertTrue(handler.getMaximalValueError() > 0.1);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
public static Test suite() {
return new TestSuite(AdamsBashforthIntegratorTest.class);
package org.apache.commons.math.ode.nonstiff;
public class AdamsMoultonIntegratorTest
extends TestCase {
public AdamsMoultonIntegratorTest(String name) {
super(name);
public void testPredictorCoefficients() {
for (int order = 1; order < 10; ++order) {
double[] moulton = new AdamsMoultonIntegrator(order, 0.01).getPredictorCoeffs();
double[] bashforth  = new AdamsBashforthIntegrator(order, 0.01).getCoeffs();
assertEquals(bashforth.length, moulton.length);
for (int i = 0; i < moulton.length; ++i) {
assertEquals(bashforth[i], moulton[i], 1.0e-16);
public void testCorrectorCoefficients() {
double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs();
assertEquals(2, coeffs1.length);
assertEquals(1.0 / 2.0, coeffs1[0], 1.0e-16);
assertEquals(1.0 / 2.0, coeffs1[1], 1.0e-16);
double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs();
assertEquals(3, coeffs2.length);
assertEquals( 5.0 / 12.0, coeffs2[0], 1.0e-16);
assertEquals( 8.0 / 12.0, coeffs2[1], 1.0e-16);
assertEquals(-1.0 / 12.0, coeffs2[2], 1.0e-16);
double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs();
assertEquals(4, coeffs3.length);
assertEquals( 9.0 / 24.0, coeffs3[0], 1.0e-16);
assertEquals(19.0 / 24.0, coeffs3[1], 1.0e-16);
assertEquals(-5.0 / 24.0, coeffs3[2], 1.0e-16);
assertEquals( 1.0 / 24.0, coeffs3[3], 1.0e-16);
double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs();
assertEquals(5, coeffs4.length);
assertEquals( 251.0 / 720.0, coeffs4[0], 1.0e-16);
assertEquals( 646.0 / 720.0, coeffs4[1], 1.0e-16);
assertEquals(-264.0 / 720.0, coeffs4[2], 1.0e-16);
assertEquals( 106.0 / 720.0, coeffs4[3], 1.0e-16);
assertEquals( -19.0 / 720.0, coeffs4[4], 1.0e-16);
double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs();
assertEquals(6, coeffs5.length);
assertEquals( 475.0 / 1440.0, coeffs5[0], 1.0e-16);
assertEquals(1427.0 / 1440.0, coeffs5[1], 1.0e-16);
assertEquals(-798.0 / 1440.0, coeffs5[2], 1.0e-16);
assertEquals( 482.0 / 1440.0, coeffs5[3], 1.0e-16);
assertEquals(-173.0 / 1440.0, coeffs5[4], 1.0e-16);
assertEquals(  27.0 / 1440.0, coeffs5[5], 1.0e-16);
double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs();
assertEquals(7, coeffs6.length);
assertEquals( 19087.0 / 60480.0, coeffs6[0], 1.0e-16);
assertEquals( 65112.0 / 60480.0, coeffs6[1], 1.0e-16);
assertEquals(-46461.0 / 60480.0, coeffs6[2], 1.0e-16);
assertEquals( 37504.0 / 60480.0, coeffs6[3], 1.0e-16);
assertEquals(-20211.0 / 60480.0, coeffs6[4], 1.0e-16);
assertEquals(  6312.0 / 60480.0, coeffs6[5], 1.0e-16);
assertEquals(  -863.0 / 60480.0, coeffs6[6], 1.0e-16);
double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs();
assertEquals(8, coeffs7.length);
assertEquals(  36799.0 / 120960.0, coeffs7[0], 1.0e-16);
assertEquals( 139849.0 / 120960.0, coeffs7[1], 1.0e-16);
assertEquals(-121797.0 / 120960.0, coeffs7[2], 1.0e-16);
assertEquals( 123133.0 / 120960.0, coeffs7[3], 1.0e-16);
assertEquals( -88547.0 / 120960.0, coeffs7[4], 1.0e-16);
assertEquals(  41499.0 / 120960.0, coeffs7[5], 1.0e-16);
assertEquals( -11351.0 / 120960.0, coeffs7[6], 1.0e-16);
assertEquals(   1375.0 / 120960.0, coeffs7[7], 1.0e-16);
double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs();
assertEquals(9, coeffs8.length);
assertEquals( 1070017.0 / 3628800.0, coeffs8[0], 1.0e-16);
assertEquals( 4467094.0 / 3628800.0, coeffs8[1], 1.0e-16);
assertEquals(-4604594.0 / 3628800.0, coeffs8[2], 1.0e-16);
assertEquals( 5595358.0 / 3628800.0, coeffs8[3], 1.0e-16);
assertEquals(-5033120.0 / 3628800.0, coeffs8[4], 1.0e-16);
assertEquals( 3146338.0 / 3628800.0, coeffs8[5], 1.0e-16);
assertEquals(-1291214.0 / 3628800.0, coeffs8[6], 1.0e-16);
assertEquals(  312874.0 / 3628800.0, coeffs8[7], 1.0e-16);
assertEquals(  -33953.0 / 3628800.0, coeffs8[8], 1.0e-16);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new AdamsMoultonIntegrator(3, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
} catch(DerivativeException de) {
fail("wrong exception caught");
} catch(IntegratorException ie) {
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
if (pb instanceof TestProblem3) {
step /= 8;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if (i > 6) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 7.0e-12);
assertTrue(handler.getMaximalValueError() < 4.0e-11);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
assertEquals("Adams-Moulton", integ.getName());
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
assertTrue(handler.getMaximalValueError() > 0.03);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
public static Test suite() {
return new TestSuite(AdamsMoultonIntegratorTest.class);
package org.apache.commons.math.ode.nonstiff;
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(handler);
integ.addStepHandler(handler);
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 7510061424396717277L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
integ.addStepHandler(handler);
private static final long serialVersionUID = -8168590945325629799L;
integ.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerHandler(pb));
integ.addStepHandler(new VariableHandler());
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
private static final long serialVersionUID = -1645853847806655456L;
private static final long serialVersionUID = -5196650833828379228L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = -6768136169276197L;
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 3300);
integ.addStepHandler(new VariableHandler());
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(DummyStepHandler.getInstance());
integ.addStepHandler(new InterpolatingStepHandler());
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = -1752092987112788459L;
private static final long serialVersionUID = 5542665697103383623L;
private static final long serialVersionUID = -5272695044664350727L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 2209212559670665268L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new EulerIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
throws DerivativeException {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
EulerIntegrator integ = new EulerIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
private static final long serialVersionUID = 291437140744677100L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
integ.addStepHandler(new KeplerStepHandler(pb));
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = 1250933165809631538L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new GillIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
GillIntegrator integ = new GillIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
integ.addStepHandler(handler);
integrator.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerStepHandler(pb));
integ.addStepHandler(new VariableStepHandler());
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = -8231434585284002546L;
private static final long serialVersionUID = -5955452449048688985L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep   = 0;
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-8;
double relTolerance = 1.0e-8;
GraggBulirschStoerIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-8);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = -5947183291381232297L;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -1157081786301178032L;
public void computeDerivatives(double t, double[] y, double[] dot)
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
public void testEventsErrors()
integ.addStepHandler(handler);
integ.addEventHandler(new EventHandler() {
return EventHandler.CONTINUE;
public double g(double t, double[] y) throws EventException {
throw new EventException("Evaluation failed for argument = {0}",
new Object[] { Double.valueOf(t) });
public void testEventsNoConvergence()
integ.addStepHandler(handler);
integ.addEventHandler(new EventHandler() {
return EventHandler.CONTINUE;
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 3200246026175251943L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 9111679755950880352L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new MidpointIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
MidpointIntegrator integ = new MidpointIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
public class StepInterpolatorAbstractTest extends TestCase {
protected StepInterpolatorAbstractTest(String name) {
super(name);
protected void checkDerivativesConsistency(final FirstOrderIntegrator integrator,
final TestProblemAbstract problem,
final double threshold)
throws DerivativeException, IntegratorException {
integrator.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 2462564234755682953L;
public boolean requiresDenseOutput() {
return true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());
final double t = interpolator.getCurrentTime() - 300 * h;
if (Math.abs(h) < 10 * Math.ulp(t)) {
return;
interpolator.setInterpolatedTime(t - 4 * h);
final double[] yM4h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - 3 * h);
final double[] yM3h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - 2 * h);
final double[] yM2h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - h);
final double[] yM1h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + h);
final double[] yP1h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 2 * h);
final double[] yP2h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 3 * h);
final double[] yP3h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 4 * h);
final double[] yP4h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t);
final double[] yDot = interpolator.getInterpolatedDerivatives();
for (int i = 0; i < yDot.length; ++i) {
final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) +
32 * (yP3h[i] - yM3h[i]) +
-168 * (yP2h[i] - yM2h[i]) +
672 * (yP1h[i] - yM1h[i])) / (840 * h);
if (Math.abs(approYDot - yDot[i]) >= threshold) {
System.out.println("gotcha!");
assertEquals(approYDot, yDot[i], threshold);
public void reset() {
});
integrator.integrate(problem,
problem.getInitialTime(), problem.getInitialState(),
problem.getFinalTime(), new double[problem.getDimension()]);
package org.apache.commons.math.ode.nonstiff;
implements FirstOrderDifferentialEquations, EventHandler {
package org.apache.commons.math.ode.nonstiff;
public class TestProblem1
private static final long serialVersionUID = 1977870815289373164L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem2
private static final long serialVersionUID = 8330741783213512366L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem3
private static final long serialVersionUID = 8567328542728919999L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem4
private static final long serialVersionUID = -5910438521889015745L;
public EventHandler[] getEventsHandlers() {
return new EventHandler[] { new Bounce(), new Stop() };
private static class Bounce implements EventHandler {
return EventHandler.RESET_STATE;
y[0] = -y[0];
private static class Stop implements EventHandler {
return EventHandler.STOP;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem5
private static final long serialVersionUID = 7579233102411804237L;
package org.apache.commons.math.ode.nonstiff;
public abstract class TestProblemAbstract
public EventHandler[] getEventsHandlers() {
return new EventHandler[0];
package org.apache.commons.math.ode.nonstiff;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 3589490480549900461L;
private ODEIntegrator integrator;
public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {
expectedStepStart = Double.NaN;
if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {
if (!Double.isNaN(expectedStepStart)) {
maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));
expectedStepStart = start + integrator.getCurrentSignedStepsize();
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 4400497468419540899L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.sampling;
assertTrue(bos.size () > 300);
assertTrue(bos.size () < 350);
package org.apache.commons.math.ode.sampling;
integ.addStepHandler(new StepNormalizer(range / 10.0,
private static final long serialVersionUID = 1650337364641626444L;
private boolean firstCall = true;
double[] yDot,
integ.addStepHandler(new StepNormalizer(range / 10.5,
private static final long serialVersionUID = 2228457391561277298L;
public void handleStep(double t,
double[] yDot,
ArrayList<Double> list = new ArrayList<Double>();
for (Double data : list) {
dataArray[i] = data.doubleValue();
Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue();
HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}
HashSet<Object> hs = new HashSet<Object>();
HashSet<Object> hs = new HashSet<Object>();
hs = new HashSet<Object>();
HashSet<Object> set = (HashSet<Object>) u[i];
HashSet<Object> sampSet = new HashSet<Object>();
assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2)));
f.addValue(Integer.valueOf(1));
f.addValue(Long.valueOf(1));
f.addValue(Integer.valueOf(-1));
assertEquals("1 count", 3, f.getCount(Integer.valueOf(1)));
assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   
obj1 = Integer.valueOf(1);
Integer int1 = Integer.valueOf(1);
f.addValue(Long.valueOf(2));
assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));
assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);
private Map<String, Double> certifiedValues;
certifiedValues = new HashMap<String, Double>();
Double value = Double.valueOf(valueString);
for (String name : certifiedValues.keySet()) {
return Double.valueOf(((Long) property).doubleValue());
public class DescriptiveStatisticsTest extends TestCase {
protected List<Object> list;
this(new ArrayList<Object>());
public ListUnivariateImpl(List<Object> list) {
public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {
list.add(Double.valueOf(v));
List<Object> externalList = new ArrayList<Object>();
List<Object> list = new ArrayList<Object>();
list.add( Double.valueOf(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());
List<Object> externalList = new ArrayList<Object>();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
new ListUnivariateImpl(new ArrayList<Object>(), transformers);
u.addObject(Integer.valueOf(12));
u.addObject(Long.valueOf(21));
u.addObject(Float.valueOf(14.1f));
u.addObject(Double.valueOf(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
assertFalse(u.equals(Double.valueOf(0)));
assertFalse("wrong type", u.equals(Double.valueOf(0)));
public class SummaryStatisticsTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsTest(String name) {
super(name);
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(Double.valueOf(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> emptyContents = new ArrayList<double[]>();
List<double[]> tooFew = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
private List<double[]> classes = new ArrayList<double[]>();
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegressionTest {
protected MultipleLinearRegression regression;
public void setUp(){
regression = createRegression();
protected abstract MultipleLinearRegression createRegression();
protected abstract int getNumberOfRegressors();
protected abstract int getSampleSize();
public void canEstimateRegressionParameters(){
double[] beta = regression.estimateRegressionParameters();        
assertEquals(getNumberOfRegressors(), beta.length);
public void canEstimateResiduals(){
double[] e = regression.estimateResiduals();
assertEquals(getSampleSize(), e.length);
public void canEstimateRegressionParametersVariance(){
double[][] variance = regression.estimateRegressionParametersVariance();
assertEquals(getNumberOfRegressors(), variance.length);
public void canEstimateRegressandVariance(){
if (getSampleSize() > getNumberOfRegressors()) {
double variance = regression.estimateRegressandVariance();
assertTrue(variance > 0.0);
}   
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
private double[][] omega;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
omega = new double[6][];
omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};
omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};
omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};
omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};
omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};
omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};
super.setUp();
public void cannotAddXSampleData() {
createRegression().newSampleData(new double[]{}, null, null);
public void cannotAddNullYSampleData() {
createRegression().newSampleData(null, new double[][]{}, null);
public void cannotAddSampleDataWithSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[1][];
x[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x, null);
public void cannotAddNullCovarianceData() {
createRegression().newSampleData(new double[]{}, new double[][]{}, null);
public void cannotAddCovarianceDataWithSampleSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[1][];
omega[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x, omega);
public void cannotAddCovarianceDataThatIsNotSquare() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[3][];
omega[0] = new double[]{1.0, 0};
omega[1] = new double[]{0, 1.0};
omega[2] = new double[]{0, 2.0};
createRegression().newSampleData(y, x, omega);
protected GLSMultipleLinearRegression createRegression() {
GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();
regression.newSampleData(y, x, omega);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
super.setUp();
protected OLSMultipleLinearRegression createRegression() {
OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();
regression.newSampleData(y, x);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;
public void cannotAddXSampleData() {
createRegression().newSampleData(new double[]{}, null);
public void cannotAddNullYSampleData() {
createRegression().newSampleData(null, new double[][]{});
public void cannotAddSampleDataWithSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[1][];
x[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x);
public void testPerfectFit() {
double[] betaHat = regression.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{11.0,0.5,0.666666666666667,0.75,0.8,0.8333333333333333},
1e-12);
double[] residuals = regression.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},
1e-12);
double[][] errors = regression.estimateRegressionParametersVariance();
public void testLongly() {
double[] design = new double[] {
60323,83.0,234289,2356,1590,107608,1947,
61122,88.5,259426,2325,1456,108632,1948,
60171,88.2,258054,3682,1616,109773,1949,
61187,89.5,284599,3351,1650,110929,1950,
63221,96.2,328975,2099,3099,112075,1951,
63639,98.1,346999,1932,3594,113270,1952,
64989,99.0,365385,1870,3547,115094,1953,
63761,100.0,363112,3578,3350,116219,1954,
66019,101.2,397469,2904,3048,117388,1955,
67857,104.6,419180,2822,2857,118734,1956,
68169,108.4,442769,2936,2798,120445,1957,
66513,110.8,444546,4681,2637,121950,1958,
68655,112.6,482704,3813,2552,123366,1959,
69564,114.2,502601,3931,2514,125368,1960,
69331,115.7,518173,4806,2572,127852,1961,
70551,116.9,554894,4007,2827,130081,1962
};
int nobs = 16;
int nvars = 6;
OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();
model.newSampleData(design, nobs, nvars);
double[] betaHat = model.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{-3482258.63459582, 15.0618722713733,
-0.358191792925910E-01,-2.02022980381683,
-1.03322686717359,-0.511041056535807E-01,
1829.15146461355}, 1E-8); // 
double[] residuals = model.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{
267.340029759711,-94.0139423988359,46.28716775752924,
-410.114621930906,309.7145907602313,-249.3112153297231,
-164.0489563956039,-13.18035686637081,14.30477260005235,
455.394094551857,-17.26892711483297,-39.0550425226967,
-155.5499735953195,-85.6713080421283,341.9315139607727,
-206.7578251937366},
1E-8);
double[][] errors = model.estimateRegressionParametersVariance();
public void testSwissFertility() {
double[] design = new double[] {
80.2,17.0,15,12,9.96,
83.1,45.1,6,9,84.84,
92.5,39.7,5,5,93.40,
85.8,36.5,12,7,33.77,
76.9,43.5,17,15,5.16,
76.1,35.3,9,7,90.57,
83.8,70.2,16,7,92.85,
92.4,67.8,14,8,97.16,
82.4,53.3,12,7,97.67,
82.9,45.2,16,13,91.38,
87.1,64.5,14,6,98.61,
64.1,62.0,21,12,8.52,
66.9,67.5,14,7,2.27,
68.9,60.7,19,12,4.43,
61.7,69.3,22,5,2.82,
68.3,72.6,18,2,24.20,
71.7,34.0,17,8,3.30,
55.7,19.4,26,28,12.11,
54.3,15.2,31,20,2.15,
65.1,73.0,19,9,2.84,
65.5,59.8,22,10,5.23,
65.0,55.1,14,3,4.52,
56.6,50.9,22,12,15.14,
57.4,54.1,20,6,4.20,
72.5,71.2,12,1,2.40,
74.2,58.1,14,8,5.23,
72.0,63.5,6,3,2.56,
60.5,60.8,16,10,7.72,
58.3,26.8,25,19,18.46,
65.4,49.5,15,8,6.10,
75.5,85.9,3,2,99.71,
69.3,84.9,7,6,99.68,
77.3,89.7,5,2,100.00,
70.5,78.2,12,6,98.96,
79.4,64.9,7,3,98.22,
65.0,75.9,9,9,99.06,
92.2,84.6,3,3,99.46,
79.3,63.1,13,13,96.83,
70.4,38.4,26,12,5.62,
65.7,7.7,29,11,13.79,
72.7,16.7,22,13,11.22,
64.4,17.6,35,32,16.92,
77.6,37.6,15,7,4.97,
67.6,18.7,25,7,8.65,
35.0,1.2,37,53,42.34,
44.7,46.6,16,29,50.43,
42.8,27.7,22,29,58.33
};
int nobs = 47;
int nvars = 4;
OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();
model.newSampleData(design, nobs, nvars);
double[] betaHat = model.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{91.05542390271397,
-0.22064551045715,
-0.26058239824328,
-0.96161238456030,
0.12441843147162}, 1E-12);
double[] residuals = model.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{
7.1044267859730512,1.6580347433531366,
4.6944952770029644,8.4548022690166160,13.6547432343186212,
-9.3586864458500774,7.5822446330520386,15.5568995563859289,
0.8113090736598980,7.1186762732484308,7.4251378771228724,
2.6761316873234109,0.8351584810309354,7.1769991119615177,
-3.8746753206299553,-3.1337779476387251,-0.1412575244091504,
1.1186809170469780,-6.3588097346816594,3.4039270429434074,
2.3374058329820175,-7.9272368576900503,-7.8361010968497959,
-11.2597369269357070,0.9445333697827101,6.6544245101380328,
-0.9146136301118665,-4.3152449403848570,-4.3536932047009183,
-3.8907885169304661,-6.3027643926302188,-7.8308982189289091,
-3.1792280015332750,-6.7167298771158226,-4.8469946718041754,
-10.6335664353633685,11.1031134362036958,6.0084032641811733,
5.4326230830188482,-7.2375578629692230,2.1671550814448222,
15.0147574652763112,4.8625103516321015,-7.1597256413907706,
-0.4515205619767598,-10.2916870903837587,-15.7812984571900063},
1E-12);  
private double[][] removeSingle = {infData[1]};
private double[][] removeMultiple = { infData[1], infData[2] };
private double removeX = infData[0][0];
private double removeY = infData[0][1];
public void testRemoveXY() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeX, removeY);
regression.addData(removeX, removeY);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveSingle() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeSingle);
regression.addData(removeSingle);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveMultiple() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeMultiple);
regression.addData(removeMultiple);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveObsFromEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.removeData(removeX, removeY);
assertEquals(regression.getN(), 0);
public void testRemoveObsFromSingle() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeX, removeY);
regression.removeData(removeX, removeY);
assertEquals(regression.getN(), 0);
public void testRemoveMultipleToEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeMultiple);
regression.removeData(removeMultiple);
assertEquals(regression.getN(), 0);
public void testRemoveMultiplePastEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeX, removeY);
regression.removeData(removeMultiple);
assertEquals(regression.getN(), 0);
Double input = Double.valueOf(expected);
Integer input = Integer.valueOf(1);
private Double x = Double.valueOf(1.0);value = new Double(d);
value = new Float(f);
value = new Integer(i);
value = new Long(l);
dynaBean.set(propertyName, new Double(v));
VitalStats vs1 = new VitalStats( new Double(120.0), 
new Double(96.4) );
Patient p1 = new Patient( vs1, new Integer( 35 ) );
VitalStats vs2 = new VitalStats( new Double(70.0), 
new Double(97.4) );
Patient p2 = new Patient( vs2, new Integer( 23 ) );
VitalStats vs3 = new VitalStats( new Double(90.0), 
new Double(98.6) );
Patient p3 = new Patient( vs3, new Integer( 42 ) );
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
new Integer(dimension1), new Integer(dimension2)
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
private static final long serialVersionUID = -7619974756160279127L;
new Object[] { new Double(argument) });
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
new Object[] { new Integer(maxIterations) });
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
} catch(Throwable t) {
return new UnivariateRealSolverFactoryImpl();
return factory;
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
new Double(initial), new Double(lowerBound), new Double(upperBound),
new Double(a), new Double(b), new Double(fa), new Double(fb) });
protected double imaginary;
protected double real;
public class ComplexFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
public ComplexFormat(NumberFormat realFormat,
NumberFormat imaginaryFormat) {
public static String formatComplex( Complex c ) {
return getInstance().format( c );
throw new IllegalArgumentException(
"Cannot format given Object as a Date");
private StringBuffer formatDouble(double value, NumberFormat format,
StringBuffer toAppendTo, FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
} else {
format.format(value, toAppendTo, pos);
return toAppendTo;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
private static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
"\"", parsePosition.getErrorIndex());
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
if ((startIndex >= source.length()) ||
(endIndex > source.length()) ||
source.substring(startIndex, endIndex).compareTo(
getImaginaryCharacter()) != 0) {
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
pos.setIndex(endIndex);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
} while (Character.isWhitespace(c) && index < n);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(String source, double value, ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
int n = sb.length();
int startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = new Double(value);
pos.setIndex(endIndex);
return ret;
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
int endIndex = pos.getIndex();
if (startIndex == endIndex) {
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
public static Complex acos(Complex z) {
return z.acos();
public static Complex asin(Complex z) {
return z.asin();
public static Complex atan(Complex z) {
return z.atan();
public static Complex cos(Complex z) {
return z.cos();
public static Complex cosh(Complex z) {
return z.cosh();
public static Complex exp(Complex z) {
return z.exp();
public static Complex log(Complex z) {
return z.log();
public static Complex pow(Complex y, Complex x) {
return y.pow(x);
public static Complex sin(Complex z) {
return z.sin();
public static Complex sinh(Complex z) {
return z.sinh();
public static Complex sqrt(Complex z) {
return z.sqrt();
public static Complex sqrt1z(Complex z) {
return z.sqrt1z();
public static Complex tan(Complex z) {
return z.tan();
public static Complex tanh(Complex z) {
return z.tanh();
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
}    
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
new Object[] { new Integer(maxCostEval) });
return new RealMatrixImpl(jTj).inverse().getData();
new Object[] { new Integer(m), new Integer(p)});
new Object[] { new Double(costRelativeTolerance) });
new Object[] { new Double(parRelativeTolerance) });
new Object[] { new Double(orthoTolerance) });
new Object[] { new Integer(rows), new Integer(cols) });
parameters   = new ArrayList();
measurements = new ArrayList();
List unbound = new ArrayList(parameters.size());
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
private final List parameters;
private final List measurements;
public class Fraction extends Number implements Comparable {
private static final long serialVersionUID = -8958519416450949235L;
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
new Object[] { new Double(value), new Integer(maxIterations) });
new Object[] { new Double(value), new Long(p), new Long(q) });
public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private static final long serialVersionUID = 8225864499430109352L;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
private static final long serialVersionUID = -5721105387745193385L;
private BigDecimal data[][] = null;
private BigDecimal lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
int nRows = d.length;
int nCols = d[0].length;
int nRows = d.length;
int nCols = d[0].length;
int nRows = v.length;
return new BigMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(d);
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].multiply(d);
return new BigMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
BigDecimal sum = ZERO;
sum = ZERO;
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
outData[row][col] = sum;
return new BigMatrixImpl(outData);
int nRows = getRowDimension();
int nCols = getColumnDimension();
double d[][] = new double[nRows][nCols];
for (int j=0; j<nCols;j++) {
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
selectedColumns.length);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out);
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out);
int ncols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[ncols];
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
BigDecimal[] out = new BigDecimal[nRows];
int nrows = this.getRowDimension();
double[] out = new double[nrows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
BigDecimal[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createBigIdentityMatrix
(this.getRowDimension()));
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[v.length];
BigDecimal bd[] = new BigDecimal[v.length];
for (int i=0;i<bd.length;i++) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[nCols];
int nRows = this.getRowDimension();
BigMatrix bMatrix = new BigMatrixImpl(b);
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
BigDecimal[] out = new BigDecimal[nRows];
BigDecimal bd[] = new BigDecimal[b.length];
for (int i=0;i<bd.length;i++) {
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
BigMatrixImpl outMat = new BigMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
if (i > 0)
if (j > 0)
BigMatrix m = (BigMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (!data[row][col].equals(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
data[row][col].hashCode();
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
double[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? 1d : 0d;
return out;
int nCols = rowData.length;
double[][] data = new double[1][nCols];
return new RealMatrixImpl(data);
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nCols = rowData.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data);
int nCols = rowData.length;
String[][] data = new String[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
return new RealMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
int nRows = columnData.length;
BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data);
String[][] data = new String[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
BigDecimal[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return out;
public interface QRDecomposition {
public abstract RealMatrix getR();
public abstract RealMatrix getQ();
private double[][] qr;
private double[] rDiag;
private int m;
private int n;
xNormSqr += qr[row][minor]*qr[row][minor];
double a = Math.sqrt(xNormSqr);
if (qr[minor][minor] > 0) a = -a;
for (int col = minor+1; col < n; col++) {
alpha -= qr[row][col]*qr[row][minor];
alpha /= a*qr[minor][minor];
qr[row][col] -= alpha*qr[row][minor];
public RealMatrix getR()
RealMatrixImpl ret = new RealMatrixImpl(m,n);
double[][] r = ret.getDataRef();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
r[row][row] = rDiag[row];
for (int col = row+1; col < n; col++) {
r[row][col] = qr[row][col];
return ret;
public RealMatrix getQ()
RealMatrixImpl ret = new RealMatrixImpl(m,m);
double[][] Q = ret.getDataRef();
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
return ret;
private static final long serialVersionUID = 4237564493130426188L;
private double data[][] = null;
private double lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static double TOO_SMALL = 10E-12;
this.copyIn(d);
int nRows = v.length;
return new RealMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + m.getEntry(row, col);
return new RealMatrixImpl(outData);
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] - m.getEntry(row, col);
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + d;
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] * d;
return new RealMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
double[][] outData = new double[nRows][nCols];
double sum = 0;
sum = 0;
sum += data[row][i] * m.getEntry(i, col);
outData[row][col] = sum;
return new RealMatrixImpl(outData);
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
endColumn > data[0].length ) {
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
double[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
selectedColumns.length);
double[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out);
int nRows = this.getRowDimension();
double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out);
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
double[] out = new double[nRows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
double[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createRealIdentityMatrix
(this.getRowDimension()));
if (v.length != this.getColumnDimension()) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[v.length];
sum += data[row][i] * v[i];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[nCols];
int nRows = this.getRowDimension();
RealMatrix bMatrix = new RealMatrixImpl(b);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
double[] out = new double[nRows];
out[row] = solution[row][0];
return out;
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
double[][] bp = new double[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] -= bp[col][j] * lu[i][col];
bp[col][j] /= lu[col][col];
bp[i][j] -= bp[col][j] * lu[i][col];
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
lu = this.getData();
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
lu[row][col] /= lu[col][col];
if (i > 0)
if (j > 0)
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (Double.doubleToLongBits(data[row][col]) != 
int nRows = getRowDimension();
int nCols = getColumnDimension();
for (int col = 0; col < nCols; col++) {
MathUtils.hash(data[row][col]);
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
double[][] out = new double[nRows][this.getColumnDimension()];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
package org.apache.commons.math.ode;
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
protected AbstractStepInterpolator(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
protected void reinitialize(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
public void storeTime(double t) {
public void setInterpolatedTime(double time)
throws DerivativeException {
interpolatedTime = time;
double oneMinusThetaH = currentTime - interpolatedTime;
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
return (double[]) interpolatedState.clone();
protected void writeBaseExternal(ObjectOutput out)
protected double readBaseExternal(ObjectInput in)
int dimension = in.readInt();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
package org.apache.commons.math.ode;
implements FirstOrderIntegrator {
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public void setInitialStepSize(double initialStepSize) {
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
protected void sanityChecks(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y.length)
});
new Integer(y0.length),
new Integer(vecAbsoluteTolerance.length)
new Integer(y0.length),
new Integer(vecRelativeTolerance.length)
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] { new Double(Math.abs(t - t0)) });
public double initializeStep(FirstOrderDifferentialEquations equations,
boolean forward, int order, double[] scale,
double t0, double[] y0, double[] yDot0,
double[] y1, double[] yDot1)
throws DerivativeException {
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
double h1 = (maxInv2 < 1.0e-15) ?
Math.max(1.0e-6, 0.001 * Math.abs(h)) :
Math.pow(0.01 / maxInv2, 1.0 / order);
protected double filterStep(double h, boolean acceptSmall)
if (Math.abs(h) < minStep) {
if (acceptSmall) {
h = (h < 0) ? -minStep : minStep;
} else {
throw new IntegratorException("minimal step size ({0}) reached," +
" integration needs {1}",
new Object[] {
new Double(minStep),
new Double(Math.abs(h))
});
if (h > maxStep) {
h = maxStep;
} else if (h < -maxStep) {
h = -maxStep;
return h;
public abstract void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public double getCurrentSignedStepsize() {
return stepSize;
protected StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
protected double stepStart;
protected double stepSize;
package org.apache.commons.math.ode;
private static final String methodName = "classical Runge-Kutta";
public ClassicalRungeKuttaIntegrator(double step) {
super(c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
protected StepInterpolator doCopy() {
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
double coeff23   = s * (( fourTheta - 2) * theta - 2);
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i] +
coeff1  * yDotK[0][i] +
coeff23 * (yDotK[1][i] + yDotK[2][i]) +
coeff4  * yDotK[3][i];
private static final long serialVersionUID = -6576285612589783992L;
steps = new ArrayList();
public void append(ContinuousOutputModel model)
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
double current  = lastInterpolator.getCurrentTime();
double previous = lastInterpolator.getPreviousTime();
double step = current - previous;
double gap = model.getInitialTime() - current;
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
steps.add(((AbstractStepInterpolator) iter.next()).copy());
public void handleStep(StepInterpolator interpolator, boolean isLast)
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
steps.add(ai.copy());
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public void setInterpolatedTime(double time) {
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
int location = locatePoint(time, si);
int iMed = (iMin + iMax) / 2;
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
double d12 = tMax - tMed;
double d23 = tMed - tMin;
double d13 = tMax - tMin;
double dt1 = time - tMax;
double dt2 = time - tMed;
double dt3 = time - tMin;
double iLagrange = ((dt2 * dt3 * d23) * iMax -
(dt1 * dt3 * d13) * iMed +
(dt1 * dt2 * d12) * iMin) /
(d12 * d23 * d13);
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
while ((index <= iMax) &&
(locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private int locatePoint(double time, StepInterpolator interval) {
private List steps;
private static final long serialVersionUID = 2259286184268533249L;
public DerivativeException(String specifier, String[] parts) {
public DerivativeException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public DormandPrince54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
e6 * yDotK[5][j] +  e7 * yDotK[6][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode;
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +
a74 * yDotK[4][i] + a75 * yDotK[5][i]);
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +
d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);
double eta = oneMinusThetaH / h;
interpolatedState[i] = currentState[i] -
eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, staticC, staticA, staticB,
public DormandPrince853Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, staticC, staticA, staticB,
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +
e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +
e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +
e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +
e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +
e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +
e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio1  = errSum1 / tol;
double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode;
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
int dimension = interpolator.currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
int dimension = currentState.length;
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +
b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +
b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +
d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +
d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +
d[k][9]  * yDotKLast[0][i] +
d[k][10] * yDotKLast[1][i] +
d[k][11] * yDotKLast[2][i]);
double eta = oneMinusThetaH / h;
interpolatedState[i] =
currentState[i] - eta * (v[0][i] - theta * (v[1][i] +
theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] +
eta * (v[5][i] + theta * (v[6][i])))))));
double[] yTmp = new double[currentState.length];
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
int dimension = in.readInt();
package org.apache.commons.math.ode;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
package org.apache.commons.math.ode;
protected DummyStepInterpolator(double[] y, boolean forward) {
public DummyStepInterpolator(DummyStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
package org.apache.commons.math.ode;
protected EmbeddedRungeKuttaIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
protected EmbeddedRungeKuttaIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double   minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public abstract String getName();
public void setSafety(double safety) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
boolean forward = (t > t0);
int stages = c.length + 1;
double[][] yDotK = new double[stages][];
double[] yTmp = new double[y0.length];
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
stepStart  = t0;
boolean lastStep;
handler.reset();
do {
double[] scale;
if ((forward && (stepStart + stepSize > t)) ||
((! forward) && (stepStart + stepSize < t))) {
stepSize = t - stepStart;
if (switchesHandler.evaluateStep(interpolator)) {
hNew = switchesHandler.getEventTime() - stepStart;
double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
hNew = filterStep(stepSize * factor, false);
double nextStep = stepStart + stepSize;
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
lastStep = true;
} else {
lastStep = forward ? (nextStep >= t) : (nextStep <= t);
handler.handleStep(interpolator, lastStep);
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
double  factor     = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
double  scaledH    = stepSize * factor;
double  nextT      = stepStart + scaledH;
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, nextIsLast);
} while (! lastStep);
public void setMinReduction(double minReduction) {
public void setMaxGrowth(double maxGrowth) {
package org.apache.commons.math.ode;
private static final String methodName = "Euler";
public EulerIntegrator(double step) {
super(c, a, b, new EulerStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
private static final long serialVersionUID = -7179861704951334960L;
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations {
public interface FirstOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount);
public void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public double getCurrentStepStart();
public double getCurrentSignedStepsize();
package org.apache.commons.math.ode;
public interface FixedStepHandler {
public void handleStep(double t, double[] y, boolean isLast);
package org.apache.commons.math.ode;
private static final String methodName = "Gill";
public GillIntegrator(double step) {
super(c, a, b, new GillStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public GillStepInterpolator(GillStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double soMt      = s * (1 - theta);
double c23       = soMt * (1 + 2 * theta);
double coeff1    = soMt * (1 - fourTheta);
double coeff2    = c23  * tMq;
double coeff3    = c23  * tPq;
double coeff4    = s * (1 + theta * (1 + fourTheta));
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
package org.apache.commons.math.ode;
private static final String methodName = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public void setStabilityCheck(boolean performTest,
int maxIter, int maxChecks,
double stabilityReduction) {
public void setStepsizeControl(double stepControl1, double stepControl2,
double stepControl3, double stepControl4) {
public void setOrderControl(int maxOrder,
double orderControl1, double orderControl2) {
public void setStepHandler (StepHandler handler) {
super.setStepHandler(handler);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
super.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
int size = maxOrder / 2;
double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(boolean useInterpolationError,
int mudif) {
public String getName() {
return methodName;
private void rescale(double[] y1, double[] y2, double[] scale) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double step, int k,
double[] scale, double[][] f,
double[] yMiddle, double[] yEnd,
double[] yTmp)
int    n        = sequence[k];
double subStep  = step / n;
double subStep2 = 2 * subStep;
double middle = yEnd[i];
double ratio = f[0][l] / scale[l];
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
boolean forward = (t > t0);
double[] yDot0   = new double[y0.length];
double[] y1      = new double[y0.length];
double[] yTmp    = new double[y0.length];
double[] yTmpDot = new double[y0.length];
double[][] diagonal = new double[sequence.length-1][];
double[][] y1Diag = new double[sequence.length-1][];
double[][][] fk  = new double[sequence.length][][];
double[] scale = new double[y0.length];
double tol =
double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);
if (denseOutput || (! switchesHandler.isEmpty())) {
handler.reset();
double nextT = stepStart + stepSize;
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
double exp = 1.0 / (2 * k + 1);
double pow = Math.pow(stepControl3, exp);
optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));
double ratio = ((double) sequence [k] * sequence[k+1]) /
(sequence[0] * sequence[0]);
double ratio = ((double) sequence[k+1]) / sequence[0];
int mu = 2 * k - mudif + 3;
int l2 = l / 2;
GraggBulirschStoerStepInterpolator gbsInterpolator
double interpError = gbsInterpolator.estimateError(scale);
if (switchesHandler.evaluateStep(interpolator)) {
hNew = Math.abs(switchesHandler.getEventTime() - stepStart);
double nextStep = stepStart + stepSize;
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
handler.handleStep(interpolator, lastStep);
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter+1] / costPerStep[k],
false);
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter] / costPerStep[k],
false);
package org.apache.commons.math.ode;
private void resetTables(int maxDegree) {
double[][] newPols = new double[maxDegree + 1][];
int ip5 = i + 5;
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double[] y1, double[] y1Dot,
double[][] yMidDots,
boolean forward) {
(GraggBulirschStoerStepInterpolator interpolator) {
int dimension = currentState.length;
public void computeCoefficients(int mu, double h) {
double yp0   = h * y0Dot[i];
double yp1   = h * y1Dot[i];
double ydiff = y1[i] - currentState[i];
double aspl  = ydiff - yp1;
double bspl  = yp0 - ydiff;
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
double ph1 = ydiff + 0.25 * (aspl - bspl);
double ph2 = yp1 - yp0;
double ph3 = 6 * (bspl - aspl);
double fac1 = 0.5 * j * (j - 1);
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(double[] scale) {
double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
int dimension = currentState.length;
double oneMinusTheta = 1.0 - theta;
double theta05       = theta - 0.5;
double t4            = theta * oneMinusTheta;
t4 = t4 * t4;
interpolatedState[i] = polynoms[0][i] +
theta * (polynoms[1][i] +
oneMinusTheta * (polynoms[2][i] * theta +
polynoms[3][i] * oneMinusTheta));
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
public void writeExternal(ObjectOutput out)
int dimension = currentState.length;
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int dimension = currentState.length;
int degree = in.readInt();
package org.apache.commons.math.ode;
private static final String methodName = "Higham-Hall 5(4)";
public HighamHall54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public HighamHall54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
package org.apache.commons.math.ode;
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double theta2 = theta * theta;
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
interpolatedState[i] = currentState[i] +
b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +
b4 * yDotK[4][i] + b5 * yDotK[5][i];
public IntegratorException(String specifier, Object[] parts) {
public IntegratorException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "midpoint";
public MidpointIntegrator(double step) {
super(c, a, b, new MidpointStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double coeff1 = oneMinusThetaH * theta;
double coeff2 = oneMinusThetaH * (1.0 + theta);
interpolatedState[i] = currentState[i] +
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];
package org.apache.commons.math.ode;
public abstract class RungeKuttaIntegrator
implements FirstOrderIntegrator {
protected RungeKuttaIntegrator(double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double step) {
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
handler         = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
resetInternalState();
public abstract String getName();
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
private void sanityChecks(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y.length)
});
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] { new Double(Math.abs(t - t0)) });
}      
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
} else {
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
boolean lastStep  = false;
stepStart = t0;
stepSize  = (t - t0) / nbStep;
handler.reset();
for (long i = 0; ! lastStep; ++i) {
interpolator.shift();
boolean needUpdate = false;
for (boolean loop = true; loop;) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
if (switchesHandler.evaluateStep(interpolator)) {
needUpdate = true;
stepSize = switchesHandler.getEventTime() - stepStart;
} else {
loop = false;
double nextStep = stepStart + stepSize;
System.arraycopy(yTmp, 0, y, 0, y0.length);
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
lastStep = true;
} else {
lastStep = (i == (nbStep - 1));
interpolator.storeTime(nextStep);
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
if (needUpdate) {
nbStep = Math.max(1l, Math.abs(Math.round((t - stepStart) / step)));
stepSize = (t - stepStart) / nbStep;
i = -1;
resetInternalState();
public double getCurrentStepStart() {
return stepStart;
public double getCurrentSignedStepsize() {
return stepSize;
private void resetInternalState() {
stepStart = Double.NaN;
stepSize  = Double.NaN;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
private StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
private double stepStart;
private double stepSize;
package org.apache.commons.math.ode;
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
int dimension = currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int kMax = in.readInt();
public interface SecondOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
package org.apache.commons.math.ode;
public interface StepHandler {
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
public class StepNormalizer
implements StepHandler {
public StepNormalizer(double h, FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime  = Double.NaN;
lastState = null;
forward   = true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
double nextTime;
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, true);
private double h;
private FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private boolean forward;
package org.apache.commons.math.ode;
class SwitchState implements Serializable {
private static final long serialVersionUID = -7307007422156119622L;
private SwitchingFunction function;
private double maxCheckInterval;
private double convergence;
private int maxIterationCount;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
public SwitchState(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
this.function          = function;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = SwitchingFunction.CONTINUE;
public void reinitializeBegin(double t0, double[] y0)
throws FunctionEvaluationException {
this.t0 = t0;
g0 = function.g(t0, y0);
g0Positive = (g0 >= 0);
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, FunctionEvaluationException, ConvergenceException {
double t1 = interpolator.getCurrentTime();
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
double gb = function.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return function.g(t, interpolator.getInterpolatedState());
} catch (DerivativeException e) {
throw new FunctionEvaluationException(t, e);
});
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(maxIterationCount);
double root = solver.solve(ta, tb);
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
} else {
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
} catch (FunctionEvaluationException e) {
Throwable cause = e.getCause();
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
throw e;
public double getEventTime() {
return pendingEventTime;
public void stepAccepted(double t, double[] y)
throws FunctionEvaluationException {
t0 = t;
g0 = function.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = function.eventOccurred(t, y);
} else {
g0Positive = (g0 >= 0);
nextAction = SwitchingFunction.CONTINUE;
public boolean stop() {
return nextAction == SwitchingFunction.STOP;
public boolean reset(double t, double[] y) {
if (! pendingEvent) {
return false;
if (nextAction == SwitchingFunction.RESET_STATE) {
function.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
return (nextAction == SwitchingFunction.RESET_STATE) ||
(nextAction == SwitchingFunction.RESET_DERIVATIVES);
package org.apache.commons.math.ode;
public interface SwitchingFunction extends Serializable {
public double g(double t, double[] y) throws FunctionEvaluationException;
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
package org.apache.commons.math.ode;
public class SwitchingFunctionsHandler {
public SwitchingFunctionsHandler() {
functions   = new ArrayList();
first       = null;
initialized = false;
public void add(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
functions.add(new SwitchState(function, maxCheckInterval,
convergence, maxIterationCount));
public boolean isEmpty() {
return functions.isEmpty();
public boolean evaluateStep(StepInterpolator interpolator)
throws DerivativeException, IntegratorException {
first = null;
if (functions.isEmpty()) {
return false;
if (! initialized) {
double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
double [] y = interpolator.getInterpolatedState();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
initialized = true;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
} else {
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
} else {
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
} catch (ConvergenceException ce) {
throw new IntegratorException(ce);
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
public void stepAccepted(double t, double[] y)
throws IntegratorException {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
public boolean stop() {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
return true;
return false;
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private List functions;
private SwitchState first;
private boolean initialized;
package org.apache.commons.math.ode;
private static final String methodName = "3/8";
public ThreeEighthesIntegrator(double step) {
super(c, a, b, new ThreeEighthesStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta2 = 4 * theta * theta;
double s          = oneMinusThetaH / 8.0;
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
double coeff2     = 3 * s * (1 + theta - fourTheta2);
double coeff3     = 3 * s * (1 + theta);
double coeff4     = s * (1 + theta + fourTheta2);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
double cost1 = ((PointCostPair) o1).getCost();
double cost2 = ((PointCostPair) o2).getCost();
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
private List binStats = null;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
val = new Double(str).doubleValue();
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
double delta = (max - min)/(new Double(binCount)).doubleValue();
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
Integer c = new Integer(randomBytes[i]);
Integer c = new Integer(hash[i]);
public Object[] nextSample(Collection c, int k) {
obj = new Long(((Integer) v).longValue());
freqTable.put(obj, new Long(1));
freqTable.put(obj, new Long(count.longValue() + 1));
addValue(new Long(v));
addValue(new Long(v.longValue()));
addValue(new Long(v));
addValue(new Character(v));
return getCount(new Long(v));
return getCount(new Long(v));
return getCount(new Character(v));
return getPct(new Long(v));       
return getPct(new Long(v));         
return getPct(new Character(v));         
return getCumFreq(new Long(v));       
return getCumFreq(new Long(v));         
return getCumFreq(new Character(v));         
return getCumPct(new Long(v));       
return getCumPct(new Long(v));         
return getCumPct(new Character(v));         
private static final long serialVersionUID = -2734185686570407433L;
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
} catch(Throwable t) {
return new DescriptiveStatisticsImpl();
return factory;
new Object[] {new Double(p)});
new Object[] {new Double(50.0d)});
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
private static final long serialVersionUID = -6467796944112488424L;
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
super(window);
public void clear() {
super.clear();
private static final long serialVersionUID = -3346512372447011854L;
public static SummaryStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
instance = (SummaryStatistics)dc.newInstance(SummaryStatistics.class, "org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl");
} catch (Throwable t) {
return new SummaryStatisticsImpl();
return instance;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())
&& MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())
&& MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
private static final long serialVersionUID = 8528794411480425963L;
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
private AnovaStats anovaStats(Collection categoryData)
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] array;
array = (double[])iterator.next();
} catch (ClassCastException ex) {
throw new IllegalArgumentException(
"ANOVA: categoryData contains non-double[] elements.");
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] data = (double[])iterator.next();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
} catch(Throwable t) {
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
public static double oneWayAnovaFValue(Collection categoryData)
public static double oneWayAnovaPValue(Collection categoryData)
public static boolean oneWayAnovaTest(Collection categoryData, double alpha)
new Object[] { new Double(x) });
new Object[] { new Double(x) });
return new Double(o.toString()).doubleValue();
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(new double[] { 0.0 });
return new Double(newA);
return new Double();
return new Double(newA);
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
new Object[] { new Double(1234567) });
ComplexFormat complexFormat = null;
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = new Double(Math.PI);
ComplexFormat cf = new ComplexFormat();
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
} 
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
} 
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
} 
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
}       
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
HashSet set = new HashSet();
for (Iterator iterator = set.iterator(); iterator.hasNext();) {
addParameter((EstimatedParameter) iterator.next());
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
public class QuadraticProblem extends SimpleEstimationProblem {
assertFalse(zero.equals(new Double(0)));
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(new Rotation().getAxis(), Vector3D.plusI);
new Rotation(u, new Vector3D());
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,
new Rotation(u1, u2, new Vector3D(), v2);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
Rotation reference = new Rotation(q0, q1, q2, q3, false);
assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);
checkVector(new Vector3D(2, Vector3D.plusI,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
5, Vector3D.minusJ,
-3, Vector3D.minusK),
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
new Vector3D().normalize();
Vector3D.angle(new Vector3D(), Vector3D.plusI);
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
assertEquals(m2,m);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData4x3);
matrix = new RealMatrixImpl(testData3x4);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
assertEquals(m2,m);
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
assertClose("inverse-operate",mInv.operate(testVector),
m.solve(testVector),normTolerance);
double[] x = m.operate(testVector);
assertClose("identity operate",testVector,x,entryTolerance);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
package org.apache.commons.math.ode;
double step = (pb.getFinalTime() - pb.getInitialTime())
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
integ.setStepHandler(cm);
public void computeDerivatives(double t, double[] y, double[] dot)
throws DerivativeException {
dot[0] = -y[1];
dot[1] =  y[0];
public int getDimension() {
return 2;
};
integ1.setStepHandler(cm1);
integ2.setStepHandler(cm2);
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 2900);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(DummyStepHandler.getInstance());
integ.setStepHandler(new InterpolatingStepHandler());
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
assertTrue(bos.size () > 250);
assertTrue(bos.size () < 300);
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
throws DerivativeException {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerStepHandler(pb));
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integrator.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerStepHandler(pb));
integ.setStepHandler(new VariableStepHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
public void computeDerivatives(double t, double[] y, double[] dot)
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
public void testSwitchingFunctionsError()
integ.setStepHandler(handler);
integ.addSwitchingFunction(new SwitchingFunction() {
return SwitchingFunction.CONTINUE;
public double g(double t, double[] y) throws FunctionEvaluationException {
throw new FunctionEvaluationException(t);
public void testSwitchingFunctionsNoConvergence()
integ.setStepHandler(handler);
integ.addSwitchingFunction(new SwitchingFunction() {
return SwitchingFunction.CONTINUE;
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(new StepNormalizer(range / 10.0,
private boolean firstCall = true;
integ.setStepHandler(new StepNormalizer(range / 10.5,
public void handleStep(double t,
package org.apache.commons.math.ode;
implements FirstOrderDifferentialEquations, SwitchingFunction {
package org.apache.commons.math.ode;
class TestProblem1
package org.apache.commons.math.ode;
class TestProblem2
package org.apache.commons.math.ode;
class TestProblem3
package org.apache.commons.math.ode;
class TestProblem4
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[] { new Bounce(), new Stop() };
private static class Bounce implements SwitchingFunction {
return SwitchingFunction.RESET_STATE;
private static class Stop implements SwitchingFunction {
return SwitchingFunction.STOP;
package org.apache.commons.math.ode;
class TestProblem5
package org.apache.commons.math.ode;
abstract class TestProblemAbstract
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[0];
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
private FirstOrderIntegrator integrator;
public TestProblemHandler(TestProblemAbstract problem, FirstOrderIntegrator integrator) {
expectedStepStart = problem.getInitialTime();
maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));
expectedStepStart = start + integrator.getCurrentSignedStepsize();
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
f.addValue(new Integer(1));
f.addValue(new Long(1));
f.addValue(new Integer(-1));
assertEquals("1 count", 3, f.getCount(new Integer(1)));
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
obj1 = new Integer(1);
Integer int1 = new Integer(1);
f.addValue(new Long(2));
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
private Map certifiedValues;
certifiedValues = new HashMap();
Double value = new Double(valueString);
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
return new Double(((Long) property).doubleValue());
package org.apache.commons.math.stat.descriptive;
public abstract class DescriptiveStatisticsAbstractTest extends TestCase {
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
public DescriptiveStatisticsAbstractTest(String name) {
super(name);
protected abstract DescriptiveStatistics createDescriptiveStatistics();
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
DescriptiveStatistics stats = createDescriptiveStatistics();
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
}     
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
}     
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}    
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
}  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}  
}     
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
}        
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
} catch (NullPointerException ex) {
} catch (Exception ex) {
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
} catch (InstantiationException ex) {
fail();
} catch (IllegalAccessException ex) {
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
} catch (IllegalArgumentException ex) {
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
} catch (IllegalArgumentException ex) {
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
DescriptiveStatistics u = createDescriptiveStatistics();
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
}       
public void testStats() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
}        
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public final class DescriptiveStatisticsImplTest extends DescriptiveStatisticsAbstractTest {
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
suite.setName("DescriptiveStatisticsImpl Tests");
return suite;
protected DescriptiveStatistics createDescriptiveStatistics() {
return new DescriptiveStatisticsImpl();
public final class DescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
list.add(new Double(v));
List externalList = new ArrayList();
List list = new ArrayList();
list.add( new Double(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
u.addObject(new Integer(12));
u.addObject(new Long(21));
u.addObject(new Float(14.1));
u.addObject(new Double(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
assertFalse(u.equals(new Double(0)));
assertFalse("wrong type", u.equals(new Double(0)));
package org.apache.commons.math.stat.descriptive;
public abstract class SummaryStatisticsAbstractTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsAbstractTest(String name) {
super(name);
protected abstract SummaryStatistics createSummaryStatistics();
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public final class SummaryStatisticsImplTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
suite.setName("SummaryStatisticsImpl Tests");
return suite;
protected SummaryStatistics createSummaryStatistics() {
return new SummaryStatisticsImpl();
public final class SummaryStatisticsTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsTest(String name) {
super(name);
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsAbstractTest {
private char[] wrongArray = { 'a', 'b', 'c' };
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List wrongContents = new ArrayList();
wrongContents.add(classC);
wrongContents.add(wrongArray);
testStatistic.anovaFValue(wrongContents);
fail("non double[] hash value for key classX, IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
}  
List emptyContents = new ArrayList();
List tooFew = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
private List classes = new ArrayList();
Double input = new Double(expected);
Integer input = new Integer(1);
private Double x = new Double(1.0);value = Double.valueOf(d);
value = Float.valueOf(f);
value = Integer.valueOf(i);
value = Long.valueOf(l);
dynaBean.set(propertyName, Double.valueOf(v));
VitalStats vs1 = new VitalStats( Double.valueOf(120.0), 
Double.valueOf(96.4) );
Patient p1 = new Patient( vs1, Integer.valueOf( 35 ) );
VitalStats vs2 = new VitalStats( Double.valueOf(70.0), 
Double.valueOf(97.4) );
Patient p2 = new Patient( vs2, Integer.valueOf( 23 ) );
VitalStats vs3 = new VitalStats( Double.valueOf(90.0), 
Double.valueOf(98.6) );
Patient p3 = new Patient( vs3, Integer.valueOf( 42 ) );
new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });
Integer.valueOf(dimension1), Integer.valueOf(dimension2)
new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });
private static final long serialVersionUID = -2193260774031645876L;
new Object[] { Double.valueOf(argument) });
private static final long serialVersionUID = 5261476508226103366L;
private static final long serialVersionUID = 1428666635974829194L;
new Object[] { Integer.valueOf(maxIterations) });
return new UnivariateRealSolverFactoryImpl();
new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),
Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),
Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });
private final double imaginary;
private final double real;
ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
public class ComplexFormat extends CompositeFormat {
private static final long serialVersionUID = -3343698360149467646L;
public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public static String formatComplex(Complex c) {
return getInstance().format(c);
throw new IllegalArgumentException("Cannot format given Object as a Complex");
"\"", parsePosition.getErrorIndex());
if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {
package org.apache.commons.math.distribution;
public interface BetaDistribution extends ContinuousDistribution, HasDensity<Double> {
void setAlpha(double alpha);
double getAlpha();
void setBeta(double beta);
double getBeta();
double density(Double x) throws MathException;
package org.apache.commons.math.distribution;
public class BetaDistributionImpl
extends AbstractContinuousDistribution implements BetaDistribution {
private static final long serialVersionUID = -1221965979403477668L;
private double alpha;
private double beta;
private double z;
public BetaDistributionImpl(double alpha, double beta) {
this.alpha = alpha;
this.beta = beta;
z = Double.NaN;
public void setAlpha(double alpha) {
this.alpha = alpha;
z = Double.NaN;
public double getAlpha() {
return alpha;
public void setBeta(double beta) {
this.beta = beta;
z = Double.NaN;
public double getBeta() {
return beta;
private void recomputeZ() {
if (Double.isNaN(z)) {
z = Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta);
public double density(Double x) throws MathException {
recomputeZ();
if (x < 0 || x > 1) {
return 0;
} else if (x == 0) {
if (alpha < 1) {
throw new MathException("Cannot compute beta density at 0 when alpha = {0,number}", new Double[]{alpha});
return 0;
} else if (x == 1) {
if (beta < 1) {
throw new MathException("Cannot compute beta density at 1 when beta = %.3g", new Double[]{beta});
return 0;
} else {
double logX = Math.log(x);
double log1mX = Math.log1p(-x);
return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);
public double inverseCumulativeProbability(double p) throws MathException {
if (p == 0) {
return 0;
} else if (p == 1) {
return 1;
} else {
return super.inverseCumulativeProbability(p);
protected double getInitialDomain(double p) {
return p;
protected double getDomainLowerBound(double p) {
return 0;
protected double getDomainUpperBound(double p) {
return 1;
public double cumulativeProbability(double x) throws MathException {
if (x <= 0) {
return 0;
} else if (x >= 1) {
return 1;
} else {
return Beta.regularizedBeta(x, alpha, beta);
public double cumulativeProbability(double x0, double x1) throws MathException {
return cumulativeProbability(x1) - cumulativeProbability(x0);
public interface ChiSquaredDistribution extends ContinuousDistribution, HasDensity<Double> {
double density(Double x);
public double density(Double x) {
return gamma.density(x);
public interface ExponentialDistribution extends ContinuousDistribution, HasDensity<Double> {
double density(Double x);
public double density(Double x) {
if (x < 0) {
return 0;
return Math.exp(-x / getMean()) / getMean();
public class FDistributionImpl
extends AbstractContinuousDistribution
implements FDistribution, Serializable  {
private static final long serialVersionUID = -8516354193418641566L;
private double numeratorDegreesOfFreedom;
private double denominatorDegreesOfFreedom;
public FDistributionImpl(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
super();
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
} else {
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();
ret = Beta.regularizedBeta((n * x) / (m + n * x),
0.5 * n,
0.5 * m);
return ret;
public double inverseCumulativeProbability(final double p) 
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
return getDenominatorDegreesOfFreedom() /
(getDenominatorDegreesOfFreedom() - 2.0);
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.denominatorDegreesOfFreedom = degreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
public interface GammaDistribution extends ContinuousDistribution, HasDensity<Double> {
double density(Double x);
public double density(Double x) {
if (x < 0) return 0;
return Math.pow(x / getBeta(), getAlpha() - 1) / getBeta() * Math.exp(-x / getBeta()) / Math.exp(Gamma.logGamma(getAlpha()));
package org.apache.commons.math.distribution;
public interface HasDensity<P> {
double density(P x) throws MathException;
public interface NormalDistribution extends ContinuousDistribution, HasDensity<Double> {
double density(Double x);
private static final double SQRT2PI = Math.sqrt(2 * Math.PI);
public double density(Double x) {
double x0 = x - getMean();
return Math.exp(-x0 * x0 / (2 * getStandardDeviation() * getStandardDeviation())) / (getStandardDeviation() * SQRT2PI);
new Object[] { Integer.valueOf(maxCostEval) });
return ((RealMatrixImpl) new RealMatrixImpl(jTj, false).inverse()).getDataRef();
new Object[] { Integer.valueOf(m), Integer.valueOf(p)});
new Object[] { Double.valueOf(costRelativeTolerance) });
new Object[] { Double.valueOf(parRelativeTolerance) });
new Object[] { Double.valueOf(orthoTolerance) });
new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });
parameters   = new ArrayList<EstimatedParameter>();
measurements = new ArrayList<WeightedMeasurement>();
List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());
for (EstimatedParameter p : parameters) {
private final List<EstimatedParameter> parameters;
private final List<WeightedMeasurement> measurements;
public class Fraction extends Number implements Comparable<Fraction> {
private static final long serialVersionUID = -5731055832688548463L;
public int compareTo(Fraction object) {
double second = object.doubleValue();
new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });
new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });
public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);
private static final long serialVersionUID = -2153622329907944313L;
private final double q0;
private final double q1;
private final double q2;
private final double q3;
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_I);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_J);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
Vector3D v1 = applyTo(Vector3D.PLUS_K);
Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
public static double distance(Rotation r1, Rotation r2) {
return r1.applyInverseTo(r2).getAngle();
new RotationOrder("XYZ", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);
new RotationOrder("XZY", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);
new RotationOrder("YXZ", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);
new RotationOrder("YZX", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);
new RotationOrder("ZXY", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);
new RotationOrder("ZYX", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);
new RotationOrder("XYX", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);
new RotationOrder("XZX", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);
new RotationOrder("YXY", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);
new RotationOrder("YZY", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);
new RotationOrder("ZXZ", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);
new RotationOrder("ZYZ", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);
public static final Vector3D ZERO   = new Vector3D(0, 0, 0);
public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);
public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);
public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);
public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);
public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);
public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);
public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);
public static final Vector3D POSITIVE_INFINITY =
new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
public static final Vector3D NEGATIVE_INFINITY =
new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
private static final Vector3DFormat DEFAULT_FORMAT =
Vector3DFormat.getInstance();
private static final long serialVersionUID = 5133268763396045979L;
private final double x;
private final double y;
private final double z;
public double getNormSq() {
return x * x + y * y + z * z;
public boolean isNaN() {
return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        
public boolean isInfinite() {
return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        
public boolean equals(Object other) {
if (this == other) { 
return true;
if (other == null) {
return false;
final Vector3D rhs = (Vector3D)other;
if (rhs.isNaN()) {
return this.isNaN();
return (x == rhs.x) && (y == rhs.y) && (z == rhs.z); 
} catch (ClassCastException ex) {
return false;
public int hashCode() {
if (isNaN()) {
return 8;
return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));
public static double distance(Vector3D v1, Vector3D v2) {
final double dx = v2.x - v1.x;
final double dy = v2.y - v1.y;
final double dz = v2.z - v1.z;
return Math.sqrt(dx * dx + dy * dy + dz * dz);
public static double distanceSq(Vector3D v1, Vector3D v2) {
final double dx = v2.x - v1.x;
final double dy = v2.y - v1.y;
final double dz = v2.z - v1.z;
return dx * dx + dy * dy + dz * dz;
public String toString() {
return DEFAULT_FORMAT.format(this);
package org.apache.commons.math.geometry;
public class Vector3DFormat extends CompositeFormat {
private static final long serialVersionUID = -5447606608652576301L;
private static final String DEFAULT_PREFIX = "{";
private static final String DEFAULT_SUFFIX = "}";
private static final String DEFAULT_SEPARATOR = "; ";
private final String prefix;
private final String suffix;
private final String separator;
private final String trimmedPrefix;
private final String trimmedSuffix;
private final String trimmedSeparator;
private NumberFormat format;
public Vector3DFormat() {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());
public Vector3DFormat(final NumberFormat format) {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);
public Vector3DFormat(final String prefix, final String suffix,
final String separator) {
this(prefix, suffix, separator, getDefaultNumberFormat());
public Vector3DFormat(final String prefix, final String suffix,
final String separator, final NumberFormat format) {
this.prefix      = prefix;
this.suffix      = suffix;
this.separator   = separator;
trimmedPrefix    = prefix.trim();
trimmedSuffix    = suffix.trim();
trimmedSeparator = separator.trim();
this.format      = format;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public String getPrefix() {
return prefix;
public String getSuffix() {
return suffix;
public String getSeparator() {
return separator;
public NumberFormat getFormat() {
return format;
public static Vector3DFormat getInstance() {
return getInstance(Locale.getDefault());
public static Vector3DFormat getInstance(final Locale locale) {
return new Vector3DFormat(getDefaultNumberFormat(locale));
public static String formatVector3D(Vector3D v) {
return getInstance().format(v);
public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
toAppendTo.append(prefix);
formatDouble(vector.getX(), format, toAppendTo, pos);
toAppendTo.append(separator);
formatDouble(vector.getY(), format, toAppendTo, pos);
toAppendTo.append(separator);
formatDouble(vector.getZ(), format, toAppendTo, pos);
toAppendTo.append(suffix);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
if (obj instanceof Vector3D) {
return format( (Vector3D)obj, toAppendTo, pos);
throw new IllegalArgumentException("Cannot format given Object as a Vector3D");
public Vector3D parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
Vector3D result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable 3D vector: \"" + source +
"\"", parsePosition.getErrorIndex());
return result;
public Vector3D parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedPrefix, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number x = parseNumber(source, format, pos);
if (x == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number y = parseNumber(source, format, pos);
if (y == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
return null;
parseAndIgnoreWhitespace(source, pos);
Number z = parseNumber(source, format, pos);
if (z == null) {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSuffix, pos)) {
return null;
return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
class BiDiagonalTransformer implements Serializable {
private static final long serialVersionUID = 8935390784125343332L;
private final double householderVectors[][];
private final double[] main;
private final double[] secondary;
private RealMatrix cachedU;
private RealMatrix cachedB;
private RealMatrix cachedV;
public BiDiagonalTransformer(RealMatrix matrix)
throws InvalidMatrixException {
final int m = matrix.getRowDimension();
final int n = matrix.getColumnDimension();
final int p = Math.min(m, n);
householderVectors = matrix.getData();
main      = new double[p];
secondary = new double[p - 1];
cachedU   = null;
cachedB   = null;
cachedV   = null;
if (m >= n) {
transformToUpperBiDiagonal();
} else {
transformToLowerBiDiagonal();
public RealMatrix getU() {
if (cachedU == null) {
final int m = householderVectors.length;
final int n = householderVectors[0].length;
final int p = main.length;
final int diagOffset    = (m >= n) ? 0 : 1;
final double[] diagonal = (m >= n) ? main : secondary;
final double[][] uData  = new double[m][m];
for (int k = m - 1; k >= p; --k) {
uData[k][k] = 1;
for (int k = p - 1; k >= diagOffset; --k) {
final double[] hK = householderVectors[k];
uData[k][k] = 1;
if (hK[k - diagOffset] != 0.0) {
for (int j = k; j < m; ++j) {
double alpha = 0;
for (int i = k; i < m; ++i) {
alpha -= uData[i][j] * householderVectors[i][k - diagOffset];
alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];
for (int i = k; i < m; ++i) {
uData[i][j] -= alpha * householderVectors[i][k - diagOffset];
if (diagOffset > 0) {
uData[0][0] = 1;
cachedU = new RealMatrixImpl(uData, false);
return cachedU;
public RealMatrix getB() {
if (cachedB == null) {
final int m = householderVectors.length;
final int n = householderVectors[0].length;
double[][] bData = new double[m][n];
for (int i = 0; i < main.length; ++i) {
bData[i][i] = main[i];
if (i < main.length - 1) {
if (m < n) {
bData[i + 1][i] = secondary[i];
} else {
bData[i][i + 1] = secondary[i];
cachedB = new RealMatrixImpl(bData, false);
return cachedB;
public RealMatrix getV() {
if (cachedV == null) {
final int m = householderVectors.length;
final int n = householderVectors[0].length;
final int p = main.length;
final int diagOffset    = (m >= n) ? 1 : 0;
final double[] diagonal = (m >= n) ? secondary : main;
final double[][] vData  = new double[n][n];
for (int k = n - 1; k >= p; --k) {
vData[k][k] = 1;
for (int k = p - 1; k >= diagOffset; --k) {
final double[] hK = householderVectors[k - diagOffset];
vData[k][k] = 1;
if (hK[k] != 0.0) {
for (int j = k; j < n; ++j) {
double beta = 0;
for (int i = k; i < n; ++i) {
beta -= vData[i][j] * hK[i];
beta /= diagonal[k - diagOffset] * hK[k];
for (int i = k; i < n; ++i) {
vData[i][j] -= beta * hK[i];
if (diagOffset > 0) {
vData[0][0] = 1;
cachedV = new RealMatrixImpl(vData, false);
return cachedV;
double[][] getHouseholderVectorsRef() {
return householderVectors;
double[] getMainDiagonalRef() {
return main;
double[] getSecondaryDiagonalRef() {
return secondary;
boolean isUpperBiDiagonal() {
return householderVectors.length >=  householderVectors[0].length;
private void transformToUpperBiDiagonal() {
final int m = householderVectors.length;
final int n = householderVectors[0].length;
for (int k = 0; k < n; k++) {
double xNormSqr = 0;
for (int i = k; i < m; ++i) {
final double c = householderVectors[i][k];
xNormSqr += c * c;
final double a = (householderVectors[k][k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
main[k] = a;
if (a != 0.0) {
householderVectors[k][k] -= a;
for (int j = k + 1; j < n; ++j) {
double alpha = 0;
for (int i = k; i < m; ++i) {
final double[] uvI = householderVectors[i];
alpha -= uvI[j] * uvI[k];
alpha /= a * householderVectors[k][k];
for (int i = k; i < m; ++i) {
final double[] uvI = householderVectors[i];
uvI[j] -= alpha * uvI[k];
if (k < n - 1) {
final double[] uvK = householderVectors[k];
xNormSqr = 0;
for (int j = k + 1; j < n; ++j) {
final double c = uvK[j];
xNormSqr += c * c;
final double b = (uvK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
secondary[k] = b;
if (b != 0.0) {
uvK[k + 1] -= b;
for (int i = k + 1; i < m; ++i) {
final double[] uvI = householderVectors[i];
double beta = 0;
for (int j = k + 1; j < n; ++j) {
beta -= uvI[j] * uvK[j];
beta /= b * uvK[k + 1];
for (int j = k + 1; j < n; ++j) {
uvI[j] -= beta * uvK[j];
private void transformToLowerBiDiagonal() {
final int m = householderVectors.length;
final int n = householderVectors[0].length;
for (int k = 0; k < m; k++) {
final double[] uvK = householderVectors[k];
double xNormSqr = 0;
for (int j = k; j < n; ++j) {
final double c = uvK[j];
xNormSqr += c * c;
final double a = (uvK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
main[k] = a;
if (a != 0.0) {
uvK[k] -= a;
for (int i = k + 1; i < m; ++i) {
final double[] uvI = householderVectors[i];
double alpha = 0;
for (int j = k; j < n; ++j) {
alpha -= uvI[j] * uvK[j];
alpha /= a * householderVectors[k][k];
for (int j = k; j < n; ++j) {
uvI[j] -= alpha * uvK[j];
if (k < m - 1) {
xNormSqr = 0;
for (int i = k + 1; i < m; ++i) {
final double c = householderVectors[i][k];
xNormSqr += c * c;
final double b = (householderVectors[k + 1][k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
secondary[k] = b;
if (b != 0.0) {
householderVectors[k + 1][k] -= b;
for (int j = k + 1; j < n; ++j) {
double beta = 0;
for (int i = k + 1; i < m; ++i) {
final double[] uvI = householderVectors[i];
beta -= uvI[j] * uvI[k];
beta /= b * householderVectors[k + 1][k];
for (int i = k + 1; i < m; ++i) {
final double[] uvI = householderVectors[i];
uvI[j] -= beta * uvI[k];
protected BigDecimal data[][] = null;
protected BigDecimal lu[][] = null;
protected int[] permutation = null;
protected int parity = 1;
private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);
public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {
if (copyArray) {
copyIn(d);
} else {
if (d == null) {
throw new NullPointerException();
}   
final int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException("Matrix must have at least one row."); 
final int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException("Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (d[r].length != nCols) {
throw new IllegalArgumentException("All input rows must have the same length.");
}       
data = d;
lu = null;
final int nRows = d.length;
final int nCols = d[0].length;
final int nRows = d.length;
final int nCols = d[0].length;
final int nRows = v.length;
return new BigMatrixImpl(this.copyOut(), false);
return add((BigMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col].add(m.getEntry(row, col));
}  
return new BigMatrixImpl(outData, false);
public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] mRow       = m.data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].add(mRow[col]);
}  
return new BigMatrixImpl(outData, false);
return subtract((BigMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col].subtract(getEntry(row, col));
}  
return new BigMatrixImpl(outData, false);
public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] mRow       = m.data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].subtract(mRow[col]);
}  
return new BigMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].add(d);
return new BigMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
outDataRow[col] = dataRow[col].multiply(d);
return new BigMatrixImpl(outData, false);
return multiply((BigMatrixImpl) m);
} catch (ClassCastException cce) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
for (int row = 0; row < nRows; row++) {
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
for (int col = 0; col < nCols; col++) {
BigDecimal sum = ZERO;
for (int i = 0; i < nSum; i++) {
sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));
outDataRow[col] = sum;
return new BigMatrixImpl(outData, false);
public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nRows][nCols];
final BigDecimal[] dataRow    = data[row];
final BigDecimal[] outDataRow = outData[row];
BigDecimal sum = ZERO;
sum = sum.add(dataRow[i].multiply(m.data[i][col]));
outDataRow[col] = sum;
}            
return new BigMatrixImpl(outData, false);
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double d[][] = new double[nRows][nCols];
for (int j = 0; j < nCols; j++) {
public BigMatrix getSubMatrix(int startRow, int endRow,
int startColumn, int endColumn)
throws MatrixIndexException {
final BigDecimal[][] subMatrixData =
new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];
System.arraycopy(data[i], startColumn,
subMatrixData[i - startRow], 0,
endColumn - startColumn + 1);
return new BigMatrixImpl(subMatrixData, false);
throws MatrixIndexException {
final BigDecimal[][] subMatrixData =
new BigDecimal[selectedRows.length][selectedColumns.length];
final BigDecimal[] subI = subMatrixData[i];
final BigDecimal[] dataSelectedI = data[selectedRows[i]];
subI[j] = dataSelectedI[selectedColumns[j]];
return new BigMatrixImpl(subMatrixData, false);
final int nRows = subMatrix.length;
final int nCols = subMatrix[0].length;
final int ncols = this.getColumnDimension();
final BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out, false);
final int nRows = this.getRowDimension();
final BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out, false);
final int ncols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[ncols];
final int ncols = this.getColumnDimension();
final double[] out = new double[ncols];
final int nRows = this.getRowDimension();
final BigDecimal[] out = new BigDecimal[nRows];
final int nrows = this.getRowDimension();
final double[] out = new double[nrows];
return data[row][column];
} catch (ArrayIndexOutOfBoundsException e) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[][] outData = new BigDecimal[nCols][nRows];
final BigDecimal[] dataRow = data[row];
outData[col][row] = dataRow[col];
return new BigMatrixImpl(outData, false);
return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[nRows];
final BigDecimal bd[] = new BigDecimal[v.length];
for (int i = 0; i < bd.length; i++) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] out = new BigDecimal[nCols];
final int nRows = this.getRowDimension();
final BigMatrix bMatrix = new BigMatrixImpl(b);
final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
final BigDecimal[] out = new BigDecimal[nRows];
final BigDecimal bd[] = new BigDecimal[b.length];
for (int i = 0; i < bd.length; i++) {
final int nCol = this.getColumnDimension();
final int nColB = b.getColumnDimension();
final int nRowB = b.getRowDimension();
final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
final BigDecimal[] bpRow = bp[row];
bpRow[col] = b.getEntry(permutation[row], col);
final BigDecimal[] bpI = bp[i];
final BigDecimal[] luI = lu[i];
bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
final BigDecimal[] bpCol = bp[col];
final BigDecimal luDiag = lu[col][col];
bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);
final BigDecimal[] bpI = bp[i];
final BigDecimal[] luI = lu[i];
bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));
return new BigMatrixImpl(bp, false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final BigDecimal[] luRow = lu[row];
sum = luRow[col];
sum = sum.subtract(luRow[i].multiply(lu[i][col]));
luRow[col] = sum;
final BigDecimal[] luRow = lu[row];
sum = luRow[col];
sum = sum.subtract(luRow[i].multiply(lu[i][col]));
luRow[col] = sum;
final BigDecimal luDiag = lu[col][col];
final BigDecimal[] luRow = lu[row];
luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);
if (i > 0) {
if (j > 0) {
final BigMatrix m = (BigMatrix) object;
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final BigDecimal[] dataRow = data[row];
if (!dataRow[col].equals(m.getEntry(row, col))) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final BigDecimal[] dataRow = data[row];
dataRow[col].hashCode();
final int[] out = new int[permutation.length];
final int nRows = this.getRowDimension();
final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
final int nRows = in.length;
final int nCols = in[0].length;
final BigDecimal[] dataI = data[i];
final double[] inI = in[i];
for (int j = 0; j < nCols; j++) {
dataI[j] = new BigDecimal(inI[j]);
final int nRows = in.length;
final int nCols = in[0].length;
final BigDecimal[] dataI = data[i];
final String[] inI = in[i];
for (int j = 0; j < nCols; j++) {
dataI[j] = new BigDecimal(inI[j]);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
package org.apache.commons.math.linear;
public interface DecompositionSolver extends Serializable {
void decompose(RealMatrix matrix)
throws InvalidMatrixException;
double[] solve(double[] b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;
RealVector solve(RealVector b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;
RealMatrix solve(RealMatrix b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;
package org.apache.commons.math.linear;
public interface LUDecomposition extends DecompositionSolver {
void decompose(RealMatrix matrix, double singularityThreshold);
RealMatrix getL() throws IllegalStateException;
RealMatrix getU() throws IllegalStateException;
RealMatrix getP() throws IllegalStateException;
int[] getPivot() throws IllegalStateException;
boolean isNonSingular() throws IllegalStateException;
double getDeterminant() throws IllegalStateException;
package org.apache.commons.math.linear;
public class LUDecompositionImpl implements LUDecomposition {
private static final long serialVersionUID = -9052751605297201067L;
private double lu[][];
private int[] pivot;
private int parity;
private boolean singular;
private RealMatrix cachedL;
private RealMatrix cachedU;
private RealMatrix cachedP;
private static final double DEFAULT_TOO_SMALL = 10E-12;
public LUDecompositionImpl() {
public LUDecompositionImpl(RealMatrix matrix)
throws InvalidMatrixException {
decompose(matrix);
public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)
throws InvalidMatrixException {
decompose(matrix, singularityThreshold);
public void decompose(RealMatrix matrix)
throws InvalidMatrixException {
decompose(matrix, DEFAULT_TOO_SMALL);
public void decompose(RealMatrix matrix, double singularityThreshold)
throws InvalidMatrixException {
if (!matrix.isSquare()) {
throw new InvalidMatrixException("LU decomposition requires that the matrix be square.");
final int m = matrix.getColumnDimension();
lu = matrix.getData();
pivot = new int[m];
cachedL = null;
cachedU = null;
cachedP = null;
for (int row = 0; row < m; row++) {
pivot[row] = row;
parity = 1;
singular = false;
for (int col = 0; col < m; col++) {
double sum = 0;
for (int row = 0; row < col; row++) {
final double[] luRow = lu[row];
sum = luRow[col];
for (int i = 0; i < row; i++) {
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
int max = col; // permutation row
double largest = Double.NEGATIVE_INFINITY;
for (int row = col; row < m; row++) {
final double[] luRow = lu[row];
sum = luRow[col];
for (int i = 0; i < col; i++) {
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
if (Math.abs(sum) > largest) {
largest = Math.abs(sum);
max = row;
if (Math.abs(lu[max][col]) < singularityThreshold) {
singular = true;
return;
if (max != col) {
double tmp = 0;
for (int i = 0; i < m; i++) {
tmp = lu[max][i];
lu[max][i] = lu[col][i];
lu[col][i] = tmp;
int temp = pivot[max];
pivot[max] = pivot[col];
pivot[col] = temp;
parity = -parity;
final double luDiag = lu[col][col];
for (int row = col + 1; row < m; row++) {
lu[row][col] /= luDiag;
public RealMatrix getL()
throws IllegalStateException {
checkDecomposed();
if ((cachedL == null) && !singular) {
final int m = pivot.length;
final double[][] lData = new double[m][m];
for (int i = 0; i < m; ++i) {
System.arraycopy(lu[i], 0, lData[i], 0, i);
lData[i][i] = 1.0;
cachedL = new RealMatrixImpl(lData, false);
return cachedL;
public RealMatrix getU()
throws IllegalStateException {
checkDecomposed();
if ((cachedU == null) && !singular) {
final int m = pivot.length;
final double[][] uData = new double[m][m];
for (int i = 0; i < m; ++i) {
System.arraycopy(lu[i], i, uData[i], i, m - i);
cachedU = new RealMatrixImpl(uData, false);
return cachedU;
public RealMatrix getP()
throws IllegalStateException {
checkDecomposed();
if ((cachedP == null) && !singular) {
final int m = pivot.length;
final double[][] pData = new double[m][m];
for (int i = 0; i < m; ++i) {
pData[i][pivot[i]] = 1.0;
cachedP = new RealMatrixImpl(pData, false);
return cachedP;
public int[] getPivot()
throws IllegalStateException {
checkDecomposed();
return pivot.clone();
public boolean isNonSingular()
throws IllegalStateException {
checkDecomposed();
return !singular;
public double getDeterminant()
throws IllegalStateException {
checkDecomposed();
if (singular) {
return 0;
} else {
final int m = pivot.length;
double determinant = parity;
for (int i = 0; i < m; i++) {
determinant *= lu[i][i];
return determinant;
public double[] solve(double[] b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
checkDecomposed();
final int m = pivot.length;
if (b.length != m) {
throw new IllegalArgumentException("constant vector has wrong length");
if (singular) {
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[m];
for (int row = 0; row < m; row++) {
bp[row] = b[pivot[row]];
for (int col = 0; col < m; col++) {
for (int i = col + 1; i < m; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = m - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return bp;
public RealVector solve(RealVector b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
return solve((RealVectorImpl) b);
} catch (ClassCastException cce) {
checkDecomposed();
final int m = pivot.length;
if (b.getDimension() != m) {
throw new IllegalArgumentException("constant vector has wrong length");
if (singular) {
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[m];
for (int row = 0; row < m; row++) {
bp[row] = b.getEntry(pivot[row]);
for (int col = 0; col < m; col++) {
for (int i = col + 1; i < m; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = m - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return new RealVectorImpl(bp, false);
public RealVectorImpl solve(RealVectorImpl b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
return new RealVectorImpl(solve(b.getDataRef()), false);
public RealMatrix solve(RealMatrix b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
checkDecomposed();
final int m = pivot.length;
if (b.getRowDimension() != m) {
throw new IllegalArgumentException("Incorrect row dimension");
if (singular) {
throw new InvalidMatrixException("Matrix is singular.");
final int nColB = b.getColumnDimension();
final double[][] bp = new double[m][nColB];
for (int row = 0; row < m; row++) {
final double[] bpRow = bp[row];
final int pRow = pivot[row];
for (int col = 0; col < nColB; col++) {
bpRow[col] = b.getEntry(pRow, col);
for (int col = 0; col < m; col++) {
final double[] bpCol = bp[col];
for (int i = col + 1; i < m; i++) {
final double[] bpI = bp[i];
final double luICol = lu[i][col];
for (int j = 0; j < nColB; j++) {
bpI[j] -= bpCol[j] * luICol;
for (int col = m - 1; col >= 0; col--) {
final double[] bpCol = bp[col];
final double luDiag = lu[col][col];
for (int j = 0; j < nColB; j++) {
bpCol[j] /= luDiag;
for (int i = 0; i < col; i++) {
final double[] bpI = bp[i];
final double luICol = lu[i][col];
for (int j = 0; j < nColB; j++) {
bpI[j] -= bpCol[j] * luICol;
return new RealMatrixImpl(bp, false);
private void checkDecomposed()
throws IllegalStateException {
if (lu == null) {
throw new IllegalStateException("no matrix have been decomposed yet");
private static final long serialVersionUID = 3728473373420246054L;
public static RealMatrix createRealMatrix(double[][] data, boolean copyArray) {
return new RealMatrixImpl(data, copyArray);
double[][] d = new double[dimension][dimension];
d[row][row] = 1d;
return new RealMatrixImpl(d, false);
public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {
return new BigMatrixImpl(data, copyArray);
public static RealVector createRealVector(double[] data) {
return new RealVectorImpl(data, true);
final int nCols = rowData.length;
final double[][] data = new double[1][nCols];
return new RealMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
for (int i = 0; i < nCols; ++i) {
data[0][i] = new BigDecimal(rowData[i]);
return new BigMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data, false);
final int nCols = rowData.length;
final BigDecimal[][] data = new BigDecimal[1][nCols];
for (int i = 0; i < nCols; ++i) {
data[0][i] = new BigDecimal(rowData[i]);
return new BigMatrixImpl(data, false);
final int nRows = columnData.length;
final double[][] data = new double[nRows][1];
return new RealMatrixImpl(data, false);
final int nRows = columnData.length;
final BigDecimal[][] data = new BigDecimal[nRows][1];
data[row][0] = new BigDecimal(columnData[row]);
return new BigMatrixImpl(data, false);
final int nRows = columnData.length;
final BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data, false);
final BigDecimal[][] data = new BigDecimal[nRows][1];
data[row][0] = new BigDecimal(columnData[row]);
return new BigMatrixImpl(data, false);
final BigDecimal[][] d = new BigDecimal[dimension][dimension];
final BigDecimal[] dRow = d[row];
Arrays.fill(dRow, BigMatrixImpl.ZERO);
dRow[row] = BigMatrixImpl.ONE;
return new BigMatrixImpl(d, false);
public interface QRDecomposition extends DecompositionSolver {
RealMatrix getR() throws IllegalStateException;
RealMatrix getQ() throws IllegalStateException;
RealMatrix getH() throws IllegalStateException;
boolean isFullRank() throws IllegalStateException;
private static final long serialVersionUID = 7560093145655650408L;
private double[][] qrt;
private RealMatrix cachedQ;
private RealMatrix cachedR;
private RealMatrix cachedH;
public QRDecompositionImpl() {
decompose(matrix);
public void decompose(RealMatrix matrix) {
final int m = matrix.getRowDimension();
final int n = matrix.getColumnDimension();
qrt = matrix.transpose().getData();
cachedQ = null;
cachedR = null;
cachedH = null;
final double[] qrtMinor = qrt[minor];
final double c = qrtMinor[row];
xNormSqr += c * c;
final double a = (qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])
final double[] qrtCol = qrt[col];
alpha -= qrtCol[row] * qrtMinor[row];
alpha /= a * qrtMinor[minor];
qrtCol[row] -= alpha * qrtMinor[row];
throws IllegalStateException {
if (cachedR == null) {
checkDecomposed();
final int n = qrt.length;
final int m = qrt[0].length;
double[][] r = new double[m][n];
for (int row = Math.min(m, n) - 1; row >= 0; row--) {
double[] rRow = r[row];
rRow[row] = rDiag[row];
for (int col = row + 1; col < n; col++) {
rRow[col] = qrt[col][row];
cachedR = new RealMatrixImpl(r, false);
return cachedR;
throws IllegalStateException {
if (cachedQ == null) {
checkDecomposed();
final int n = qrt.length;
final int m = qrt[0].length;
double[][] q = new double[m][m];
for (int minor = m - 1; minor >= Math.min(m, n); minor--) {
q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
final double[] qrtMinor = qrt[minor];
q[minor][minor] = 1;
if (qrtMinor[minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= q[row][col] * qrtMinor[row];
alpha /= rDiag[minor] * qrtMinor[minor];
for (int row = minor; row < m; row++) {
q[row][col] -= alpha * qrtMinor[row];
cachedQ = new RealMatrixImpl(q, false);
return cachedQ;
public RealMatrix getH()
throws IllegalStateException {
if (cachedH == null) {
checkDecomposed();
final int n = qrt.length;
final int m = qrt[0].length;
double[][] hData = new double[m][n];
for (int i = 0; i < m; ++i) {
final double[] hDataI = hData[i];
for (int j = 0; j < Math.min(i + 1, n); ++j) {
hDataI[j] = qrt[j][i] / -rDiag[j];
cachedH = new RealMatrixImpl(hData, false);
return cachedH;
public boolean isFullRank()
throws IllegalStateException {
checkDecomposed();
for (double diag : rDiag) {
if (diag == 0) {
return false;
return true;
public double[] solve(double[] b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
checkDecomposed();
final int n = qrt.length;
final int m = qrt[0].length;
if (b.length != m) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!isFullRank()) {
throw new InvalidMatrixException("Matrix is rank-deficient");
final double[] x = new double[n];
final double[] y = b.clone();
for (int minor = 0; minor < Math.min(m, n); minor++) {
final double[] qrtMinor = qrt[minor];
double dotProduct = 0;
for (int row = minor; row < m; row++) {
dotProduct += y[row] * qrtMinor[row];
dotProduct /= rDiag[minor] * qrtMinor[minor];
for (int row = minor; row < m; row++) {
y[row] += dotProduct * qrtMinor[row];
for (int row = n - 1; row >= 0; --row) {
y[row] /= rDiag[row];
final double yRow   = y[row];
final double[] qrtRow = qrt[row];
x[row] = yRow;
for (int i = 0; i < row; i++) {
y[i] -= yRow * qrtRow[i];
return x;
public RealVector solve(RealVector b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
return solve((RealVectorImpl) b);
} catch (ClassCastException cce) {
checkDecomposed();
return new RealVectorImpl(solve(b.getData()), false);
public RealVectorImpl solve(RealVectorImpl b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
return new RealVectorImpl(solve(b.getDataRef()), false);
public RealMatrix solve(RealMatrix b)
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
checkDecomposed();
final int n = qrt.length;
final int m = qrt[0].length;
if (b.getRowDimension() != m) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!isFullRank()) {
throw new InvalidMatrixException("Matrix is rank-deficient");
final int cols = b.getColumnDimension();
final double[][] xData = new double[n][cols];
final double[] y = new double[b.getRowDimension()];
for (int k = 0; k < cols; ++k) {
for (int j = 0; j < y.length; ++j) {
y[j] = b.getEntry(j, k);
for (int minor = 0; minor < Math.min(m, n); minor++) {
final double[] qrtMinor = qrt[minor];
double dotProduct = 0;
for (int row = minor; row < m; row++) {
dotProduct += y[row] * qrtMinor[row];
dotProduct /= rDiag[minor] * qrtMinor[minor];
for (int row = minor; row < m; row++) {
y[row] += dotProduct * qrtMinor[row];
for (int row = n - 1; row >= 0; --row) {
y[row] /= rDiag[row];
final double yRow = y[row];
final double[] qrtRow = qrt[row];
xData[row][k] = yRow;
for (int i = 0; i < row; i++) {
y[i] -= yRow * qrtRow[i];
return new RealMatrixImpl(xData, false);
private void checkDecomposed()
throws IllegalStateException {
if (qrt == null) {
throw new IllegalStateException("no matrix have been decomposed yet");
RealVector getRowVector(int row) throws MatrixIndexException;
RealVector getColumnVector(int column) throws MatrixIndexException;
RealVector operate(RealVector v) throws IllegalArgumentException;
RealVector preMultiply(RealVector v) throws IllegalArgumentException;
RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException;
private static final long serialVersionUID = 4970229902484487012L;
protected double data[][] = null;
protected double lu[][] = null;
protected int[] permutation = null;
protected int parity = 1;
private static final double TOO_SMALL = 10E-12;
copyIn(d);
lu = null;
public RealMatrixImpl(double[][] d, boolean copyArray) {
if (copyArray) {
copyIn(d);
} else {
if (d == null) {
throw new NullPointerException();
}   
final int nRows = d.length;
if (nRows == 0) {
throw new IllegalArgumentException("Matrix must have at least one row."); 
final int nCols = d[0].length;
if (nCols == 0) {
throw new IllegalArgumentException("Matrix must have at least one column."); 
for (int r = 1; r < nRows; r++) {
if (d[r].length != nCols) {
throw new IllegalArgumentException("All input rows must have the same length.");
}       
data = d;
final int nRows = v.length;
return new RealMatrixImpl(copyOut(), false);
return add((RealMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col] + m.getEntry(row, col);
}  
return new RealMatrixImpl(outData, false);
public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] mRow       = m.data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] + mRow[col];
return new RealMatrixImpl(outData, false);
return subtract((RealMatrixImpl) m);
} catch (ClassCastException cce) {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
throw new IllegalArgumentException("matrix dimension mismatch");
final double[][] outData = new double[rowCount][columnCount];
for (int row = 0; row < rowCount; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < columnCount; col++) {
outDataRow[col] = dataRow[col] - m.getEntry(row, col);
}  
return new RealMatrixImpl(outData, false);
public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] mRow       = m.data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] - mRow[col];
}  
return new RealMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] + d;
return new RealMatrixImpl(outData, false);
final int rowCount    = getRowDimension();
final int columnCount = getColumnDimension();
final double[][] outData = new double[rowCount][columnCount];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
outDataRow[col] = dataRow[col] * d;
return new RealMatrixImpl(outData, false);
return multiply((RealMatrixImpl) m);
} catch (ClassCastException cce) {
if (this.getColumnDimension() != m.getRowDimension()) {
throw new IllegalArgumentException("Matrices are not multiplication compatible.");
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final double[][] outData = new double[nRows][nCols];
for (int row = 0; row < nRows; row++) {
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nSum; i++) {
sum += dataRow[i] * m.getEntry(i, col);
outDataRow[col] = sum;
return new RealMatrixImpl(outData, false);
public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {
final int nRows = this.getRowDimension();
final int nCols = m.getColumnDimension();
final int nSum = this.getColumnDimension();
final double[][] outData = new double[nRows][nCols];
final double[] dataRow    = data[row];
final double[] outDataRow = outData[row];
double sum = 0;
sum += dataRow[i] * m.data[i][col];
outDataRow[col] = sum;
}            
return new RealMatrixImpl(outData, false);
public RealMatrix getSubMatrix(int startRow, int endRow,
int startColumn, int endColumn)
throws MatrixIndexException {
endColumn > data[0].length) {
final double[][] subMatrixData =
new double[endRow - startRow + 1][endColumn - startColumn + 1];
System.arraycopy(data[i], startColumn,
subMatrixData[i - startRow], 0,
endColumn - startColumn + 1);
return new RealMatrixImpl(subMatrixData, false);
throws MatrixIndexException {
final double[][] subMatrixData =
new double[selectedRows.length][selectedColumns.length];
final double[] subI = subMatrixData[i];
final double[] dataSelectedI = data[selectedRows[i]];
subI[j] = dataSelectedI[selectedColumns[j]];
} catch (ArrayIndexOutOfBoundsException e) {
return new RealMatrixImpl(subMatrixData, false);
final int nRows = subMatrix.length;
final int nCols = subMatrix[0].length;
final int ncols = this.getColumnDimension();
final double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out, false);
final int nRows = this.getRowDimension();
final double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out, false);
public RealVector getColumnVector(int column) throws MatrixIndexException {
return new RealVectorImpl(getColumn(column), false);
public RealVector getRowVector(int row) throws MatrixIndexException {
return new RealVectorImpl(getRow(row), false);
final int ncols = this.getColumnDimension();
final double[] out = new double[ncols];
final int nRows = this.getRowDimension();
final double[] out = new double[nRows];
return data[row][column];
} catch (ArrayIndexOutOfBoundsException e) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[][] outData = new double[nCols][nRows];
final double[] dataRow = data[row];
outData[col][row] = dataRow[col];
return new RealMatrixImpl(outData, false);
return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
if (v.length != nCols) {
final double[] out = new double[nRows];
final double[] dataRow = data[row];
sum += dataRow[i] * v[i];
public RealVector operate(RealVector v) throws IllegalArgumentException {
return operate((RealVectorImpl) v);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
if (v.getDimension() != nCols) {
throw new IllegalArgumentException("vector has wrong length");
final double[] out = new double[nRows];
for (int row = 0; row < nRows; row++) {
final double[] dataRow = data[row];
double sum = 0;
for (int i = 0; i < nCols; i++) {
sum += dataRow[i] * v.getEntry(i);
out[row] = sum;
return new RealVectorImpl(out, false);
public RealVectorImpl operate(RealVectorImpl v) throws IllegalArgumentException {
return new RealVectorImpl(operate(v.getDataRef()), false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
final double[] out = new double[nCols];
public RealVector preMultiply(RealVector v) throws IllegalArgumentException {
return preMultiply((RealVectorImpl) v);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
if (v.getDimension() != nRows) {
throw new IllegalArgumentException("vector has wrong length");
final int nCols = this.getColumnDimension();
final double[] out = new double[nCols];
for (int col = 0; col < nCols; col++) {
double sum = 0;
for (int i = 0; i < nRows; i++) {
sum += data[i][col] * v.getEntry(i);
out[col] = sum;
return new RealVectorImpl(out, false);
RealVectorImpl preMultiply(RealVectorImpl v) throws IllegalArgumentException {
return new RealVectorImpl(preMultiply(v.getDataRef()), false);
final int nRows = this.getRowDimension();
final int nCol  = this.getColumnDimension();
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[nRows];
bp[row] = b[permutation[row]];
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = nCol - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return bp;
public RealVector solve(RealVector b)
throws IllegalArgumentException, InvalidMatrixException {
return solve((RealVectorImpl) b);
} catch (ClassCastException cce) {
final int nRows = this.getRowDimension();
final int nCol  = this.getColumnDimension();
if (b.getDimension() != nRows) {
throw new IllegalArgumentException("constant vector has wrong length");
if (!isSquare()) {
throw new InvalidMatrixException("coefficient matrix is not square");
if (isSingular()) { // side effect: compute LU decomp
throw new InvalidMatrixException("Matrix is singular.");
final double[] bp = new double[nRows];
for (int row = 0; row < nRows; row++) {
bp[row] = b.getEntry(permutation[row]);
for (int col = 0; col < nCol; col++) {
for (int i = col + 1; i < nCol; i++) {
bp[i] -= bp[col] * lu[i][col];
for (int col = nCol - 1; col >= 0; col--) {
bp[col] /= lu[col][col];
for (int i = 0; i < col; i++) {
bp[i] -= bp[col] * lu[i][col];
return new RealVectorImpl(bp, false);
RealVectorImpl solve(RealVectorImpl b)
throws IllegalArgumentException, InvalidMatrixException {
return new RealVectorImpl(solve(b.getDataRef()), false);
final int nCol  = this.getColumnDimension();
final int nColB = b.getColumnDimension();
final int nRowB = b.getRowDimension();
final double[][] bp = new double[nRowB][nColB];
final double[] bpRow = bp[row];
final int pRow = permutation[row];
bpRow[col] = b.getEntry(pRow, col);
final double[] bpCol = bp[col];
final double[] bpI = bp[i];
final double luICol = lu[i][col];
bpI[j] -= bpCol[j] * luICol;
final double[] bpCol = bp[col];
final double luDiag = lu[col][col];
bpCol[j] /= luDiag;
final double[] bpI = bp[i];
final double luICol = lu[i][col];
bpI[j] -= bpCol[j] * luICol;
return new RealMatrixImpl(bp, false);
final int nRows = this.getRowDimension();
final int nCols = this.getColumnDimension();
lu = getData();
final double[] luRow = lu[row];
sum = luRow[col];
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
final double[] luRow = lu[row];
sum = luRow[col];
sum -= luRow[i] * lu[i][col];
luRow[col] = sum;
final double luDiag = lu[col][col];
lu[row][col] /= luDiag;
if (i > 0) {
if (j > 0) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[] dataRow = data[row];
if (dataRow[col] != m.getEntry(row, col)) {
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
final double[] dataRow = data[row];
for (int col = 0; col < nCols; col++) {
MathUtils.hash(dataRow[col]);
final int[] out = new int[permutation.length];
final int nRows = this.getRowDimension();
final double[][] out = new double[nRows][this.getColumnDimension()];
final int nRows = getRowDimension();
final int nCols = getColumnDimension();
package org.apache.commons.math.linear;
public interface RealVector {
RealVector copy();
RealVector add(RealVector v)
throws IllegalArgumentException;
RealVector subtract(RealVector v)
throws IllegalArgumentException;
RealVector mapAdd(double d);
RealVector mapAddToSelf(double d);
RealVector mapSubtract(double d);
RealVector mapSubtractToSelf(double d);
RealVector mapMultiply(double d);
RealVector mapMultiplyToSelf(double d);
RealVector mapDivide(double d);
RealVector mapDivideToSelf(double d);
RealVector mapPow(double d);
RealVector mapPowToSelf(double d);
RealVector mapExp();
RealVector mapExpToSelf();
RealVector mapExpm1();
RealVector mapExpm1ToSelf();
RealVector mapLog();
RealVector mapLogToSelf();
RealVector mapLog10();
RealVector mapLog10ToSelf();
RealVector mapLog1p();
RealVector mapLog1pToSelf();
RealVector mapCosh();
RealVector mapCoshToSelf();
RealVector mapSinh();
RealVector mapSinhToSelf();
RealVector mapTanh();
RealVector mapTanhToSelf();
RealVector mapCos();
RealVector mapCosToSelf();
RealVector mapSin();
RealVector mapSinToSelf();
RealVector mapTan();
RealVector mapTanToSelf();
RealVector mapAcos();
RealVector mapAcosToSelf();
RealVector mapAsin();
RealVector mapAsinToSelf();
RealVector mapAtan();
RealVector mapAtanToSelf();
RealVector mapInv();
RealVector mapInvToSelf();
RealVector mapAbs();
RealVector mapAbsToSelf();
RealVector mapSqrt();
RealVector mapSqrtToSelf();
RealVector mapCbrt();
RealVector mapCbrtToSelf();
RealVector mapCeil();
RealVector mapCeilToSelf();
RealVector mapFloor();
RealVector mapFloorToSelf();
RealVector mapRint();
RealVector mapRintToSelf();
RealVector mapSignum();
RealVector mapSignumToSelf();
RealVector mapUlp();
RealVector mapUlpToSelf();
public RealVector ebeMultiply(RealVector v)
throws IllegalArgumentException;
public RealVector ebeDivide(RealVector v)
throws IllegalArgumentException;
double[] getData();
double dotProduct(RealVector v)
throws IllegalArgumentException;
double getNorm();
double getL1Norm();
double getLInfNorm();
double getDistance(RealVector v)
throws IllegalArgumentException;
double getL1Distance(RealVector v)
throws IllegalArgumentException;
double getLInfDistance(RealVector v)
throws IllegalArgumentException;
RealVector unitVector();
void unitize();
RealVector projection(RealVector v)
throws IllegalArgumentException;
RealMatrix outerProduct(RealVector v)
throws IllegalArgumentException;
double getEntry(int index)
throws MatrixIndexException;
int getDimension();
RealVector append(RealVector v);
RealVector append(double d);
RealVector append(double[] a);
RealVector get(int index, int n)
throws MatrixIndexException;
void set(int index, double value)
throws MatrixIndexException;
void set(int index, RealVector v)
throws MatrixIndexException;
void set(double value);
double[] toArray();
public boolean isNaN();
public boolean isInfinite();
package org.apache.commons.math.linear;
public class RealVectorFormat extends CompositeFormat {
private static final long serialVersionUID = -708767813036157690L;
private static final String DEFAULT_PREFIX = "{";
private static final String DEFAULT_SUFFIX = "}";
private static final String DEFAULT_SEPARATOR = "; ";
private final String prefix;
private final String suffix;
private final String separator;
private final String trimmedPrefix;
private final String trimmedSuffix;
private final String trimmedSeparator;
private NumberFormat format;
public RealVectorFormat() {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());
public RealVectorFormat(final NumberFormat format) {
this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);
public RealVectorFormat(final String prefix, final String suffix,
final String separator) {
this(prefix, suffix, separator, getDefaultNumberFormat());
public RealVectorFormat(final String prefix, final String suffix,
final String separator, final NumberFormat format) {
this.prefix      = prefix;
this.suffix      = suffix;
this.separator   = separator;
trimmedPrefix    = prefix.trim();
trimmedSuffix    = suffix.trim();
trimmedSeparator = separator.trim();
this.format      = format;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
public String getPrefix() {
return prefix;
public String getSuffix() {
return suffix;
public String getSeparator() {
return separator;
public NumberFormat getFormat() {
return format;
public static RealVectorFormat getInstance() {
return getInstance(Locale.getDefault());
public static RealVectorFormat getInstance(final Locale locale) {
return new RealVectorFormat(getDefaultNumberFormat(locale));
public static String formatRealVector(RealVector v) {
return getInstance().format(v);
public StringBuffer format(RealVector vector, StringBuffer toAppendTo,
FieldPosition pos) {
pos.setBeginIndex(0);
pos.setEndIndex(0);
toAppendTo.append(prefix);
for (int i = 0; i < vector.getDimension(); ++i) {
if (i > 0) {
toAppendTo.append(separator);
formatDouble(vector.getEntry(i), format, toAppendTo, pos);
toAppendTo.append(suffix);
return toAppendTo;
public StringBuffer format(Object obj, StringBuffer toAppendTo,
FieldPosition pos) {
if (obj instanceof RealVector) {
return format( (RealVector)obj, toAppendTo, pos);
throw new IllegalArgumentException("Cannot format given Object as a RealVector");
public RealVectorImpl parse(String source) throws ParseException {
ParsePosition parsePosition = new ParsePosition(0);
RealVectorImpl result = parse(source, parsePosition);
if (parsePosition.getIndex() == 0) {
throw new ParseException("Unparseable real vector: \"" + source +
"\"", parsePosition.getErrorIndex());
return result;
public RealVectorImpl parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedPrefix, pos)) {
return null;
List<Number> components = new ArrayList<Number>();
for (boolean loop = true; loop;){
if (!components.isEmpty()) {
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSeparator, pos)) {
loop = false;
if (loop) {
parseAndIgnoreWhitespace(source, pos);
Number component = parseNumber(source, format, pos);
if (component != null) {
components.add(component);
} else {
pos.setIndex(initialIndex);
return null;
parseAndIgnoreWhitespace(source, pos);
if (!parseFixedstring(source, trimmedSuffix, pos)) {
return null;
double[] data = new double[components.size()];
for (int i = 0; i < data.length; ++i) {
data[i] = components.get(i).doubleValue();
return new RealVectorImpl(data, false);
public Object parseObject(String source, ParsePosition pos) {
return parse(source, pos);
package org.apache.commons.math.linear;
public class RealVectorImpl implements RealVector, Serializable {
private static final long serialVersionUID = 7838747548772166404L;
private static final RealVectorFormat DEFAULT_FORMAT =
RealVectorFormat.getInstance();
protected double data[];
public RealVectorImpl() {
data = new double[0];
public RealVectorImpl(int size) {
data = new double[size];
public RealVectorImpl(int size, double preset) {
data = new double[size];
Arrays.fill(data, preset);
public RealVectorImpl(double[] d) {
data = d.clone();
public RealVectorImpl(double[] d, boolean copyArray)
throws NullPointerException, IllegalArgumentException {
if (d == null) {
throw new NullPointerException();
}   
if (d.length == 0) {
throw new IllegalArgumentException("Vector must have at least one element."); 
data = copyArray ? d.clone() :  d;
public RealVectorImpl(double[] d, int pos, int size) {
if (d.length < pos + size) {
throw new IllegalArgumentException("Position " + pos + " and size " + size +
" don't fit to the size of the input array " +
d.length);
data = new double[size];
System.arraycopy(d, pos, data, 0, size);
public RealVectorImpl(Double[] d) {
data = new double[d.length];
for (int i = 0; i < d.length; i++) {
data[i] = d[i].doubleValue();
public RealVectorImpl(Double[] d, int pos, int size) {
if (d.length < pos + size) {
throw new IllegalArgumentException("Position " + pos + " and size " + size +
" don't fit to the size of the input array " +
d.length);
data = new double[size];
for (int i = pos; i < pos + size; i++) {
data[i-pos] = d[i].doubleValue();
public RealVectorImpl(RealVector v) {
data = new double[v.getDimension()];
for (int i = 0; i < data.length; ++i) {
data[i] = v.getEntry(i);
public RealVectorImpl(RealVectorImpl v) {
data = v.data.clone();
public RealVectorImpl(RealVectorImpl v, boolean deep) {
data = deep ? v.data.clone() : v.data;
public RealVectorImpl(RealVectorImpl v1, RealVectorImpl v2) {
data = new double[v1.data.length + v2.data.length];
System.arraycopy(v1.data, 0, data, 0, v1.data.length);
System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);
public RealVector copy() {
return new RealVectorImpl(this, true);
public RealVector add(RealVector v)
throws IllegalArgumentException {
return add((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl add(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + v.data[i];
return new RealVectorImpl(out);
public RealVector subtract(RealVector v)
throws IllegalArgumentException {
return subtract((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl subtract(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - v.data[i];
return new RealVectorImpl(out);
public RealVector mapAdd(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] + d;
return new RealVectorImpl(out);
public RealVector mapAddToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] + d;
return this;
public RealVector mapSubtract(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] - d;
return new RealVectorImpl(out);
public RealVector mapSubtractToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] - d;
return this;
public RealVector mapMultiply(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * d;
return new RealVectorImpl(out);
public RealVector mapMultiplyToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] * d;
return this;
public RealVector mapDivide(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / d;
return new RealVectorImpl(out);
public RealVector mapDivideToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = data[i] / d;
return this;
public RealVector mapPow(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.pow(data[i], d);
return new RealVectorImpl(out);
public RealVector mapPowToSelf(double d) {
for (int i = 0; i < data.length; i++) {
data[i] = Math.pow(data[i], d);
return this;
public RealVector mapExp() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.exp(data[i]);
return new RealVectorImpl(out);
public RealVector mapExpToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.exp(data[i]);
return this;
public RealVector mapExpm1() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.expm1(data[i]);
return new RealVectorImpl(out);
public RealVector mapExpm1ToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.expm1(data[i]);
return this;
public RealVector mapLog() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log(data[i]);
return new RealVectorImpl(out);
public RealVector mapLogToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log(data[i]);
return this;
public RealVector mapLog10() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log10(data[i]);
return new RealVectorImpl(out);
public RealVector mapLog10ToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log10(data[i]);
return this;
public RealVector mapLog1p() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.log1p(data[i]);
return new RealVectorImpl(out);
public RealVector mapLog1pToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.log1p(data[i]);
return this;
public RealVector mapCosh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cosh(data[i]);
return new RealVectorImpl(out);
public RealVector mapCoshToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cosh(data[i]);
return this;
public RealVector mapSinh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sinh(data[i]);
return new RealVectorImpl(out);
public RealVector mapSinhToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sinh(data[i]);
return this;
public RealVector mapTanh() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.tanh(data[i]);
return new RealVectorImpl(out);
public RealVector mapTanhToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.tanh(data[i]);
return this;
public RealVector mapCos() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cos(data[i]);
return new RealVectorImpl(out);
public RealVector mapCosToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cos(data[i]);
return this;
public RealVector mapSin() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sin(data[i]);
return new RealVectorImpl(out);
public RealVector mapSinToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sin(data[i]);
return this;
public RealVector mapTan() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.tan(data[i]);
return new RealVectorImpl(out);
public RealVector mapTanToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.tan(data[i]);
return this;
public RealVector mapAcos() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.acos(data[i]);
return new RealVectorImpl(out);
public RealVector mapAcosToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.acos(data[i]);
return this;
public RealVector mapAsin() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.asin(data[i]);
return new RealVectorImpl(out);
public RealVector mapAsinToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.asin(data[i]);
return this;
public RealVector mapAtan() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.atan(data[i]);
return new RealVectorImpl(out);
public RealVector mapAtanToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.atan(data[i]);
return this;
public RealVector mapInv() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = 1.0 / data[i];
return new RealVectorImpl(out);
public RealVector mapInvToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = 1.0 / data[i];
return this;
public RealVector mapAbs() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.abs(data[i]);
return new RealVectorImpl(out);
public RealVector mapAbsToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.abs(data[i]);
return this;
public RealVector mapSqrt() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.sqrt(data[i]);
return new RealVectorImpl(out);
public RealVector mapSqrtToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.sqrt(data[i]);
return this;
public RealVector mapCbrt() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.cbrt(data[i]);
return new RealVectorImpl(out);
public RealVector mapCbrtToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.cbrt(data[i]);
return this;
public RealVector mapCeil() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.ceil(data[i]);
return new RealVectorImpl(out);
public RealVector mapCeilToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.ceil(data[i]);
return this;
public RealVector mapFloor() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.floor(data[i]);
return new RealVectorImpl(out);
public RealVector mapFloorToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.floor(data[i]);
return this;
public RealVector mapRint() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.rint(data[i]);
return new RealVectorImpl(out);
public RealVector mapRintToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.rint(data[i]);
return this;
public RealVector mapSignum() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.signum(data[i]);
return new RealVectorImpl(out);
public RealVector mapSignumToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.signum(data[i]);
return this;
public RealVector mapUlp() {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = Math.ulp(data[i]);
return new RealVectorImpl(out);
public RealVector mapUlpToSelf() {
for (int i = 0; i < data.length; i++) {
data[i] = Math.ulp(data[i]);
return this;
public RealVector ebeMultiply(RealVector v)
throws IllegalArgumentException {
return ebeMultiply((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl ebeMultiply(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * v.data[i];
return new RealVectorImpl(out);
public RealVector ebeDivide(RealVector v)
throws IllegalArgumentException {
return ebeDivide((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / v.getEntry(i);
return new RealVectorImpl(out);
public RealVectorImpl ebeDivide(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] / v.data[i];
return new RealVectorImpl(out);
public double[] getData() {
return data.clone();
public double[] getDataRef() {
return data;
public double dotProduct(RealVector v)
throws IllegalArgumentException {
return dotProduct((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double dotProduct(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double getNorm() {
double sum = 0;
for (double a : data) {
sum += a * a;
return Math.sqrt(sum);
public double getL1Norm() {
double sum = 0;
for (double a : data) {
sum += Math.abs(a);
return sum;
public double getLInfNorm() {
double max = 0;
for (double a : data) {
max += Math.max(max, Math.abs(a));
return max;
public double getDistance(RealVector v)
throws IllegalArgumentException {
return getDistance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
sum += delta * delta;
return Math.sqrt(sum);
public double getDistance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
sum += delta * delta;
return Math.sqrt(sum);
public double getL1Distance(RealVector v)
throws IllegalArgumentException {
return getL1Distance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
sum += Math.abs(delta);
return sum;
public double getL1Distance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double sum = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
sum += Math.abs(delta);
return sum;
public double getLInfDistance(RealVector v)
throws IllegalArgumentException {
return getLInfDistance((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double max = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.getEntry(i); 
max = Math.max(max, Math.abs(delta));
return max;
public double getLInfDistance(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double max = 0;
for (int i = 0; i < data.length; ++i) {
final double delta = data[i] - v.data[i];
max = Math.max(max, Math.abs(delta));
return max;
public RealVector unitVector() throws ArithmeticException {
final double norm = getNorm();
if (norm == 0) {
throw new ArithmeticException("null norm");
return mapDivide(getNorm());
public void unitize() throws ArithmeticException {
final double norm = getNorm();
if (norm == 0) {
throw new ArithmeticException("null norm");
for (int i = 0; i < data.length; i++) {
data[i] /= norm;
public RealVector projection(RealVector v) {
return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
public RealVectorImpl projection(RealVectorImpl v) {
return (RealVectorImpl) v.mapMultiply(dotProduct(v) / v.dotProduct(v));
public RealMatrix outerProduct(RealVector v)
throws IllegalArgumentException {
return outerProduct((RealVectorImpl) v);
} catch (ClassCastException cce) {
checkVectorDimensions(v);
double[][] out = new double[data.length][data.length];
for (int i = 0; i < data.length; i++) {
for (int j = 0; j < data.length; j++) {
out[i][j] = data[i] * v.getEntry(j);
return new RealMatrixImpl(out);
public RealMatrixImpl outerProduct(RealVectorImpl v)
throws IllegalArgumentException {
checkVectorDimensions(v);
double[][] out = new double[data.length][data.length];
for (int i = 0; i < data.length; i++) {
for (int j = 0; j < data.length; j++) {
out[i][j] = data[i] * v.data[j];
return new RealMatrixImpl(out);
public double getEntry(int index) throws MatrixIndexException {
return data[index];
public int getDimension() {
return data.length;
public RealVector append(RealVector v) {
return append((RealVectorImpl) v);
} catch (ClassCastException cce) {
return new RealVectorImpl(this,new RealVectorImpl(v));
public RealVectorImpl append(RealVectorImpl v) {
return new RealVectorImpl(this, v);
public RealVector append(double in) {
final double[] out = new double[data.length + 1];
System.arraycopy(data, 0, out, 0, data.length);
out[data.length] = in;
return new RealVectorImpl(out);
public RealVector append(double[] in) {
final double[] out = new double[data.length + in.length];
System.arraycopy(data, 0, out, 0, data.length);
System.arraycopy(in, 0, out, data.length, in.length);
return new RealVectorImpl(out);
public RealVector get(int index, int n) {
RealVectorImpl out = new RealVectorImpl(n);
System.arraycopy(data, index, out.data, 0, n);
return out;
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, double value) {
data[index] = value;
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, RealVector v) {
set(index, (RealVectorImpl) v);
} catch (ClassCastException cce) {
for (int i = index; i < index + v.getDimension(); ++i) {
data[i] = v.getEntry(i-index);
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(int index, RealVectorImpl v)
throws MatrixIndexException {
System.arraycopy(v.data, 0, data, index, v.data.length);
} catch (IndexOutOfBoundsException e) {
throw new MatrixIndexException(e.getMessage());
public void set(double value) {
Arrays.fill(data, value);
public double[] toArray(){
return data.clone();
public String toString(){
return DEFAULT_FORMAT.format(this);
public void checkVectorDimensions(RealVector v)
throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
public void checkVectorDimensions(int n)
throws IllegalArgumentException {
if (data.length != n) {
throw new IllegalArgumentException("vector dimension is " + data.length +
", not " + n + " as expected");
public boolean isNaN() {
for (double v : data) {
if (Double.isNaN(v)) {
return true;
return false;
public boolean isInfinite() {
if (isNaN()) {
return false;
for (double v : data) {
if (Double.isInfinite(v)) {
return true;
return false;
public boolean equals(Object other) {
if (this == other) { 
return true;
if (other == null) {
return false;
RealVector rhs = (RealVector) other;
if (data.length != rhs.getDimension()) {
return false;
if (rhs.isNaN()) {
return this.isNaN();
for (int i = 0; i < data.length; ++i) {
if (data[i] != rhs.getEntry(i)) {
return false;
return true;
} catch (ClassCastException ex) {
return false;
public int hashCode() {
if (isNaN()) {
return 9;
return MathUtils.hash(data);
package org.apache.commons.math.ode;
public abstract class AbstractIntegrator implements FirstOrderIntegrator {
private final String name;
protected Collection<StepHandler> stepHandlers;
protected double stepStart;
protected double stepSize;
protected CombinedEventsManager eventsHandlersManager;
public AbstractIntegrator(final String name) {
this.name = name;
stepHandlers = new ArrayList<StepHandler>();
stepStart = Double.NaN;
stepSize  = Double.NaN;
eventsHandlersManager = new CombinedEventsManager();
public String getName() {
return name;
public void addStepHandler(final StepHandler handler) {
stepHandlers.add(handler);
public Collection<StepHandler> getStepHandlers() {
return Collections.unmodifiableCollection(stepHandlers);
public void clearStepHandlers() {
stepHandlers.clear();
public void addEventHandler(final EventHandler function,
final double maxCheckInterval,
final double convergence,
final int maxIterationCount) {
eventsHandlersManager.addEventHandler(function, maxCheckInterval,
convergence, maxIterationCount);
public Collection<EventHandler> getEventHandlers() {
return eventsHandlersManager.getEventsHandlers();
public void clearEventHandlers() {
eventsHandlersManager.clearEventsHandlers();
protected boolean requiresDenseOutput() {
for (StepHandler handler : stepHandlers) {
if (handler.requiresDenseOutput()) {
return true;
return false;
public double getCurrentStepStart() {
return stepStart;
public double getCurrentSignedStepsize() {
return stepSize;
protected void sanityChecks(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y.length)
});
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
Double.valueOf(Math.abs(t - t0))
});
protected CombinedEventsManager addEndTimeChecker(final double startTime,
final double endTime,
final CombinedEventsManager manager) {
CombinedEventsManager newManager = new CombinedEventsManager();
for (final EventState state : manager.getEventsStates()) {
newManager.addEventHandler(state.getEventHandler(),
state.getMaxCheckInterval(),
state.getConvergence(),
state.getMaxIterationCount());
newManager.addEventHandler(new EndTimeChecker(endTime),
Double.POSITIVE_INFINITY,
Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),
100);
return newManager;
private static class EndTimeChecker implements EventHandler {
private static final long serialVersionUID = -5211782540446301964L;
private final double endTime;
public EndTimeChecker(final double endTime) {
this.endTime = endTime;
public int eventOccurred(double t, double[] y) {
return STOP;
public double g(double t, double[] y) {
return t - endTime;
public void resetState(double t, double[] y) {
steps = new ArrayList<StepInterpolator>();
public void append(final ContinuousOutputModel model)
final StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
final double current  = lastInterpolator.getCurrentTime();
final double previous = lastInterpolator.getPreviousTime();
final double step = current - previous;
final double gap = model.getInitialTime() - current;
for (StepInterpolator interpolator : model.steps) {
steps.add(interpolator.copy());
public void handleStep(final StepInterpolator interpolator, final boolean isLast)
steps.add(interpolator.copy());
finalTime = interpolator.getCurrentTime();
return steps.get(index).getInterpolatedTime();
public void setInterpolatedTime(final double time) {
final StepInterpolator sMin = steps.get(iMin);
final StepInterpolator sMax = steps.get(iMax);
final StepInterpolator si = steps.get(index);
final int location = locatePoint(time, si);
final int iMed = (iMin + iMax) / 2;
final StepInterpolator sMed = steps.get(iMed);
final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
final double d12 = tMax - tMed;
final double d23 = tMed - tMin;
final double d13 = tMax - tMin;
final double dt1 = time - tMax;
final double dt2 = time - tMed;
final double dt3 = time - tMin;
final double iLagrange = ((dt2 * dt3 * d23) * iMax -
(dt1 * dt3 * d13) * iMed +
(dt1 * dt2 * d12) * iMin) /
(d12 * d23 * d13);
final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {
steps.get(index).setInterpolatedTime(time);
return steps.get(index).getInterpolatedState();
private int locatePoint(final double time, final StepInterpolator interval) {
private List<StepInterpolator> steps;
private static final long serialVersionUID = -1417964919405031606L;
public DerivativeException(final String specifier, final Object[] parts) {
public DerivativeException(final Throwable cause) {
private static final long serialVersionUID = -8233657110042144146L;
public FirstOrderConverter (final SecondOrderDifferentialEquations equations) {
public void computeDerivatives(final double t, final double[] y, final double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations extends Serializable {
public interface FirstOrderIntegrator extends ODEIntegrator {
public double integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public IntegratorException(final String specifier, final Object[] parts) {
public IntegratorException(final Throwable cause) {
package org.apache.commons.math.ode;
public interface ODEIntegrator extends Serializable {
String getName();
void addStepHandler(StepHandler handler);
Collection<StepHandler> getStepHandlers();
void clearStepHandlers();
void addEventHandler(EventHandler handler,
double maxCheckInterval,
double convergence,
int maxIterationCount);
Collection<EventHandler> getEventHandlers();
void clearEventHandlers();
double getCurrentStepStart();
double getCurrentSignedStepsize();
public interface SecondOrderIntegrator extends ODEIntegrator {
package org.apache.commons.math.ode.events;
public class CombinedEventsManager implements Serializable {
private static final long serialVersionUID = -4151965151236441261L;
private final List<EventState> states;
private EventState first;
private boolean initialized;
public CombinedEventsManager() {
states      = new ArrayList<EventState>();
first       = null;
initialized = false;
public void addEventHandler(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
states.add(new EventState(handler, maxCheckInterval,
convergence, maxIterationCount));
public Collection<EventHandler> getEventsHandlers() {
final List<EventHandler> list = new ArrayList<EventHandler>();
for (EventState state : states) {
list.add(state.getEventHandler());
return Collections.unmodifiableCollection(list);
public void clearEventsHandlers() {
states.clear();
public Collection<EventState> getEventsStates() {
return states;
public boolean isEmpty() {
return states.isEmpty();
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, IntegratorException {
first = null;
if (states.isEmpty()) {
return false;
if (! initialized) {
final double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
final double [] y = interpolator.getInterpolatedState();
for (EventState state : states) {
state.reinitializeBegin(t0, y);
initialized = true;
for (EventState state : states) {
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
} else {
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
} else {
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
} catch (EventException se) {
throw new IntegratorException(se);
} catch (ConvergenceException ce) {
throw new IntegratorException(ce);
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
public void stepAccepted(final double t, final double[] y)
throws IntegratorException {
for (EventState state : states) {
state.stepAccepted(t, y);
} catch (EventException se) {
throw new IntegratorException(se);
public boolean stop() {
for (EventState state : states) {
if (state.stop()) {
return true;
return false;
public boolean reset(final double t, final double[] y)
throws IntegratorException {
boolean resetDerivatives = false;
for (EventState state : states) {
if (state.reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
} catch (EventException se) {
throw new IntegratorException(se);
package org.apache.commons.math.ode.events;
public class EventException extends MathException {
private static final long serialVersionUID = -898215297400035290L;
public EventException(final String specifier, final Object[] parts) {
super(specifier, parts);
public EventException(final Throwable cause) {
super(cause);
package org.apache.commons.math.ode.events;
public interface EventHandler extends Serializable {
public double g(double t, double[] y) throws EventException;
public int eventOccurred(double t, double[] y) throws EventException;
public void resetState(double t, double[] y) throws EventException;
package org.apache.commons.math.ode.events;
public class EventState implements Serializable {
private static final long serialVersionUID = -216176055159247559L;
private final EventHandler handler;
private final double maxCheckInterval;
private final double convergence;
private final int maxIterationCount;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
public EventState(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
this.handler           = handler;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = EventHandler.CONTINUE;
public EventHandler getEventHandler() {
return handler;
public double getMaxCheckInterval() {
return maxCheckInterval;
public double getConvergence() {
return convergence;
public int getMaxIterationCount() {
return maxIterationCount;
public void reinitializeBegin(final double t0, final double[] y0)
throws EventException {
this.t0 = t0;
g0 = handler.g(t0, y0);
g0Positive = (g0 >= 0);
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, EventException, ConvergenceException {
final double t1 = interpolator.getCurrentTime();
final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
final double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
final double gb = handler.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
final UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(final double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return handler.g(t, interpolator.getInterpolatedState());
} catch (DerivativeException e) {
throw new FunctionEvaluationException(t, e);
} catch (EventException e) {
throw new FunctionEvaluationException(t, e);
});
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(maxIterationCount);
final double root = (ta <= tb) ? solver.solve(ta, tb) : solver.solve(tb, ta);
if (Math.abs(root - ta) <= convergence) {
ta = tb;
ga = gb;
} else if (Double.isNaN(previousEventTime) ||
(Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
} else {
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
} catch (FunctionEvaluationException e) {
final Throwable cause = e.getCause();
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
} else if ((cause != null) && (cause instanceof EventException)) {
throw (EventException) cause;
throw new EventException(e);
public double getEventTime() {
return pendingEventTime;
public void stepAccepted(final double t, final double[] y)
throws EventException {
t0 = t;
g0 = handler.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = handler.eventOccurred(t, y);
} else {
g0Positive = (g0 >= 0);
nextAction = EventHandler.CONTINUE;
public boolean stop() {
return nextAction == EventHandler.STOP;
public boolean reset(final double t, final double[] y)
throws EventException {
if (! pendingEvent) {
return false;
if (nextAction == EventHandler.RESET_STATE) {
handler.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
return (nextAction == EventHandler.RESET_STATE) ||
(nextAction == EventHandler.RESET_DERIVATIVES);
package org.apache.commons.math.ode.nonstiff;
public class AdamsBashforthIntegrator extends MultistepIntegrator {
private static final long serialVersionUID = 1676381657635800870L;
private static final String METHOD_NAME = "Adams-Bashforth";
private final double[] coeffs;
private final double step;
public AdamsBashforthIntegrator(final int order, final double step) {
super(METHOD_NAME, order, new AdamsBashforthStepInterpolator());
int[][] bdArray = computeBackwardDifferencesArray(order);
Fraction[] gamma = computeGammaArray(order);
coeffs = new double[order];
for (int i = 0; i < order; ++i) {
Fraction f = Fraction.ZERO;
for (int j = i; j < order; ++j) {
f = f.add(gamma[j].multiply(new Fraction(bdArray[j][i], 1)));
coeffs[i] = f.doubleValue();
this.step = Math.abs(step);
public double integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[] yTmp = new double[y0.length];
final AdamsBashforthStepInterpolator interpolator =
(AdamsBashforthStepInterpolator) prototype.copy();
interpolator.reinitialize(yTmp, previousT, previousF, forward);
stepStart = t0;
stepSize  = forward ? step : -step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
double stopTime =
start(previousF.length, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
interpolator.storeTime(stepStart);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < coeffs.length; ++l) {
sum += coeffs[l] * previousF[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
final boolean truncated;
if (manager.evaluateStep(interpolator)) {
truncated = true;
interpolator.truncateStep(manager.getEventTime());
} else {
truncated = false;
final double nextStep = interpolator.getCurrentTime();
interpolator.setInterpolatedTime(nextStep);
System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (!lastStep) {
if (manager.reset(stepStart, y)) {
stopTime =
start(previousF.length, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
} else {
if (truncated) {
for (int i = 1; i < previousF.length; ++i) {
previousT[i] = stepStart - i * stepSize;
interpolator.setInterpolatedTime(previousT[i]);
System.arraycopy(interpolator.getInterpolatedState(), 0,
previousF[i], 0, y0.length);
} else {
rotatePreviousSteps();
previousT[0] = stepStart;
equations.computeDerivatives(stepStart, y, previousF[0]);
stopTime  = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
public double[] getCoeffs() {
return coeffs.clone();
int[][] bdArray = new int[order][];
bdArray[0] = new int[] { 1 };
for (int i = 1; i < order; ++i) {
bdArray[i] = new int[i + 1];
bdArray[i][0] = 1;
for (int j = 0; j < i - 1; ++j) {
bdArray[i][j + 1] = bdArray[i - 1][j + 1] - bdArray[i - 1][j];
bdArray[i][i] = -bdArray[i - 1][i - 1];
return bdArray;
Fraction[] gammaArray = new Fraction[order];
gammaArray[0] = Fraction.ONE;
for (int i = 1; i < order; ++i) {
Fraction gamma = Fraction.ONE;
for (int j = 1; j <= i; ++j) {
gamma = gamma.subtract(gammaArray[i - j].multiply(new Fraction(1, j + 1)));
gammaArray[i] = gamma;
return gammaArray;
package org.apache.commons.math.ode.nonstiff;
class AdamsBashforthStepInterpolator extends MultistepStepInterpolator {
private static final long serialVersionUID = -7179861704951334960L;
private double[] neville;
private double[] rollback;
private double[] gamma;
private int[][] bdArray;
private double nonTruncatedEnd;
private double nonTruncatedH;
public AdamsBashforthStepInterpolator() {
public AdamsBashforthStepInterpolator(final AdamsBashforthStepInterpolator interpolator) {
super(interpolator);
nonTruncatedEnd = interpolator.nonTruncatedEnd;
nonTruncatedH   = interpolator.nonTruncatedH;
protected StepInterpolator doCopy() {
return new AdamsBashforthStepInterpolator(this);
protected void initializeCoefficients() {
neville  = new double[previousF.length];
rollback = new double[previousF.length];
bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);
Fraction[] fGamma = AdamsBashforthIntegrator.computeGammaArray(previousF.length);
gamma = new double[fGamma.length];
for (int i = 0; i < fGamma.length; ++i) {
gamma[i] = fGamma[i].doubleValue();
public void storeTime(final double t) {
nonTruncatedEnd = t;
nonTruncatedH   = nonTruncatedEnd - previousTime;
super.storeTime(t);
void truncateStep(final double truncatedEndTime) {
currentTime = truncatedEndTime;
h = currentTime - previousTime;
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;
final double theta = (nonTruncatedH == 0) ?
0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;
computeInterpolatedState(theta, oneMinusThetaH);
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {
interpolateDerivatives();
interpolateState(theta);
private void interpolateDerivatives() {
for (int i = 0; i < interpolatedDerivatives.length; ++i) {
for (int k = 0; k < previousF.length; ++k) {
neville[k] = previousF[k][i];
for (int l = 1; l < neville.length; ++l) {
for (int m = neville.length - 1; m >= l; --m) {
final double xm   = previousT[m];
final double xmMl = previousT[m - l];
neville[m] = ((interpolatedTime - xm) * neville[m-1] +
(xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);
interpolatedDerivatives[i] = neville[neville.length - 1];
private void interpolateState(final double theta) {
computeRollback(previousT.length - 1, theta);
for (int j = 0; j < interpolatedState.length; ++j) {
double sum = 0;
for (int l = 0; l < previousT.length; ++l) {
sum += rollback[l] * previousF[l][j];
interpolatedState[j] = currentState[j] - h * sum;
private void computeRollback(final int order, final double theta) {
double product = theta;
rollback[0]  = theta;
for (int i = 1; i < order; ++i) {
product *= (i + theta) / (i + 1);
double g = product;
for (int j = 1; j <= i; ++j) {
g -= rollback[i - j] / (j + 1);
rollback[i] = g;
for (int i = 0; i < order; ++i) {
rollback[i] -= gamma[i];
for (int i = 0; i < order; ++i) {
double f = 0;
for (int j = i; j <= order; ++j) {
f -= rollback[j] * bdArray[j][i];
rollback[i] = f;
public void writeExternal(final ObjectOutput out)
throws IOException {
super.writeExternal(out);
out.writeDouble(nonTruncatedEnd);
public void readExternal(final ObjectInput in)
throws IOException {
nonTruncatedEnd = in.readDouble();
package org.apache.commons.math.ode.nonstiff;
public class AdamsMoultonIntegrator extends MultistepIntegrator {
private static final long serialVersionUID = 4990335331377040417L;
private static final String METHOD_NAME = "Adams-Moulton";
private final double[] predictorCoeffs;
private final double[] correctorCoeffs;
private final double step;
public AdamsMoultonIntegrator(final int order, final double step) {
super(METHOD_NAME, order + 1, new AdamsMoultonStepInterpolator());
int[][] bdArray      = AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);
Fraction[] gamma     = AdamsBashforthIntegrator.computeGammaArray(order);
predictorCoeffs = new double[order];
for (int i = 0; i < order; ++i) {
Fraction fPredictor = Fraction.ZERO;
for (int j = i; j < order; ++j) {
Fraction f = new Fraction(bdArray[j][i], 1);
fPredictor = fPredictor.add(gamma[j].multiply(f));
predictorCoeffs[i] = fPredictor.doubleValue();
Fraction[] gammaStar = computeGammaStarArray(order);
correctorCoeffs = new double[order + 1];
for (int i = 0; i <= order; ++i) {
Fraction fCorrector = Fraction.ZERO;
for (int j = i; j <= order; ++j) {
Fraction f = new Fraction(bdArray[j][i], 1);
fCorrector = fCorrector.add(gammaStar[j].multiply(f));
correctorCoeffs[i] = fCorrector.doubleValue();
this.step = Math.abs(step);
public double integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[] yTmp = new double[y0.length];
final AdamsMoultonStepInterpolator interpolator =
(AdamsMoultonStepInterpolator) prototype.copy();
interpolator.reinitialize(yTmp, previousT, previousF, forward);
stepStart = t0;
stepSize  = forward ? step : -step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
double stopTime =
start(previousF.length - 1, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
rotatePreviousSteps();
previousF[0] = new double[y0.length];
interpolator.storeTime(stepStart);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < predictorCoeffs.length; ++l) {
sum += predictorCoeffs[l] * previousF[l+1][j];
yTmp[j] = y[j] + stepSize * sum;
final double stepEnd = stepStart + stepSize;
equations.computeDerivatives(stepEnd, yTmp, previousF[0]);
for (int j = 0; j < y0.length; ++j) {
double sum = 0;
for (int l = 0; l < correctorCoeffs.length; ++l) {
sum += correctorCoeffs[l] * previousF[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepEnd);
final boolean truncated;
if (manager.evaluateStep(interpolator)) {
truncated = true;
interpolator.truncateStep(manager.getEventTime());
} else {
truncated = false;
final double nextStep = interpolator.getCurrentTime();
interpolator.setInterpolatedTime(nextStep);
System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (!lastStep) {
if (manager.reset(stepStart, y)) {
stopTime =
start(previousF.length - 1, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
rotatePreviousSteps();
previousF[0] = new double[y0.length];
} else {
if (truncated) {
for (int i = 1; i < previousF.length; ++i) {
previousT[i] = stepStart - i * stepSize;
interpolator.setInterpolatedTime(previousT[i]);
System.arraycopy(interpolator.getInterpolatedState(), 0,
previousF[i], 0, y0.length);
} else {
rotatePreviousSteps();
previousT[0] = stepStart;
equations.computeDerivatives(stepStart, y, previousF[0]);
stopTime  = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
public double[] getPredictorCoeffs() {
return predictorCoeffs.clone();
public double[] getCorrectorCoeffs() {
return correctorCoeffs.clone();
Fraction[] gammaStarArray = new Fraction[order + 1];
gammaStarArray[0] = Fraction.ONE;
for (int i = 1; i <= order; ++i) {
Fraction gammaStar = Fraction.ZERO;
for (int j = 1; j <= i; ++j) {
gammaStar = gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1, j + 1)));
gammaStarArray[i] = gammaStar;
return gammaStarArray;
package org.apache.commons.math.ode.nonstiff;
class AdamsMoultonStepInterpolator extends MultistepStepInterpolator {
private static final long serialVersionUID = 735568489801241899L;
private double[] neville;
private double[] rollback;
private double[] gammaStar;
private int[][] bdArray;
private double nonTruncatedEnd;
private double nonTruncatedH;
public AdamsMoultonStepInterpolator() {
public AdamsMoultonStepInterpolator(final AdamsMoultonStepInterpolator interpolator) {
super(interpolator);
nonTruncatedEnd = interpolator.nonTruncatedEnd;
nonTruncatedH   = interpolator.nonTruncatedH;
protected StepInterpolator doCopy() {
return new AdamsMoultonStepInterpolator(this);
protected void initializeCoefficients() {
neville  = new double[previousF.length];
rollback = new double[previousF.length];
bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);
Fraction[] fGammaStar = AdamsMoultonIntegrator.computeGammaStarArray(previousF.length);
gammaStar = new double[fGammaStar.length];
for (int i = 0; i < fGammaStar.length; ++i) {
gammaStar[i] = fGammaStar[i].doubleValue();
public void storeTime(final double t) {
nonTruncatedEnd = t;
nonTruncatedH   = nonTruncatedEnd - previousTime;
super.storeTime(t);
void truncateStep(final double truncatedEndTime) {
currentTime = truncatedEndTime;
h = currentTime - previousTime;
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;
final double theta = (nonTruncatedH == 0) ?
0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;
computeInterpolatedState(theta, oneMinusThetaH);
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {
interpolateDerivatives();
interpolateState(theta);
private void interpolateDerivatives() {
for (int i = 0; i < interpolatedDerivatives.length; ++i) {
for (int k = 0; k < previousF.length; ++k) {
neville[k] = previousF[k][i];
for (int l = 1; l < neville.length; ++l) {
for (int m = neville.length - 1; m >= l; --m) {
final double xm   = previousT[m];
final double xmMl = previousT[m - l];
neville[m] = ((interpolatedTime - xm) * neville[m-1] +
(xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);
interpolatedDerivatives[i] = neville[neville.length - 1];
private void interpolateState(final double theta) {
computeRollback(previousT.length - 1, theta);
for (int j = 0; j < interpolatedState.length; ++j) {
double sum = 0;
for (int l = 0; l < previousT.length; ++l) {
sum += rollback[l] * previousF[l][j];
interpolatedState[j] = currentState[j] - h * sum;
private void computeRollback(final int order, final double theta) {
double product = theta - 1;
rollback[0]  = theta;
for (int i = 1; i <= order; ++i) {
product *= (i - 1 + theta) / (i + 1);
double gStar = product;
for (int j = 1; j <= i; ++j) {
gStar -= rollback[i - j] / (j + 1);
rollback[i] = gStar;
for (int i = 0; i <= order; ++i) {
rollback[i] -= gammaStar[i];
for (int i = 0; i <= order; ++i) {
double f = 0;
for (int j = i; j <= order; ++j) {
f -= rollback[j] * bdArray[j][i];
rollback[i] = f;
public void writeExternal(final ObjectOutput out)
throws IOException {
super.writeExternal(out);
out.writeDouble(nonTruncatedEnd);
public void readExternal(final ObjectInput in)
throws IOException {
nonTruncatedEnd = in.readDouble();
package org.apache.commons.math.ode.nonstiff;
extends AbstractIntegrator {
public AdaptiveStepsizeIntegrator(final String name,
final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(name);
this.minStep     = Math.abs(minStep);
this.maxStep     = Math.abs(maxStep);
public AdaptiveStepsizeIntegrator(final String name,
final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(name);
public void setInitialStepSize(final double initialStepSize) {
protected void sanityChecks(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws IntegratorException {
super.sanityChecks(equations, t0, y0, t, y);
Integer.valueOf(y0.length),
Integer.valueOf(vecAbsoluteTolerance.length)
Integer.valueOf(y0.length),
Integer.valueOf(vecRelativeTolerance.length)
public double initializeStep(final FirstOrderDifferentialEquations equations,
final boolean forward, final int order, final double[] scale,
final double t0, final double[] y0, final double[] yDot0,
final double[] y1, final double[] yDot1)
throws DerivativeException {
final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
final double h1 = (maxInv2 < 1.0e-15) ?
Math.max(1.0e-6, 0.001 * Math.abs(h)) :
Math.pow(0.01 / maxInv2, 1.0 / order);
protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)
double filteredH = h;
if (Math.abs(h) < minStep) {
if (acceptSmall) {
filteredH = forward ? minStep : -minStep;
} else {
throw new IntegratorException("minimal step size ({0}) reached," +
" integration needs {1}",
new Object[] {
Double.valueOf(minStep),
Double.valueOf(Math.abs(h))
});
if (filteredH > maxStep) {
filteredH = maxStep;
} else if (filteredH < -maxStep) {
filteredH = -maxStep;
return filteredH;
public abstract double integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 3710070023793519840L;
public ClassicalRungeKuttaIntegrator(final double step) {
super("classical Runge-Kutta", c, a, b,
new ClassicalRungeKuttaStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
private static final long serialVersionUID = -6576285612589783992L;
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(final ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
protected StepInterpolator doCopy() {
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
throws DerivativeException {
final double fourTheta      = 4 * theta;
final double oneMinusTheta  = 1 - theta;
final double oneMinus2Theta = 1 - 2 * theta;
final double s             = oneMinusThetaH / 6.0;
final double coeff1        = s * ((-fourTheta + 5) * theta - 1);
final double coeff23       = s * (( fourTheta - 2) * theta - 2);
final double coeff4        = s * ((-fourTheta - 1) * theta - 1);
final double coeffDot1     = oneMinusTheta * oneMinus2Theta;
final double coeffDot23    = 2 * theta * oneMinusTheta;
final double coeffDot4     = -theta * oneMinus2Theta;
for (int i = 0; i < interpolatedState.length; ++i) {
final double yDot1  = yDotK[0][i];
final double yDot23 = yDotK[1][i] + yDotK[2][i];
final double yDot4  = yDotK[3][i];
interpolatedState[i] =
currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7932553613600031791L;
private static final String METHOD_NAME = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public DormandPrince54Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
e6 * yDotK[5][j] +  e7 * yDotK[6][j];
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode.nonstiff;
public DormandPrince54StepInterpolator(final DormandPrince54StepInterpolator interpolator) {
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
public void storeTime(final double t) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double yDot0 = yDotK[0][i];
final double yDot2 = yDotK[2][i];
final double yDot3 = yDotK[3][i];
final double yDot4 = yDotK[4][i];
final double yDot5 = yDotK[5][i];
final double yDot6 = yDotK[6][i];
v1[i] = a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5;
v2[i] = yDot0 - v1[i];
v3[i] = v1[i] - v2[i] - yDot6;
v4[i] = d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6;
final double eta = 1 - theta;
final double twoTheta = 2 * theta;
final double dot2 = 1 - twoTheta;
final double dot3 = theta * (2 - 3 * theta);
final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));
interpolatedState[i] =
currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -8627142100635188441L;
private static final String METHOD_NAME = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB,
public DormandPrince853Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, true, staticC, staticA, staticB,
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +
e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +
e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +
e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +
e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +
e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +
e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio1  = errSum1 / tol;
final double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode.nonstiff;
public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {
final int dimension = interpolator.currentState.length;
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
final int dimension = currentState.length;
public void storeTime(final double t) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double yDot1  = yDotK[0][i];
final double yDot6  = yDotK[5][i];
final double yDot7  = yDotK[6][i];
final double yDot8  = yDotK[7][i];
final double yDot9  = yDotK[8][i];
final double yDot10 = yDotK[9][i];
final double yDot11 = yDotK[10][i];
final double yDot12 = yDotK[11][i];
final double yDot13 = yDotK[12][i];
final double yDot14 = yDotKLast[0][i];
final double yDot15 = yDotKLast[1][i];
final double yDot16 = yDotKLast[2][i];
v[0][i] = b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +
b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +
b_11 * yDot11 + b_12 * yDot12;
v[1][i] = yDot1 - v[0][i];
v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +
d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +
d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +
d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16;
final double eta      = 1 - theta;
final double twoTheta = 2 * theta;
final double theta2   = theta * theta;
final double dot1 = 1 - twoTheta;
final double dot2 = theta * (2 - 3 * theta);
final double dot3 = twoTheta * (1 + theta * (twoTheta -3));
final double dot4 = theta2 * (3 + theta * (5 * theta - 8));
final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));
final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));
interpolatedState[i] = currentState[i] -
oneMinusThetaH * (v[0][i] -
theta * (v[1][i] +
theta * (v[2][i] +
eta * (v[3][i] +
theta * (v[4][i] +
eta * (v[5][i] +
theta * (v[6][i])))))));
interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +
dot3 * v[3][i] + dot4 * v[4][i] +
dot5 * v[5][i] + dot6 * v[6][i];
final double[] yTmp = new double[currentState.length];
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final int dimension = in.readInt();
package org.apache.commons.math.ode.nonstiff;
protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double   minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public void setSafety(final double safety) {
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
final boolean forward = (t > t0);
final int stages = c.length + 1;
final double[][] yDotK = new double[stages][];
final double[] yTmp = new double[y0.length];
if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
stepStart         = t0;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
boolean lastStep = false;
while (!lastStep) {
final double[] scale;
if (manager.evaluateStep(interpolator)) {
hNew = manager.getEventTime() - stepStart;
final double factor =
Math.min(maxGrowth,
Math.max(minReduction, safety * Math.pow(error, exp)));
hNew = filterStep(stepSize * factor, forward, false);
final double nextStep = stepStart + stepSize;
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
if (manager.reset(stepStart, y) && ! lastStep) {
stepSize = filterStep(stepSize, forward, true);
final double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
final double  scaledH    = stepSize * factor;
final double  nextT      = stepStart + scaledH;
final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, forward, nextIsLast);
final double stopTime = stepStart;
return stopTime;
public void setMinReduction(final double minReduction) {
public void setMaxGrowth(final double maxGrowth) {
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 1828811360890387657L;
public EulerIntegrator(final double step) {
super("Euler", c, a, b, new EulerStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7179861704951334960L;
public EulerStepInterpolator(final EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 5566682259665027132L;
public GillIntegrator(final double step) {
super("Gill", c, a, b, new GillStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public GillStepInterpolator(final GillStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double twoTheta  = 2 * theta;
final double fourTheta = 4 * theta;
final double s         = oneMinusThetaH / 6.0;
final double oMt       = 1 - theta;
final double soMt      = s * oMt;
final double c23       = soMt * (1 + twoTheta);
final double coeff1    = soMt * (1 - fourTheta);
final double coeff2    = c23  * tMq;
final double coeff3    = c23  * tPq;
final double coeff4    = s * (1 + theta * (1 + fourTheta));
final double coeffDot1 = theta * (twoTheta - 3) + 1;
final double cDot23    = theta * oMt;
final double coeffDot2 = cDot23  * tMq;
final double coeffDot3 = cDot23  * tPq;
final double coeffDot4 = theta * (twoTheta - 1);
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
final double yDot3 = yDotK[2][i];
final double yDot4 = yDotK[3][i];
interpolatedState[i] =
currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 7364884082146325264L;
private static final String METHOD_NAME = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, minStep, maxStep,
scalAbsoluteTolerance, scalRelativeTolerance);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, minStep, maxStep,
vecAbsoluteTolerance, vecRelativeTolerance);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public void setStabilityCheck(final boolean performTest,
final int maxIter, final int maxChecks,
final double stabilityReduction) {
public void setStepsizeControl(final double stepControl1, final double stepControl2,
final double stepControl3, final double stepControl4) {
public void setOrderControl(final int maxOrder,
final double orderControl1, final double orderControl2) {
public void addStepHandler (final StepHandler handler) {
super.addStepHandler(handler);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
public void addEventHandler(final EventHandler function,
final double maxCheckInterval,
final double convergence,
final int maxIterationCount) {
super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);
denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());
final int size = maxOrder / 2;
final double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(final boolean useInterpolationError,
final int mudif) {
private void rescale(final double[] y1, final double[] y2, final double[] scale) {
final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0, final double step, final int k,
final double[] scale, final double[][] f,
final double[] yMiddle, final double[] yEnd,
final double[] yTmp)
final int    n        = sequence[k];
final double subStep  = step / n;
final double subStep2 = 2 * subStep;
final double middle = yEnd[i];
final double ratio = f[0][l] / scale[l];
final double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(final int offset, final int k,
final double[][] diag, final double[] last) {
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0, final double t, final double[] y)
final boolean forward = (t > t0);
final double[] yDot0   = new double[y0.length];
final double[] y1      = new double[y0.length];
final double[] yTmp    = new double[y0.length];
final double[] yTmpDot = new double[y0.length];
final double[][] diagonal = new double[sequence.length-1][];
final double[][] y1Diag = new double[sequence.length-1][];
final double[][][] fk  = new double[sequence.length][][];
final double[] scale = new double[y0.length];
final double tol =
final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);
if (denseOutput || (! eventsHandlersManager.isEmpty())) {
for (StepHandler handler : stepHandlers) {
handler.reset();
final double nextT = stepStart + stepSize;
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));
final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));
final double exp = 1.0 / (2 * k + 1);
final double pow = Math.pow(stepControl3, exp);
optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));
final double ratio = ((double) sequence [k] * sequence[k+1]) /
(sequence[0] * sequence[0]);
final double ratio = ((double) sequence[k+1]) / sequence[0];
final int mu = 2 * k - mudif + 3;
final int l2 = l / 2;
final GraggBulirschStoerStepInterpolator gbsInterpolator
final double interpError = gbsInterpolator.estimateError(scale);
if (eventsHandlersManager.evaluateStep(interpolator)) {
hNew = Math.abs(eventsHandlersManager.getEventTime() - stepStart);
final double nextStep = stepStart + stepSize;
eventsHandlersManager.stepAccepted(nextStep, y);
if (eventsHandlersManager.stop()) {
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {
hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],
forward, false);
hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],
forward, false);
return stepStart;
package org.apache.commons.math.ode.nonstiff;
private void resetTables(final int maxDegree) {
final double[][] newPols = new double[maxDegree + 1][];
final int ip5 = i + 5;
final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,
final double[] y1, final double[] y1Dot,
final double[][] yMidDots,
final boolean forward) {
(final GraggBulirschStoerStepInterpolator interpolator) {
final int dimension = currentState.length;
public void computeCoefficients(final int mu, final double h) {
final double yp0   = h * y0Dot[i];
final double yp1   = h * y1Dot[i];
final double ydiff = y1[i] - currentState[i];
final double aspl  = ydiff - yp1;
final double bspl  = yp0 - ydiff;
final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
final double ph1 = ydiff + 0.25 * (aspl - bspl);
final double ph2 = yp1 - yp0;
final double ph3 = 6 * (bspl - aspl);
final double fac1 = 0.5 * j * (j - 1);
final double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(final double[] scale) {
final double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final int dimension = currentState.length;
final double oneMinusTheta = 1.0 - theta;
final double theta05       = theta - 0.5;
final double tOmT          = theta * oneMinusTheta;
final double t4            = tOmT * tOmT;
final double t4Dot         = 2 * tOmT * (1 - 2 * theta);
final double dot1          = 1.0 / h;
final double dot2          = theta * (2 - 3 * theta) / h;
final double dot3          = ((3 * theta - 4) * theta + 1) / h;
final double p0 = polynoms[0][i];
final double p1 = polynoms[1][i];
final double p2 = polynoms[2][i];
final double p3 = polynoms[3][i];
interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));
interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;
if (currentDegree > 3) {
double cDot = 0;
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
final double d = 1.0 / (j - 3);
cDot = d * (theta05 * cDot + c);
c = polynoms[j][i] + c * d * theta05;
interpolatedState[i]       += t4 * c;
interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;
if (h == 0) {
System.arraycopy(yMidDots[1], 0, interpolatedDerivatives, 0, dimension);
public void writeExternal(final ObjectOutput out)
final int dimension = currentState.length;
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
final int dimension = currentState.length;
final int degree = in.readInt();
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 1462328766749870097L;
private static final String METHOD_NAME = "Higham-Hall 5(4)";
public HighamHall54Integrator(final double minStep, final double maxStep,
final double scalAbsoluteTolerance,
final double scalRelativeTolerance) {
super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public HighamHall54Integrator(final double minStep, final double maxStep,
final double[] vecAbsoluteTolerance,
final double[] vecRelativeTolerance) {
super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
protected double estimateError(final double[][] yDotK,
final double[] y0, final double[] y1,
final double h) {
final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
final double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
final double ratio  = h * errSum / tol;
package org.apache.commons.math.ode.nonstiff;
public HighamHall54StepInterpolator(final HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double theta2 = theta * theta;
final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));
final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));
final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));
final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));
final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);
final double yDot0 = yDotK[0][i];
final double yDot2 = yDotK[2][i];
final double yDot3 = yDotK[3][i];
final double yDot4 = yDotK[4][i];
final double yDot5 = yDotK[5][i];
interpolatedState[i] =
currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;
interpolatedDerivatives[i] =
bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -7690774342890000483L;
public MidpointIntegrator(final double step) {
super("midpoint", c, a, b, new MidpointStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public MidpointStepInterpolator(final MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
final double coeff1    = oneMinusThetaH * theta;
final double coeff2    = oneMinusThetaH * (1.0 + theta);
final double coeffDot2 = 2 * theta;
final double coeffDot1 = 1 - coeffDot2;
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;
interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;
package org.apache.commons.math.ode.nonstiff;
public abstract class MultistepIntegrator extends AbstractIntegrator {
private FirstOrderIntegrator starter;
protected double[] previousT;
protected double[][] previousF;
private double resetTime;
protected MultistepStepInterpolator prototype;
protected MultistepIntegrator(final String name, final int k,
final MultistepStepInterpolator prototype) {
super(name);
starter = new DormandPrince853Integrator(1.0e-6, 1.0e6, 1.0e-5, 1.0e-6);
previousT = new double[k];
previousF = new double[k][];
this.prototype = prototype;
public ODEIntegrator getStarterIntegrator() {
return starter;
public void setStarterIntegrator(FirstOrderIntegrator starter) {
this.starter = starter;
protected double start(final int n, final double h,
final CombinedEventsManager manager,
final FirstOrderDifferentialEquations equations,
final double t0, final double[] y)
throws DerivativeException, IntegratorException {
Arrays.fill(previousT, Double.NaN);
Arrays.fill(previousF, null);
starter.clearEventHandlers();
for (EventState state : manager.getEventsStates()) {
starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),
state.getMaxCheckInterval(),
state.getConvergence(), state.getMaxIterationCount());
starter.clearStepHandlers();
for (final StepHandler handler : stepHandlers) {
starter.addStepHandler(new FilteringWrapper(handler));
final StoringStepHandler store = new StoringStepHandler(n);
starter.addStepHandler(new StepNormalizer(h, store));
double t = t0;
double stopTime = Double.NaN;
do {
resetTime = Double.NaN;
store.restart();
stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);
if (!Double.isNaN(resetTime)) {
t = resetTime;
} while (!Double.isNaN(resetTime));
starter.clearEventHandlers();
starter.clearStepHandlers();
if (store.getFinalState() != null) {
System.arraycopy(store.getFinalState(), 0, y, 0, y.length);
return stopTime;
protected void rotatePreviousSteps() {
final double[] rolled = previousF[previousT.length - 1];
for (int k = previousF.length - 1; k > 0; --k) {
previousT[k] = previousT[k - 1];
previousF[k] = previousF[k - 1];
previousF[0] = rolled;
private class ResetCheckingWrapper implements EventHandler {
private static final long serialVersionUID = 4922660285376467937L;
private final EventHandler handler;
public ResetCheckingWrapper(final EventHandler handler) {
this.handler = handler;
public int eventOccurred(double t, double[] y) throws EventException {
final int action = handler.eventOccurred(t, y);
if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {
resetTime = t;
return STOP;
return action;
public double g(double t, double[] y) throws EventException {
return handler.g(t, y);
public void resetState(double t, double[] y) throws EventException {
handler.resetState(t, y);
private class FilteringWrapper implements StepHandler {
private static final long serialVersionUID = 4607975253344802232L;
private final StepHandler handler;
public FilteringWrapper(final StepHandler handler) {
this.handler = handler;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
handler.handleStep(interpolator, eventsHandlersManager.stop());
public boolean requiresDenseOutput() {
return handler.requiresDenseOutput();
public void reset() {
handler.reset();
private class StoringStepHandler implements FixedStepHandler {
private static final long serialVersionUID = 4592974435520688797L;
private final int n;
private int count;
private double[] finalState;
public StoringStepHandler(final int n) {
this.n = n;
restart();
public void restart() {
count = 0;
finalState = null;
public double[] getFinalState() {
return finalState;
public void handleStep(final double t, final double[] y, final double[] yDot,
final boolean isLast) {
if (count++ < n) {
previousT[n - count] = t;
previousF[n - count] = yDot.clone();
if (count == n) {
finalState = y.clone();
package org.apache.commons.math.ode.nonstiff;
abstract class MultistepStepInterpolator
extends AbstractStepInterpolator {
protected double[] previousT;
protected double[][] previousF;
protected MultistepStepInterpolator() {
previousT = null;
previousF = null;
public MultistepStepInterpolator(final MultistepStepInterpolator interpolator) {
super(interpolator);
if (interpolator.currentState != null) {
previousT = interpolator.previousT.clone();
previousF = new double[interpolator.previousF.length][];
for (int k = 0; k < interpolator.previousF.length; ++k) {
previousF[k] = interpolator.previousF[k].clone();
initializeCoefficients();
} else {
previousT = null;
previousF = null;
public void reinitialize(final double[] y,
final double[] previousT, final double[][] previousF,
final boolean forward) {
reinitialize(y, forward);
this.previousT = previousT;
this.previousF = previousF;
initializeCoefficients();
protected abstract void initializeCoefficients();
public void writeExternal(final ObjectOutput out)
throws IOException {
writeBaseExternal(out);
out.writeInt(previousT.length);
for (int k = 0; k < previousF.length; ++k) {
out.writeDouble(previousT[k]);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(previousF[k][i]);
public void readExternal(final ObjectInput in)
throws IOException {
final double t = readBaseExternal(in);
final int kMax = in.readInt();
previousT = new double[kMax];
previousF = new double[kMax][];
for (int k = 0; k < kMax; ++k) {
previousT[k] = in.readDouble();
previousF[k] = new double[currentState.length];
for (int i = 0; i < currentState.length; ++i) {
previousF[k][i] = in.readDouble();
initializeCoefficients();
setInterpolatedTime(t);
} catch (DerivativeException e) {
throw new IOException(e.getMessage());
package org.apache.commons.math.ode.nonstiff;
public abstract class RungeKuttaIntegrator extends AbstractIntegrator {
protected RungeKuttaIntegrator(final String name,
final double[] c, final double[][] a, final double[] b,
final RungeKuttaStepInterpolator prototype,
final double step) {
super(name);
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = Math.abs(step);
public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,
final double t, final double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
final boolean forward = (t > t0);
final int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
final double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
final double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
} else {
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
stepStart = t0;
stepSize  = forward ? step : -step;
for (StepHandler handler : stepHandlers) {
handler.reset();
CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
boolean lastStep = false;
while (!lastStep) {
interpolator.shift();
for (boolean loop = true; loop;) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
if (manager.evaluateStep(interpolator)) {
stepSize = manager.getEventTime() - stepStart;
} else {
loop = false;
final double nextStep = stepStart + stepSize;
System.arraycopy(yTmp, 0, y, 0, y0.length);
manager.stepAccepted(nextStep, y);
lastStep = manager.stop();
interpolator.storeTime(nextStep);
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (manager.reset(stepStart, y) && ! lastStep) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
stepSize = forward ? step : -step;
final double stopTime = stepStart;
stepStart = Double.NaN;
stepSize  = Double.NaN;
return stopTime;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
package org.apache.commons.math.ode.nonstiff;
public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {
final int dimension = currentState.length;
public void reinitialize(final FirstOrderDifferentialEquations equations,
final double[] y, final double[][] yDotK, final boolean forward) {
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
final int kMax = in.readInt();
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -2480984691453028021L;
public ThreeEighthesIntegrator(final double step) {
super("3/8", c, a, b, new ThreeEighthesStepInterpolator(), step);
package org.apache.commons.math.ode.nonstiff;
public ThreeEighthesStepInterpolator(final ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta,
final double oneMinusThetaH)
throws DerivativeException {
final double fourTheta2 = 4 * theta * theta;
final double s          = oneMinusThetaH / 8.0;
final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
final double coeff2     = 3 * s * (1 + theta - fourTheta2);
final double coeff3     = 3 * s * (1 + theta);
final double coeff4     = s * (1 + theta + fourTheta2);
final double coeffDot3  = 0.75 * theta;
final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;
final double coeffDot2  = coeffDot3 * (5 - 6 * theta);
final double coeffDot4  = coeffDot3 * (2 * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
final double yDot1 = yDotK[0][i];
final double yDot2 = yDotK[1][i];
final double yDot3 = yDotK[2][i];
final double yDot4 = yDotK[3][i];
interpolatedState[i] =
currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;
interpolatedDerivatives[i] =
coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;
package org.apache.commons.math.ode.sampling;
protected double[] interpolatedDerivatives;
previousTime            = Double.NaN;
currentTime             = Double.NaN;
h                       = Double.NaN;
interpolatedTime        = Double.NaN;
currentState            = null;
interpolatedState       = null;
interpolatedDerivatives = null;
finalized               = false;
this.forward            = true;
protected AbstractStepInterpolator(final double[] y, final boolean forward) {
currentState            = y;
interpolatedState       = new double[y.length];
interpolatedDerivatives = new double[y.length];
protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {
currentState            = (double[]) interpolator.currentState.clone();
interpolatedState       = (double[]) interpolator.interpolatedState.clone();
interpolatedDerivatives = (double[]) interpolator.interpolatedDerivatives.clone();
currentState            = null;
interpolatedState       = null;
interpolatedDerivatives = null;
protected void reinitialize(final double[] y, final boolean forward) {
currentState            = y;
interpolatedState       = new double[y.length];
interpolatedDerivatives = new double[y.length];
public void storeTime(final double t) {
public void setInterpolatedTime(final double time)
throws DerivativeException {
interpolatedTime = time;
final double oneMinusThetaH = currentTime - interpolatedTime;
final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;
computeInterpolatedState(theta, oneMinusThetaH);
return interpolatedState;
public double[] getInterpolatedDerivatives() {
return interpolatedDerivatives;
protected void writeBaseExternal(final ObjectOutput out)
protected double readBaseExternal(final ObjectInput in)
final int dimension = in.readInt();
interpolatedTime        = Double.NaN;
interpolatedState       = new double[dimension];
interpolatedDerivatives = new double[dimension];
package org.apache.commons.math.ode.sampling;
public void handleStep(final StepInterpolator interpolator, final boolean isLast) {
package org.apache.commons.math.ode.sampling;
public DummyStepInterpolator(final double[] y, final boolean forward) {
public DummyStepInterpolator(final DummyStepInterpolator interpolator) {
protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)
public void writeExternal(final ObjectOutput out)
public void readExternal(final ObjectInput in)
final double t = readBaseExternal(in);
package org.apache.commons.math.ode.sampling;
public interface FixedStepHandler extends Serializable {
public void handleStep(double t, double[] y, double[] yDot, boolean isLast)
throws DerivativeException;
package org.apache.commons.math.ode.sampling;
public interface StepHandler extends Serializable {
package org.apache.commons.math.ode.sampling;
public double[] getInterpolatedDerivatives();
package org.apache.commons.math.ode.sampling;
public class StepNormalizer implements StepHandler {
private static final long serialVersionUID = -789699939659144654L;
private double h;
private final FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private double[] lastDerivatives;
private boolean forward;
public StepNormalizer(final double h, final FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime        = Double.NaN;
lastState       = null;
lastDerivatives = null;
forward         = true;
public void handleStep(final StepInterpolator interpolator, final boolean isLast)
throws DerivativeException {
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
lastState = interpolator.getInterpolatedState().clone();
lastDerivatives = interpolator.getInterpolatedDerivatives().clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
double nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, lastDerivatives, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,
lastDerivatives, 0, lastDerivatives.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, lastDerivatives, true);
private static Comparator<PointCostPair> pointCostPairComparator =
new Comparator<PointCostPair>() {
public int compare(PointCostPair o1, PointCostPair o2) {
return (o1.getCost() < o2.getCost()) ? -1 : ((o1 == o2) ? 0 : +1);
System.arraycopy(b[i], 0, root.getDataRef()[index[i]], 0, rank);
List<SummaryStatistics> getBinStats();
private static final long serialVersionUID = 5729073523949762654L;
private List<SummaryStatistics> binStats = null;
binStats = new ArrayList<SummaryStatistics>();
binStats = new ArrayList<SummaryStatistics>();
SummaryStatistics stats = binStats.get(findBin(min, val, delta));
val = Double.valueOf(str).doubleValue();
binStats.get(findBin(min, inputArray[i], delta));
double delta = (max - min)/(Double.valueOf(binCount)).doubleValue();
((double) binStats.get(0).getN()) / (double) sampleStats.getN();
((double) binStats.get(i).getN()) / (double) sampleStats.getN();
SummaryStatistics stats = binStats.get(i);
public List<SummaryStatistics> getBinStats() {
Object[] nextSample(Collection<?> c, int k);
Integer c = Integer.valueOf(randomBytes[i]);
Integer c = Integer.valueOf(hash[i]);
public Object[] nextSample(Collection<?> c, int k) {
obj = Long.valueOf(((Integer) v).longValue());
freqTable.put(obj, Long.valueOf(1));
freqTable.put(obj, Long.valueOf(count.longValue() + 1));
addValue(Long.valueOf(v));
addValue(Long.valueOf(v.longValue()));
addValue(Long.valueOf(v));
addValue(Character.valueOf(v));
return getCount(Long.valueOf(v));
return getCount(Long.valueOf(v));
return getCount(Character.valueOf(v));
return getPct(Long.valueOf(v));       
return getPct(Long.valueOf(v));         
return getPct(Character.valueOf(v));         
return getCumFreq(Long.valueOf(v));       
return getCumFreq(Long.valueOf(v));         
return getCumFreq(Character.valueOf(v));         
return getCumPct(Long.valueOf(v));       
return getCumPct(Long.valueOf(v));         
return getCumPct(Character.valueOf(v));         
private static final long serialVersionUID = 4133067267405273064L;
new Object[] {Double.valueOf(p)});
new Object[] {Double.valueOf(50.0d)});
private static final long serialVersionUID = -2021321786743555871L;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&
MathUtils.equals(stat.getMax(), this.getMax()) &&
MathUtils.equals(stat.getMean(), this.getMean()) &&
MathUtils.equals(stat.getMin(), this.getMin()) &&
MathUtils.equals(stat.getN(), this.getN()) &&
MathUtils.equals(stat.getSum(), this.getSum()) &&
MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&
MathUtils.equals(stat.getVariance(),
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
public double anovaFValue(Collection<double[]> categoryData)
public double anovaPValue(Collection<double[]> categoryData)
public boolean anovaTest(Collection<double[]> categoryData, double alpha)
private AnovaStats anovaStats(Collection<double[]> categoryData)
for (double[] array : categoryData) {
for (double[] data : categoryData) {
public static double oneWayAnovaFValue(Collection<double[]> categoryData)
public static double oneWayAnovaPValue(Collection<double[]> categoryData)
public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegression implements
MultipleLinearRegression {
protected RealMatrix X;
protected RealMatrix Y;
public void newSampleData(double[] data, int nobs, int nvars) {
double[] y = new double[nobs];
double[][] x = new double[nobs][nvars + 1];
int pointer = 0;
for (int i = 0; i < nobs; i++) {
y[i] = data[pointer++];
x[i][0] = 1.0d;
for (int j = 1; j < nvars + 1; j++) {
x[i][j] = data[pointer++];
this.X = new RealMatrixImpl(x);
this.Y = new RealMatrixImpl(y);
protected void newYSampleData(double[] y) {
this.Y = new RealMatrixImpl(y);
protected void newXSampleData(double[][] x) {
this.X = new RealMatrixImpl(x);
protected void validateSampleData(double[][] x, double[] y) {
if (x == null) {
throw new IllegalArgumentException("The regressors matrix x cannot be null.");
if (y == null) {
throw new IllegalArgumentException("The regressand vector y cannot be null.");
if (x.length != y.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the regressand vector y");
protected void validateCovarianceData(double[][] x, double[][] covariance) {
if (covariance == null) {
throw new IllegalArgumentException("Covariance matrix cannot be null.");
if (x.length != covariance.length) {
throw new IllegalArgumentException(
"The regressors matrix x columns must have the same length of the covariance matrix columns");
if (covariance.length > 0 && covariance.length != covariance[0].length) {
throw new IllegalArgumentException("The covariance matrix must be square");
public double[] estimateRegressionParameters() {
RealMatrix b = calculateBeta();
return b.getColumn(0);
public double[] estimateResiduals() {
RealMatrix b = calculateBeta();
RealMatrix e = Y.subtract(X.multiply(b));
return e.getColumn(0);
public double[][] estimateRegressionParametersVariance() {
return calculateBetaVariance().getData();
public double estimateRegressandVariance() {
return calculateYVariance();
protected abstract RealMatrix calculateBeta();
protected abstract RealMatrix calculateBetaVariance();
protected abstract double calculateYVariance();
protected RealMatrix calculateResiduals() {
RealMatrix b = calculateBeta();
return Y.subtract(X.multiply(b));
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
private RealMatrix Omega;
public void newSampleData(double[] y, double[][] x, double[][] covariance) {
validateSampleData(x, y);
newYSampleData(y);
newXSampleData(x);
validateCovarianceData(x, covariance);
newCovarianceData(covariance);
protected void newCovarianceData(double[][] omega){
this.Omega = new RealMatrixImpl(omega);
protected RealMatrix calculateBeta() {
RealMatrix OI = Omega.inverse();
RealMatrix XT = X.transpose();
RealMatrix XTOIX = XT.multiply(OI).multiply(X);
return XTOIX.inverse().multiply(XT).multiply(OI).multiply(Y);
protected RealMatrix calculateBetaVariance() {
RealMatrix XTOIX = X.transpose().multiply(Omega.inverse()).multiply(X);
return XTOIX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse =  u.transpose().multiply(Omega.inverse()).multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
package org.apache.commons.math.stat.regression;
public interface MultipleLinearRegression {
double[] estimateRegressionParameters();
double[][] estimateRegressionParametersVariance();
double[] estimateResiduals();
double estimateRegressandVariance();
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {
private QRDecomposition qr = null;
public void newSampleData(double[] y, double[][] x) {
validateSampleData(x, y);
newYSampleData(y);
newXSampleData(x);
public void newSampleData(double[] data, int nobs, int nvars) {
super.newSampleData(data, nobs, nvars);
qr = new QRDecompositionImpl(X);
protected void newXSampleData(double[][] x) {
this.X = new RealMatrixImpl(x);
qr = new QRDecompositionImpl(X);
protected RealMatrix calculateBeta() {
return solveUpperTriangular((RealMatrixImpl) qr.getR(),
(RealMatrixImpl) qr.getQ().transpose().multiply(Y));
protected RealMatrix calculateBetaVariance() {
RealMatrix XTX = X.transpose().multiply(X);
return XTX.inverse();
protected double calculateYVariance() {
RealMatrix u = calculateResiduals();
RealMatrix sse = u.transpose().multiply(u);
return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());
private static RealMatrix solveUpperTriangular(RealMatrixImpl coefficients,
RealMatrixImpl constants) {
if (!isUpperTriangular(coefficients, 1E-12)) {
throw new IllegalArgumentException(
"Coefficients is not upper-triangular");
if (constants.getColumnDimension() != 1) {
throw new IllegalArgumentException(
"Constants not a column matrix.");
int length = coefficients.getColumnDimension();
double[][] cons = constants.getDataRef();
double[][] coef = coefficients.getDataRef();
double x[] = new double[length];
for (int i = 0; i < length; i++) {
int index = length - 1 - i;
double sum = 0;
for (int j = index + 1; j < length; j++) {
sum += coef[index][j] * x[j];
x[index] = (cons[index][0] - sum) / coef[index][index];
} 
return new RealMatrixImpl(x);
private static boolean isUpperTriangular(RealMatrixImpl m, double epsilon) {
double[][] data = m.getDataRef();
int nCols = m.getColumnDimension();
int nRows = m.getRowDimension();
for (int r = 0; r < nRows; r++) {
int bound = Math.min(r, nCols);
for (int c = 0; c < bound; c++) {
if (Math.abs(data[r][c]) > epsilon) {
return false;
return true;
public void removeData(double x, double y) {
if (n > 0) {
double dx = x - xbar;
double dy = y - ybar;
sumXX -= dx * dx * (double) n / (double) (n - 1.0);
sumYY -= dy * dy * (double) n / (double) (n - 1.0);
sumXY -= dx * dy * (double) n / (double) (n - 1.0);
xbar -= dx / (double) (n - 1.0);
ybar -= dy / (double) (n - 1.0);
sumX -= x;
sumY -= y;
n--;
if (n > 2) {
distribution.setDegreesOfFreedom(n - 2);
} 
public void removeData(double[][] data) {
for (int i = 0; i < data.length && n > 0; i++) {
removeData(data[i][0], data[i][1]);
package org.apache.commons.math.util;
public abstract class CompositeFormat extends Format {
protected static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
protected static NumberFormat getDefaultNumberFormat(final Locale locale) {
final NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
protected void parseAndIgnoreWhitespace(final String source,
final ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
protected char parseNextCharacter(final String source,
final ParsePosition pos) {
int index = pos.getIndex();
final int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
} while (Character.isWhitespace(c) && index < n);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(final String source, final double value,
final ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
final int n = sb.length();
final int startIndex = pos.getIndex();
final int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = Double.valueOf(value);
pos.setIndex(endIndex);
return ret;
protected Number parseNumber(final String source, final NumberFormat format,
final ParsePosition pos) {
final int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
final int endIndex = pos.getIndex();
if (startIndex == endIndex) {
final double[] special = {
Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
protected boolean parseFixedstring(final String source, final String expected,
final ParsePosition pos) {
final int startIndex = pos.getIndex();
final int endIndex = startIndex + expected.length();
if ((startIndex >= source.length()) ||
(endIndex > source.length()) ||
(source.substring(startIndex, endIndex).compareTo(expected) != 0)) {
pos.setIndex(startIndex);
pos.setErrorIndex(startIndex);
return false;
pos.setIndex(endIndex);
return true;
protected StringBuffer formatDouble(final double value, final NumberFormat format,
final StringBuffer toAppendTo,
final FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
} else {
format.format(value, toAppendTo, pos);
return toAppendTo;
new Object[] { Double.valueOf(x) });
new Object[] { Double.valueOf(x) });
return Double.valueOf(o.toString()).doubleValue();
private static final long serialVersionUID = 4605318041528645258L;
private Map<Class<?>, NumberTransformer> map = null;
map = new HashMap<Class<?>, NumberTransformer>();
public boolean containsClass(Class<?> key) {
public NumberTransformer getTransformer(Class<?> key) {
public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {
public NumberTransformer removeTransformer(Class<?> key) {
public Set<Class<?>> classes() {
public Collection<NumberTransformer> transformers() {
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(newA);
return Double.valueOf(new double[] { 0.0 });
return Double.valueOf(newA);
return Double.valueOf();
return Double.valueOf(newA);
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Double.valueOf(0.0) };
Object[] arguments = { Double.valueOf(0.0) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };
new Object[] { Double.valueOf(1234567) });
CompositeFormat complexFormat = null;
CompositeFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = Double.valueOf(Math.PI);
CompositeFormat cf = new ComplexFormat();
assertEquals(w.getReal(), 4.0, 0);
assertTrue(Double.isNaN(w.getImaginary()));
assertEquals(w.getImaginary(), 1, 0);
assertEquals(inf, w.getReal(), 0);
assertTrue(Double.isNaN(x.add(z).getReal()));
assertEquals(neginf, z.conjugate().getImaginary(), 0);
assertEquals(inf, z.conjugate().getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(inf, z.getReal(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertEquals(inf, z.getImaginary(), 0);
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertTrue(Double.isNaN(z.getReal()));
assertTrue(Double.isNaN(z.getImaginary()));
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertEquals(w.getReal(), inf, 0);
assertEquals(w.getImaginary(), inf, 0);
assertTrue(Double.isNaN(w.getReal()));
assertTrue(Double.isNaN(w.getImaginary()));  
public void testMath221() {
assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));
return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));
package org.apache.commons.math.distribution;
public class BetaDistributionTest extends TestCase {
public void testCumulative() throws MathException {
double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};
checkCumulative(0.1, 0.1,
x, new double[]{
0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,
0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,
0.5936149061, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 0.5,
x, new double[]{
0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,
0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,
0.9423662883, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 1.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,
0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,
0.9895192582, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 2.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,
0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,
0.9994144508, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 4.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,
0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,
0.9999967829, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 0.1,
x, new double[]{
0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,
0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,
0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});
checkCumulative(0.5, 0.5,
x, new double[]{
0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,
0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,
0.7951672353, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 1.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,
0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,
0.9486832981, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 2.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,
0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,
0.9961174630, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 4.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,
0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,
0.9999714889, 1.0000000000, 1.0000000000});
checkCumulative(1.0, 0.1,
x, new double[]{
0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,
0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,
0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});
checkCumulative(1.0, 0.5,
x, new double[]{
0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,
0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,
0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});
checkCumulative(1, 1,
x, new double[]{
0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});
checkCumulative(1, 2,
x, new double[]{
0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});
checkCumulative(1, 4,
x, new double[]{
0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,
0.9984, 0.9999, 1.0000, 1.0000});
checkCumulative(2.0, 0.1,
x, new double[]{
0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,
0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,
0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});
checkCumulative(2, 1,
x, new double[]{
0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});
checkCumulative(2.0, 0.5,
x, new double[]{
0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,
0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,
0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});
checkCumulative(2, 2,
x, new double[]{
0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});
checkCumulative(2, 4,
x, new double[]{
0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,
0.96922, 0.99328, 0.99954, 1.00000, 1.00000});
checkCumulative(4.0, 0.1,
x, new double[]{
0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,
3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,
1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});
checkCumulative(4.0, 0.5,
x, new double[]{
0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,
2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,
1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});
checkCumulative(4, 1,
x, new double[]{
0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,
0.4096, 0.6561, 1.0000, 1.0000});
checkCumulative(4, 2,
x, new double[]{
0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,
0.52822, 0.73728, 0.91854, 1.00000, 1.00000});
checkCumulative(4, 4,
x, new double[]{
0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,
0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});
private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {
BetaDistribution d = new BetaDistributionImpl(alpha, beta);
for (int i = 0; i < x.length; i++) {
assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);
for (int i = 1; i < x.length - 1; i++) {
assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);
public void testDensity() throws MathException {
double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};
checkDensity(0.1, 0.1,
x, new double[]{
12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,
1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,
2.639396531e-01, 4.429925026e-01});
checkDensity(0.1, 0.5,
x, new double[]{
2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,
2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,
2.414013907e-01, 3.070567405e-01});
checkDensity(0.1, 1.0,
x, new double[]{
2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,
2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,
1.222414585e-01, 1.099464743e-01});
checkDensity(0.1, 2.0,
x, new double[]{
2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,
1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,
2.689298641e-02, 1.209399123e-02});
checkDensity(0.1, 4.0,
x, new double[]{
2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,
5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,
1.167143939e-03, 1.312171805e-04});
checkDensity(0.5, 0.1,
x, new double[]{
88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,
0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,
0.4203052841, 0.7394649088});
checkDensity(0.5, 0.5,
x, new double[]{
318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,
0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,
0.7957762075, 1.0610376697});
checkDensity(0.5, 1.0,
x, new double[]{
500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,
0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,
0.5590166450, 0.5270459839});
checkDensity(0.5, 2.0,
x, new double[]{
749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,
0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,
0.16770415497, 0.07905610701});
checkDensity(0.5, 4.0,
x, new double[]{
1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,
3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,
9.782644546e-03, 1.152878503e-03});
checkDensity(1.0, 0.1,
x, new double[]{
0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,
0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,
0.7943353837});
checkDensity(1.0, 0.5,
x, new double[]{
0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,
0.7071074883, 0.7905704033, 0.9128724506,
1.1180367838, 1.5811467358});
checkDensity(1, 1,
x, new double[]{
1, 1, 1,
1, 1, 1, 1,
1, 1, 1});
checkDensity(1, 2,
x, new double[]{
1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,
0.599998, 0.399998,
0.199998});
checkDensity(1, 4,
x, new double[]{
3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,
0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,
0.031999520002, 0.003999880001});
checkDensity(2.0, 0.1,
x, new double[]{
1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,
6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,
3.745917198e-01, 7.863929037e-01});
checkDensity(2.0, 0.5,
x, new double[]{
7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,
3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,
1.341645818e+00, 2.134537420613655});
checkDensity(2, 1,
x, new double[]{
0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,
1.400002, 1.600002,
1.800002});
checkDensity(2, 2,
x, new double[]{
5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,
1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,
9.5999640e-01, 5.3999520e-01});
checkDensity(2, 4,
x, new double[]{
0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,
1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,
0.12799824001, 0.01799948000});
checkDensity(4.0, 0.1,
x, new double[]{
1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,
1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,
2.601171405e-01, 6.911229392e-01});
checkDensity(4.0, 0.5,
x, new double[]{
1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,
9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,
1.252205894e+00, 2.52142232809988});
checkDensity(4, 1,
x, new double[]{
4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,
2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,
2.048007680e+00, 2.916009720e+00});
checkDensity(4, 2,
x, new double[]{
1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,
7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,
2.047997440e+00, 1.457990280e+00});
checkDensity(4, 4,
x, new double[]{
1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,
1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,
5.734335488e-01, 1.020572784e-01});
private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {
BetaDistribution d = new BetaDistributionImpl(alpha, beta);
for (int i = 0; i < x.length; i++) {
assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);
public void testDensity() {
double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};
checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});
checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});
checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});
checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});
private void checkDensity(double df, double[] x, double[] expected) {
ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);
for (int i = 0; i < x.length; i++) {
assertEquals(expected[i], d.density(x[i]), 1e-5);
public void testDensity() throws MathException {
ExponentialDistribution d1 = new ExponentialDistributionImpl(1);
assertEquals(0.0, d1.density(-1e-9));
assertEquals(1.0, d1.density(0.0));
assertEquals(0.0, d1.density(1000.0));
assertEquals(Math.exp(-1), d1.density(1.0));
assertEquals(Math.exp(-2), d1.density(2.0));
ExponentialDistribution d2 = new ExponentialDistributionImpl(3);
assertEquals(1/3.0, d2.density(0.0));
assertEquals(0.2388437702, d2.density(1.0), 1e-8);
assertEquals(0.1711390397, d2.density(2.0), 1e-8);
0.990d, 0.975d, 0.950d, 0.900d};
public void testDensity() {
double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};
checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});
checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});
checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});
checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});
checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});
checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});
checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});
checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});
private void checkDensity(double alpha, double rate, double[] x, double[] expected) {
GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);
for (int i = 0; i < x.length; i++) {
assertEquals(expected[i], d.density(x[i]), 1e-5);
public void testDensity() {
double [] x = new double[]{-2, -1, 0, 1, 2};
checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});
checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});
private void checkDensity(double mean, double sd, double[] x, double[] expected) {
NormalDistribution d = new NormalDistributionImpl(mean, sd);
for (int i = 0; i < x.length; i++) {
assertEquals(expected[i], d.density(x[i]), 1e-9);
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
for (EstimatedParameter p : set) {
addParameter(p);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();
set.add(parameters[j]);
points  = new ArrayList<PointModel>();
for (PointModel point : points) {
dRdX += point.getPartialDiX();
for (PointModel point : points) {
dRdY += point.getPartialDiY();
for (PointModel point : points) {
r += point.getCenterDistance();
private ArrayList<PointModel> points;
private static class QuadraticProblem extends SimpleEstimationProblem {
assertFalse(zero.equals(Double.valueOf(0)));
package org.apache.commons.math.geometry;
public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
Rotation r = Rotation.IDENTITY;
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);
r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);
r = new Rotation(Vector3D.PLUS_J, Math.PI);
checkVector(r.getAxis(), Vector3D.PLUS_J);
checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);
new Rotation(u, Vector3D.ZERO);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);
if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {
checkVector(axis, Vector3D.PLUS_K);
checkVector(axis, Vector3D.MINUS_K);
r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,
new Rotation(u1, u2, Vector3D.ZERO, v2);
checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);
checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);
checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);
checkVector(r.applyTo(Vector3D.PLUS_I),
checkVector(r.applyTo(Vector3D.PLUS_J),
checkVector(r.applyTo(Vector3D.PLUS_K),
r = Rotation.IDENTITY;
r = new Rotation(Vector3D.PLUS_K, Math.PI);
assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);
assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);
package org.apache.commons.math.geometry;
public abstract class Vector3DFormatAbstractTest extends TestCase {
Vector3DFormat vector3DFormat = null;
Vector3DFormat vector3DFormatSquare = null;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
vector3DFormat = Vector3DFormat.getInstance(getLocale());
final NumberFormat nf = NumberFormat.getInstance(getLocale());
nf.setMaximumFractionDigits(2);
vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf);
public void testSimpleNoDecimals() {
Vector3D c = new Vector3D(1, 1, 1);
String expected = "{1; 1; 1}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
Vector3D c = new Vector3D(1.23, 1.43, 1.63);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeX() {
Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);
String expected =
"{-1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeY() {
Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; -1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeZ() {
Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; -1" + getDecimalCharacter() +
"63}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testNonDefaultSetting() {
Vector3D c = new Vector3D(1, 1, 1);
String expected = "[1 : 1 : 1]";
String actual = vector3DFormatSquare.format(c); 
assertEquals(expected, actual);
public void testStaticFormatVector3D() {
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
Vector3D c = new Vector3D(232.222, -342.33, 432.444);
String expected =
"{232"    + getDecimalCharacter() +
"22; -342" + getDecimalCharacter() +
"33; 432" + getDecimalCharacter() +
"44}";
String actual = Vector3DFormat.formatVector3D(c); 
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
Vector3D c = Vector3D.NaN;
String expected = "{(NaN); (NaN); (NaN)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testPositiveInfinity() {
Vector3D c = Vector3D.POSITIVE_INFINITY;
String expected = "{(Infinity); (Infinity); (Infinity)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void tesNegativeInfinity() {
Vector3D c = Vector3D.NEGATIVE_INFINITY;
String expected = "{(-Infinity); (-Infinity); (-Infinity)}";
String actual = vector3DFormat.format(c); 
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
String source = "{1; 1; 1}";
Vector3D expected = new Vector3D(1, 1, 1);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseIgnoredWhitespace() {
Vector3D expected = new Vector3D(1, 1, 1);
ParsePosition pos1 = new ParsePosition(0);
String source1 = "{1;1;1}";
assertEquals(expected, vector3DFormat.parseObject(source1, pos1));
assertEquals(source1.length(), pos1.getIndex());
ParsePosition pos2 = new ParsePosition(0);
String source2 = " { 1 ; 1 ; 1 } ";
assertEquals(expected, vector3DFormat.parseObject(source2, pos2));
assertEquals(source2.length() - 1, pos2.getIndex());
public void testParseSimpleWithDecimals() {
String source =
"{1" + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
Vector3D expected = new Vector3D(1.23, 1.43, 1.63);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeX() {
String source =
"{-1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeY() {
String source =
"{1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeZ() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeAll() {
String source =
"{-1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseZeroX() {
String source =
"{0" + getDecimalCharacter() +
"0; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNonDefaultSetting() {
String source =
"[1" + getDecimalCharacter() +
"2323 : 1" + getDecimalCharacter() +
"4343 : 1" + getDecimalCharacter() +
"6333]";
Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);
Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNan() {
String source = "{(NaN); (NaN); (NaN)}";
Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); 
assertEquals(Vector3D.NaN, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
String source = "{(Infinity); (Infinity); (Infinity)}";
Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); 
assertEquals(Vector3D.POSITIVE_INFINITY, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeInfinity() {
String source = "{(-Infinity); (-Infinity); (-Infinity)}";
Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); 
assertEquals(Vector3D.NEGATIVE_INFINITY, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
Vector3DFormat cf = new Vector3DFormat(nf);
assertNotNull(cf);
assertEquals(nf, cf.getFormat());
public void testFormatObject() {
CompositeFormat cf = new Vector3DFormat();
Object object = new Object();
cf.format(object);
fail();
} catch (IllegalArgumentException ex) {
public void testForgottenPrefix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("1; 1; 1}", pos));
assertEquals(0, pos.getErrorIndex());
public void testForgottenSeparator() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("{1; 1 1}", pos));
assertEquals(6, pos.getErrorIndex());
public void testForgottenSuffix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos));
assertEquals(8, pos.getErrorIndex());
package org.apache.commons.math.geometry;
public class Vector3DFormatTest extends Vector3DFormatAbstractTest {
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
checkVector(new Vector3D(2, Vector3D.PLUS_I,
-3, Vector3D.MINUS_K),
checkVector(new Vector3D(2, Vector3D.PLUS_I,
5, Vector3D.PLUS_J,
-3, Vector3D.MINUS_K),
checkVector(new Vector3D(2, Vector3D.PLUS_I,
5, Vector3D.PLUS_J,
5, Vector3D.MINUS_J,
-3, Vector3D.MINUS_K),
assertTrue(Math.abs(Vector3D.ZERO.getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);
Vector3D.ZERO.normalize();
Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);
package org.apache.commons.math.linear;
public class BiDiagonalTransformerTest extends TestCase {
private double[][] testSquare = {
{ 24.0 / 25.0, 43.0 / 25.0 },
{ 57.0 / 25.0, 24.0 / 25.0 }
};
private double[][] testNonSquare = {
{  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },
{ -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },
{  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },
{  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },
};
public BiDiagonalTransformerTest(String name) {
super(name);
public void testDimensions() {
checkdimensions(new RealMatrixImpl(testSquare, false));
checkdimensions(new RealMatrixImpl(testNonSquare, false));
checkdimensions(new RealMatrixImpl(testNonSquare, false).transpose());
private void checkdimensions(RealMatrix matrix) {
final int m = matrix.getRowDimension();
final int n = matrix.getColumnDimension();
BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);
assertEquals(m, transformer.getU().getRowDimension());
assertEquals(m, transformer.getU().getColumnDimension());
assertEquals(m, transformer.getB().getRowDimension());
assertEquals(n, transformer.getB().getColumnDimension());
assertEquals(n, transformer.getV().getRowDimension());
assertEquals(n, transformer.getV().getColumnDimension());
public void testAEqualUSVt() {
checkAEqualUSVt(new RealMatrixImpl(testSquare, false));
checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));
checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());
private void checkAEqualUSVt(RealMatrix matrix) {
BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);
RealMatrix u = transformer.getU();
RealMatrix b = transformer.getB();
RealMatrix v = transformer.getV();
double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();
assertEquals(0, norm, 1.0e-14);
public void testUOrthogonal() {
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getU());
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getU());
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getU());
public void testVOrthogonal() {
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getV());
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getV());
checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getV());
private void checkOrthogonal(RealMatrix m) {
RealMatrix mTm = m.transpose().multiply(m);
RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());
assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);        
public void testBBiDiagonal() {
checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getB());
checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getB());
checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getB());
private void checkBiDiagonal(RealMatrix m) {
final int rows = m.getRowDimension();
final int cols = m.getColumnDimension();
for (int i = 0; i < rows; ++i) {
for (int j = 0; j < cols; ++j) {
if (rows < cols) {
if ((i < j) || (i > j + 1)) {
assertEquals(0, m.getEntry(i, j), 1.0e-16);
}                    
} else {
if ((i < j - 1) || (i > j)) {
assertEquals(0, m.getEntry(i, j), 1.0e-16);
public void testMatricesValues() {
BiDiagonalTransformer transformer =
new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false));
final double s17 = Math.sqrt(17.0);
RealMatrix uRef = new RealMatrixImpl(new double[][] {
{  -8 / (5 * s17), 19 / (5 * s17) },
{ -19 / (5 * s17), -8 / (5 * s17) }
});
RealMatrix bRef = new RealMatrixImpl(new double[][] {
{ -3 * s17 / 5, 32 * s17 / 85 },
{      0.0,     -5 * s17 / 17 }
});
RealMatrix vRef = new RealMatrixImpl(new double[][] {
{ 1.0,  0.0 },
{ 0.0, -1.0 }
});
RealMatrix u = transformer.getU();
assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);
RealMatrix b = transformer.getB();
assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);
RealMatrix v = transformer.getV();
assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);
assertTrue(u == transformer.getU());
assertTrue(b == transformer.getB());
assertTrue(v == transformer.getV());
public void testUpperOrLower() {
assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).isUpperBiDiagonal());
assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).isUpperBiDiagonal());
assertFalse(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).isUpperBiDiagonal());
public static Test suite() {
return new TestSuite(BiDiagonalTransformerTest.class);
BigMatrixImpl m1 = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());
assertEquals(m2,m1);
BigMatrixImpl m3 = new BigMatrixImpl(testData);
BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);
assertEquals(m4,m3);
BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);
BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);
assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE);
assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE);
BigMatrix mPlusMInv = m.add(mInv);
public void testMath209() {
BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {
{ new BigDecimal(1), new BigDecimal(2) },
{ new BigDecimal(3), new BigDecimal(4) },
{ new BigDecimal(5), new BigDecimal(6) }
}, false);
BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);
assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);
assertEquals(11.0, b[2].doubleValue(), 1.0e-12);
package org.apache.commons.math.linear;
public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {
protected char getDecimalCharacter() {
return ',';
protected Locale getLocale() {
return Locale.FRENCH;
package org.apache.commons.math.linear;
public class LUDecompositionImplTest extends TestCase {
private double[][] testData = {
{ 1.0, 2.0, 3.0},
{ 2.0, 5.0, 3.0},
{ 1.0, 0.0, 8.0}
};
private double[][] testDataMinus = {
{ -1.0, -2.0, -3.0},
{ -2.0, -5.0, -3.0},
{ -1.0,  0.0, -8.0}
};
private double[][] luData = {
{ 2.0, 3.0, 3.0 },
{ 0.0, 5.0, 7.0 },
{ 6.0, 9.0, 8.0 }
};
private double[][] singular = {
{ 2.0, 3.0 },
{ 2.0, 3.0 }
};
private double[][] bigSingular = {
{ 1.0, 2.0,   3.0,    4.0 },
{ 2.0, 5.0,   3.0,    4.0 },
{ 7.0, 3.0, 256.0, 1930.0 },
{ 3.0, 7.0,   6.0,    8.0 }
}; // 4th row = 1st + 2nd
private static final double entryTolerance = 10e-16;
private static final double normTolerance = 10e-14;
public LUDecompositionImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(LUDecompositionImplTest.class);
suite.setName("LUDecompositionImpl Tests");
return suite;
public void testDimensions() {
RealMatrixImpl matrix = new RealMatrixImpl(testData, false);
LUDecomposition LU = new LUDecompositionImpl(matrix);
assertEquals(testData.length, LU.getL().getRowDimension());
assertEquals(testData.length, LU.getL().getColumnDimension());
assertEquals(testData.length, LU.getU().getRowDimension());
assertEquals(testData.length, LU.getU().getColumnDimension());
assertEquals(testData.length, LU.getP().getRowDimension());
assertEquals(testData.length, LU.getP().getColumnDimension());
public void testNonSquare() {
new LUDecompositionImpl(new RealMatrixImpl(new double[3][2], false));
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
public void testNoDecompose() {
new LUDecompositionImpl().getPivot();
fail("an exception should have been caught");
} catch (IllegalStateException ise) {
} catch (Exception e) {
fail("wrong exception caught");
public void testThreshold() {
final RealMatrix matrix = new RealMatrixImpl(new double[][] {
{ 1.0, 2.0, 3.0},
{ 2.0, 5.0, 3.0},
{ 4.000001, 9.0, 9.0}
}, false);
assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).isNonSingular());
assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).isNonSingular());
public void testPAEqualLU() {
RealMatrix matrix = new RealMatrixImpl(testData, false);
LUDecomposition lu = new LUDecompositionImpl(matrix);
RealMatrix l = lu.getL();
RealMatrix u = lu.getU();
RealMatrix p = lu.getP();
double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();
assertEquals(0, norm, normTolerance);
matrix = new RealMatrixImpl(testDataMinus, false);
lu = new LUDecompositionImpl(matrix);
l = lu.getL();
u = lu.getU();
p = lu.getP();
norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();
assertEquals(0, norm, normTolerance);
matrix = MatrixUtils.createRealIdentityMatrix(17);
lu = new LUDecompositionImpl(matrix);
l = lu.getL();
u = lu.getU();
p = lu.getP();
norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();
assertEquals(0, norm, normTolerance);
matrix = new RealMatrixImpl(singular, false);
lu = new LUDecompositionImpl(matrix);
assertFalse(lu.isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
matrix = new RealMatrixImpl(bigSingular, false);
lu = new LUDecompositionImpl(matrix);
assertFalse(lu.isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
public void testLLowerTriangular() {
RealMatrixImpl matrix = new RealMatrixImpl(testData, false);
RealMatrix l = new LUDecompositionImpl(matrix).getL();
for (int i = 0; i < l.getRowDimension(); i++) {
assertEquals(l.getEntry(i, i), 1, entryTolerance);
for (int j = i + 1; j < l.getColumnDimension(); j++) {
assertEquals(l.getEntry(i, j), 0, entryTolerance);
public void testUUpperTriangular() {
RealMatrixImpl matrix = new RealMatrixImpl(testData, false);
RealMatrix u = new LUDecompositionImpl(matrix).getU();
for (int i = 0; i < u.getRowDimension(); i++) {
for (int j = 0; j < i; j++) {
assertEquals(u.getEntry(i, j), 0, entryTolerance);
public void testPPermutation() {
RealMatrixImpl matrix = new RealMatrixImpl(testData, false);
RealMatrix p   = new LUDecompositionImpl(matrix).getP();
RealMatrix ppT = p.multiply(p.transpose());
RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());
assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);
for (int i = 0; i < p.getRowDimension(); i++) {
int zeroCount  = 0;
int oneCount   = 0;
int otherCount = 0;
for (int j = 0; j < p.getColumnDimension(); j++) {
final double e = p.getEntry(i, j);
if (e == 0) {
++zeroCount;
} else if (e == 1) {
++oneCount;
} else {
++otherCount;
assertEquals(p.getColumnDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
for (int j = 0; j < p.getColumnDimension(); j++) {
int zeroCount  = 0;
int oneCount   = 0;
int otherCount = 0;
for (int i = 0; i < p.getRowDimension(); i++) {
final double e = p.getEntry(i, j);
if (e == 0) {
++zeroCount;
} else if (e == 1) {
++oneCount;
} else {
++otherCount;
assertEquals(p.getRowDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
public void testSingular() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(testData, false));
assertTrue(lu.isNonSingular());
lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false));
assertFalse(lu.isNonSingular());
lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false));
assertFalse(lu.isNonSingular());
public void testSolveDimensionErrors() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(testData, false));
RealMatrix b = new RealMatrixImpl(new double[2][2]);
lu.solve(b);
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
lu.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolveSingularityErrors() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(singular, false));
RealMatrix b = new RealMatrixImpl(new double[2][2]);
lu.solve(b);
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
lu.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
lu.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolve() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(testData, false));
RealMatrix b = new RealMatrixImpl(new double[][] {
{ 1, 0 }, { 2, -5 }, { 3, 1 }
});
RealMatrix xRef = new RealMatrixImpl(new double[][] {
{ 19, -71 }, { -6, 22 }, { -2, 9 }
});
assertEquals(0, lu.solve(b).subtract(xRef).getNorm(), 1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
new RealVectorImpl(lu.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
lu.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
RealVectorImplTest.RealVectorTestImpl v =
new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));
assertEquals(0,
lu.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
public void testMatricesValues1() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(testData, false));
RealMatrix lRef = new RealMatrixImpl(new double[][] {
{ 1.0, 0.0, 0.0 },
{ 0.5, 1.0, 0.0 },
{ 0.5, 0.2, 1.0 }
});
RealMatrix uRef = new RealMatrixImpl(new double[][] {
{ 2.0,  5.0, 3.0 },
{ 0.0, -2.5, 6.5 },
{ 0.0,  0.0, 0.2 }
});
RealMatrix pRef = new RealMatrixImpl(new double[][] {
{ 0.0, 1.0, 0.0 },
{ 0.0, 0.0, 1.0 },
{ 1.0, 0.0, 0.0 }
});
int[] pivotRef = { 1, 2, 0 };
RealMatrix l = lu.getL();
assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);
RealMatrix u = lu.getU();
assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);
RealMatrix p = lu.getP();
assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);
int[] pivot = lu.getPivot();
for (int i = 0; i < pivotRef.length; ++i) {
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
public void testMatricesValues2() {
LUDecomposition lu =
new LUDecompositionImpl(new RealMatrixImpl(luData, false));
RealMatrix lRef = new RealMatrixImpl(new double[][] {
{    1.0,    0.0, 0.0 },
{    0.0,    1.0, 0.0 },
{ 1.0 / 3.0, 0.0, 1.0 }
});
RealMatrix uRef = new RealMatrixImpl(new double[][] {
{ 6.0, 9.0,    8.0    },
{ 0.0, 5.0,    7.0    },
{ 0.0, 0.0, 1.0 / 3.0 }
});
RealMatrix pRef = new RealMatrixImpl(new double[][] {
{ 0.0, 0.0, 1.0 },
{ 0.0, 1.0, 0.0 },
{ 1.0, 0.0, 0.0 }
});
int[] pivotRef = { 2, 1, 0 };
RealMatrix l = lu.getL();
assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);
RealMatrix u = lu.getU();
assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);
RealMatrix p = lu.getP();
assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);
int[] pivot = lu.getPivot();
for (int i = 0; i < pivotRef.length; ++i) {
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
public void testDeterminant() {
assertEquals(-1,
new LUDecompositionImpl(new RealMatrixImpl(testData, false)).getDeterminant(),
1.0e-15);
assertEquals(-10,
new LUDecompositionImpl(new RealMatrixImpl(luData, false)).getDeterminant(),
1.0e-14);
assertEquals(0,
new LUDecompositionImpl(new RealMatrixImpl(singular, false)).getDeterminant(),
1.0e-17);
assertEquals(0,
new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)).getDeterminant(),
1.0e-17);
assertEquals(new RealMatrixImpl(testData, false), 
MatrixUtils.createRealMatrix(testData, true));
assertEquals(new RealMatrixImpl(testData, true), 
MatrixUtils.createRealMatrix(testData, false));
assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), 
MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));
assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), 
MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData4x3, false);
matrix = new RealMatrixImpl(testData3x4, false);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
matrix = new RealMatrixImpl(testData3x3Singular, false);
matrix = new RealMatrixImpl(testData3x4, false);
matrix = new RealMatrixImpl(testData4x3, false);
R = new QRDecompositionImpl(matrix).getR();
for (int i = 0; i < R.getRowDimension(); i++)
for (int j = 0; j < i; j++)
assertEquals("R lower triangle", R.getEntry(i, j), 0,
entryTolerance);
public void testHTrapezoidal() {
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);
RealMatrix H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData3x3Singular, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData3x4, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
matrix = new RealMatrixImpl(testData4x3, false);
H = new QRDecompositionImpl(matrix).getH();
for (int i = 0; i < H.getRowDimension(); i++)
for (int j = i + 1; j < H.getColumnDimension(); j++)
assertEquals(H.getEntry(i, j), 0, entryTolerance);
public void testRank() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
assertTrue(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));
assertFalse(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false));
assertFalse(qr.isFullRank());
qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false));
assertTrue(qr.isFullRank());
public void testSolveDimensionErrors() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix b = new RealMatrixImpl(new double[2][2]);
qr.solve(b);
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (IllegalArgumentException iae) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolveRankErrors() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));
RealMatrix b = new RealMatrixImpl(new double[3][2]);
qr.solve(b);
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
qr.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException iae) {
} catch (Exception e) {
fail("wrong exception caught");
public void testSolve() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix b = new RealMatrixImpl(new double[][] {
{ -102, 12250 }, { 544, 24500 }, { 167, -36750 }
});
RealMatrix xRef = new RealMatrixImpl(new double[][] {
{ 1, 2515 }, { 2, 422 }, { -3, 898 }
});
assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
assertEquals(0,
qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
for (int i = 0; i < b.getColumnDimension(); ++i) {
RealVectorImplTest.RealVectorTestImpl v =
new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));
assertEquals(0,
qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),
1.0e-13);
public void testMatricesValues() {
QRDecomposition qr =
new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));
RealMatrix qRef = new RealMatrixImpl(new double[][] {
{ -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },
{  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },
{   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }
});
RealMatrix rRef = new RealMatrixImpl(new double[][] {
{ -14.0,  -21.0, 14.0 },
{   0.0, -175.0, 70.0 },
{   0.0,    0.0, 35.0 }
});
RealMatrix hRef = new RealMatrixImpl(new double[][] {
{ 26.0 / 14.0, 0.0, 0.0 },
{  6.0 / 14.0, 648.0 / 325.0, 0.0 },
{ -4.0 / 14.0,  36.0 / 325.0, 2.0 }
});
RealMatrix q = qr.getQ();
assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);
RealMatrix r = qr.getR();
assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);
RealMatrix h = qr.getH();
assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);
assertTrue(q == qr.getQ());
assertTrue(r == qr.getR());
assertTrue(h == qr.getH());
public void testNoDecompose() {
new QRDecompositionImpl().isFullRank();
fail("an exception should have been caught");
} catch (IllegalStateException ise) {
} catch (Exception e) {
fail("wrong exception caught");
RealMatrixImpl m1 = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());
assertEquals(m2,m1);
RealMatrixImpl m3 = new RealMatrixImpl(testData);
RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);
assertEquals(m4,m3);
RealMatrix mPlusMInv = m.add(mInv);
assertClose("inverse-operate", mInv.operate(testVector),
m.solve(testVector), normTolerance);
assertClose("inverse-operate", mInv.operate(testVector),
m.solve(new RealVectorImpl(testVector)).getData(), normTolerance);
assertClose("identity operate", testVector,
m.operate(testVector), entryTolerance);
assertClose("identity operate", testVector,
m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);
public void testMath209() {
RealMatrix a = new RealMatrixImpl(new double[][] {
{ 1, 2 }, { 3, 4 }, { 5, 6 }
}, false);
double[] b = a.operate(new double[] { 1, 1 });
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0], 1.0e-12);
assertEquals( 7.0, b[1], 1.0e-12);
assertEquals(11.0, b[2], 1.0e-12);
assertClose("premultiply", m.preMultiply(testVector),
preMultTest, normTolerance);
assertClose("premultiply", m.preMultiply(new RealVectorImpl(testVector).getData()),
preMultTest, normTolerance);
public void testGetRowVector() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealVector mRow0 = new RealVectorImpl(subRow0[0]);
RealVector mRow3 = new RealVectorImpl(subRow3[0]);
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
m.getRowVector(-1);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
m.getRowVector(4);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
public void testGetColumnVector() {
RealMatrix m = new RealMatrixImpl(subTestData);
RealVector mColumn1 = columnToVector(subColumn1);
RealVector mColumn3 = columnToVector(subColumn3);
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
m.getColumnVector(-1);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
m.getColumnVector(4);
fail("Expecting MatrixIndexException");
} catch (MatrixIndexException ex) {
private RealVector columnToVector(double[][] column) {
double[] data = new double[column.length];
for (int i = 0; i < data.length; ++i) {
data[i] = column[i][0];
return new RealVectorImpl(data, false);
package org.apache.commons.math.linear;
public abstract class RealVectorFormatAbstractTest extends TestCase {
RealVectorFormat realVectorFormat = null;
RealVectorFormat realVectorFormatSquare = null;
protected abstract Locale getLocale();
protected abstract char getDecimalCharacter();
protected void setUp() throws Exception {
realVectorFormat = RealVectorFormat.getInstance(getLocale());
final NumberFormat nf = NumberFormat.getInstance(getLocale());
nf.setMaximumFractionDigits(2);
realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);
public void testSimpleNoDecimals() {
RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});
String expected = "{1; 1; 1}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimals() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testSimpleWithDecimalsTrunc() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeX() {
RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});
String expected =
"{-1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeY() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; -1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNegativeZ() {
RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});
String expected =
"{1"    + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; -1" + getDecimalCharacter() +
"63}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testNonDefaultSetting() {
RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});
String expected = "[1 : 1 : 1]";
String actual = realVectorFormatSquare.format(c); 
assertEquals(expected, actual);
public void testStaticFormatRealVectorImpl() {
Locale defaultLocal = Locale.getDefault();
Locale.setDefault(getLocale());
RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444});
String expected =
"{232"    + getDecimalCharacter() +
"22; -342" + getDecimalCharacter() +
"33; 432" + getDecimalCharacter() +
"44}";
String actual = RealVectorFormat.formatRealVector(c); 
assertEquals(expected, actual);
Locale.setDefault(defaultLocal);
public void testNan() {
RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN});
String expected = "{(NaN); (NaN); (NaN)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testPositiveInfinity() {
RealVectorImpl c = new RealVectorImpl(new double[] {
Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
});
String expected = "{(Infinity); (Infinity); (Infinity)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void tesNegativeInfinity() {
RealVectorImpl c = new RealVectorImpl(new double[] {
Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY
});
String expected = "{(-Infinity); (-Infinity); (-Infinity)}";
String actual = realVectorFormat.format(c); 
assertEquals(expected, actual);
public void testParseSimpleNoDecimals() {
String source = "{1; 1; 1}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseIgnoredWhitespace() {
RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});
ParsePosition pos1 = new ParsePosition(0);
String source1 = "{1;1;1}";
assertEquals(expected, realVectorFormat.parseObject(source1, pos1));
assertEquals(source1.length(), pos1.getIndex());
ParsePosition pos2 = new ParsePosition(0);
String source2 = " { 1 ; 1 ; 1 } ";
assertEquals(expected, realVectorFormat.parseObject(source2, pos2));
assertEquals(source2.length() - 1, pos2.getIndex());
public void testParseSimpleWithDecimals() {
String source =
"{1" + getDecimalCharacter() +
"23; 1" + getDecimalCharacter() +
"43; 1" + getDecimalCharacter() +
"63}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseSimpleWithDecimalsTrunc() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeX() {
String source =
"{-1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeY() {
String source =
"{1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeZ() {
String source =
"{1" + getDecimalCharacter() +
"2323; 1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeAll() {
String source =
"{-1" + getDecimalCharacter() +
"2323; -1" + getDecimalCharacter() +
"4343; -1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseZeroX() {
String source =
"{0" + getDecimalCharacter() +
"0; -1" + getDecimalCharacter() +
"4343; 1" + getDecimalCharacter() +
"6333}";
RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNonDefaultSetting() {
String source =
"[1" + getDecimalCharacter() +
"2323 : 1" + getDecimalCharacter() +
"4343 : 1" + getDecimalCharacter() +
"6333]";
RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});
RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); 
assertEquals(expected, actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNan() {
String source = "{(NaN); (NaN); (NaN)}";
RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParsePositiveInfinity() {
String source = "{(Infinity); (Infinity); (Infinity)}";
RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {
Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY
}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNegativeInfinity() {
String source = "{(-Infinity); (-Infinity); (-Infinity)}";
RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); 
assertEquals(new RealVectorImpl(new double[] {
Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY
}), actual);
} catch (ParseException ex) {
fail(ex.getMessage());
public void testParseNoComponents() {
realVectorFormat.parseObject("{ }");
} catch (ParseException pe) {
} catch (Exception e) {
fail("wrong exception caught");
public void testParseManyComponents() throws ParseException {
RealVectorImpl parsed =
(RealVectorImpl) realVectorFormat.parseObject("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");
assertEquals(24, parsed.getDimension());
public void testConstructorSingleFormat() {
NumberFormat nf = NumberFormat.getInstance();
RealVectorFormat cf = new RealVectorFormat(nf);
assertNotNull(cf);
assertEquals(nf, cf.getFormat());
public void testFormatObject() {
CompositeFormat cf = new RealVectorFormat();
Object object = new Object();
cf.format(object);
fail();
} catch (IllegalArgumentException ex) {
public void testForgottenPrefix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("1; 1; 1}", pos));
assertEquals(0, pos.getErrorIndex());
public void testForgottenSeparator() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("{1; 1 1}", pos));
assertEquals(6, pos.getErrorIndex());
public void testForgottenSuffix() {
ParsePosition pos = new ParsePosition(0);
assertNull(new RealVectorFormat().parse("{1; 1; 1 ", pos));
assertEquals(8, pos.getErrorIndex());
package org.apache.commons.math.linear;
public class RealVectorFormatTest extends RealVectorFormatAbstractTest {
protected char getDecimalCharacter() {
return '.';
protected Locale getLocale() {
return Locale.US;
package org.apache.commons.math.linear;
public class RealVectorImplTest extends TestCase {
protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};
protected double[] vec1 = {1d, 2d, 3d};
protected double[] vec2 = {4d, 5d, 6d};
protected double[] vec3 = {7d, 8d, 9d};
protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};
protected double[] vec_null = {0d, 0d, 0d};
protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};
protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
public static class RealVectorTestImpl implements RealVector, Serializable {
private static final long serialVersionUID = 8731816072271374422L;
protected double data[];
public RealVectorTestImpl(double[] d) {
data = d.clone();
private UnsupportedOperationException unsupported() {
return new UnsupportedOperationException("Not supported, unneeded for test purposes");
public RealVector copy() {
throw unsupported();
public RealVector add(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector subtract(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector mapAdd(double d) {
throw unsupported();
public RealVector mapAddToSelf(double d) {
throw unsupported();
public RealVector mapSubtract(double d) {
throw unsupported();
public RealVector mapSubtractToSelf(double d) {
throw unsupported();
public RealVector mapMultiply(double d) {
double[] out = new double[data.length];
for (int i = 0; i < data.length; i++) {
out[i] = data[i] * d;
return new RealVectorImpl(out);
public RealVector mapMultiplyToSelf(double d) {
throw unsupported();
public RealVector mapDivide(double d) {
throw unsupported();
public RealVector mapDivideToSelf(double d) {
throw unsupported();
public RealVector mapPow(double d) {
throw unsupported();
public RealVector mapPowToSelf(double d) {
throw unsupported();
public RealVector mapExp() {
throw unsupported();
public RealVector mapExpToSelf() {
throw unsupported();
public RealVector mapExpm1() {
throw unsupported();
public RealVector mapExpm1ToSelf() {
throw unsupported();
public RealVector mapLog() {
throw unsupported();
public RealVector mapLogToSelf() {
throw unsupported();
public RealVector mapLog10() {
throw unsupported();
public RealVector mapLog10ToSelf() {
throw unsupported();
public RealVector mapLog1p() {
throw unsupported();
public RealVector mapLog1pToSelf() {
throw unsupported();
public RealVector mapCosh() {
throw unsupported();
public RealVector mapCoshToSelf() {
throw unsupported();
public RealVector mapSinh() {
throw unsupported();
public RealVector mapSinhToSelf() {
throw unsupported();
public RealVector mapTanh() {
throw unsupported();
public RealVector mapTanhToSelf() {
throw unsupported();
public RealVector mapCos() {
throw unsupported();
public RealVector mapCosToSelf() {
throw unsupported();
public RealVector mapSin() {
throw unsupported();
public RealVector mapSinToSelf() {
throw unsupported();
public RealVector mapTan() {
throw unsupported();
public RealVector mapTanToSelf() {
throw unsupported();
public RealVector mapAcos() {
throw unsupported();
public RealVector mapAcosToSelf() {
throw unsupported();
public RealVector mapAsin() {
throw unsupported();
public RealVector mapAsinToSelf() {
throw unsupported();
public RealVector mapAtan() {
throw unsupported();
public RealVector mapAtanToSelf() {
throw unsupported();
public RealVector mapInv() {
throw unsupported();
public RealVector mapInvToSelf() {
throw unsupported();
public RealVector mapAbs() {
throw unsupported();
public RealVector mapAbsToSelf() {
throw unsupported();
public RealVector mapSqrt() {
throw unsupported();
public RealVector mapSqrtToSelf() {
throw unsupported();
public RealVector mapCbrt() {
throw unsupported();
public RealVector mapCbrtToSelf() {
throw unsupported();
public RealVector mapCeil() {
throw unsupported();
public RealVector mapCeilToSelf() {
throw unsupported();
public RealVector mapFloor() {
throw unsupported();
public RealVector mapFloorToSelf() {
throw unsupported();
public RealVector mapRint() {
throw unsupported();
public RealVector mapRintToSelf() {
throw unsupported();
public RealVector mapSignum() {
throw unsupported();
public RealVector mapSignumToSelf() {
throw unsupported();
public RealVector mapUlp() {
throw unsupported();
public RealVector mapUlpToSelf() {
throw unsupported();
public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double[] getData() {
return data.clone();
public double dotProduct(RealVector v) throws IllegalArgumentException {
double dot = 0;
for (int i = 0; i < data.length; i++) {
dot += data[i] * v.getEntry(i);
return dot;
public double getNorm() {
throw unsupported();
public double getL1Norm() {
throw unsupported();
public double getLInfNorm() {
throw unsupported();
public double getDistance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getL1Distance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getLInfDistance(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealVector unitVector() {
throw unsupported();
public void unitize() {
throw unsupported();
public RealVector projection(RealVector v) throws IllegalArgumentException {
throw unsupported();
public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {
throw unsupported();
public double getEntry(int index) throws MatrixIndexException {
return data[index];
public int getDimension() {
return data.length;
public RealVector append(RealVector v) {
throw unsupported();
public RealVector append(double d) {
throw unsupported();
public RealVector append(double[] a) {
throw unsupported();
public RealVector get(int index, int n) throws MatrixIndexException {
throw unsupported();
public void set(int index, double value) throws MatrixIndexException {
throw unsupported();
public void set(int index, RealVector v) throws MatrixIndexException {
throw unsupported();
public void set(double value) {
throw unsupported();
public double[] toArray() {
throw unsupported();
public boolean isNaN() {
throw unsupported();
public boolean isInfinite() {
throw unsupported();
public static Test suite() {
TestSuite suite = new TestSuite(RealVectorImplTest.class);
suite.setName("RealVectorImpl Tests");
return suite;
public void testConstructors() {
RealVectorImpl v0 = new RealVectorImpl();
assertEquals("testData len", 0, v0.getDimension());
RealVectorImpl v1 = new RealVectorImpl(7);
assertEquals("testData len", 7, v1.getDimension());
assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));
RealVectorImpl v2 = new RealVectorImpl(5, 1.23);
assertEquals("testData len", 5, v2.getDimension());
assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4));
RealVectorImpl v3 = new RealVectorImpl(vec1);
assertEquals("testData len", 3, v3.getDimension());
assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));
RealVectorImpl v4 = new RealVectorImpl(vec4, 3, 2);
assertEquals("testData len", 2, v4.getDimension());
assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));
new RealVectorImpl(vec4, 8, 3);
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVector v5_i = new RealVectorImpl(dvec1);
assertEquals("testData len", 9, v5_i.getDimension());
assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));
RealVectorImpl v5 = new RealVectorImpl(dvec1);
assertEquals("testData len", 9, v5.getDimension());
assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));
RealVectorImpl v6 = new RealVectorImpl(dvec1, 3, 2);
assertEquals("testData len", 2, v6.getDimension());
assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0));
new RealVectorImpl(dvec1, 8, 3);
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v7 = new RealVectorImpl(v1);
assertEquals("testData len", 7, v7.getDimension());
assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));
RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);
RealVectorImpl v7_2 = new RealVectorImpl(v7_i);
assertEquals("testData len", 3, v7_2.getDimension());
assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));
RealVectorImpl v8 = new RealVectorImpl(v1, true);
assertEquals("testData len", 7, v8.getDimension());
assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));
assertNotSame("testData not same object ", v1.data, v8.data);
RealVectorImpl v8_2 = new RealVectorImpl(v1, false);
assertEquals("testData len", 7, v8_2.getDimension());
assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6));
assertEquals("testData same object ", v1.data, v8_2.data);
RealVectorImpl v9 = new RealVectorImpl(v1, v3);
assertEquals("testData len", 10, v9.getDimension());
assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7));
public void testDataInOut() {
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v2 = new RealVectorImpl(vec2);
RealVectorImpl v4 = new RealVectorImpl(vec4);
RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); 
RealVector v_append_1 = v1.append(v2);
assertEquals("testData len", 6, v_append_1.getDimension());
assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));
RealVector v_append_2 = v1.append(2.0);
assertEquals("testData len", 4, v_append_2.getDimension());
assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));
RealVector v_append_3 = v1.append(vec2);
assertEquals("testData len", 6, v_append_3.getDimension());
assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));
RealVector v_append_4 = v1.append(v2_t);
assertEquals("testData len", 6, v_append_4.getDimension());
assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));
RealVector v_copy = v1.copy();
assertEquals("testData len", 3, v_copy.getDimension());
assertNotSame("testData not same object ", v1.data, v_copy.getData());
double[] a_double = v1.toArray();
assertEquals("testData len", 3, a_double.length);
assertNotSame("testData not same object ", v1.data, a_double);
RealVector vout5 = v4.get(3, 3);
assertEquals("testData len", 3, vout5.getDimension());
assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));
v4.get(3, 7);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set1 = (RealVectorImpl) v1.copy();
v_set1.set(1, 11.0);
assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));
v_set1.set(3, 11.0);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set2 = (RealVectorImpl) v4.copy();
v_set2.set(3, v1);
assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));
assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));
v_set2.set(7, v1);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set3 = (RealVectorImpl) v1.copy();
v_set3.set(13.0);
assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));
v_set3.getEntry(23);
fail("ArrayIndexOutOfBoundsException expected");
} catch (ArrayIndexOutOfBoundsException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_set4 = (RealVectorImpl) v4.copy();
v_set4.set(3, v2_t);
assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));
assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));
v_set4.set(7, v2_t);
fail("MatrixIndexException expected");
} catch (MatrixIndexException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl vout10 = (RealVectorImpl) v1.copy();       
RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy();
assertEquals(vout10, vout10_2);
vout10_2.set(0, 1.1);
assertNotSame(vout10, vout10_2);
public void testMapFunctions() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVector v_mapAdd = v1.mapAdd(2.0d);
double[] result_mapAdd = {3d, 4d, 5d};
assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);
RealVector v_mapAddToSelf = v1.copy();
v_mapAddToSelf.mapAddToSelf(2.0d);
double[] result_mapAddToSelf = {3d, 4d, 5d};
assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);
RealVector v_mapSubtract = v1.mapSubtract(2.0d);
double[] result_mapSubtract = {-1d, 0d, 1d};
assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);
RealVector v_mapSubtractToSelf = v1.copy();
v_mapSubtractToSelf.mapSubtractToSelf(2.0d);
double[] result_mapSubtractToSelf = {-1d, 0d, 1d};
assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);
RealVector v_mapMultiply = v1.mapMultiply(2.0d);
double[] result_mapMultiply = {2d, 4d, 6d};
assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);
RealVector v_mapMultiplyToSelf = v1.copy();
v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);
double[] result_mapMultiplyToSelf = {2d, 4d, 6d};
assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);
RealVector v_mapDivide = v1.mapDivide(2.0d);
double[] result_mapDivide = {.5d, 1d, 1.5d};
assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);
RealVector v_mapDivideToSelf = v1.copy();
v_mapDivideToSelf.mapDivideToSelf(2.0d);
double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};
assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);
RealVector v_mapPow = v1.mapPow(2.0d);
double[] result_mapPow = {1d, 4d, 9d};
assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);
RealVector v_mapPowToSelf = v1.copy();
v_mapPowToSelf.mapPowToSelf(2.0d);
double[] result_mapPowToSelf = {1d, 4d, 9d};
assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);
RealVector v_mapExp = v1.mapExp();
double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};
assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);
RealVector v_mapExpToSelf = v1.copy();
v_mapExpToSelf.mapExpToSelf();
double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};
assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);
RealVector v_mapExpm1 = v1.mapExpm1();
double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};
assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);
RealVector v_mapExpm1ToSelf = v1.copy();
v_mapExpm1ToSelf.mapExpm1ToSelf();
double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};
assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);
RealVector v_mapLog = v1.mapLog();
double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};
assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);
RealVector v_mapLogToSelf = v1.copy();
v_mapLogToSelf.mapLogToSelf();
double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};
assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);
RealVector v_mapLog10 = v1.mapLog10();
double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};
assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);
RealVector v_mapLog10ToSelf = v1.copy();
v_mapLog10ToSelf.mapLog10ToSelf();
double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};
assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);
RealVector v_mapLog1p = v1.mapLog1p();
double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};
assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);
RealVector v_mapLog1pToSelf = v1.copy();
v_mapLog1pToSelf.mapLog1pToSelf();
double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};
assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);
RealVector v_mapCosh = v1.mapCosh();
double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};
assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);
RealVector v_mapCoshToSelf = v1.copy();
v_mapCoshToSelf.mapCoshToSelf();
double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};
assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);
RealVector v_mapSinh = v1.mapSinh();
double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};
assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);
RealVector v_mapSinhToSelf = v1.copy();
v_mapSinhToSelf.mapSinhToSelf();
double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};
assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);
RealVector v_mapTanh = v1.mapTanh();
double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};
assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);
RealVector v_mapTanhToSelf = v1.copy();
v_mapTanhToSelf.mapTanhToSelf();
double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};
assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);
RealVector v_mapCos = v1.mapCos();
double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};
assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);
RealVector v_mapCosToSelf = v1.copy();
v_mapCosToSelf.mapCosToSelf();
double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};
assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);
RealVector v_mapSin = v1.mapSin();
double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};
assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);
RealVector v_mapSinToSelf = v1.copy();
v_mapSinToSelf.mapSinToSelf();
double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};
assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);
RealVector v_mapTan = v1.mapTan();
double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};
assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);
RealVector v_mapTanToSelf = v1.copy();
v_mapTanToSelf.mapTanToSelf();
double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};
assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);
double[] vat_a = {0d, 0.5d, 1.0d};
RealVectorImpl vat = new RealVectorImpl(vat_a);
RealVector v_mapAcos = vat.mapAcos();
double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};
assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);
RealVector v_mapAcosToSelf = vat.copy();
v_mapAcosToSelf.mapAcosToSelf();
double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};
assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);
RealVector v_mapAsin = vat.mapAsin();
double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};
assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);
RealVector v_mapAsinToSelf = vat.copy();
v_mapAsinToSelf.mapAsinToSelf();        
double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};
assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);
RealVector v_mapAtan = vat.mapAtan();
double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};
assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);
RealVector v_mapAtanToSelf = vat.copy();
v_mapAtanToSelf.mapAtanToSelf();
double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};
assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);
RealVector v_mapInv = v1.mapInv();
double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};
assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);
RealVector v_mapInvToSelf = v1.copy();
v_mapInvToSelf.mapInvToSelf();
double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};
assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);
double[] abs_a = {-1.0d, 0.0d, 1.0d};
RealVectorImpl abs_v = new RealVectorImpl(abs_a);
RealVector v_mapAbs = abs_v.mapAbs();
double[] result_mapAbs = {1d,0d,1d};
assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);
RealVector v_mapAbsToSelf = abs_v.copy();
v_mapAbsToSelf.mapAbsToSelf();
double[] result_mapAbsToSelf = {1d,0d,1d};
assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);
RealVector v_mapSqrt = v1.mapSqrt();
double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};
assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);
RealVector v_mapSqrtToSelf = v1.copy();
v_mapSqrtToSelf.mapSqrtToSelf();
double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};
assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);
double[] cbrt_a = {-2.0d, 0.0d, 2.0d};
RealVectorImpl cbrt_v = new RealVectorImpl(cbrt_a);
RealVector v_mapCbrt = cbrt_v.mapCbrt();
double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};
assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);
RealVector v_mapCbrtToSelf = cbrt_v.copy();
v_mapCbrtToSelf.mapCbrtToSelf();
double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};
assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);
double[] ceil_a = {-1.1d, 0.9d, 1.1d};
RealVectorImpl ceil_v = new RealVectorImpl(ceil_a);
RealVector v_mapCeil = ceil_v.mapCeil();
double[] result_mapCeil = {-1d,1d,2d};
assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);
RealVector v_mapCeilToSelf = ceil_v.copy();
v_mapCeilToSelf.mapCeilToSelf();
double[] result_mapCeilToSelf =  {-1d,1d,2d};
assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);
RealVector v_mapFloor = ceil_v.mapFloor();
double[] result_mapFloor = {-2d,0d,1d};
assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);
RealVector v_mapFloorToSelf = ceil_v.copy();
v_mapFloorToSelf.mapFloorToSelf();
double[] result_mapFloorToSelf =  {-2d,0d,1d};
assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);
RealVector v_mapRint = ceil_v.mapRint();
double[] result_mapRint = {-1d,1d,1d};
assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);
RealVector v_mapRintToSelf = ceil_v.copy();
v_mapRintToSelf.mapRintToSelf();
double[] result_mapRintToSelf =  {-1d,1d,1d};
assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);
RealVector v_mapSignum = ceil_v.mapSignum();
double[] result_mapSignum = {-1d,1d,1d};
assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);
RealVector v_mapSignumToSelf = ceil_v.copy();
v_mapSignumToSelf.mapSignumToSelf();
double[] result_mapSignumToSelf =  {-1d,1d,1d};
assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);
RealVector v_mapUlp = ceil_v.mapUlp();
double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};
assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);
RealVector v_mapUlpToSelf = ceil_v.copy();
v_mapUlpToSelf.mapUlpToSelf();
double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};
assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);
public void testBasicFunctions() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v2 = new RealVectorImpl(vec2);
RealVectorImpl v_null = new RealVectorImpl(vec_null);
RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); 
double d_getNorm = v1.getNorm();
assertEquals("compare values  ", 3.7416573867739413,d_getNorm);
double d_getL1Norm = v1.getL1Norm();
assertEquals("compare values  ",6.0, d_getL1Norm);
double d_getLInfNorm = v1.getLInfNorm();
assertEquals("compare values  ",6.0, d_getLInfNorm);
double dist = v1.getDistance(v2);
assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );
double dist_2 = v1.getDistance(v2_t);
assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );
double d_getL1Distance = v1. getL1Distance(v2);
assertEquals("compare values  ",9d, d_getL1Distance );
double d_getL1Distance_2 = v1. getL1Distance(v2_t);
assertEquals("compare values  ",9d, d_getL1Distance_2 );
double d_getLInfDistance = v1. getLInfDistance(v2);
assertEquals("compare values  ",3d, d_getLInfDistance );
double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);
assertEquals("compare values  ",3d, d_getLInfDistance_2 );
RealVectorImpl v_add = v1.add(v2);
double[] result_add = {5d, 7d, 9d};
assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);
RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);
RealVector v_add_i = v1.add(vt2);
double[] result_add_i = {5d, 7d, 9d};
assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);
RealVectorImpl v_subtract = v1.subtract(v2);
double[] result_subtract = {-3d, -3d, -3d};
assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);
RealVector v_subtract_i = v1.subtract(vt2);
double[] result_subtract_i = {-3d, -3d, -3d};
assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);
RealVectorImpl  v_ebeMultiply = v1.ebeMultiply(v2);
double[] result_ebeMultiply = {4d, 10d, 18d};
assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);
RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);
double[] result_ebeMultiply_2 = {4d, 10d, 18d};
assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);
RealVectorImpl  v_ebeDivide = v1.ebeDivide(v2);
double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};
assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);
RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);
double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};
assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);
double dot =  v1.dotProduct(v2);
assertEquals("compare val ",32d, dot);
double dot_2 =  v1.dotProduct(v2_t);
assertEquals("compare val ",32d, dot_2);
RealMatrixImpl m_outerProduct = v1.outerProduct(v2);
assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));
RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);
assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));
RealVector v_unitVector = v1.unitVector();
RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); 
assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);
v_null.unitVector();
fail("Expecting ArithmeticException");
} catch (ArithmeticException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_unitize = (RealVectorImpl)v1.copy();
v_unitize.unitize();
assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);
v_null.unitize();
fail("Expecting ArithmeticException");
} catch (ArithmeticException ex) {
} catch (Exception e) {
fail("wrong exception caught");
RealVectorImpl v_projection = v1.projection(v2);
double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};
assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);
RealVector v_projection_2 = v1.projection(v2_t);
double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};
assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);
}  
public void testMisc() { 
RealVectorImpl v1 = new RealVectorImpl(vec1);
RealVectorImpl v4 = new RealVectorImpl(vec4);
RealVector v4_2 = new RealVectorImpl(vec4);
String out1 = v1.toString();
assertTrue("some output ",  out1.length()!=0);
double[] dout1 = v1.copyOut();
assertEquals("testData len", 3, dout1.length);
assertNotSame("testData not same object ", v1.data, dout1);   
v1.checkVectorDimensions(2); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
} 
v1.checkVectorDimensions(v4); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
}        
v1.checkVectorDimensions(v4_2); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
}        
public void testPredicates() {
RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 });
assertFalse(v.isNaN());
v.set(1, Double.NaN);
assertTrue(v.isNaN());
assertFalse(v.isInfinite());
v.set(0, Double.POSITIVE_INFINITY);
assertFalse(v.isInfinite());
v.set(1, 1);
assertTrue(v.isInfinite());
v.set(0, 0);
assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 }));
assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)}));
assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 }));
assertEquals(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode(),
new RealVectorImpl(new double[] { 0, Double.NaN, 2 }).hashCode());
assertTrue(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode() !=
new RealVectorImpl(new double[] { 0, 1, 2 }).hashCode());
protected void assertClose(String msg, double[] m, double[] n,
double tolerance) {
if (m.length != n.length) {
fail("vectors have different lengths");
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);
integ.addStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();
integ.addStepHandler(cm);
private static final long serialVersionUID = 2472449657345878299L;
public void computeDerivatives(double t, double[] y, double[] dot)
throws DerivativeException {
dot[0] = -y[1];
dot[1] =  y[0];
public int getDimension() {
return 2;
};
integ1.addStepHandler(cm1);
integ2.addStepHandler(cm2);
package org.apache.commons.math.ode.nonstiff;
public class AdamsBashforthIntegratorTest
extends TestCase {
public AdamsBashforthIntegratorTest(String name) {
super(name);
public void testCoefficients() {
double[] coeffs1 = new AdamsBashforthIntegrator(1, 0.01).getCoeffs();
assertEquals(1, coeffs1.length);
assertEquals(1.0, coeffs1[0], 1.0e-16);
double[] coeffs2 = new AdamsBashforthIntegrator(2, 0.01).getCoeffs();
assertEquals(2, coeffs2.length);
assertEquals( 3.0 / 2.0, coeffs2[0], 1.0e-16);
assertEquals(-1.0 / 2.0, coeffs2[1], 1.0e-16);
double[] coeffs3 = new AdamsBashforthIntegrator(3, 0.01).getCoeffs();
assertEquals(3, coeffs3.length);
assertEquals( 23.0 / 12.0, coeffs3[0], 1.0e-16);
assertEquals(-16.0 / 12.0, coeffs3[1], 1.0e-16);
assertEquals(  5.0 / 12.0, coeffs3[2], 1.0e-16);
double[] coeffs4 = new AdamsBashforthIntegrator(4, 0.01).getCoeffs();
assertEquals(4, coeffs4.length);
assertEquals( 55.0 / 24.0, coeffs4[0], 1.0e-16);
assertEquals(-59.0 / 24.0, coeffs4[1], 1.0e-16);
assertEquals( 37.0 / 24.0, coeffs4[2], 1.0e-16);
assertEquals( -9.0 / 24.0, coeffs4[3], 1.0e-16);
double[] coeffs5 = new AdamsBashforthIntegrator(5, 0.01).getCoeffs();
assertEquals(5, coeffs5.length);
assertEquals( 1901.0 / 720.0, coeffs5[0], 1.0e-16);
assertEquals(-2774.0 / 720.0, coeffs5[1], 1.0e-16);
assertEquals( 2616.0 / 720.0, coeffs5[2], 1.0e-16);
assertEquals(-1274.0 / 720.0, coeffs5[3], 1.0e-16);
assertEquals(  251.0 / 720.0, coeffs5[4], 1.0e-16);
double[] coeffs6 = new AdamsBashforthIntegrator(6, 0.01).getCoeffs();
assertEquals(6, coeffs6.length);
assertEquals( 4277.0 / 1440.0, coeffs6[0], 1.0e-16);
assertEquals(-7923.0 / 1440.0, coeffs6[1], 1.0e-16);
assertEquals( 9982.0 / 1440.0, coeffs6[2], 1.0e-16);
assertEquals(-7298.0 / 1440.0, coeffs6[3], 1.0e-16);
assertEquals( 2877.0 / 1440.0, coeffs6[4], 1.0e-16);
assertEquals( -475.0 / 1440.0, coeffs6[5], 1.0e-16);
double[] coeffs7 = new AdamsBashforthIntegrator(7, 0.01).getCoeffs();
assertEquals(7, coeffs7.length);
assertEquals( 198721.0 / 60480.0, coeffs7[0], 1.0e-16);
assertEquals(-447288.0 / 60480.0, coeffs7[1], 1.0e-16);
assertEquals( 705549.0 / 60480.0, coeffs7[2], 1.0e-16);
assertEquals(-688256.0 / 60480.0, coeffs7[3], 1.0e-16);
assertEquals( 407139.0 / 60480.0, coeffs7[4], 1.0e-16);
assertEquals(-134472.0 / 60480.0, coeffs7[5], 1.0e-16);
assertEquals(  19087.0 / 60480.0, coeffs7[6], 1.0e-16);
double[] coeffs8 = new AdamsBashforthIntegrator(8, 0.01).getCoeffs();
assertEquals(8, coeffs8.length);
assertEquals(  434241.0 / 120960.0, coeffs8[0], 1.0e-16);
assertEquals(-1152169.0 / 120960.0, coeffs8[1], 1.0e-16);
assertEquals( 2183877.0 / 120960.0, coeffs8[2], 1.0e-16);
assertEquals(-2664477.0 / 120960.0, coeffs8[3], 1.0e-16);
assertEquals( 2102243.0 / 120960.0, coeffs8[4], 1.0e-16);
assertEquals(-1041723.0 / 120960.0, coeffs8[5], 1.0e-16);
assertEquals(  295767.0 / 120960.0, coeffs8[6], 1.0e-16);
assertEquals(  -36799.0 / 120960.0, coeffs8[7], 1.0e-16);
double[] coeffs9 = new AdamsBashforthIntegrator(9, 0.01).getCoeffs();
assertEquals(9, coeffs9.length);
assertEquals(  14097247.0 / 3628800.0, coeffs9[0], 1.0e-16);
assertEquals( -43125206.0 / 3628800.0, coeffs9[1], 1.0e-16);
assertEquals(  95476786.0 / 3628800.0, coeffs9[2], 1.0e-16);
assertEquals(-139855262.0 / 3628800.0, coeffs9[3], 1.0e-16);
assertEquals( 137968480.0 / 3628800.0, coeffs9[4], 1.0e-16);
assertEquals( -91172642.0 / 3628800.0, coeffs9[5], 1.0e-16);
assertEquals(  38833486.0 / 3628800.0, coeffs9[6], 1.0e-16);
assertEquals(  -9664106.0 / 3628800.0, coeffs9[7], 1.0e-16);
assertEquals(   1070017.0 / 3628800.0, coeffs9[8], 1.0e-16);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new AdamsBashforthIntegrator(3, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
} catch(DerivativeException de) {
fail("wrong exception caught");
} catch(IntegratorException ie) {
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if (i > 6) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-9);
assertTrue(handler.getMaximalValueError() < 3.0e-8);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
assertEquals("Adams-Bashforth", integ.getName());
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.05);
assertTrue(handler.getMaximalValueError() > 0.1);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 8.0e-11);
assertTrue(handler.getMaximalValueError() < 8.0e-11);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Adams-Bashforth", integ.getName());
public static Test suite() {
return new TestSuite(AdamsBashforthIntegratorTest.class);
package org.apache.commons.math.ode.nonstiff;
public class AdamsMoultonIntegratorTest
extends TestCase {
public AdamsMoultonIntegratorTest(String name) {
super(name);
public void testPredictorCoefficients() {
for (int order = 1; order < 10; ++order) {
double[] moulton = new AdamsMoultonIntegrator(order, 0.01).getPredictorCoeffs();
double[] bashforth  = new AdamsBashforthIntegrator(order, 0.01).getCoeffs();
assertEquals(bashforth.length, moulton.length);
for (int i = 0; i < moulton.length; ++i) {
assertEquals(bashforth[i], moulton[i], 1.0e-16);
public void testCorrectorCoefficients() {
double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs();
assertEquals(2, coeffs1.length);
assertEquals(1.0 / 2.0, coeffs1[0], 1.0e-16);
assertEquals(1.0 / 2.0, coeffs1[1], 1.0e-16);
double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs();
assertEquals(3, coeffs2.length);
assertEquals( 5.0 / 12.0, coeffs2[0], 1.0e-16);
assertEquals( 8.0 / 12.0, coeffs2[1], 1.0e-16);
assertEquals(-1.0 / 12.0, coeffs2[2], 1.0e-16);
double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs();
assertEquals(4, coeffs3.length);
assertEquals( 9.0 / 24.0, coeffs3[0], 1.0e-16);
assertEquals(19.0 / 24.0, coeffs3[1], 1.0e-16);
assertEquals(-5.0 / 24.0, coeffs3[2], 1.0e-16);
assertEquals( 1.0 / 24.0, coeffs3[3], 1.0e-16);
double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs();
assertEquals(5, coeffs4.length);
assertEquals( 251.0 / 720.0, coeffs4[0], 1.0e-16);
assertEquals( 646.0 / 720.0, coeffs4[1], 1.0e-16);
assertEquals(-264.0 / 720.0, coeffs4[2], 1.0e-16);
assertEquals( 106.0 / 720.0, coeffs4[3], 1.0e-16);
assertEquals( -19.0 / 720.0, coeffs4[4], 1.0e-16);
double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs();
assertEquals(6, coeffs5.length);
assertEquals( 475.0 / 1440.0, coeffs5[0], 1.0e-16);
assertEquals(1427.0 / 1440.0, coeffs5[1], 1.0e-16);
assertEquals(-798.0 / 1440.0, coeffs5[2], 1.0e-16);
assertEquals( 482.0 / 1440.0, coeffs5[3], 1.0e-16);
assertEquals(-173.0 / 1440.0, coeffs5[4], 1.0e-16);
assertEquals(  27.0 / 1440.0, coeffs5[5], 1.0e-16);
double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs();
assertEquals(7, coeffs6.length);
assertEquals( 19087.0 / 60480.0, coeffs6[0], 1.0e-16);
assertEquals( 65112.0 / 60480.0, coeffs6[1], 1.0e-16);
assertEquals(-46461.0 / 60480.0, coeffs6[2], 1.0e-16);
assertEquals( 37504.0 / 60480.0, coeffs6[3], 1.0e-16);
assertEquals(-20211.0 / 60480.0, coeffs6[4], 1.0e-16);
assertEquals(  6312.0 / 60480.0, coeffs6[5], 1.0e-16);
assertEquals(  -863.0 / 60480.0, coeffs6[6], 1.0e-16);
double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs();
assertEquals(8, coeffs7.length);
assertEquals(  36799.0 / 120960.0, coeffs7[0], 1.0e-16);
assertEquals( 139849.0 / 120960.0, coeffs7[1], 1.0e-16);
assertEquals(-121797.0 / 120960.0, coeffs7[2], 1.0e-16);
assertEquals( 123133.0 / 120960.0, coeffs7[3], 1.0e-16);
assertEquals( -88547.0 / 120960.0, coeffs7[4], 1.0e-16);
assertEquals(  41499.0 / 120960.0, coeffs7[5], 1.0e-16);
assertEquals( -11351.0 / 120960.0, coeffs7[6], 1.0e-16);
assertEquals(   1375.0 / 120960.0, coeffs7[7], 1.0e-16);
double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs();
assertEquals(9, coeffs8.length);
assertEquals( 1070017.0 / 3628800.0, coeffs8[0], 1.0e-16);
assertEquals( 4467094.0 / 3628800.0, coeffs8[1], 1.0e-16);
assertEquals(-4604594.0 / 3628800.0, coeffs8[2], 1.0e-16);
assertEquals( 5595358.0 / 3628800.0, coeffs8[3], 1.0e-16);
assertEquals(-5033120.0 / 3628800.0, coeffs8[4], 1.0e-16);
assertEquals( 3146338.0 / 3628800.0, coeffs8[5], 1.0e-16);
assertEquals(-1291214.0 / 3628800.0, coeffs8[6], 1.0e-16);
assertEquals(  312874.0 / 3628800.0, coeffs8[7], 1.0e-16);
assertEquals(  -33953.0 / 3628800.0, coeffs8[8], 1.0e-16);
public void testDimensionCheck() {
TestProblem1 pb = new TestProblem1();
new AdamsMoultonIntegrator(3, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
fail("an exception should have been thrown");
} catch(DerivativeException de) {
fail("wrong exception caught");
} catch(IntegratorException ie) {
public void testDecreasingSteps()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
if (pb instanceof TestProblem3) {
step /= 8;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if (i > 6) {
assertTrue(error < Math.abs(previousError));
previousError = error;
public void testSmallStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 7.0e-12);
assertTrue(handler.getMaximalValueError() < 4.0e-11);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
assertEquals("Adams-Moulton", integ.getName());
public void testBigStep()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.01);
assertTrue(handler.getMaximalValueError() > 0.03);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 5.0e-10);
assertTrue(handler.getMaximalValueError() < 7.0e-10);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Adams-Moulton", integ.getName());
public static Test suite() {
return new TestSuite(AdamsMoultonIntegratorTest.class);
package org.apache.commons.math.ode.nonstiff;
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 5.0e-10);
assertTrue(handler.getMaximalValueError() < 7.0e-10);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("classical Runge-Kutta", integ.getName());
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 7510061424396717277L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-7);
assertTrue(handler.getMaximalValueError() < 2.0e-7);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Dormand-Prince 5(4)", integ.getName());
private static final long serialVersionUID = -8168590945325629799L;
integ.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerHandler(pb));
integ.addStepHandler(new VariableHandler());
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
private static final long serialVersionUID = -1645853847806655456L;
private static final long serialVersionUID = -5196650833828379228L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = -6768136169276197L;
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 8.0e-8);
assertTrue(handler.getMaximalValueError() < 2.0e-7);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 3300);
integ.addStepHandler(new VariableHandler());
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(DummyStepHandler.getInstance());
integ.addStepHandler(new InterpolatingStepHandler());
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = -1752092987112788459L;
private static final long serialVersionUID = 5542665697103383623L;
private static final long serialVersionUID = -5272695044664350727L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 2209212559670665268L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new EulerIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 0.45);
assertTrue(handler.getMaximalValueError() < 0.45);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Euler", integ.getName());
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new EulerIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
throws DerivativeException {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
EulerIntegrator integ = new EulerIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
private static final long serialVersionUID = 291437140744677100L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new GillIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 5.0e-10);
assertTrue(handler.getMaximalValueError() < 7.0e-10);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Gill", integ.getName());
integ.addStepHandler(new KeplerStepHandler(pb));
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = 1250933165809631538L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new GillIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
GillIntegrator integ = new GillIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 9.0e-10);
assertTrue(handler.getMaximalValueError() < 9.0e-10);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Gragg-Bulirsch-Stoer", integ.getName());
integ.addStepHandler(handler);
integrator.addStepHandler(handler);
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
integ.addStepHandler(new KeplerStepHandler(pb));
integ.addStepHandler(new VariableStepHandler());
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);
private static final long serialVersionUID = -8231434585284002546L;
private static final long serialVersionUID = -5955452449048688985L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.9);
double minStep   = 0;
double maxStep   = pb.getFinalTime() - pb.getInitialTime();
double absTolerance = 1.0e-8;
double relTolerance = 1.0e-8;
GraggBulirschStoerIntegrator integ =
new GraggBulirschStoerIntegrator(minStep, maxStep,
absTolerance, relTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-8);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = -5947183291381232297L;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = -1157081786301178032L;
public void computeDerivatives(double t, double[] y, double[] dot)
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;
FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 5.0e-7);
assertTrue(handler.getMaximalValueError() < 5.0e-7);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("Higham-Hall 5(4)", integ.getName());
public void testEvents()
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
assertEquals(functions.length, integ.getEventHandlers().size());
integ.clearEventHandlers();
assertEquals(0, integ.getEventHandlers().size());
public void testEventsErrors()
integ.addStepHandler(handler);
integ.addEventHandler(new EventHandler() {
return EventHandler.CONTINUE;
public double g(double t, double[] y) throws EventException {
throw new EventException("Evaluation failed for argument = {0}",
new Object[] { Double.valueOf(t) });
public void testEventsNoConvergence()
integ.addStepHandler(handler);
integ.addEventHandler(new EventHandler() {
return EventHandler.CONTINUE;
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 3200246026175251943L;
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3(0.1);
double minStep = 0;
double maxStep = pb.getFinalTime() - pb.getInitialTime();
double scalAbsoluteTolerance = 1.0e-8;
double scalRelativeTolerance = scalAbsoluteTolerance;
HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,
scalAbsoluteTolerance,
scalRelativeTolerance);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 9111679755950880352L;
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new MidpointIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 6.0e-4);
assertTrue(handler.getMaximalValueError() < 6.0e-4);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("midpoint", integ.getName());
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new MidpointIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
MidpointIntegrator integ = new MidpointIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.nonstiff;
public class StepInterpolatorAbstractTest extends TestCase {
protected StepInterpolatorAbstractTest(String name) {
super(name);
protected void checkDerivativesConsistency(final FirstOrderIntegrator integrator,
final TestProblemAbstract problem,
final double threshold)
throws DerivativeException, IntegratorException {
integrator.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 2462564234755682953L;
public boolean requiresDenseOutput() {
return true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());
final double t = interpolator.getCurrentTime() - 300 * h;
if (Math.abs(h) < 10 * Math.ulp(t)) {
return;
interpolator.setInterpolatedTime(t - 4 * h);
final double[] yM4h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - 3 * h);
final double[] yM3h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - 2 * h);
final double[] yM2h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t - h);
final double[] yM1h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + h);
final double[] yP1h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 2 * h);
final double[] yP2h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 3 * h);
final double[] yP3h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t + 4 * h);
final double[] yP4h = interpolator.getInterpolatedState().clone();
interpolator.setInterpolatedTime(t);
final double[] yDot = interpolator.getInterpolatedDerivatives();
for (int i = 0; i < yDot.length; ++i) {
final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) +
32 * (yP3h[i] - yM3h[i]) +
-168 * (yP2h[i] - yM2h[i]) +
672 * (yP1h[i] - yM1h[i])) / (840 * h);
if (Math.abs(approYDot - yDot[i]) >= threshold) {
System.out.println("gotcha!");
assertEquals(approYDot, yDot[i], threshold);
public void reset() {
});
integrator.integrate(problem,
problem.getInitialTime(), problem.getInitialState(),
problem.getFinalTime(), new double[problem.getDimension()]);
package org.apache.commons.math.ode.nonstiff;
implements FirstOrderDifferentialEquations, EventHandler {
package org.apache.commons.math.ode.nonstiff;
public class TestProblem1
private static final long serialVersionUID = 1977870815289373164L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem2
private static final long serialVersionUID = 8330741783213512366L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem3
private static final long serialVersionUID = 8567328542728919999L;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem4
private static final long serialVersionUID = -5910438521889015745L;
public EventHandler[] getEventsHandlers() {
return new EventHandler[] { new Bounce(), new Stop() };
private static class Bounce implements EventHandler {
return EventHandler.RESET_STATE;
y[0] = -y[0];
private static class Stop implements EventHandler {
return EventHandler.STOP;
package org.apache.commons.math.ode.nonstiff;
public class TestProblem5
private static final long serialVersionUID = 7579233102411804237L;
package org.apache.commons.math.ode.nonstiff;
public abstract class TestProblemAbstract
public EventHandler[] getEventsHandlers() {
return new EventHandler[0];
package org.apache.commons.math.ode.nonstiff;
package org.apache.commons.math.ode.nonstiff;
private static final long serialVersionUID = 3589490480549900461L;
private ODEIntegrator integrator;
public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {
expectedStepStart = Double.NaN;
if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {
if (!Double.isNaN(expectedStepStart)) {
maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));
expectedStepStart = start + integrator.getCurrentSignedStepsize();
package org.apache.commons.math.ode.nonstiff;
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
integ.addEventHandler(functions[l],
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
integ.addStepHandler(handler);
integ.addStepHandler(handler);
public void testBackward()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 5.0e-10);
assertTrue(handler.getMaximalValueError() < 7.0e-10);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);
assertEquals("3/8", integ.getName());
integ.addStepHandler(new KeplerHandler(pb));
private static final long serialVersionUID = 4400497468419540899L;
public void testStepSize()
throws DerivativeException, IntegratorException {
final double step = 1.23456;
FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);
integ.addStepHandler(new StepHandler() {
private static final long serialVersionUID = 0L;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
if (! isLast) {
assertEquals(step,
interpolator.getCurrentTime() - interpolator.getPreviousTime(),
1.0e-12);
public boolean requiresDenseOutput() {
return false;
public void reset() {
}          
});
integ.integrate(new FirstOrderDifferentialEquations() {
private static final long serialVersionUID = 0L;
public void computeDerivatives(double t, double[] y, double[] dot) {
dot[0] = 1.0;
public int getDimension() {
return 1;
}, 0.0, new double[] { 0.0 }, 5.0, new double[1]);
package org.apache.commons.math.ode.nonstiff;
extends StepInterpolatorAbstractTest {
public void testDerivativesConsistency()
throws DerivativeException, IntegratorException {
TestProblem3 pb = new TestProblem3();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);
checkDerivativesConsistency(integ, pb, 1.0e-10);
integ.addStepHandler(new ContinuousOutputModel());
for (StepHandler handler : integ.getStepHandlers()) {
oos.writeObject(handler);
package org.apache.commons.math.ode.sampling;
assertTrue(bos.size () > 300);
assertTrue(bos.size () < 350);
package org.apache.commons.math.ode.sampling;
integ.addStepHandler(new StepNormalizer(range / 10.0,
private static final long serialVersionUID = 1650337364641626444L;
private boolean firstCall = true;
double[] yDot,
integ.addStepHandler(new StepNormalizer(range / 10.5,
private static final long serialVersionUID = 2228457391561277298L;
public void handleStep(double t,
double[] yDot,
public void testMath226()
throws DimensionMismatchException, NotPositiveDefiniteMatrixException {
double[] mean = { 1, 1, 10, 1 };
double[][] cov = {
{ 1, 3, 2, 6 },
{ 3, 13, 16, 2 },
{ 2, 16, 38, -1 },
{ 6, 2, -1, 197 }
};
RealMatrix covRM = new RealMatrixImpl(cov, false);
JDKRandomGenerator jg = new JDKRandomGenerator();
jg.setSeed(5322145245211l);
NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);
CorrelatedRandomVectorGenerator sg =
new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);
for (int i = 0; i < 10; i++) {
double[] generated = sg.nextVector();
assertTrue(Math.abs(generated[0] - 1) > 0.1);
ArrayList<Double> list = new ArrayList<Double>();
for (Double data : list) {
dataArray[i] = data.doubleValue();
Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue();
HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}
HashSet<Object> hs = new HashSet<Object>();
HashSet<Object> hs = new HashSet<Object>();
hs = new HashSet<Object>();
HashSet<Object> set = (HashSet<Object>) u[i];
HashSet<Object> sampSet = new HashSet<Object>();
assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2)));
f.addValue(Integer.valueOf(1));
f.addValue(Long.valueOf(1));
f.addValue(Integer.valueOf(-1));
assertEquals("1 count", 3, f.getCount(Integer.valueOf(1)));
assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   
obj1 = Integer.valueOf(1);
Integer int1 = Integer.valueOf(1);
f.addValue(Long.valueOf(2));
assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));
assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);
private Map<String, Double> certifiedValues;
certifiedValues = new HashMap<String, Double>();
Double value = Double.valueOf(valueString);
for (String name : certifiedValues.keySet()) {
return Double.valueOf(((Long) property).doubleValue());
public class DescriptiveStatisticsTest extends TestCase {
protected List<Object> list;
this(new ArrayList<Object>());
public ListUnivariateImpl(List<Object> list) {
public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {
list.add(Double.valueOf(v));
List<Object> externalList = new ArrayList<Object>();
List<Object> list = new ArrayList<Object>();
list.add( Double.valueOf(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());
List<Object> externalList = new ArrayList<Object>();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
new ListUnivariateImpl(new ArrayList<Object>(), transformers);
u.addObject(Integer.valueOf(12));
u.addObject(Long.valueOf(21));
u.addObject(Float.valueOf(14.1f));
u.addObject(Double.valueOf(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);
assertFalse(u.equals(Double.valueOf(0)));
assertFalse("wrong type", u.equals(Double.valueOf(0)));
public class SummaryStatisticsTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsTest(String name) {
super(name);
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(Double.valueOf(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> emptyContents = new ArrayList<double[]>();
List<double[]> tooFew = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
List<double[]> threeClasses = new ArrayList<double[]>();
List<double[]> twoClasses = new ArrayList<double[]>();
private List<double[]> classes = new ArrayList<double[]>();
package org.apache.commons.math.stat.regression;
public abstract class AbstractMultipleLinearRegressionTest {
protected MultipleLinearRegression regression;
public void setUp(){
regression = createRegression();
protected abstract MultipleLinearRegression createRegression();
protected abstract int getNumberOfRegressors();
protected abstract int getSampleSize();
public void canEstimateRegressionParameters(){
double[] beta = regression.estimateRegressionParameters();        
assertEquals(getNumberOfRegressors(), beta.length);
public void canEstimateResiduals(){
double[] e = regression.estimateResiduals();
assertEquals(getSampleSize(), e.length);
public void canEstimateRegressionParametersVariance(){
double[][] variance = regression.estimateRegressionParametersVariance();
assertEquals(getNumberOfRegressors(), variance.length);
public void canEstimateRegressandVariance(){
if (getSampleSize() > getNumberOfRegressors()) {
double variance = regression.estimateRegressandVariance();
assertTrue(variance > 0.0);
}   
package org.apache.commons.math.stat.regression;
public class GLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
private double[][] omega;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
omega = new double[6][];
omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};
omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};
omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};
omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};
omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};
omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};
super.setUp();
public void cannotAddXSampleData() {
createRegression().newSampleData(new double[]{}, null, null);
public void cannotAddNullYSampleData() {
createRegression().newSampleData(null, new double[][]{}, null);
public void cannotAddSampleDataWithSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[1][];
x[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x, null);
public void cannotAddNullCovarianceData() {
createRegression().newSampleData(new double[]{}, new double[][]{}, null);
public void cannotAddCovarianceDataWithSampleSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[1][];
omega[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x, omega);
public void cannotAddCovarianceDataThatIsNotSquare() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[2][];
x[0] = new double[]{1.0, 0};
x[1] = new double[]{0, 1.0};
double[][] omega = new double[3][];
omega[0] = new double[]{1.0, 0};
omega[1] = new double[]{0, 1.0};
omega[2] = new double[]{0, 2.0};
createRegression().newSampleData(y, x, omega);
protected GLSMultipleLinearRegression createRegression() {
GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();
regression.newSampleData(y, x, omega);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;
package org.apache.commons.math.stat.regression;
public class OLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {
private double[] y;
private double[][] x;
public void setUp(){
y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};
x = new double[6][];
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
super.setUp();
protected OLSMultipleLinearRegression createRegression() {
OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();
regression.newSampleData(y, x);
return regression;
protected int getNumberOfRegressors() {
return x[0].length;
protected int getSampleSize() {
return y.length;
public void cannotAddXSampleData() {
createRegression().newSampleData(new double[]{}, null);
public void cannotAddNullYSampleData() {
createRegression().newSampleData(null, new double[][]{});
public void cannotAddSampleDataWithSizeMismatch() {
double[] y = new double[]{1.0, 2.0};
double[][] x = new double[1][];
x[0] = new double[]{1.0, 0};
createRegression().newSampleData(y, x);
public void testPerfectFit() {
double[] betaHat = regression.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{11.0,0.5,0.666666666666667,0.75,0.8,0.8333333333333333},
1e-12);
double[] residuals = regression.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},
1e-12);
double[][] errors = regression.estimateRegressionParametersVariance();
public void testLongly() {
double[] design = new double[] {
60323,83.0,234289,2356,1590,107608,1947,
61122,88.5,259426,2325,1456,108632,1948,
60171,88.2,258054,3682,1616,109773,1949,
61187,89.5,284599,3351,1650,110929,1950,
63221,96.2,328975,2099,3099,112075,1951,
63639,98.1,346999,1932,3594,113270,1952,
64989,99.0,365385,1870,3547,115094,1953,
63761,100.0,363112,3578,3350,116219,1954,
66019,101.2,397469,2904,3048,117388,1955,
67857,104.6,419180,2822,2857,118734,1956,
68169,108.4,442769,2936,2798,120445,1957,
66513,110.8,444546,4681,2637,121950,1958,
68655,112.6,482704,3813,2552,123366,1959,
69564,114.2,502601,3931,2514,125368,1960,
69331,115.7,518173,4806,2572,127852,1961,
70551,116.9,554894,4007,2827,130081,1962
};
int nobs = 16;
int nvars = 6;
OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();
model.newSampleData(design, nobs, nvars);
double[] betaHat = model.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{-3482258.63459582, 15.0618722713733,
-0.358191792925910E-01,-2.02022980381683,
-1.03322686717359,-0.511041056535807E-01,
1829.15146461355}, 1E-8); // 
double[] residuals = model.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{
267.340029759711,-94.0139423988359,46.28716775752924,
-410.114621930906,309.7145907602313,-249.3112153297231,
-164.0489563956039,-13.18035686637081,14.30477260005235,
455.394094551857,-17.26892711483297,-39.0550425226967,
-155.5499735953195,-85.6713080421283,341.9315139607727,
-206.7578251937366},
1E-8);
double[][] errors = model.estimateRegressionParametersVariance();
public void testSwissFertility() {
double[] design = new double[] {
80.2,17.0,15,12,9.96,
83.1,45.1,6,9,84.84,
92.5,39.7,5,5,93.40,
85.8,36.5,12,7,33.77,
76.9,43.5,17,15,5.16,
76.1,35.3,9,7,90.57,
83.8,70.2,16,7,92.85,
92.4,67.8,14,8,97.16,
82.4,53.3,12,7,97.67,
82.9,45.2,16,13,91.38,
87.1,64.5,14,6,98.61,
64.1,62.0,21,12,8.52,
66.9,67.5,14,7,2.27,
68.9,60.7,19,12,4.43,
61.7,69.3,22,5,2.82,
68.3,72.6,18,2,24.20,
71.7,34.0,17,8,3.30,
55.7,19.4,26,28,12.11,
54.3,15.2,31,20,2.15,
65.1,73.0,19,9,2.84,
65.5,59.8,22,10,5.23,
65.0,55.1,14,3,4.52,
56.6,50.9,22,12,15.14,
57.4,54.1,20,6,4.20,
72.5,71.2,12,1,2.40,
74.2,58.1,14,8,5.23,
72.0,63.5,6,3,2.56,
60.5,60.8,16,10,7.72,
58.3,26.8,25,19,18.46,
65.4,49.5,15,8,6.10,
75.5,85.9,3,2,99.71,
69.3,84.9,7,6,99.68,
77.3,89.7,5,2,100.00,
70.5,78.2,12,6,98.96,
79.4,64.9,7,3,98.22,
65.0,75.9,9,9,99.06,
92.2,84.6,3,3,99.46,
79.3,63.1,13,13,96.83,
70.4,38.4,26,12,5.62,
65.7,7.7,29,11,13.79,
72.7,16.7,22,13,11.22,
64.4,17.6,35,32,16.92,
77.6,37.6,15,7,4.97,
67.6,18.7,25,7,8.65,
35.0,1.2,37,53,42.34,
44.7,46.6,16,29,50.43,
42.8,27.7,22,29,58.33
};
int nobs = 47;
int nvars = 4;
OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();
model.newSampleData(design, nobs, nvars);
double[] betaHat = model.estimateRegressionParameters();
TestUtils.assertEquals(betaHat, 
new double[]{91.05542390271397,
-0.22064551045715,
-0.26058239824328,
-0.96161238456030,
0.12441843147162}, 1E-12);
double[] residuals = model.estimateResiduals();
TestUtils.assertEquals(residuals, new double[]{
7.1044267859730512,1.6580347433531366,
4.6944952770029644,8.4548022690166160,13.6547432343186212,
-9.3586864458500774,7.5822446330520386,15.5568995563859289,
0.8113090736598980,7.1186762732484308,7.4251378771228724,
2.6761316873234109,0.8351584810309354,7.1769991119615177,
-3.8746753206299553,-3.1337779476387251,-0.1412575244091504,
1.1186809170469780,-6.3588097346816594,3.4039270429434074,
2.3374058329820175,-7.9272368576900503,-7.8361010968497959,
-11.2597369269357070,0.9445333697827101,6.6544245101380328,
-0.9146136301118665,-4.3152449403848570,-4.3536932047009183,
-3.8907885169304661,-6.3027643926302188,-7.8308982189289091,
-3.1792280015332750,-6.7167298771158226,-4.8469946718041754,
-10.6335664353633685,11.1031134362036958,6.0084032641811733,
5.4326230830188482,-7.2375578629692230,2.1671550814448222,
15.0147574652763112,4.8625103516321015,-7.1597256413907706,
-0.4515205619767598,-10.2916870903837587,-15.7812984571900063},
1E-12);  
private double[][] removeSingle = {infData[1]};
private double[][] removeMultiple = { infData[1], infData[2] };
private double removeX = infData[0][0];
private double removeY = infData[0][1];
public void testRemoveXY() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeX, removeY);
regression.addData(removeX, removeY);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveSingle() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeSingle);
regression.addData(removeSingle);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveMultiple() throws Exception {
SimpleRegression regression = new SimpleRegression();
regression.addData(infData);
regression.removeData(removeMultiple);
regression.addData(removeMultiple);
assertEquals("slope std err", 0.011448491,
regression.getSlopeStdErr(), 1E-10);
assertEquals("std err intercept", 0.286036932,
regression.getInterceptStdErr(),1E-8);
assertEquals("significance", 4.596e-07,
regression.getSignificance(),1E-8);    
assertEquals("slope conf interval half-width", 0.0270713794287, 
regression.getSlopeConfidenceInterval(),1E-8);
public void testRemoveObsFromEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.removeData(removeX, removeY);
assertEquals(regression.getN(), 0);
public void testRemoveObsFromSingle() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeX, removeY);
regression.removeData(removeX, removeY);
assertEquals(regression.getN(), 0);
public void testRemoveMultipleToEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeMultiple);
regression.removeData(removeMultiple);
assertEquals(regression.getN(), 0);
public void testRemoveMultiplePastEmpty() {
SimpleRegression regression = new SimpleRegression();
regression.addData(removeX, removeY);
regression.removeData(removeMultiple);
assertEquals(regression.getN(), 0);
Double input = Double.valueOf(expected);
Integer input = Integer.valueOf(1);
private Double x = Double.valueOf(1.0);value = new Double(d);
value = new Float(f);
value = new Integer(i);
value = new Long(l);
dynaBean.set(propertyName, new Double(v));
VitalStats vs1 = new VitalStats( new Double(120.0), 
new Double(96.4) );
Patient p1 = new Patient( vs1, new Integer( 35 ) );
VitalStats vs2 = new VitalStats( new Double(70.0), 
new Double(97.4) );
Patient p2 = new Patient( vs2, new Integer( 23 ) );
VitalStats vs3 = new VitalStats( new Double(90.0), 
new Double(98.6) );
Patient p3 = new Patient( vs3, new Integer( 42 ) );
new Object[] { new Double(argument), new Double(lower), new Double(upper) });
public ConvergenceException(String msg, Throwable rootCause) {
super(msg, rootCause);
public ConvergenceException(String msg) {
super(msg);
new Integer(dimension1), new Integer(dimension2)
new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });
private static final long serialVersionUID = -7619974756160279127L;
new Object[] { new Double(argument) });
public FunctionEvaluationException(double argument, String message) {
super(message);
this.argument = argument;
public FunctionEvaluationException(double argument,
String message, Throwable cause) {
super(message, cause);
this.argument = argument;
private static final long serialVersionUID = -4056541384141349722L;
public MathConfigurationException(String message) {
super(message);
public MathConfigurationException(String message, Throwable cause) {
super(message, cause);
private static final long serialVersionUID = -8602234299177097102L;
public MathException(String msg) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = null;
public MathException(String msg, Throwable rootCause) {
super(msg);
this.pattern   = msg;
this.arguments = new Object[0];
this.rootCause = rootCause;
new Object[] { new Integer(maxIterations) });
UnivariateRealSolverFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (UnivariateRealSolverFactory) dc.newInstance(
UnivariateRealSolverFactory.class,
"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl");
} catch(Throwable t) {
return new UnivariateRealSolverFactoryImpl();
return factory;
new Object[] { new Integer(numIterations), new Integer(maximumIterations),
new Double(initial), new Double(lowerBound), new Double(upperBound),
new Double(a), new Double(b), new Double(fa), new Double(fb) });
protected double imaginary;
protected double real;
ret = (Double.doubleToRawLongBits(real) ==
Double.doubleToRawLongBits(rhs.getReal())) &&
(Double.doubleToRawLongBits(imaginary) ==
Double.doubleToRawLongBits(rhs.getImaginary())); 
public class ComplexFormat extends Format implements Serializable {
private static final long serialVersionUID = -6337346779577272306L;
public ComplexFormat(NumberFormat realFormat,
NumberFormat imaginaryFormat) {
public static String formatComplex( Complex c ) {
return getInstance().format( c );
throw new IllegalArgumentException(
"Cannot format given Object as a Date");
private StringBuffer formatDouble(double value, NumberFormat format,
StringBuffer toAppendTo, FieldPosition pos) {
if( Double.isNaN(value) || Double.isInfinite(value) ) {
toAppendTo.append('(');
toAppendTo.append(value);
toAppendTo.append(')');
} else {
format.format(value, toAppendTo, pos);
return toAppendTo;
public static Locale[] getAvailableLocales() {
return NumberFormat.getAvailableLocales();
private static NumberFormat getDefaultNumberFormat() {
return getDefaultNumberFormat(Locale.getDefault());
private static NumberFormat getDefaultNumberFormat(Locale locale) {
NumberFormat nf = NumberFormat.getInstance(locale);
nf.setMaximumFractionDigits(2);
return nf;
"\"", parsePosition.getErrorIndex());
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
if ((startIndex >= source.length()) ||
(endIndex > source.length()) ||
source.substring(startIndex, endIndex).compareTo(
getImaginaryCharacter()) != 0) {
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
pos.setIndex(endIndex);
private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;
if (index < n) {
char c;
do {
c = source.charAt(index++);
} while (Character.isWhitespace(c) && index < n);
pos.setIndex(index);
if (index < n) {
ret = c;
return ret;
private Number parseNumber(String source, double value, ParsePosition pos) {
Number ret = null;
StringBuffer sb = new StringBuffer();
sb.append('(');
sb.append(value);
sb.append(')');
int n = sb.length();
int startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (endIndex < source.length()) {
if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {
ret = new Double(value);
pos.setIndex(endIndex);
return ret;
private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {
int startIndex = pos.getIndex();
Number number = format.parse(source, pos);
int endIndex = pos.getIndex();
if (startIndex == endIndex) {
double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};
for (int i = 0; i < special.length; ++i) {
number = parseNumber(source, special[i], pos);
if (number != null) {
break;
return number;
public static Complex acos(Complex z) {
return z.acos();
public static Complex asin(Complex z) {
return z.asin();
public static Complex atan(Complex z) {
return z.atan();
public static Complex cos(Complex z) {
return z.cos();
public static Complex cosh(Complex z) {
return z.cosh();
public static Complex exp(Complex z) {
return z.exp();
public static Complex log(Complex z) {
return z.log();
public static Complex pow(Complex y, Complex x) {
return y.pow(x);
public static Complex sin(Complex z) {
return z.sin();
public static Complex sinh(Complex z) {
return z.sinh();
public static Complex sqrt(Complex z) {
return z.sqrt();
public static Complex sqrt1z(Complex z) {
return z.sqrt1z();
public static Complex tan(Complex z) {
return z.tan();
public static Complex tanh(Complex z) {
return z.tanh();
public interface ChiSquaredDistribution extends ContinuousDistribution {
package org.apache.commons.math.distribution;
public abstract class DistributionFactory {
protected DistributionFactory() {
super();
public static DistributionFactory newInstance() {
return new DistributionFactoryImpl();
public abstract BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess);
public PascalDistribution createPascalDistribution(
int numberOfSuccesses, double probabilityOfSuccess) {
return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);
public CauchyDistribution createCauchyDistribution(
double median, double scale)
return new CauchyDistributionImpl(median, scale);
public abstract ChiSquaredDistribution createChiSquareDistribution(
double degreesOfFreedom);
public abstract ExponentialDistribution createExponentialDistribution(
double mean);
public abstract FDistribution createFDistribution(
double numeratorDegreesOfFreedom, double denominatorDegreesOfFreedom);
public abstract GammaDistribution createGammaDistribution(
double alpha, double beta);
public abstract TDistribution createTDistribution(double degreesOfFreedom);
public abstract HypergeometricDistribution
createHypergeometricDistribution(int populationSize,
int numberOfSuccesses, int sampleSize);
public abstract NormalDistribution 
createNormalDistribution(double mean, double sd);
public abstract NormalDistribution createNormalDistribution();
public abstract PoissonDistribution 
createPoissonDistribution(double lambda);
public WeibullDistribution createWeibullDistribution(
double alpha, double beta)
return new WeibullDistributionImpl(alpha, beta);
package org.apache.commons.math.distribution;
public class DistributionFactoryImpl extends DistributionFactory {
public DistributionFactoryImpl() {
super();
public ChiSquaredDistribution createChiSquareDistribution(
final double degreesOfFreedom) {
return new ChiSquaredDistributionImpl(degreesOfFreedom);
public GammaDistribution createGammaDistribution(
double alpha, double beta) {
return new GammaDistributionImpl(alpha, beta);
public TDistribution createTDistribution(double degreesOfFreedom) {
return new TDistributionImpl(degreesOfFreedom);
public FDistribution createFDistribution(
double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
return new FDistributionImpl(numeratorDegreesOfFreedom,
denominatorDegreesOfFreedom);
public ExponentialDistribution createExponentialDistribution(double mean) {
return new ExponentialDistributionImpl(mean);
}    
public BinomialDistribution createBinomialDistribution(
int numberOfTrials, double probabilityOfSuccess) {
return new BinomialDistributionImpl(numberOfTrials,
probabilityOfSuccess);
public HypergeometricDistribution createHypergeometricDistribution(
int populationSize, int numberOfSuccesses, int sampleSize) {
return new HypergeometricDistributionImpl(populationSize,
numberOfSuccesses, sampleSize);
public NormalDistribution createNormalDistribution(double mean, double sd) {
return new NormalDistributionImpl(mean, sd);
public NormalDistribution createNormalDistribution() {
return new NormalDistributionImpl();
public PoissonDistribution  createPoissonDistribution(double lambda) {
return new PoissonDistributionImpl(lambda);
public interface ExponentialDistribution extends ContinuousDistribution {
public class FDistributionImpl extends AbstractContinuousDistribution implements
FDistribution, Serializable {
private static final long serialVersionUID = -8516354193418641566L;
private double numeratorDegreesOfFreedom;
private double denominatorDegreesOfFreedom;
public FDistributionImpl(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom) {
super();
setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);
setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);
public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
} else {
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();
ret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);
return ret;
public double inverseCumulativeProbability(final double p)
throws MathException {
if (p == 0) {
return 0d;
if (p == 1) {
return Double.POSITIVE_INFINITY;
return super.inverseCumulativeProbability(p);
protected double getDomainLowerBound(double p) {
return 0.0;
protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
protected double getInitialDomain(double p) {
double ret = 1.0;
double d = getDenominatorDegreesOfFreedom();
if (d > 2.0) {
ret = d / (d - 2.0);
return ret;
public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.numeratorDegreesOfFreedom = degreesOfFreedom;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {
if (degreesOfFreedom <= 0.0) {
throw new IllegalArgumentException(
"degrees of freedom must be positive.");
this.denominatorDegreesOfFreedom = degreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
public interface GammaDistribution extends ContinuousDistribution {
public interface NormalDistribution extends ContinuousDistribution {
new Object[] { new Integer(maxCostEval) });
return new RealMatrixImpl(jTj).inverse().getData();
new Object[] { new Integer(m), new Integer(p)});
new Object[] { new Double(costRelativeTolerance) });
new Object[] { new Double(parRelativeTolerance) });
new Object[] { new Double(orthoTolerance) });
new Object[] { new Integer(rows), new Integer(cols) });
parameters   = new ArrayList();
measurements = new ArrayList();
List unbound = new ArrayList(parameters.size());
for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {
EstimatedParameter p = (EstimatedParameter) iterator.next();
private final List parameters;
private final List measurements;
public class Fraction extends Number implements Comparable {
private static final long serialVersionUID = -8958519416450949235L;
public int compareTo(Object object) {
Fraction other = (Fraction)object;
double second = other.doubleValue();
new Object[] { new Double(value), new Integer(maxIterations) });
new Object[] { new Double(value), new Long(p), new Long(q) });
public Rotation() {
q0 = 1;
q1 = 0;
q2 = 0;
q3 = 0;
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusI);
Vector3D v2 = applyInverseTo(Vector3D.plusI);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusJ);
Vector3D v2 = applyInverseTo(Vector3D.plusJ);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
Vector3D v1 = applyTo(Vector3D.plusK);
Vector3D v2 = applyInverseTo(Vector3D.plusK);
private final double q0;
private final double q1;
private final double q2;
private final double q3;
private static final long serialVersionUID = 8225864499430109352L;
new RotationOrder("XYZ", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);
new RotationOrder("XZY", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("YXZ", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("YZX", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("ZXY", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("ZYX", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XYX", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);
new RotationOrder("XZX", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);
new RotationOrder("YXY", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);
new RotationOrder("YZY", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);
new RotationOrder("ZXZ", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);
new RotationOrder("ZYZ", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);
public static final Vector3D plusI = new Vector3D(1, 0, 0);
public static final Vector3D minusI = new Vector3D(-1, 0, 0);
public static final Vector3D plusJ = new Vector3D(0, 1, 0);
public static final Vector3D minusJ = new Vector3D(0, -1, 0);
public static final Vector3D plusK = new Vector3D(0, 0, 1);
public static final Vector3D minusK = new Vector3D(0, 0, -1);
public static final Vector3D zero   = new Vector3D(0, 0, 0);
public Vector3D() {
x = 0;
y = 0;
z = 0;
private final double x;
private final double y;
private final double z;
private static final long serialVersionUID = -5721105387745193385L;
private BigDecimal data[][] = null;
private BigDecimal lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);
int nRows = d.length;
int nCols = d[0].length;
int nRows = d.length;
int nCols = d[0].length;
int nRows = v.length;
return new BigMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(m.getEntry(row, col));
return new BigMatrixImpl(outData);
public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].subtract(m.getEntry(row, col));
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].add(d);
return new BigMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];
outData[row][col] = data[row][col].multiply(d);
return new BigMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
BigDecimal[][] outData = new BigDecimal[nRows][nCols];
BigDecimal sum = ZERO;
sum = ZERO;
sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));
outData[row][col] = sum;
return new BigMatrixImpl(outData);
int nRows = getRowDimension();
int nCols = getColumnDimension();
double d[][] = new double[nRows][nCols];
for (int j=0; j<nCols;j++) {
public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,
selectedColumns.length);
BigDecimal[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
BigDecimal[][] out = new BigDecimal[1][ncols]; 
return new BigMatrixImpl(out);
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][1]; 
return new BigMatrixImpl(out);
int ncols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[ncols];
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
BigDecimal[] out = new BigDecimal[nRows];
int nrows = this.getRowDimension();
double[] out = new double[nrows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);
BigDecimal[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createBigIdentityMatrix
(this.getRowDimension()));
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[v.length];
BigDecimal bd[] = new BigDecimal[v.length];
for (int i=0;i<bd.length;i++) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
BigDecimal[] out = new BigDecimal[nCols];
int nRows = this.getRowDimension();
BigMatrix bMatrix = new BigMatrixImpl(b);
BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();
BigDecimal[] out = new BigDecimal[nRows];
BigDecimal bd[] = new BigDecimal[b.length];
for (int i=0;i<bd.length;i++) {
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
BigDecimal[][] bp = new BigDecimal[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);
bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));
BigMatrixImpl outMat = new BigMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
sum = lu[row][col];
sum = sum.subtract(lu[row][i].multiply(lu[i][col]));
lu[row][col] = sum;
lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);
if (i > 0)
if (j > 0)
BigMatrix m = (BigMatrix) object;
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (!data[row][col].equals(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
data[row][col].hashCode();
protected BigMatrix getIdentity(int dimension) {
return MatrixUtils.createBigIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = in.length;
int nCols = in[0].length;
for (int j=0; j < nCols; j++) {
data[i][j] = new BigDecimal(in[i][j]);
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
private static final long serialVersionUID = -1341109412864309526L;
public MatrixIndexException() {
this(null);
RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);
double[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? 1d : 0d;
return out;
int nCols = rowData.length;
double[][] data = new double[1][nCols];
return new RealMatrixImpl(data);
int nCols = rowData.length;
double[][] data = new double[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nCols = rowData.length;
BigDecimal[][] data = new BigDecimal[1][nCols];
return new BigMatrixImpl(data);
int nCols = rowData.length;
String[][] data = new String[1][nCols];
System.arraycopy(rowData, 0, data[0], 0, nCols);
return new BigMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
return new RealMatrixImpl(data);
int nRows = columnData.length;
double[][] data = new double[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
int nRows = columnData.length;
BigDecimal[][] data = new BigDecimal[nRows][1];
return new BigMatrixImpl(data);
String[][] data = new String[nRows][1];
data[row][0] = columnData[row];
return new BigMatrixImpl(data);
BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);
BigDecimal[][] d = out.getDataRef();
for (int col = 0; col < dimension; col++) {
d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;
return out;
public interface QRDecomposition {
public abstract RealMatrix getR();
public abstract RealMatrix getQ();
private double[][] qr;
private int m;
private int n;
m = matrix.getRowDimension();
n = matrix.getColumnDimension();
qr = matrix.getData();
xNormSqr += qr[row][minor]*qr[row][minor];
double a = Math.sqrt(xNormSqr);
if (qr[minor][minor] > 0) a = -a;
qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])
alpha -= qr[row][col]*qr[row][minor];
alpha /= a*qr[minor][minor];
qr[row][col] -= alpha*qr[row][minor];
RealMatrixImpl ret = new RealMatrixImpl(m,n);
double[][] r = ret.getDataRef();
for (int row = Math.min(m,n)-1; row >= 0; row--) {
r[row][row] = rDiag[row];
for (int col = row+1; col < n; col++) {
r[row][col] = qr[row][col];
return ret;
public RealMatrix getQ()
RealMatrixImpl ret = new RealMatrixImpl(m,m);
double[][] Q = ret.getDataRef();
for (int minor = m-1; minor >= Math.min(m,n); minor--) {
Q[minor][minor]=1;
for (int minor = Math.min(m,n)-1; minor >= 0; minor--){
Q[minor][minor] = 1;
if (qr[minor][minor] != 0.0) {
for (int col = minor; col < m; col++) {
double alpha = 0;
for (int row = minor; row < m; row++) {
alpha -= Q[row][col] * qr[row][minor];
alpha /= rDiag[minor]*qr[minor][minor];
for (int row = minor; row < m; row++) {
Q[row][col] -= alpha*qr[row][minor];
return ret;
private static final long serialVersionUID = 4237564493130426188L;
private double data[][] = null;
private double lu[][] = null;
private int[] permutation = null;
private int parity = 1;
protected static double TOO_SMALL = 10E-12;
this.copyIn(d);
int nRows = v.length;
return new RealMatrixImpl(this.copyOut());
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + m.getEntry(row, col);
return new RealMatrixImpl(outData);
if (this.getColumnDimension() != m.getColumnDimension() ||
this.getRowDimension() != m.getRowDimension()) {
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] - m.getEntry(row, col);
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] + d;
return new RealMatrixImpl(outData);
int rowCount = this.getRowDimension();
int columnCount = this.getColumnDimension();
double[][] outData = new double[rowCount][columnCount];
outData[row][col] = data[row][col] * d;
return new RealMatrixImpl(outData);
int nRows = this.getRowDimension();
int nCols = m.getColumnDimension();
int nSum = this.getColumnDimension();
double[][] outData = new double[nRows][nCols];
double sum = 0;
sum = 0;
sum += data[row][i] * m.getEntry(i, col);
outData[row][col] = sum;
return new RealMatrixImpl(outData);
public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,
int endColumn) throws MatrixIndexException {
endColumn > data[0].length ) {
RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,
endColumn - startColumn+1);
double[][] subMatrixData = subMatrix.getDataRef();
for (int j = startColumn; j <= endColumn; j++) {
subMatrixData[i - startRow][j - startColumn] = data[i][j];
return subMatrix;
throws MatrixIndexException {
RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,
selectedColumns.length);
double[][] subMatrixData = subMatrix.getDataRef();
subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];
catch (ArrayIndexOutOfBoundsException e) {
return subMatrix;
int nRows = subMatrix.length;
int nCols = subMatrix[0].length;
int ncols = this.getColumnDimension();
double[][] out = new double[1][ncols]; 
return new RealMatrixImpl(out);
int nRows = this.getRowDimension();
double[][] out = new double[nRows][1]; 
return new RealMatrixImpl(out);
int ncols = this.getColumnDimension();
double[] out = new double[ncols];
int nRows = this.getRowDimension();
double[] out = new double[nRows];
if (!isValidCoordinate(row,column)) {
return data[row][column];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);
double[][] outData = out.getDataRef();
outData[col][row] = data[row][col];
return out;
return solve(MatrixUtils.createRealIdentityMatrix
(this.getRowDimension()));
if (v.length != this.getColumnDimension()) {
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[v.length];
sum += data[row][i] * v[i];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
double[] out = new double[nCols];
int nRows = this.getRowDimension();
RealMatrix bMatrix = new RealMatrixImpl(b);
double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();
double[] out = new double[nRows];
out[row] = solution[row][0];
return out;
int nCol = this.getColumnDimension();
int nColB = b.getColumnDimension();
int nRowB = b.getRowDimension();
double[][] bp = new double[nRowB][nColB];
bp[row][col] = b.getEntry(permutation[row], col);
bp[i][j] -= bp[col][j] * lu[i][col];
bp[col][j] /= lu[col][col];
bp[i][j] -= bp[col][j] * lu[i][col];
RealMatrixImpl outMat = new RealMatrixImpl(bp);
return outMat;
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
lu = this.getData();
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
sum = lu[row][col];
sum -= lu[row][i] * lu[i][col];
lu[row][col] = sum;
lu[row][col] /= lu[col][col];
if (i > 0)
if (j > 0)
int nRows = getRowDimension();
int nCols = getColumnDimension();
if (Double.doubleToLongBits(data[row][col]) != 
Double.doubleToLongBits(m.getEntry(row, col))) {
int nRows = getRowDimension();
int nCols = getColumnDimension();
for (int col = 0; col < nCols; col++) {
MathUtils.hash(data[row][col]);
protected RealMatrix getIdentity(int dimension) {
return MatrixUtils.createRealIdentityMatrix(dimension);
int[] out = new int[permutation.length];
int nRows = this.getRowDimension();
double[][] out = new double[nRows][this.getColumnDimension()];
int nRows = this.getRowDimension();
int nCols = this.getColumnDimension();
package org.apache.commons.math.ode;
previousTime      = Double.NaN;
currentTime       = Double.NaN;
h                 = Double.NaN;
interpolatedTime  = Double.NaN;
currentState      = null;
interpolatedState = null;
finalized         = false;
this.forward      = true;
protected AbstractStepInterpolator(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {
currentState      = (double[]) interpolator.currentState.clone();
interpolatedState = (double[]) interpolator.interpolatedState.clone();
currentState      = null;
interpolatedState = null;
protected void reinitialize(double[] y, boolean forward) {
currentState      = y;
interpolatedState = new double[y.length];
public void storeTime(double t) {
public void setInterpolatedTime(double time)
throws DerivativeException {
interpolatedTime = time;
double oneMinusThetaH = currentTime - interpolatedTime;
computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);
return (double[]) interpolatedState.clone();
protected void writeBaseExternal(ObjectOutput out)
protected double readBaseExternal(ObjectInput in)
int dimension = in.readInt();
interpolatedTime  = Double.NaN;
interpolatedState = new double[dimension];
package org.apache.commons.math.ode;
implements FirstOrderIntegrator {
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
this.minStep     = minStep;
this.maxStep     = maxStep;
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public AdaptiveStepsizeIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
handler = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
public void setInitialStepSize(double initialStepSize) {
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
protected void sanityChecks(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y.length)
});
new Integer(y0.length),
new Integer(vecAbsoluteTolerance.length)
new Integer(y0.length),
new Integer(vecRelativeTolerance.length)
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] { new Double(Math.abs(t - t0)) });
public double initializeStep(FirstOrderDifferentialEquations equations,
boolean forward, int order, double[] scale,
double t0, double[] y0, double[] yDot0,
double[] y1, double[] yDot1)
throws DerivativeException {
double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);
double h1 = (maxInv2 < 1.0e-15) ?
Math.max(1.0e-6, 0.001 * Math.abs(h)) :
Math.pow(0.01 / maxInv2, 1.0 / order);
protected double filterStep(double h, boolean acceptSmall)
if (Math.abs(h) < minStep) {
if (acceptSmall) {
h = (h < 0) ? -minStep : minStep;
} else {
throw new IntegratorException("minimal step size ({0}) reached," +
" integration needs {1}",
new Object[] {
new Double(minStep),
new Double(Math.abs(h))
});
if (h > maxStep) {
h = maxStep;
} else if (h < -maxStep) {
h = -maxStep;
return h;
public abstract void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public double getCurrentSignedStepsize() {
return stepSize;
protected StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
protected double stepStart;
protected double stepSize;
package org.apache.commons.math.ode;
private static final String methodName = "classical Runge-Kutta";
public ClassicalRungeKuttaIntegrator(double step) {
super(c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
class ClassicalRungeKuttaStepInterpolator
extends RungeKuttaStepInterpolator {
public ClassicalRungeKuttaStepInterpolator() {
public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {
super(interpolator);
protected StepInterpolator doCopy() {
return new ClassicalRungeKuttaStepInterpolator(this);
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double coeff1    = s * ((-fourTheta + 5) * theta - 1);
double coeff23   = s * (( fourTheta - 2) * theta - 2);
double coeff4    = s * ((-fourTheta - 1) * theta - 1);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i] +
coeff1  * yDotK[0][i] +
coeff23 * (yDotK[1][i] + yDotK[2][i]) +
coeff4  * yDotK[3][i];
private static final long serialVersionUID = -6576285612589783992L;
steps = new ArrayList();
public void append(ContinuousOutputModel model)
StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);
double current  = lastInterpolator.getCurrentTime();
double previous = lastInterpolator.getPreviousTime();
double step = current - previous;
double gap = model.getInitialTime() - current;
for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {
steps.add(((AbstractStepInterpolator) iter.next()).copy());
public void handleStep(StepInterpolator interpolator, boolean isLast)
AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;
steps.add(ai.copy());
finalTime = ai.getCurrentTime();
return ((StepInterpolator) steps.get(index)).getInterpolatedTime();
public void setInterpolatedTime(double time) {
StepInterpolator sMin = (StepInterpolator) steps.get(iMin);
StepInterpolator sMax = (StepInterpolator) steps.get(iMax);
StepInterpolator si = (StepInterpolator) steps.get(index);
int location = locatePoint(time, si);
int iMed = (iMin + iMax) / 2;
StepInterpolator sMed = (StepInterpolator) steps.get(iMed);
double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());
double d12 = tMax - tMed;
double d23 = tMed - tMin;
double d13 = tMax - tMin;
double dt1 = time - tMax;
double dt2 = time - tMed;
double dt3 = time - tMin;
double iLagrange = ((dt2 * dt3 * d23) * iMax -
(dt1 * dt3 * d13) * iMed +
(dt1 * dt2 * d12) * iMin) /
(d12 * d23 * d13);
int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);
int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);
while ((index <= iMax) &&
(locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {
StepInterpolator si = (StepInterpolator) steps.get(index);
si.setInterpolatedTime(time);
return ((StepInterpolator) steps.get(index)).getInterpolatedState();
private int locatePoint(double time, StepInterpolator interval) {
private List steps;
private static final long serialVersionUID = 2259286184268533249L;
public DerivativeException(String specifier, String[] parts) {
public DerivativeException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 5(4)";
public DormandPrince54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public DormandPrince54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +
e4 * yDotK[3][j] +  e5 * yDotK[4][j] +
e6 * yDotK[5][j] +  e7 * yDotK[6][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
error += ratio * ratio;
package org.apache.commons.math.ode;
public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i] +
a74 * yDotK[4][i] + a75 * yDotK[5][i]);
v2[i] = h * yDotK[0][i] - v1[i];
v3[i] = v1[i] - v2[i] - h * yDotK[6][i];
v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i] +
d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);
double eta = oneMinusThetaH / h;
interpolatedState[i] = currentState[i] -
eta * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));
package org.apache.commons.math.ode;
private static final String methodName = "Dormand-Prince 8 (5, 3)";
public DormandPrince853Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(true, staticC, staticA, staticB,
public DormandPrince853Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(true, staticC, staticA, staticB,
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +
e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +
e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +
e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];
double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +
e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +
e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +
e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio1  = errSum1 / tol;
double ratio2  = errSum2 / tol;
package org.apache.commons.math.ode;
public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {
int dimension = interpolator.currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
int dimension = currentState.length;
public void storeTime(double t) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i] +
b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i] +
b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);
v[1][i] = h * yDotK[0][i] - v[0][i];
v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];
for (int k = 0; k < d.length; ++k) {
v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i] +
d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i] +
d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i] +
d[k][9]  * yDotKLast[0][i] +
d[k][10] * yDotKLast[1][i] +
d[k][11] * yDotKLast[2][i]);
double eta = oneMinusThetaH / h;
interpolatedState[i] =
currentState[i] - eta * (v[0][i] - theta * (v[1][i] +
theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] +
eta * (v[5][i] + theta * (v[6][i])))))));
double[] yTmp = new double[currentState.length];
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
int dimension = in.readInt();
package org.apache.commons.math.ode;
public void handleStep(StepInterpolator interpolator, boolean isLast) {
package org.apache.commons.math.ode;
protected DummyStepInterpolator(double[] y, boolean forward) {
public DummyStepInterpolator(DummyStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta, double oneMinusThetaH)
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
package org.apache.commons.math.ode;
protected EmbeddedRungeKuttaIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
protected EmbeddedRungeKuttaIntegrator(boolean fsal,
double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double   minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
public abstract String getName();
public void setSafety(double safety) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
boolean forward = (t > t0);
int stages = c.length + 1;
double[][] yDotK = new double[stages][];
double[] yTmp = new double[y0.length];
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
stepStart  = t0;
boolean lastStep;
handler.reset();
do {
double[] scale;
if ((forward && (stepStart + stepSize > t)) ||
((! forward) && (stepStart + stepSize < t))) {
stepSize = t - stepStart;
if (switchesHandler.evaluateStep(interpolator)) {
hNew = switchesHandler.getEventTime() - stepStart;
double factor = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
hNew = filterStep(stepSize * factor, false);
double nextStep = stepStart + stepSize;
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
lastStep = true;
} else {
lastStep = forward ? (nextStep >= t) : (nextStep <= t);
handler.handleStep(interpolator, lastStep);
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
double  factor     = Math.min(maxGrowth,
Math.max(minReduction,
safety * Math.pow(error, exp)));
double  scaledH    = stepSize * factor;
double  nextT      = stepStart + scaledH;
boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, nextIsLast);
} while (! lastStep);
public void setMinReduction(double minReduction) {
public void setMaxGrowth(double maxGrowth) {
package org.apache.commons.math.ode;
private static final String methodName = "Euler";
public EulerIntegrator(double step) {
super(c, a, b, new EulerStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public EulerStepInterpolator(EulerStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
private static final long serialVersionUID = -7179861704951334960L;
public FirstOrderConverter (SecondOrderDifferentialEquations equations) {
public void computeDerivatives(double t, double[] y, double[] yDot)
throws DerivativeException {
public interface FirstOrderDifferentialEquations {
public interface FirstOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount);
public void integrate (FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
public double getCurrentStepStart();
public double getCurrentSignedStepsize();
package org.apache.commons.math.ode;
public interface FixedStepHandler {
public void handleStep(double t, double[] y, boolean isLast);
package org.apache.commons.math.ode;
private static final String methodName = "Gill";
public GillIntegrator(double step) {
super(c, a, b, new GillStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public GillStepInterpolator(GillStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double fourTheta = 4 * theta;
double s         = oneMinusThetaH / 6.0;
double soMt      = s * (1 - theta);
double c23       = soMt * (1 + 2 * theta);
double coeff1    = soMt * (1 - fourTheta);
double coeff2    = c23  * tMq;
double coeff3    = c23  * tPq;
double coeff4    = s * (1 + theta * (1 + fourTheta));
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
package org.apache.commons.math.ode;
private static final String methodName = "Gragg-Bulirsch-Stoer";
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public GraggBulirschStoerIntegrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public void setStabilityCheck(boolean performTest,
int maxIter, int maxChecks,
double stabilityReduction) {
public void setStepsizeControl(double stepControl1, double stepControl2,
double stepControl3, double stepControl4) {
public void setOrderControl(int maxOrder,
double orderControl1, double orderControl2) {
public void setStepHandler (StepHandler handler) {
super.setStepHandler(handler);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
super.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);
denseOutput = (handler.requiresDenseOutput() || (! switchesHandler.isEmpty()));
int size = maxOrder / 2;
double ratio = ((double) sequence[k]) / sequence[k-l-1];
public void setInterpolationControl(boolean useInterpolationError,
int mudif) {
public String getName() {
return methodName;
private void rescale(double[] y1, double[] y2, double[] scale) {
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));
private boolean tryStep(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double step, int k,
double[] scale, double[][] f,
double[] yMiddle, double[] yEnd,
double[] yTmp)
int    n        = sequence[k];
double subStep  = step / n;
double subStep2 = 2 * subStep;
double middle = yEnd[i];
double ratio = f[0][l] / scale[l];
double ratio = (f[j+1][l] - f[0][l]) / scale[l];
private void extrapolate(int offset, int k, double[][] diag, double[] last) {
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
boolean forward = (t > t0);
double[] yDot0   = new double[y0.length];
double[] y1      = new double[y0.length];
double[] yTmp    = new double[y0.length];
double[] yTmpDot = new double[y0.length];
double[][] diagonal = new double[sequence.length-1][];
double[][] y1Diag = new double[sequence.length-1][];
double[][][] fk  = new double[sequence.length][][];
double[] scale = new double[y0.length];
double tol =
double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);
if (denseOutput || (! switchesHandler.isEmpty())) {
handler.reset();
double nextT = stepStart + stepSize;
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
hNew   = Math.abs(filterStep(stepSize * stabilityReduction, false));
double exp = 1.0 / (2 * k + 1);
double pow = Math.pow(stepControl3, exp);
optimalStep[k]     = Math.abs(filterStep(stepSize * fac, true));
double ratio = ((double) sequence [k] * sequence[k+1]) /
(sequence[0] * sequence[0]);
double ratio = ((double) sequence[k+1]) / sequence[0];
int mu = 2 * k - mudif + 3;
int l2 = l / 2;
GraggBulirschStoerStepInterpolator gbsInterpolator
double interpError = gbsInterpolator.estimateError(scale);
if (switchesHandler.evaluateStep(interpolator)) {
hNew = Math.abs(switchesHandler.getEventTime() - stepStart);
double nextStep = stepStart + stepSize;
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
handler.handleStep(interpolator, lastStep);
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter+1] / costPerStep[k],
false);
hNew = filterStep(optimalStep[k] *
costPerStep[optimalIter] / costPerStep[k],
false);
package org.apache.commons.math.ode;
private void resetTables(int maxDegree) {
double[][] newPols = new double[maxDegree + 1][];
int ip5 = i + 5;
double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);
public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,
double[] y1, double[] y1Dot,
double[][] yMidDots,
boolean forward) {
(GraggBulirschStoerStepInterpolator interpolator) {
int dimension = currentState.length;
public void computeCoefficients(int mu, double h) {
double yp0   = h * y0Dot[i];
double yp1   = h * y1Dot[i];
double ydiff = y1[i] - currentState[i];
double aspl  = ydiff - yp1;
double bspl  = yp0 - ydiff;
double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);
double ph1 = ydiff + 0.25 * (aspl - bspl);
double ph2 = yp1 - yp0;
double ph3 = 6 * (bspl - aspl);
double fac1 = 0.5 * j * (j - 1);
double fac2 = 2 * fac1 * (j - 2) * (j - 3);
public double estimateError(double[] scale) {
double e = polynoms[currentDegree][i] / scale[i];
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
int dimension = currentState.length;
double oneMinusTheta = 1.0 - theta;
double theta05       = theta - 0.5;
double t4            = theta * oneMinusTheta;
t4 = t4 * t4;
interpolatedState[i] = polynoms[0][i] +
theta * (polynoms[1][i] +
oneMinusTheta * (polynoms[2][i] * theta +
polynoms[3][i] * oneMinusTheta));
if (currentDegree > 3) {
double c = polynoms[currentDegree][i];
for (int j = currentDegree - 1; j > 3; --j) {
c = polynoms[j][i] + c * theta05 / (j - 3);
interpolatedState[i] += t4 * c;
public void writeExternal(ObjectOutput out)
int dimension = currentState.length;
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int dimension = currentState.length;
int degree = in.readInt();
package org.apache.commons.math.ode;
private static final String methodName = "Higham-Hall 5(4)";
public HighamHall54Integrator(double minStep, double maxStep,
double scalAbsoluteTolerance,
double scalRelativeTolerance) {
super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public HighamHall54Integrator(double minStep, double maxStep,
double[] vecAbsoluteTolerance,
double[] vecRelativeTolerance) {
super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),
public String getName() {
return methodName;
protected double estimateError(double[][] yDotK,
double[] y0, double[] y1,
double h) {
double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));
double tol = (vecAbsoluteTolerance == null) ?
(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :
(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);
double ratio  = h * errSum / tol;
package org.apache.commons.math.ode;
public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double theta2 = theta * theta;
double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));
double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));
double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));
double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));
double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));
interpolatedState[i] = currentState[i] +
b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i] +
b4 * yDotK[4][i] + b5 * yDotK[5][i];
public IntegratorException(String specifier, Object[] parts) {
public IntegratorException(Throwable cause) {
package org.apache.commons.math.ode;
private static final String methodName = "midpoint";
public MidpointIntegrator(double step) {
super(c, a, b, new MidpointStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
double coeff1 = oneMinusThetaH * theta;
double coeff2 = oneMinusThetaH * (1.0 + theta);
interpolatedState[i] = currentState[i] +
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];
package org.apache.commons.math.ode;
public abstract class RungeKuttaIntegrator
implements FirstOrderIntegrator {
protected RungeKuttaIntegrator(double[] c, double[][] a, double[] b,
RungeKuttaStepInterpolator prototype,
double step) {
this.c          = c;
this.a          = a;
this.b          = b;
this.prototype  = prototype;
this.step       = step;
handler         = DummyStepHandler.getInstance();
switchesHandler = new SwitchingFunctionsHandler();
resetInternalState();
public abstract String getName();
public void setStepHandler (StepHandler handler) {
this.handler = handler;
public StepHandler getStepHandler() {
return handler;
public void addSwitchingFunction(SwitchingFunction function,
double maxCheckInterval,
double convergence,
int maxIterationCount) {
switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);
private void sanityChecks(FirstOrderDifferentialEquations equations,
double t0, double[] y0, double t, double[] y)
throws IntegratorException {
if (equations.getDimension() != y0.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y0.length)
});
if (equations.getDimension() != y.length) {
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
new Integer(equations.getDimension()),
new Integer(y.length)
});
if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] { new Double(Math.abs(t - t0)) });
}      
public void integrate(FirstOrderDifferentialEquations equations,
double t0, double[] y0,
double t, double[] y)
throws DerivativeException, IntegratorException {
sanityChecks(equations, t0, y0, t, y);
boolean forward = (t > t0);
int stages = c.length + 1;
if (y != y0) {
System.arraycopy(y0, 0, y, 0, y0.length);
double[][] yDotK = new double[stages][];
for (int i = 0; i < stages; ++i) {
yDotK [i] = new double[y0.length];
double[] yTmp = new double[y0.length];
AbstractStepInterpolator interpolator;
if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {
RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
rki.reinitialize(equations, yTmp, yDotK, forward);
interpolator = rki;
} else {
interpolator = new DummyStepInterpolator(yTmp, forward);
interpolator.storeTime(t0);
long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));
boolean lastStep  = false;
stepStart = t0;
stepSize  = (t - t0) / nbStep;
handler.reset();
for (long i = 0; ! lastStep; ++i) {
interpolator.shift();
boolean needUpdate = false;
for (boolean loop = true; loop;) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
for (int k = 1; k < stages; ++k) {
for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
yTmp[j] = y[j] + stepSize * sum;
interpolator.storeTime(stepStart + stepSize);
if (switchesHandler.evaluateStep(interpolator)) {
needUpdate = true;
stepSize = switchesHandler.getEventTime() - stepStart;
} else {
loop = false;
double nextStep = stepStart + stepSize;
System.arraycopy(yTmp, 0, y, 0, y0.length);
switchesHandler.stepAccepted(nextStep, y);
if (switchesHandler.stop()) {
lastStep = true;
} else {
lastStep = (i == (nbStep - 1));
interpolator.storeTime(nextStep);
handler.handleStep(interpolator, lastStep);
stepStart = nextStep;
if (switchesHandler.reset(stepStart, y) && ! lastStep) {
equations.computeDerivatives(stepStart, y, yDotK[0]);
if (needUpdate) {
nbStep = Math.max(1l, Math.abs(Math.round((t - stepStart) / step)));
stepSize = (t - stepStart) / nbStep;
i = -1;
resetInternalState();
public double getCurrentStepStart() {
return stepStart;
public double getCurrentSignedStepsize() {
return stepSize;
private void resetInternalState() {
stepStart = Double.NaN;
stepSize  = Double.NaN;
private double[] c;
private double[][] a;
private double[] b;
private RungeKuttaStepInterpolator prototype;
private double step;
private StepHandler handler;
protected SwitchingFunctionsHandler switchesHandler;
private double stepStart;
private double stepSize;
package org.apache.commons.math.ode;
public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {
int dimension = currentState.length;
public void reinitialize(FirstOrderDifferentialEquations equations,
double[] y, double[][] yDotK, boolean forward) {
public void writeExternal(ObjectOutput out)
public void readExternal(ObjectInput in)
double t = readBaseExternal(in);
int kMax = in.readInt();
public interface SecondOrderIntegrator {
public String getName();
public void setStepHandler (StepHandler handler);
public StepHandler getStepHandler();
package org.apache.commons.math.ode;
public interface StepHandler {
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
public class StepNormalizer
implements StepHandler {
public StepNormalizer(double h, FixedStepHandler handler) {
this.h       = Math.abs(h);
this.handler = handler;
reset();
public boolean requiresDenseOutput() {
return true;
public void reset() {
lastTime  = Double.NaN;
lastState = null;
forward   = true;
public void handleStep(StepInterpolator interpolator, boolean isLast)
throws DerivativeException {
double nextTime;
if (lastState == null) {
lastTime = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(lastTime);
double[] state = interpolator.getInterpolatedState();
lastState = (double[]) state.clone();
forward = (interpolator.getCurrentTime() >= lastTime);
if (! forward) {
h = -h;
nextTime = lastTime + h;
boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
while (nextInStep) {
handler.handleStep(lastTime, lastState, false);
lastTime = nextTime;
interpolator.setInterpolatedTime(lastTime);
System.arraycopy(interpolator.getInterpolatedState(), 0,
lastState, 0, lastState.length);
nextTime  += h;
nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());
if (isLast) {
handler.handleStep(lastTime, lastState, true);
private double h;
private FixedStepHandler handler;
private double lastTime;
private double[] lastState;
private boolean forward;
package org.apache.commons.math.ode;
class SwitchState implements Serializable {
private static final long serialVersionUID = -7307007422156119622L;
private SwitchingFunction function;
private double maxCheckInterval;
private double convergence;
private int maxIterationCount;
private double t0;
private double g0;
private boolean g0Positive;
private boolean pendingEvent;
private double pendingEventTime;
private double previousEventTime;
private boolean increasing;
private int nextAction;
public SwitchState(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
this.function          = function;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = SwitchingFunction.CONTINUE;
public void reinitializeBegin(double t0, double[] y0)
throws FunctionEvaluationException {
this.t0 = t0;
g0 = function.g(t0, y0);
g0Positive = (g0 >= 0);
public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, FunctionEvaluationException, ConvergenceException {
double t1 = interpolator.getCurrentTime();
int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
double h  = (t1 - t0) / n;
double ta = t0;
double ga = g0;
double tb = t0 + ((t1 > t0) ? convergence : -convergence);
for (int i = 0; i < n; ++i) {
tb += h;
interpolator.setInterpolatedTime(tb);
double gb = function.g(tb, interpolator.getInterpolatedState());
if (g0Positive ^ (gb >= 0)) {
increasing = (gb >= ga);
UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {
public double value(double t) throws FunctionEvaluationException {
interpolator.setInterpolatedTime(t);
return function.g(t, interpolator.getInterpolatedState());
} catch (DerivativeException e) {
throw new FunctionEvaluationException(t, e);
});
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(maxIterationCount);
double root = solver.solve(ta, tb);
if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
return false;
pendingEvent = true;
return true;
} else {
ta = tb;
ga = gb;
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;
} catch (FunctionEvaluationException e) {
Throwable cause = e.getCause();
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
throw e;
public double getEventTime() {
return pendingEventTime;
public void stepAccepted(double t, double[] y)
throws FunctionEvaluationException {
t0 = t;
g0 = function.g(t, y);
if (pendingEvent) {
previousEventTime = t;
g0Positive        = increasing;
nextAction        = function.eventOccurred(t, y);
} else {
g0Positive = (g0 >= 0);
nextAction = SwitchingFunction.CONTINUE;
public boolean stop() {
return nextAction == SwitchingFunction.STOP;
public boolean reset(double t, double[] y) {
if (! pendingEvent) {
return false;
if (nextAction == SwitchingFunction.RESET_STATE) {
function.resetState(t, y);
pendingEvent      = false;
pendingEventTime  = Double.NaN;
return (nextAction == SwitchingFunction.RESET_STATE) ||
(nextAction == SwitchingFunction.RESET_DERIVATIVES);
package org.apache.commons.math.ode;
public interface SwitchingFunction extends Serializable {
public double g(double t, double[] y) throws FunctionEvaluationException;
public int eventOccurred(double t, double[] y);
public void resetState(double t, double[] y);
package org.apache.commons.math.ode;
public class SwitchingFunctionsHandler {
public SwitchingFunctionsHandler() {
functions   = new ArrayList();
first       = null;
initialized = false;
public void add(SwitchingFunction function, double maxCheckInterval,
double convergence, int maxIterationCount) {
functions.add(new SwitchState(function, maxCheckInterval,
convergence, maxIterationCount));
public boolean isEmpty() {
return functions.isEmpty();
public boolean evaluateStep(StepInterpolator interpolator)
throws DerivativeException, IntegratorException {
first = null;
if (functions.isEmpty()) {
return false;
if (! initialized) {
double t0 = interpolator.getPreviousTime();
interpolator.setInterpolatedTime(t0);
double [] y = interpolator.getInterpolatedState();
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).reinitializeBegin(t0, y);
initialized = true;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
SwitchState state = (SwitchState) iter.next();
if (state.evaluateStep(interpolator)) {
if (first == null) {
first = state;
} else {
if (interpolator.isForward()) {
if (state.getEventTime() < first.getEventTime()) {
first = state;
} else {
if (state.getEventTime() > first.getEventTime()) {
first = state;
return first != null;
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
} catch (ConvergenceException ce) {
throw new IntegratorException(ce);
public double getEventTime() {
return (first == null) ? Double.NaN : first.getEventTime();
public void stepAccepted(double t, double[] y)
throws IntegratorException {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
((SwitchState) iter.next()).stepAccepted(t, y);
} catch (FunctionEvaluationException fee) {
throw new IntegratorException(fee);
public boolean stop() {
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).stop()) {
return true;
return false;
public boolean reset(double t, double[] y) {
boolean resetDerivatives = false;
for (Iterator iter = functions.iterator(); iter.hasNext();) {
if (((SwitchState) iter.next()).reset(t, y)) {
resetDerivatives = true;
return resetDerivatives;
private List functions;
private SwitchState first;
private boolean initialized;
package org.apache.commons.math.ode;
private static final String methodName = "3/8";
public ThreeEighthesIntegrator(double step) {
super(c, a, b, new ThreeEighthesStepInterpolator(), step);
public String getName() {
return methodName;
package org.apache.commons.math.ode;
public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {
protected void computeInterpolatedState(double theta,
double oneMinusThetaH)
throws DerivativeException {
double fourTheta2 = 4 * theta * theta;
double s          = oneMinusThetaH / 8.0;
double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);
double coeff2     = 3 * s * (1 + theta - fourTheta2);
double coeff3     = 3 * s * (1 + theta);
double coeff4     = s * (1 + theta + fourTheta2);
for (int i = 0; i < interpolatedState.length; ++i) {
interpolatedState[i] = currentState[i] -
coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i] -
coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];
private static Comparator pointCostPairComparator = new Comparator() {
public int compare(Object o1, Object o2) {
double cost1 = ((PointCostPair) o1).getCost();
double cost2 = ((PointCostPair) o2).getCost();
return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);
System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);
List getBinStats();
private static final long serialVersionUID = -6773236347582113490L;
private List binStats = null;
binStats = new ArrayList();
binStats = new ArrayList();
SummaryStatistics stats =
(SummaryStatistics) binStats.get(findBin(min, val, delta));
val = new Double(str).doubleValue();
(SummaryStatistics) binStats.get(
findBin(min, inputArray[i], delta));
double delta = (max - min)/(new Double(binCount)).doubleValue();
((double)((SummaryStatistics)binStats.get(0)).getN())/
(double)sampleStats.getN();
((double)((SummaryStatistics)binStats.get(i)).getN())/
(double)sampleStats.getN();
SummaryStatistics stats = (SummaryStatistics)binStats.get(i);
public List getBinStats() {
Object[] nextSample(Collection c, int k);
Integer c = new Integer(randomBytes[i]);
Integer c = new Integer(hash[i]);
public Object[] nextSample(Collection c, int k) {
obj = new Long(((Integer) v).longValue());
freqTable.put(obj, new Long(1));
freqTable.put(obj, new Long(count.longValue() + 1));
addValue(new Long(v));
addValue(new Long(v.longValue()));
addValue(new Long(v));
addValue(new Character(v));
return getCount(new Long(v));
return getCount(new Long(v));
return getCount(new Character(v));
return getPct(new Long(v));       
return getPct(new Long(v));         
return getPct(new Character(v));         
return getCumFreq(new Long(v));       
return getCumFreq(new Long(v));         
return getCumFreq(new Character(v));         
return getCumPct(new Long(v));       
return getCumPct(new Long(v));         
return getCumPct(new Character(v));         
private static final long serialVersionUID = -2734185686570407433L;
public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (DescriptiveStatistics)cls.newInstance();
public static DescriptiveStatistics newInstance() {
DescriptiveStatistics factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (DescriptiveStatistics) dc.newInstance(
DescriptiveStatistics.class,
"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl");
} catch(Throwable t) {
return new DescriptiveStatisticsImpl();
return factory;
new Object[] {new Double(p)});
new Object[] {new Double(50.0d)});
package org.apache.commons.math.stat.descriptive;
public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {
private static final long serialVersionUID = -6467796944112488424L;
public DescriptiveStatisticsImpl() {
super();
public DescriptiveStatisticsImpl(int window) {
super(window);
public void clear() {
super.clear();
private static final long serialVersionUID = -3346512372447011854L;
public static SummaryStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {
return (SummaryStatistics)cls.newInstance();
public static SummaryStatistics newInstance() {
SummaryStatistics instance = null;
DiscoverClass dc = new DiscoverClass();
instance = (SummaryStatistics)dc.newInstance(SummaryStatistics.class, "org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl");
} catch (Throwable t) {
return new SummaryStatisticsImpl();
return instance;
return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())
&& MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())
&& MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),
package org.apache.commons.math.stat.descriptive;
public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {
private static final long serialVersionUID = 8528794411480425963L;
public SummaryStatisticsImpl() {
super();
public void clear() {
super.clear();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
public double anovaFValue(Collection categoryData)
public double anovaPValue(Collection categoryData)
public boolean anovaTest(Collection categoryData, double alpha)
private AnovaStats anovaStats(Collection categoryData)
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] array;
array = (double[])iterator.next();
} catch (ClassCastException ex) {
throw new IllegalArgumentException(
"ANOVA: categoryData contains non-double[] elements.");
for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {
double[] data = (double[])iterator.next();
protected DistributionFactory getDistributionFactory() {
return DistributionFactory.newInstance();
package org.apache.commons.math.stat.inference;
public abstract class TestFactory {
protected TestFactory() {
super();
public static TestFactory newInstance() {
TestFactory factory = null;
DiscoverClass dc = new DiscoverClass();
factory = (TestFactory) dc.newInstance(
TestFactory.class,
"org.apache.commons.math.stat.inference.TestFactoryImpl");
} catch(Throwable t) {
return new TestFactoryImpl();
return factory;
public abstract TTest createTTest();
public abstract ChiSquareTest createChiSquareTest();  
package org.apache.commons.math.stat.inference;
public class TestFactoryImpl extends TestFactory {
public TestFactoryImpl() {
super();
public TTest createTTest() {       
return new TTestImpl();
public ChiSquareTest createChiSquareTest() { 
return new ChiSquareTestImpl();
public static double oneWayAnovaFValue(Collection categoryData)
public static double oneWayAnovaPValue(Collection categoryData)
public static boolean oneWayAnovaTest(Collection categoryData, double alpha)
new Object[] { new Double(x) });
new Object[] { new Double(x) });
return new Double(o.toString()).doubleValue();
private static final long serialVersionUID = -942772950698439883L;
private Map map = null;
map = new HashMap();
public boolean containsClass(Class key) {
public NumberTransformer getTransformer(Class key) {
public Object putTransformer(Class key, NumberTransformer transformer) {
public Object removeTransformer(Class key) {
public Set classes() {
public Collection transformers() {
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(newA);
return new Double(new double[] { 0.0 });
return new Double(newA);
return new Double();
return new Double(newA);
public HarmonicFitter(int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public HarmonicFitter(EstimatedParameter[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, convergence,
steadyStateThreshold, epsilon));
public PolynomialFitter(int degree,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(degree,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
public PolynomialFitter(PolynomialCoefficient[] coefficients,
int maxIterations, double convergence,
double steadyStateThreshold, double epsilon) {
this(coefficients,
new GaussNewtonEstimator(maxIterations, steadyStateThreshold,
convergence, epsilon));
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Double(0.0) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
Object[] arguments = { new Integer(6), new Integer(4) };
new Object[] { new Double(1234567) });
ComplexFormat complexFormat = null;
ComplexFormat cf = ComplexFormat.getInstance(getLocale());
Double pi = new Double(Math.PI);
ComplexFormat cf = new ComplexFormat();
assertEquals(w.real, 4.0, 0);
assertTrue(Double.isNaN(w.imaginary));
assertEquals(w.imaginary, 1, 0);
assertEquals(inf, w.real, 0);
assertTrue(Double.isNaN(x.add(z).real));
assertEquals(neginf, z.conjugate().imaginary, 0);
assertEquals(inf, z.conjugate().imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.imaginary));
assertEquals(inf, z.real, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertEquals(inf, z.imaginary, 0);
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertTrue(Double.isNaN(z.real));
assertTrue(Double.isNaN(z.imaginary));
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertEquals(w.real, inf, 0);
assertEquals(w.imaginary, inf, 0);
assertTrue(Double.isNaN(w.real));
assertTrue(Double.isNaN(w.imaginary));  
private Complex oneInf = new Complex(1, inf);
private Complex oneNegInf = new Complex(1, negInf);
private Complex infOne = new Complex(inf, 1);
private Complex negInfOne = new Complex(negInf, 1);
private Complex negInfNaN = new Complex(negInf, nan);
private Complex nanInf = new Complex(nan, inf);
private Complex nanNegInf = new Complex(nan, negInf);
private Complex zeroNaN = new Complex(0, nan);
private Complex nanZero = new Complex(nan, 0);
private Complex infZero = new Complex(inf, 0);
private Complex zeroInf = new Complex(0, inf);
private Complex negInfZero = new Complex(negInf, 0);
public void testAcos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.936812, -2.30551);
TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);
TestUtils.assertEquals(new Complex(Math.acos(0), 0), 
ComplexUtils.acos(Complex.ZERO), 1.0e-12);
public void testAcosInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));
public void testAcosNaN() {
assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());
public void testAcosNull() {
ComplexUtils.acos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAsin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(0.633984, 2.30551);
TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);
public void testAsinNaN() {
assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());
public void testAsinInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));
public void testAsinNull() {
ComplexUtils.asin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testAtan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.44831, 0.158997);
TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);
public void testAtanInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));
} 
public void testAtanNaN() {
assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());
assertTrue(ComplexUtils.atan(Complex.I).isNaN());
public void testAtanNull() {
ComplexUtils.atan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCos() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-27.03495, -3.851153);
TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);
public void testCosNaN() {
assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());
public void testCosInf() {
TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));
TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));
} 
public void testCosNull() {
ComplexUtils.cos(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testCosh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.58066, -7.58155);
TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);
public void testCoshNaN() {
assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());
public void testCoshInf() {  
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));
TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));
} 
public void testCoshNull() {
ComplexUtils.cosh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testExp() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-13.12878, -15.20078);
TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);
TestUtils.assertEquals(Complex.ONE, 
ComplexUtils.exp(Complex.ZERO), 10e-12);
Complex iPi = Complex.I.multiply(new Complex(pi,0));
TestUtils.assertEquals(Complex.ONE.negate(), 
ComplexUtils.exp(iPi), 10e-12);
public void testExpNaN() {
assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());
public void testExpInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));
TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));
public void testExpNull() {
ComplexUtils.exp(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testLog() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.60944, 0.927295);
TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);
public void testLogNaN() {
assertTrue(ComplexUtils.log(Complex.NaN).isNaN());
public void testLogInf() {
TestUtils.assertEquals(new Complex(inf, pi / 2),
ComplexUtils.log(oneInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 2),
ComplexUtils.log(oneNegInf), 10e-12);
TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi),
ComplexUtils.log(negInfOne), 10e-12);
TestUtils.assertEquals(new Complex(inf, pi / 4),
ComplexUtils.log(infInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, -pi / 4),
ComplexUtils.log(infNegInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),
ComplexUtils.log(negInfInf), 10e-12);
TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),
ComplexUtils.log(negInfNegInf), 10e-12);
public void testLogZero() {
TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));
public void testlogNull() {
ComplexUtils.log(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
return ComplexUtils.exp(Complex.I.multiply
(new Complex(theta, 0))).multiply(new Complex(r, 0));
public void testPow() {
Complex x = new Complex(3, 4);
Complex y = new Complex(5, 6);
Complex expected = new Complex(-1.860893, 11.83677);
TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);
public void testPowNaNBase() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());
public void testPowNaNExponent() {
Complex x = new Complex(3, 4);
assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());
public void testPowInf() {
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));
TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   
public void testPowZero() {
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ONE));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.ZERO));
TestUtils.assertSame(Complex.NaN, 
ComplexUtils.pow(Complex.ZERO, Complex.I));
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);
public void testpowNull() {
ComplexUtils.pow(null, Complex.ONE); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
ComplexUtils.pow(Complex.ONE, null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSin() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(3.853738, -27.01681);
TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);
public void testSinInf() {
TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));
TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));
public void testSinNaN() {
assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());
public void testSinNull() {
ComplexUtils.sin(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSinh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-6.54812, -7.61923);
TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);
public void testSinhNaN() {
assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());
public void testSinhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));
TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));
TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));
public void testsinhNull() {
ComplexUtils.sinh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrtRealPositive() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(2, 1);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealZero() {
Complex z = new Complex(0.0, 4);
Complex expected = new Complex(1.41421, 1.41421);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtRealNegative() {
Complex z = new Complex(-3.0, 4);
Complex expected = new Complex(1, 2);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryZero() {
Complex z = new Complex(-3.0, 0.0);
Complex expected = new Complex(0.0, 1.73205);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtImaginaryNegative() {
Complex z = new Complex(-3.0, -4.0);
Complex expected = new Complex(1.0, -2.0);
TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);
public void testSqrtPolar() {
double r = 1;
for (int i = 0; i < 5; i++) {
r += i;
double theta = 0;
for (int j =0; j < 11; j++) {
theta += pi /12;
Complex z = ComplexUtils.polar2Complex(r, theta);
Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);
TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);
}       
public void testSqrtNaN() {
assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());
public void testSqrtInf() {
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));
TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));
TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));
TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));
TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));
TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));
public void testSqrtNull() {
ComplexUtils.sqrt(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testSqrt1z() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(4.08033, -2.94094);
TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);
public void testSqrt1zNaN() {
assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());
public void testSqrt1zNull() {
ComplexUtils.sqrt1z(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTan() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(-0.000187346, 0.999356);
TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);
public void testTanNaN() {
assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());
public void testTanInf() {
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));
TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));
public void testTanCritical() {
TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));
TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));
public void testTanNull() {
ComplexUtils.tan(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
public void testTanh() {
Complex z = new Complex(3, 4);
Complex expected = new Complex(1.00071, 0.00490826);
TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);
public void testTanhNaN() {
assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());
public void testTanhInf() {
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));
TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));
TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));
public void testTanhCritical() {
TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));
public void testTanhNull() {
ComplexUtils.tanh(null); 
fail("Expecting NullPointerException");
} catch (NullPointerException ex) {
} 
}   
0.990d, 0.975d, 0.950d, 0.900d}; 
} 
HashSet set = new HashSet();
for (Iterator iterator = set.iterator(); iterator.hasNext();) {
addParameter((EstimatedParameter) iterator.next());
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
HashMap map = new HashMap();
map.put(parameters[j], null);
Set set = map.keySet();
points  = new ArrayList();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdX += ((PointModel) iterator.next()).getPartialDiX();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
dRdY += ((PointModel) iterator.next()).getPartialDiY();
for (Iterator iterator = points.iterator(); iterator.hasNext();) {
r += ((PointModel) iterator.next()).getCenterDistance();
private ArrayList points;
public class QuadraticProblem extends SimpleEstimationProblem {
assertFalse(zero.equals(new Double(0)));
Rotation r = new Rotation();
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);
r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);
r = new Rotation(Vector3D.plusJ, Math.PI);
checkVector(r.getAxis(), Vector3D.plusJ);
checkVector(new Rotation().getAxis(), Vector3D.plusI);
new Rotation(u, new Vector3D());
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);
if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {
checkVector(axis, Vector3D.plusK);
checkVector(axis, Vector3D.minusK);
r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,
new Rotation(u1, u2, new Vector3D(), v2);
checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);
checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);
checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);
checkVector(r.applyTo(Vector3D.plusI),
checkVector(r.applyTo(Vector3D.plusJ),
checkVector(r.applyTo(Vector3D.plusK),
r = new Rotation();
r = new Rotation(Vector3D.plusK, Math.PI);
a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));
assertTrue(Math.abs(a1 - a2) < 1.0e-10);
Rotation reference = new Rotation(q0, q1, q2, q3, false);
assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);
checkVector(new Vector3D(2, Vector3D.plusI,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
-3, Vector3D.minusK),
checkVector(new Vector3D(2, Vector3D.plusI,
5, Vector3D.plusJ,
5, Vector3D.minusJ,
-3, Vector3D.minusK),
assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);
assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);
assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);
assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);
assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);
new Vector3D().normalize();
Vector3D.angle(new Vector3D(), Vector3D.plusI);
BigMatrixImpl m = new BigMatrixImpl(testData);
BigMatrixImpl m2 = new BigMatrixImpl(m.getData());
assertEquals(m2,m);
BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData4x3);
matrix = new RealMatrixImpl(testData3x4);
RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);
RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x3Singular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);
matrix = new RealMatrixImpl(testData3x4);
matrix = new RealMatrixImpl(testData4x3);
RealMatrixImpl m = new RealMatrixImpl(testData);
RealMatrixImpl m2 = new RealMatrixImpl(m.getData());
assertEquals(m2,m);
RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);
assertClose("inverse-operate",mInv.operate(testVector),
m.solve(testVector),normTolerance);
double[] x = m.operate(testVector);
assertClose("identity operate",testVector,x,entryTolerance);
assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);
package org.apache.commons.math.ode;
double step = (pb.getFinalTime() - pb.getInitialTime())
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new ContinuousOutputModel());
ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();
integ.setStepHandler(cm);
public void computeDerivatives(double t, double[] y, double[] dot)
throws DerivativeException {
dot[0] = -y[1];
dot[1] =  y[0];
public int getDimension() {
return 2;
};
integ1.setStepHandler(cm1);
integ2.setStepHandler(cm2);
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
public void handleStep(StepInterpolator interpolator, boolean isLast)
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerHandler(pb));
assertTrue(pb.getCalls() < 2900);
integ.setStepHandler(new VariableHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(DummyStepHandler.getInstance());
integ.setStepHandler(new InterpolatingStepHandler());
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
assertTrue(bos.size () > 250);
assertTrue(bos.size () < 300);
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
throws DerivativeException {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerStepHandler(pb));
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integrator.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.setStepHandler(new KeplerStepHandler(pb));
integ.setStepHandler(new VariableStepHandler());
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12, 1000);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
public void computeDerivatives(double t, double[] y, double[] dot)
integ.setStepHandler(handler);
integ.setStepHandler(handler);
public void testSwitchingFunctions()
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
public void testSwitchingFunctionsError()
integ.setStepHandler(handler);
integ.addSwitchingFunction(new SwitchingFunction() {
return SwitchingFunction.CONTINUE;
public double g(double t, double[] y) throws FunctionEvaluationException {
throw new FunctionEvaluationException(t);
public void testSwitchingFunctionsNoConvergence()
integ.setStepHandler(handler);
integ.addSwitchingFunction(new SwitchingFunction() {
return SwitchingFunction.CONTINUE;
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
integ.setStepHandler(new StepHandler() {
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
package org.apache.commons.math.ode;
integ.setStepHandler(new StepNormalizer(range / 10.0,
private boolean firstCall = true;
integ.setStepHandler(new StepNormalizer(range / 10.5,
public void handleStep(double t,
package org.apache.commons.math.ode;
implements FirstOrderDifferentialEquations, SwitchingFunction {
package org.apache.commons.math.ode;
class TestProblem1
package org.apache.commons.math.ode;
class TestProblem2
package org.apache.commons.math.ode;
class TestProblem3
package org.apache.commons.math.ode;
class TestProblem4
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[] { new Bounce(), new Stop() };
private static class Bounce implements SwitchingFunction {
return SwitchingFunction.RESET_STATE;
private static class Stop implements SwitchingFunction {
return SwitchingFunction.STOP;
package org.apache.commons.math.ode;
class TestProblem5
package org.apache.commons.math.ode;
abstract class TestProblemAbstract
public SwitchingFunction[] getSwitchingFunctions() {
return new SwitchingFunction[0];
package org.apache.commons.math.ode;
package org.apache.commons.math.ode;
private FirstOrderIntegrator integrator;
public TestProblemHandler(TestProblemAbstract problem, FirstOrderIntegrator integrator) {
expectedStepStart = problem.getInitialTime();
maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));
expectedStepStart = start + integrator.getCurrentSignedStepsize();
package org.apache.commons.math.ode;
integ.setStepHandler(handler);
SwitchingFunction[] functions = pb.getSwitchingFunctions();
integ.addSwitchingFunction(functions[l],
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
integ.setStepHandler(handler);
integ.setStepHandler(handler);
integ.setStepHandler(new KeplerHandler(pb));
package org.apache.commons.math.ode;
extends TestCase {
integ.setStepHandler(new ContinuousOutputModel());
oos.writeObject(integ.getStepHandler());
ArrayList list = new ArrayList();
for (Iterator iter = list.iterator(); iter.hasNext();) {
dataArray[i] = ((Double)iter.next()).doubleValue();
new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();
HashSet cPop = new HashSet();  //{0,1,2,3,4}
HashSet hs = new HashSet();
HashSet hs = new HashSet();
hs = new HashSet();
HashSet set = (HashSet) u[i];
HashSet sampSet = new HashSet();
assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));
f.addValue(new Integer(1));
f.addValue(new Long(1));
f.addValue(new Integer(-1));
assertEquals("1 count", 3, f.getCount(new Integer(1)));
assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);
assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);
assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);
assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);
assertEquals("count, empty table",0, f.getCount(new Integer(0)));
assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));
assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));   
obj1 = new Integer(1);
Integer int1 = new Integer(1);
f.addValue(new Long(2));
assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));
assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);
assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);
private Map certifiedValues;
certifiedValues = new HashMap();
Double value = new Double(valueString);
Iterator iter = certifiedValues.keySet().iterator();
while (iter.hasNext()) {
String name = iter.next().toString();
return new Double(((Long) property).doubleValue());
package org.apache.commons.math.stat.descriptive;
public abstract class DescriptiveStatisticsAbstractTest extends TestCase {
private double var = 0.666666666666666666667;
private double max = 3;
private double mean = 2;
private double min = 1;
private double n = 4;
private double one = 1;
private double std = Math.sqrt(var);
private double sum = 8;
private double sumSq = 18;
private int three = 3;
private double tolerance = 10E-15;
private float two = 2;
public DescriptiveStatisticsAbstractTest(String name) {
super(name);
protected abstract DescriptiveStatistics createDescriptiveStatistics();
public void setUp() {  
public void testAddValue() {
double[] test1 = {5,4,3,2,1,0};
double[] test2 = {5,2,1,0,4,3};
DescriptiveStatistics stats = createDescriptiveStatistics();
stats.setWindowSize(12);
for(int i = 0; i < test1.length; i++){
stats.addValue(test1[i]);
}     
double[] test3 = stats.getValues();
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test1[i],0.0);
}     
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}    
for(int i = 0; i < test2.length; i++){
stats.addValue(test2[i]);
}     
test3 = stats.getValues();  
for(int i = 0; i < 6; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i],0.0);
}  
for(int i = 6; i < 12; i++){
assertEquals( "Added value ["+i+"] not equal", 
test3[i], test2[i-6],0.0);
}  
}     
public void testGetSortedValues() {
double[] test1 = {5,4,3,2,1};
double[] test2 = {5,2,1,3,4,0};
double[] test3 = {1};
int[] testi = null;
double[] test4 = null;
RandomData rd = new RandomDataImpl();
tstGetSortedValues(test1);
tstGetSortedValues(test2);
tstGetSortedValues(test3);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,6);
test4 = new double[6];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
for (int i = 0; i < 10; i++) {
testi = rd.nextPermutation(10,5);
test4 = new double[5];
for (int j = 0; j < testi.length; j++) {
test4[j] = (double) testi[j];
tstGetSortedValues(test4);
}        
public void testN0andN1Conditions() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN",
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue( "Mean of n = 1 set should be value of single item n1",
u.getMean() == one);
assertTrue( "StdDev of n = 1 set should be zero, instead it is: " 
+ u.getStandardDeviation(), u.getStandardDeviation() == 0);
assertTrue( "Variance of n = 1 set should be zero", 
u.getVariance() == 0);  
public void testNewInstanceClassNull() {
DescriptiveStatistics.newInstance((Class)null);
fail("null is not a valid descriptive statistics class");
} catch (NullPointerException ex) {
} catch (Exception ex) {
fail();
public void testNewInstanceClassValid() {
DescriptiveStatistics u = DescriptiveStatistics.newInstance(
DescriptiveStatisticsImpl.class);
assertNotNull(u);
assertTrue(u instanceof DescriptiveStatisticsImpl);
} catch (InstantiationException ex) {
fail();
} catch (IllegalAccessException ex) {
fail();
public void testPercentiles() {
double[] test = {5,4,3,2,1};
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(110);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
assertEquals("expecting min",1,u.getPercentile(5),10E-12);
assertEquals("expecting max",5,u.getPercentile(99),10E-12);
assertEquals("expecting middle",3,u.getPercentile(50),10E-12);
u.getPercentile(0);
fail("expecting IllegalArgumentException for getPercentile(0)");
} catch (IllegalArgumentException ex) {
u.getPercentile(120);
fail("expecting IllegalArgumentException for getPercentile(120)");
} catch (IllegalArgumentException ex) {
u.clear();
double[] test2 = {1,2,3,4};
for (int i = 0; i < test2.length; i++) {
u.addValue(test2[i]);
assertEquals("Q1",1.25,u.getPercentile(25),10E-12);
assertEquals("Q3",3.75,u.getPercentile(75),10E-12);
assertEquals("Q2",2.5,u.getPercentile(50),10E-12);
u.clear();
double[] test3 = {1};
for (int i = 0; i < test3.length; i++) {
u.addValue(test3[i]);
assertEquals("Q1",1,u.getPercentile(25),10E-12);
assertEquals("Q3",1,u.getPercentile(75),10E-12);
assertEquals("Q2",1,u.getPercentile(50),10E-12);
u.clear();
RandomData rd = new RandomDataImpl();
int[] testi = rd.nextPermutation(100,100); // will contain 0-99
for (int j = 0; j < testi.length; j++) {
u.addValue((double) testi[j]);  //OK, laugh at me for the cast
for (int i = 1; i < 100; i++) {
assertEquals("percentile " + i,
(double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);
u.clear();
double[] test4 = {1,2,3,4,100};
for (int i = 0; i < test4.length; i++) {
u.addValue(test4[i]);
assertEquals("80th",80.8,u.getPercentile(80),10E-12);
u.clear();
assertTrue("empty value set should return NaN",
Double.isNaN(u.getPercentile(50)));
public void testProductAndGeometricMean() throws Exception {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(10);
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 
2.213364, u.getGeometricMean(), 0.00001 );
for( int i = 0; i < 10; i++ ) {
u.addValue( i + 2 );
assertEquals( "Geometric mean not expected", 5.755931, 
u.getGeometricMean(), 0.00001 );
public void testSerialization() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); 
u2.addValue(two);
u2.addValue(three);
assertEquals("N",n,u2.getN(),tolerance);
assertEquals("sum",sum,u2.getSum(),tolerance);
assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);
assertEquals("var",var,u2.getVariance(),tolerance);
assertEquals("std",std,u2.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u2.getMean(),tolerance);
assertEquals("min",min,u2.getMin(),tolerance);
assertEquals("max",max,u2.getMax(),tolerance);
u2.clear();
assertEquals("total count",0,u2.getN(),tolerance);    
public void testSkewAndKurtosis() {
DescriptiveStatistics u = createDescriptiveStatistics();
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
assertEquals("mean", 12.40455, u.getMean(), 0.0001);
assertEquals("variance", 10.00236, u.getVariance(), 0.0001);
assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);
assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);
}       
public void testStats() {
DescriptiveStatistics u = createDescriptiveStatistics(); 
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(two);
u.addValue(two);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
public void testToString() {
DescriptiveStatistics u = createDescriptiveStatistics();
assertTrue(u.toString().indexOf("NaN") > 0);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
double[] testArray = 
{ 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,
9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };
for( int i = 0; i < testArray.length; i++) {
u.addValue( testArray[i]);
}        
assertTrue(u.toString().indexOf("NaN") == -1);  
assertTrue(u.toString().startsWith("DescriptiveStatistics"));
public void testWindowing() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(2);
u.addValue(1.0);
assertEquals(1.0, u.getMean(), tolerance);
u.addValue(2.0);
assertEquals(1.5, u.getMean(), tolerance);
u.addValue(3.0);
assertEquals(2.5, u.getMean(), tolerance);
u.setWindowSize(1);
assertEquals(3.0, u.getMean(), tolerance);
public void testWindowSize() {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(1234);
assertEquals(1234, u.getWindowSize());
u.addValue(1.0);
u.addValue(2.0);
u.addValue(3.0);
u.addValue(4.0);
u.addValue(5.0);
assertEquals(5, u.getN());
u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);
assertEquals(5, u.getN());
private void tstGetSortedValues(double[] test) {
DescriptiveStatistics u = createDescriptiveStatistics();
u.setWindowSize(test.length);
for (int i = 0; i < test.length; i++) {
u.addValue(test[i]);
double[] sorted = u.getSortedValues();
if (sorted.length != test.length) {
fail("wrong length for sorted values array");
for (int i = 0; i < sorted.length-1; i++) {
if (sorted[i] > sorted[i+1]) {
fail("sorted values out of sequence");
package org.apache.commons.math.stat.descriptive;
public final class DescriptiveStatisticsImplTest extends DescriptiveStatisticsAbstractTest {
public DescriptiveStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);
suite.setName("DescriptiveStatisticsImpl Tests");
return suite;
protected DescriptiveStatistics createDescriptiveStatistics() {
return new DescriptiveStatisticsImpl();
public final class DescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
protected List list;
this(new ArrayList());
public ListUnivariateImpl(List list) {
public ListUnivariateImpl(List list, NumberTransformer transformer) {
list.add(new Double(v));
List externalList = new ArrayList();
List list = new ArrayList();
list.add( new Double(one));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());
List externalList = new ArrayList();
DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);
new ListUnivariateImpl(new ArrayList(), transformers);
u.addObject(new Integer(12));
u.addObject(new Long(21));
u.addObject(new Float(14.1));
u.addObject(new Double(19.8));
ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);
assertFalse(u.equals(new Double(0)));
assertFalse("wrong type", u.equals(new Double(0)));
package org.apache.commons.math.stat.descriptive;
public abstract class SummaryStatisticsAbstractTest extends TestCase {
private double one = 1;
private float twoF = 2;
private long twoL = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double std = Math.sqrt(var);
private double n = 4;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
public SummaryStatisticsAbstractTest(String name) {
super(name);
protected abstract SummaryStatistics createSummaryStatistics();
public void testStats() {
SummaryStatistics u = createSummaryStatistics();
assertEquals("total count",0,u.getN(),tolerance);
u.addValue(one);
u.addValue(twoF);
u.addValue(twoL);
u.addValue(three);
assertEquals("N",n,u.getN(),tolerance);
assertEquals("sum",sum,u.getSum(),tolerance);
assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);
assertEquals("var",var,u.getVariance(),tolerance);
assertEquals("std",std,u.getStandardDeviation(),tolerance);
assertEquals("mean",mean,u.getMean(),tolerance);
assertEquals("min",min,u.getMin(),tolerance);
assertEquals("max",max,u.getMax(),tolerance);
u.clear();
assertEquals("total count",0,u.getN(),tolerance);    
}     
public void testN0andN1Conditions() throws Exception {
SummaryStatistics u = createSummaryStatistics();
assertTrue("Mean of n = 0 set should be NaN", 
Double.isNaN( u.getMean() ) );
assertTrue("Standard Deviation of n = 0 set should be NaN", 
Double.isNaN( u.getStandardDeviation() ) );
assertTrue("Variance of n = 0 set should be NaN", 
Double.isNaN(u.getVariance() ) );
u.addValue(one);
assertTrue("mean should be one (n = 1)", 
u.getMean() == one);
assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), 
u.getGeometricMean() == one);
assertTrue("Std should be zero (n = 1)", 
u.getStandardDeviation() == 0.0);
assertTrue("variance should be zero (n = 1)", 
u.getVariance() == 0.0);
u.addValue(twoF);
assertTrue("Std should not be zero (n = 2)", 
u.getStandardDeviation() != 0.0);
assertTrue("variance should not be zero (n = 2)", 
u.getVariance() != 0.0);
public void testProductAndGeometricMean() throws Exception {
SummaryStatistics u = createSummaryStatistics();
u.addValue( 1.0 );
u.addValue( 2.0 );
u.addValue( 3.0 );
u.addValue( 4.0 );
assertEquals( "Geometric mean not expected", 2.213364, 
u.getGeometricMean(), 0.00001 );
public void testNaNContracts() {
SummaryStatistics u = createSummaryStatistics();
assertTrue("mean not NaN",Double.isNaN(u.getMean())); 
assertTrue("min not NaN",Double.isNaN(u.getMin())); 
assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); 
assertTrue("var not NaN",Double.isNaN(u.getVariance())); 
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(1.0);
assertEquals( "mean not expected", 1.0, 
u.getMean(), Double.MIN_VALUE);
assertEquals( "variance not expected", 0.0, 
u.getVariance(), Double.MIN_VALUE);
assertEquals( "geometric mean not expected", 1.0, 
u.getGeometricMean(), Double.MIN_VALUE);
u.addValue(-1.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
u.addValue(0.0);
assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));
public void testGetSummary() {
SummaryStatistics u = createSummaryStatistics();
StatisticalSummary summary = u.getSummary();
verifySummary(u, summary);
u.addValue(1d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);
u.addValue(2d);
summary = u.getSummary();
verifySummary(u, summary);     
public void testSerialization() {
SummaryStatistics u = createSummaryStatistics();
TestUtils.checkSerializedEquality(u);
SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
StatisticalSummary summary = s.getSummary();
verifySummary(u, summary);
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
u.addValue(5d);
TestUtils.checkSerializedEquality(u);
s = (SummaryStatistics) TestUtils.serializeAndRecover(u);
summary = s.getSummary();
verifySummary(u, summary);
public void testEqualsAndHashCode() {
SummaryStatistics u = createSummaryStatistics();
SummaryStatistics t = null;
int emptyHash = u.hashCode();
assertTrue("reflexive", u.equals(u));
assertFalse("non-null compared to null", u.equals(t));
assertFalse("wrong type", u.equals(new Double(0)));
t = createSummaryStatistics();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
u.addValue(2d);
u.addValue(1d);
u.addValue(3d);
u.addValue(4d);
assertFalse("different n's should make instances not equal", t.equals(u));
assertFalse("different n's should make instances not equal", u.equals(t));
assertTrue("different n's should make hashcodes different", 
u.hashCode() != t.hashCode());
t.addValue(2d);
t.addValue(1d);
t.addValue(3d);
t.addValue(4d);
assertTrue("summaries based on same data should be equal", t.equals(u));
assertTrue("summaries based on same data should be equal", u.equals(t));
assertEquals("summaries based on same data should have same hashcodes", 
u.hashCode(), t.hashCode());   
u.clear();
t.clear();
assertTrue("empty instances should be equal", t.equals(u));
assertTrue("empty instances should be equal", u.equals(t));
assertEquals("empty hash code", emptyHash, t.hashCode());
assertEquals("empty hash code", emptyHash, u.hashCode());
private void verifySummary(SummaryStatistics u, StatisticalSummary s) {
assertEquals("N",s.getN(),u.getN());
TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);
TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);
TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);
TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);
TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);
TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);   
package org.apache.commons.math.stat.descriptive;
public final class SummaryStatisticsImplTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);
suite.setName("SummaryStatisticsImpl Tests");
return suite;
protected SummaryStatistics createSummaryStatistics() {
return new SummaryStatisticsImpl();
public final class SummaryStatisticsTest extends SummaryStatisticsAbstractTest {
public SummaryStatisticsTest(String name) {
super(name);
public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {
public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsAbstractTest {
private char[] wrongArray = { 'a', 'b', 'c' };
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List wrongContents = new ArrayList();
wrongContents.add(classC);
wrongContents.add(wrongArray);
testStatistic.anovaFValue(wrongContents);
fail("non double[] hash value for key classX, IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
}  
List emptyContents = new ArrayList();
List tooFew = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
List threeClasses = new ArrayList();
List twoClasses = new ArrayList();
private List classes = new ArrayList();
Double input = new Double(expected);
Integer input = new Integer(1);
private Double x = new Double(1.0);if (cachedQ == null) {if (cachedQT == null) {private static final double SQRT2PI = Math.sqrt(2 * Math.PI);this.arguments = null;for (int i4 = np; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {
for (int i4 = nn - 17; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {
for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {
for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start - 1 + pingPong; i4 -= 4) {data = new double[subMatrix.length][subMatrix[0].length];
System.arraycopy(subMatrix[i], 0, data[i], 0, subMatrix[i].length);void decompose(RealMatrix matrix, double singularityThreshold);
RealMatrix getL() throws IllegalStateException;
RealMatrix getU() throws IllegalStateException;
RealMatrix getP() throws IllegalStateException;
int[] getPivot() throws IllegalStateException;
public boolean isSingular();
RealMatrix getQ() throws IllegalStateException;
RealMatrix getQT() throws IllegalStateException;
RealMatrix getH() throws IllegalStateException;
RealMatrix getU() throws IllegalStateException;
RealMatrix getUT() throws IllegalStateException;
RealMatrix getS() throws IllegalStateException;
double[] getSingularValues() throws IllegalStateException;
RealMatrix getV() throws IllegalStateException;
RealMatrix getVT() throws IllegalStateException;
double getNorm() throws IllegalStateException;
double getConditionNumber() throws IllegalStateException;
int getRank() throws IllegalStateException;++k;
++q;
return new RealMatrixImpl(data, false);public interface Fitness extends Comparable {
this.main      = main;
this.secondary = secondary;
return new Solver(realEigenvalues, eigenvectors);
private final double[] eigenvalues;
private Solver(final double[] eigenvalues, final RealVectorImpl[] eigenvectors) {
this.eigenvalues  = eigenvalues;
this.eigenvectors = eigenvectors; 
final int m = eigenvalues.length;
final double s = v.dotProduct(b) / eigenvalues[i];
final int m = eigenvalues.length;
final double s = v.dotProduct(b) / eigenvalues[i];
final int m = eigenvalues.length;
s /= eigenvalues[i];
for (double lambda : eigenvalues) {
if (lambda == 0) {
final int m = eigenvalues.length;
invIJ += vK[i] * vK[j] / eigenvalues[k];
final int fourN1  = 4 * (n - 1);
double sumDiag    = 0;
final double qi = work[fourI];
sumDiag    += qi;
final double qi = work[fourN1];
sumDiag += qi;
RealMatrix getR() throws IllegalStateException;
public interface RealMatrix {
double[] mainTridiagonal;
double[] secondaryTridiagonal;
public interface RandomData {
vector.length != dimensionSize.length) {
throw new IllegalArgumentException("Number of dimensions must "
+ "match");
vector.length != dimensionSize.length) {
throw new IllegalArgumentException("Number of dimensions must "
+ "match");
final int referenceCount;
boolean result = true;
ResizableDoubleArray other = (ResizableDoubleArray) object;
result = result && (other.initialCapacity == initialCapacity);
result = result && (other.contractionCriteria == contractionCriteria);
result = result && (other.expansionFactor == expansionFactor);
result = result && (other.expansionMode == expansionMode);
result = result && (other.numElements == numElements);
result = result && (other.startIndex == startIndex);
if (!result) { 
return false;
} else {
return Arrays.equals(internalArray, other.internalArray);private static final long serialVersionUID = -710169279109099264L;
public double[] transform(double f[]) throws IllegalArgumentException {
return fht(f);
return fht(FastFourierTransformer.sample(f, min, max, n));
checkTransform(new double[] { 1.0, 4.0, -2.0, 3.0, 0.0, 1.0, 4.0, -1.0 },
new double[] { 10.0, -4.0, 2.0, -4.0, 2.0, -12.0, 6.0, 8.0 });
checkTransform(new double[] { 1.0, 2.0, 3.0, 4.0 },
new double[] { 10.0, -2.0, -4.0, 0.0 });
private void checkTransform(double[]x, double[] y) {
double result[] = transformer.transform(x);
for (int i=0;i<result.length;i++) {
assertEquals(y[i], result[i]);RealMatrix m = new RealMatrixImpl(subTestData);
assertEquals(new RealMatrixImpl(reference), sub);
assertEquals(new RealMatrixImpl(reference), sub);
RealMatrix m = new RealMatrixImpl(subTestData);
assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));
assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));final int      width    = blockWidth(index);
final int width2 = blockWidth(index + 1);
final int width2 = blockWidth(index + 1);rDiag = new double[n];
public RealMatrix getQ()
throws IllegalStateException {
public RealMatrix getQT()
throws IllegalStateException {
public RealMatrix getH()
throws IllegalStateException {
public boolean isNonSingular()
throws IllegalStateException {
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
throw new IllegalArgumentException("Incorrect row dimension");
for (int row = n - 1; row >= 0; --row) {
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
throw new IllegalArgumentException("Incorrect row dimension");
final int cols = b.getColumnDimension();
final double[][] xData = new double[n][cols];
final double[] y = new double[b.getRowDimension()];
for (int k = 0; k < cols; ++k) {
for (int j = 0; j < y.length; ++j) {
y[j] = b.getEntry(j, k);
double dotProduct = 0;
for (int row = minor; row < m; row++) {
dotProduct += y[row] * qrtMinor[row];
dotProduct /= rDiag[minor] * qrtMinor[minor];
for (int row = minor; row < m; row++) {
y[row] += dotProduct * qrtMinor[row];
for (int row = n - 1; row >= 0; --row) {
y[row] /= rDiag[row];
final double yRow = y[row];
final double[] qrtRow = qrt[row];
xData[row][k] = yRow;
for (int i = 0; i < row; i++) {
y[i] -= yRow * qrtRow[i];
return new RealMatrixImpl(xData, false);
throws IllegalStateException, InvalidMatrixException {if (u * v == 0) {return localmin(min, max, relativeAccuracy, absoluteAccuracy, f);
private double localmin(double a, double b, final double eps,
protected void checkResultComputed() throws IllegalArgumentException {
throws ConvergenceException, FunctionEvaluationException;
throws ConvergenceException, FunctionEvaluationException;
protected void checkResultComputed() throws IllegalArgumentException {
public interface SecondOrderDifferentialEquations {
if (vector == null && dimensionSize.length > 1) {
throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
new Object[] { 0, dimensionSize.length });
Object lastDimension = multiDimensionalComplexArray;
lastDimension = ((Object[]) lastDimension)[vector[i]];
Complex lastValue = (Complex) ((Object[])
lastDimension)[vector[dimensionSize.length - 1]];
((Object[]) lastDimension)[vector[dimensionSize.length - 1]] =
magnitude;
hashData[0] = Arrays.hashCode(internalArray);
hashData[1] = new Float(expansionFactor).hashCode();
hashData[2] = new Float(contractionCriteria).hashCode();
hashData[3] = initialCapacity;
hashData[4] = expansionMode;
hashData[5] = numElements;
hashData[6] = startIndex;vals[i] = values[i];
protected boolean isZero(int key) {
return !entries.containsKey(key);
}
} else if (!isZero(index)) {double target[] = {y[0], 1d, 0d, 0d};
target = new double[]{y[1], 1d, 0d, 0d};
double target[] = {y[0], 1d, 0d, 0d};
target = new double[]{y[1], 1d, 0d, 0d};
target = new double[]{y[2], 1d, 0d, 0d};package org.apache.commons.math.linear;
public class SparseRealVector implements RealVector {
private OpenIntToDoubleHashMap entries;
private final int virtualSize;
private double epsilon = 1.0e-12;
public SparseRealVector() {
virtualSize = 0;
entries = new OpenIntToDoubleHashMap(0.0);
}
public SparseRealVector(int dimension) {
virtualSize = dimension;
entries = new OpenIntToDoubleHashMap(0.0);
}
public SparseRealVector(int dimension, double epsilon){
virtualSize = dimension;
entries = new OpenIntToDoubleHashMap(0.0);
this.epsilon = epsilon;
}
protected SparseRealVector(SparseRealVector v, int resize) {
virtualSize = v.getDimension() + resize;
entries = new OpenIntToDoubleHashMap(v.entries);
}
public SparseRealVector(int dimension, int expectedSize) {
entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);
virtualSize = dimension;
}
public SparseRealVector(int dimension, int expectedSize, double epsilon){
virtualSize = dimension;
entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);
this.epsilon = epsilon;
}
public SparseRealVector(double[] values) {
virtualSize = values.length;
fromDoubleArray(values);
}
public SparseRealVector(double [] values, double epsilon){
virtualSize = values.length;
this.epsilon = epsilon;
fromDoubleArray(values);
}
public SparseRealVector(Double [] values) {
virtualSize = values.length;
double[] vals = new double[values.length];
for(int i=0; i < values.length; i++){
vals[i] = values[i].doubleValue();
}
fromDoubleArray(vals);
}
public SparseRealVector(Double [] values, double epsilon){
virtualSize = values.length;
this.epsilon = epsilon;
double[] vals = new double[values.length];
for(int i=0; i < values.length; i++){
vals[i] = values[i].doubleValue();
}
fromDoubleArray(vals);
}
public SparseRealVector(SparseRealVector v){
virtualSize = v.getDimension();
epsilon = v.getEpsilon();
entries = new OpenIntToDoubleHashMap(v.getEntries());
}
public SparseRealVector(RealVector v) {
virtualSize = v.getDimension();
fromDoubleArray(v.getData());
}
private void fromDoubleArray(double[] values) {
entries = new OpenIntToDoubleHashMap(0.0);
for (int key = 0; key < values.length; key++) {
double value = values[key];
if (!isZero(value)) {
entries.put(key, value);
}
}
}
private OpenIntToDoubleHashMap getEntries() {
return entries;
}
protected boolean isZero(double value) {
return value > -epsilon && value < epsilon;
}
public double getEpsilon() {
return epsilon;
}
public void setEpsilon(double epsilon) {
this.epsilon = epsilon;
}
public RealVector add(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if (v instanceof SparseRealVector)
return add((SparseRealVector) v);
return add(v.getData());
}
public SparseRealVector add(SparseRealVector v) {
SparseRealVector res = (SparseRealVector) copy();
Iterator iter = res.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (v.getEntries().containsKey(key)) {
res.set(key, iter.value() + v.getEntry(key));
}
}
iter = v.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (!entries.containsKey(key)) {
res.set(key, iter.value());
}
}
return res;
}
public RealVector add(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
SparseRealVector res = new SparseRealVector(getDimension());
for (int i = 0; i < v.length; i++) {
res.set(i, v[i] + getEntry(i));
}
return res;
}
public SparseRealVector append(SparseRealVector v) {
SparseRealVector res = new SparseRealVector(this, v.getDimension());
Iterator iter = v.entries.iterator();
while (iter.hasNext()) {
iter.advance();
res.set(iter.key() + virtualSize, iter.value());
}
return res;
}
public RealVector append(RealVector v) {
if (v instanceof SparseRealVector) {
return append((SparseRealVector) v);
}
return append(v.getData());
}
public RealVector append(double d) {
RealVector res = new SparseRealVector(this, 1);
res.set(virtualSize, d);
return res;
}
public RealVector append(double[] a) {
RealVector res = new SparseRealVector(this, a.length);
for (int i = 0; i < a.length; i++) {
res.set(i + virtualSize, a[i]);
}
return res;
}
public RealVector copy() {
return new SparseRealVector(this);
}
public double dotProduct(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res += v.getEntry(iter.key()) * iter.value();
}
return res;
}
public double dotProduct(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
int idx = iter.key();
double value = 0;
if (idx < v.length)
value = v[idx];
res += value * iter.value();
}
return res;
}
public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
SparseRealVector res = new SparseRealVector(this);
Iterator iter = res.entries.iterator();
while (iter.hasNext()) {
iter.advance();
res.set(iter.key(), iter.value() / v.getEntry(iter.key()));
}
return res;
}
public RealVector ebeDivide(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
SparseRealVector res = new SparseRealVector(this);
Iterator iter = res.entries.iterator();
while (iter.hasNext()) {
iter.advance();
res.set(iter.key(), iter.value() / v[iter.key()]);
}
return null;
}
public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
SparseRealVector res = new SparseRealVector(this);
Iterator iter = res.entries.iterator();
while (iter.hasNext()) {
iter.advance();
res.set(iter.key(), iter.value() * v.getEntry(iter.key()));
}
return res;
}
public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
SparseRealVector res = new SparseRealVector(this);
Iterator iter = res.entries.iterator();
while (iter.hasNext()) {
iter.advance();
res.set(iter.key(), iter.value() * v[iter.key()]);
}
return res;
}
public RealVector get(int index, int n) throws MatrixIndexException {
checkIndex(index);
checkIndex(index+n-1);
SparseRealVector res = new SparseRealVector(n);
int end = index + n;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (key >= index && key < end) {
res.set(key - index, iter.value());
}
}
return res;
}
public double[] getData() {
double[] res = new double[virtualSize];
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res[iter.key()] = iter.value();
}
return res;
}
public int getDimension() {
return virtualSize;
}
public double getDistance(SparseRealVector v) {
Iterator iter = entries.iterator();
double res = 0;
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
double delta;
delta = iter.value() - v.getEntry(key);
res += delta * delta;
}
iter = v.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (!entries.containsKey(key)) {
res += iter.value() * iter.value();
}
}
return Math.sqrt(res);
}
public double getDistance(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if (v instanceof SparseRealVector) {
return getDistance((SparseRealVector) v);
}
return getDistance(v.getData());
}
public double getDistance(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
double res = 0;
for (int i = 0; i < v.length; i++) {
double delta = entries.get(i) - v[i];
res += delta * delta;
}
return Math.sqrt(res);
}
public double getEntry(int index) throws MatrixIndexException {
checkIndex(index);
return entries.get(index);
}
public double getL1Distance(SparseRealVector v) {
double max = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
max += delta;
}
iter = v.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (!entries.containsKey(key)) {
double delta = Math.abs(iter.value());
max +=  Math.abs(delta);
}
}
return max;
}
public double getL1Distance(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if (v instanceof SparseRealVector) {
return getL1Distance((SparseRealVector) v);
}
return getL1Distance(v.getData());
}
public double getL1Distance(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
double max = 0;
for (int i = 0; i < v.length; i++) {
double delta = Math.abs(getEntry(i) - v[i]);
max += delta;
}
return max;
}
public double getL1Norm() {
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res += Math.abs(iter.value());
}
return res;
}
private double getLInfDistance(SparseRealVector v) {
double max = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
if(delta > max)
max = delta;
}
iter = v.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (!entries.containsKey(key)) {
if(iter.value() > max)
max = iter.value();
}
}
return max;
}
public double getLInfDistance(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if (v instanceof SparseRealVector) {
return getLInfDistance((SparseRealVector) v);
}
return getLInfDistance(v.getData());
}
public double getLInfDistance(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
double max = 0;
for (int i = 0; i < v.length; i++) {
double delta = Math.abs(getEntry(i) - v[i]);
if(delta > max)
max = delta;
}
return max;
}
public double getLInfNorm() {
double max = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
max += iter.value();
}
return max;
}
public double getNorm() {
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res += iter.value() * iter.value();
}
return Math.sqrt(res);
}
public boolean isInfinite() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
if (Double.isInfinite(iter.value()))
return true;
}
return false;
}
public boolean isNaN() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
if (Double.isNaN(iter.value()))
return true;
}
return false;
}
public RealVector mapAbs() {
return copy().mapAbsToSelf();
}
public RealVector mapAbsToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.abs(iter.value()));
}
return this;
}
public RealVector mapAcos() {
return copy().mapAcosToSelf();
}
public RealVector mapAcosToSelf() {
for(int i=0; i < virtualSize; i++){
set(i, Math.acos(getEntry(i)));
}
return this;
}
public RealVector mapAdd(double d) {
return copy().mapAddToSelf(d);
}
public RealVector mapAddToSelf(double d) {
for (int i = 0; i < virtualSize; i++) {
set(i, getEntry(i) + d);
}
return this;
}
public RealVector mapAsin() {
return copy().mapAsinToSelf();
}
public RealVector mapAsinToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.asin(iter.value()));
}
return this;
}
public RealVector mapAtan() {
return copy().mapAtanToSelf();
}
public RealVector mapAtanToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.atan(iter.value()));
}
return this;
}
public RealVector mapCbrt() {
return copy().mapCbrtToSelf();
}
public RealVector mapCbrtToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.cbrt(iter.value()));
}
return this;
}
public RealVector mapCeil() {
return copy().mapCeilToSelf();
}
public RealVector mapCeilToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.ceil(iter.value()));
}
return this;
}
public RealVector mapCos() {
return copy().mapCosToSelf();
}
public RealVector mapCosToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.cos(iter.value()));
}
return this;
}
public RealVector mapCosh() {
return copy().mapCoshToSelf();
}
public RealVector mapCoshToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.cosh(iter.value()));
}
return this;
}
public RealVector mapDivide(double d) {
return copy().mapDivideToSelf(d);
}
public RealVector mapDivideToSelf(double d) {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), iter.value() / d);
}
return this;
}
public RealVector mapExp() {
return copy().mapExpToSelf();
}
public RealVector mapExpToSelf() {
for (int i = 0; i < virtualSize; i++) {
entries.put(i, Math.exp(entries.get(i)));
}
return this;
}
public RealVector mapExpm1() {
return copy().mapExpm1ToSelf();
}
public RealVector mapExpm1ToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.expm1(iter.value()));
}
return this;
}
public RealVector mapFloor() {
return copy().mapFloorToSelf();
}
public RealVector mapFloorToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.floor(iter.value()));
}
return this;
}
public RealVector mapInv() {
return copy().mapInvToSelf();
}
public RealVector mapInvToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), 1 / iter.value());
}
return this;
}
public RealVector mapLog() {
return copy().mapLogToSelf();
}
public RealVector mapLog10() {
return copy().mapLog10ToSelf();
}
public RealVector mapLog10ToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.log10(iter.value()));
}
return this;
}
public RealVector mapLog1p() {
return copy().mapLog1pToSelf();
}
public RealVector mapLog1pToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.log1p(iter.value()));
}
return this;
}
public RealVector mapLogToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.log(iter.value()));
}
return this;
}
public RealVector mapMultiply(double d) {
return copy().mapMultiplyToSelf(d);
}
public RealVector mapMultiplyToSelf(double d) {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), iter.value() * d);
}
return this;
}
public RealVector mapPow(double d) {
return copy().mapPowToSelf(d);
}
public RealVector mapPowToSelf(double d) {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.pow(iter.value(), d));
}
return this;
}
public RealVector mapRint() {
return copy().mapRintToSelf();
}
public RealVector mapRintToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.rint(iter.value()));
}
return this;
}
public RealVector mapSignum() {
return copy().mapSignumToSelf();
}
public RealVector mapSignumToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.signum(iter.value()));
}
return this;
}
public RealVector mapSin() {
return copy().mapSinToSelf();
}
public RealVector mapSinToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.sin(iter.value()));
}
return this;
}
public RealVector mapSinh() {
return copy().mapSinhToSelf();
}
public RealVector mapSinhToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.sinh(iter.value()));
}
return this;
}
public RealVector mapSqrt() {
return copy().mapSqrtToSelf();
}
public RealVector mapSqrtToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.sqrt(iter.value()));
}
return this;
}
public RealVector mapSubtract(double d) {
return copy().mapSubtractToSelf(d);
}
public RealVector mapSubtractToSelf(double d) {
return mapAddToSelf(-d);
}
public RealVector mapTan() {
return copy().mapTanToSelf();
}
public RealVector mapTanToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.tan(iter.value()));
}
return this;
}
public RealVector mapTanh() {
return copy().mapTanhToSelf();
}
public RealVector mapTanhToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.tanh(iter.value()));
}
return this;
}
public RealVector mapUlp() {
return copy().mapUlpToSelf();
}
public RealVector mapUlpToSelf() {
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), Math.ulp(iter.value()));
}
return this;
}
public SparseRealMatrix outerproduct(SparseRealVector v){
checkVectorDimensions(v.getDimension());
SparseRealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);
Iterator iter = entries.iterator();
while(iter.hasNext()){
iter.advance();
Iterator iter2 = v.getEntries().iterator();
while(iter2.hasNext()){
iter2.advance();
res.setEntry(iter.key(), iter2.key(), iter.value()*iter2.value());
}
}
return res;
}
public RealMatrix outerProduct(RealVector v)
throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if(v instanceof SparseRealVector){
return outerproduct((SparseRealVector)v);
}
RealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);
Iterator iter = entries.iterator();
while(iter.hasNext()){
iter.advance();
int row = iter.key();
for(int col=0; col < virtualSize; col++){
res.setEntry(row, col, iter.value()*v.getEntry(col));
}
}
return res;
}
public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
RealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
int row = iter.key();
double value = iter.value();
for (int col = 0; col < virtualSize; col++) {
res.setEntry(row, col, value * v[col]);
}
}
return res;
}
public RealVector projection(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
}
public RealVector projection(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
return projection(new SparseRealVector(v));
}
public void set(int index, double value) throws MatrixIndexException {
checkIndex(index);
if (!isZero(value)) {
entries.put(index, value);
} else if (entries.containsKey(index)) {
entries.remove(index);
}
}
public void set(int index, RealVector v) throws MatrixIndexException {
checkIndex(index);
checkIndex(index + v.getDimension() - 1);
set(index, v.getData());
}
public void set(int index, double[] v) throws MatrixIndexException {
checkIndex(index);
checkIndex(index + v.length - 1);
for (int i = 0; i < v.length; i++) {
set(i + index, v[i]);
}
}
public void set(double value) {
entries = new OpenIntToDoubleHashMap(value);
}
public SparseRealVector subtract(SparseRealVector v) {
checkVectorDimensions(v.getDimension());
SparseRealVector res = new SparseRealVector(this);
Iterator iter = v.getEntries().iterator();
OpenIntToDoubleHashMap values = res.getEntries();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (entries.containsKey(key)) {
values.put(key, entries.get(key) - iter.value());
} else {
values.put(key, -iter.value());
}
}
return res;
}
public RealVector subtract(RealVector v) throws IllegalArgumentException {
checkVectorDimensions(v.getDimension());
if (v instanceof SparseRealVector) {
return subtract((SparseRealVector) v);
}
return subtract(v.getData());
}
public RealVector subtract(double[] v) throws IllegalArgumentException {
checkVectorDimensions(v.length);
SparseRealVector res = new SparseRealVector(this);
for (int i = 0; i < v.length; i++) {
if (entries.containsKey(i)) {
res.set(i, entries.get(i) - v[i]);
} else {
res.set(i, -v[i]);
}
}
return res;
}
public RealVector unitVector() {
RealVector res = copy();
res.unitize();
return res;
}
public void unitize() {
double norm = getNorm();
if(isZero(norm)){
throw  MathRuntimeException.createArithmeticException("cannot normalize a zero norm vector",
null);
}
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
entries.put(iter.key(), iter.value() / norm);
}
}
private void checkIndex(final int index) throws MatrixIndexException {
if (index < 0 || index >= getDimension()) {
throw new MatrixIndexException(
"index {0} out of allowed range [{1}, {2}]", new Object[] {
index, 0, getDimension() - 1 });
}
}
public void checkVectorDimensions(int n) throws IllegalArgumentException {
if (getDimension() != n) {
throw new IllegalArgumentException("vector dimension is "
+ getDimension() + ", not " + n + " as expected");
}
}
public double[] toArray() {
return getData();
}
}public SparseRealVector add(SparseRealVector v) {
SparseRealVector res = (SparseRealVector) copy();
Iterator iter = res.getEntries().iterator();
if (v.getEntries().containsKey(key)) {
res.setEntry(key, iter.value() + v.getEntry(key));
iter = v.getEntries().iterator();
while (iter.hasNext()) {
iter.advance();
int key = iter.key();
if (!entries.containsKey(key)) {
public double getDistance(SparseRealVector v) {
public SparseRealMatrix outerproduct(SparseRealVector v){
public SparseRealVector subtract(SparseRealVector v) {
SparseRealVector res = new SparseRealVector(this);
OpenIntToDoubleHashMap values = res.getEntries();
values.put(key, entries.get(key) - iter.value());
values.put(key, -iter.value());private static class RootsOfUnity {throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("Incorrect row dimension");
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("constant vector has wrong length");
throw new IllegalArgumentException("Incorrect row dimension");
"index {0} out of allowed range [{1}, {2}]", new Object[] {
index, 0, getDimension() - 1 });
throw new IllegalArgumentException("vector dimension is "
+ getDimension() + ", not " + n + " as expected");throw MathRuntimeException.createIllegalArgumentException("wrong array size (got {0}, expected {1})",
new Object[] {
data.length,
expectedLength
});
new Object[] { columns, length }); 
throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
new Object[] {
refLength, subRow.length
}); 
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
nRows, 1
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
1, vector.getDimension(),
1, columns
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
vector.getDimension(), 1,
rows, 1
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
1, array.length,
1, columns
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
array.length, 1,
rows, 1
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, columns
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, rows
});
"Argument {0} outside domain [{1} ; {2}]",
new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });
private static final long serialVersionUID = 4380655778005469702L;
super("Convergence failed", null);
public ConvergenceException(String pattern, Object[] arguments) {
public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
super("dimension mismatch {0} != {1}",
new Object[] {
Integer.valueOf(dimension1), Integer.valueOf(dimension2)
});
new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });
private static final long serialVersionUID = -2193260774031645876L;
super("Evaluation failed for argument = {0}",
new Object[] { Double.valueOf(argument) });
String pattern, Object[] arguments) {
public FunctionEvaluationException(double argument, Throwable cause) {
public FunctionEvaluationException(double argument,
String pattern, Object[] arguments,
Throwable cause) {
super(pattern, arguments, cause);
public MathConfigurationException(String pattern, Object[] arguments) {
public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {
super(pattern, arguments, cause);
private static final long serialVersionUID = 5924076008552401454L;
private static String buildMessage(String pattern, Object[] arguments, Locale locale) {
public MathException(String pattern, Object[] arguments) {
super(buildMessage(pattern, arguments, Locale.US));
public MathException(String pattern, Object[] arguments, Throwable rootCause) {
super(buildMessage(pattern, arguments, Locale.US), rootCause);
return buildMessage(pattern, arguments, locale);
private static final long serialVersionUID = -143052521750625264L;
private static String buildMessage(final String pattern, final Object[] arguments,
final Locale locale) {
public MathRuntimeException(final String pattern, final Object[] arguments) {
super(buildMessage(pattern, arguments, Locale.US));
public MathRuntimeException(final String pattern, final Object[] arguments,
final Throwable rootCause) {
super(buildMessage(pattern, arguments, Locale.US), rootCause);
return buildMessage(pattern, arguments, locale);
final Object[] arguments) {
return new ArithmeticException(buildMessage(pattern, arguments, Locale.US)) {
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new ArrayIndexOutOfBoundsException(buildMessage(pattern, arguments, Locale.US)) {
private static final long serialVersionUID = 8077627622976962141L;
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new EOFException(buildMessage(pattern, arguments, Locale.US)) {
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new IllegalArgumentException(buildMessage(pattern, arguments, Locale.US)) {
private static final long serialVersionUID = -7537852425838457684L;
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new IllegalStateException(buildMessage(pattern, arguments, Locale.US)) {
private static final long serialVersionUID = 5173599768297434381L;
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new ConcurrentModificationException(buildMessage(pattern, arguments, Locale.US)) {
return buildMessage(pattern, arguments, Locale.getDefault());
final Object[] arguments) {
return new NoSuchElementException(buildMessage(pattern, arguments, Locale.US)) {
return buildMessage(pattern, arguments, Locale.getDefault());
public static ParseException createParseException(final String pattern,
final Object[] arguments,
final int offset) {
return new ParseException(buildMessage(pattern, arguments, Locale.US), offset) {
return buildMessage(pattern, arguments, Locale.getDefault());
private static final long serialVersionUID = -2154780004193976271L;
private int maxIterations;
public MaxIterationsExceededException(int maxIterations) {
super("Maximal number of iterations ({0}) exceeded",
new Object[] { Integer.valueOf(maxIterations) });
public MaxIterationsExceededException(int maxIterations,
String pattern, Object[] arguments) {
new Object[] { n, 2, 5 });
new Object[] { 0, 32 });
new Object[] { 0, 64 });
new Object[] { 0, 64 });
throw MathRuntimeException.createIllegalStateException("no result available", null);
new Object[] { lower, upper });
new Object[] { minimalIterationCount, maximalIterationCount });
throw MathRuntimeException.createIllegalStateException("no result available", null);
throw new FunctionEvaluationException(z, e.getPattern(), e.getArguments(), e);
new Object[] {
i, k, x[i]
});
new Object[] { min, max, yMin, yMax });       
throw MathRuntimeException.createIllegalArgumentException("function is not polynomial", null);
throw MathRuntimeException.createIllegalArgumentException("function is not polynomial", null);
throw MathRuntimeException.createIllegalArgumentException("function is not differentiable",
null);
throw MathRuntimeException.createIllegalArgumentException("function to solve cannot be null",
null);
throw MathRuntimeException.createIllegalStateException("no result available", null);
new Object[] { lower, upper });
new Object[] { lower, initial, upper });
new Object[] { lower, upper, f.value(lower), f.value(upper) });       
new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),
Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),
Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });
throw MathRuntimeException.createIllegalArgumentException("cannot compute nth root for null or negative n: {0}",
new Object[] { n });
throw MathRuntimeException.createParseException("unparseable complex number: \"{0}\"",
new Object[] { source },
parsePosition.getErrorIndex());
throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);
throw new MathException("Cannot compute beta density at 0 when alpha = {0,number}", new Double[]{alpha});
throw new MathException("Cannot compute beta density at 1 when beta = %.3g", new Double[]{beta});
throw MathRuntimeException.createIllegalArgumentException("invalid number of elements {0}" +
" (must be positive)",
new Object[] { n });
throw MathRuntimeException.createIllegalArgumentException("invalid exponent {0} (must be positive)",
new Object[] { s });
new Object[] { Integer.valueOf(maxCostEval) });
throw new EstimationException("unable to compute covariances: singular problem",
null);
throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",
new Object[] { Integer.valueOf(m), Integer.valueOf(p)});
public EstimationException(String specifier, Object[] parts) {
throw new EstimationException("unable to solve: singular problem", null);
new Object[] { Double.valueOf(costRelativeTolerance) });
new Object[] { Double.valueOf(parRelativeTolerance) });
new Object[] { Double.valueOf(orthoTolerance) });
throw new EstimationException("unable to perform Q.R decomposition on the {0}x{1} jacobian matrix",
new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });
new Object[] { num, den});
new Object[] { num, den});
new Object[] { numerator, denominator});
new Object[] { w });
throw MathRuntimeException.createArithmeticException("the fraction to divide by must not be zero: {0}/{1}",
new Object[] { fraction.numerator, fraction.denominator });
throw MathRuntimeException.createArithmeticException("zero denominator in fraction {0}/{1}",
new Object[] { numerator, denominator});
throw MathRuntimeException.createArithmeticException("overflow in fraction {0}/{1}, cannot negate",
new Object[] { numerator, denominator});
super("Unable to convert {0} to fraction after {1} iterations",
new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });
super("Overflow trying to convert {0} to fraction ({1}/{2})",
new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });
throw MathRuntimeException.createParseException("unparseable fraction number: \"{0}\"",
new Object[] { source },
parsePosition.getErrorIndex());
super(isCardan ? "Cardan angles singularity" : "Euler angles singularity", null);
public NotARotationMatrixException(String specifier, Object[] parts) {
throw MathRuntimeException.createArithmeticException("zero norm for rotation axis",
null);
throw new NotARotationMatrixException("a {0}x{1} matrix" +
" cannot be a rotation matrix",
new Object[] {
Integer.toString(m.length),
Integer.toString(m[0].length)
});
throw new NotARotationMatrixException("the closest orthogonal matrix" +
" has a negative determinant {0}",
new Object[] {
Double.toString(det)
});
throw new NotARotationMatrixException("unable to orthogonalize matrix" +
" in {0} iterations",
new Object[] {
Integer.toString(i - 1)
});
throw MathRuntimeException.createArithmeticException("cannot normalize a zero norm vector",
null);
throw MathRuntimeException.createArithmeticException("zero norm", null);
throw MathRuntimeException.createArithmeticException("zero norm", null);
throw MathRuntimeException.createParseException("unparseable 3D vector: \"{0}\"",
new Object[] { source },
parsePosition.getErrorIndex());
throw MathRuntimeException.createIllegalArgumentException("invalid row dimension {0}" +
" (must be positive)",
new Object[] { rowDimension });
throw MathRuntimeException.createIllegalArgumentException("invalid column dimension {0}" +
" (must be positive)",
new Object[] { columnDimension });
new Object[] {
destination.length, destination[0].length,
rowsCount, columnsCount
});
new Object[] {
destination.length, destination[0].length,
selectedRows.length, selectedColumns.length
});
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one row",
null); 
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column",
null); 
throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
new Object[] {
nCols, subMatrix[r].length
}); 
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
nRows, 1
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
1, vector.getDimension(),
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
vector.getDimension(), 1,
nRows, 1
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
1, array.length,
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
array.length, 1,
nRows, 1
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, nCols
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.getDimension(), nCols
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, nRows
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.getDimension(), nRows
});
new Object[] { row, 0, getRowDimension() - 1});
new Object[] { column, 0, getColumnDimension() - 1});
new Object[] { startRow, endRow });
new Object[] { startColumn, endColumn });
throw new MatrixIndexException("empty selected row index array", null);
throw new MatrixIndexException("empty selected column index array", null);
throw MathRuntimeException.createIllegalArgumentException("{0}x{1} and {2}x{3} matrices are not" +
" addition compatible",
new Object[] {
getRowDimension(),
getColumnDimension(),
m.getRowDimension(),
m.getColumnDimension()
});
throw MathRuntimeException.createIllegalArgumentException("{0}x{1} and {2}x{3} matrices are not" +
" subtraction compatible",
new Object[] {
getRowDimension(),
getColumnDimension(),
m.getRowDimension(),
m.getColumnDimension()
});
throw MathRuntimeException.createIllegalArgumentException("{0}x{1} and {2}x{3} matrices are not" +
" multiplication compatible",
new Object[] {
getRowDimension(),
getColumnDimension(),
m.getRowDimension(),
m.getColumnDimension()
});
new Object[] { startRow, endRow });
new Object[] { startColumn, endColumn });
throw new MatrixIndexException("empty selected row index array", null);
throw new MatrixIndexException("empty selected column index array", null);
throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
new Object[] { row });
throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
new Object[] { column });
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new IllegalArgumentException("matrix is not square");
if (v.length != this.getColumnDimension()) {
throw new IllegalArgumentException("vector has wrong length");
throw new IllegalArgumentException("vector has wrong length");
throw new IllegalArgumentException("constant vector has wrong length");
if (b.getRowDimension() != this.getRowDimension()) {
throw new IllegalArgumentException("Incorrect row dimension");
if (!this.isSquare()) {
throw new MatrixIndexException("row index {0} out of allowed range [{1}, {2}]",
new Object[] { row, 0, getRowDimension() - 1});
throw new MatrixIndexException("column index {0} out of allowed range [{1}, {2}]",
new Object[] { column, 0, getColumnDimension() - 1});
throw MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})",
new Object[] {
blockData[index].length,
iHeight * blockWidth(jBlock)
});
new Object[] { columns, length }); 
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column",
null);             
throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
new Object[] {
refLength, subRow.length
}); 
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
matrix.getRowDimension(),
matrix.getColumnDimension(),
nRows, 1
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
1, array.length,
1, nCols
});
throw new InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}",
new Object[] {
array.length, 1,
nRows, 1
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, columns
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, rows
});
public InvalidMatrixException(final String pattern, final Object[] arguments) {
public MatrixIndexException(final String pattern, final Object[] arguments) {
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one row",
null); 
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column",
null); 
throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while" +
" others have length {1}",
new Object[] { nCols, d[r].length });
throw MathRuntimeException.createIllegalStateException("first {0} rows are not initialized yet",
new Object[] { row });
throw MathRuntimeException.createIllegalStateException("first {0} columns are not initialized yet",
new Object[] { column });
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one row",
null); 
throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column",
null); 
throw MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}",
new Object[] {
nCols, subMatrix[i].length
}); 
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw new MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix",
new Object[] {
row, column,
getRowDimension(), getColumnDimension()
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, nCols
});
throw MathRuntimeException.createIllegalArgumentException("vector length mismatch:" +
" got {0} but expected {1}",
new Object[] {
v.length, nRows
});
throw MathRuntimeException.createParseException("unparseable real vector: \"{0}\"",
new Object[] { source },
parsePosition.getErrorIndex());
throw MathRuntimeException.createArithmeticException("zero norm", null);
throw MathRuntimeException.createArithmeticException("cannot normalize a zero norm vector",
null);
throw new MatrixIndexException("index {0} out of allowed range [{1}, {2}]",
new Object[] { index, 0, getDimension() - 1});
throw  MathRuntimeException.createArithmeticException("cannot normalize a zero norm vector",
null);
new Object[] { index, 0, getDimension() - 1 });
new Object[] { getDimension(), n });
new Object[] { b.length, m });
new Object[] { b.getDimension(), m });
new Object[] { b.getRowDimension(), b.getColumnDimension(), m, "n"});
throw new InvalidMatrixException("eigen decomposition of assymetric matrices not supported yet",
null);
new Object[] { b.length, m });
new Object[] { b.getDimension(), m });
new Object[] {
b.getRowDimension(), b.getColumnDimension(),
m, "n"
});
throw new InvalidMatrixException("cannot solve degree {0} equation", new Object[] { 2 });
throw new InvalidMatrixException("cannot solve degree {0} equation", new Object[] { 3 });           
new Object[] { b.length, m });
new Object[] { b.getDimension(), m });
new Object[] { b.getRowDimension(), b.getColumnDimension(), m, "n"});
new Object[] { rows, columns });
super("not positive definite matrix", null);
super("not symmetric matrix", null);
new Object[] { b.length, m });
new Object[] { b.getRowDimension(), b.getColumnDimension(), m, "n"});
super("matrix is singular", null);
new Object[] { b.length, singularValues.length });
new Object[] { b.getDimension(), singularValues.length });
new Object[] {
b.getRowDimension(), b.getColumnDimension(),
singularValues.length, "n"
});
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" initial state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y0.length)
});
throw new IntegratorException("dimensions mismatch: ODE problem has dimension {0}," +
" final state vector has dimension {1}",
new Object[] {
Integer.valueOf(equations.getDimension()),
Integer.valueOf(y.length)
});
throw new IntegratorException("too small integration interval: length = {0}",
new Object[] {
Double.valueOf(Math.abs(t - t0))
});
throw new MathRuntimeException("unexpected exception caught", null, de);
public DerivativeException(final String specifier, final Object[] parts) {
private static final long serialVersionUID = -4100440615830558122L;
public IntegratorException(final String specifier, final Object[] parts) {
private static final long serialVersionUID = -1215318282266670558L;
public EventException(final String specifier, final Object[] parts) {
throw new FunctionEvaluationException(t, e);
throw new FunctionEvaluationException(t, e);
throw new IntegratorException("dimensions mismatch: state vector has dimension {0}," +
" absolute tolerance vector has dimension {1}",
new Object[] {
Integer.valueOf(y0.length),
Integer.valueOf(vecAbsoluteTolerance.length)
});
throw new IntegratorException("dimensions mismatch: state vector has dimension {0}," +
" relative tolerance vector has dimension {1}",
new Object[] {
Integer.valueOf(y0.length),
Integer.valueOf(vecRelativeTolerance.length)
});
throw new IntegratorException("minimal step size ({0}) reached," +
" integration needs {1}",
new Object[] {
Double.valueOf(minStep),
Double.valueOf(Math.abs(h))
});
public CostException(String pattern, Object[] arguments) {
throw new MathRuntimeException("unexpected exception caught", null, dme);
throw new ConvergenceException("none of the {0} start points" +
" lead to convergence",
new Object[] {
Integer.toString(starts)
});
new Object[] { url });
throw MathRuntimeException.createIllegalStateException("distribution not loaded",
null);
throw new MathRuntimeException("no bin selected", null);
default: throw MathRuntimeException.createIllegalStateException("unknown mode {0}, known modes: " +
"{1} ({2}), {3} ({4}), {5} ({6}), " +
"{7} ({8}), {9} ({10}) and {11} ({12})",
new Object[] {
mode,
"DIGEST_MODE",      DIGEST_MODE,
"REPLAY_MODE",      REPLAY_MODE,
"UNIFORM_MODE",     UNIFORM_MODE,
"EXPONENTIAL_MODE", EXPONENTIAL_MODE,
"GAUSSIAN_MODE",    GAUSSIAN_MODE,
"CONSTANT_MODE",    CONSTANT_MODE
});
throw MathRuntimeException.createIllegalStateException("digest not initialized", null);
new Object[] { valuesFileURL });
"Arrays must have the same length and both must have at " +
new Object[] {xArray.length, yArray.length});
"Insufficient data:  only {0} rows and {1} columns.",
new Object[]{nRows, nCols});
throw MathRuntimeException.createIllegalArgumentException(
"Covariance matrix is null", null);
"Invalid array dimensions. xArray has size {0}; yArray has {1} elements",
new Object[] {xArray.length, yArray.length});
"Insufficient data: only {0} rows and {1} columns.",
new Object[]{nRows, nCols});
throw MathRuntimeException.createIllegalStateException("{0} values have been added before statistic is configured",
new Object[] { n });
throw MathRuntimeException.createIllegalStateException("{0} values have been added before statistic is configured",
new Object[] { n });
throw MathRuntimeException.createIllegalStateException("{0} values have been added before statistic is configured",
new Object[] { getN() });
throw MathRuntimeException.createIllegalStateException("statistics constructed from external " +
"moments cannot be incremented",
null);
throw MathRuntimeException.createIllegalStateException("statistics constructed from external " +
"moments cannot be cleared",
null);
throw MathRuntimeException.createIllegalArgumentException("{0} is not a power of 2 plus one",
new Object[] { f.length });
throw MathRuntimeException.createIllegalArgumentException("number of sample is not positive: {0}",
new Object[] { n });
throw MathRuntimeException.createIllegalArgumentException("{0} is not a power of 2, consider padding for fix",
new Object[] { d.length });
throw MathRuntimeException.createIllegalArgumentException("{0} is not a power of 2, consider padding for fix",
new Object[] { o.length });
throw MathRuntimeException.createIllegalArgumentException("endpoints do not specify an interval: [{0}, {1}]",
new Object[] { lower, upper });
throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
new Object[] { 0, dimensionSize.length });
throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
new Object[] {
vector.length,
dimensionSize.length
});
throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
new Object[] { 0, dimensionSize.length });
throw MathRuntimeException.createIllegalArgumentException("some dimensions don't math: {0} != {1}",
new Object[] {
vector.length,
dimensionSize.length
});
"roots of unity have not been computed yet",
null);
"cannot compute 0-th root of unity, indefinite result",
null);
"roots of unity have not been computed yet",
null);
new Object[] { k, 0, omegaCount - 1 });
"roots of unity have not been computed yet",
null);
new Object[] { k, 0, omegaCount - 1 });
throw MathRuntimeException.createIllegalArgumentException("{0} is not a power of 2",
new Object[] { n });
throw MathRuntimeException.createIllegalArgumentException("{0} is not a power of 2",
new Object[] { n });
throw MathRuntimeException.createIllegalArgumentException("first element is not 0: {0}",
new Object[] { f[0] });
new Object[] { Double.valueOf(x) });
new Object[] { Double.valueOf(x) });
throw new MathException("Conversion Exception in Transformation, Object is null", null);
throw new MathException("Conversion Exception in Transformation: {0}",
new Object[] { e.getMessage() }, e);
new Object[] { p, q });
new Object[] { p, q });
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating",
null);
throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating",
null);
throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating",
null);
throw MathRuntimeException.createNoSuchElementException("iterator exhausted", null);
"cannot substitute an element from an empty array", null);
String msg =
"Contraction criteria can never be smaller than " +
"the expansion factor.  This would lead to a never " +
"ending loop of expansion and contraction as a newly " +
"expanded internal storage array would immediately " +
"satisfy the criteria for contraction";
throw new IllegalArgumentException(msg);
String msg =
"The contraction criteria must be a number larger " +
"than one.  If the contractionCriteria is less than or " +
"equal to one an endless loop of contraction and " +
"expansion would ensue as an internalArray.length " +
"== numElements would satisfy the contraction criteria";
throw new IllegalArgumentException(msg);
String msg =
"The expansion factor must be a number greater than 1.0";
throw new IllegalArgumentException(msg);
String msg = "Cannot discard more elements than are" +
"contained in this array.";
throw new IllegalArgumentException(msg);
} else if (i < 0) {
String msg = "Cannot discard a negative number of elements.";
throw new IllegalArgumentException(msg);
throw MathRuntimeException.createArrayIndexOutOfBoundsException("the index specified: {0} is larger than the current maximal index {1}",
new Object[] { index, numElements - 1 });
throw MathRuntimeException.createArrayIndexOutOfBoundsException("elements cannot be retrieved from a negative array index {0}",
new Object[] { index });
throw MathRuntimeException.createArrayIndexOutOfBoundsException("cannot set an element at a negative index {0}",
new Object[] { index });
throw new IllegalArgumentException("Illegal expansionMode setting.");  
} else {
String msg =
"The initial capacity supplied: " + initialCapacity +
"must be a positive integer";
throw new IllegalArgumentException(msg);
String msg =
"Number of elements must be zero or a positive " + "integer";
throw new IllegalArgumentException(msg);
ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);
FunctionEvaluationException ex = new FunctionEvaluationException(0.0, cause);
MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);
MathException ex = new MathException(pattern, arguments, cause);
MathException cause = new MathConfigurationException(inMsg, null);
MathException ex = new MathException(outMsg, null, cause);
MathException cause = new MathConfigurationException(inMsg, null);
MathException ex = new MathException(outMsg, null, cause);
new Object[] { Double.valueOf(1234567) });
throw new InvalidMatrixException("incorrect dimensions", null);
InvalidMatrixException ex = new InvalidMatrixException(msg, null);
MatrixIndexException ex = new MatrixIndexException(msg, null);
throw new InvalidMatrixException("incorrect dimensions", null);
private int n;
throw new DerivativeException("{0}", new String[] { "oops" });
throw new EventException("Evaluation failed for argument = {0}",
new Object[] { Double.valueOf(t) });
throw new CostException("{0}", new Object[] { "oops"});
throw new CostException("{0}", new Object[] { "oops"});
throw new MathRuntimeException("?", null);fail("Expecting illegalArgumentException");
} catch (IllegalArgumentException ex) {final boolean copyArray) {
this.target    = target;
this.weights   = weights;
implements RandomVectorGenerator {
public interface NormalizedRandomGenerator {
public interface RandomVectorGenerator {
new double[] { 4.0, 6.0, 1.0 });public interface RealVector {Integer basicRow = getBasicRow(getNumObjectiveFunctions() + decisionVariable);
return basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); 
public void testSomething() throws OptimizationException {
assertEquals(13366.0, solution.getValue(), .0000001);assertEquals(ci, l40[i], ci * 1.0e-15);{ "some dimensions don't math: {0} != {1}",
"some dimensions don't math: {0} != {1}",
"some dimensions don't math: {0} != {1}",
"some dimensions don't math: {0} != {1}",
"some dimensions don't math: {0} != {1}",if (Double.isInfinite(iter.value())) {
return true;
return false;
assertFalse(v.isInfinite()); // NaN is checked before infinity
assertEquals(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),double c2 = c1
+ Math.sqrt(Math.PI * muDeltaHalf
/ (2.0 * Math.exp(1.0 / mu2delta)));
double c = c4 + 2.0 / delta * mu2delta
accept = (w <= x * Math.log(mu)
- MathUtils.factorialLog((int) (mu + x))
/ muFactorialLog);int[][] bdArray      = AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);
correctorCoeffs = new double[order + 1];
for (int i = 0; i <= order; ++i) {
for (int j = i; j <= order; ++j) {
double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs();
double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs();
double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs();
double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs();
double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs();
double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs();
double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs();
double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs();
assertTrue(handler.getLastError() < 7.0e-12);
assertTrue(handler.getMaximalValueError() < 4.0e-11);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);final T[][] blockData, final boolean copyArray)
private static final long serialVersionUID = -1741417096265465690L;
final List<T> points;
final T center;
private static final long serialVersionUID = 1L;final int rowDimension, final int columnDimension)
public SparseFieldMatrix(SparseFieldMatrix<T> other){
for(int i=0; i < rowDimension; i++){
for(int j=0; j < columnDimension; j++){
entries = new OpenIntToFieldHashMap<T> (field,expectedSize);
if(v instanceof SparseFieldVector)
return append((SparseFieldVector<T>)v);
else
throws IllegalArgumentException {
if(v instanceof SparseFieldVector)
else
if (this == obj)
if (obj == null)
if (!(obj instanceof SparseFieldVector))
if (other.field != null)
} else if (!field.equals(other.field))
if (virtualSize != other.virtualSize)private static final double C_LIMIT = 49;
private static final double S_LIMIT = 1e-5;out.writeInt(currentState.length);
for (int i = 0; i < currentState.length; ++i) {
yDotKLast[0] = new double[dimension];
yDotKLast[1] = new double[dimension];
yDotKLast[2] = new double[dimension];
final int dimension = currentState.length;
final int dimension = currentState.length;
out.writeInt(yDotK.length);
for (int k = 0; k < yDotK.length; ++k) {
for (int i = 0; i < currentState.length; ++i) {
yDotK = new double[kMax][];
yDotK[k] = new double[currentState.length];
for (int i = 0; i < currentState.length; ++i) {
setInterpolatedTime(t);
} catch (DerivativeException e) {
throw MathRuntimeException.createIOException(e);
out.writeInt(currentState.length);
for (int i = 0; i < currentState.length; ++i) {
out.writeDouble(currentState[i]);
currentState  = new double[dimension];
for (int i = 0; i < currentState.length; ++i) {
currentState[i] = in.readDouble();
interpolatedState       = new double[dimension];
interpolatedDerivatives = new double[dimension];result = prime * result
+ ((freqTable == null) ? 0 : freqTable.hashCode());private final RealVector coefficients;
private final RealVector coefficients;
protected RealMatrix tableau;stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
if (Math.abs(root - ta) <= convergence) {
(Math.abs(previousEventTime - root) > convergence)) {interpolator.reinitialize(stepSize, scaled, nordsieck);if (lTData[i][i] < absolutePositivityThreshold) {
throw new NotPositiveDefiniteMatrixException();
public class CholeskyDecompositionImplTest extends TestCase {
public CholeskyDecompositionImplTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(CholeskyDecompositionImplTest.class);
suite.setName("CholeskyDecompositionImpl Tests");
return suite;
public void testNonSquare() {
new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));
} catch (NonSquareMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
public void testNotSymmetricMatrixException() {
double[][] changed = testData.clone();
changed[0][changed[0].length - 1] += 1.0e-5;
new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));
} catch (NotSymmetricMatrixException e) {
} catch (Exception e) {
fail("wrong exception caught");
public void testNotPositiveDefinite() {
new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {
{ 14, 11, 13, 15, 24 },
{ 11, 34, 13, 8,  25 },
{ 13, 13, 14, 15, 21 },
{ 15, 8,  15, 18, 23 },
{ 24, 25, 21, 23, 45 }
}));
} catch (NotPositiveDefiniteMatrixException e) {
} catch (Exception e) {
fail("wrong exception caught");
assertEquals(0.0, l.getEntry(i, j));public class AdamsIntegrator extends MultistepIntegrator {
private static final long serialVersionUID = -5893911062100008922L;
private static final String NO_CORRECTION_METHOD_NAME = "Adams-Bashforth";
private static final String CORRECTION_METHOD_NAME = "Adams-Moulton";
private final boolean withCorrection;
public AdamsIntegrator(final int order, final boolean withCorrection,
final double step)
super(withCorrection ? CORRECTION_METHOD_NAME : NO_CORRECTION_METHOD_NAME,
order, new NordsieckStepInterpolator());
this.withCorrection = withCorrection;
final NordsieckStepInterpolator interpolator =
(NordsieckStepInterpolator) prototype.copy();
interpolator.reinitialize(yTmp, forward);
System.arraycopy(y, 0, yTmp, 0, n);
interpolator.reinitialize(stepSize, scaled, nordsieck);
if (withCorrection) {
equations.computeDerivatives(stepEnd, interpolator.getInterpolatedState(), f0);
nordsieck = coefficients.msUpdate.multiply(nordsieck);
final double[] end = new double[y0.length];
end[j] = stepSize * f0[j];
nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));
scaled = end;
nordsieck.walkInOptimizedOrder(new Corrector(y, scaled, yTmp));
interpolator.reinitialize(stepSize, scaled, nordsieck);
interpolator.storeTime(stepStart + stepSize);
if (manager.evaluateStep(interpolator)) {
stepSize = manager.getEventTime() - stepStart;
interpolator.setInterpolatedTime(nextStep);
System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, n);
if (!lastStep) {
if (manager.reset(stepStart, y)) {
stopTime =
start(previousF.length, stepSize, manager, equations, stepStart, y);
if (Double.isNaN(previousT[0])) {
return stopTime;
stepStart = previousT[0];
scaled    = convertToNordsieckLow();
nordsieck = convertToNordsieckHigh(scaled);
interpolator.reinitialize(stepSize, scaled, nordsieck);
interpolator.storeTime(stepStart);
} else {
final double[] f0 = previousF[0];
previousT[0] = stepStart;
equations.computeDerivatives(stepStart, y, f0);
if (!withCorrection) {
nordsieck = coefficients.msUpdate.multiply(nordsieck);
final double[] end = new double[y0.length];
for (int j = 0; j < y0.length; ++j) {
end[j] = stepSize * f0[j];
nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));
scaled = end;
interpolator.reinitialize(stepSize, scaled, nordsieck);
System.arraycopy(y, 0, yTmp, 0, n);
final Class<AdamsIntegrator> cl = AdamsIntegrator.class;
package org.apache.commons.math.ode.nonstiff;
public class AdamsIntegratorTest {
public void dimensionCheckBashforth() throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
new AdamsIntegrator(3, false, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
public void decreasingStepsBashforth() throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
FirstOrderIntegrator integ = new AdamsIntegrator(5, false, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {
assertTrue(error <= Math.abs(1.05 * previousError));
previousError = error;
public void smallStepBashforth() throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsIntegrator(3, false, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 2.0e-9);
assertTrue(handler.getMaximalValueError() < 9.0e-9);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
assertEquals("Adams-Bashforth", integ.getName());
public void bigStepBashforth() throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsIntegrator(3, false, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() > 0.06);
assertTrue(handler.getMaximalValueError() > 0.06);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);
public void backwardBashforth() throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsIntegrator(5, false, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 8.0e-11);
assertTrue(handler.getMaximalValueError() < 8.0e-11);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);
assertEquals("Adams-Bashforth", integ.getName());
public void polynomialBashforth() throws DerivativeException, IntegratorException {
TestProblem6 pb = new TestProblem6();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;
for (int order = 2; order < 9; ++order) {
AdamsIntegrator integ = new AdamsIntegrator(order, false, step);
integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,
1.0e-5, 1.0e-5));
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (order < 5) {
assertTrue(handler.getMaximalValueError() > 1.0e-5);
} else {
assertTrue(handler.getMaximalValueError() < 7.0e-12);
public void serializationBashforth()
throws IntegratorException, DerivativeException,
IOException, ClassNotFoundException {
TestProblem6 pb = new TestProblem6();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream    oos = new ObjectOutputStream(bos);
oos.writeObject(new AdamsIntegrator(8, false, step));
assertTrue(bos.size() > 3000);
assertTrue(bos.size() < 3100);
ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream     ois = new ObjectInputStream(bis);
FirstOrderIntegrator integ  = (AdamsIntegrator) ois.readObject();
assertEquals("Adams-Bashforth", integ.getName());
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalValueError() < 7.0e-13);
public void dimensionCheckMoulton()
throws DerivativeException, IntegratorException {
TestProblem1 pb = new TestProblem1();
new AdamsIntegrator(3, true, 0.01).integrate(pb,
0.0, new double[pb.getDimension()+10],
1.0, new double[pb.getDimension()+10]);
public void decreasingStepsMoulton()
throws DerivativeException, IntegratorException {
TestProblemAbstract[] problems = TestProblemFactory.getProblems();
for (int k = 0; k < problems.length; ++k) {
double previousError = Double.NaN;
for (int i = 6; i < 10; ++i) {
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);
FirstOrderIntegrator integ = new AdamsIntegrator(5, true, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
EventHandler[] functions = pb.getEventsHandlers();
for (int l = 0; l < functions.length; ++l) {
integ.addEventHandler(functions[l],
Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);
double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
if (functions.length == 0) {
assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);
double error = handler.getMaximalValueError();
if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {
assertTrue(error <= Math.abs(1.05 * previousError));
previousError = error;
public void smallStepMoulton()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsIntegrator(3, true, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 1.0e-14);
assertTrue(handler.getMaximalValueError() < 2.0e-17);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);
assertEquals("Adams-Moulton", integ.getName());
public void bigStepMoulton()
throws DerivativeException, IntegratorException {
TestProblem1 pb  = new TestProblem1();
double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;
FirstOrderIntegrator integ = new AdamsIntegrator(3, true, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb,
pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalValueError() > 6.0e-6);
public void backwardMoulton()
throws DerivativeException, IntegratorException {
TestProblem5 pb = new TestProblem5();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
FirstOrderIntegrator integ = new AdamsIntegrator(5, true, step);
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getLastError() < 1.0e-15);
assertTrue(handler.getMaximalValueError() < 3.0e-16);
assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);
assertEquals("Adams-Moulton", integ.getName());
public void polynomialMoulton()
throws DerivativeException, IntegratorException {
TestProblem6 pb = new TestProblem6();
double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;
for (int order = 2; order < 9; ++order) {
AdamsIntegrator integ = new AdamsIntegrator(order, true, step);
integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,
1.0e-5, 1.0e-5));
TestProblemHandler handler = new TestProblemHandler(pb, integ);
integ.addStepHandler(handler);
integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),
pb.getFinalTime(), new double[pb.getDimension()]);
assertTrue(handler.getMaximalValueError() < 2.0e-13);
AdamsIntegrator integ = new AdamsIntegrator(5, false, step);
AdamsIntegrator integ = new AdamsIntegrator(5, false, step);scalingH = interpolator.scalingH;this.maxIterations            = Integer.MAX_VALUE;
this.maxIterations            = Integer.MAX_VALUE;
this.maxIterations    = Integer.MAX_VALUE;
this.maxIterations    = Integer.MAX_VALUE;
optima          = new double[starts];
totalIterations = 0;
private int iterations;
throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
throw new OptimizationException(new MaxEvaluationsExceededException(maxEvaluations));
n, simplex.length);
if (++iterations > maxIterations) {
throw new OptimizationException(new MaxIterationsExceededException(maxIterations));
++objectiveEvaluations;
implements DifferentiableMultivariateRealOptimizer{
if (++iterations > maxIterations) {
throw new OptimizationException(new MaxIterationsExceededException(maxIterations));
++evaluations;
if (++iterations > maxIterations) {
throw new OptimizationException(new MaxIterationsExceededException(maxIterations));
iterations = 0;
double fx = f.value(x);
double fu = f.value(u);
} catch (OptimizationException oe) {
if (oe.getCause() instanceof ConvergenceException) {
throw (ConvergenceException) oe.getCause();
throw oe;super("Adams-Bashforth", nSteps, nSteps + 1, minStep, maxStep,
super("Adams-Bashforth", nSteps, nSteps + 1, minStep, maxStep,
assertTrue(handler.getMaximalValueError() > (28.0 * scalAbsoluteTolerance));
assertTrue(handler.getMaximalValueError() < (42.0 * scalAbsoluteTolerance));AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);
AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);public static final BigFraction TWO_FIFTHS = new BigFraction(4, 5);
public static final Fraction TWO_FIFTHS = new Fraction(4, 5);throws IOException;
throws IOException {
if ((scaled != null) && (nordsieck != null)) {
assertTrue(bos.size () >  16000);
assertTrue(bos.size () <  17000);if (! (another instanceof RandomKey))
if (!(original instanceof RandomKey)) {
if (v instanceof SparseFieldVector) {
if(v instanceof SparseFieldVector)
if(v instanceof SparseFieldVector)
if (v instanceof SparseFieldVector) {
private class MultiDimensionalComplexMatrix
implements Serializable, Cloneable {
private static final long serialVersionUID =  0x564FCD47EBA8169BL;
float contractionCritera,
if (contractionCritera < expansionFactor) {
contractionCritera, expansionFactor);
contractionCriteria);
this.contractionCriteria = contractionCriteria;
this.expansionFactor = expansionFactor;
this.expansionMode = expansionMode;
public int hashCode() {
synchronized(this) {
public double getA() {
return a.getEstimate();
public double getB() {
return b.getEstimate();
public double getC() {
return c.getEstimate();
DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});
DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});
checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, -1, 1, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);
checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);
if (mustFail) {
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, -1, 1, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, new int[] {},    new int[] { 0 }, true);
checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, -1, 1, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);
checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new BlockRealMatrix(reference), sub);
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new BlockRealMatrix(reference), sub);
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, -1, 1, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, new int[] {},    new int[] { 0 }, true);
checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
double multiplier = 1d;
if (multiplier == 1d && Math.abs(colEntry) > 1E-14
checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, -1, 1, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 2, true);
checkGetSubMatrix(m, null,  1, 0, 2, 4, true);
checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);
checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);
checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);
checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   
checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  
checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  
checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); 
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, -1, 1, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 2, true);
checkCopy(m, null,  1, 0, 2, 4, true);
checkCopy(m, null, new int[] {},    new int[] { 0 }, true);
checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);
int startRow, int endRow, int startColumn, int endColumn,
boolean mustFail) {
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
int[] selectedRows, int[] selectedColumns,
boolean mustFail) {
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));
if (mustFail) {
fail("Expecting MatrixIndexException");
if (!mustFail) {
assertTrue(m2 instanceof SparseFieldMatrix);
assertTrue(m4 instanceof SparseFieldMatrix);
assertTrue(m2 instanceof OpenMapRealMatrix);
assertTrue(m4 instanceof OpenMapRealMatrix);
public Object clone() {
public Object clone() {
public Object clone() {
public Object clone() {
public Object clone() {
return new TestProblem6(this);
implements FirstOrderDifferentialEquations, Cloneable {
public abstract Object clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblem1 pb2 = (TestProblem1) pb1.clone();
TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();
public BadStepInterpolator() {
super();
public BadStepInterpolator(double[] y, boolean forward) {
super(y, forward);
protected void doFinalize()
throws DerivativeException {
private class Rosenbrock implements MultivariateRealFunction {
private class Rosenbrock implements MultivariateRealFunction {
private class Powell implements MultivariateRealFunction {
optimum =
optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });
public int getN() {
return points.size();
Long cachedResult = binomialCache.get(n).get(new Integer(k));
binomialCache.get(n).put(new Integer(k), new Long(result));points.add(new PointModel(px, py));
private class PointModel extends WeightedMeasurement {
public PointModel(double px, double py) {
if (parameter == cx) {
return getPartialDiX() - getPartialRadiusX();
} else if (parameter == cy) {
return getPartialDiY() - getPartialRadiusY();
double dx = px - cx.getEstimate();
double dy = py - cy.getEstimate();
return (cx.getEstimate() - px) / getCenterDistance();
return (cy.getEstimate() - py) / getCenterDistance();
return getCenterDistance() - getRadius();
points.add(new PointModel(px, py));
private class PointModel extends WeightedMeasurement {
public PointModel(double px, double py) {
if (parameter == cx) {
return getPartialDiX() - getPartialRadiusX();
} else if (parameter == cy) {
return getPartialDiY() - getPartialRadiusY();
double dx = px - cx.getEstimate();
double dy = py - cy.getEstimate();
return (cx.getEstimate() - px) / getCenterDistance();
return (cy.getEstimate() - py) / getCenterDistance();
return getCenterDistance() - getRadius();
addMeasurement(new LocalMeasurement(x, y, w));
private class LocalMeasurement extends WeightedMeasurement {
public LocalMeasurement(double x, double y, double w) {
return theoreticalValue(x);
return partial(x, parameter);
measurements[i] = new MinpackMeasurement(i);
private class MinpackMeasurement extends WeightedMeasurement {
public MinpackMeasurement(int index) {
return getResiduals()[index];
for (int j = 0; j < n; ++j) {
if (parameter == parameters[j]) {
return getJacobian()[index][j];new BigMatrixImpl(testData2).getDeterminant().doubleValue();
fail("Expecting InvalidMatrixException");
m.getTrace().doubleValue();
fail("Expecting NonSquareMatrixException");if (fa * fb >= 0.0 ) {
public void testBracketCornerSolution() throws MathException {
UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); 
fail("Expecting ConvergenceException");
} catch (ConvergenceException ex) {this.vecAbsoluteTolerance  = vecAbsoluteTolerance;
this.vecRelativeTolerance  = vecRelativeTolerance;optima[i] = optimizer.optimize(f, goalType,
Math.min(bound1, bound2),
Math.max(bound1, bound2));
optima[i] = Double.NaN;
optima[i] = Double.NaN;
Arrays.sort(optima, 0, lastNaN);
if (goalType == GoalType.MAXIMIZE) {
for (int i = 0, j = lastNaN - 1; i < j; ++i, --j) {
double tmp = optima[i];
optima[i] = optima[j];
optima[j] = tmp;package org.apache.commons.math.stat.clustering;
public interface Clusterable<T> {
double distanceFrom(T p);
T centroidOf(Collection<T> p);
}
package org.apache.commons.math.util;
public class OpenIntToFieldHashMap<T extends FieldElement<T>> implements Serializable {
private static final long serialVersionUID = -9179080286849120720L;
private static final float LOAD_FACTOR = 0.5f;
private static final int DEFAULT_EXPECTED_SIZE = 16;
private static final int RESIZE_MULTIPLIER = 2;
private static final int PERTURB_SHIFT = 5;
protected static final byte FREE    = 0;
protected static final byte FULL    = 1;
protected static final byte REMOVED = 2;
private final Field<T> field;
private int[] keys;
private T[] values;
private byte[] states;
private final T missingEntries;
private int size;
private int mask;
private transient int count;
public OpenIntToFieldHashMap(final Field<T>field) {
this(field, DEFAULT_EXPECTED_SIZE, field.getZero());
}
public OpenIntToFieldHashMap(final Field<T>field, final T missingEntries) {
this(field,DEFAULT_EXPECTED_SIZE, missingEntries);
}
public OpenIntToFieldHashMap(final Field<T> field,final int expectedSize) {
this(field,expectedSize, field.getZero());
}
public OpenIntToFieldHashMap(final Field<T> field,final int expectedSize,
final T missingEntries) {
this.field = field;
final int capacity = computeCapacity(expectedSize);
keys   = new int[capacity];
values = buildArray(capacity);
states = new byte[capacity];
this.missingEntries = missingEntries;
mask   = capacity - 1;
}
public OpenIntToFieldHashMap(final OpenIntToFieldHashMap<T> source) {
field = source.field;
final int length = source.keys.length;
keys = new int[length];
System.arraycopy(source.keys, 0, keys, 0, length);
values = buildArray(length);
System.arraycopy(source.values, 0, values, 0, length);
states = new byte[length];
System.arraycopy(source.states, 0, states, 0, length);
missingEntries = source.missingEntries;
size  = source.size;
mask  = source.mask;
count = source.count;
}
private static int computeCapacity(final int expectedSize) {
if (expectedSize == 0) {
return 1;
}
final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);
final int powerOfTwo = Integer.highestOneBit(capacity);
if (powerOfTwo == capacity) {
return capacity;
}
return nextPowerOfTwo(capacity);
}
private static int nextPowerOfTwo(final int i) {
return Integer.highestOneBit(i) << 1;
}
public T get(final int key) {
final int hash  = hashOf(key);
int index = hash & mask;
if (containsKey(key, index)) {
return values[index];
}
if (states[index] == FREE) {
return missingEntries;
}
for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {
j = probe(perturb, j);
index = j & mask;
if (containsKey(key, index)) {
return values[index];
}
}
return missingEntries;
}
public boolean containsKey(final int key) {
final int hash  = hashOf(key);
int index = hash & mask;
if (containsKey(key, index)) {
return true;
}
if (states[index] == FREE) {
return false;
}
for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {
j = probe(perturb, j);
index = j & mask;
if (containsKey(key, index)) {
return true;
}
}
return false;
}
public Iterator iterator() {
return new Iterator();
}
private static int perturb(final int hash) {
return hash & 0x7fffffff;
}
private int findInsertionIndex(final int key) {
return findInsertionIndex(keys, states, key, mask);
}
private static int findInsertionIndex(final int[] keys, final byte[] states,
final int key, final int mask) {
final int hash = hashOf(key);
int index = hash & mask;
if (states[index] == FREE) {
return index;
} else if (states[index] == FULL && keys[index] == key) {
return changeIndexSign(index);
}
int perturb = perturb(hash);
int j = index;
if (states[index] == FULL) {
while (true) {
j = probe(perturb, j);
index = j & mask;
perturb >>= PERTURB_SHIFT;
if (states[index] != FULL || keys[index] == key) {
break;
}
}
}
if (states[index] == FREE) {
return index;
} else if (states[index] == FULL) {
return changeIndexSign(index);
}
final int firstRemoved = index;
while (true) {
j = probe(perturb, j);
index = j & mask;
if (states[index] == FREE) {
return firstRemoved;
} else if (states[index] == FULL && keys[index] == key) {
return changeIndexSign(index);
}
perturb >>= PERTURB_SHIFT;
}
}
private static int probe(final int perturb, final int j) {
return (j << 2) + j + perturb + 1;
}
private static int changeIndexSign(final int index) {
return -index - 1;
}
public int size() {
return size;
}
public T remove(final int key) {
final int hash  = hashOf(key);
int index = hash & mask;
if (containsKey(key, index)) {
return doRemove(index);
}
if (states[index] == FREE) {
return missingEntries;
}
for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {
j = probe(perturb, j);
index = j & mask;
if (containsKey(key, index)) {
return doRemove(index);
}
}
return missingEntries;
}
private boolean containsKey(final int key, final int index) {
return (key != 0 || states[index] == FULL) && keys[index] == key;
}
private T doRemove(int index) {
keys[index]   = 0;
states[index] = REMOVED;
final T previous = values[index];
values[index] = missingEntries;
--size;
++count;
return previous;
}
public T put(final int key, final T value) {
int index = findInsertionIndex(key);
T previous = missingEntries;
boolean newMapping = true;
if (index < 0) {
index = changeIndexSign(index);
previous = values[index];
newMapping = false;
}
keys[index]   = key;
states[index] = FULL;
values[index] = value;
if (newMapping) {
++size;
if (shouldGrowTable()) {
growTable();
}
++count;
}
return previous;
}
private void growTable() {
final int oldLength      = states.length;
final int[] oldKeys      = keys;
final T[] oldValues = values;
final byte[] oldStates   = states;
final int newLength = RESIZE_MULTIPLIER * oldLength;
final int[] newKeys = new int[newLength];
final T[] newValues = buildArray(newLength);
final byte[] newStates = new byte[newLength];
final int newMask = newLength - 1;
for (int i = 0; i < oldLength; ++i) {
if (oldStates[i] == FULL) {
final int key = oldKeys[i];
final int index = findInsertionIndex(newKeys, newStates, key, newMask);
newKeys[index]   = key;
newValues[index] = oldValues[i];
newStates[index] = FULL;
}
}
mask   = newMask;
keys   = newKeys;
values = newValues;
states = newStates;
}
private boolean shouldGrowTable() {
return size > (mask + 1) * LOAD_FACTOR;
}
private static int hashOf(final int key) {
final int h = key ^ ((key >>> 20) ^ (key >>> 12));
return h ^ (h >>> 7) ^ (h >>> 4);
}
public class Iterator {
private final int referenceCount;
private int current;
private int next;
private Iterator() {
referenceCount = count;
next = -1;
advance();
} catch (NoSuchElementException nsee) {
}
}
public boolean hasNext() {
return next >= 0;
}
public int key()
throws ConcurrentModificationException, NoSuchElementException {
if (referenceCount != count) {
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating");
}
if (current < 0) {
throw MathRuntimeException.createNoSuchElementException("iterator exhausted");
}
return keys[current];
}
public T value()
throws ConcurrentModificationException, NoSuchElementException {
if (referenceCount != count) {
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating");
}
if (current < 0) {
throw MathRuntimeException.createNoSuchElementException("iterator exhausted");
}
return values[current];
}
public void advance()
throws ConcurrentModificationException, NoSuchElementException {
if (referenceCount != count) {
throw MathRuntimeException.createConcurrentModificationException("map has been modified while iterating");
}
current = next;
while (states[++next] != FULL) {
}
} catch (ArrayIndexOutOfBoundsException e) {
next = -2;
if (current < 0) {
throw MathRuntimeException.createNoSuchElementException("iterator exhausted");
}
}
}
}
private void readObject(final ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
count = 0;
}
private T[] buildArray(final int length) {
return (T[]) Array.newInstance(field.getZero().getClass(), length);
}
}
package org.apache.commons.math.linear;
public class SparseFieldVectorTest extends TestCase {
protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};
protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};
protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};
protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};
protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};
protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};
protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};
protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};
protected double entryTolerance = 10E-16;
protected double normTolerance = 10E-14;
protected FractionField field = FractionField.getInstance();
public void testMapFunctions() throws FractionConversionException { 
SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);
FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));
Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};
assertEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());
FieldVector<Fraction> v_mapAddToSelf = v1.copy();
v_mapAddToSelf.mapAddToSelf(new Fraction(2));
Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};
assertEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());
FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));
Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};
assertEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());
FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();
v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));
Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};
assertEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());
FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));
Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};
assertEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());
FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();
v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));
Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};
assertEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());
FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));
Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};
assertEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());
FieldVector<Fraction> v_mapDivideToSelf = v1.copy();
v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));
Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};
assertEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());
FieldVector<Fraction> v_mapInv = v1.mapInv();
Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};
assertEquals("compare vectors" ,result_mapInv,v_mapInv.getData());
FieldVector<Fraction> v_mapInvToSelf = v1.copy();
v_mapInvToSelf.mapInvToSelf();
Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};
assertEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());
}
public void testBasicFunctions() throws FractionConversionException { 
SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);
SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);
SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2); 
FieldVector<Fraction> v_add = v1.add(v2);
Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};
assertEquals("compare vect" ,v_add.getData(),result_add);
SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);
FieldVector<Fraction> v_add_i = v1.add(vt2);
Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};
assertEquals("compare vect" ,v_add_i.getData(),result_add_i);
SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);
Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};
assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);
FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);
Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};
assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);
FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);
Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};
assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);
FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);
Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};
assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);
FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);
Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};
assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);
FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);
Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};
assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);
Fraction dot =  v1.dotProduct(v2);
assertEquals("compare val ",new Fraction(32), dot);
Fraction dot_2 =  v1.dotProduct(v2_t);
assertEquals("compare val ",new Fraction(32), dot_2);
FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);
assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));
FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);
assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));
}
public void testMisc() { 
SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);
String out1 = v1.toString();
assertTrue("some output ",  out1.length()!=0);
v1.checkVectorDimensions(2); 
fail("IllegalArgumentException expected");
} catch (IllegalArgumentException ex) {
} catch (Exception e) {
fail("wrong exception caught");
}     
}
public void testPredicates() {
SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });
v.setEntry(0, field.getZero());
assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));
assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));
}
protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {
if (m.length != n.length) {
fail("vectors have different lengths");
}
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);
}
}
protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {
if (m.length != n.length) {
fail("vectors have different lengths");
}
for (int i = 0; i < m.length; i++) {
assertEquals(msg + " " +  i + " elements differ", m[i].doubleValue(),n[i].doubleValue(), tolerance);
}
}
}for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
double[] coefficients = new double[getOriginalNumDecisionVariables()];
Integer basicRow =
getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
Set<Integer> basicRows = new HashSet<Integer>();
for (int i = 0; i < coefficients.length; i++) {
basicRow = getBasicRow(getNumObjectiveFunctions() + i);
if (basicRows.contains(basicRow)) {
coefficients[i] = 0;
} else {
basicRows.add(basicRow);
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {
double ratio = rhs / tableau.getEntry(i, col);private final Collection<LinearConstraint> constraints;
this.constraints            = constraints;
List<LinearConstraint> constraints = getNormalizedConstraints();
public List<LinearConstraint> getNormalizedConstraints() {copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
matrix[zIndex][width - 1] =
maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
if (!restrictToNonNegative) {
matrix[zIndex][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(objectiveCoefficients);
int slackVar = 0;
int artificialVar = 0;
for (int i = 0; i < constraints.size(); i++) {
LinearConstraint constraint = constraints.get(i);
int row = getNumObjectiveFunctions() + i;
copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
if (!restrictToNonNegative) {
matrix[row][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(constraint.getCoefficients());
matrix[row][width - 1] = constraint.getValue();
if (constraint.getRelationship() == Relationship.LEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack
} else if (constraint.getRelationship() == Relationship.GEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess
if ((constraint.getRelationship() == Relationship.EQ) ||
(constraint.getRelationship() == Relationship.GEQ)) {
matrix[0][getArtificialVariableOffset() + artificialVar] = 1; 
matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; 
return matrix;{ "minimal step size ({0}) reached, integration needs {1}",
"pas minimal ({0}) atteint, l''int\u00e9gration n\u00e9cessite {1}" },
"minimal step size ({0}) reached, integration needs {1}",AnovaStats(int dfbg, int dfwg, double F) {public final double[] smooth(final double[] xval, final double[] yval)
checkAllFiniteReal(xval, true);
checkAllFiniteReal(yval, false);
final double w    = tricube(dist * denom) * robustnessWeights[k];
if (meanXSquared == meanX * meanX) {
if (medianResidual == 0) {
robustnessWeights[i] = (arg >= 1) ? 0 : Math.pow(1 - arg * arg, 2);
private static void checkAllFiniteReal(final double[] values, final boolean isAbscissae)
final String pattern = isAbscissae ?
"all abscissae must be finite real numbers, but {0}-th is {1}" :
"all ordinatae must be finite real numbers, but {0}-th is {1}";MathRuntimeException.createIllegalArgumentException("no data");
MathRuntimeException.createIllegalArgumentException(
MathRuntimeException.createIllegalArgumentException(public double value(double[] point)
throws FunctionEvaluationException {
public void setMicropshereElements(final int microsphereElements) {
this.microsphereElements = microsphereElements;
public MultivariateRealFunction interpolate(double[][] xval,
double[] yval)public AnovaStats(int dfbg, int dfwg, double F) {public void testNextPoissionConistency() throws Exception {double p2 = SaddlePointExpansion.logBinomialProbability(sampleSize
- x, f, p, q);
double p3 = SaddlePointExpansion.logBinomialProbability(sampleSize,
m, p, q);
return Math.exp(MathUtils.binomialCoefficientLog(m, x)
+ MathUtils.binomialCoefficientLog(n - m, k - x)
- MathUtils.binomialCoefficientLog(n, k));
ret = Math.exp(-SaddlePointExpansion.getStirlingError(x)
- SaddlePointExpansion.getDeviancePart(x, mean))
/ Math.sqrt(2.0 * Math.PI * x); // TODO make MathUtils.PI
private static double PI_2 = 2.0 * Math.PI;
private static double HALF_LOG_2_PI = 0.5 * Math.log(PI_2);
ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) + z
- HALF_LOG_2_PI;
ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2)
/ z2)
/ z2)
/ z2)
/ z;
double d = (x - mu);
ret = getStirlingError(n) - getStirlingError(x)
- getStirlingError(n - x) - getDeviancePart(x, n * p)
- getDeviancePart(n - x, n * q);
double f = (PI_2 * x * (n - x)) / n;work[lowerStart + m - 1] = dCurrent - eCurrent;
work[upperStart + m - 1] = dCurrent + eCurrent;
for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
if (end - start > 2) {flipIfWarranted(n, 2);
if (flipIfWarranted(deflatedEnd, 1)) {
private boolean flipIfWarranted(final int n, final int step) {
if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
int j = 4 * (n - 1);
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];
work[i + k] = work[j - k];
work[j - k] = tmp;
j -= 4;
return true;
return false;final double liP1 = li * di / diP1;next = new EntryImpl();
next.setIndex(current.getIndex());
advance(next);return new BigReal(d.divide(a.d));data = new double[v1.data.length + v2.length];
System.arraycopy(v1.data, 0, data, 0, v1.data.length);
System.arraycopy(v2, 0, data, v1.data.length, v2.length);
data = new double[v1.length + v2.data.length];
System.arraycopy(v1, 0, data, 0, v1.length);
System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);
data = new double[v1.length + v2.length];
System.arraycopy(v1, 0, data, 0, v1.length);
System.arraycopy(v2, 0, data, v1.length, v2.length);
throws IllegalArgumentException {
if(v instanceof ArrayRealVector) {
while(it.hasNext() && (e = it.next()) != null) {
return new ArrayRealVector(out);
throws IllegalArgumentException {
return new ArrayRealVector(out);
throws IllegalArgumentException {
if(v instanceof ArrayRealVector) {
return new ArrayRealVector(out);
throws IllegalArgumentException {
return new ArrayRealVector(out);
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
if(v instanceof ArrayRealVector) {
return append((ArrayRealVector) v);
return new ArrayRealVector(this,new ArrayRealVector(v));
return new ArrayRealVector(out);max += Math.max(max, Math.abs(a));
public double getL1Norm() {
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res += Math.abs(iter.value());
return res;
public double getLInfNorm() {
double max = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
max += iter.value();
return max;
public double getNorm() {
double res = 0;
Iterator iter = entries.iterator();
while (iter.hasNext()) {
iter.advance();
res += iter.value() * iter.value();
return Math.sqrt(res);
double d_getNorm = v1.getNorm();
assertEquals("compare values  ", 3.7416573867739413,d_getNorm);
double d_getL1Norm = v1.getL1Norm();
assertEquals("compare values  ",6.0, d_getL1Norm);
double d_getLInfNorm = v1.getLInfNorm();
assertEquals("compare values  ",6.0, d_getLInfNorm);
double d_getNorm = v1.getNorm();
assertEquals("compare values  ", 3.7416573867739413,d_getNorm);
double d_getL1Norm = v1.getL1Norm();
assertEquals("compare values  ",6.0, d_getL1Norm);
double d_getLInfNorm = v1.getLInfNorm();
assertEquals("compare values  ",6.0, d_getLInfNorm);public SingularValueDecompositionImpl(RealMatrix matrix)
singularValues = eigenDecomposition.getRealEigenvalues();
for (int i = 0; i < singularValues.length; ++i) {
final double si = singularValues[i];
singularValues[i] = (si < 0) ? 0.0 : Math.sqrt(si);
final double[][] eData = eigenDecomposition.getV().getData();
final double[][] iData = new double[m][];
iData[0] = ei1;
for (int i = 0; i < n - 1; ++i) {
iData[i + 1] = ei1;
for (int j = 0; j < n; ++j) {
ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
final double lastMain = mainBidiagonal[n - 1];
for (int j = 0; j < n; ++j) {
ei1[j] *= lastMain / singularValues[j];
for (int i = n; i < m; ++i) {
iData[i] = new double[n];
transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));
cachedU = transformer.getU().multiply(eigenDecomposition.getV());
cachedV = transformer.getV().multiply(eigenDecomposition.getV());
final double[][] eData = eigenDecomposition.getV().getData();
final double[][] iData = new double[n][];
iData[0] = ei1;
for (int i = 0; i < m - 1; ++i) {
iData[i + 1] = ei1;
for (int j = 0; j < m; ++j) {
ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
final double lastMain = mainBidiagonal[m - 1];
for (int j = 0; j < m; ++j) {
ei1[j] *= lastMain / singularValues[j];
for (int i = m; i < n; ++i) {
iData[i] = new double[m];
transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));
while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {
final double[][] data = new double[dimension][n];
}, 0, dimension - 1, 0, n - 1);
getRank() == singularValues.length);
private final double[] singularValues;
private final RealMatrix uT;
private final RealMatrix v;
this.singularValues = singularValues;
this.uT             = uT;
this.v              = v;
this.nonSingular    = nonSingular;
throws IllegalArgumentException, InvalidMatrixException {
if (b.length != uT.getColumnDimension()) {
throw MathRuntimeException.createIllegalArgumentException(
"vector length mismatch: got {0} but expected {1}",
b.length, uT.getColumnDimension());
final double[] w = uT.operate(b);
for (int i = 0; i < singularValues.length; ++i) {
final double si = singularValues[i];
if (si == 0) {
throw new SingularMatrixException();
w[i] /= si;
return v.operate(w);
throws IllegalArgumentException, InvalidMatrixException {
if (b.getDimension() != uT.getColumnDimension()) {
throw MathRuntimeException.createIllegalArgumentException(
"vector length mismatch: got {0} but expected {1}",
b.getDimension(), uT.getColumnDimension());
final RealVector w = uT.operate(b);
for (int i = 0; i < singularValues.length; ++i) {
final double si = singularValues[i];
if (si == 0) {
throw new SingularMatrixException();
w.setEntry(i, w.getEntry(i) / si);
return v.operate(w);
throws IllegalArgumentException, InvalidMatrixException {
if (b.getRowDimension() != singularValues.length) {
throw MathRuntimeException.createIllegalArgumentException(
"dimensions mismatch: got {0}x{1} but expected {2}x{3}",
b.getRowDimension(), b.getColumnDimension(),
singularValues.length, "n");
final RealMatrix w = uT.multiply(b);
for (int i = 0; i < singularValues.length; ++i) {
final double si  = singularValues[i];
if (si == 0) {
throw new SingularMatrixException();
final double inv = 1.0 / si;
for (int j = 0; j < b.getColumnDimension(); ++j) {
w.multiplyEntry(i, j, inv);
return v.multiply(w);
public RealMatrix getInverse()
throws InvalidMatrixException {
if (!isNonSingular()) {
throw new SingularMatrixException();
return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));
public class SingularValueSolverTest extends TestCase {
public SingularValueSolverTest(String name) {
super(name);
public static Test suite() {
TestSuite suite = new TestSuite(SingularValueSolverTest.class);
suite.setName("SingularValueSolver Tests");
return suite;
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
fail("an exception should have been thrown");
fail("wrong exception caught");
public void testSolveSingularityErrors() {
RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);
solver.solve(b);
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
solver.solve(b.getColumn(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
solver.solve(b.getColumnVector(0));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));
fail("an exception should have been thrown");
} catch (InvalidMatrixException ime) {
} catch (Exception e) {
fail("wrong exception caught");
assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);
assertEquals(0,
assertEquals(0,
assertEquals(0,
assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);if (delta >= 0) {
final double sqrtMq = Math.sqrt(-q);
final double theta  = Math.acos(r / (-q * sqrtMq));
final double alpha  = 2 * sqrtMq;
final double beta   = b / 3;
double z0 = alpha * Math.cos(theta / 3) - beta;
double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;
double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;private static final double TOLERANCE = 100 * MathUtils.EPSILON;
private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE;
private double splitTolerance;
private double[] squaredSecondary;
private double lowerSpectra;
private double upperSpectra;
private double minPivot;
private double sigma;
private double sigmaLow;
private double tau;
private double[] work;
private int pingPong;
private double qMax;
private double eMin;
private int    tType;
private double dMin;
private double dMin1;
private double dMin2;
private double dN;
private double dN1;
private double dN2;
private double g;
public EigenDecompositionImpl(final RealMatrix matrix,
final double splitTolerance)
throws InvalidMatrixException {
this.splitTolerance = splitTolerance;
decompose();
throw new InvalidMatrixException("eigen decomposition of assymetric matrices not supported yet");
public EigenDecompositionImpl(final double[] main, double[] secondary,
throws InvalidMatrixException {
squaredSecondary = new double[secondary.length];
for (int i = 0; i < squaredSecondary.length; ++i) {
final double s = secondary[i];
squaredSecondary[i] = s * s;
this.splitTolerance = splitTolerance;
decompose();
final int rows    = matrix.getRowDimension();
final double eps  = 10 * rows * columns * MathUtils.EPSILON;
if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {
private void decompose() {
cachedV  = null;
cachedD  = null;
cachedVt = null;
work     = new double[6 * main.length];
computeGershgorinCircles();
findEigenvalues();
eigenvectors = null;
public RealMatrix getV()
throws InvalidMatrixException {
if (eigenvectors == null) {
findEigenVectors();
public RealMatrix getD()
throws InvalidMatrixException {
public RealMatrix getVT()
throws InvalidMatrixException {
if (eigenvectors == null) {
findEigenVectors();
public double[] getRealEigenvalues()
throws InvalidMatrixException {
public double getRealEigenvalue(final int i)
throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
public double[] getImagEigenvalues()
throws InvalidMatrixException {
public double getImagEigenvalue(final int i)
throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
throws InvalidMatrixException, ArrayIndexOutOfBoundsException {
if (eigenvectors == null) {
findEigenVectors();
if (eigenvectors == null) {
findEigenVectors();
private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,
final ArrayRealVector[] eigenvectors) {
this.eigenvectors    = eigenvectors;
throws IllegalArgumentException, InvalidMatrixException {
throws IllegalArgumentException, InvalidMatrixException {
"vector length mismatch: got {0} but expected {1}",
b.getDimension(), m);
throws IllegalArgumentException, InvalidMatrixException {
throw MathRuntimeException.createIllegalArgumentException(
"dimensions mismatch: got {0}x{1} but expected {2}x{3}",
b.getRowDimension(), b.getColumnDimension(), m, "n");
public RealMatrix getInverse()
throws InvalidMatrixException {
main      = transformer.getMainDiagonalRef();
squaredSecondary = new double[secondary.length];
for (int i = 0; i < squaredSecondary.length; ++i) {
final double s = secondary[i];
squaredSecondary[i] = s * s;
private void computeGershgorinCircles() {
final int m     = main.length;
final int lowerStart = 4 * m;
final int upperStart = 5 * m;
lowerSpectra = Double.POSITIVE_INFINITY;
upperSpectra = Double.NEGATIVE_INFINITY;
double eMax = 0;
double eCurrent = 0;
for (int i = 0; i < m - 1; ++i) {
final double dCurrent = main[i];
final double ePrevious = eCurrent;
eCurrent = Math.abs(secondary[i]);
eMax = Math.max(eMax, eCurrent);
final double radius = ePrevious + eCurrent;
final double lower = dCurrent - radius;
work[lowerStart + i] = lower;
lowerSpectra = Math.min(lowerSpectra, lower);
final double upper = dCurrent + radius;
work[upperStart + i] = upper;
upperSpectra = Math.max(upperSpectra, upper);
final double dCurrent = main[m - 1];
final double lower = dCurrent - eCurrent;
work[lowerStart + m - 1] = lower;
lowerSpectra = Math.min(lowerSpectra, lower);
final double upper = dCurrent + eCurrent;
work[upperStart + m - 1] = upper;
upperSpectra = Math.max(upperSpectra, upper);
minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
private void findEigenvalues()
throws InvalidMatrixException {
List<Integer> splitIndices = computeSplits();
realEigenvalues = new double[main.length];
imagEigenvalues = new double[main.length];
int begin = 0;
for (final int end : splitIndices) {
final int n = end - begin;
switch (n) {
case 1:
process1RowBlock(begin);
break;
case 2:
process2RowsBlock(begin);
break;
case 3:
process3RowsBlock(begin);
break;
default:
final double[] range       = eigenvaluesRange(begin, n);
final double oneFourth     = 0.25 * (3 * range[0] + range[1]);
final int oneFourthCount   = countEigenValues(oneFourth, begin, n);
final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);
final int threeFourthCount = countEigenValues(threeFourth, begin, n);
final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);
final double lambda        = chooseLeft ? range[0] : range[1];
tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;
ldlTDecomposition(lambda, begin, n);
processGeneralBlock(n);
if (chooseLeft) {
for (int i = 0; i < n; ++i) {
realEigenvalues[begin + i] = lambda + work[4 * i];
} else {
for (int i = 0; i < n; ++i) {
realEigenvalues[begin + i] = lambda - work[4 * i];
begin = end;
Arrays.sort(realEigenvalues);
int j = realEigenvalues.length - 1;
for (int i = 0; i < j; ++i) {
final double tmp = realEigenvalues[i];
realEigenvalues[i] = realEigenvalues[j];
realEigenvalues[j] = tmp;
--j;
private List<Integer> computeSplits() {
final List<Integer> list = new ArrayList<Integer>();
double absDCurrent = Math.abs(main[0]);
for (int i = 0; i < secondary.length; ++i) {
final double absDPrevious = absDCurrent;
absDCurrent = Math.abs(main[i + 1]);
final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);
if (Math.abs(secondary[i]) <= max) {
list.add(i + 1);
secondary[i] = 0;
squaredSecondary[i] = 0;
list.add(secondary.length + 1);
return list;
private void process1RowBlock(final int index) {
realEigenvalues[index] = main[index];
private void process2RowsBlock(final int index)
throws InvalidMatrixException {
final double q0   = main[index];
final double q1   = main[index + 1];
final double e12  = squaredSecondary[index];
final double s     = q0 + q1;
final double p     = q0 * q1 - e12;
final double delta = s * s - 4 * p;
if (delta < 0) {
throw new InvalidMatrixException("cannot solve degree {0} equation", 2);
final double largestRoot = 0.5 * (s + Math.sqrt(delta));
realEigenvalues[index]     = largestRoot;
realEigenvalues[index + 1] = p / largestRoot;
private void process3RowsBlock(final int index)
throws InvalidMatrixException {
final double q0       = main[index];
final double q1       = main[index + 1];
final double q2       = main[index + 2];
final double e12      = squaredSecondary[index];
final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];
final double b        = -(q0 + q1 + q2);
final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;
final double d        = q2 * e12 - q0 * q1q2Me22;
final double b2       = b * b;
final double beta     = b / 3;
final double q        = (3 * c - b2) / 9;
final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;
final double delta    = q * q * q + r * r;
double z0;
double z1;
double z2;
if (delta > 0) {
throw new InvalidMatrixException("cannot solve degree {0} equation", 3);
} else if (delta < 0) {
final double sqrtMq = Math.sqrt(-q);
final double theta  = Math.acos(r / (-q * sqrtMq));
final double alpha  = 2 * sqrtMq;
z0 = alpha * Math.cos(theta / 3) - beta;
z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;
z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;
} else {
final double cbrtR = Math.cbrt(r);
z0 = 2 * cbrtR - beta;
z1 = -cbrtR - beta;
z2 = z1;
if (z0 < z1) {
final double t = z0;
z0 = z1;
z1 = t;
if (z1 < z2) {
final double t = z1;
z1 = z2;
z2 = t;
if (z0 < z1) {
final double t = z0;
z0 = z1;
z1 = t;
realEigenvalues[index]     = z0;
realEigenvalues[index + 1] = z1;
realEigenvalues[index + 2] = z2;
private void processGeneralBlock(final int n)
throws InvalidMatrixException {
double sumOffDiag = 0;
for (int i = 0; i < n - 1; ++i) {
final int fourI = 4 * i;
final double ei = work[fourI + 2];
sumOffDiag += ei;
if (sumOffDiag == 0) {
return;
flipEveryOtherIfWarranted(n);
initialSplits(n);
tType = 0;
dMin1 = 0;
dMin2 = 0;
dN    = 0;
dN1   = 0;
dN2   = 0;
tau   = 0;
int i0 = 0;
int n0 = n;
while (n0 > 0) {
sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];
sigmaLow = 0;
double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
double offDiagMax = 0;
double diagMax    = work[4 * n0 - 4];
double diagMin    = diagMax;
i0 = 0;
for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
if (work[i + 2] <= 0) {
i0 = 1 + i / 4;
break;
if (diagMin >= 4 * offDiagMax) {
diagMin    = Math.min(diagMin, work[i + 4]);
offDiagMax = Math.max(offDiagMax, work[i + 2]);
diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
offDiagMin = Math.min(offDiagMin, work[i + 2]);
work[4 * n0 - 2] = offDiagMin;
dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));
pingPong = 0;
int maxIter = 30 * (n0 - i0);
for (int k = 0; i0 < n0; ++k) {
if (k >= maxIter) {
throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
n0 = goodStep(i0, n0);
pingPong = 1 - pingPong;
if ((pingPong == 0) && (n0 - i0 > 3) &&
(work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&
(work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
int split  = i0 - 1;
diagMax    = work[4 * i0];
offDiagMin = work[4 * i0 + 2];
double previousEMin = work[4 * i0 + 3];
for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
(work[i + 2] <= TOLERANCE_2 * sigma)) {
work[i + 2]  = -sigma;
split        = i / 4;
diagMax      = 0;
offDiagMin   = work[i + 6];
previousEMin = work[i + 7];
} else {
diagMax      = Math.max(diagMax, work[i + 4]);
offDiagMin   = Math.min(offDiagMin, work[i + 2]);
previousEMin = Math.min(previousEMin, work[i + 3]);
work[4 * n0 - 2] = offDiagMin;
work[4 * n0 - 1] = previousEMin;
i0 = split + 1;
private void initialSplits(final int n) {
pingPong = 0;
for (int k = 0; k < 2; ++k) {
double d = work[4 * (n - 1) + pingPong];
for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {
if (work[i + 2] <= TOLERANCE_2 * d) {
work[i + 2] = -0.0;
d = work[i];
} else {
d *= work[i] / (d + work[i + 2]);
d = work[pingPong];
for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {
final int j = i - 2 * pingPong - 1;
work[j] = d + work[i];
if (work[i] <= TOLERANCE_2 * d) {
work[i]     = -0.0;
work[j]     = d;
work[j + 2] = 0.0;
d = work[i + 2];
} else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
(MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
final double tmp = work[i + 2] / work[j];
work[j + 2] = work[i] * tmp;
d *= tmp;
} else {
work[j + 2] = work[i + 2] * (work[i] / work[j]);
d *= work[i + 2] / work[j];
work[4 * n - 3 - pingPong] = d;
pingPong = 1 - pingPong;
private int goodStep(final int start, final int end) {
g = 0.0;
int deflatedEnd = end;
for (boolean deflating = true; deflating;) {
if (start >= deflatedEnd) {
return deflatedEnd;
final int k = 4 * deflatedEnd + pingPong - 1;
if ((start == deflatedEnd - 1) ||
((start != deflatedEnd - 2) &&
((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||
(work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {
work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];
deflatedEnd -= 1;
} else if ((start == deflatedEnd - 2) ||
(work[k - 9] <= TOLERANCE_2 * sigma) ||
(work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {
if (work[k - 3] > work[k - 7]) {
final double tmp = work[k - 3];
work[k - 3] = work[k - 7];
work[k - 7] = tmp;
if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
double s = work[k - 3] * (work[k - 5] / t);
if (s <= t) {
s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
t = work[k - 7] + (s + work[k - 5]);
work[k - 3] *= work[k - 7] / t;
work[k - 7]  = t;
work[4 * deflatedEnd - 8] = sigma + work[k - 7];
work[4 * deflatedEnd - 4] = sigma + work[k - 3];
deflatedEnd -= 2;
} else {
deflating = false;
final int l = 4 * deflatedEnd + pingPong - 1;
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipAllIfWarranted(deflatedEnd)) {
dMin2 = Math.min(dMin2, work[l - 1]);
work[l - 1] =
Math.min(work[l - 1],
Math.min(work[3 + pingPong], work[7 + pingPong]));
work[l - 2 * pingPong] =
Math.min(work[l - 2 * pingPong],
Math.min(work[6 + pingPong], work[6 + pingPong]));
qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
dMin  = -0.0;
if ((dMin < 0) ||
(MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],
Math.min(work[l - 9],
dMin2 + work[l - 2 * pingPong])))) {
computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);
for (boolean loop = true; loop;) {
dqds(start, deflatedEnd);
if ((dMin >= 0) && (dMin1 > 0)) {
updateSigma(tau);
return deflatedEnd;
} else if ((dMin < 0.0) &&
(dMin1 > 0.0) &&
(work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&
(Math.abs(dN) < TOLERANCE * sigma)) {
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;
updateSigma(tau);
return deflatedEnd;
} else if (dMin < 0.0) {
if (tType < -22) {
tau = 0.0;
} else if (dMin1 > 0.0) {
tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
tType -= 11;
} else {
tau *= 0.25;
tType -= 12;
} else if (Double.isNaN(dMin)) {
tau = 0.0;
} else {
loop = false;
dqd(start, deflatedEnd);
return deflatedEnd;
private boolean flipAllIfWarranted(final int n) {
if (1.5 * work[pingPong] >= work[4 * (n - 1) + pingPong]) {
return false;
int j = 4 * (n - 1);
for (int i = 0; i < j; i += 4) {
final double tmp1 = work[i];
work[i] = work[j];
work[j] = tmp1;
final double tmp2 = work[i+1];
work[i+1] = work[j+1];
work[j+1] = tmp2;
final double tmp3 = work[i+2];
work[i+2] = work[j-2];
work[j-2] = tmp3;
final double tmp4 = work[i+3];
work[i+3] = work[j-1];
work[j-1] = tmp4;
j -= 4;
return true;
private boolean flipEveryOtherIfWarranted(final int n) {
if (1.5 * work[pingPong] >= work[4 * (n - 1) + pingPong]) {
return false;
int j = 4 * (n - 1);
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += 2) {
final double tmp = work[i + k];
work[i + k] = work[j - k];
work[j - k] = tmp;
j -= 4;
return true;
private double[] eigenvaluesRange(final int index, final int n) {
final int lowerStart = 4 * main.length;
final int upperStart = 5 * main.length;
double lower = Double.POSITIVE_INFINITY;
double upper = Double.NEGATIVE_INFINITY;
for (int i = 0; i < n; ++i) {
lower = Math.min(lower, work[lowerStart + index +i]);
upper = Math.max(upper, work[upperStart + index +i]);
final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));
final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);
final double absoluteTolerance = 4 * minPivot;
final int maxIter =
2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));
final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);
double left  = lower - margin;
double right = upper + margin;
for (int i = 0; i < maxIter; ++i) {
final double range = right - left;
if ((range < absoluteTolerance) ||
(range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {
break;
final double middle = 0.5 * (left + right);
if (countEigenValues(middle, index, n) >= 1) {
right = middle;
} else {
left = middle;
lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));
left  = lower - margin;
right = upper + margin;
for (int i = 0; i < maxIter; ++i) {
final double range = right - left;
if ((range < absoluteTolerance) ||
(range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {
break;
final double middle = 0.5 * (left + right);
if (countEigenValues(middle, index, n) >= n) {
right = middle;
} else {
left = middle;
upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));
return new double[] { lower, upper };
private int countEigenValues(final double t, final int index, final int n) {
double ratio = main[index] - t;
int count = (ratio > 0) ? 0 : 1;
for (int i = 1; i < n; ++i) {
ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;
if (ratio <= 0) {
++count;
return count;
private void ldlTDecomposition(final double lambda, final int index, final int n) {
double di = main[index] - lambda;
work[0] = Math.abs(di);
for (int i = 1; i < n; ++i) {
final int    fourI = 4 * i;
final double eiM1  = secondary[index + i - 1];
final double ratio = eiM1 / di;
work[fourI - 2] = ratio * ratio * Math.abs(di);
di = (main[index + i] - lambda) - eiM1 * ratio;
work[fourI] = Math.abs(di);
private void dqds(final int start, final int end) {
eMin = work[4 * start + pingPong + 4];
double d = work[4 * start + pingPong] - tau;
dMin = d;
dMin1 = -work[4 * start + pingPong];
if (pingPong == 0) {
for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
work[j4 - 2] = d + work[j4 - 1];
final double tmp = work[j4 + 1] / work[j4 - 2];
d = d * tmp - tau;
dMin = Math.min(dMin, d);
work[j4] = work[j4 - 1] * tmp;
eMin = Math.min(work[j4], eMin);
} else {
for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
work[j4 - 3] = d + work[j4];
final double tmp = work[j4 + 2] / work[j4 - 3];
d = d * tmp - tau;
dMin = Math.min(dMin, d);
work[j4 - 1] = work[j4] * tmp;
eMin = Math.min(work[j4 - 1], eMin);
dN2 = d;
dMin2 = dMin;
int j4 = 4 * (end - 2) - pingPong - 1;
int j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN2 + work[j4p2];
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;
dMin = Math.min(dMin, dN1);
dMin1 = dMin;
j4 = j4 + 4;
j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN1 + work[j4p2];
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;
dMin = Math.min(dMin, dN);
work[j4 + 2] = dN;
work[4 * end - pingPong - 1] = eMin;
private void dqd(final int start, final int end) {
eMin = work[4 * start + pingPong + 4];
double d = work[4 * start + pingPong];
dMin = d;
if (pingPong == 0) {
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
work[j4 - 2] = d + work[j4 - 1];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
d = work[j4 + 1];
dMin = d;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
final double tmp = work[j4 + 1] / work[j4 - 2];
work[j4] = work[j4 - 1] * tmp;
d *= tmp;
} else {
work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
d *= work[j4 + 1] / work[j4 - 2];
dMin = Math.min(dMin, d);
eMin = Math.min(eMin, work[j4]);
} else {
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
work[j4 - 3] = d + work[j4];
if (work[j4 - 3] == 0.0) {
work[j4 - 1] = 0.0;
d = work[j4 + 2];
dMin = d;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
(MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
final double tmp = work[j4 + 2] / work[j4 - 3];
work[j4 - 1] = work[j4] * tmp;
d *= tmp;
} else {
work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
d *= work[j4 + 2] / work[j4 - 3];
dMin = Math.min(dMin, d);
eMin = Math.min(eMin, work[j4 - 1]);
dN2   = d;
dMin2 = dMin;
int j4 = 4 * (end - 2) - pingPong - 1;
int j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN2 + work[j4p2];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
dN1  = work[j4p2 + 2];
dMin = dN1;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
final double tmp = work[j4p2 + 2] / work[j4 - 2];
work[j4] = work[j4p2] * tmp;
dN1 = dN2 * tmp;
} else {
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
dMin = Math.min(dMin, dN1);
dMin1 = dMin;
j4 = j4 + 4;
j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN1 + work[j4p2];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
dN   = work[j4p2 + 2];
dMin = dN;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
final double tmp = work[j4p2 + 2] / work[j4 - 2];
work[j4] = work[j4p2] * tmp;
dN = dN1 * tmp;
} else {
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
dMin = Math.min(dMin, dN);
work[j4 + 2] = dN;
work[4 * end - pingPong - 1] = eMin;
private void computeShiftIncrement(final int start, final int end, final int deflated) {
final double cnst1 = 0.563;
final double cnst2 = 1.010;
final double cnst3 = 1.05;
if (dMin <= 0.0) {
tau = -dMin;
tType = -1;
return;
int nn = 4 * end + pingPong - 1;
switch (deflated) {
case 0 : // no realEigenvalues deflated.
if (dMin == dN || dMin == dN1) {
double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
double a2 = work[nn - 7] + work[nn - 5];
if (dMin == dN && dMin1 == dN1) {
final double gap2 = dMin2 - a2 - dMin2 * 0.25;
final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
if (gap1 > 0.0 && gap1 > b1) {
tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
tType = -2;
} else {
double s = 0.0;
if (dN > b1) {
s = dN - b1;
if (a2 > (b1 + b2)) {
s = Math.min(s, a2 - (b1 + b2));
tau   = Math.max(s, 0.333 * dMin);
tType = -3;
} else {
tType = -4;
double s = 0.25 * dMin;
double gam;
int np;
if (dMin == dN) {
gam = dN;
a2 = 0.0;
if (work[nn - 5]  >  work[nn - 7]) {
return;
b2 = work[nn - 5] / work[nn - 7];
np = nn - 9;
} else {
np = nn - 2 * pingPong;
b2 = work[np - 2];
gam = dN1;
if (work[np - 4]  >  work[np - 2]) {
return;
a2 = work[np - 4] / work[np - 2];
if (work[nn - 9]  >  work[nn - 11]) {
return;
b2 = work[nn - 9] / work[nn - 11];
np = nn - 13;
a2 = a2 + b2;
for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
if(b2 == 0.0) {
b1 = b2;
if (work[i4]  >  work[i4 - 2]) {
return;
b2 = b2 * (work[i4] / work[i4 - 2]);
a2 = a2 + b2;
if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
break;
a2 = cnst3 * a2;
if (a2 < cnst1) {
s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
tau = s;
} else if (dMin == dN2) {
tType = -5;
double s = 0.25 * dMin;
final int np = nn - 2 * pingPong;
double b1 = work[np - 2];
double b2 = work[np - 6];
final double gam = dN2;
if (work[np - 8] > b2 || work[np - 4] > b1) {
return;
double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
if (end - start > 3) {
b2 = work[nn - 13] / work[nn - 15];
a2 = a2 + b2;
for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
if (b2 == 0.0) {
break;
b1 = b2;
if (work[i4]  >  work[i4 - 2]) {
return;
b2 = b2 * (work[i4] / work[i4 - 2]);
a2 = a2 + b2;
if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
break;
a2 = cnst3 * a2;
if (a2 < cnst1) {
tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
} else {
tau = s;
} else {
if (tType == -6) {
g += 0.333 * (1 - g);
} else if (tType == -18) {
g = 0.25 * 0.333;
} else {
g = 0.25;
tau   = g * dMin;
tType = -6;
break;
case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
if (dMin1 == dN1 && dMin2 == dN2) {
tType = -7;
double s = 0.333 * dMin1;
if (work[nn - 5] > work[nn - 7]) {
return;
double b1 = work[nn - 5] / work[nn - 7];
double b2 = b1;
if (b2 != 0.0) {
for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
final double oldB1 = b1;
if (work[i4] > work[i4 - 2]) {
return;
b1 = b1 * (work[i4] / work[i4 - 2]);
b2 = b2 + b1;
if (100 * Math.max(b1, oldB1) < b2) {
break;
b2 = Math.sqrt(cnst3 * b2);
final double a2 = dMin1 / (1 + b2 * b2);
final double gap2 = 0.5 * dMin2 - a2;
if (gap2 > 0.0 && gap2 > b2 * a2) {
tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
} else {
tau = Math.max(s, a2 * (1 - cnst2 * b2));
tType = -8;
} else {
tau = 0.25 * dMin1;
if (dMin1 == dN1) {
tau = 0.5 * dMin1;
tType = -9;
break;
case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.
if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
tType = -10;
final double s = 0.333 * dMin2;
if (work[nn - 5] > work[nn - 7]) {
return;
double b1 = work[nn - 5] / work[nn - 7];
double b2 = b1;
if (b2 != 0.0){
for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
if (work[i4] > work[i4 - 2]) {
return;
b1 *= work[i4] / work[i4 - 2];
b2 += b1;
if (100 * b1 < b2) {
break;
b2 = Math.sqrt(cnst3 * b2);
final double a2 = dMin2 / (1 + b2 * b2);
final double gap2 = work[nn - 7] + work[nn - 9] -
Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
if (gap2 > 0.0 && gap2 > b2 * a2) {
tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
} else {
tau = Math.max(s, a2 * (1 - cnst2 * b2));
} else {
tau   = 0.25 * dMin2;
tType = -11;
break;
default : // case 12, more than two realEigenvalues deflated. no information.
tau   = 0.0;
tType = -12;
private void updateSigma(final double shift) {
if (shift < sigma) {
sigmaLow += shift;
final double t = sigma + sigmaLow;
sigmaLow -= t - sigma;
sigma = t;
} else {
final double t = sigma + shift;
sigmaLow += sigma - (t - shift);
sigma = t;
private void findEigenVectors() {
final int m = main.length;
eigenvectors = new ArrayRealVector[m];
final double[] d = new double[m];
final double[] l = new double[m - 1];
final double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;
double di = main[0]+mu;
d[0] = di;
for (int i = 1; i < m; ++i) {
final double eiM1  = secondary[i - 1];
final double ratio = eiM1 / di;
di       = main[i] - eiM1 * ratio + mu;
l[i - 1] = ratio;
d[i]     = di;
for (int i = 0; i < m; ++i) {
eigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);
private ArrayRealVector findEigenvector(final double eigenvalue,
final double[] d, final double[] l) {
final int m = main.length;
stationaryQuotientDifferenceWithShift(d, l, eigenvalue);
progressiveQuotientDifferenceWithShift(d, l, eigenvalue);
int r = m - 1;
double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);
int sixI = 0;
for (int i = 0; i < m - 1; ++i) {
final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);
if (absG < minG) {
r = i;
minG = absG;
sixI += 6;
double[] eigenvector = new double[m];
double n2 = 1;
eigenvector[r] = 1;
double z = 1;
for (int i = r - 1; i >= 0; --i) {
z *= -work[6 * i + 2];
eigenvector[i] = z;
n2 += z * z;
z = 1;
for (int i = r + 1; i < m; ++i) {
z *= -work[6 * i - 1];
eigenvector[i] = z;
n2 += z * z;
final double inv = 1.0 / Math.sqrt(n2);
for (int i = 0; i < m; ++i) {
eigenvector[i] *= inv;
return (transformer == null) ?
new ArrayRealVector(eigenvector, false) :
new ArrayRealVector(transformer.getQ().operate(eigenvector), false);
private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,
final double lambda) {
final int nM1 = d.length - 1;
double si = -lambda;
int sixI = 0;
for (int i = 0; i < nM1; ++i) {
final double di   = d[i];
final double li   = l[i];
final double ldi  = li * di;
final double diP1 = di + si;
final double liP1 = ldi / diP1;
work[sixI]        = si;
work[sixI + 1]    = diP1;
work[sixI + 2]    = liP1;
si = li * liP1 * si - lambda;
sixI += 6;
if (Double.isNaN(si)) {
si = -lambda;
sixI = 0;
for (int i = 0; i < nM1; ++i) {
final double di   = d[i];
final double li   = l[i];
final double ldi  = li * di;
double diP1 = di + si;
if (Math.abs(diP1) < minPivot) {
diP1 = -minPivot;
final double liP1 = ldi / diP1;
work[sixI]        = si;
work[sixI + 1]    = diP1;
work[sixI + 2]    = liP1;
si = li * ((liP1 == 0) ? li * di : liP1 * si) - lambda;
sixI += 6;
work[6 * nM1 + 1] = d[nM1] + si;
work[6 * nM1]     = si;
private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,
final double lambda) {
final int nM1 = d.length - 1;
double pi = d[nM1] - lambda;
int sixI = 6 * (nM1 - 1);
for (int i = nM1 - 1; i >= 0; --i) {
final double di   = d[i];
final double li   = l[i];
final double diP1 = di * li * li + pi;
final double t    = di / diP1;
work[sixI +  9]   = pi;
work[sixI + 10]   = diP1;
work[sixI +  5]   = li * t;
pi = pi * t - lambda;
sixI -= 6;
if (Double.isNaN(pi)) {
pi = d[nM1] - lambda;
sixI = 6 * (nM1 - 1);
for (int i = nM1 - 1; i >= 0; --i) {
final double di   = d[i];
final double li   = l[i];
double diP1 = di * li * li + pi;
if (Math.abs(diP1) < minPivot) {
diP1 = -minPivot;
final double t    = di / diP1;
work[sixI +  9]   = pi;
work[sixI + 10]   = diP1;
work[sixI +  5]   = li * t;
pi = ((t == 0) ? di : pi * t) - lambda;
sixI -= 6;
work[3] = pi;
work[4] = pi;
public class SingularValueDecompositionImpl implements SingularValueDecomposition {
private BiDiagonalTransformer transformer;
private double[] mainBidiagonal;
private double[] secondaryBidiagonal;
private double[] mainTridiagonal;
private double[] secondaryTridiagonal;
throws InvalidMatrixException {
this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)
throws InvalidMatrixException {
cachedU  = null;
cachedS  = null;
cachedV  = null;
transformer         = new BiDiagonalTransformer(matrix);
mainBidiagonal      = transformer.getMainDiagonalRef();
secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
mainTridiagonal      = new double[mainBidiagonal.length];
secondaryTridiagonal = new double[mainBidiagonal.length - 1];
double a = mainBidiagonal[0];
mainTridiagonal[0] = a * a;
for (int i = 1; i < mainBidiagonal.length; ++i) {
final double b  = secondaryBidiagonal[i - 1];
secondaryTridiagonal[i - 1] = a * b;
a = mainBidiagonal[i];
mainTridiagonal[i] = a * a + b * b;
eigenDecomposition =
new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,
MathUtils.SAFE_MIN);
final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
int p = Math.min(max, eigenValues.length);
while ((p > 0) && (eigenValues[p - 1] <= 0)) {
--p;
singularValues = new double[p];
for (int i = 0; i < p; ++i) {
singularValues[i] = Math.sqrt(eigenValues[i]);
public RealMatrix getU()
throws InvalidMatrixException {
if (cachedU == null) {
final int p = singularValues.length;
if (m >= n) {
final RealMatrix e =
eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
final double[][] eData = e.getData();
final double[][] wData = new double[m][p];
double[] ei1 = eData[0];
for (int i = 0; i < p; ++i) {
final double mi = mainBidiagonal[i];
final double[] ei0 = ei1;
final double[] wi  = wData[i];
if (i < n - 1) {
ei1 = eData[i + 1];
final double si = secondaryBidiagonal[i];
for (int j = 0; j < p; ++j) {
wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
} else {
for (int j = 0; j < p; ++j) {
wi[j] = mi * ei0[j] / singularValues[j];
for (int i = p; i < m; ++i) {
wData[i] = new double[p];
cachedU =
transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
} else {
final RealMatrix e =
eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
cachedU = transformer.getU().multiply(e);
public RealMatrix getUT()
throws InvalidMatrixException {
public RealMatrix getS()
throws InvalidMatrixException {
public double[] getSingularValues()
throws InvalidMatrixException {
public RealMatrix getV()
throws InvalidMatrixException {
if (cachedV == null) {
final int p = singularValues.length;
if (m >= n) {
final RealMatrix e =
eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
cachedV = transformer.getV().multiply(e);
} else {
final RealMatrix e =
eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
final double[][] eData = e.getData();
final double[][] wData = new double[n][p];
double[] ei1 = eData[0];
for (int i = 0; i < p; ++i) {
final double mi = mainBidiagonal[i];
final double[] ei0 = ei1;
final double[] wi  = wData[i];
if (i < m - 1) {
ei1 = eData[i + 1];
final double si = secondaryBidiagonal[i];
for (int j = 0; j < p; ++j) {
wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
} else {
for (int j = 0; j < p; ++j) {
wi[j] = mi * ei0[j] / singularValues[j];
for (int i = p; i < n; ++i) {
wData[i] = new double[p];
cachedV =
transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
public RealMatrix getVT()
throws InvalidMatrixException {
"cutoff singular value is {0}, should be at most {1}",
minSingularValue, singularValues[0]);
public void visit(final int row, final int column, final double value) {
public double getNorm()
throws InvalidMatrixException {
public double getConditionNumber()
throws InvalidMatrixException {
public int getRank()
throws IllegalStateException {
if (singularValues[i] > threshold) {
return i + 1;
return new Solver(singularValues, getUT(), getV(),
getRank() == Math.max(m, n));
private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,
final boolean nonSingular) {
double[][] suT      = uT.getData();
final double a      = 1.0 / singularValues[i];
pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));
public double[] solve(final double[] b)
throws IllegalArgumentException {
throws IllegalArgumentException {
throws IllegalArgumentException {
new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),
new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })
assertEquals(0, es.solve(b).subtract(xRef).getNorm(), 2.0e-12);
public void testMatricesValues2() {
assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);
Assert.assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);double maxAbsoluteValue=0.0;
for (int j = 0; j < n; j++) {
for (int j = 0; j < m; j++) {public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;
public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;return (Math.abs(u) + Math.abs(v));int zIndex = n + j;
zIndex += l;
zDot[n + i * n + j] = s;
int zIndex = n * (n + 1)+ j;
zDot[n * (n + 1) + i * k + j] = s;
return new StepInterpolatorWrapper(interpolator.copy(),
y.length, dydy0[0].length);
SummaryStatistics residuals0 = new SummaryStatistics();
SummaryStatistics residuals1 = new SummaryStatistics();
residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 600);
Assert.assertTrue(residuals0.getStandardDeviation() > 30);
Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 800);
Assert.assertTrue(residuals1.getStandardDeviation() > 50);
SummaryStatistics residuals0 = new SummaryStatistics();
SummaryStatistics residuals1 = new SummaryStatistics();
residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 0.02);
Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.03);
Assert.assertTrue(residuals0.getStandardDeviation() > 0.003);
Assert.assertTrue(residuals0.getStandardDeviation() < 0.004);
Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 0.04);
Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.05);
Assert.assertTrue(residuals1.getStandardDeviation() > 0.006);
Assert.assertTrue(residuals1.getStandardDeviation() < 0.007);
SummaryStatistics residuals0 = new SummaryStatistics();
SummaryStatistics residuals1 = new SummaryStatistics();
residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());
residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());
Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.006);
Assert.assertTrue(residuals0.getStandardDeviation() < 0.0009);
Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.006);
Assert.assertTrue(residuals1.getStandardDeviation() < 0.0012);
throws IntegratorException, DerivativeException {
new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);
SummaryStatistics residuals0 = new SummaryStatistics();
SummaryStatistics residuals1 = new SummaryStatistics();
residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());
residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());
Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.004);
Assert.assertTrue(residuals0.getStandardDeviation() < 0.001);
Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.005);
Assert.assertTrue(residuals1.getStandardDeviation() < 0.001);
return -1087.8787631970476 + (1050.4387741821572 + (-338.90621620263096 + 36.51793006801084 * b) * b) * b;
return 1499.0904666097015 + (-1434.9574631810726 + (459.71079478756945 - 49.29949940968588 * b) * b) * b;private double[] yDot;
y     = new double[n];
yDot  = new double[n];
dydy0 = new double[n][n];
dydp  = new double[n][k];
System.arraycopy(extendedDerivatives, start, dydy0[i], 0, n);
return dydy0;
final int k = dydp[0].length;
System.arraycopy(extendedDerivatives, start, dydp[i], 0, k);
return dydp;
System.arraycopy(y,    0, copied.y,    0, n);
System.arraycopy(yDot, 0, copied.yDot, 0, n);
for (int i = 0; i < n; ++i) {
System.arraycopy(dydy0[i], 0, copied.dydy0[i], 0, n);
for (int i = 0; i < n; ++i) {
System.arraycopy(dydp[i], 0, copied.dydp[i], 0, k);
final int n = y.length;
final int k = dydp[0].length;
out.writeInt(n);
out.writeInt(k);
for (int i = 0; i < n; ++i) {
out.writeDouble(y[i]);
for (int i = 0; i < n; ++i) {
out.writeDouble(yDot[i]);
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
out.writeDouble(dydy0[i][j]);
for (int i = 0; i < n; ++i) {
for (int j = 0; j < k; ++j) {
out.writeDouble(dydp[i][j]);
y = new double[n];
dydy0 = new double[n][n];
dydp = new double[n][k];
for (int i = 0; i < n; ++i) {
y[i] = in.readDouble();
for (int i = 0; i < n; ++i) {
yDot[i] = in.readDouble();
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
dydy0[i][j] = in.readDouble();
for (int i = 0; i < n; ++i) {
for (int j = 0; j < k; ++j) {
dydp[i][j] = in.readDouble();private final static double[][] aInv = {
throws MathException {
for (int i = 1, max = val.length; i < max; i++) {
final double[] row = aInv[i];
return a00 + a01 * y + a02 * y2 + a03 * y3
+ a10 * x + a11 * x * y + a12 * x * y2 + a13 * x * y3
+ a20 * x2 + a21 * x2 * y + a22 * x2 * y2 + a23 * x2 * y3
+ a30 * x3 + a31 * x3 * y + a32 * x3 * y2 + a33 * x3 * y3;
dZdXdY[i][j] =  (zY_2[nI][nJ] - zY_2[nI][pJ]
- zY_2[pI][nJ] + zY_2[pI][pJ])
/ ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ])) ;
for (int i = 1, max = val.length; i < max; i++) {int sampleSize = 1000;        // Number of deviates to generate
int minExpectedCount = 7;     // Minimum size of expected bin count
double alpha = 0.001;         // Probability of false failure"Taille de l'\u00e9chantillon doit \u00eatre positif" },
if (ak2 == 0) {return MathUtils.equals(stat.getResult(), this.getResult()) &&
MathUtils.equals(stat.getN(), this.getN());
return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&
MathUtils.equals(stat.getMax(),           getMax())           &&
MathUtils.equals(stat.getMean(),          getMean())          &&
MathUtils.equals(stat.getMin(),           getMin())           &&
MathUtils.equals(stat.getN(),             getN())             &&
MathUtils.equals(stat.getSum(),           getSum())           &&
MathUtils.equals(stat.getSumSq(),         getSumSq())         &&
MathUtils.equals(stat.getSumLog(),        getSumLog())        &&
return MathUtils.equals(stat.getMax(),      getMax())  &&
MathUtils.equals(stat.getMean(),     getMean()) &&
MathUtils.equals(stat.getMin(),      getMin())  &&
MathUtils.equals(stat.getN(),        getN())    &&
MathUtils.equals(stat.getSum(),      getSum())  &&
MathUtils.equals(stat.getVariance(), getVariance());
return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&
MathUtils.equals(stat.getMax(),           getMax())           &&
MathUtils.equals(stat.getMean(),          getMean())          &&
MathUtils.equals(stat.getMin(),           getMin())           &&
MathUtils.equals(stat.getN(),             getN())             &&
MathUtils.equals(stat.getSum(),           getSum())           &&
MathUtils.equals(stat.getSumsq(),         getSumsq())         &&
MathUtils.equals(stat.getVariance(),      getVariance());
return equals(x, y) || (Math.abs(y - x) <= eps);
return Math.abs(xInt - yInt) <= maxUlps;
assertTrue(MathUtils.equals(mean1, dstat.getMean()));
assertTrue(MathUtils.equals(mean2, dstat.getMean()));
assertTrue(MathUtils.equals(mean3, dstat.getMean()));
public void testEquals() {
assertTrue(MathUtils.equals(testArray[i], testArray[j]));
assertTrue(MathUtils.equals(testArray[j], testArray[i]));
assertTrue(!MathUtils.equals(testArray[i], testArray[j]));
assertTrue(!MathUtils.equals(testArray[j], testArray[i]));
assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1.0));
assertTrue(MathUtils.equals(153, 153, 1));
assertTrue(MathUtils.equals(153, 153.00000000000003, 1));
assertFalse(MathUtils.equals(153, 153.00000000000006, 1));
assertTrue(MathUtils.equals(153, 152.99999999999997, 1));
assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));
assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));
assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));
assertFalse(MathUtils.equals(-128, -128.00000000000006, 1));
assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1));
assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));RandomData randomData = new RandomDataImpl();
randomData.reSeed(1000);            // Reseed randomGenerator to get fixed sequencepublic double value(double x, double y)
public double value(double x, double y, double z)
private final double[][] a = new double[N][N];
BivariateRealFunction partialDerivativeX = null;
BivariateRealFunction partialDerivativeY = null;
BivariateRealFunction partialDerivativeXX = null;
BivariateRealFunction partialDerivativeYY = null;
BivariateRealFunction partialDerivativeXY = null;
public BicubicSplineFunction(double[] aV) {
a[i][j] = aV[i + N * j];
MathUtils.checkOrder(xval, 1, true);
MathUtils.checkOrder(yval, 1, true);
if (xLen == 0 || yLen == 0 || z.length == 0
|| f.length == 0 || f[0].length == 0) {
private static final short N2 = N * N;
a[i][j][k] = aV[i + N * j + N2 * k];
(boundIsAllowed ?
LocalizedFormats.NUMBER_TOO_LARGE :
LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED),
(boundIsAllowed ?
LocalizedFormats.NUMBER_TOO_SMALL :
LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED),
if(next.getValue() == 0){
advance(next);
int index = next.getIndex();
if(index < 0){
throw new NoSuchElementException();
current.setIndex(index);
advance(next);
return current;
protected int mainSetDimension;
this.point = (point == null ? null : point.clone());
this.point = (copyArray ?
(point == null ? null : point.clone()) :
point);
return (point == null ? null : point.clone());
this.point = (point == null ? null : point.clone());
this.value = (value == null ? null : value.clone());
this.point = (copyArray ?
(point == null ? null : point.clone()) :
point);
this.value = (copyArray ?
(value == null ? null : value.clone()) :
value);
return (point == null ? null : point.clone());
return (value == null ? null : value.clone());
if (startConfiguration == null
|| startConfiguration.length != startPoint.length) {
private int gradientEvaluations;
private MultivariateVectorialFunction gradient;
public void setQRRankingThreshold(final double qrRankingThreshold) {
this.qrRankingThreshold = qrRankingThreshold;
switch (goal) {
case MINIMIZE:
return (fVal < fX ? current : previous);
case MAXIMIZE:
return (fVal > fX ? current : previous);
} catch (Exception e) {
final boolean isMinim = (goal == GoalType.MINIMIZE);
double a, b;
if (p > q * (a - x)
&& p < q * (b - x)
&& Math.abs(p) < Math.abs(0.5 * q * r)) {
if (u - a < tol2
|| b - u < tol2) {
if (fu <= fw
|| w == x) {
} else if (fu <= fv
|| v == x
|| v == w) {
final boolean isEqual = (Math.abs(xInt - yInt) <= maxUlps);
final int index = i + N * j;throws DimensionMismatchException, IllegalArgumentException {
public void setConvergenceChecker(RealConvergenceChecker checker) {
this.checker = checker;
private GoalType goal;
private double min;
private double max;
private double startValue;
return goal;
return min;
return max;
return startValue;
public double optimize(UnivariateRealFunction function, GoalType goal,
this.min = min;
this.max = max;
this.startValue = startValue;
this.goal = goal;
this.function = function;
INCREASING,
DECREASING
if (index < 0
|| index >= totalSize) {
public int getCount(int ... c) {
if (index < 0
|| index >= size[i]) {if (e[i + 1] == 0.0 && i >= j)
matAAT[j][i]=matAAT[i][j];
double criterion = 0;
for (int i = 0; i < rows; ++i) {
final double residual = residuals[i];
criterion += residualsWeights[i] * residual * residual;
return Math.sqrt(criterion / rows);
chiSquare += residual * residual / residualsWeights[i];
assertEquals(0.002, errors[0], 0.001);
assertEquals(0.002, errors[1], 0.001);RealVector residuals = calculateResiduals();private Dfp snan;
snan = factory.newDfp((byte)1, Dfp.SNAN);
snan = null;return 17 + (sign << 8) + (nans << 16) + exp + mant.hashCode();public static double acos(final double a) {
return Math.acos(a);
public static double asin(final double a) {
return Math.asin(a);
if (x < 0) {
if (y == (long) y) {
return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
} else {
return Double.NaN;
if (y < 0 && y == (long)y)
if (x*x < 1.0) {
return Double.NEGATIVE_INFINITY;
double tmp1 = y * 1073741824.0;
final double ya = y + tmp1 - tmp1;
final double yb = y - ya;
tmp1 = lna * 1073741824.0;
final double tmp2 = lna + tmp1 - tmp1;
xa = a;
xb = b;
boolean recip = false;
if (recip) {
final double pi2a = 1.5707963267948966;
final double pi2b = 6.123233995736766E-17;
double za = pi2a - ya;
double zb = -(za - pi2a + ya);
temp = za - EIGHTHES[idx];
zb += -(temp - za + EIGHTHES[idx]);
za = temp;
zb += pi2b - yb;
ya = za;
yb = zb;
result = yb + ya;
resultb = -(result - yb - ya);
} else {
double za = EIGHTHES[idx] + ya;
double zb = -(za - EIGHTHES[idx] - ya);
temp = za + yb;
zb += -(temp - za - yb);
za = temp;
result = za + zb;
resultb = -(result - za - zb);
final double za = pia - result;
double zb = -(za - pia + result);
return 0.0;
if (x < 0) {
return y + 1.0;if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || (a.equals(a) == false)) {
if (!x.equals(x)) {
if (!x.equals(x) || !y.equals(y)) {this.X = new Array2DRowRealMatrix(x);
} else if ((x.length > 0) && (x[0].length > x.length)) {
this.X = new Array2DRowRealMatrix(x);
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
return x[0].length;
protected MultipleLinearRegression regression;
protected abstract MultipleLinearRegression createRegression();
x[0] = new double[]{1.0, 0, 0, 0, 0, 0};
x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};
x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};
x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};
x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};
x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};
return x[0].length;
public void cannotAddXSampleData() {
createRegression().newSampleData(new double[]{}, null);
public void cannotAddNullYSampleData() {
createRegression().newSampleData(null, new double[][]{});
int nobs = 47;
int nvars = 4;
double[] betaHat = model.estimateRegressionParameters();
double[] residuals = model.estimateResiduals();
double[] errors = model.estimateRegressionParametersStandardErrors();public DfpField(final int decimalDigits, final boolean computeConstants) {if (FastMath.abs(mij - mji) > (FastMath.max(FastMath.abs(mij), Math
.abs(mji)) * eps)) {fail("Expecting IllegalArgumentException");MessageFormat fmt = null;
fmt = new MessageFormat(general.getLocalizedString(locale), locale);
sb.append(fmt.format(arguments));
fmt = new MessageFormat(specific.getLocalizedString(locale), locale);
sb.append(fmt.format(arguments));internalArray = new double[initialCapacity];
internalArray = initialArray;if (Double.isNaN(d) || Double.isInfinite(d)) {
reportError(mathMethod.getName()+"(float "+d+") expected "+expected+" actual "+actual+ " entry "+entry);final boolean fatal = false; // TODO set true once all bugs have been fixedreturn (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);if (Double.isNaN(d)) {
return d;
if (d < direction) {
return -Double.MAX_VALUE;
} else if (direction < d) {
return Double.MAX_VALUE;
} else {
return d;
long bits     = Double.doubleToLongBits(d);
long sign     = bits & 0x8000000000000000L;
long exponent = bits & 0x7ff0000000000000L;
long mantissa = bits & 0x000fffffffffffffL;
if (d * (direction - d) >= 0) {
if (mantissa == 0x000fffffffffffffL) {
return Double.longBitsToDouble(sign |
(exponent + 0x0010000000000000L));
} else {
return Double.longBitsToDouble(sign |
exponent | (mantissa + 1));
if (mantissa == 0L) {
return Double.longBitsToDouble(sign |
(exponent - 0x0010000000000000L) |
0x000fffffffffffffL);
} else {
return Double.longBitsToDouble(sign |
exponent | (mantissa - 1));
public static float nextAfter(float f, float direction) {
if (Float.isNaN(f)) {
return f;
if (f < direction) {
return -Float.MAX_VALUE;
} else if (direction < f) {
return Float.MAX_VALUE;
} else {
return f;
return (direction < 0f) ? -Float.MIN_VALUE : Float.MIN_VALUE;
int bits     = Float.floatToIntBits(f);
int sign     = bits & 0x80000000;
int exponent = bits & 0x7f800000;
int mantissa = bits & 0x007fffff;
if (f * (direction - f) >= 0f) {
if (mantissa == 0x000fffff) {
return Float.intBitsToFloat(sign | (exponent + 0x00800000));
} else {
return Float.intBitsToFloat(sign | exponent | (mantissa + 1));
if (mantissa == 0) {
return Float.intBitsToFloat(sign | (exponent - 0x00800000) | 0x007fffff);
} else {
return Float.intBitsToFloat(sign | exponent | (mantissa - 1));
public void testNextAfter() {
assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);
assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);
assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);
assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);
assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);
assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);
assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);
assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);
assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
public void testDoubleNextAfterSpecialCases() {
assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D));
assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D));
assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D));
assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY));
assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY));
assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D);
assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D);
assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D);
assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D);
public void testFloatNextAfterSpecialCases() {
assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F));
assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F));
assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN, 0F));
assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY));
assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY));
assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F);
assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F);
assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F);
assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);return Math.round(x);protected boolean statesInitialized;
SortedSet<EventState> occuringEvents = new TreeSet<EventState>();
interpolator.setSoftBounds(previousT, eventT);
interpolator.setSoftBounds(eventT, currentT);
public class EventState implements Comparable<EventState> {
return pendingEventTime;
public int compareTo(final EventState state) {
final double instanceTime = pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;
final double otherTime = state.pendingEvent ? state.pendingEventTime : Double.POSITIVE_INFINITY;
return Double.compare(instanceTime, otherTime);
statesInitialized = false;
statesInitialized = false;
statesInitialized = false;
statesInitialized = false;
statesInitialized = false;
private double globalPreviousTime;
private double globalCurrentTime;
private double softPreviousTime;
private double softCurrentTime;
public void setSoftBounds(final double softPreviousTime, final double softCurrentTime) {
this.softPreviousTime = softPreviousTime;
double numer = (bits & 0x3ffffffffffL);return Double.compare(es0.getEventTime(), es1.getEventTime());
for (final EventState state : occuringEvents) {
final double eventT = state.getEventTime();
state.stepAccepted(eventT, eventY);
isLastStep = state.stop();
if (state.reset(eventT, eventY)) {if (ra == 0 && (y < 0)) { // Fix up the sign so atan works correctly
ra = -0.0;package org.apache.commons.math.exception;
package org.apache.commons.math.exception;
package org.apache.commons.math.exception;
package org.apache.commons.math.exception;
package org.apache.commons.math.exception;
throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
package org.apache.commons.math.exception;
public final class Array2DRowRealMatrixTest extends TestCase {
public Array2DRowRealMatrixTest(String name) {
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals(m2,m1);
assertEquals(m4,m3);
assertEquals("sum entry entry",
fail("MathIllegalArgumentException expected");
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);
assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0], 1.0e-12);
assertEquals( 7.0, b[1], 1.0e-12);
assertEquals(11.0, b[2], 1.0e-12);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
fail ("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);
assertEquals(new Array2DRowRealMatrix(reference), sub);
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new Array2DRowRealMatrix(reference), sub);
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals("Row0", mRow0,
assertEquals("Row3", mRow3,
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowMatrix(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Column1", mColumn1,
assertEquals("Column3", mColumn3,
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowVector(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(subRow3[0][0] != m.getRow(0)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(mColumn3[0] != m.getColumn(1)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(expected.length, actual.length);
assertEquals(expected[i], actual[i]);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));
assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
assertEquals("Array2DRowRealMatrix{}",
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullPointerException");
fail("expecting MathIllegalStateException");
fail("expecting MathIllegalStateException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(m,TestUtils.serializeAndRecover(m));
assertEquals(i + j / 1024.0, value, 0.0);
public final class BlockFieldMatrixTest extends TestCase {
public BlockFieldMatrixTest(String name) {
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals(m1, m2);
assertEquals(m3, m4);
assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);
fail("MathIllegalArgumentException expected");
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
assertEquals(m.getRowDimension(), mT.getColumnDimension());
assertEquals(m.getColumnDimension(), mT.getRowDimension());
assertEquals(m.getEntry(j, i), mT.getEntry(i, j));
assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));
assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));
assertEquals(sum, mTm.getEntry(i, j));
assertEquals(sum, mmT.getEntry(i, j));
assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));
assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));
assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));
assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));
assertEquals(new Fraction(3),m.getTrace());
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals( new Fraction(3), b[0]);
assertEquals( new Fraction(7), b[1]);
assertEquals(new Fraction(11), b[2]);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals(m.getEntry(0,1),new Fraction(2));
fail ("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(new Fraction(2).multiply(solution[0]).
assertEquals(new Fraction(-1).multiply(solution[0]).
assertEquals(new Fraction(4).multiply(solution[0]).
assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);
fail("Expecting OutOfRangeException or NotStrictlyPositiveException"
assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);
fail("Expecting OutOfRangeException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));
assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals("Row0", mRow0, m.getRowMatrix(0));
assertEquals("Row3", mRow3, m.getRowMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowMatrix(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(sub, m.getRowMatrix(2));
assertEquals(mColumn1, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(sub, m.getColumnMatrix(2));
assertEquals(mRow0, m.getRowVector(0));
assertEquals(mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowVector(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(sub, m.getRowVector(2));
assertEquals(mColumn1, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(sub, m.getColumnVector(2));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(subRow3[0][0] != m.getRow(0)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(mColumn3[0] != m.getColumn(1)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(new Fraction(0), m.getEntry(i, j));
assertEquals(new Fraction(1), m.getEntry(i, j));
assertEquals(expected.length, actual.length);
assertEquals(expected[i], actual[i]);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));
assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, matrix);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullPointerException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(m,TestUtils.serializeAndRecover(m));
assertEquals(new Fraction(i * 11 + j, 11), value);
public final class BlockRealMatrixTest extends TestCase {
public BlockRealMatrixTest(String name) {
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals(m1, m2);
assertEquals(m3, m4);
assertEquals("sum entry entry",
fail("MathIllegalArgumentException expected");
assertEquals("testData norm",14d,m.getNorm(),entryTolerance);
assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);
assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);
assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);
fail("Expecting illegalArgumentException");
public void testMultiply() {
fail("Expecting illegalArgumentException");
assertEquals(m.getRowDimension(), mT.getColumnDimension());
assertEquals(m.getColumnDimension(), mT.getRowDimension());
assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);
assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);
assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);
assertEquals(sum, mTm.getEntry(i, j), 0);
assertEquals(sum, mmT.getEntry(i, j), 0);
assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);
assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);
assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);
assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);
RealMatrix m3 = new BlockRealMatrix(d3);
RealMatrix m4 = new BlockRealMatrix(d4);
RealMatrix m5 = new BlockRealMatrix(d5);
assertClose(m3.multiply(m4), m5, entryTolerance);
assertEquals("identity trace",3d,m.getTrace(),entryTolerance);
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals( 3.0, b[0], 1.0e-12);
assertEquals( 7.0, b[1], 1.0e-12);
assertEquals(11.0, b[2], 1.0e-12);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);
fail ("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);
assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);
assertEquals(new BlockRealMatrix(reference), sub);
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new BlockRealMatrix(reference), sub);
fail("Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));
assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals("Row0", mRow0, m.getRowMatrix(0));
assertEquals("Row3", mRow3, m.getRowMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowMatrix(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(sub, m.getRowMatrix(2));
assertEquals(mColumn1, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(sub, m.getColumnMatrix(2));
assertEquals(mRow0, m.getRowVector(0));
assertEquals(mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowVector(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(sub, m.getRowVector(2));
assertEquals(mColumn1, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(sub, m.getColumnVector(2));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(subRow3[0][0] != m.getRow(0)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(mColumn3[0] != m.getColumn(1)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(0.0, m.getEntry(i, j), 0.0);
assertEquals(1.0, m.getEntry(i, j), 0.0);
assertEquals(expected.length, actual.length);
assertEquals(expected[i], actual[i]);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new BlockRealMatrix(bigSingular)));
assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, matrix);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullPointerException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(0.0, m.getEntry(i, 0), 0);
assertEquals(0.0, m.getEntry(i, columns - 1), 0);
assertEquals(0.0, m.getEntry(0, j), 0);
assertEquals(0.0, m.getEntry(rows - 1, j), 0);
assertEquals(m,TestUtils.serializeAndRecover(m));
assertEquals(i + j / 1024.0, value, 0.0);
assertTrue(m.subtract(n).getNorm() < tolerance);
fail("vectors not same length");
assertEquals(m[i], n[i], tolerance);
assertEquals(testData.length, llt.getL().getRowDimension());
assertEquals(testData.length, llt.getL().getColumnDimension());
assertEquals(testData.length, llt.getLT().getRowDimension());
assertEquals(testData.length, llt.getLT().getColumnDimension());
assertEquals(0, norm, 1.0e-15);
assertEquals(0.0, l.getEntry(i, j), 0.0);
assertEquals(0, norm, 1.0e-15);
assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);
assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);
assertTrue(l  == llt.getL());
assertTrue(lt == llt.getLT());
public class EigenSolverTest extends TestCase {
private double[] refValues;
private RealMatrix matrix;
public EigenSolverTest(String name) {
super(name);
assertFalse(es.isNonSingular());
fail("an exception should have been thrown");
assertTrue(es.isNonSingular());
assertEquals(0, error.getNorm(), 4.0e-15);
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);
assertEquals(0,
assertEquals(0,
assertEquals(0,
public void setUp() {
refValues = new double[] {
2.003, 2.002, 2.001, 1.001, 1.000, 0.001
};
matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);
public void tearDown() {
refValues = null;
matrix    = null;
public class FieldLUDecompositionImplTest extends TestCase {
public FieldLUDecompositionImplTest(String name) {
super(name);
assertEquals(testData.length, LU.getL().getRowDimension());
assertEquals(testData.length, LU.getL().getColumnDimension());
assertEquals(testData.length, LU.getU().getRowDimension());
assertEquals(testData.length, LU.getU().getColumnDimension());
assertEquals(testData.length, LU.getP().getRowDimension());
assertEquals(testData.length, LU.getP().getColumnDimension());
fail("Expected NonSquareMatrixException");
assertFalse(lu.getSolver().isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
assertFalse(lu.getSolver().isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
assertEquals(Fraction.ONE, l.getEntry(i, i));
assertEquals(Fraction.ZERO, l.getEntry(i, j));
assertEquals(Fraction.ZERO, u.getEntry(i, j));
assertEquals(p.getColumnDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
assertEquals(p.getRowDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
assertTrue(lu.getSolver().isNonSingular());
assertFalse(lu.getSolver().isNonSingular());
assertFalse(lu.getSolver().isNonSingular());
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
public final class FieldMatrixImplTest extends TestCase {
public FieldMatrixImplTest(String name) {
super(name);
assertEquals("testData row dimension",3,m.getRowDimension());
assertEquals("testData column dimension",3,m.getColumnDimension());
assertTrue("testData is square",m.isSquare());
assertEquals("testData2 row dimension",m2.getRowDimension(),2);
assertEquals("testData2 column dimension",m2.getColumnDimension(),3);
assertTrue("testData2 is not square",!m2.isSquare());
assertEquals(m2,m1);
assertEquals(m4,m3);
assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);
fail("MathIllegalArgumentException expected");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals("identity trace",new Fraction(3),m.getTrace());
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals( new Fraction(3), b[0]);
assertEquals( new Fraction(7), b[1]);
assertEquals(new Fraction(11), b[2]);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals("get entry", m.getEntry(0,1), new Fraction(2));
fail ("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(new Fraction(2).multiply(solution[0]).
assertEquals(new Fraction(-1).multiply(solution[0]).
assertEquals(new Fraction(4).multiply(solution[0]).
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);
fail("Expecting OutOfRangeException or NotStrictlyPositiveException"
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);
fail("Expecting OutOfRangeException or NotStrictlyPositiveException"
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));
fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");
assertEquals("Row0", mRow0,
assertEquals("Row3", mRow3,
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowMatrix(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Column1", mColumn1,
assertEquals("Column3", mColumn3,
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnMatrix(1));
assertEquals(mColumn3, m.getColumnMatrix(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mRow3, m.getRowMatrix(0));
assertEquals(mRow3, m.getRowVector(0));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertNotSame(mColumn3, m.getColumnVector(1));
assertEquals(mColumn3, m.getColumnVector(1));
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(subRow3[0][0] != m.getRow(0)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(mColumn3[0] != m.getColumn(1)[0]);
fail("Expecting OutOfRangeException");
fail("Expecting MatrixDimensionMismatchException");
assertEquals(expected.length, actual.length);
assertEquals(expected[i], actual[i]);
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));
assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());
assertEquals("Array2DRowFieldMatrix{}", m.toString());
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullArgumentException");
fail("expecting MathIllegalStateException");
fail("expecting MathIllegalStateException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(rows * columns, getVisitor.getCount());
assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());
assertEquals(new Fraction(0), m.getEntry(i, 0));
assertEquals(new Fraction(0), m.getEntry(i, columns - 1));
assertEquals(new Fraction(0), m.getEntry(0, j));
assertEquals(new Fraction(0), m.getEntry(rows - 1, j));
assertEquals(m,TestUtils.serializeAndRecover(m));
assertEquals(new Fraction(i * 1024 + j, 1024), value);
public class LUDecompositionImplTest extends TestCase {
public LUDecompositionImplTest(String name) {
super(name);
assertEquals(testData.length, LU.getL().getRowDimension());
assertEquals(testData.length, LU.getL().getColumnDimension());
assertEquals(testData.length, LU.getU().getRowDimension());
assertEquals(testData.length, LU.getU().getColumnDimension());
assertEquals(testData.length, LU.getP().getRowDimension());
assertEquals(testData.length, LU.getP().getColumnDimension());
fail("Expecting NonSquareMatrixException");
assertEquals(0, norm, normTolerance);
assertEquals(0, norm, normTolerance);
assertEquals(0, norm, normTolerance);
assertFalse(lu.getSolver().isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
assertFalse(lu.getSolver().isNonSingular());
assertNull(lu.getL());
assertNull(lu.getU());
assertNull(lu.getP());
assertEquals(l.getEntry(i, i), 1, entryTolerance);
assertEquals(l.getEntry(i, j), 0, entryTolerance);
assertEquals(u.getEntry(i, j), 0, entryTolerance);
assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);
assertEquals(p.getColumnDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
assertEquals(p.getRowDimension() - 1, zeroCount);
assertEquals(1, oneCount);
assertEquals(0, otherCount);
assertTrue(lu.getSolver().isNonSingular());
assertFalse(lu.getSolver().isNonSingular());
assertFalse(lu.getSolver().isNonSingular());
assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);
assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);
assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);
assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);
assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);
assertEquals(pivotRef[i], pivot[i]);
assertTrue(l == lu.getL());
assertTrue(u == lu.getU());
assertTrue(p == lu.getP());
public class LUSolverTest extends TestCase {
public LUSolverTest(String name) {
super(name);
assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());
assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());
assertTrue(solver.isNonSingular());
assertFalse(solver.isNonSingular());
assertFalse(solver.isNonSingular());
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);
assertEquals(0,
assertEquals(0,
assertEquals(0,
assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);
assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);
assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);
assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);
public class QRSolverTest extends TestCase {
public QRSolverTest(String name) {
super(name);
assertTrue(solver.isNonSingular());
assertFalse(solver.isNonSingular());
assertTrue(solver.isNonSingular());
assertTrue(solver.isNonSingular());
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
fail("an exception should have been thrown");
assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());
assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());
assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());
assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());
assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);
assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);
assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());
m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){
public double visit(int row, int column, double value) {
return 2.0 * r.nextDouble() - 1.0;
});
public class SparseFieldMatrixTest extends TestCase {
public SparseFieldMatrixTest(String name) {
super(name);
setupFractionArrays();
private void setupFractionArrays() {
assertEquals("testData row dimension", 3, m.getRowDimension());
assertEquals("testData column dimension", 3, m.getColumnDimension());
assertTrue("testData is square", m.isSquare());
assertEquals("testData2 row dimension", m2.getRowDimension(), 2);
assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);
assertTrue("testData2 is not square", !m2.isSquare());
assertEquals(m1.getClass(), m2.getClass());
assertEquals((m2), m1);
assertEquals(m3.getClass(), m4.getClass());
assertEquals((m4), m3);
assertEquals("sum entry entry",
fail("MathIllegalArgumentException expected");
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance);
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals(3.0, b[0].doubleValue(), 1.0e-12);
assertEquals(7.0, b[1].doubleValue(), 1.0e-12);
assertEquals(11.0, b[2].doubleValue(), 1.0e-12);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);
fail("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),
assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),
assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),
assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));
assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));
assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));
assertEquals("Rows02Cols13", mRows02Cols13,
assertEquals("Rows03Cols12", mRows03Cols12,
assertEquals("Rows03Cols123", mRows03Cols123,
assertEquals("Rows20Cols123", mRows20Cols123,
assertEquals("Rows31Cols31", mRows31Cols31,
assertEquals("Rows31Cols31", mRows31Cols31,
fail("Expecting NumberIsTooSmallException");
fail("Expecting OutOfRangeException");
fail("Expecting NumberIsTooSmallException");
fail("Expecting NumberIsTooSmallException");
fail("Expecting NoDataException");
fail("Expecting OutOfRangeException");
assertEquals("Row0", mRow0, m.getRowMatrix(0));
assertEquals("Row3", mRow3, m.getRowMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Column1", mColumn1, m.getColumnMatrix(1));
assertEquals("Column3", mColumn3, m.getColumnMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(createSparseMatrix(bigSingular)));
assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString());
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, matrix);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullArgumentException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);
fail("vectors not same length");
assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(),
public final class SparseRealMatrixTest extends TestCase {
public SparseRealMatrixTest(String name) {
super(name);
assertEquals("testData row dimension", 3, m.getRowDimension());
assertEquals("testData column dimension", 3, m.getColumnDimension());
assertTrue("testData is square", m.isSquare());
assertEquals("testData2 row dimension", m2.getRowDimension(), 2);
assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);
assertTrue("testData2 is not square", !m2.isSquare());
assertEquals(m1.getClass(), m2.getClass());
assertEquals((m2), m1);
assertEquals(m3.getClass(), m4.getClass());
assertEquals((m4), m3);
assertEquals("sum entry entry",
fail("MathIllegalArgumentException expected");
assertEquals("testData norm", 14d, m.getNorm(), entryTolerance);
assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance);
fail("Expecting illegalArgumentException");
fail("Expecting illegalArgumentException");
assertEquals("identity trace", 3d, m.getTrace(), entryTolerance);
fail("Expecting NonSquareMatrixException");
fail("Expecting illegalArgumentException");
assertEquals(a.getRowDimension(), b.length);
assertEquals(3.0, b[0], 1.0e-12);
assertEquals(7.0, b[1], 1.0e-12);
assertEquals(11.0, b[2], 1.0e-12);
fail("expecting MathIllegalArgumentException");
fail("Expecting illegalArgumentException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);
fail("Expecting OutOfRangeException");
assertEquals(2, p.getRowDimension());
assertEquals(2, p.getColumnDimension());
assertEquals(2, pInverse.getRowDimension());
assertEquals(2, pInverse.getColumnDimension());
assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],
assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],
assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],
assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));
assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));
assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));
assertEquals("Rows02Cols13", mRows02Cols13,
assertEquals("Rows03Cols12", mRows03Cols12,
assertEquals("Rows03Cols123", mRows03Cols123,
assertEquals("Rows20Cols123", mRows20Cols123,
assertEquals("Rows31Cols31", mRows31Cols31,
assertEquals("Rows31Cols31", mRows31Cols31,
fail("Expecting NumberIsTooSmallException");
fail("Expecting OutOfRangeException");
fail("Expecting NumberIsTooSmallException");
fail("Expecting NumberIsTooSmallException");
fail("Expecting NoDataException");
fail("Expecting OutOfRangeException");
assertEquals("Row0", mRow0, m.getRowMatrix(0));
assertEquals("Row3", mRow3, m.getRowMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Column1", mColumn1, m.getColumnMatrix(1));
assertEquals("Column3", mColumn3, m.getColumnMatrix(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Row0", mRow0, m.getRowVector(0));
assertEquals("Row3", mRow3, m.getRowVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertEquals("Column1", mColumn1, m.getColumnVector(1));
assertEquals("Column3", mColumn3, m.getColumnVector(3));
fail("Expecting OutOfRangeException");
fail("Expecting OutOfRangeException");
assertTrue(m.hashCode() != mt.hashCode());
assertEquals(m.hashCode(), m1.hashCode());
assertEquals(m, m);
assertEquals(m, m1);
assertFalse(m.equals(null));
assertFalse(m.equals(mt));
assertFalse(m.equals(createSparseMatrix(bigSingular)));
assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",
assertEquals("OpenMapRealMatrix{{0.0}}", m.toString());
public void testSetSubMatrix() throws Exception {
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, m);
assertEquals(expected, matrix);
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting OutOfRangeException");
fail("expecting NullPointerException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
fail("expecting MathIllegalArgumentException");
assertEquals(m,TestUtils.serializeAndRecover(m));
assertTrue(msg, m.subtract(n).getNorm() < tolerance);
fail("vectors not same length");
assertEquals(msg + " " + i + " elements differ", m[i], n[i],
public class TriDiagonalTransformerTest extends TestCase {
public TriDiagonalTransformerTest(String name) {
super(name);
fail("an exception should have been thrown");
assertEquals(0, norm, 4.0e-15);
assertEquals(0, norm, 4.0e-15);
assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);
assertEquals(0, m.getEntry(i, j), 1.0e-16);
assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);
assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);
assertTrue(q == transformer.getQ());
assertTrue(t == transformer.getT());public double value(double x,
double[] param) {
public double[] gradient(double x, double[] param) {
public double value(double x,
double[] param) {
public double[] gradient(double x, double[] param) {
public double value(double x,
double[] param) {
public double[] gradient(double x, double[] param) {
public double value(double x,
double[] param) {
public double[] gradient(double x, double[] param) {
public double value(double x,
double[] param) {
public double[] gradient(double x, double[] param) {
public double[] gradient(double x, double[] parameters) {
public double value(final double x, final double[] parameters) {
public double value(double x, double[] p) {
public double[] gradient(double x, double[] p) {
public double value(double x, double[] parameters) {
public double[] gradient(double x, double[] parameters) {
public double value(double x, double[] parameters) {
public double[] gradient(double x, double[] doubles) {Assert.assertEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());
Assert.assertEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());
Assert.assertEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());
Assert.assertEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());
Assert.assertEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());
Assert.assertEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());
Assert.assertEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());
Assert.assertEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());
Assert.assertEquals("compare vectors" ,result_mapInv,v_mapInv.getData());
Assert.assertEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());
Assert.assertEquals("compare vect" ,v_add.getData(),result_add);
Assert.assertEquals("compare vect" ,v_add_i.getData(),result_add_i);throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
throw new UnsupportedOperationException("This class is deprecated; calling this method is a bug.");
public void setMaximalIterationCount(int count);
public int getMaximalIterationCount();
public void setAbsoluteAccuracy(double accuracy);
public double getAbsoluteAccuracy();
public void setRelativeAccuracy(double accuracy);
public double getRelativeAccuracy();
protected final void setResult(final double newResult, final int iterationCount) {
this.iterationCount = iterationCount;
public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;
public double cdf(double d);
final int n = this.n;
return (exact) ? this.exactK(d) : this.roundedK(d);
final int n = this.n;
return pFrac.bigDecimalValue(20, BigDecimal.ROUND_HALF_UP)
.doubleValue();
final int n = this.n;
int n = this.n;
Hdata[m - 1][0] = Hdata[m - 1][0].add(h.multiply(2).subtract(1)
.pow(m));
}    
final char[] binaryRepresentation = Integer.toBinaryString(power).toCharArray();       
for (int i = 0; i < binaryRepresentation.length; ++i) {            
}        
private double valueRange = 1.0;
private boolean isRepairMode = true;
private double[] encode(final double[] x) {
private double[] decode(final double[] x) {
private double value(final double[] point) {
private boolean isFeasible(final double[] x) {
private void setValueRange(double valueRange) {
private double[] concatinateSamples(final double[] x, final double[] y) {
final double[] z = concatinateSamples(x, y);
private double[] calculateDifferences(final double[] x, final double[] y)
throws IllegalArgumentException {public abstract Vector<S> parse(String source);
public double getOffset(final Hyperplane<Euclidean2D> hyperplane) {
Line line = (Line) hyperplane;
final IntervalsSet region = 
public AbstractRegion(final Hyperplane<S>[] hyperplanes) {
if ((hyperplanes == null) || (hyperplanes.length == 0)) {
tree = new BSPTree<S>(Boolean.FALSE);
} else {
tree = hyperplanes[0].wholeSpace().getTree(false);
BSPTree<S> node = tree;
node.setAttribute(Boolean.TRUE);
for (final Hyperplane<S> hyperplane : hyperplanes) {
if (node.insertCut(hyperplane)) {
node.setAttribute(null);
node.getPlus().setAttribute(Boolean.FALSE);
node = node.getMinus();
node.setAttribute(Boolean.TRUE);
protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyperplane,
final Region<T> remainingRegion);
public abstract Side side(Hyperplane<S> hyperplane);
public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);
final SubHyperplane<S> plusOutside;
final SubHyperplane<S> plusInside;
if (attribute.plusOutside != null) {
boundarySize += attribute.plusOutside.getSize();
if (attribute.plusInside != null) {
boundarySize += attribute.plusInside.getSize();
int count;
final double[] t;
final double[][] y;
final double[][] yDot;
private static final int DEFAULT_ULPS = 10;final UnivariateRealFunction f = interpolator.interpolate(xval, yval);
final UnivariateRealFunction f = interpolator.interpolate(xval, yval);final RandomGenerator generator = getRan();
double unif = generator.nextDouble();
while (unif == 0.0d) {
unif = generator.nextDouble();
return -mean * FastMath.log(unif);
randomData.reSeed(1000);  
public void testNextExponential() {
} DummyRandomKey drk = new DummyRandomKey(new Double[] {0.1, 0.1, 2d, 0.8, 0.2});
Assert.fail("Expecting InvalidRepresentationException");
} catch (IllegalArgumentException ex) {private AllowedSolutions allowedSolutions;
this.allowedSolutions = AllowedSolutions.ANY_SIDE;
this.allowedSolutions = AllowedSolutions.ANY_SIDE;
this.allowedSolutions = allowedSolutions;
switch (allowedSolutions) {
switch (allowedSolutions) {if (isNaN()) {
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (rhs.isNaN()) {
return this.isNaN();
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (isNaN() || Double.isNaN(rhs)) {
if (isNaN()) {
if (isNaN() || rhs.isNaN()) {
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
return Complex.NaN;
if (isNaN()) {
result.add(Complex.NaN);
result.add(Complex.INF);return nextInversionDeviate(new GammaDistributionImpl(shape, scale));
double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));
long[] counts = new long[4];dist.reseedRandomGenerator(1000);  // Use fixed seedprotected EmpiricalDistribution empiricalDistribution2 = null;public class AbstractRandomGeneratorTest extends RandomDataTest {
protected TestRandomGenerator testGenerator = new TestRandomGenerator();
public AbstractRandomGeneratorTest() {
randomData = new RandomDataImpl(testGenerator);
public void testNextInt() {
testGenerator.nextInt(-1);
Assert.fail("MathIllegalArgumentException expected");
} catch (MathIllegalArgumentException ex) {
Frequency freq = new Frequency();
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
value = testGenerator.nextInt(4);
Assert.assertTrue("nextInt range",(value >= 0) && (value <= 3));
freq.addValue(value);
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);
public void testNextLong() {
long q1 = Long.MAX_VALUE/4;
long q2 = 2 *  q1;
long q3 = 3 * q1;
Frequency freq = new Frequency();
long val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextLong();
if (val < q1) {
value = 0;
} else if (val < q2) {
value = 1;
} else if (val < q3) {
value = 2;
} else {
value = 3;
freq.addValue(value);
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);
public void testNextBoolean() {
long halfSampleSize = smallSampleSize / 2;
double[] expected = {halfSampleSize, halfSampleSize};
long[] observed = new long[2];
for (int i=0; i<smallSampleSize; i++) {
if (testGenerator.nextBoolean()) {
observed[0]++;
} else {
observed[1]++;
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 10.828);
public void testNextFloat() {
Frequency freq = new Frequency();
float val = 0;
int value = 0;
for (int i=0; i<smallSampleSize; i++) {
val = testGenerator.nextFloat();
if (val < 0.25) {
value = 0;
} else if (val < 0.5) {
value = 1;
} else if (val < 0.75) {
value = 2;
} else {
value = 3;
freq.addValue(value);
long[] observed = new long[4];
for (int i=0; i<4; i++) {
observed[i] = freq.getCount(i);
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected,observed) < 16.27);
public class MersenneTwisterTest {
public void testGaussian() {
MersenneTwister mt = new MersenneTwister(42853252100l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 1000; ++i) {
sample.addValue(mt.nextGaussian());
Assert.assertEquals(0.0, sample.getMean(), 0.005);
Assert.assertEquals(1.0, sample.getStandardDeviation(), 0.025);
public void testDouble() {
MersenneTwister mt = new MersenneTwister(195357343514l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 1000; ++i) {
sample.addValue(mt.nextDouble());
Assert.assertEquals(0.5, sample.getMean(), 0.02);
Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
sample.getStandardDeviation(),
0.002);
public void testFloat() {
MersenneTwister mt = new MersenneTwister(4442733263l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 1000; ++i) {
sample.addValue(mt.nextFloat());
Assert.assertEquals(0.5, sample.getMean(), 0.01);
Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
sample.getStandardDeviation(),
0.006);
public void testNextIntNeg() {
new MersenneTwister(1).nextInt(-1);
public void testNextIntN() {
MersenneTwister mt = new MersenneTwister(0x12b8a7412bb25el);
for (int n = 1; n < 20; ++n) {
int[] count = new int[n];
for (int k = 0; k < 10000; ++k) {
int l = mt.nextInt(n);
++count[l];
Assert.assertTrue(l >= 0);
Assert.assertTrue(l <  n);
for (int i = 0; i < n; ++i) {
Assert.assertTrue(n * count[i] >  8600);
Assert.assertTrue(n * count[i] < 11200);
public void testNextInt() {
MersenneTwister mt = new MersenneTwister(new int[] { 1, 2, 3, 4, 5 });
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextInt() >= 0) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 120);
public void testNextLong() {
MersenneTwister mt = new MersenneTwister(12345);
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextLong() >= 0) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 50);
public void testNexBoolean() {
MersenneTwister mt = new MersenneTwister(76342);
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextBoolean()) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 250);
public void testNexBytes() {
MersenneTwister mt = new MersenneTwister(0);
int[] count = new int[256];
byte[] bytes = new byte[10];
for (int k = 0; k < 100000; ++k) {
mt.nextBytes(bytes);
for (byte b : bytes) {
++count[b + 128];
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int c : count) {
min = FastMath.min(min, c);
max = FastMath.max(max, c);
int expected = (100000 * bytes.length) / count.length;
Assert.assertTrue((expected - 200) < min);
Assert.assertTrue(max < (expected + 200));
randomData.reSeed(1000);
public class Well1024aTest {
public void testGaussian() {
Well1024a mt = new Well1024a(42853252100l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 10000; ++i) {
sample.addValue(mt.nextGaussian());
Assert.assertEquals(0.0, sample.getMean(), 0.004);
Assert.assertEquals(1.0, sample.getStandardDeviation(), 0.003);
public void testDouble() {
Well1024a mt = new Well1024a(195357343514l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 10000; ++i) {
sample.addValue(mt.nextDouble());
Assert.assertEquals(0.5, sample.getMean(), 0.0006);
Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
sample.getStandardDeviation(),
0.002);
public void testFloat() {
Well1024a mt = new Well1024a(4442733263l);
SummaryStatistics sample = new SummaryStatistics();
for (int i = 0; i < 10000; ++i) {
sample.addValue(mt.nextFloat());
Assert.assertEquals(0.5, sample.getMean(), 0.0001);
Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
sample.getStandardDeviation(),
0.003);
public void testNextIntNeg() {
new Well1024a(1).nextInt(-1);
public void testNextIntN() {
Well1024a mt = new Well1024a(0x12b8a7412bb25el);
for (int n = 1; n < 20; ++n) {
int[] count = new int[n];
for (int k = 0; k < 10000; ++k) {
int l = mt.nextInt(n);
++count[l];
Assert.assertTrue(l >= 0);
Assert.assertTrue(l <  n);
for (int i = 0; i < n; ++i) {
Assert.assertTrue(n * count[i] >  8600);
Assert.assertTrue(n * count[i] < 11200);
public void testNextInt() {
Well1024a mt = new Well1024a(new int[] { 1, 2, 3, 4, 5 });
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextInt() >= 0) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 70);
public void testNextLong() {
Well1024a mt = new Well1024a(12345);
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextLong() >= 0) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 70);
public void testNexBoolean() {
Well1024a mt = new Well1024a(76342);
int walk = 0;
for (int k = 0; k < 10000; ++k) {
if (mt.nextBoolean()) {
++walk;
} else {
--walk;
Assert.assertTrue(FastMath.abs(walk) < 180);
public void testNexBytes() {
Well1024a mt = new Well1024a(0);
int[] count = new int[256];
byte[] bytes = new byte[10];
for (int k = 0; k < 1000000; ++k) {
mt.nextBytes(bytes);
for (byte b : bytes) {
++count[b + 128];
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int c : count) {
min = FastMath.min(min, c);
max = FastMath.max(max, c);
int expected = (1000000 * bytes.length) / count.length;
Assert.assertTrue((expected - 600) < min);
Assert.assertTrue(max < (expected + 600));
public class Well19937aTest {
public class Well19937cTest {
public class Well44497aTest {
public class Well44497bTest {
public class Well512aTest {return (int) (nextDouble() * Integer.MAX_VALUE);
return (long) (nextDouble() * Long.MAX_VALUE);
public void testNextInt2() {
public void testNextLong2() {
generator.setSeed(1000);throw MathRuntimeException.createIllegalArgumentException(
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.INSUFFICIENT_DIMENSION, length, 2);
throw MathRuntimeException.createIllegalArgumentException(public LegendreGaussIntegrator(final int n, final int defaultMaximalIterationCount)
throws IllegalArgumentException {
super(defaultMaximalIterationCount);
public double integrate(final UnivariateRealFunction f, final double min, final double max)
throws ConvergenceException,  MathUserException, IllegalArgumentException {
clearResult();
verifyInterval(min, max);
verifyIterationCount();
double oldt = stage(f, min, max, 1);
for (int i = 0; i < maximalIterationCount; ++i) {
final double t = stage(f, min, max, n);
if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {
setResult(t, i);
throw new MaxCountExceededException(maximalIterationCount);
private double stage(final UnivariateRealFunction f,
final double min, final double max, final int n)
throws MathUserException {
sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);
super(32);
public double integrate(final UnivariateRealFunction f, final double min, final double max)
throws MaxCountExceededException, MathUserException, IllegalArgumentException {
final int m = maximalIterationCount + 1;
clearResult();
verifyInterval(min, max);
verifyIterationCount();
currentRow[0] = qtrap.stage(f, min, max, 0);
for (int i = 1; i <= maximalIterationCount; ++i) {
currentRow[0] = qtrap.stage(f, min, max, i);
setResult(s, i);
throw new MaxCountExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 32) {
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.INVALID_ITERATIONS_LIMITS,
0, 32);
super(64);
public double integrate(final UnivariateRealFunction f, final double min, final double max)
throws MaxCountExceededException, MathUserException, IllegalArgumentException {
clearResult();
verifyInterval(min, max);
verifyIterationCount();
final double s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;
setResult(s, 1);
double oldt = qtrap.stage(f, min, max, 0);
for (int i = 1; i <= maximalIterationCount; ++i) {
final double t = qtrap.stage(f, min, max, i);
if (i >= minimalIterationCount) {
setResult(s, i);
throw new MaxCountExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.INVALID_ITERATIONS_LIMITS,
0, 64);
super(64);
double stage(final UnivariateRealFunction f,
final double min, final double max, final int n)
throws MathUserException {
s = 0.5 * (max - min) * (f.value(min) + f.value(max));
final double spacing = (max - min) / np; // spacing between adjacent new points
double x = min + 0.5 * spacing;    // the first new point
sum += f.value(x);
public double integrate(final UnivariateRealFunction f, final double min, final double max)
throws MaxCountExceededException, MathUserException, IllegalArgumentException {
clearResult();
verifyInterval(min, max);
verifyIterationCount();
double oldt = stage(f, min, max, 0);
for (int i = 1; i <= maximalIterationCount; ++i) {
final double t = stage(f, min, max, i);
setResult(t, i);
throw new MaxCountExceededException(maximalIterationCount);
protected void verifyIterationCount() throws IllegalArgumentException {
super.verifyIterationCount();
if (maximalIterationCount > 64) {
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.INVALID_ITERATIONS_LIMITS,
0, 64);
void setMaximalIterationCount(int count);
int getMaximalIterationCount();
void setAbsoluteAccuracy(double accuracy);
void setRelativeAccuracy(double accuracy);
double getRelativeAccuracy();
void setMinimalIterationCount(int count);
void resetMinimalIterationCount();
double integrate(UnivariateRealFunction f, double min, double max)
throws ConvergenceException, MathUserException, IllegalArgumentException;
protected int maximalIterationCount;
protected int defaultMinimalIterationCount;
protected int iterationCount;
protected UnivariateRealIntegratorImpl(final int maximalIterationCount) {
setMaximalIterationCount(maximalIterationCount);
setAbsoluteAccuracy(1.0e-15);
setRelativeAccuracy(1.0e-6);
setMinimalIterationCount(3);
verifyIterationCount();
public void setMaximalIterationCount(final int count) {
maximalIterationCount = count;
public int getMaximalIterationCount() {
return maximalIterationCount;
public void setAbsoluteAccuracy(double accuracy) {
absoluteAccuracy = accuracy;
public void setRelativeAccuracy(final double accuracy) {
relativeAccuracy = accuracy;
public double getRelativeAccuracy() {
return relativeAccuracy;
protected final void setResult(final double newResult, final int newCount) {
this.result         = newResult;
this.iterationCount = newCount;
this.resultComputed = true;
protected final void clearResult() {
this.iterationCount = 0;
this.resultComputed = false;
public void setMinimalIterationCount(final int count) {
minimalIterationCount = count;
public int getMinimalIterationCount() {
return minimalIterationCount;
public void resetMinimalIterationCount() {
minimalIterationCount = defaultMinimalIterationCount;
protected void verifyInterval(final double lower, final double upper)
throws IllegalArgumentException {
if (lower >= upper) {
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,
lower, upper);
protected void verifyIterationCount() throws IllegalArgumentException {
if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {
throw MathRuntimeException.createIllegalArgumentException(
LocalizedFormats.INVALID_ITERATIONS_LIMITS,
minimalIterationCount, maximalIterationCount);
protected void resetIterationsCounter() {
iterationCount = 0;
protected void incrementIterationsCounter() {
if (++iterationCount > maximalIterationCount) {
throw new MaxCountExceededException(maximalIterationCount);
UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 64);
integrator.setAbsoluteAccuracy(1.0e-10);
integrator.setRelativeAccuracy(1.0e-14);
integrator.setMinimalIterationCount(2);
integrator.setMaximalIterationCount(15);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
new LegendreGaussIntegrator(n, 64);
double result    = integrator.integrate(p, -5.0, 15.0);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
UnivariateRealIntegrator integrator = new RombergIntegrator();
integrator.integrate(f, 1, -1);
Assert.fail("Expecting IllegalArgumentException - bad interval");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(50);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
UnivariateRealIntegrator integrator = new SimpsonIntegrator();
integrator.integrate(f, 1, -1);
Assert.fail("Expecting IllegalArgumentException - bad interval");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
result = integrator.integrate(f, min, max);
UnivariateRealIntegrator integrator = new TrapezoidIntegrator();
integrator.integrate(f, 1, -1);
Assert.fail("Expecting IllegalArgumentException - bad interval");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(5);
integrator.setMaximalIterationCount(4);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {
integrator.setMinimalIterationCount(10);
integrator.setMaximalIterationCount(99);
integrator.integrate(f, -1, 1);
Assert.fail("Expecting IllegalArgumentException - bad iteration limits");
} catch (IllegalArgumentException ex) {setResult(t);
return result;
setResult(s);
return result;
final double s = (4 * qtrap.stage(this, 1) - qtrap.stage(this, 0)) / 3.0;
setResult(s);
return result;
setResult(s);
return result;
setResult(t);
return result;
double getResult() throws IllegalStateException;
int getEvaluations() throws IllegalStateException;
int getIterations() throws IllegalStateException;
protected boolean resultComputed = false;
protected double result;
public double getResult() throws IllegalStateException {
if (resultComputed) {
return result;
} else {
throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);
public int getEvaluations() throws IllegalStateException {
if (resultComputed) {
return evaluations.getCount();
} else {
throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);
public int getIterations() throws IllegalStateException {
if (resultComputed) {
return iterations.getCount();
} else {
throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);
protected final void setResult(final double newResult) {
result         = newResult;
resultComputed = true;
resultComputed = false;curv = hq.getEntry((j + j * j) / 2 - 1);ArrayRealVector xbase, 
int iact = -1; 
} return new DataInputStream(new BufferedInputStream(FastMathResources.class.getResourceAsStream(fullName)));rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));
rand = new JDKRandomGenerator();
rand = new JDKRandomGenerator();
rand.setSeed(System.currentTimeMillis());throw new PathIsExploredException(); // XXX
interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));
interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));
throw new PathIsExploredException(); // XXX
class PathIsExploredException extends RuntimeException {
private static final long serialVersionUID = 745350979634801853L;
private static final String PATH_IS_EXPLORED
= "If this exception is thrown, just remove it from the code";
PathIsExploredException() {
super(PATH_IS_EXPLORED);
double[] startPoint,
double[][] boundaries,
GoalType goal,
double fTol,
double pointTol,
int maxEvaluations,
RealPointValuePair expected) {
BOBYQAOptimizer optim = new BOBYQAOptimizer(2 * dim + 1);
Assert.assertEquals(expected.getValue(),
result.getValue(), fTol);
result.getPoint()[i], pointTol);final InvertibleRealLinearOperator m,
final RealVector b, final RealVector x0)
checkParameters(a, m, b, x0);
if (m == null) {
if (m != null) {
z = m.solve(r);
context.setValue(OPERATOR, m);
package org.apache.commons.math.linear;
public abstract class InvertibleRealLinearOperator extends RealLinearOperator {
public abstract RealVector solve(final RealVector b);
final RealVector b,
final RealVector x0)
throws NullArgumentException, NonSquareOperatorException,
public RealVector solve(RealLinearOperator a, RealVector b)
RealVector x0)
throws NullArgumentException, NonSquareOperatorException,
public class JacobiPreconditioner
extends InvertibleRealLinearOperator {
return x.ebeMultiply(diag);
public RealVector solve(final RealVector b) {
return b.ebeDivide(diag);
final InvertibleRealLinearOperator m,
final RealVector b, final RealVector x0)
return solveInPlace(a, m, b, x0.copy());
final InvertibleRealLinearOperator m,
final RealVector b,
final RealVector x0)
if (m != null) {
if (m.getColumnDimension() != m.getRowDimension()) {
throw new NonSquareOperatorException(m.getColumnDimension(),
m.getRowDimension());
if (m.getRowDimension() != a.getRowDimension()) {
throw new DimensionMismatchException(m.getRowDimension(),
public RealVector solve(RealLinearOperator a,
InvertibleRealLinearOperator m, RealVector b)
throws NullArgumentException, NonSquareOperatorException,
return solveInPlace(a, m, b, x);
InvertibleRealLinearOperator m,
RealVector b, RealVector x0)
throws NullArgumentException, NonSquareOperatorException,
final RealVector b, final RealVector x0)
throws NullArgumentException, NonSquareOperatorException,
private final InvertibleRealLinearOperator m;
private final RealVector mSolveB;
public State(final RealLinearOperator a,
final InvertibleRealLinearOperator m, final RealVector b,
final RealVector x, final boolean goodb, final double shift) {
this.m = m;
this.mSolveB = m == null ? b : m.solve(b);
final double bi = mSolveB.getEntry(i);
final double bi = mSolveB.getEntry(i);
this.y = this.m == null ? this.b.copy() : this.m.solve(this.r1);
if ((this.m != null) && check) {
checkSymmetry(this.m, this.r1, this.y, this.m.solve(this.y));
throwNPDLOException(this.m, this.y);
if (this.m != null) {
this.y = this.m.solve(this.r2);
throwNPDLOException(this.m, this.y);
if (m != null) {
y = m.solve(r2);
throwNPDLOException(m, y);
final RealVector x, final RealVector y,
final RealVector z)
final double b, final RealVector y,
final RealVector z) {
final RealVector y) {
final RealVector v)
throws NonPositiveDefiniteOperatorException {
final InvertibleRealLinearOperator m,
final RealVector b)
throws NullArgumentException, NonSquareOperatorException,
DimensionMismatchException, NonSelfAdjointOperatorException,
NonPositiveDefiniteOperatorException, IllConditionedOperatorException,
MaxCountExceededException {
return solveInPlace(a, m, b, x, false, 0.);
final InvertibleRealLinearOperator m,
final RealVector b, final boolean goodb,
final double shift)
throws NullArgumentException, NonSquareOperatorException,
DimensionMismatchException, NonSelfAdjointOperatorException,
NonPositiveDefiniteOperatorException, IllConditionedOperatorException,
MaxCountExceededException {
return solveInPlace(a, m, b, x, goodb, shift);
final InvertibleRealLinearOperator m,
final RealVector b, final RealVector x)
return solveInPlace(a, m, b, x.copy(), false, 0.);
final boolean goodb, final double shift)
throws NullArgumentException, NonSquareOperatorException,
DimensionMismatchException, NonSelfAdjointOperatorException,
IllConditionedOperatorException, MaxCountExceededException {
final RealVector x)
throws NullArgumentException, NonSquareOperatorException,
DimensionMismatchException, NonSelfAdjointOperatorException,
IllConditionedOperatorException, MaxCountExceededException {
final InvertibleRealLinearOperator m,
final RealVector b, final RealVector x)
return solveInPlace(a, m, b, x, false, 0.);
final InvertibleRealLinearOperator m,
final RealVector b, final RealVector x,
final boolean goodb, final double shift)
checkParameters(a, m, b, x);
final State state = new State(a, m, b, x, goodb, shift);
final RealVector b, final RealVector x)
throws NullArgumentException, NonSquareOperatorException,
DimensionMismatchException, NonSelfAdjointOperatorException,
IllConditionedOperatorException, MaxCountExceededException {
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
throw new UnsupportedOperationException();
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
throw new UnsupportedOperationException();
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
final ArrayRealVector x = new ArrayRealVector(2);
x.setEntry(0, -b.getEntry(0));
x.setEntry(1, b.getEntry(1));
return x;
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector operate(final RealVector x) {
if (x.getDimension() != n) {
throw new DimensionMismatchException(x.getDimension(),
n);
final double[] y = new double[n];
for (int i = 0; i < n; i++) {
double d = (i + 1) * 1.1 / n;
d = FastMath.abs(d - shiftm);
if (i % 10 == 0) {
d += pertm;
y[i] = d * x.getEntry(i);
return new ArrayRealVector(y, false);
public RealVector solve(final RealVector b) {
if (b.getDimension() != n) {
throw new DimensionMismatchException(b.getDimension(),
final double[] x = new double[n];
x[i] = b.getEntry(i) / d;
return new ArrayRealVector(x, false);
m = null;
final RealVector x = solver.solve(a, m, b, goodb, shift);
Assert.assertTrue("enorm="
+ enorm
+ ", "
+ solver.getIterationManager()
.getIterations(),
enorm <= etol);
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
throw new UnsupportedOperationException();
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
throw new UnsupportedOperationException();
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
public RealVector solve(final RealVector b) {
final ArrayRealVector x = new ArrayRealVector(2);
x.setEntry(0, -b.getEntry(0));
x.setEntry(1, -b.getEntry(1));
return x;
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);
final int npcg = prec.getIterationManager().getIterations();
final int ncg = unprec.getIterationManager().getIterations();
msg = String.format(pattern, npcg, ncg);
Assert.assertTrue(msg, npcg < ncg);
final InvertibleRealLinearOperator m;
m = new InvertibleRealLinearOperator() {
return mMat.operate(x);
public RealVector solve(final RealVector b) {
return mSolver.solve(b);
new SymmLQ(100, 1., true).solve(a, m, b);
final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);private static interface Mapper {
public double unboundedToBounded(double y);
public double boundedToUnbounded(double x);final double[][] control, final double[][] processNoise,
final double[] initialStateEstimate,
final double[][] initialErrorCovariance) {
final double[][] control, final double[][] processNoise) {
final RealMatrix control, final RealMatrix processNoise,
final RealVector initialStateEstimate,
final RealMatrix initialErrorCovariance) {ElitisticListPopulation nextGeneration = new ElitisticListPopulation(this.getPopulationLimit(), this.getElitismRate());public HessenbergTransformer(RealMatrix matrix) {numberOfSuccesses, x + 1);public void testNextHex() {
if (hexString.length() != 1) {
Assert.fail("incorrect length for generated string");
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected, observed) < 37.70);
public void testNextSecureHex() {
if (hexString.length() != 1) {
Assert.fail("incorrect length for generated string");
Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",
testStatistic.chiSquare(expected, observed) < 37.70);ret = innerCumulativeProbability(domain[0], x, 1, populationSize,
numberOfSuccesses, sampleSize);
private double probability(int n, int m, int k, int x) {
return FastMath.exp(ArithmeticUtils.binomialCoefficientLog(m, x) +
ArithmeticUtils.binomialCoefficientLog(n - m, k - x) -
ArithmeticUtils.binomialCoefficientLog(n, k));
if (x < domain[0]) {
ret = innerCumulativeProbability(domain[1], x, -1, populationSize,
numberOfSuccesses, sampleSize);
private double innerCumulativeProbability(int x0, int x1, int dx,
int n, int m, int k) {
double ret = probability(n, m, k, x0);
ret += probability(n, m, k, x0);final int n1n2prod = n1 * n2;
final double EU = (double) n1n2prod / 2.0;
final double VarU = (double) (n1n2prod * (n1 + n2 + 1)) / 12.0;final double n1n2prod = n1 * n2;} else {
checkVectorDimensions(v);
double dot = 0;
Iterator<Entry> it = v.sparseIterator();
while (it.hasNext()) {
final Entry e = it.next();
dot += data[e.getIndex()] * e.getValue();
return dot;
public double dotProduct(OpenMapRealVector v) {
checkVectorDimensions(v.getDimension());
boolean thisIsSmaller  = entries.size() < v.entries.size();
Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();
OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;
double d = 0;
while(iter.hasNext()) {
iter.advance();
d += iter.value() * larger.get(iter.key());
return d;
public double dotProduct(RealVector v) {
if(v instanceof OpenMapRealVector) {
return dotProduct((OpenMapRealVector)v);
} else {
return super.dotProduct(v);
Iterator<Entry> it = sparseIterator();
while (it.hasNext()) {
final Entry e = it.next();
d += e.getValue() * v.getEntry(e.getIndex());RealMatrix product;
product = new OpenMapRealMatrix(this.getDimension(),
v.getDimension());
product = new Array2DRowRealMatrix(this.getDimension(),
v.getDimension());
Iterator<Entry> thisIt = sparseIterator();
while (thisIt.hasNext()) {
final Entry thisE = thisIt.next();
Iterator<Entry> otherIt = v.sparseIterator();
while (otherIt.hasNext()) {
final Entry otherE = otherIt.next();
product.setEntry(thisE.getIndex(), otherE.getIndex(),
thisE.getValue() * otherE.getValue());double result = 1;
double d2p    = d;
result *= d2p;
d2p *= d2p;
return result;
final int maxExp = 300;
final double expected = FastMath.pow(base, (double) i);
Assert.assertEquals("exp=" + i,
expected,
FastMath.pow(base, i),
60 * Math.ulp(expected));private static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();Assert.assertNull("Should not parse <"+source+">", new RealMatrixFormat().parse(source, pos));
Assert.assertNull("Should not parse <"+source+">", new RealMatrixFormat().parse(source, pos));
Assert.assertNull("Should not parse <"+source+">", new RealMatrixFormat().parse(source, pos));return cache[parameters][order];
for (int diag = 0; diag <= maxParameters + maxOrder; ++diag) {
for (int o = FastMath.max(0, diag - maxParameters); o <= FastMath.min(maxOrder, diag); ++o) {public void removeMostRecentValue() {
eDA.discardMostRecentElements(1);
public double replaceMostRecentValue(double v) {
public double getPercentile(double p) throws MathIllegalStateException {
public double evaluate(final double[] values, final double cutoff) {
public double evaluate(final double[] values, final double cutoff, final Direction direction) {
public StandardDeviation(StandardDeviation original) {
public Product(Product original) {
public double evaluate(final double[] values, final int begin, final int length) {
final int begin, final int length) {
public double evaluate(final double[] values, final double[] weights) {
public Sum(Sum original) {
public double evaluate(final double[] values, final int begin, final int length) {
final int begin, final int length) {
public double evaluate(final double[] values, final double[] weights) {
public SumOfLogs(SumOfLogs original) {
public double evaluate(final double[] values, final int begin, final int length) {
public SumOfSquares(SumOfSquares original) {
public double evaluate(final double[] values,final int begin, final int length) {Assert.assertEquals(310, LocalizedFormats.values().length);public static Quaternion product(final Quaternion q1, final Quaternion q2) {
return product(this, q);
return dotProduct(q);
final Quaternion qResult = Quaternion.product(qA, qB);
final Quaternion conjugateOfProduct = Quaternion.product(qB.getConjugate(), qA.getConjugate());
final Quaternion productOfConjugate = (Quaternion.product(qA, qB)).getConjugate();
final Quaternion qResultQxV = Quaternion.product(quaternion, new Quaternion(vector));
final Quaternion qResultVxQ = Quaternion.product(new Quaternion(vector), quaternion);
final double actual = Quaternion.dotProduct(q1, q2);
Assert.assertEquals(expected, actual, EPS);
final Quaternion q = Quaternion.add(q1, q2);
Assert.assertEquals(w, q.getQ0(), EPS);
Assert.assertEquals(x, q.getQ1(), EPS);
Assert.assertEquals(y, q.getQ2(), EPS);
Assert.assertEquals(z, q.getQ3(), EPS);
final Quaternion q = Quaternion.subtract(q1, q2);
Assert.assertEquals(w, q.getQ0(), EPS);
Assert.assertEquals(x, q.getQ1(), EPS);
Assert.assertEquals(y, q.getQ2(), EPS);
Assert.assertEquals(z, q.getQ3(), EPS);
final double normSquareRef = Quaternion.product(q, q.getConjugate()).getScalarPart();
final Quaternion product = Quaternion.product(inverseQ, q);if (chopped.isEmpty()) {if (vertices.length == 0) {
final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();
List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);
for (final Vector2D vertex : vertices) {
list.add(new Vertex(vertex));
insertVertices(hyperplaneThickness, tree, list);
private static void insertVertices(final double hyperplaneThickness,
final BSPTree<Euclidean2D> node,
final List<Vertex> vertices) {
Vertex current = vertices.get(vertices.size() - 1);
Line inserted = null;
while (inserted == null && index < vertices.size()) {
final Vertex previous = current;
current = vertices.get(index++);
if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {
if (previous.shareNodeWith(current)) {
} else {
inserted = new Line(previous.getLocation(), current.getLocation());
if (node.insertCut(inserted)) {
previous.addNode(node);
previous.outgoingProcessed();
current.addNode(node);
current.incomingProcessed();
} else {
inserted = null;
if (node.getCut() == null) {
Side currentSide = Side.HYPER;
final List<Vertex> plusList  = new ArrayList<Vertex>();
plusList.add(current);
int plusCount = 0;
final List<Vertex> minusList = new ArrayList<Vertex>();
minusList.add(current);
int minusCount = 0;
while (index < vertices.size()) {
final Vertex previous = current;
final Side previousSide = currentSide;
current = vertices.get(index++);
final double currentOffset = inserted.getOffset(current.getLocation());
currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ?
Side.HYPER :
((currentOffset < 0) ? Side.MINUS : Side.PLUS);
switch (currentSide) {
case PLUS:
if (previousSide == Side.MINUS) {
final Line line = new Line(previous.getLocation(), current.getLocation());
final Vertex splitPoint = new Vertex(inserted.intersection(line));
splitPoint.addNode(node);
minusList.add(splitPoint);
plusList.add(splitPoint);
plusList.add(current);
if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {
++plusCount;
break;
case MINUS:
if (previousSide == Side.PLUS) {
final Line line = new Line(previous.getLocation(), current.getLocation());
final Vertex splitPoint = new Vertex(inserted.intersection(line));
splitPoint.addNode(node);
minusList.add(splitPoint);
plusList.add(splitPoint);
minusList.add(current);
if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {
++minusCount;
break;
default:
current.addNode(node);
plusList.add(current);
minusList.add(current);
break;
if (plusCount > 0) {
insertVertices(hyperplaneThickness, node.getPlus(),  plusList);
if (minusCount > 0) {
insertVertices(hyperplaneThickness, node.getMinus(), minusList);
private final List<BSPTree<Euclidean2D>> nodes;
private boolean incomingNeedsProcessing;
private boolean outgoingNeedsProcessing;
this.location                = location;
this.nodes                   = new ArrayList<BSPTree<Euclidean2D>>();
this.incomingNeedsProcessing = true;
this.outgoingNeedsProcessing = true;
public boolean shareNodeWith(final Vertex vertex) {
for (final BSPTree<Euclidean2D> node1 : nodes) {
for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {
if (node1 == node2) {
return true;
return false;
public void addNode(final BSPTree<Euclidean2D> node) {
nodes.add(node);
public boolean incomingNeedsProcessing() {
return incomingNeedsProcessing;
public boolean outgoingNeedsProcessing() {
return outgoingNeedsProcessing;
public void incomingProcessed() {
incomingNeedsProcessing = false;
public void outgoingProcessed() {
outgoingNeedsProcessing = false;
public void testIssue880Complete() throws FileNotFoundException {
PolygonsSet set1 = new PolygonsSet(1.0e-10, vertices1);
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0905, 38.3755)));
PolygonsSet set2 = new PolygonsSet(1.0e-10, vertices2);
Vector2D[][] vertices = set.getVertices();
Assert.assertTrue(vertices[0][0] != null);
Assert.assertEquals(2, vertices.length);private ValueServer vs = new ValueServer();for (int i = 1; i < rowsCount; i++) {
if (destination[i].length != columnsCount) {
throw new MatrixDimensionMismatchException(destination.length, destination[i].length,
rowsCount, columnsCount);
final int nCols = selectedColumns.length;
(destination[0].length < nCols)) {
if (destinationI.length != nCols) {
throw new MatrixDimensionMismatchException(destination.length, destinationI.length,
selectedRows.length, selectedColumns.length);
double[][] copy = new double[][] { { 0, 0, 0 }, { 0, 0 } };
checkCopy(m, copy, 0, 1, 0, 2, true);
checkCopy(m, copy, new int[] { 0, 1 }, new int[] { 0, 2 }, true);(destination[0].length < selectedColumns.length)) {int count = (samples / centers) * centers;
g2.drawString(String.format("%.2f s", duration / 1e3), w - 30, h - 5);private double one = 1;
private float two = 2;
private int three = 3;
private double mean = 2;
private double sumSq = 18;
private double sum = 8;
private double var = 0.666666666666666666667;
private double min = 1;
private double max = 3;
private double tolerance = 10E-15;
private double nan = Double.NaN;
double[] values = new double[] { one, two, two, three };
Assert.assertEquals("sum", sum, StatUtils.sum(values), tolerance);
Assert.assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);
Assert.assertEquals("var", var, StatUtils.variance(values), tolerance);
Assert.assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);
Assert.assertEquals("mean", mean, StatUtils.mean(values), tolerance);
Assert.assertEquals("min", min, StatUtils.min(values), tolerance);
Assert.assertEquals("max", max, StatUtils.max(values), tolerance);
values = new double[] { one };
StatUtils.mean(values) == one);
TestUtils.assertEquals(0, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);
TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);
TestUtils.assertEquals(1, StatUtils.product(x), tolerance);
TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.product(x), tolerance);
TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(12, StatUtils.product(x), tolerance);
TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);
TestUtils.assertEquals(0, StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(FastMath.log(one) + 2.0 * FastMath.log(two) + FastMath.log(three), StatUtils.sumLog(x), tolerance);
TestUtils.assertEquals(2.0 * FastMath.log(two), StatUtils.sumLog(x, 1, 2), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.populationVariance(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(0.0, StatUtils.populationVariance(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 0, 2), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 2.5, 2, 2), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(three, StatUtils.max(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(two, StatUtils.max(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);
x = new double[] {nan, two, three};
TestUtils.assertEquals(two, StatUtils.min(x), tolerance);
x = new double[] {one, nan, three};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {one, two, nan};
TestUtils.assertEquals(one, StatUtils.min(x), tolerance);
x = new double[] {nan, nan, nan};
TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);
x = new double[] {two};
TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);
TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);
x = new double[] {one, two, two, three};
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);
TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);
Assert.assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);
Assert.assertEquals(meanDifference, StatUtils.mean(diff), tolerance);
StatUtils.variance(diff), tolerance);private long oneL = 1;
private long twoL = 2;
private long threeL = 3;
private int oneI = 1;
private int twoI = 2;
private int threeI=3;
private double tolerance = 10E-15;
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
Assert.assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);
Assert.assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);
Assert.assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);
Assert.assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);
Assert.assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);
Assert.assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);
Assert.assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);
Assert.assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);
Assert.assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(threeL);
f.addValue(threeL);
f.addValue(threeI);
Assert.assertEquals("one pct",0.25,f.getPct(1),tolerance);
Assert.assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);
Assert.assertEquals("three pct",0.5,f.getPct(threeL),tolerance);
Assert.assertEquals("five pct",0,f.getPct(5),tolerance);
Assert.assertEquals("foo pct",0,f.getPct("foo"),tolerance);
Assert.assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);
Assert.assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);
Assert.assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);
Assert.assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);
Assert.assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);
Assert.assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);
Assert.assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);
Assert.assertEquals("a pct",0.5,f.getPct(aChar),tolerance);
Assert.assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);
Assert.assertEquals("a string pct",0.0,f.getPct(aString),tolerance);
Assert.assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);
Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);
Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
f.addValue(oneL);
f.addValue(oneL);
f.addValue(twoI);
f.incrementValue(oneL, 1);
Assert.assertEquals(1, f.getCount(oneL));
f.incrementValue(oneL, 4);
Assert.assertEquals(5, f.getCount(oneL));
f.incrementValue(oneL, -5);
Assert.assertEquals(0, f.getCount(oneL));
f.addValue(oneL);
f.addValue(twoL);
f.addValue(oneI);
f.addValue(twoI);
Assert.assertEquals(2, f.getCount(oneI));
Assert.assertEquals(2, f.getCount(twoI));
g.addValue(oneL);
g.addValue(threeL);
g.addValue(threeI);
Assert.assertEquals(1, g.getCount(oneI));
Assert.assertEquals(2, g.getCount(threeI));
Assert.assertEquals(3, f.getCount(oneI));
Assert.assertEquals(2, f.getCount(twoI));
Assert.assertEquals(2, f.getCount(threeI));        
f.addValue(oneL);
Assert.assertEquals(1, f.getCount(oneI));
Assert.assertEquals(0, f.getCount(twoI));
g.addValue(twoL);
h.addValue(threeL);
Assert.assertEquals(1, f.getCount(oneI));
Assert.assertEquals(1, f.getCount(twoI));
Assert.assertEquals(1, f.getCount(threeI));        shuffle(index, n - k);
int[] result = new int[k];
for (int i = 0; i < k; i++) {
result[i] = index[n - i - 1];
return result;return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();if (realEigenvalues[i] == 0 &&
imagEigenvalues[i] == 0) {throw new NumberIsTooSmallException(nobs, nvars, false);boolean minusIgnored = false;
boolean plusIgnored  = false;
minusIgnored = addArcStart(minus, a[0], minusIgnored);
minusIgnored = addArcEnd(minus, minusToPlus, minusIgnored);
plusIgnored  = addArcStart(plus, minusToPlus, plusIgnored);
plusIgnored  = addArcEnd(plus, plusToMinus, plusIgnored);
minusIgnored = addArcStart(minus, plusToMinus, minusIgnored);
minusIgnored = addArcEnd(minus, a[1], minusIgnored);
plusIgnored  = addArcEnd(plus, a[1], plusIgnored);
minusIgnored = addArcEnd(minus, a[1], minusIgnored);
plusIgnored  = addArcStart(plus, a[0], plusIgnored);
plusIgnored  = addArcEnd(plus, plusToMinus, plusIgnored);
minusIgnored = addArcStart(minus, plusToMinus, minusIgnored);
minusIgnored = addArcEnd(minus, minusToPlus, minusIgnored);
plusIgnored  = addArcStart(plus, minusToPlus, plusIgnored);
plusIgnored  = addArcEnd(plus, a[1], plusIgnored);
minusIgnored = addArcEnd(minus, a[1], minusIgnored);
plusIgnored  = addArcEnd(plus, a[1], plusIgnored);
return new Split(createSplitPart(plus, plusIgnored), createSplitPart(minus, minusIgnored));
private boolean addArcStart(final BSPTree<Sphere1D> tree, final double alpha, final boolean ignored) {
final BSPTree<Sphere1D> last = getLastLeaf(tree);
if (alpha <= getTolerance()) {
last.setAttribute(Boolean.TRUE);
return true;
} else {
last.insertCut(new LimitAngle(new S1Point(alpha), false, getTolerance()));
last.setAttribute(null);
last.getPlus().setAttribute(Boolean.FALSE);
last.getMinus().setAttribute(Boolean.TRUE);
return ignored;
private boolean addArcEnd(final BSPTree<Sphere1D> tree, final double alpha, final boolean ignored) {
final BSPTree<Sphere1D> last = getLastLeaf(tree);
if (alpha >= MathUtils.TWO_PI - getTolerance()) {
last.setAttribute(Boolean.TRUE);
return true;
last.insertCut(new LimitAngle(new S1Point(alpha), true, getTolerance()));
last.setAttribute(null);
last.getPlus().setAttribute(Boolean.FALSE);
last.getMinus().setAttribute(Boolean.TRUE);
return ignored;
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree, final boolean ignored) {
if (ignored) {
final BSPTree<Sphere1D> first = getFirstLeaf(tree);
final boolean firstState      = (Boolean) first.getAttribute();
final BSPTree<Sphere1D> last  = getLastLeaf(tree);
final boolean lastState       = (Boolean) last.getAttribute();
if (firstState ^ lastState) {
first.insertCut(new LimitAngle(new S1Point(0.0), true, getTolerance()));
first.getPlus().setAttribute(firstState);
first.getMinus().setAttribute(lastState);
for (double alpha = 0; alpha <= MathUtils.TWO_PI; alpha += 0.01) {
ArcsSet split1Plus  = (ArcsSet) split1.getPlus();
ArcsSet split1Minus = (ArcsSet) split1.getMinus();
ArcsSet split2Plus  = (ArcsSet) split2.getPlus();
ArcsSet split2Minus = (ArcsSet) split2.getMinus();
ArcsSet split3Plus  = (ArcsSet) split3.getPlus();
ArcsSet split3Minus = (ArcsSet) split3.getMinus();
ArcsSet split4Plus  = (ArcsSet) split4.getPlus();
ArcsSet split4Minus = (ArcsSet) split4.getMinus();
ArcsSet split1Plus  = (ArcsSet) split1.getPlus();
ArcsSet split1Minus = (ArcsSet) split1.getMinus();
ArcsSet split2Plus  = (ArcsSet) split2.getPlus();
ArcsSet split2Minus = (ArcsSet) split2.getMinus();
ArcsSet split3Plus  = (ArcsSet) split3.getPlus();
ArcsSet split3Minus = (ArcsSet) split3.getMinus();
ArcsSet split4Plus  = (ArcsSet) split4.getPlus();
ArcsSet split4Minus = (ArcsSet) split4.getMinus();if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {
if (syncedEnd > arcLength) {
final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();
minus.setAttribute(Boolean.FALSE);
final BSPTree<Sphere1D> plus  = new BSPTree<Sphere1D>();
plus.setAttribute(Boolean.FALSE);
addArcLimit(minus, a[0], true);
addArcLimit(minus, minusToPlus, false);
addArcLimit(plus, minusToPlus, true);
addArcLimit(plus, plusToMinus, false);
addArcLimit(minus, plusToMinus, true);
addArcLimit(minus, a[1], false);
addArcLimit(plus, a[1], false);
addArcLimit(minus, a[1], false);
addArcLimit(plus, a[0], true);
addArcLimit(plus, plusToMinus, false);
addArcLimit(minus, plusToMinus, true);
addArcLimit(minus, minusToPlus, false);
addArcLimit(plus, minusToPlus, true);
addArcLimit(plus, a[1], false);
addArcLimit(minus, a[1], false);
addArcLimit(plus, a[1], false);
leafBefore(node).setAttribute(Boolean.valueOf(!isStart));
} else {
node.insertCut(limit);
node.setAttribute(null);
node.getPlus().setAttribute(Boolean.FALSE);
node.getMinus().setAttribute(Boolean.TRUE);
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {
if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {public class WelzlEncloserTest {
BallGenerator generator = new BallGenerator();
BallGenerator generator = new BallGenerator();
checkBall(list, Arrays.asList(list.get(2), list.get(3), list.get(4)));
checkBall(list, Arrays.asList(list.get(2), list.get(3)));
checkBall(points);
private void checkBall(List<Vector2D> points, List<Vector2D> refSupport) {
EnclosingBall<Euclidean2D, Vector2D> ball = checkBall(points);
BallGenerator generator = new BallGenerator();
Assert.assertEquals(refSupport.size(), ball.getSupportSize());
Assert.assertEquals(expected.getRadius(),        ball.getRadius(),        1.0e-10);
Assert.assertEquals(expected.getCenter().getX(), ball.getCenter().getX(), 1.0e-10);
Assert.assertEquals(expected.getCenter().getY(), ball.getCenter().getY(), 1.0e-10);
for (Vector2D s : ball.getSupport()) {
for (int i = 0; i < ball.getSupportSize(); ++i) {
for (Vector2D s : ball.getSupport()) {
EnclosingBall<Euclidean2D, Vector2D> reducedBall = generator.ballOnSupport(reducedSupport);
if (!reducedBall.contains(points.get(j), 1.0e-10)) {
private EnclosingBall<Euclidean2D, Vector2D> checkBall(List<Vector2D> points) {
new WelzlEncloser<Euclidean2D, Vector2D>(1.0e-10, 2, new BallGenerator());
EnclosingBall<Euclidean2D, Vector2D> ball = encloser.enclose(points);
Assert.assertTrue(ball.contains(v, 1.0e-10));
for (Vector2D s : ball.getSupport()) {
Assert.assertFalse(ball.contains(v, -0.001));
return ball;EnclosingBall<S, P> enclose(List<P> points);
public EnclosingBall<S, P> enclose(final List<P> points) {
if (points == null || points.isEmpty()) {
private EnclosingBall<S, P> pivotingBall(final List<P> points) {
extreme.add(points.get(0));
EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);
ball = moveToFrontBall(extreme, support);
private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {
for (int i = 0; i < extreme.size(); ++i) {
ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);
for (int j = i; j > 1; --j) {
public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {
public void testReducingBall() {final double last = getLocation(point, p1, p2);
if (last * getLocation(point, p1, p2) < 0) {
private static double getLocation(final Vector2D point,
final Vector2D linePoint1,
final Vector2D linePoint2) {
return (linePoint2.getX() - linePoint1.getX()) * (point.getY() - linePoint1.getY()) -
(point.getX() - linePoint1.getX()) * (linePoint2.getY() - linePoint1.getY());
private final Line[] lineSegments;
this.lineSegments = new Line[0];
this.lineSegments = new Line[1];
this.lineSegments[0] = new Line(it.next(), it.next(), tolerance);
this.lineSegments = new Line[size];
this.lineSegments[index++] = new Line(lastPoint, point, tolerance);
this.lineSegments[index] = new Line(lastPoint, firstPoint, tolerance);
public Line[] getLineSegments() {
return factory.buildConvex(lineSegments);
if (getLocation(p, p1, p2) <= 0) {
if (getLocation(p, p1, p2) <= 0) {
private double getLocation(final Vector2D point,
final Vector2D linePoint1,
final Vector2D linePoint2) {
return (linePoint2.getX() - linePoint1.getX()) * (point.getY() - linePoint1.getY()) -
(point.getX() - linePoint1.getX()) * (linePoint2.getY() - linePoint1.getY());new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);
Assert.assertArrayEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapInv,v_mapInv.getData());
Assert.assertArrayEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());
Assert.assertArrayEquals("compare vect" ,v_add.getData(),result_add);
Assert.assertArrayEquals("compare vect" ,v_add_i.getData(),result_add_i);
assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);
assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);
assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);
assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);
assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);
assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);= new MultiStartMultivariateOptimizer(underlying, 10, generator);
= optimizer.optimize(new MaxEval(200),
Assert.assertEquals(200, optimizer.getMaxEvaluations());
Assert.assertEquals(69.9601, circle.getRadius(center), 1e-4);
Assert.assertEquals(96.075, center.getX(), 1e-3);
Assert.assertEquals(48.13516, center.getY(), 1e-5);
Assert.assertTrue(optimizer.getEvaluations() > 590);
Assert.assertTrue(optimizer.getEvaluations() < 610);
= new MultiStartMultivariateOptimizer(underlying, 10, generator);
Assert.assertTrue(optimum.getValue() < 8e-4);for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {ConvexHullGenerator2D generator = new MonotoneChain(true, 1e-6);doDistributionTest(new NormalDistribution(4000, 50));
doDistributionTest(new LogNormalDistribution(4000, 50));stepSize  = forward ? step : -step;qr = new QRDecomposition(getX());System.out.println("Computing FastMath.exp(x=" + x + ")");
System.out.println("intval="+intVal);public double getQuadraticMean() {
final long n = getN();
return n > 0 ? FastMath.sqrt(getSumsq() / n) : Double.NaN;
public double getQuadraticMean() {
final long n = getN();
return n > 0 ? FastMath.sqrt(getSumsq() / n) : Double.NaN;
public synchronized double getQuadraticMean() {
return super.getQuadraticMean();
public synchronized double getQuadraticMean() {
return super.getQuadraticMean();
int intVal;
intVal = (int) -x;
if (intVal > 746 || x < Integer.MIN_VALUE) {
if (intVal > 709) {
if (intVal == 709) {
intVal++;
intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];
intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];
intVal = -intVal;
intVal = (int) x;
intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];
intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];
public void testQuadraticMean() {
final double[] values = { 1.2, 3.4, 5.6, 7.89 };
final DescriptiveStatistics stats = new DescriptiveStatistics(values);
final int len = values.length;
double expected = 0;
for (int i = 0; i < len; i++) {
final double v = values[i];
expected += v * v / len;
expected = Math.sqrt(expected);
Assert.assertEquals(expected, stats.getQuadraticMean(), Math.ulp(expected));
public void testQuadraticMean() {
final double[] values = { 1.2, 3.4, 5.6, 7.89 };
final SummaryStatistics stats = createSummaryStatistics();
final int len = values.length;
double expected = 0;
for (int i = 0; i < len; i++) {
final double v = values[i];
expected += v * v / len;
stats.addValue(v);
expected = Math.sqrt(expected);
Assert.assertEquals(expected, stats.getQuadraticMean(), Math.ulp(expected));return pBminus + pB;
Assert.assertEquals(1.0, dist.cumulativeProbability(0.7), Double.MIN_VALUE);
Assert.assertEquals(0.2, dist.cumulativeProbability(1), tol);
Assert.assertEquals(0.8, dist.cumulativeProbability(10), tol);
Assert.assertEquals(1.0, dist.cumulativeProbability(13), tol);if (y > 0) {
return Double.NaN;
if (y != y) { // y is NaN
return y;
if (x * x == 1.0) {
return Double.NaN;
if (x * x > 1.0) {
return 0.0;
if (y != y) { // y is NaN
return y;public static double cosAngle(double[] v1, double[] v2) {
return linearCombination(v1, v2) / (safeNorm(v1) * safeNorm(v2));
public void testCosAngle2D() {
double expected;
final double[] v1 = { 1, 0 };
expected = 1;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v1), 0d);
final double[] v2 = { 0, 1 };
expected = 0;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v2), 0d);
final double[] v3 = { 7, 7 };
expected = Math.sqrt(2) / 2;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v3), 1e-15);
Assert.assertEquals(expected, MathArrays.cosAngle(v3, v2), 1e-15);
final double[] v4 = { -5, 0 };
expected = -1;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v4), 0);
final double[] v5 = { -100, 100 };
expected = 0;
Assert.assertEquals(expected, MathArrays.cosAngle(v3, v5), 0);
public void testCosAngle3D() {
double expected;
final double[] v1 = { 1, 1, 0 };
expected = 1;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v1), 1e-15);
final double[] v2 = { 1, 1, 1 };
expected = Math.sqrt(2) / Math.sqrt(3);
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v2), 1e-15);
public void testCosAngleExtreme() {
double expected;
final double tiny = 1e-200;
final double[] v1 = { tiny, tiny };
final double big = 1e200;
final double[] v2 = { -big, -big };
expected = -1;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v2), 1e-15);
final double[] v3 = { big, -big };
expected = 0;
Assert.assertEquals(expected, MathArrays.cosAngle(v1, v3), 1e-15);Arrays.fill(b, true);
for (int k = nn; k < sum; k++) {
int r = rng.nextInt(k);
b[(b[r]) ? r : k] = false;if (data != null && data.length > 1) {new GaussianRandomGenerator(new JDKRandomGenerator()));62 bits of precision when combined with the contant 1.  This will beif (hasTies(x, y)) {
return exactP(x, y, strict);
public double exactP(double[] x, double[] y, boolean strict) {
final long d = integralKolmogorovSmirnovStatistic(x, y);
final int n = x.length;
final int m = y.length;
final double[] universe = new double[n + m];
System.arraycopy(x, 0, universe, 0, n);
System.arraycopy(y, 0, universe, n, m);
Iterator<int[]> combinationsIterator = CombinatoricsUtils.combinationsIterator(n + m, n);
long tail = 0;
final double[] nSet = new double[n];
final double[] mSet = new double[m];
while (combinationsIterator.hasNext()) {
final int[] nSetI = combinationsIterator.next();
int j = 0;
int k = 0;
for (int i = 0; i < n + m; i++) {
if (j < n && nSetI[j] == i) {
nSet[j++] = universe[i];
} else {
mSet[k++] = universe[i];
final long curD = integralKolmogorovSmirnovStatistic(nSet, mSet);
if (curD > d || (curD == d && !strict)) {
tail++;
return (double) tail / (double) CombinatoricsUtils.binomialCoefficient(n + m, n);
public void testExactPConsistency() {
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
final double[] x = {
1, 7, 9, 13, 19, 21, 22, 23, 24
};
final double[] y = {
3, 4, 12, 16, 20, 27, 28, 32, 44, 54
};
Assert.assertEquals(test.exactP(x, y, true),
test.exactP(test.kolmogorovSmirnovStatistic(x, y),
x.length, y.length, true), Double.MIN_VALUE);
Assert.assertEquals(test.exactP(x, y, false),
test.exactP(test.kolmogorovSmirnovStatistic(x, y),
x.length, y.length, false), Double.MIN_VALUE);
public void testExactPNoVariance() {
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
final double[] x = {
1, 1, 1, 1, 1, 1
};
final double[] y = {
1, 1, 1, 1
};
Assert.assertEquals(0, test.exactP(x, y, true), Double.MIN_VALUE);
Assert.assertEquals(1, test.exactP(x, y, false), Double.MIN_VALUE);
Assert.assertEquals(0, test.kolmogorovSmirnovTest(x, y, true), Double.MIN_VALUE);
Assert.assertEquals(1, test.kolmogorovSmirnovTest(x, y, false), Double.MIN_VALUE);
public void testExactPSimpleSplit() {
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();
final double[] x = {
0, 0, 0
};
final double[] y = {
1, 1, 1
};
Assert.assertEquals(0, test.exactP(x, y, true), Double.MIN_VALUE);
Assert.assertEquals(2 / (double) CombinatoricsUtils.binomialCoefficient(6, 3),
test.exactP(x, y, false), Double.MIN_VALUE);OutOfRangeException, IllegalArgumentException;final T two     = getField().getOne().multiply(2);
final T two     = getField().getOne().multiply(2);
b[1] = two.subtract(sqrtTwo).divide(6);
b[2] = two.add(sqrtTwo).divide(6);
private static final double ONE_MINUS_INV_SQRT_2 = 1 - FastMath.sqrt(0.5);
private static final double ONE_PLUS_INV_SQRT_2 = 1 + FastMath.sqrt(0.5);
final T coeffDot2  = cDot23.multiply(ONE_MINUS_INV_SQRT_2);
final T coeffDot3  = cDot23.multiply(ONE_PLUS_INV_SQRT_2);
final T coeff1          = s.multiply(fourTheta2.subtract(theta.multiply(6)).add(6));
final T coeff2          = c23.multiply(ONE_MINUS_INV_SQRT_2);
final T coeff3          = c23.multiply(ONE_PLUS_INV_SQRT_2);
final T coeff2 = c23.multiply(ONE_MINUS_INV_SQRT_2);
final T coeff3 = c23.multiply(ONE_PLUS_INV_SQRT_2);
interpolatedState       = previousStateLinearCombination(coeff1, coeff2, coeff3, coeff4);final Complex c[] = ComplexUtils.convertToComplex(getCoefficients());
return complexSolver.solveAll(ComplexUtils.convertToComplex(coefficients),
return complexSolver.solve(ComplexUtils.convertToComplex(coefficients),
throw new MathIllegalArgumentException(
LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);
public static Complex[] convertToComplex(double[] real) {
for (int i = 0; i < real.length; i++) {
c[i] = new Complex(real[i], 0);
private static final long serialVersionUID = 20160318L;
public static int[] sample(int n,
IntegerDistribution.Sampler sampler) {
final int[] samples = new int[n];
for (int i = 0; i < n; i++) {
samples[i] = sampler.sample();
return samples;
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
public int sample() {
return inverseCumulativeProbability(rng.nextDouble());
};
implements RealDistribution, Serializable {
private static final long serialVersionUID = 20160311L;
public static double[] sample(int n,
RealDistribution.Sampler sampler) {
final double[] samples = new double[n];
for (int i = 0; i < n; i++) {
samples[i] = sampler.sample();
return samples;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
return inverseCumulativeProbability(rng.nextDouble());
};
private static final long serialVersionUID = 20160311L;
private final double z;
public BetaDistribution(double alpha,
z = Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta);
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new ChengBetaSampler(rng, alpha, beta);
private static class ChengBetaSampler implements RealDistribution.Sampler {
private final UniformRandomProvider rng;
private final double alphaShape;
private final double betaShape;
ChengBetaSampler(UniformRandomProvider generator,
double alpha,
double beta) {
rng = generator;
alphaShape = alpha;
betaShape = beta;
public double sample() {
final double a = FastMath.min(alphaShape, betaShape);
final double b = FastMath.max(alphaShape, betaShape);
return algorithmBB(alphaShape, a, b);
return algorithmBC(alphaShape, b, a);
private double algorithmBB(double a0,
double a,
double b) {
final double beta = FastMath.sqrt((alpha - 2) / (2 * a * b - alpha));
final double gamma = a + 1 / beta;
final double u1 = rng.nextDouble();
final double u2 = rng.nextDouble();
private double algorithmBC(double a0,
double a,
double b) {
final double beta = 1 / b;
final double delta = 1 + a - b;
while (true) {
final double u1 = rng.nextDouble();
final double u2 = rng.nextDouble();
public BinomialDistribution(int trials,
private static final long serialVersionUID = 20160311L;
public CauchyDistribution(double median,
double scale) {
this(median, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public CauchyDistribution(double median,
private static final long serialVersionUID = 20160311L;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
return value;
};
private static final long serialVersionUID = 20160319L;
public EnumeratedDistribution(final List<Pair<T, Double>> pmf)
throws NotPositiveException,
MathArithmeticException,
NotFiniteNumberException,
NotANumberException {
public Sampler createSampler(final UniformRandomProvider rng) {
return new Sampler(rng);
public class Sampler {
private final UniformRandomProvider random;
Sampler(UniformRandomProvider rng) {
random = rng;
public T sample() {
final double randomValue = random.nextDouble();
int index = Arrays.binarySearch(cumulativeProbabilities, randomValue);
if (index < 0) {
index = -index - 1;
if (index >= 0 &&
index < probabilities.length &&
randomValue < cumulativeProbabilities[index]) {
return singletons.get(index);
return singletons.get(singletons.size() - 1);
public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
if (sampleSize <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
sampleSize);
final Object[] out = new Object[sampleSize];
for (int i = 0; i < sampleSize; i++) {
out[i] = sample();
return out;
public T[] sample(int sampleSize, final T[] array) throws NotStrictlyPositiveException {
if (sampleSize <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);
if (array == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
T[] out;
if (array.length < sampleSize) {
final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), sampleSize);
out = unchecked;
} else {
out = array;
for (int i = 0; i < sampleSize; i++) {
out[i] = sample();
return out;
public EnumeratedIntegerDistribution(final int[] singletons,
final double[] probabilities)
throws DimensionMismatchException,
NotPositiveException,
MathArithmeticException,
NotFiniteNumberException,
NotANumberException {
innerDistribution = new EnumeratedDistribution<Integer>(createDistribution(singletons,
probabilities));
public EnumeratedIntegerDistribution(final int[] data) {
innerDistribution = new EnumeratedDistribution<Integer>(createDistribution(values, probabilities));
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final EnumeratedDistribution<Integer>.Sampler inner =
innerDistribution.createSampler(rng);
public int sample() {
return inner.sample();
};
private static final long serialVersionUID = 20160311L;
public EnumeratedRealDistribution(final double[] singletons,
final double[] probabilities)
throws DimensionMismatchException,
NotPositiveException,
MathArithmeticException,
NotFiniteNumberException,
NotANumberException {
innerDistribution = new EnumeratedDistribution<Double>(createDistribution(singletons, probabilities));
public EnumeratedRealDistribution(final double[] data) {
innerDistribution = new EnumeratedDistribution<Double>(createDistribution(values, probabilities));
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final EnumeratedDistribution<Double>.Sampler inner =
innerDistribution.createSampler(rng);
public double sample() {
return inner.sample();
};
private static final long serialVersionUID = 20160311L;
public ExponentialDistribution(double mean,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
double a = 0;
double u = rng.nextDouble();
while (u < 0.5) {
a += EXPONENTIAL_SA_QI[0];
u *= 2;
u += u - 1;
if (u <= EXPONENTIAL_SA_QI[0]) {
return mean * (a + u);
int i = 0; // Should be 1, be we iterate before it in while using 0
double u2 = rng.nextDouble();
double umin = u2;
do {
++i;
u2 = rng.nextDouble();
if (u2 < umin) {
umin = u2;
} while (u > EXPONENTIAL_SA_QI[i]); // Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1
return mean * (a + umin * EXPONENTIAL_SA_QI[0]);
};
public FDistribution(double numeratorDegreesOfFreedom,
private static final long serialVersionUID = 20160311L;
public GammaDistribution(double shape, double scale)
this(shape, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public GammaDistribution(double shape,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final RealDistribution.Sampler gaussian = new NormalDistribution().createSampler(rng);
public double sample() {
if (shape < 1) {
while (true) {
final double u = rng.nextDouble();
final double bGS = 1 + shape / FastMath.E;
final double p = bGS * u;
if (p <= 1) {
final double x = FastMath.pow(p, 1 / shape);
final double u2 = rng.nextDouble();
if (u2 > FastMath.exp(-x)) {
continue;
} else {
return scale * x;
} else {
final double x = -1 * FastMath.log((bGS - p) / shape);
final double u2 = rng.nextDouble();
if (u2 > FastMath.pow(x, shape - 1)) {
continue;
} else {
return scale * x;
final double d = shape - 0.333333333333333333;
final double c = 1 / (3 * FastMath.sqrt(d));
while (true) {
final double x = gaussian.sample();
final double v = (1 + c * x) * (1 + c * x) * (1 + c * x);
if (v <= 0) {
final double x2 = x * x;
final double u = rng.nextDouble();
if (u < 1 - 0.0331 * x2 * x2) {
return scale * d * v;
if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) {
return scale * d * v;
};
private static final long serialVersionUID = 20160318L;
public GeometricDistribution(double p) {
private static final long serialVersionUID = 20160311L;
private static final long serialVersionUID = 20160318L;
public HypergeometricDistribution(int populationSize,
throws NotPositiveException,
NotStrictlyPositiveException,
NumberIsTooLargeException {
Sampler createSampler(UniformRandomProvider rng);
interface Sampler {
int sample();
private static final long serialVersionUID = 20160311L;
private static final long serialVersionUID = 20630311L;
public LevyDistribution(final double mu, final double c) {
this.mu = mu;
this.c = c;
public LogNormalDistribution(double scale, double shape)
this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public LogNormalDistribution(double scale,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final RealDistribution.Sampler gaussian = new NormalDistribution().createSampler(rng);
public double sample() {
final double n = gaussian.sample();
return FastMath.exp(scale + shape * n);
};
private static final long serialVersionUID = 20160311L;
public LogisticDistribution(double mu,
double s) {
private static final long serialVersionUID = 20160311L;
public NakagamiDistribution(double mu,
double omega) {
public NakagamiDistribution(double mu,
double omega,
double inverseAbsoluteAccuracy) {
public NormalDistribution(double mean,
double sd)
public NormalDistribution(double mean,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private double nextGaussian = Double.NaN;
public double sample() {
final double random;
if (Double.isNaN(nextGaussian)) {
final double x = rng.nextDouble();
final double y = rng.nextDouble();
final double alpha = 2 * FastMath.PI * x;
final double r = FastMath.sqrt(-2 * FastMath.log(y));
random = r * FastMath.cos(alpha);
nextGaussian = r * FastMath.sin(alpha);
} else {
random = nextGaussian;
nextGaussian = Double.NaN;
return standardDeviation * random + mean;
};
private static final long serialVersionUID = 20160311L;
public ParetoDistribution(double scale,
double shape)
public ParetoDistribution(double scale,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
final double n = rng.nextDouble();
return scale / FastMath.pow(n, 1 / shape);
};
public PascalDistribution(int r,
throws NotStrictlyPositiveException,
OutOfRangeException {
public PoissonDistribution(double p)
throws NotStrictlyPositiveException {
public PoissonDistribution(double p,
throws NotStrictlyPositiveException {
normal = new NormalDistribution(p, FastMath.sqrt(p),
throws NotStrictlyPositiveException {
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final RealDistribution.Sampler exponentialSampler
= new ExponentialDistribution(1).createSampler(rng);
private final RealDistribution.Sampler gaussianSampler
= new NormalDistribution().createSampler(rng);
public int sample() {
return (int) FastMath.min(nextPoisson(mean),
Integer.MAX_VALUE);
private long nextPoisson(double meanPoisson) {
final double pivot = 40.0d;
if (meanPoisson < pivot) {
double p = FastMath.exp(-meanPoisson);
long n = 0;
double r = 1.0d;
double rnd = 1.0d;
while (n < 1000 * meanPoisson) {
rnd = rng.nextDouble();
r *= rnd;
if (r >= p) {
n++;
} else {
return n;
return n;
final double lambda = FastMath.floor(meanPoisson);
final double lambdaFractional = meanPoisson - lambda;
final double logLambda = FastMath.log(lambda);
final double logLambdaFactorial = CombinatoricsUtils.factorialLog((int) lambda);
final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));
final double halfDelta = delta / 2;
final double twolpd = 2 * lambda + delta;
final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / (8 * lambda));
final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd);
final double aSum = a1 + a2 + 1;
final double p1 = a1 / aSum;
final double p2 = a2 / aSum;
final double c1 = 1 / (8 * lambda);
double x = 0;
double y = 0;
double v = 0;
int a = 0;
double t = 0;
double qr = 0;
double qa = 0;
while (true) {
final double u = rng.nextDouble();
if (u <= p1) {
final double n = gaussianSampler.sample();
x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d;
if (x > delta || x < -lambda) {
continue;
y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x);
final double e = exponentialSampler.sample();
v = -e - (n * n / 2) + c1;
} else {
if (u > p1 + p2) {
y = lambda;
break;
} else {
x = delta + (twolpd / delta) * exponentialSampler.sample();
y = FastMath.ceil(x);
v = -exponentialSampler.sample() - delta * (x + 1) / twolpd;
a = x < 0 ? 1 : 0;
t = y * (y + 1) / (2 * lambda);
if (v < -t && a == 0) {
y = lambda + y;
break;
qr = t * ((2 * y + 1) / (6 * lambda) - 1);
qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
if (v < qa) {
y = lambda + y;
break;
if (v > qr) {
continue;
if (v < y * logLambda - CombinatoricsUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
y = lambda + y;
break;
return y2 + (long) y;
};
Sampler createSampler(UniformRandomProvider rng);
interface Sampler {
double sample();
private static final long serialVersionUID = 20160311L;
public TDistribution(double degreesOfFreedom,
private static final long serialVersionUID = 20160311L;
public TriangularDistribution(double a,
throws NumberIsTooLargeException,
NumberIsTooSmallException {
private static final long serialVersionUID = 20160308L;
public UniformIntegerDistribution(int lower,
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
public int sample() {
final int max = (upper - lower) + 1;
if (max <= 0) {
while (true) {
final int r = rng.nextInt();
if (r >= lower &&
r <= upper) {
return r;
} else {
return lower + rng.nextInt(max);
};
private static final long serialVersionUID = 20160311L;
public UniformRealDistribution(double lower,
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
final double u = rng.nextDouble();
return u * upper + (1 - u) * lower;
};
private static final long serialVersionUID = 20160311L;
public WeibullDistribution(double alpha,
public ZipfDistribution(int numberOfElements,
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final ZipfRejectionInversionSampler sampler =
new ZipfRejectionInversionSampler(numberOfElements, exponent);
public int sample() {
return sampler.sample(rng);
};
int sample(final UniformRandomProvider random) {
public static FeatureInitializer uniform(final UniformRandomProvider rng,
return randomize(new UniformRealDistribution(min, max).createSampler(rng),
return uniform(RandomSource.create(RandomSource.WELL_19937_C), min, max);
public static FeatureInitializer randomize(final RealDistribution.Sampler random,
boolean needReset = false;
for (final EventState state : eventsStates) {
needReset =  needReset || state.reset(eventT, eventYComplete);
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
if (!loaded) {
throw new MathIllegalStateException(LocalizedFormats.DISTRIBUTION_NOT_LOADED);
return super.createSampler(rng);
return new NormalDistribution(bStats.getMean(), bStats.getStandardDeviation(),
NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
private RandomGenerator rand;
rand = new Well19937c();
return new UniformIntegerDistribution(lower, upper).createSampler(getRandomProvider()).sample();
return new UniformIntegerDistribution(lower, upper).createSampler(getSecureRandomProvider()).sample();
return new PoissonDistribution(mean,
PoissonDistribution.DEFAULT_MAX_ITERATIONS).createSampler(getRandomProvider()).sample();
return new ExponentialDistribution(mean, ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new GammaDistribution(shape, scale, GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new HypergeometricDistribution(populationSize, numberOfSuccesses, sampleSize).createSampler(getRandomProvider()).sample();
return new PascalDistribution(r, p).createSampler(getRandomProvider()).sample();
return new TDistribution(df, TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new WeibullDistribution(shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new ZipfDistribution(numberOfElements, exponent).createSampler(getRandomProvider()).sample();
return new BetaDistribution(alpha, beta, BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new BinomialDistribution(numberOfTrials, probabilityOfSuccess).createSampler(getRandomProvider()).sample();
return new CauchyDistribution(median, scale, CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new ChiSquaredDistribution(df, ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
return new FDistribution(numeratorDf, denominatorDf, FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).createSampler(getRandomProvider()).sample();
MathArrays.shuffle(index, getRandomProvider());
getRandomGenerator().setSeed(seed);
reSeed(System.currentTimeMillis() + System.identityHashCode(this));
private UniformRandomProvider wrapRandomGenerator(final RandomGenerator rng) {
return new UniformRandomProvider() {
public void nextBytes(byte[] bytes) {
rng.nextBytes(bytes);
public void nextBytes(byte[] bytes,
int start,
int len) {
throw new MathInternalError();
public int nextInt() {
return rng.nextInt();
public int nextInt(int n) {
return rng.nextInt(n);
public long nextLong() {
return rng.nextLong();
public long nextLong(long n) {
throw new MathInternalError();
public boolean nextBoolean() {
return rng.nextBoolean();
public float nextFloat() {
return rng.nextFloat();
public double nextDouble() {
return rng.nextDouble();
};
private UniformRandomProvider getSecureRandomProvider() {
return wrapRandomGenerator(getSecRan());
UniformRandomProvider getRandomProvider() {
return wrapRandomGenerator(getRandomGenerator());
empiricalDistribution = new EmpiricalDistribution(binCount);
return empiricalDistribution.createSampler(randomData.getRandomProvider()).sample();
package org.apache.commons.math4.rng;
public enum RandomSource {
JDK(ProviderBuilder.RandomSourceInternal.JDK),
WELL_512_A(ProviderBuilder.RandomSourceInternal.WELL_512_A),
WELL_1024_A(ProviderBuilder.RandomSourceInternal.WELL_1024_A),
WELL_19937_A(ProviderBuilder.RandomSourceInternal.WELL_19937_A),
WELL_19937_C(ProviderBuilder.RandomSourceInternal.WELL_19937_C),
WELL_44497_A(ProviderBuilder.RandomSourceInternal.WELL_44497_A),
WELL_44497_B(ProviderBuilder.RandomSourceInternal.WELL_44497_B),
MT(ProviderBuilder.RandomSourceInternal.MT),
ISAAC(ProviderBuilder.RandomSourceInternal.ISAAC),
SPLIT_MIX_64(ProviderBuilder.RandomSourceInternal.SPLIT_MIX_64),
XOR_SHIFT_1024_S(ProviderBuilder.RandomSourceInternal.XOR_SHIFT_1024_S),
TWO_CMRES(ProviderBuilder.RandomSourceInternal.TWO_CMRES),
TWO_CMRES_SELECT(ProviderBuilder.RandomSourceInternal.TWO_CMRES_SELECT),
MT_64(ProviderBuilder.RandomSourceInternal.MT_64);
private final ProviderBuilder.RandomSourceInternal internalIdentifier;
RandomSource(ProviderBuilder.RandomSourceInternal id) {
internalIdentifier = id;
ProviderBuilder.RandomSourceInternal getInternalIdentifier() {
return internalIdentifier;
public boolean isNativeSeed(Object seed) {
return internalIdentifier.isNativeSeed(seed);
public interface State {}
public static UniformRandomProvider create(RandomSource source) {
return create(source, null);
public static UniformRandomProvider create(RandomSource source,
Object seed,
Object ... data) {
return ProviderBuilder.create(source.getInternalIdentifier(), seed, data);
public static int numberOfCmresGenerators() {
return TwoCmres.numberOfSubcycleGenerators();
public static State saveState(UniformRandomProvider provider) {
if (!(provider instanceof BaseProvider)) {
throw new MathUnsupportedOperationException();
} else {
return ((BaseProvider) provider).getState();
public static void restoreState(UniformRandomProvider provider,
State state) {
if (!(provider instanceof BaseProvider)) {
throw new MathUnsupportedOperationException();
} else {
((BaseProvider) provider).setState(state);
public static int createInt() {
return SeedFactory.createInt();
public static long createLong() {
return SeedFactory.createLong();
public static int[] createIntArray(int n) {
return SeedFactory.createIntArray(n);
public static long[] createLongArray(int n) {
return SeedFactory.createLongArray(n);
package org.apache.commons.math4.rng;
public interface UniformRandomProvider {
void nextBytes(byte[] bytes);
void nextBytes(byte[] bytes,
int start,
int len);
int nextInt();
int nextInt(int n);
long nextLong();
long nextLong(long n);
boolean nextBoolean();
float nextFloat();
double nextDouble();
package org.apache.commons.math4.rng.internal;
public abstract class BaseProvider
implements UniformRandomProvider,
StateSettable {
public int nextInt(int n) throws IllegalArgumentException {
if (n > 0) {
if ((n & -n) == n) {
return (int) ((n * (long) (nextInt() >>> 1)) >> 31);
int bits;
int val;
do {
bits = nextInt() >>> 1;
val = bits % n;
} while (bits - val + (n - 1) < 0);
return val;
throw new NotStrictlyPositiveException(n);
public long nextLong(long n) {
if (n > 0) {
long bits;
long val;
do {
bits = nextLong() >>> 1;
val  = bits % n;
} while (bits - val + (n - 1) < 0);
return val;
throw new NotStrictlyPositiveException(n);
public String toString() {
return getClass().getName();
public RandomSource.State getState() {
return new State(getStateInternal());
public void setState(RandomSource.State state) {
final State s = (State) state;
setStateInternal(s.getState());
protected byte[] getStateInternal() {
throw new MathUnsupportedOperationException();
protected void setStateInternal(byte[] state) {
throw new MathUnsupportedOperationException();
private static class State
implements RandomSource.State,
Serializable {
private static final long serialVersionUID = 4720160226L;
private byte[] state;
State(byte[] state) {
this.state = Arrays.copyOf(state, state.length);
byte[] getState() {
return Arrays.copyOf(state, state.length);
package org.apache.commons.math4.rng.internal;
public class ProviderBuilder {
private static final int RANDOM_SEED_ARRAY_SIZE = 128;
private static final Long2Int LONG_TO_INT = new Long2Int();
private static final Int2Long INT_TO_LONG = new Int2Long();
private static final Long2IntArray LONG_TO_INT_ARRAY = new Long2IntArray(RANDOM_SEED_ARRAY_SIZE);
private static final Long2LongArray LONG_TO_LONG_ARRAY = new Long2LongArray(RANDOM_SEED_ARRAY_SIZE);
private static final LongArray2Long LONG_ARRAY_TO_LONG = new LongArray2Long();
private static final IntArray2Int INT_ARRAY_TO_INT = new IntArray2Int();
private static final LongArray2IntArray LONG_ARRAY_TO_INT_ARRAY = new LongArray2IntArray();
private static final IntArray2LongArray INT_ARRAY_TO_LONG_ARRAY = new IntArray2LongArray();
private static final Map<Class<?>, SeedConverter<Integer,?>> CONV_INT = new HashMap<>();
private static final Map<Class<?>, SeedConverter<int[],?>> CONV_INT_ARRAY = new HashMap<>();
private static final Map<Class<?>, SeedConverter<Long,?>> CONV_LONG = new HashMap<>();
private static final Map<Class<?>, SeedConverter<long[],?>> CONV_LONG_ARRAY = new HashMap<>();
CONV_LONG.put(Integer.class, LONG_TO_INT);
CONV_LONG.put(Long.class, new NoOpConverter<Long>());
CONV_LONG.put(int[].class, LONG_TO_INT_ARRAY);
CONV_LONG.put(long[].class, LONG_TO_LONG_ARRAY);
CONV_INT.put(Integer.class, new NoOpConverter<Integer>());
CONV_INT.put(Long.class, INT_TO_LONG);
CONV_INT.put(int[].class, new SeedConverterComposer<Integer,Long,int[]>(INT_TO_LONG, LONG_TO_INT_ARRAY));
CONV_INT.put(long[].class, new SeedConverterComposer<Integer,Long,long[]>(INT_TO_LONG, LONG_TO_LONG_ARRAY));
CONV_INT_ARRAY.put(Integer.class, INT_ARRAY_TO_INT);
CONV_INT_ARRAY.put(Long.class, new SeedConverterComposer<int[],Integer,Long>(INT_ARRAY_TO_INT, INT_TO_LONG));
CONV_INT_ARRAY.put(int[].class, new NoOpConverter<int[]>());
CONV_INT_ARRAY.put(long[].class, INT_ARRAY_TO_LONG_ARRAY);
CONV_LONG_ARRAY.put(Integer.class, new SeedConverterComposer<long[],Long,Integer>(LONG_ARRAY_TO_LONG, LONG_TO_INT));
CONV_LONG_ARRAY.put(Long.class, LONG_ARRAY_TO_LONG);
CONV_LONG_ARRAY.put(int[].class, LONG_ARRAY_TO_INT_ARRAY);
CONV_LONG_ARRAY.put(long[].class, new NoOpConverter<long[]>());
private ProviderBuilder() {}
public static UniformRandomProvider create(RandomSourceInternal source,
Object seed,
Object[] args) {
final Object nativeSeed = createSeed(source, seed);
final List<Object> all = new ArrayList<>();
all.add(nativeSeed);
if (args != null) {
all.addAll(Arrays.asList(args));
return create(createConstructor(source), all.toArray());
private static Object createSeed(RandomSourceInternal source,
Object seed) {
Object nativeSeed = null;
if (seed == null) {
if (source.getSeed().equals(Integer.class)) {
nativeSeed = SeedFactory.createInt();
} else if (source.getSeed().equals(Long.class)) {
nativeSeed = SeedFactory.createLong();
} else if (source.getSeed().equals(int[].class)) {
nativeSeed = SeedFactory.createIntArray(RANDOM_SEED_ARRAY_SIZE);
} else if (source.getSeed().equals(long[].class)) {
nativeSeed = SeedFactory.createLongArray(RANDOM_SEED_ARRAY_SIZE);
} else {
if (seed instanceof Integer) {
nativeSeed = CONV_INT.get(source.getSeed()).convert((Integer) seed);
} else if (seed instanceof Long) {
nativeSeed = CONV_LONG.get(source.getSeed()).convert((Long) seed);
} else if (seed instanceof int[]) {
nativeSeed = CONV_INT_ARRAY.get(source.getSeed()).convert((int[]) seed);
} else if (seed instanceof long[]) {
nativeSeed = CONV_LONG_ARRAY.get(source.getSeed()).convert((long[]) seed);
if (nativeSeed == null) {
throw new MathUnsupportedOperationException();
if (!source.isNativeSeed(nativeSeed)) {
throw new MathInternalError();
return nativeSeed;
private static Constructor<?> createConstructor(RandomSourceInternal source) {
return source.getRng().getConstructor(source.getArgs());
} catch (NoSuchMethodException e) {
throw new MathInternalError(e);
private static UniformRandomProvider create(Constructor<?> rng,
Object[] args) {
return (UniformRandomProvider) rng.newInstance(args);
} catch (InvocationTargetException |
InstantiationException |
IllegalArgumentException |
IllegalAccessException e) {
throw new MathInternalError(e);
public enum RandomSourceInternal {
JDK(JDKRandom.class,
Long.class),
WELL_512_A(Well512a.class,
int[].class),
WELL_1024_A(Well1024a.class,
int[].class),
WELL_19937_A(Well19937a.class,
int[].class),
WELL_19937_C(Well19937c.class,
int[].class),
WELL_44497_A(Well44497a.class,
int[].class),
WELL_44497_B(Well44497b.class,
int[].class),
MT(MersenneTwister.class,
int[].class),
ISAAC(ISAACRandom.class,
int[].class),
SPLIT_MIX_64(SplitMix64.class,
Long.class),
XOR_SHIFT_1024_S(XorShift1024Star.class,
long[].class),
TWO_CMRES(TwoCmres.class,
Integer.class),
TWO_CMRES_SELECT(TwoCmres.class,
Integer.class,
Integer.TYPE,
Integer.TYPE),
MT_64(MersenneTwister64.class,
long[].class);
private final Class<? extends UniformRandomProvider> rng;
private final Class<?>[] args;
RandomSourceInternal(Class<? extends UniformRandomProvider> rng,
Class<?> ... args) {
this.rng = rng;
this.args = Arrays.copyOf(args, args.length);
public Class<?> getRng() {
return rng;
Class<?> getSeed() {
return args[0];
Class<?>[] getArgs() {
return args;
public <SEED> boolean isNativeSeed(SEED seed) {
return getSeed().equals(seed.getClass());
package org.apache.commons.math4.rng.internal;
public interface StateSettable {
void setState(RandomSource.State state);
RandomSource.State getState();
package org.apache.commons.math4.rng.internal;
package org.apache.commons.math4.rng.internal.source32;
public abstract class AbstractWell extends IntProvider {
protected int index;
protected final int[] v;
protected AbstractWell(final int k,
final int[] seed) {
final int r = calculateBlockCount(k);
v = new int[r];
index = 0;
setSeedInternal(seed);
protected byte[] getStateInternal() {
final int[] s = Arrays.copyOf(v, v.length + 1);
s[v.length] = index;
return NumberFactory.makeByteArray(s);
protected void setStateInternal(byte[] s) {
if (s.length != (v.length + 1) * 4) {
throw new InsufficientDataException();
final int[] tmp = NumberFactory.makeIntArray(s);
System.arraycopy(tmp, 0, v, 0, v.length);
index = tmp[v.length];
private void setSeedInternal(final int[] seed) {
System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));
if (seed.length < v.length) {
for (int i = seed.length; i < v.length; ++i) {
final long current = v[i - seed.length];
v[i] = (int) ((1812433253L * (current ^ (current >> 30)) + i) & 0xffffffffL);
index = 0;
private static int calculateBlockCount(final int k) {
final int w = 32;
final int r = (k + w - 1) / w;
return r;
protected static final class IndexTable {
private final int[] iRm1;
private final int[] iRm2;
private final int[] i1;
private final int[] i2;
private final int[] i3;
public IndexTable(final int k, final int m1, final int m2, final int m3) {
final int r = calculateBlockCount(k);
iRm1 = new int[r];
iRm2 = new int[r];
i1 = new int[r];
i2 = new int[r];
i3 = new int[r];
for (int j = 0; j < r; ++j) {
iRm1[j] = (j + r - 1) % r;
iRm2[j] = (j + r - 2) % r;
i1[j] = (j + m1) % r;
i2[j] = (j + m2) % r;
i3[j] = (j + m3) % r;
public int getIndexPred(final int index) {
return iRm1[index];
public int getIndexPred2(final int index) {
return iRm2[index];
public int getIndexM1(final int index) {
return i1[index];
public int getIndexM2(final int index) {
return i2[index];
public int getIndexM3(final int index) {
return i3[index];
package org.apache.commons.math4.rng.internal.source32;
public class ISAACRandom extends IntProvider {
private static final int SIZE_L = 8;
private static final int SIZE = 1 << SIZE_L;
private static final int H_SIZE = SIZE >> 1;
private static final int MASK = SIZE - 1 << 2;
private static final int GLD_RATIO = 0x9e3779b9;
private final int[] rsl = new int[SIZE];
private final int[] mem = new int[SIZE];
private int count;
private int isaacA;
private int isaacB;
private int isaacC;
private final int[] arr = new int[8];
private int isaacX;
private int isaacI;
private int isaacJ;
public ISAACRandom(int[] seed) {
setSeedInternal(seed);
protected byte[] getStateInternal() {
final int[] sRsl = Arrays.copyOf(rsl, SIZE);
final int[] sMem = Arrays.copyOf(mem, SIZE);
final int[] sRem = Arrays.copyOf(new int[] { count, isaacA, isaacB, isaacC }, 4);
final int[] s = new int[2 * SIZE + sRem.length];
System.arraycopy(sRsl, 0, s, 0, SIZE);
System.arraycopy(sMem, 0, s, SIZE, SIZE);
System.arraycopy(sRem, 0, s, 2 * SIZE, sRem.length);
return NumberFactory.makeByteArray(s);
protected void setStateInternal(byte[] s) {
if (s.length != (2 * SIZE + 4) * 4) {
throw new InsufficientDataException();
final int[] tmp = NumberFactory.makeIntArray(s);
System.arraycopy(tmp, 0, rsl, 0, SIZE);
System.arraycopy(tmp, SIZE, mem, 0, SIZE);
final int offset = 2 * SIZE;
count = tmp[offset];
isaacA = tmp[offset + 1];
isaacB = tmp[offset + 2];
isaacC = tmp[offset + 3];
private void setSeedInternal(int[] seed) {
final int seedLen = seed.length;
final int rslLen = rsl.length;
System.arraycopy(seed, 0, rsl, 0, Math.min(seedLen, rslLen));
if (seedLen < rslLen) {
for (int j = seedLen; j < rslLen; j++) {
long k = rsl[j - seedLen];
rsl[j] = (int) (0x6c078965L * (k ^ k >> 30) + j & 0xffffffffL);
initState();
public int next() {
if (count < 0) {
isaac();
count = SIZE - 1;
return rsl[count--];
private void isaac() {
isaacI = 0;
isaacJ = H_SIZE;
isaacB += ++isaacC;
while (isaacI < H_SIZE) {
isaac2();
isaacJ = 0;
while (isaacJ < H_SIZE) {
isaac2();
private void isaac2() {
isaacX = mem[isaacI];
isaacA ^= isaacA << 13;
isaacA += mem[isaacJ++];
isaac3();
isaacX = mem[isaacI];
isaacA ^= isaacA >>> 6;
isaacA += mem[isaacJ++];
isaac3();
isaacX = mem[isaacI];
isaacA ^= isaacA << 2;
isaacA += mem[isaacJ++];
isaac3();
isaacX = mem[isaacI];
isaacA ^= isaacA >>> 16;
isaacA += mem[isaacJ++];
isaac3();
private void isaac3() {
mem[isaacI] = mem[(isaacX & MASK) >> 2] + isaacA + isaacB;
isaacB = mem[(mem[isaacI] >> SIZE_L & MASK) >> 2] + isaacX;
rsl[isaacI++] = isaacB;
private void initState() {
isaacA = 0;
isaacB = 0;
isaacC = 0;
for (int j = 0; j < arr.length; j++) {
arr[j] = GLD_RATIO;
for (int j = 0; j < 4; j++) {
shuffle();
for (int j = 0; j < SIZE; j += 8) {
arr[0] += rsl[j];
arr[1] += rsl[j + 1];
arr[2] += rsl[j + 2];
arr[3] += rsl[j + 3];
arr[4] += rsl[j + 4];
arr[5] += rsl[j + 5];
arr[6] += rsl[j + 6];
arr[7] += rsl[j + 7];
shuffle();
setState(j);
for (int j = 0; j < SIZE; j += 8) {
arr[0] += mem[j];
arr[1] += mem[j + 1];
arr[2] += mem[j + 2];
arr[3] += mem[j + 3];
arr[4] += mem[j + 4];
arr[5] += mem[j + 5];
arr[6] += mem[j + 6];
arr[7] += mem[j + 7];
shuffle();
setState(j);
isaac();
count = SIZE - 1;
private void shuffle() {
arr[0] ^= arr[1] << 11;
arr[3] += arr[0];
arr[1] += arr[2];
arr[1] ^= arr[2] >>> 2;
arr[4] += arr[1];
arr[2] += arr[3];
arr[2] ^= arr[3] << 8;
arr[5] += arr[2];
arr[3] += arr[4];
arr[3] ^= arr[4] >>> 16;
arr[6] += arr[3];
arr[4] += arr[5];
arr[4] ^= arr[5] << 10;
arr[7] += arr[4];
arr[5] += arr[6];
arr[5] ^= arr[6] >>> 4;
arr[0] += arr[5];
arr[6] += arr[7];
arr[6] ^= arr[7] << 8;
arr[1] += arr[6];
arr[7] += arr[0];
arr[7] ^= arr[0] >>> 9;
arr[2] += arr[7];
arr[0] += arr[1];
private void setState(int start) {
mem[start] = arr[0];
mem[start + 1] = arr[1];
mem[start + 2] = arr[2];
mem[start + 3] = arr[3];
mem[start + 4] = arr[4];
mem[start + 5] = arr[5];
mem[start + 6] = arr[6];
mem[start + 7] = arr[7];
package org.apache.commons.math4.rng.internal.source32;
public abstract class IntProvider
extends BaseProvider
implements RandomIntSource {
public abstract int next();
public int nextInt() {
return next();
public boolean nextBoolean() {
return NumberFactory.makeBoolean(nextInt());
public double nextDouble() {
return NumberFactory.makeDouble(nextInt(), nextInt());
public float nextFloat() {
return NumberFactory.makeFloat(nextInt());
public long nextLong() {
return NumberFactory.makeLong(nextInt(), nextInt());
public void nextBytes(byte[] bytes) {
nextBytesFill(this, bytes, 0, bytes.length);
public void nextBytes(byte[] bytes,
int start,
int len) {
if (start < 0 ||
start >= bytes.length) {
throw new OutOfRangeException(start, 0, bytes.length);
if (len < 0 ||
len > bytes.length - start) {
throw new OutOfRangeException(len, 0, bytes.length - start);
nextBytesFill(this, bytes, start, len);
byte[] bytes,
int start,
int len) {
int index = start; // Index of first insertion.
final int indexLoopLimit = index + (len & 0x7ffffffc);
while (index < indexLoopLimit) {
final int random = source.next();
bytes[index++] = (byte) random;
bytes[index++] = (byte) (random >>> 8);
bytes[index++] = (byte) (random >>> 16);
bytes[index++] = (byte) (random >>> 24);
final int indexLimit = start + len; // Index of last insertion + 1.
if (index < indexLimit) {
int random = source.next();
while (true) {
bytes[index++] = (byte) random;
if (index < indexLimit) {
random >>>= 8;
} else {
break;
package org.apache.commons.math4.rng.internal.source32;
public class JDKRandom extends IntProvider {
private Random delegate;
public JDKRandom(Long seed) {
delegate = new Random(seed);
public int next() {
return delegate.nextInt();
protected byte[] getStateInternal() {
final ByteArrayOutputStream bos = new ByteArrayOutputStream();
final ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(delegate);
return bos.toByteArray();
} catch (IOException e) {
throw new RuntimeException(e);
protected void setStateInternal(byte[] s) {
final ByteArrayInputStream bis = new ByteArrayInputStream(s);
final ObjectInputStream ois = new ObjectInputStream(bis);
delegate = (Random) ois.readObject();
} catch (ClassNotFoundException|IOException e) {
throw new RuntimeException(e);
package org.apache.commons.math4.rng.internal.source32;
public class MersenneTwister extends IntProvider {
private static final long INT_MASK_LONG = 0xffffffffL;
private static final long UPPER_MASK_LONG = 0x80000000L;
private static final long LOWER_MASK_LONG = 0x7fffffffL;
private static final int UPPER_MASK = 0x80000000;
private static final int LOWER_MASK = 0x7fffffff;
private static final int N = 624;
private static final int M = 397;
private static final int[] MAG01 = { 0x0, 0x9908b0df };
private int[] mt = new int[N];
private int mti;
public MersenneTwister(int[] seed) {
setSeedInternal(seed);
protected byte[] getStateInternal() {
final int[] s = Arrays.copyOf(mt, N + 1);
s[N] = mti;
return NumberFactory.makeByteArray(s);
protected void setStateInternal(byte[] s) {
if (s.length != (N + 1) * 4) {
throw new InsufficientDataException();
final int[] tmp = NumberFactory.makeIntArray(s);
System.arraycopy(tmp, 0, mt, 0, N);
mti = tmp[N];
private void setSeedInternal(int[] seed) {
initState(19650218);
int i = 1;
int j = 0;
for (int k = Math.max(N, seed.length); k != 0; k--) {
final long l0 = (mt[i] & LOWER_MASK_LONG)   | ((mt[i]   < 0) ? UPPER_MASK_LONG : 0);
final long l1 = (mt[i-1] & LOWER_MASK_LONG) | ((mt[i-1] < 0) ? UPPER_MASK_LONG : 0);
final long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear
mt[i]   = (int) (l & INT_MASK_LONG);
i++; j++;
if (i >= N) {
mt[0] = mt[N - 1];
i = 1;
if (j >= seed.length) {
j = 0;
for (int k = N - 1; k != 0; k--) {
final long l0 = (mt[i] & LOWER_MASK_LONG)   | ((mt[i]   < 0) ? UPPER_MASK_LONG : 0);
final long l1 = (mt[i-1] & LOWER_MASK_LONG) | ((mt[i-1] < 0) ? UPPER_MASK_LONG : 0);
final long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear
mt[i]   = (int) (l & INT_MASK_LONG);
i++;
if (i >= N) {
mt[0] = mt[N - 1];
i = 1;
mt[0] = UPPER_MASK; // MSB is 1; assuring non-zero initial array
private void initState(int seed) {
long longMT = seed & INT_MASK_LONG;
mt[0]= (int) longMT;
for (mti = 1; mti < N; ++mti) {
longMT = (1812433253L * (longMT ^ (longMT >> 30)) + mti) & INT_MASK_LONG;
mt[mti]= (int) longMT;
public int next() {
int y;
if (mti >= N) { // Generate N words at one time.
int mtNext = mt[0];
for (int k = 0; k < N - M; ++k) {
int mtCurr = mtNext;
mtNext = mt[k + 1];
y = (mtCurr & UPPER_MASK) | (mtNext & LOWER_MASK);
mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 1];
for (int k = N - M; k < N - 1; ++k) {
int mtCurr = mtNext;
mtNext = mt[k + 1];
y = (mtCurr & UPPER_MASK) | (mtNext & LOWER_MASK);
mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 1];
y = (mtNext & UPPER_MASK) | (mt[0] & LOWER_MASK);
mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 1];
mti = 0;
y = mt[mti++];
y ^=  y >>> 11;
y ^= (y << 7) & 0x9d2c5680;
y ^= (y << 15) & 0xefc60000;
y ^=  y >>> 18;
return y;
package org.apache.commons.math4.rng.internal.source32;
public interface RandomIntSource {
int next();
package org.apache.commons.math4.rng.internal.source32;
public class Well1024a extends AbstractWell {
private static final int K = 1024;
private static final int M1 = 3;
private static final int M2 = 24;
private static final int M3 = 10;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well1024a(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int v0 = v[index];
final int vM1 = v[TABLE.getIndexM1(index)];
final int vM2 = v[TABLE.getIndexM2(index)];
final int vM3 = v[TABLE.getIndexM3(index)];
final int z0 = v[indexRm1];
final int z1 = v0 ^ (vM1 ^ (vM1 >>> 8));
final int z2 = (vM2 ^ (vM2 << 19)) ^ (vM3 ^ (vM3 << 14));
final int z3 = z1 ^ z2;
final int z4 = (z0 ^ (z0 << 11)) ^ (z1 ^ (z1 << 7)) ^ (z2 ^ (z2 << 13));
v[index] = z3;
v[indexRm1] = z4;
index = indexRm1;
return z4;
package org.apache.commons.math4.rng.internal.source32;
public class Well19937a extends AbstractWell {
private static final int K = 19937;
private static final int M1 = 70;
private static final int M2 = 179;
private static final int M3 = 449;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well19937a(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int indexRm2 = TABLE.getIndexPred2(index);
final int v0 = v[index];
final int vM1 = v[TABLE.getIndexM1(index)];
final int vM2 = v[TABLE.getIndexM2(index)];
final int vM3 = v[TABLE.getIndexM3(index)];
final int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);
final int z1 = (v0 ^ (v0 << 25)) ^ (vM1 ^ (vM1 >>> 27));
final int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));
final int z3 = z1 ^ z2;
final int z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));
v[index] = z3;
v[indexRm1] = z4;
v[indexRm2] &= 0x80000000;
index = indexRm1;
return z4;
package org.apache.commons.math4.rng.internal.source32;
public class Well19937c extends AbstractWell {
private static final int K = 19937;
private static final int M1 = 70;
private static final int M2 = 179;
private static final int M3 = 449;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well19937c(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int indexRm2 = TABLE.getIndexPred2(index);
final int v0 = v[index];
final int vM1 = v[TABLE.getIndexM1(index)];
final int vM2 = v[TABLE.getIndexM2(index)];
final int vM3 = v[TABLE.getIndexM3(index)];
final int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);
final int z1 = (v0 ^ (v0 << 25)) ^ (vM1 ^ (vM1 >>> 27));
final int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));
final int z3 = z1 ^ z2;
int z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));
v[index] = z3;
v[indexRm1] = z4;
v[indexRm2] &= 0x80000000;
index = indexRm1;
z4 ^= (z4 <<  7) & 0xe46e1700;
z4 ^= (z4 << 15) & 0x9b868000;
return z4;
package org.apache.commons.math4.rng.internal.source32;
public class Well44497a extends AbstractWell {
private static final int K = 44497;
private static final int M1 = 23;
private static final int M2 = 481;
private static final int M3 = 229;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well44497a(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int indexRm2 = TABLE.getIndexPred2(index);
final int v0 = v[index];
final int vM1 = v[TABLE.getIndexM1(index)];
final int vM2 = v[TABLE.getIndexM2(index)];
final int vM3 = v[TABLE.getIndexM3(index)];
final int z0 = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);
final int z1 = (v0 ^ (v0 << 24)) ^ (vM1 ^ (vM1 >>> 30));
final int z2 = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);
final int z3 = z1 ^ z2;
final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;
final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;
final int z4 = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;
v[index] = z3;
v[indexRm1] = z4;
v[indexRm2] &= 0xFFFF8000;
index = indexRm1;
return z4;
package org.apache.commons.math4.rng.internal.source32;
public class Well44497b extends AbstractWell {
private static final int K = 44497;
private static final int M1 = 23;
private static final int M2 = 481;
private static final int M3 = 229;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well44497b(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int indexRm2 = TABLE.getIndexPred2(index);
final int v0 = v[index];
final int vM1 = v[TABLE.getIndexM1(index)];
final int vM2 = v[TABLE.getIndexM2(index)];
final int vM3 = v[TABLE.getIndexM3(index)];
final int z0 = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);
final int z1 = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));
final int z2 = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);
final int z3 = z1 ^ z2;
final int z2Prime = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;
final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;
int z4 = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;
v[index] = z3;
v[indexRm1] = z4;
v[indexRm2] &= 0xFFFF8000;
index = indexRm1;
z4 ^= (z4 <<  7) & 0x93dd1400;
z4 ^= (z4 << 15) & 0xfa118000;
return z4;
package org.apache.commons.math4.rng.internal.source32;
public class Well512a extends AbstractWell {
private static final int K = 512;
private static final int M1 = 13;
private static final int M2 = 9;
private static final int M3 = 5;
private static final IndexTable TABLE = new IndexTable(K, M1, M2, M3);
public Well512a(int[] seed) {
super(K, seed);
public int next() {
final int indexRm1 = TABLE.getIndexPred(index);
final int vi = v[index];
final int vi1 = v[TABLE.getIndexM1(index)];
final int vi2 = v[TABLE.getIndexM2(index)];
final int z0 = v[indexRm1];
final int z1 = (vi ^ (vi << 16)) ^ (vi1 ^ (vi1 << 15));
final int z2 = vi2 ^ (vi2 >>> 11);
final int z3 = z1 ^ z2;
final int z4 = (z0 ^ (z0 << 2)) ^ (z1 ^ (z1 << 18)) ^ (z2 << 28) ^ (z3 ^ ((z3 << 5) & 0xda442d24));
v[index] = z3;
v[indexRm1] = z4;
index = indexRm1;
return z4;
package org.apache.commons.math4.rng.internal.source32;
package org.apache.commons.math4.rng.internal.source64;
public abstract class LongProvider
extends BaseProvider
implements RandomLongSource {
public abstract long next();
public long nextLong() {
return next();
public int nextInt() {
return NumberFactory.makeInt(nextLong());
public double nextDouble() {
return NumberFactory.makeDouble(nextLong());
public boolean nextBoolean() {
return NumberFactory.makeBoolean(nextLong());
public float nextFloat() {
return NumberFactory.makeFloat(nextInt());
public void nextBytes(byte[] bytes) {
nextBytesFill(this, bytes, 0, bytes.length);
public void nextBytes(byte[] bytes,
int start,
int len) {
if (start < 0 ||
start >= bytes.length) {
throw new OutOfRangeException(start, 0, bytes.length);
if (len < 0 ||
len > bytes.length - start) {
throw new OutOfRangeException(len, 0, bytes.length - start);
nextBytesFill(this, bytes, start, len);
byte[] bytes,
int start,
int len) {
int index = start; // Index of first insertion.
final int indexLoopLimit = index + (len & 0x7ffffff8);
while (index < indexLoopLimit) {
final long random = source.next();
bytes[index++] = (byte) random;
bytes[index++] = (byte) (random >>> 8);
bytes[index++] = (byte) (random >>> 16);
bytes[index++] = (byte) (random >>> 24);
bytes[index++] = (byte) (random >>> 32);
bytes[index++] = (byte) (random >>> 40);
bytes[index++] = (byte) (random >>> 48);
bytes[index++] = (byte) (random >>> 56);
final int indexLimit = start + len; // Index of last insertion + 1.
if (index < indexLimit) {
long random = source.next();
while (true) {
bytes[index++] = (byte) random;
if (index < indexLimit) {
random >>>= 8;
} else {
break;
package org.apache.commons.math4.rng.internal.source64;
public class MersenneTwister64 extends LongProvider {
private static final int NN = 312;
private static final int MM = 156;
private static final long[] MAG01 = { 0x0, 0xb5026f5aa96619e9L };
private static final long UM = 0xffffffff80000000L;
private static final long LM = 0x7fffffffL;
private long[] mt = new long[NN];
private int mti;
public MersenneTwister64(long[] seed) {
setSeedInternal(seed);
protected byte[] getStateInternal() {
final long[] s = Arrays.copyOf(mt, NN + 1);
s[NN] = mti;
return NumberFactory.makeByteArray(s);
protected void setStateInternal(byte[] s) {
if (s.length != (NN + 1) * 8) {
throw new InsufficientDataException();
final long[] tmp = NumberFactory.makeLongArray(s);
System.arraycopy(tmp, 0, mt, 0, NN);
mti = (int) tmp[NN];
private void setSeedInternal(long[] seed) {
initState(19650218L);
int i = 1;
int j = 0;
for (int k = Math.max(NN, seed.length); k != 0; k--) {
final long mm1 = mt[i - 1];
mt[i] = (mt[i] ^ ((mm1 ^ (mm1 >>> 62)) * 0x369dea0f31a53f85L)) + seed[j] + j; // non linear
i++;
j++;
if (i >= NN) {
mt[0] = mt[NN - 1];
i = 1;
if (j >= seed.length) {
j = 0;
for (int k = NN - 1; k != 0; k--) {
final long mm1 = mt[i - 1];
mt[i] = (mt[i] ^ ((mm1 ^ (mm1 >>> 62)) * 0x27bb2ee687b0b0fdL)) - i; // non linear
i++;
if (i >= NN) {
mt[0] = mt[NN - 1];
i = 1;
mt[0] = 0x8000000000000000L; // MSB is 1; assuring non-zero initial array
private void initState(long seed) {
mt[0] = seed;
for (mti = 1; mti < NN; mti++) {
final long mm1 = mt[mti - 1];
mt[mti] = 0x5851f42d4c957f2dL * (mm1 ^ (mm1 >>> 62)) + mti;
public long next() {
long x;
if (mti >= NN) { // generate NN words at one time
for (int i = 0; i < NN - MM; i++) {
x = (mt[i] & UM) | (mt[i + 1] & LM);
mt[i] = mt[i + MM] ^ (x >>> 1) ^ MAG01[(int)(x & 0x1L)];
for (int i = NN - MM; i < NN - 1; i++) {
x = (mt[i] & UM) | (mt[i + 1] & LM);
mt[i] = mt[ i + (MM - NN)] ^ (x >>> 1) ^ MAG01[(int)(x & 0x1L)];
x = (mt[NN - 1] & UM) | (mt[0] & LM);
mt[NN - 1] = mt[MM - 1] ^ (x >>> 1) ^ MAG01[(int)(x & 0x1L)];
mti = 0;
x = mt[mti++];
x ^= (x >>> 29) & 0x5555555555555555L;
x ^= (x << 17) & 0x71d67fffeda60000L;
x ^= (x << 37) & 0xfff7eee000000000L;
x ^= x >>> 43;
return x;
package org.apache.commons.math4.rng.internal.source64;
public interface RandomLongSource {
long next();
package org.apache.commons.math4.rng.internal.source64;
public class SplitMix64 extends LongProvider {
private long state;
public SplitMix64(Long seed) {
setSeedInternal(seed);
private void setSeedInternal(Long seed) {
state = seed;
public long next() {
long z = state += 0x9e3779b97f4a7c15L;
z = (z ^ (z >>> 30)) * 0xbf58476d1ce4e5b9L;
z = (z ^ (z >>> 27)) * 0x94d049bb133111ebL;
return z ^ (z >>> 31);
protected byte[] getStateInternal() {
return NumberFactory.makeByteArray(state);
protected void setStateInternal(byte[] s) {
if (s.length != 8) {
throw new InsufficientDataException();
state = NumberFactory.makeLong(s);
package org.apache.commons.math4.rng.internal.source64;
public class TwoCmres extends LongProvider {
private static final byte SEED_GUARD = 9;
private static final Cmres.Factory FACTORY = new Cmres.Factory();
private final Cmres x;
private final Cmres y;
private long xx;
private long yy;
private TwoCmres(int seed,
Cmres x,
Cmres y) {
if (x == y) {
throw new InsufficientDataException();
this.x = x;
this.y = y;
setSeedInternal(seed);
public TwoCmres(Integer seed) {
this(seed, 0, 1);
public TwoCmres(Integer seed,
int i,
int j) {
this(seed, FACTORY.get(i), FACTORY.get(j));
public long next() {
xx = x.transform(xx);
yy = y.transform(yy);
return xx + yy;
public String toString() {
return super.toString() + " (" + x + " + " + y + ")";
public static int numberOfSubcycleGenerators() {
return FACTORY.numberOfSubcycleGenerators();
protected byte[] getStateInternal() {
return NumberFactory.makeByteArray(new long[] { xx, yy });
protected void setStateInternal(byte[] s) {
if (s.length != 16) {
throw new InsufficientDataException();
final long[] state = NumberFactory.makeLongArray(s);
xx = state[0];
yy = state[1];
private void setSeedInternal(int seed) {
final long s = NumberFactory.makeLong(0, seed); // s >= 0
final int xMax = (int) (s & 0xffff + SEED_GUARD);
final int yMax = (int) ((s >> 16) + SEED_GUARD);
if (xMax < 0 ||
yMax < 0) {
throw new MathInternalError();
xx = x.getStart();
for (int i = xMax; i > 0; i--) {
xx = x.transform(xx);
yy = y.getStart();
for (int i = yMax; i > 0; i--) {
yy = y.transform(yy);
private final int start;
private final long multiply;
private final int rotate;
Cmres(long multiply,
int rotate,
int start) {
this.multiply = multiply;
this.rotate = rotate;
this.start = start;
public String toString() {
final String sep = ", ";
final String m = String.format((java.util.Locale) null, "0x%016xL", multiply);
return "Cmres: [" + m + sep + rotate + sep + start + "]";
public long getMultiply() {
return multiply;
public int getStart() {
return start;
long transform(long state) {
long s = state;
s *= multiply;
s = rotl(s);
s -= state;
return s;
private long rotl(long state) {
return (state << rotate) | (state >>> (64 - rotate));
private static final List<Cmres> TABLE = new ArrayList<Cmres>();
add(0xedce446814d3b3d9L, 33, 0x13b572e7);
add(0xc5b3cf786c806df7L, 33, 0x13c8e18a);
add(0xdd91bbb8ab9e0e65L, 31, 0x06dd03a6);
add(0x7b69342c0790221dL, 31, 0x1646bb8b);
add(0x0c72c0d18614c32bL, 33, 0x06014a3d);
add(0xd8d98c13bebe26c9L, 33, 0x014e8475);
add(0xcb039dc328bbc40fL, 31, 0x008684bd);
add(0x858c5ef3c021ed2fL, 32, 0x0dc8d622);
add(0x4c8be96bfc23b127L, 33, 0x0b6b20cc);
add(0x11eab77f808cf641L, 32, 0x06534421);
add(0xbc9bd78810fd28fdL, 31, 0x1d9ba40d);
add(0x0f1505c780688cb5L, 33, 0x0b7b7b67);
add(0xadc174babc2053afL, 31, 0x267f4197);
add(0x900b6b82b31686d9L, 31, 0x023c6985);
int numberOfSubcycleGenerators() {
return TABLE.size();
Cmres get(int index) {
if (index < 0 ||
index >= TABLE.size()) {
throw new OutOfRangeException(index, 0, TABLE.size());
return TABLE.get(index);
private static void add(long multiply,
int rotate,
int start) {
for (Cmres sg : TABLE) {
if (multiply == sg.getMultiply()) {
throw new MathInternalError();
TABLE.add(new Cmres(multiply, rotate, start));
package org.apache.commons.math4.rng.internal.source64;
public class XorShift1024Star extends LongProvider {
private static final int SEED_SIZE = 16;
private final long[] state = new long[SEED_SIZE];
private int index;
public XorShift1024Star(long[] seed) {
setSeedInternal(seed);
protected byte[] getStateInternal() {
final long[] s = Arrays.copyOf(state, SEED_SIZE + 1);
s[SEED_SIZE] = index;
return NumberFactory.makeByteArray(s);
protected void setStateInternal(byte[] s) {
if (s.length != (SEED_SIZE + 1) * 8) {
throw new InsufficientDataException();
final long[] tmp = NumberFactory.makeLongArray(s);
System.arraycopy(tmp, 0, state, 0, SEED_SIZE);
index = (int) tmp[SEED_SIZE];
private void setSeedInternal(long[] seed) {
System.arraycopy(seed, 0, state, 0, Math.min(seed.length, state.length));
if (seed.length < SEED_SIZE) {
for (int i = seed.length; i < SEED_SIZE; i++) {
state[i] = 26021969L * i;
for (int i = SEED_SIZE - 1; i > seed.length; i--) {
state[i] ^= state[SEED_SIZE - i - 1];
state[seed.length] = 0x8000000000000000L; // Ensuring non-zero initial array.
index = 0;
public long next() {
final long s0 = state[index];
long s1 = state[index = (index + 1) & 15];
s1 ^= s1 << 31; // a
state[index] = s1 ^ s0 ^ (s1 >>> 11) ^ (s0 >>> 30); // b,c
return state[index] * 1181783497276652981L;
package org.apache.commons.math4.rng.internal.source64;
package org.apache.commons.math4.rng.internal.util;
public class Int2Long implements SeedConverter<Integer, Long> {
public Long convert(Integer seed) {
final int s = seed;
return NumberFactory.makeLong(s, ~s);
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class IntArray2Int implements SeedConverter<int[], Integer> {
public Integer convert(int[] seed) {
int out = 0;
for (int i = 0; i < seed.length; i++) {
out ^= seed[i];
return out;
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class IntArray2LongArray implements SeedConverter<int[], long[]> {
public long[] convert(int[] seed) {
final int outSize = (seed.length + 1) / 2;
final long[] out = new long[outSize];
for (int i = 0; i < outSize; i++) {
final int lo = seed[i];
final int hi = outSize + i < seed.length ? seed[outSize + i] : 0;
out[i] = NumberFactory.makeLong(hi, lo) ;
return out;
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class Long2Int implements SeedConverter<Long, Integer> {
public Integer convert(Long seed) {
return NumberFactory.makeInt(seed);
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class Long2IntArray implements SeedConverter<Long, int[]> {
private final int size;
public Long2IntArray(int size) {
this.size = size;
public int[] convert(Long seed) {
return SeedFactory.createIntArray(size, new SplitMix64(seed));
public String toString() {
return getClass().getSimpleName() + "(size=" + size + ")";
package org.apache.commons.math4.rng.internal.util;
public class Long2LongArray implements SeedConverter<Long, long[]> {
private final int size;
public Long2LongArray(int size) {
this.size = size;
public long[] convert(Long seed) {
final long[] out = new long[size];
final SplitMix64 rng = new SplitMix64(seed);
for (int i = 0; i < size; i++) {
out[i] = rng.nextLong();
return out;
public String toString() {
return getClass().getSimpleName() + "(size: " + size + ")";
package org.apache.commons.math4.rng.internal.util;
public class LongArray2IntArray implements SeedConverter<long[], int[]> {
public int[] convert(long[] seed) {
final int[] out = new int[seed.length * 2];
for (int i = 0; i < seed.length; i++) {
final long current = seed[i];
out[i] = NumberFactory.extractLo(current);
out[seed.length + i] = NumberFactory.extractHi(current);
return out;
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class LongArray2Long implements SeedConverter<long[], Long> {
public Long convert(long[] seed) {
long out = 0;
for (int i = 0; i < seed.length; i++) {
out ^= seed[i];
return out;
public String toString() {
return getClass().getSimpleName();
package org.apache.commons.math4.rng.internal.util;
public class LongMixInt implements SeedConverter<Long, int[]> {
private final int size;
public LongMixInt(int size) {
this.size = size;
public int[] convert(Long seed) {
return SeedFactory.createIntArray(size, new SplitMix64(seed));
public String toString() {
return getClass().getSimpleName() + "(size=" + size + ")";
package org.apache.commons.math4.rng.internal.util;
public class LongMixLong implements SeedConverter<Long, long[]> {
private final int size;
public LongMixLong(int size) {
this.size = size;
public long[] convert(Long seed) {
final long[] out = new long[size];
final SplitMix64 rng = new SplitMix64(seed);
for (int i = 0; i < size; i++) {
out[i] = rng.nextLong();
return out;
public String toString() {
return getClass().getSimpleName() + "(size: " + size + ")";
package org.apache.commons.math4.rng.internal.util;
public class NoOpConverter<SEED> implements SeedConverter<SEED, SEED> {
public SEED convert(SEED seed) {
return seed;
public String toString() {
return "Pass-through";
package org.apache.commons.math4.rng.internal.util;
public final class NumberFactory {
private static final long DOUBLE_HIGH_BITS = 0x3ffL << 52;
private static final float FLOAT_MULTIPLIER = 0x1.0p-23f;
private static final double DOUBLE_MULTIPLIER = 0x1.0p-52d;
private static final long LONG_LOWEST_BYTE_MASK = 0xffL;
private static final int LONG_SIZE = 8;
private static final int INT_LOWEST_BYTE_MASK = 0xff;
private static final int INT_SIZE = 4;
private NumberFactory() {}
public static boolean makeBoolean(int v) {
return (v >>> 31) != 0;
public static boolean makeBoolean(long v) {
return (v >>> 63) != 0;
public static double makeDouble(long v) {
return Double.longBitsToDouble(DOUBLE_HIGH_BITS | v >>> 12) - 1d;
public static double makeDouble(int v,
int w) {
final long high = ((long) (v >>> 6)) << 26;
final int low = w >>> 6;
return (high | low) * DOUBLE_MULTIPLIER;
public static float makeFloat(int v) {
return (v >>> 9) * FLOAT_MULTIPLIER;
public static long makeLong(int v,
int w) {
return (((long) v) << 32) | (w & 0xffffffffL);
public static int makeInt(long v) {
return extractHi(v) ^ extractLo(v);
public static int extractHi(long v) {
return (int) (v >>> 32);
public static int extractLo(long v) {
return (int) v;
public static byte[] makeByteArray(long v) {
final byte[] b = new byte[LONG_SIZE];
for (int i = 0; i < LONG_SIZE; i++) {
final int shift = i * 8;
b[i] = (byte) ((v >>> shift) & LONG_LOWEST_BYTE_MASK);
return b;
public static long makeLong(byte[] input) {
if (input.length != LONG_SIZE) {
throw new DimensionMismatchException(input.length, LONG_SIZE);
long v = 0;
for (int i = 0; i < LONG_SIZE; i++) {
final int shift = i * 8;
v |= (((long) input[i]) & LONG_LOWEST_BYTE_MASK) << shift;
return v;
public static byte[] makeByteArray(long[] input) {
final int size = input.length * LONG_SIZE;
final byte[] b = new byte[size];
for (int i = 0; i < input.length; i++) {
final byte[] current = makeByteArray(input[i]);
System.arraycopy(current, 0, b, i * LONG_SIZE, LONG_SIZE);
return b;
public static long[] makeLongArray(byte[] input) {
final int size = input.length;
final int num = size / LONG_SIZE;
if (num * LONG_SIZE != size) {
throw new DimensionMismatchException(size, num * LONG_SIZE);
final long[] output = new long[num];
for (int i = 0; i < num; i++) {
final int from = i * LONG_SIZE;
final byte[] current = Arrays.copyOfRange(input, from, from + LONG_SIZE);
output[i] = makeLong(current);
return output;
public static byte[] makeByteArray(int v) {
final byte[] b = new byte[INT_SIZE];
for (int i = 0; i < INT_SIZE; i++) {
final int shift = i * 8;
b[i] = (byte) ((v >>> shift) & INT_LOWEST_BYTE_MASK);
return b;
public static int makeInt(byte[] input) {
if (input.length != INT_SIZE) {
throw new DimensionMismatchException(input.length, INT_SIZE);
int v = 0;
for (int i = 0; i < INT_SIZE; i++) {
final int shift = i * 8;
v |= (((int) input[i]) & INT_LOWEST_BYTE_MASK) << shift;
return v;
public static byte[] makeByteArray(int[] input) {
final int size = input.length * INT_SIZE;
final byte[] b = new byte[size];
for (int i = 0; i < input.length; i++) {
final byte[] current = makeByteArray(input[i]);
System.arraycopy(current, 0, b, i * INT_SIZE, INT_SIZE);
return b;
public static int[] makeIntArray(byte[] input) {
final int size = input.length;
final int num = size / INT_SIZE;
if (num * INT_SIZE != size) {
throw new DimensionMismatchException(size, num * INT_SIZE);
final int[] output = new int[num];
for (int i = 0; i < num; i++) {
final int from = i * INT_SIZE;
final byte[] current = Arrays.copyOfRange(input, from, from + INT_SIZE);
output[i] = makeInt(current);
return output;
package org.apache.commons.math4.rng.internal.util;
public interface SeedConverter<IN, OUT> {
OUT convert(IN seed);
package org.apache.commons.math4.rng.internal.util;
public class SeedConverterComposer<IN, TRANS, OUT> implements SeedConverter<IN, OUT> {
private SeedConverter<IN, TRANS> first;
private SeedConverter<TRANS, OUT> second;
public SeedConverterComposer(SeedConverter<IN, TRANS> first,
SeedConverter<TRANS, OUT> second) {
this.first = first;
this.second = second;
public OUT convert(IN seed) {
final TRANS trans = first.convert(seed);
return second.convert(trans);
public String toString() {
return getClass().getSimpleName() + " (" + second + " o " + first + ")";
package org.apache.commons.math4.rng.internal.util;
public class SeedFactory {
private static final RandomIntSource SEED_GENERATOR;
final long t = System.currentTimeMillis();
final int h = System.identityHashCode(Runtime.getRuntime());
final SplitMix64 rng = new SplitMix64(t ^ NumberFactory.makeLong(h, ~h));
final int blockCount = 1391; // Size of the state array of "Well44497b".
SEED_GENERATOR = new Well44497b(createIntArray(blockCount, rng));
private SeedFactory() {}
public static int createInt() {
return createInt(SEED_GENERATOR, System.identityHashCode(new Object()));
public static long createLong() {
return createLong(SEED_GENERATOR, System.identityHashCode(new Object()));
public static int[] createIntArray(int n) {
return createIntArray(n, SEED_GENERATOR, new Object());
public static long[] createLongArray(int n) {
return createLongArray(n, SEED_GENERATOR, new Object());
RandomIntSource source) {
return createLongArray(n, source, null);
RandomLongSource source) {
return createIntArray(n, source, null);
RandomIntSource source) {
return createIntArray(n, source, null);
private static long[] createLongArray(int n,
RandomIntSource source,
Object h) {
final long[] array = new long[n];
final int hash = System.identityHashCode(h);
for (int i = 0; i < n; i++) {
array[i] = createLong(source, hash);
return array;
private static int[] createIntArray(int n,
RandomLongSource source,
Object h) {
final int[] array = new int[n];
final int hash = System.identityHashCode(h);
for (int i = 0; i < n; i += 2) {
final long v = createLong(source, hash);
array[i] = NumberFactory.extractHi(v);
if (i + 1 < n) {
array[i + 1] = NumberFactory.extractLo(v);
return array;
private static int[] createIntArray(int n,
RandomIntSource source,
Object h) {
final int[] array = new int[n];
final int hash = System.identityHashCode(h);
for (int i = 0; i < n; i++) {
array[i] = createInt(source, hash);
return array;
private static long createLong(RandomLongSource source,
int number) {
synchronized (source) {
return source.next() ^ NumberFactory.makeLong(number, number);
private static long createLong(RandomIntSource source,
int number) {
synchronized (source) {
return NumberFactory.makeLong(source.next() ^ number,
source.next() ^ number);
private static int createInt(RandomIntSource source,
int number) {
synchronized (source) {
return source.next() ^ number;
package org.apache.commons.math4.rng.internal.util;
package org.apache.commons.math4.rng;
final BinomialDistribution distribution = new BinomialDistribution(numberOfTrials, probability);
new ChiSquaredDistribution(expected.length - 1.0);
new ChiSquaredDistribution((double) observed1.length - 1);
new ChiSquaredDistribution(expected.length - 1.0);
new ChiSquaredDistribution(expected.length - 2.0);
new ChiSquaredDistribution((double) observed1.length - 1);
private final UniformRandomProvider rng;
rng = RandomSource.create(RandomSource.WELL_19937_C);
public KolmogorovSmirnovTest(RandomSource source,
long seed) {
rng = RandomSource.create(source, seed);
final RealDistribution.Sampler sampler = new EnumeratedRealDistribution(combined).createSampler(rng);
curX = AbstractRealDistribution.sample(xLength, sampler);
curY = AbstractRealDistribution.sample(yLength, sampler);
private static void fillBooleanArrayRandomlyWithFixedNumberTrueValues(final boolean[] b, final int numberOfTrueValues, final UniformRandomProvider rng) {
final RealDistribution.Sampler sampler =
new UniformRealDistribution(-minDelta, minDelta).createSampler(RandomSource.create(RandomSource.JDK, 100));
jitter(x, sampler);
jitter(y, sampler);
private static void jitter(double[] data, RealDistribution.Sampler sampler) {
final double d = sampler.sample();
data[i] += d;
final NormalDistribution standardNormal = new NormalDistribution(0, 1);
final FDistribution fdist = new FDistribution(a.dfbg, a.dfwg);
final FDistribution fdist = new FDistribution(a.dfbg, a.dfwg);
final TDistribution distribution = new TDistribution(n - 1);
final TDistribution distribution = new TDistribution(degreesOfFreedom);
final TDistribution distribution = new TDistribution(degreesOfFreedom);
final NormalDistribution standardNormal = new NormalDistribution(0, 1);
shuffle(list, start, pos, RandomSource.create(RandomSource.WELL_19937_C));
UniformRandomProvider rng) {
target = new UniformIntegerDistribution(start, i).createSampler(rng).sample();
target = new UniformIntegerDistribution(i, start).createSampler(rng).sample();
UniformRandomProvider rng) {
shuffle(list, RandomSource.create(RandomSource.WELL_19937_C));
private static UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L); // "tol" depends on the seed.
final RealDistribution.Sampler distX =
new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final double interpolationTolerance = 1e-13;
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234567L);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1234568L);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distZ = new UniformRealDistribution(zValues[0], zValues[zValues.length - 1]).createSampler(rng);
TestUtils.assertEquals(Complex.ONE,
ComplexUtils.polar2Complex(1, 0), 10e-12);
TestUtils.assertEquals(Complex.ZERO,
ComplexUtils.polar2Complex(0, 1), 10e-12);
TestUtils.assertEquals(Complex.ZERO,
ComplexUtils.polar2Complex(0, -1), 10e-12);
TestUtils.assertEquals(Complex.I,
ComplexUtils.polar2Complex(1, pi/2), 10e-12);
TestUtils.assertEquals(Complex.I.negate(),
ComplexUtils.polar2Complex(1, -pi/2), 10e-12);
r += i;
double theta = 0;
for (int j =0; j < 20; j++) {
theta += pi / 6;
TestUtils.assertEquals(altPolar(r, theta),
ComplexUtils.polar2Complex(r, theta), 10e-12);
theta = -2 * pi;
for (int j =0; j < 20; j++) {
theta -= pi / 6;
TestUtils.assertEquals(altPolar(r, theta),
ComplexUtils.polar2Complex(r, theta), 10e-12);
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(nan, nan));
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(1, negInf));
TestUtils.assertSame(Complex.NaN,
ComplexUtils.polar2Complex(inf, negInf));
TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));
TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));
TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));
TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));
public void testConvertToComplex() {
final Complex[] complex = ComplexUtils.convertToComplex(real);
distribution = new AbstractRealDistribution() {
distribution = new AbstractRealDistribution() {
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_1024_A,
123456789L);
final BetaDistribution betaDistribution = new BetaDistribution(alpha, beta);
final double[] observed = AbstractRealDistribution.sample(numSamples,
betaDistribution.createSampler(rng));
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_A,
123456789L);
final BetaDistribution betaDistribution = new BetaDistribution(alpha, beta);
final RealDistribution.Sampler sampler = betaDistribution.createSampler(rng);
final double[] observed = AbstractRealDistribution.sample(numSamples, sampler);
new KolmogorovSmirnovTest(RandomSource.JDK, 3448845623L).kolmogorovSmirnovTest(betaDistribution, observed) < level);
public void testSampler() {
final double value = 12.345;
final RealDistribution.Sampler sampler = new ConstantRealDistribution(value).createSampler(null);
Assert.assertEquals(value, sampler.sample(), 0);
final IntegerDistribution.Sampler sampler
= testDistribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C,
-334759360)); // fixed seed
final int[] samples = AbstractIntegerDistribution.sample(n, sampler);
final RealDistribution.Sampler sampler =
testDistribution.createSampler(RandomSource.create(RandomSource.WELL_1024_A, -123456789));
final double[] samples = AbstractRealDistribution.sample(n, sampler);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_512_A);
Assert.assertEquals(1, new EnumeratedDistribution<Object>(list).createSampler(rng).sample(1).length);
final IntegerDistribution.Sampler dist =
new HypergeometricDistribution(N, m, n).createSampler(RandomSource.create(RandomSource.WELL_512_A));
final IntegerDistribution.Sampler sampler =
distribution.createSampler(RandomSource.create(RandomSource.WELL_512_A,
1000));
int[] sample = AbstractIntegerDistribution.sample(sampleSize, sampler);
return new LevyDistribution(1.2, 0.4);
public void testSampler() {
final RealDistribution.Sampler sampler =
distribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 123456789L));
final double[] sample = AbstractRealDistribution.sample(sampleSize, sampler);
final double[] quartiles = TestUtils.getDistributionQuartiles(distribution);
final double[] expected = {250, 250, 250, 250};
final long[] counts = new long[4];
final long seed = 123;
RandomSource source = RandomSource.WELL_512_A;
RealDistribution.Sampler origSampler = distribution.createSampler(RandomSource.create(source, seed));
RealDistribution.Sampler clonedSampler = cloned.createSampler(RandomSource.create(source, seed));
Assert.assertEquals(origSampler.sample(),
clonedSampler.sample(),
0d);
IntegerDistribution.Sampler distribution =
new ZipfDistribution(numPoints, exponent).createSampler(RandomSource.create(RandomSource.WELL_19937_C, 6));
int[] sample = AbstractIntegerDistribution.sample(sampleSize, distribution);
final double actual = ZipfRejectionInversionSampler.helper1(testValue) * testValue;
TestUtils.assertRelativelyEquals(expected, actual, tol);
final double actual = ZipfRejectionInversionSampler.helper2(testValue) * testValue;
TestUtils.assertRelativelyEquals(expected, actual, tol);
final IntegerDistribution.Sampler distribution =
new ZipfDistribution(numPoints, exponent).createSampler(RandomSource.create(RandomSource.WELL_1024_A));
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);
final RealDistribution.Sampler dist = new NormalDistribution(0, measurementNoise).createSampler(rng);
final RealDistribution.Sampler rng
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
final RealDistribution.Sampler rng
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784253L));
final long seed = 59321761412L;
private final RealDistribution.Sampler cX;
private final RealDistribution.Sampler cY;
private final RealDistribution.Sampler tP;
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_44497_B, seed);
cX = new NormalDistribution(x, xSigma).createSampler(rng);
cY = new NormalDistribution(y, ySigma).createSampler(rng);
tP = new UniformRealDistribution(0, MathUtils.TWO_PI).createSampler(rng);
private final RealDistribution.Sampler x;
private final RealDistribution.Sampler error;
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_44497_B, seed);
error = new NormalDistribution(0, sigma).createSampler(rng);
x = new UniformRealDistribution(lo, hi).createSampler(rng);
RealDistribution.Sampler dist 
= new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
RealDistribution.Sampler dist 
= new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
RealDistribution.Sampler dist
= new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
private final UniformRandomProvider random;
this(cityList, numNeuronsPerCity, RandomSource.createLong());
random = RandomSource.create(RandomSource.WELL_1024_A, seed);
final RealDistribution u = new UniformRealDistribution(-0.05 * radius, 0.05 * radius);
FeatureInitializerFactory.randomize(u.createSampler(random),
FeatureInitializerFactory.function(f1, 0, 1)),
FeatureInitializerFactory.randomize(u.createSampler(random),
FeatureInitializerFactory.function(f2, 0, 1))
public void testNextFail1() {
empiricalDistribution.createSampler(RandomSource.create(RandomSource.JDK)).sample();
Assert.fail("Expecting MathIllegalStateException");
} catch (MathIllegalStateException ex) {
public void testNextFail2() {
empiricalDistribution2.createSampler(RandomSource.create(RandomSource.JDK)).sample();
RealDistribution.Sampler sampler
= empiricalDistribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
stats.addValue(sampler.sample());
RealDistribution.Sampler sampler
= empiricalDistribution2.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
stats.addValue(sampler.sample());
RealDistribution.Sampler sampler
= dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
final double dev = sampler.sample();
RealDistribution.Sampler sampler
= dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
final double dev = sampler.sample();
RealDistribution.Sampler sampler
= dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
Assert.assertTrue(Arrays.binarySearch(values, sampler.sample()) >= 0);
RealDistribution.Sampler sampler
= dist.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
final double v = sampler.sample();
return new UniformRealDistribution(bStats.getMin(), bStats.getMax());
package org.apache.commons.math4.rng;
public class Providers32ParametricTest {
private final UniformRandomProvider generator;
public Providers32ParametricTest(ProvidersList.Data data) {
final RandomSource source = data.getSource();
final Object seed = data.getSeed();
final Object[] args = data.getArgs();
generator = RandomSource.create(source, seed, args);
public static Iterable<ProvidersList.Data[]> getList() {
return ProvidersList.list32();
public void testNextBytesChunks() {
final int[] chunkSizes = { 4, 8, 12, 16 };
final int[] chunks = { 1, 2, 3, 4, 5 };
for (int chunkSize : chunkSizes) {
for (int numChunks : chunks) {
ProvidersCommonParametricTest.checkNextBytesChunks(generator,
chunkSize,
numChunks);
package org.apache.commons.math4.rng;
public class Providers64ParametricTest {
private final UniformRandomProvider generator;
public Providers64ParametricTest(ProvidersList.Data data) {
final RandomSource source = data.getSource();
final Object seed = data.getSeed();
final Object[] args = data.getArgs();
generator = RandomSource.create(source, seed, args);
public static Iterable<ProvidersList.Data[]> getList() {
return ProvidersList.list64();
public void testNextBytesChunks() {
final int[] chunkSizes = { 8, 16, 24 };
final int[] chunks = { 1, 2, 3, 4, 5 };
for (int chunkSize : chunkSizes) {
for (int numChunks : chunks) {
ProvidersCommonParametricTest.checkNextBytesChunks(generator,
chunkSize,
numChunks);
package org.apache.commons.math4.rng;
public class ProvidersCommonParametricTest {
private final UniformRandomProvider generator;
private final RandomSource originalSource;
private final Object originalSeed;
private final Object[] originalArgs;
public ProvidersCommonParametricTest(ProvidersList.Data data) {
originalSource = data.getSource();
originalSeed = data.getSeed();
originalArgs = data.getArgs();
generator = RandomSource.create(originalSource, originalSeed, originalArgs);
public static Iterable<ProvidersList.Data[]> getList() {
return ProvidersList.list();
public void testPreconditionNextInt1() {
generator.nextInt(-1);
public void testPreconditionNextInt2() {
generator.nextInt(0);
public void testPreconditionNextLong1() {
generator.nextLong(-1);
public void testPreconditionNextLong2() {
generator.nextLong(0);
public void testPreconditionNextBytes1() {
final int size = 10;
final int num = 1;
final byte[] buf = new byte[size];
generator.nextBytes(buf, -1, num);
public void testPreconditionNextBytes2() {
final int size = 10;
final byte[] buf = new byte[size];
generator.nextBytes(buf, size, 0);
public void testPreconditionNextBytes3() {
final int size = 10;
final int offset = 2;
final byte[] buf = new byte[size];
generator.nextBytes(buf, offset, size - offset + 1);
public void testPreconditionNextBytes4() {
final int size = 10;
final int offset = 1;
final byte[] buf = new byte[size];
generator.nextBytes(buf, offset, -1);
public void testUniformNextBytesFullBuffer() {
final int size = 23;
final byte[] buffer = new byte[size];
final Runnable nextMethod = new Runnable() {
public void run() {
generator.nextBytes(buffer);
};
final double smallAlpha = 1e-3;
Assert.assertTrue(isUniformNextBytes(buffer, 0, size, nextMethod, smallAlpha));
public void testUniformNextBytesPartialBuffer() {
final int totalSize = 1234;
final int offset = 567;
final int size = 89;
final byte[] buffer = new byte[totalSize];
final Runnable nextMethod = new Runnable() {
public void run() {
generator.nextBytes(buffer, offset, size);
};
final double smallAlpha = 1e-3;
Assert.assertTrue("Test can fail randomly due to sampling error with probability " + smallAlpha,
isUniformNextBytes(buffer, offset, offset + size, nextMethod, smallAlpha));
final double largeAlpha = 0.5;
Assert.assertFalse(isUniformNextBytes(buffer, 0, offset, nextMethod, largeAlpha));
Assert.assertFalse(isUniformNextBytes(buffer, offset + size, buffer.length, nextMethod, largeAlpha));
public void testUniformNextIntegerInRange() {
checkNextIntegerInRange(4, 1000);
checkNextIntegerInRange(10, 1000);
checkNextIntegerInRange(12, 1000);
checkNextIntegerInRange(31, 1000);
checkNextIntegerInRange(32, 1000);
checkNextIntegerInRange(2016128993, 1000);
checkNextIntegerInRange(1834691456, 1000);
checkNextIntegerInRange(869657561, 1000);
checkNextIntegerInRange(1570504788, 1000);
public void testUniformNextLongInRange() {
checkNextLongInRange(4, 1000);
checkNextLongInRange(11, 1000);
checkNextLongInRange(19, 1000);
checkNextLongInRange(31, 1000);
checkNextLongInRange(32, 1000);
final long q = Long.MAX_VALUE / 4;
checkNextLongInRange(q, 1000);
checkNextLongInRange(2 * q, 1000);
checkNextLongInRange(3 * q, 1000);
public void testUniformNextFloat() {
final double[] sample = new double[1000];
for (int i = 0; i < sample.length; i++) {
sample[i] = generator.nextFloat();
final RealDistribution uniformDistribution = new UniformRealDistribution(0, 1);
final KolmogorovSmirnovTest ks = new KolmogorovSmirnovTest();
Assert.assertFalse(generator.toString(),
ks.kolmogorovSmirnovTest(uniformDistribution, sample, 0.01));
public void testUniformNextDouble() {
final double[] sample = new double[1000];
for (int i = 0; i < sample.length; i++) {
sample[i] = generator.nextDouble();
final RealDistribution uniformDistribution = new UniformRealDistribution(0, 1);
final KolmogorovSmirnovTest ks = new KolmogorovSmirnovTest();
Assert.assertFalse(generator.toString(),
ks.kolmogorovSmirnovTest(uniformDistribution, sample, 0.01));
public void testUniformNextIntRandomWalk() {
final Callable<Boolean> nextMethod = new Callable<Boolean>() {
public Boolean call() throws Exception {
return generator.nextInt() >= 0;
};
checkRandomWalk(1000, nextMethod);
public void testUniformNextLongRandomWalk() {
final Callable<Boolean> nextMethod = new Callable<Boolean>() {
public Boolean call() throws Exception {
return generator.nextLong() >= 0;
};
checkRandomWalk(1000, nextMethod);
public void testUniformNextBooleanRandomWalk() {
final Callable<Boolean> nextMethod = new Callable<Boolean>() {
public Boolean call() throws Exception {
return generator.nextBoolean();
};
checkRandomWalk(1000, nextMethod);
public void testUnsupportedSeedType() {
final byte seed = 123;
RandomSource.create(originalSource, seed, originalArgs);
public void testAllSeedTypes() {
final Integer intSeed = -12131415;
final Long longSeed = -1213141516171819L;
final int[] intArraySeed = new int[] { 0, 11, -22, 33, -44, 55, -66, 77, -88, 99 };
final long[] longArraySeed = new long[] { 11111L, -222222L, 3333333L, -44444444L };
final Object[] seeds = new Object[] { intSeed, longSeed, intArraySeed, longArraySeed };
int nonNativeSeedCount = 0;
int seedCount = 0;
for (Object s : seeds) {
++seedCount;
if (!(originalSource.isNativeSeed(s))) {
++nonNativeSeedCount;
Assert.assertNotEquals(intSeed, originalSeed);
RandomSource.create(originalSource, s, originalArgs);
Assert.assertEquals(4, seedCount);
Assert.assertEquals(3, nonNativeSeedCount);
public void testStateSettable() {
final int n = 10000;
final RandomSource.State state = RandomSource.saveState(generator);
final List<Number> listOrig = makeList(n);
final List<Number> listDiscard = makeList(n);
Assert.assertTrue(listDiscard.size() != 0);
Assert.assertFalse(listOrig.equals(listDiscard));
RandomSource.restoreState(generator, state);
final List<Number> listReplay = makeList(n);
Assert.assertFalse(listOrig == listReplay);
Assert.assertTrue(listOrig.equals(listReplay));
public void testSerializedState()
throws IOException,
ClassNotFoundException {
final int n = 100;
final RandomSource.State stateOrig = RandomSource.saveState(generator);
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(stateOrig);
final List<Number> listOrig = makeList(n);
final List<Number> listDiscard = makeList(n);
Assert.assertTrue(listDiscard.size() != 0);
Assert.assertFalse(listOrig.equals(listDiscard));
ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
ObjectInputStream ois = new ObjectInputStream(bis);
final RandomSource.State stateNew = (RandomSource.State) ois.readObject();
Assert.assertTrue(stateOrig != stateNew);
RandomSource.restoreState(generator, stateNew);
final List<Number> listReplay = makeList(n);
Assert.assertFalse(listOrig == listReplay);
Assert.assertTrue(listOrig.equals(listReplay));
public void testStateWrongClass() {
RandomSource.restoreState(generator, new RandomSource.State() {});
public void testStateWrongSize() {
Assume.assumeTrue(generator.toString().indexOf("JDKRandom") == -1);
final RandomSource.State state = RandomSource.saveState(new DummyGenerator());
RandomSource.restoreState(generator, state);
private List<Number> makeList(int n) {
final List<Number> list = new ArrayList<Number>();
for (int i = 0; i < n; i++) {
list.add(generator.nextInt());
list.add(generator.nextInt(21));
list.add(generator.nextInt(436));
list.add(generator.nextLong());
list.add(generator.nextLong(157894));
list.add(generator.nextLong(5745833));
list.add(generator.nextFloat());
list.add(generator.nextFloat());
list.add(generator.nextDouble());
list.add(generator.nextDouble());
list.add(generator.nextDouble());
return list;
private boolean isUniformNextBytes(byte[] buffer,
int first,
int last,
Runnable nextMethod,
double alpha) {
final int sampleSize = 100000;
final int byteRange = 256;
final int byteRangeOffset = 128;
final long[] count = new long[byteRange];
final double[] expected = new double[byteRange];
for (int i = 0; i < byteRange; i++) {
expected[i] = sampleSize / (double) byteRange;
for (int k = 0; k < sampleSize; k++) {
nextMethod.run();
for (int i = first; i < last; i++) {
final byte b = buffer[i];
++count[b + byteRangeOffset];
} catch (Exception e) {
throw new RuntimeException("Unexpected");
final boolean reject = new ChiSquareTest().chiSquareTest(expected, count, alpha);
return !reject;
private void checkRandomWalk(int sampleSize,
Callable<Boolean> nextMethod) {
int walk = 0;
for (int k = 0; k < sampleSize; ++k) {
if (nextMethod.call()) {
++walk;
} else {
--walk;
} catch (Exception e) {
throw new RuntimeException("Unexpected");
final double actual = FastMath.abs(walk);
final double max = FastMath.sqrt(sampleSize) * 2.576;
Assert.assertTrue(generator + ": Walked too far astray: " + actual +
" > " + max +
" (test will fail randomly about 1 in 100 times)",
actual < max);
private void checkNextIntegerInRange(final int max,
int sampleSize) {
final Callable<Integer> nextMethod = new Callable<Integer>() {
public Integer call() throws Exception {
return generator.nextInt(max);
};
checkNextInRange(max, sampleSize, nextMethod);
private void checkNextLongInRange(final long max,
int sampleSize) {
final Callable<Long> nextMethod = new Callable<Long>() {
public Long call() throws Exception {
return generator.nextLong(max);
};
checkNextInRange(max, sampleSize, nextMethod);
private <T extends Number> void checkNextInRange(T max,
int sampleSize,
Callable<T> nextMethod) {
final ChiSquareTest testStatistic = new ChiSquareTest();
final int numTests = 1000;
final long n = max.longValue();
long[] binUpperBounds;
if (n < 32) {
binUpperBounds = new long[(int) n];
for (int k = 0; k < n; k++) {
binUpperBounds[k] = k + 1;
} else {
final int numBins = 10;
binUpperBounds = new long[numBins];
final long step = n / numBins;
for (int k = 0; k < numBins; k++) {
binUpperBounds[k] = (k + 1) * step;
int numFailures = 0;
final int binCount = binUpperBounds.length;
final long[] observed = new long[binCount];
final double[] expected = new double[binCount];
long previousUpperBound = 0;
for (int k = 0; k < binCount; k++) {
final long range = binUpperBounds[k] - previousUpperBound;
expected[k] = sampleSize * (range / (double) n);
previousUpperBound = binUpperBounds[k];
for (int i = 0; i < numTests; i++) {
Arrays.fill(observed, 0);
for (int j = 0; j < sampleSize; j++) {
final long value = nextMethod.call().longValue();
Assert.assertTrue("Range", (value >= 0) && (value < n));
for (int k = 0; k < binCount; k++) {
if (value < binUpperBounds[k]) {
++observed[k];
break;
} catch (Exception e) {
throw new RuntimeException("Unexpected");
if (testStatistic.chiSquareTest(expected, observed) < 0.01) {
++numFailures;
if ((double) numFailures / (double) numTests > 0.02) {
Assert.fail(generator + ": Too many failures for n = " + n +
" (" + numFailures + " out of " + numTests + " tests failed)");
int chunkSize,
int numChunks) {
final byte[] b1 = new byte[chunkSize * numChunks];
final byte[] b2 = new byte[chunkSize];
final RandomSource.State state = RandomSource.saveState(rng);
rng.nextBytes(b1);
RandomSource.restoreState(rng, state);
for (int i = 0; i < numChunks; i++) {
rng.nextBytes(b2);
final byte[] b3 = new byte[chunkSize];
System.arraycopy(b1, b1.length - b3.length, b3, 0, b3.length);
Assert.assertArrayEquals("chunkSize=" + chunkSize + " numChunks=" + numChunks,
b2, b3);
class DummyGenerator extends org.apache.commons.math4.rng.internal.source32.IntProvider {
private int state;
public int next() {
return 4; // https://www.xkcd.com/221/
protected byte[] getStateInternal() {
return NumberFactory.makeByteArray(state);
protected void setStateInternal(byte[] s) {
state = NumberFactory.makeInt(s);
package org.apache.commons.math4.rng;
public class ProvidersList {
private static final List<Data[]> LIST = new ArrayList<>();
private static final List<Data[]> LIST32 = new ArrayList<>();
private static final List<Data[]> LIST64 = new ArrayList<>();
add(LIST32, RandomSource.JDK, -122333444455555L);
add(LIST32, RandomSource.MT, new int[] { -123, -234, -345 });
add(LIST32, RandomSource.WELL_512_A, new int[] { -23, -34, -45 });
add(LIST32, RandomSource.WELL_1024_A, new int[] { -1234, -2345, -3456 });
add(LIST32, RandomSource.WELL_19937_A, new int[] { -2123, -3234, -4345 });
add(LIST32, RandomSource.WELL_19937_C, new int[] { -123, -234, -345, -456 });
add(LIST32, RandomSource.WELL_44497_A, new int[] { -12345, -23456, -34567 });
add(LIST32, RandomSource.WELL_44497_B, new int[] { 123, 234, 345 });
add(LIST32, RandomSource.ISAAC, new int[] { 123, -234, 345, -456 });
add(LIST64, RandomSource.SPLIT_MIX_64, -988777666655555L);
add(LIST64, RandomSource.XOR_SHIFT_1024_S, new long[] { 123456L, 234567L, -345678L });
add(LIST64, RandomSource.TWO_CMRES, 55443322);
add(LIST64, RandomSource.TWO_CMRES_SELECT, -987654321, 5, 8);
add(LIST64, RandomSource.MT_64, new long[] { 1234567L, 2345678L, -3456789L });
LIST.addAll(LIST32);
LIST.addAll(LIST64);
} catch (Exception e) {
System.err.println("Unexpected exception while creating the list of generators: " + e);
e.printStackTrace(System.err);
throw e;
private ProvidersList() {}
private static void add(List<Data[]> list,
RandomSource source,
Object ... data) {
final RandomSource rng = source;
final Object seed = data.length > 0 ? data[0] : null;
final Object[] args = data.length > 1 ? Arrays.copyOfRange(data, 1, data.length) : null;
list.add(new Data[] { new Data(rng, seed, args) });
public static Iterable<Data[]> list() {
return Collections.unmodifiableList(LIST);
public static Iterable<Data[]> list32() {
return Collections.unmodifiableList(LIST32);
public static Iterable<Data[]> list64() {
return Collections.unmodifiableList(LIST64);
public static class Data {
private final RandomSource source;
private final Object seed;
private final Object[] args;
public Data(RandomSource source,
Object seed,
Object[] args) {
this.source = source;
this.seed = seed;
this.args = args;
public RandomSource getSource() {
return source;
public Object getSeed() {
return seed;
public Object[] getArgs() {
return args == null ? null : Arrays.copyOf(args, args.length);
public String toString() {
return source.toString() + " seed=" + seed + " args=" + Arrays.toString(args);
package org.apache.commons.math4.rng.internal.source32;
public final class ISAACRandomTest {
private static final int[] SEED_1 = {
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
};
private static final int[] SEED_2 = {
0x61b12894, 0x4a43da95, 0x03e4d8c5, 0xd92e174f, 0xe8998d71, 0x0ecaaa89, 0xaba8a61d, 0xcfd457fc,
0xbf25f0a7, 0xe05b20a9, 0xdc744513, 0x9a3eb193, 0x1b69542b, 0xedb0890d, 0xca6b233d, 0xfcabf357,
0x297e95f0, 0x1a6c456f, 0x0e3738b0, 0x1c0517f2, 0xcfd105bd, 0x3b7c39eb, 0x141804e9, 0x8a13a0d1,
0x3e57cf5c, 0x35471206, 0x00115ef6, 0x3424ec23, 0x2a6a63a7, 0x4cecb3e8, 0xecb4d341, 0x63d25ac1,
0x8b68eafd, 0x0eca65b4, 0xd8354668, 0xb37b1ff8, 0x82e80ce3, 0x4c212f9c, 0x58d82d5f, 0x47f36348,
0x5bd88987, 0xf77ac66e, 0x75ff93ee, 0xef763453, 0x9705f8b6, 0x64e44649, 0x84f03338, 0x902120e9,
0x5350212e, 0x34f466f8, 0x97f96d0e, 0x7f1db8f0, 0x15879833, 0xefee14b4, 0xda25520a, 0x81c0dd7c,
0xa20bb729, 0x2fd76844, 0x1b522548, 0xf394565d, 0xabff5f1b, 0x38eaf2e7, 0x364a6ccf, 0x8ed5e169,
0xe76aae18, 0x0e4c0b62, 0x68356792, 0x8bc4aa83, 0x31546e69, 0xa6d04441, 0x2abef1df, 0xa40a164e,
0x8a8d00ba, 0x32b38dba, 0x6f66a7c6, 0x493b0c84, 0xd86846f0, 0x50d50178, 0x26a7e67c, 0x97802153,
0xf35f4ad3, 0x4b54b54e, 0x35bcaef1, 0xc3ed09d6, 0xc127bc55, 0xb2e34ea4, 0x8d674133, 0xed82f03d,
0xa8443b28, 0x30bf4bd9, 0x6748419c, 0x155eb313, 0xb17c85da, 0xcd0d8014, 0xf1e95740, 0x5e769ed2,
0xf8fa5819, 0x3bd0d93a, 0xa46eaf3f, 0x90f5ae2c, 0x912aa83d, 0x66995d3d, 0x8359b2a9, 0x64534b93,
0x1fa38094, 0x89fde50c, 0xef925ef5, 0x4edf2287, 0xc6e82b2b, 0x99812c32, 0x53f6fe01, 0xf104263f,
0xbc5d8b8e, 0x6f23f102, 0xb6cc174d, 0xb47b2421, 0xdb083f26, 0xd67a1f25, 0x4f4b0c50, 0x86fca924,
0x442036ba, 0x0d7dba08, 0xf6d89c1e, 0x65c9e28e, 0xd689fafc, 0x47f7ae9b, 0x3cb86674, 0x798dc4ce,
0x62a2d235, 0x73912420, 0x276ef9b4, 0x50deb689, 0x40b6b744, 0x84d79856, 0x86e5f0c6, 0x835a552b,
0xeb73ff95, 0xe428e392, 0x1d60bf15, 0x9ad09e35, 0x783e60ae, 0xb42feb61, 0x028a0343, 0x90febcfc,
0xdffb01c8, 0x1087ab1e, 0x84d8a8f9, 0xe5433763, 0x897548cc, 0xb4075ece, 0xd0a5a727, 0x0a84da19,
0x0f33964b, 0x5634a097, 0xb7cbac77, 0xe50340eb, 0x93f0ce63, 0x0c743ed4, 0xf6f6f015, 0x30f74cca,
0xbb0306a7, 0x3d037943, 0x22f2979e, 0x3591b2c3, 0x9a772e24, 0x5c5812fa, 0x9e733c8a, 0xaae1c943,
0xd0b7d924, 0x56b9c463, 0xfaedb557, 0x139b7aa5, 0xe173f123, 0x2d0686a2, 0x03cd0bef, 0x4f47c01e,
0x4cf9fb83, 0xba9d433e, 0x95a620d5, 0x62b67429, 0xe836067d, 0x606bc5f7, 0x36af81e2, 0xae0b8b30,
0x38ffe5fa, 0xb548228b, 0xc2a25bcb, 0x4ba139ee, 0xab214ad7, 0x66ef4f50, 0x5f8787fa, 0xcb5982b1,
0xdbb48ff8, 0x14eaa914, 0xe0874168, 0x3e578246, 0x488c1c11, 0x982039a2, 0xde096b35, 0xa420fb41,
0x197a1b67, 0x16eabc59, 0x0e689585, 0x24db72b7, 0xf89878c3, 0x04a5e854, 0x3346da02, 0xb4bb6a04,
0x278a0dd4, 0x7bb6e224, 0x92e219c3, 0x595f8a33, 0xedd87ae6, 0xa313cc9f, 0x385c1d3a, 0x0a8b1db5,
0xb192379d, 0x3a0be0eb, 0xb8ba269b, 0x1f0c62a5, 0x56307342, 0x8fc9ac94, 0xec91a232, 0xa7b8d3db,
0xfbf43a60, 0xa773463e, 0x72d5a4d1, 0x8ddf1755, 0x27da39bb, 0xa8d4668a, 0xd2f3bbfc, 0xa188d6af,
0x82ed668e, 0xb45f0032, 0xcdfd4ca0, 0x14e5a80d, 0x456594bc, 0x68efcdd5, 0x7dbf1f9d, 0x74599699,
0xfc8639e8, 0x4139e791, 0x9c06921a, 0xc5121d36, 0xd15b9425, 0x0670dca7, 0xbc60c353, 0xaa49e487,
0xa7cb5854, 0xd06ddbdb, 0xcb4be0d2, 0x8391ab98, 0xc750d7bf, 0x365340b1, 0x264677c7, 0xb76075a4
};
private static final int[] EXPECTED_SEQUENCE_1 = {
0x182600f3, 0x300b4a8d, 0x301b6622, 0xb08acd21, 0x296fd679, 0x995206e9, 0xb3ffa8b5, 0x0fc99c24,
0x5f071faf, 0x52251def, 0x894f41c2, 0xcc4c9afb, 0x96c33f74, 0x347cb71d, 0xc90f8fbd, 0xa658f57a,
0xc5c29e18, 0x6249fa29, 0xbae16ffa, 0x25c871bd, 0xf4c75e24, 0x5ab3eab9, 0xac450b8f, 0x1629cfa4,
0x0016e86f, 0xf27c4d0d, 0x67648b17, 0x05c04fce, 0x44d3ff79, 0xc6acd20f, 0x472fd994, 0x842131c4,
0xead4a900, 0xc01eda0d, 0x9e604c7b, 0xfb8a0e99, 0x02e17b6f, 0xe8b4f627, 0xc7041eae, 0x42d19cd7,
0xa358eb94, 0x19ca2158, 0x6be6ce81, 0x4b90a4de, 0x26f0774d, 0x4e83930a, 0x2492d476, 0xb97ffabe,
0x675cc8ae, 0x4cfdd254, 0x5d3c00ea, 0x7bba5ead, 0x6f461810, 0xbef63eea, 0x72eb767b, 0xed6e963b,
0xb026016d, 0x17cb7ebf, 0xa7dc6e56, 0xf460bdf1, 0x1ffe0e04, 0x902b347d, 0x02c0d8ab, 0x98cb3f8b,
0x6f359a39, 0x9521825f, 0x9026d97e, 0xde342516, 0x890a740c, 0x0f2969e4, 0x2e7ea9ed, 0x394b8a4f,
0x1bdf1fd0, 0x15d565b4, 0xbaf0406d, 0x4dac20db, 0x03359832, 0xe34802d5, 0xcc5fff02, 0x0935ad6e,
0x7c53c9b2, 0xb10b5d29, 0x4fbb94be, 0xd7e48546, 0xb7cfa23c, 0x7f081c9a, 0xe099baf1, 0x9c7dc323,
0xb831ad14, 0x5b563101, 0xfa55319b, 0x060ded54, 0xc5418124, 0x765f0dba, 0x1ad3d9d5, 0x3f07ec49,
0xdd5e06c6, 0xc230e2ac, 0xc6ba1971, 0x9cc17bcc, 0x10b22a22, 0x7dfc8c7f, 0xb3310333, 0x205530ee,
0xdbf38a8f, 0x003a02f5, 0x007e96a3, 0x36658201, 0x08dfd64f, 0x6275acf3, 0x3d29669b, 0x6b2f4538,
0xb0cc336b, 0x1d3043eb, 0x1ad1d764, 0x4c655b84, 0x7a725bb2, 0xb3fc5c66, 0x80b4b915, 0xb2cbd9e4,
0x2992dfc6, 0xdf8be548, 0xb310d06e, 0x436385c6, 0x44d6e893, 0x44c4d79d, 0xe3bb2064, 0xe41ea465,
0x3ff4cc70, 0x9d21ac42, 0x672c3725, 0xa43a1d02, 0xfd84b19b, 0x5b6fb132, 0x4af40896, 0xe15000a6,
0x7cab12f6, 0x8b8e753c, 0xfb253454, 0x359ac366, 0x67822b45, 0x290a1140, 0xade6e428, 0x6095efcb,
0x99d8d9e6, 0xa5b5981d, 0x332c95d6, 0xaf5cfcab, 0x161f5ca6, 0x1844cee2, 0xffb8ab5c, 0x82fccaeb,
0x49ecf97a, 0x7a60fabd, 0xf9585a3a, 0x4eb6bd32, 0x3b347002, 0xf4930dba, 0x5d21d51e, 0x64e8e3f4,
0x52801fa8, 0x71ce907c, 0x872783a4, 0x0761dc80, 0x5c509848, 0x41ba2adc, 0x7e2f5520, 0x85c5eec2,
0x368d3d00, 0x5fc7c5f3, 0xb849d785, 0xd95f25b3, 0x79801fd5, 0xbf2443d6, 0x360d41cd, 0x651b11c0,
0x801a89ca, 0x8b9e6b94, 0xfde283c4, 0xcc5e6974, 0x2b2f4c09, 0x8b2160a8, 0xdbf57f01, 0x76aa1c4e,
0x11f0831a, 0x54713d17, 0xc99a2639, 0x4c373e7a, 0x09e6e57f, 0x71f63b07, 0x7be3f02e, 0x2c907ade,
0xe5f489f6, 0x0b0cd6da, 0xb566e14c, 0x0f955969, 0xa0e5710b, 0x80d8c2de, 0x9971e496, 0xc7efbc2f,
0x97a48e53, 0x2d845c0d, 0xe1194b0e, 0xad2ba480, 0xd5253552, 0xca890b31, 0x60060afb, 0x89dae927,
0x565e2229, 0x43abc21c, 0x03dd14a5, 0xbbadd184, 0x9e979702, 0x2f659883, 0xf313adec, 0x621bd7ca,
0xb6470834, 0x4c3901c6, 0x32028bb8, 0x9ded8244, 0x66907654, 0x0a06b272, 0x4a8ec630, 0x4207d36f,
0x3e7a8b49, 0x13871be7, 0xbf7af48e, 0x3de0df39, 0x0e864542, 0x8c090a23, 0xaf90e49e, 0x97661c5e,
0x365aa66c, 0x0073e342, 0x9c8ac447, 0x6f57e7ce, 0xd5be7ffa, 0x89651d84, 0x53f78eaa, 0x8173dc04,
0xd70b1e10, 0x43c1a57b, 0x10c8a5ab, 0xed6abd62, 0x2f840e43, 0x4873d91e, 0x49f413fc, 0x5d89a1c1,
0xd3a388fc, 0x96c59cf4, 0x456f1edd, 0x3dd20023, 0xa264e933, 0xd32956e5, 0xd91aa738, 0xe76dd339,
0x7a68710f, 0x6554abda, 0x90c10757, 0x0b5e435f, 0xaf7d1fb8, 0x01913fd3, 0x6a158d10, 0xb8f6fd4a,
0xc2b9aa36, 0x96da2655, 0xfe1e42d5, 0x56e6cd21, 0xd5b2d750, 0x7229ea81, 0x5de87abb, 0xb6b9d766,
0x1e16614c, 0x3b708f99, 0x5cf824cd, 0xa4ca0cf1, 0x62d31911, 0x7cdd662f, 0xcb9e1563, 0x79ae4c10,
0x080c79ec, 0x18080c8e, 0x4a0a283c, 0x3dde9f39, 0x09c36f90, 0xad567643, 0x08294766, 0xb4415f7d,
0x5597ec0f, 0x78ffa568, 0x8bace62e, 0x4188bfcd, 0xc87c8006, 0xafa92a6d, 0x50fc8194, 0xcae8deba,
0x33f6d7b1, 0x53245b79, 0x61119a5a, 0x7e315aeb, 0xe75b41c9, 0xd2a93b51, 0xec46b0b6, 0x1ed3ff4e,
0x5d023e65, 0xadf6bc23, 0xf7f58f7b, 0xe4f3a26a, 0x0c571a7d, 0xed35e5ee, 0xeadebeac, 0x30bcc764,
0x66f1e0ab, 0x826dfa89, 0x0d9c7e7e, 0xe7e26581, 0xd5990dfb, 0x02c9b944, 0x4112d96c, 0x3ff1e524,
0xc35e4580, 0xfdfef62d, 0xb83f957a, 0xbfc7f7cc, 0xb510ce0e, 0xcd7411a7, 0x04db4e13, 0x76904b6d,
0x08607f04, 0x3718d597, 0x46c0a6f5, 0x8406b137, 0x309bfb78, 0xf7d3f39f, 0x8c2f0d55, 0xc613f157,
0x127dd430, 0x72c9137d, 0x68a39358, 0x07c28cd1, 0x848f520a, 0xdd2dc1d5, 0x9388b13b, 0x28e7cb78,
0x03fb88f4, 0xb0b84e7b, 0x14c8009b, 0x884d6825, 0x21c171ec, 0x0809e494, 0x6a107589, 0x12595a19,
0x0bb3263f, 0x4d8fae82, 0x2a98121a, 0xb00960ba, 0x6708a2bc, 0x35a124b5, 0xbccaaeed, 0x294d37e5,
0xd405ded8, 0x9f39e2d9, 0x21835c4d, 0xe89b1a3b, 0x7364944b, 0xbd2e5024, 0x6a123f57, 0x34105a8c,
0x5ad0d3b0, 0xcc033ce3, 0xd51f093d, 0x56a001e3, 0x01a9bd70, 0x8891b3db, 0x13add922, 0x3d77d9a2,
0x0e7e0e67, 0xd73f72d4, 0x917bdec2, 0xa37f63ff, 0x23d74f4e, 0x3a6ce389, 0x0606cf9f, 0xde11ed34,
0x70cc94ae, 0xcb0eee4a, 0x13edc0cb, 0xfe29661c, 0xdb6dbe96, 0xb388d96c, 0x33bc405d, 0xa6d12101,
0x2f36fa86, 0x7ded386f, 0xe6344451, 0xcd57c7f7, 0x1b0dcdc1, 0xcd49ebdb, 0x9e8a51da, 0x12a0594b,
0x60d4d5f8, 0x91c8d925, 0xe43d0fbb, 0x5d2a542f, 0x451e7ec8, 0x2b36505c, 0x37c0ed05, 0x2364a1aa,
0x814bc24c, 0xe3a662d9, 0xf2b5cc05, 0xb8b0ccfc, 0xb058bafb, 0x3aea3dec, 0x0d028684, 0x64af0fef,
0x210f3925, 0xb67ec13a, 0x97166d14, 0xf7e1cdd0, 0x5adb60e7, 0xd5295ebc, 0x28833522, 0x60eda8da,
0x7bc76811, 0xac9fe69d, 0x30ab93ec, 0x03696614, 0x15e3a5b9, 0xecc5dc91, 0x1d3b8e97, 0x7275e277,
0x538e1f4e, 0x6cb167db, 0xa7a2f402, 0x2db35dfe, 0xa8bcc22d, 0xd8c58a6a, 0x6a529b0b, 0x0fd43963,
0xafc17a97, 0x943c3c74, 0x95138769, 0x6f4e0772, 0xb143b688, 0x3b18e752, 0x69d2e4ae, 0x8107c9ff,
0xcdbc62e2, 0x5781414f, 0x8b87437e, 0xa70e1101, 0x91dabc65, 0x4e232cd0, 0x229749b5, 0xd7386806,
0xb3c3f24b, 0x60dc5207, 0x0bdb9c30, 0x1a70e7e9, 0xf37c71d5, 0x44b89b08, 0xb4d2f976, 0xb40e27bc,
0xffdf8a80, 0x9c411a2a, 0xd0f7b37d, 0xef53cec4, 0xeca4d58a, 0x0b923200, 0xcf22e064, 0x8ebfa303,
0xf7cf814c, 0x32ae2a2b, 0xb5e13dae, 0xc998f9ff, 0x349947b0, 0x29cf72ce, 0x17e38f85, 0xf3b26129,
0xd45d6d81, 0x09b3ce98, 0x860536b8, 0xe5792e1b, 0x12ad6419, 0xf5f71c69, 0xcbc8b7c2, 0x8f651659,
0xa0cc74f3, 0xd78cb99e, 0x51c08d83, 0x29f55449, 0x002ed713, 0x38a824f3, 0x57161df6, 0x7452e319,
0x25890e2e, 0xc7442433, 0x4a5f6355, 0x6a83e1e0, 0x823cedb6, 0xf1d444eb, 0x88381097, 0x5de3743e,
0x46ca4f9a, 0xd8370487, 0xedec154a, 0x433f1afb, 0xf5fad54f, 0x98db2fb4, 0xe448e96d, 0xf650e4c8,
0x4bb5af29, 0x9d855e89, 0xc54cd95b, 0x46d95ca5, 0xef73fbf0, 0xf943f672, 0x86ba527f, 0x9d8d1908,
0xf3310c92, 0x05340e15, 0x07cffad9, 0x21e2547e, 0x8c17eff0, 0xd32be060, 0x8aba3ffb, 0x94d40125,
0xc5a87748, 0x824c2009, 0x73c0e762, 0xcdfec2af, 0x0e6c51b3, 0xa86f875e, 0xbc6172c7, 0xf7f395f1,
0x3f7579b3, 0x7aa114ed, 0x165b1015, 0xd531161a, 0xe36ef5bb, 0xdc153e5f, 0x1d0cb81b, 0xceffc147,
0x6079e4ce, 0xc3142d8f, 0xa617a083, 0xb54fed6f, 0xc3c7be2c, 0x02614abf, 0x6fb5ce56, 0xd21e796c,
0x2d0985de, 0xe9f84163, 0xc1a71e3c, 0x2887d96f, 0x57c4c925, 0x05efe294, 0x88157153, 0x9a30c4e8,
0x8854a0a1, 0x02503f7d, 0x0cd6ef81, 0x1da4f25a, 0xe8fa3860, 0x32e39273, 0x4c8652d6, 0x9ab3a42f,
0x9ead7f70, 0x836d8003, 0x6cbe7935, 0x721502dd, 0x5a48755c, 0x07497cae, 0xde462f4d, 0x92f57ea7,
0x1fe26ce0, 0x27c82282, 0xd6ec2f2b, 0x80c6e402, 0xce86fdfc, 0x52649d6c, 0xc798f047, 0x45bae606,
0x891aec49, 0x66c97340, 0x9ca45e1c, 0x4286619c, 0xf5f9cc3b, 0x4e823ad3, 0xc0d5d42a, 0xaee19096,
0x3d469303, 0xfe4cb380, 0xc9cd808c, 0x37a97df6, 0x308f751f, 0x276df0b4, 0xe5fbb9c7, 0x97ca2070,
0x88412761, 0x2ce5d3d5, 0xd7b43abe, 0xa30519ad, 0x26414ff3, 0xc5bde908, 0x275ead3a, 0x26ceb003,
0xbf1bd691, 0x037464c0, 0xe24124c0, 0x81d4cc5f, 0x484525e4, 0x1c3a4524, 0x9e7e4f04, 0xe1279bff,
0x6dd1943a, 0x403dae08, 0x82846526, 0xd5683858, 0x29322d0d, 0xa949bea2, 0x74096ae7, 0x85a13f85,
0x68235b9d, 0x8ef4bce6, 0x142a6e85, 0xdad1b22a, 0xb7546681, 0x959e234e, 0xfd8650d8, 0x3e730fa8,
0x56f55a71, 0xd20adf03, 0x7cdc78a2, 0x19047c79, 0x253b1d7a, 0x4389a84a, 0x0aeb8165, 0x9c15db3b,
0xaafef5a7, 0xbe8b06b2, 0xb5fe87c0, 0xe2a4ef71, 0xd9d711f9, 0xecfcf20b, 0x80fac4c2, 0xbbb8abc4,
0x239e3b0a, 0x858129a6, 0xd97cd348, 0x8a30738a, 0xc5b71937, 0xd649a428, 0x18c1ef9a, 0x75c08a36,
0xc921f94e, 0xdf9afa29, 0x040f7074, 0x72f5972f, 0x84ef01da, 0x2cb7b77f, 0x867027d7, 0x9ce0199d,
0x71865c4c, 0x7a36af93, 0x6c48ddd8, 0x19b48fd0, 0x75f4e9e2, 0x0084cfe5, 0x63bfd4d8, 0x9783cdee,
0x64f2632c, 0xf1b20eaf, 0xcc8bfa2d, 0x39ddf25a, 0x740e0066, 0x9ddb477f, 0x12b2cfb6, 0xd067fce5,
0x1a4b6a53, 0x001cdb95, 0x12c06908, 0x531ac6bf, 0x513c1764, 0xf7476978, 0x1be79937, 0x8a8dfaa3,
0x70a1660e, 0xfb737b1a, 0x3f28ee63, 0xc1a51375, 0x84bd6dd6, 0xe4a51d21, 0xeafed133, 0x22ae0582,
0x4d678f26, 0xf854b522, 0x31907d62, 0x4b55dd99, 0x04d3658a, 0x19c1e69c, 0xc6112fdd, 0xc66699fd,
0xa0eabe6b, 0x3724d4dc, 0x0d28fe52, 0x46819e2e, 0x96f703ac, 0x21182ca3, 0x2e7b022f, 0x31860f13,
0x1956b1e5, 0xe1322228, 0x08063a85, 0x1d964589, 0x94d90481, 0x53c078f3, 0x5afb43ae, 0x1e3437f7,
0x877eb7b4, 0x5d67133c, 0xa385cb2c, 0xb82f2703, 0xef05ee06, 0x931dd7e2, 0x10d210aa, 0xe21339cc,
0x479c3a22, 0x613b67b2, 0x33c5321c, 0xa5f48ac4, 0xba5590c8, 0xeb244925, 0xd0ef3cc9, 0xd8c423fb,
0x15cfcc5c, 0x1feb2e4f, 0x36ec0ea3, 0xdbef7d9f, 0xd5ec6bf4, 0x3d3dff8a, 0x1e04a7f7, 0x8766bb54,
0x9a1d7745, 0xc79a1749, 0xb8d2486d, 0x582e3014, 0xa82427f5, 0x65dfa427, 0xbc5654c1, 0xbd086f26,
0x0451516d, 0xff4cfc35, 0x81f2864d, 0x31860f05, 0xd0638e1a, 0xb059261d, 0x3d1e9150, 0x21e2a51c,
0x82d53d12, 0x1010b275, 0x786b2908, 0x4d3cfbda, 0x94a302f4, 0x95c85eaa, 0xd7e1c7be, 0x82ac484f,
0xd24daa9a, 0x70055204, 0xbf27ef0d, 0x740ebb34, 0x47a1ff2f, 0x037e5e95, 0x3362d8d3, 0xb08c9e58,
0x7036b9a5, 0x3354197a, 0x326c9f12, 0xab99166e, 0x6c5d388b, 0xb222a768, 0x1bf121c5, 0x2ef76080,
0xb0658121, 0x8331bdd3, 0x64b5cd35, 0xc3c7fbe4, 0x576e7d5e, 0x1cbdc1b2, 0x5c54b675, 0xbffd76e3,
0x2ad7b53f, 0xe596de29, 0xc2d972db, 0xf1c92f34, 0x6af3ded6, 0xec317d66, 0x6a17bed5, 0x27750e9e,
0x8d950cb3, 0xb07688cc, 0x17a6ddd8, 0x5bf140e0, 0xed8713e0, 0x05890caa, 0xf66e4d73, 0x5ea0347f,
0xf535f2f5, 0x240c70f3, 0x5e922192, 0x8e59f944, 0x3185f7a7, 0x852dd342, 0x58c8e53b, 0x760071c5,
0xadb76f78, 0x185ab80c, 0x9d84df28, 0x4d2056da, 0x69bebccc, 0xa9fcb5f8, 0xb9d3ac81, 0xcc374aac,
0xc04e1ee9, 0x72634634, 0xb3bbf485, 0x1eb91de5, 0x5e8de602, 0x211cd561, 0xb03404e6, 0x051f3a53,
0xb263569c, 0x96cbc54f, 0x9eaf58e6, 0x32e9f0f2, 0x370f1cd9, 0x15bf840d, 0x1dbd5d06, 0xb04d214d,
0x6d1697ee, 0xc4b6fce1, 0x1b95f82d, 0x46979ca6, 0x0354cfc8, 0xd5950d3d, 0x10db605d, 0x18af3572,
0x990ec7a8, 0x2a0fe87f, 0x7937dbb8, 0xee376c86, 0xcc9f9070, 0xc953caa8, 0xd5c7c2ed, 0xee4f752e,
0x84f302f7, 0x1e08a48e, 0x44a5da35, 0x0fab83e2, 0xbb7cb9df, 0x2590afe1, 0xfef026aa, 0x83dbd643,
0xbe916d11, 0x27f7fba9, 0x82135d43, 0x6c5fa2a4, 0xe1e1370e, 0x51534581, 0x4cd9def3, 0xd94b4990,
0x74772379, 0x59264a1d, 0xc1dcdd8e, 0xed4ef1e9, 0xf29d901a, 0x68ecd0ad, 0x9ac31f92, 0x839a285e,
0x46447122, 0xc0e56c6e, 0xb09a4b83, 0xa9500b90, 0xda83c4e5, 0x4175b2f8, 0xeb4ddb4a, 0x236c6f2e,
0xeeb57a32, 0x2626e708, 0xa9d35265, 0x6ab3e9ab, 0xf12fcc1f, 0x1c317c43, 0x66c34fb3, 0xe17e58a0,
0x0295d4a1, 0x40cd40f9, 0x72700bb0, 0xd591e61e, 0x3e96b29b, 0xb50d5db3, 0xa3715dcc, 0x3405bcb4,
0x0e034d65, 0x210a4a2b, 0x7c302f2c, 0x24e8bef6, 0xa5135147, 0x0607ef80, 0x01f86c8f, 0x2c792c8a,
0x6ab73133, 0x6f436006, 0x09bf22a6, 0x1fde4622, 0x9841bd1c, 0xb23a7ad7, 0xdad579a4, 0x431229e9,
0xfa5dcb2d, 0x7da4f790, 0xa9b2c914, 0xcd191ced, 0x7a05e4aa, 0x73af1889, 0x192667b3, 0x538d4540,
0xacdbca81, 0x6b9d9e90, 0xc0462bba, 0xfcf5a7b9, 0x7b5c2904, 0x41a83c83, 0x7e69828f, 0x328a3bab,
0xdcd0f182, 0x1d113bcd, 0x1fb5c81c, 0x2d52afa0, 0x2d0c6111, 0x2a02ce14, 0x3fcd2c15, 0x54d574f9,
0xde57e605, 0x85dbb53d, 0xfc7cc003, 0x769c74d9, 0x6f834a4f, 0x79b3b87e, 0xe3d7c853, 0xa83e14b2,
0x3b1fc1ad, 0xb7dc2988, 0xb60ed652, 0xda3e3d1a, 0x5f2f680c, 0xb46e08da, 0x589b77da, 0xcef68535,
0x1c05d7a6, 0x24572da1, 0x939b02a5, 0xccd08d13, 0xdfa22970, 0xdff7581b, 0x2d5fade6, 0x5cfd3389,
0xce26cbb1, 0x376d7fd0, 0x02811e2e, 0xcc8030ab, 0xa7a4c9dc, 0x81db0ca7, 0x15a1bcef, 0x2045c6b5,
0x52c2f563, 0x6c829737, 0xb4f3384f, 0xb14d2f2b, 0xe102e00a, 0xba359973, 0x6045dd8b, 0xd0a5e531,
0xd679300f, 0xaabec63e, 0x526ad900, 0x95224f33, 0x723d6d44, 0x83584ad4, 0xa14ed869, 0x727bb03a,
0xdde37025, 0xb29d6587, 0xc3f3971d, 0x725933c2, 0x68f3eda4, 0xf73e9fdc, 0x944afd04, 0xa4c5e05f,
0x477f70ae, 0xffebfc90, 0xc21cff70, 0x84c68e32, 0xe82a3d6b, 0xba243867, 0x511c142f, 0x2062b8ac,
0x274a119f, 0x772afba2, 0x88a3974d, 0x205cf0de, 0xe45d5a2a, 0x1745056b, 0x2c8138f5, 0x982938a7,
0xfb265af9, 0x700c2cdf, 0x93e549b4, 0xb8abd353, 0xd74073e8, 0x289caf2a, 0x63e802e9, 0xc2f9adb7
};
private static final int[] EXPECTED_SEQUENCE_2 = {
0x67ae8a37, 0xa78322ea, 0xb9394933, 0x61f6e3c5, 0xbea576f1, 0xbb958f18, 0x12ce6479, 0xc593d5de,
0xdef281a0, 0x8435bb62, 0xf20b44db, 0x8a98479a, 0xbf2b8b66, 0x1080265e, 0xf0f8f12f, 0x021fa7f3,
0x81d2ed59, 0xb224a5f8, 0x0c1ff346, 0x92007ea8, 0x8fd1ce43, 0xeced69f5, 0x651fe09a, 0x45cf2c3e,
0x449b2b1e, 0x4f136be5, 0x8240cc97, 0xca979afa, 0x33b6a857, 0x7300f4f3, 0x79755d71, 0xcf11dd62,
0x916b7e04, 0x02076c0e, 0x9b4e3e68, 0x04836ed5, 0xf1b492c6, 0x887ef90c, 0x091b68f6, 0xaf7f0d3b,
0x89d7e5c1, 0x2b28fff7, 0xe6280e4f, 0x6681a805, 0xcb270bbb, 0x8e037463, 0x31a125f7, 0x0ba3c135,
0x7c2e8b3e, 0x6e21e06e, 0xc8b336ba, 0x08d677c3, 0x469fd05c, 0x71528649, 0x2024c602, 0x000e4f99,
0xb03395b1, 0x0a12d960, 0x68b15274, 0x7c415c07, 0x047c739b, 0x46658905, 0x45512a3c, 0x7f4cd2ff,
0x3d4d4ef6, 0xd7016dad, 0x6074bbf0, 0xbeaa55eb, 0xc519d326, 0x3ad349fd, 0x2fec4649, 0x14fa40ae,
0x96b51341, 0x2bf08ef1, 0xd1d374e4, 0x44168b14, 0xb01bee9b, 0x0b3f4332, 0xc799b9da, 0x76fc7dbd,
0x8c368a57, 0xe4cd2cad, 0xeeb0318a, 0xc2152908, 0x2b707a0e, 0x73457464, 0xc08e92a0, 0xfcdfca5b,
0x1320ed43, 0x333b77b9, 0x2e70948a, 0xa77d94f7, 0xbc1fb9fa, 0xa8ad15a1, 0x3c47b0f4, 0x867c4a8f,
0xb85784e0, 0x8a854e80, 0x456c8700, 0xc28f3a01, 0x415da6aa, 0x1315c6d8, 0x70a4ca70, 0xfdea940e,
0x686fbdc9, 0xda649eba, 0x661196f7, 0x795b5d27, 0xe10c78fa, 0x2fd89cf3, 0x61e850da, 0x00c49764,
0xee51d841, 0x00c18025, 0xdea163b3, 0x8b1b2080, 0x6abdd683, 0xe560c731, 0xc661b3e0, 0x23a3ff08,
0xa7579919, 0xfa443cba, 0x480bd220, 0x0a11740b, 0xb4b327c7, 0x831a0840, 0xb7c50ff3, 0x4266dff1,
0x835d0665, 0x52593038, 0x3917fb8e, 0x88c3b400, 0x05fb8823, 0xc9eaa89f, 0x6957fd17, 0x8dbcb8fe,
0xdec10c3c, 0x918d5fd8, 0x6af8619a, 0x8f472255, 0xc2f757b7, 0x9d62e804, 0x45e0e276, 0x482597d3,
0x06190214, 0x172b8501, 0xe91d7b8c, 0x4ee985fc, 0x3ecbf47a, 0xbbae5d98, 0x1f0bbdeb, 0x0d38208e,
0x6d4cb3e3, 0xa70050c4, 0xf0db408e, 0xddb6f1a7, 0x4bc4bc61, 0x90e1c1db, 0x203770dc, 0x39959247,
0xe2e0376a, 0xf70a8521, 0x81c759b2, 0x24d9915b, 0x09cc2ec3, 0x0fd0bff9, 0x58875636, 0xee78837e,
0x025a7eee, 0x4226859f, 0x85e21806, 0x9c1328bd, 0x0522fda0, 0x585441aa, 0x366f9ea0, 0xeb70934f,
0x0e394c41, 0xfa801419, 0x2b6d4c3e, 0xb09775fe, 0x3f0184ae, 0x3ace3518, 0xf80bf893, 0x9754753b,
0x78c46b93, 0x281e1918, 0x0dfcc5ee, 0xc0401601, 0xf8b11ce9, 0x9f799306, 0xb65c4232, 0x12ee4f73,
0xade72a42, 0x0ce54d71, 0xa6780e69, 0xe73bd8f9, 0xc245228f, 0x5fa2ed1a, 0x11627d1d, 0x2617ea2f,
0xd7404db6, 0x228fb877, 0xc5379535, 0xfe00008d, 0xc5f1491e, 0x1a3bdb0e, 0x9a90cc98, 0xa0abe3f5,
0xac7a0d18, 0x87bb3538, 0xa224baf7, 0xf2496ca4, 0x6a5b9bd6, 0x9a7da8d8, 0x72419677, 0xa36aec4d,
0x2a08ac0d, 0xfc4d7b21, 0x25f2aad0, 0x4f7146d4, 0xb4a603bd, 0x194e9792, 0x8f60cf1c, 0xed8ae037,
0xa47f90b1, 0x5eec55a3, 0x326c33d4, 0x6f79168f, 0xbcfc27fa, 0xd9e76d04, 0x79430e33, 0xd0c3b727,
0xd4bb06af, 0x8805066b, 0xaaef1130, 0x04958fef, 0x2e3270f4, 0xf5a8ffe8, 0x2a089c72, 0xff411bfc,
0xd6ed9552, 0x6253f5ef, 0x0c836c2f, 0xb79471b0, 0x127d177c, 0xf901cefa, 0xff75dc46, 0xde79ec4f,
0xe9f1f182, 0x9d28d8cd, 0xfcc98a94, 0x227670c2, 0x46b7c48c, 0x8fd77dcb, 0x60bc6d66, 0xe775322d,
0x0def2251, 0xf3dd14cb, 0x6c3f3468, 0x87696244, 0x10cca0be, 0x1d7fa716, 0x955b963b, 0xe53b6074,
0x77af9ec4, 0xfc856100, 0x91a06dc7, 0x8d55e3f1, 0xf8c805a3, 0xf3a1cb7a, 0xbcd51c6d, 0x301fdcdf,
0xdbcbcc54, 0x8b85fe57, 0x946d707e, 0x388a2ed4, 0xc4b93a5b, 0xd48631d2, 0xae2b4f28, 0x5b731392,
0xdf6e621e, 0xc4590c30, 0xa3a23cd5, 0xbfce9899, 0x4620cff9, 0x966c8c3f, 0x7a302556, 0x3fe549fa,
0x67533e77, 0x80250302, 0xcd899fe7, 0x694e77ea, 0x0879525d, 0xab6675e4, 0x763f8b35, 0x7684e6a1,
0x8fa35070, 0xe9fccaf1, 0x2d7195b7, 0x85b45186, 0xab799317, 0x2c84bd2c, 0xf8354c09, 0x02d96875,
0x8fdcc390, 0xf6af5aec, 0x2a584739, 0x8a1ba7e9, 0xea46f9b2, 0x98acd24f, 0xfc8a3a24, 0xa496eff9,
0x625c30ea, 0xc6ea0535, 0x3ed3b5d6, 0xffcd675d, 0x0b1719f6, 0x1b1c4e7b, 0x3206a672, 0x62fc1851,
0xa6a4c781, 0x78bbdbbe, 0x06c1c8ce, 0x5747c340, 0xfff7ab9c, 0xebaf9370, 0xf7b185a8, 0xf8309f84,
0xfa1601de, 0xf9fc8780, 0x59c2f8bd, 0xe74fcd5b, 0xf115f57f, 0xddda3332, 0x2ee56568, 0xa2243659,
0x9d6d578f, 0xbb507574, 0x95d44e0e, 0xdbdf2bc3, 0x0dc1b750, 0xc6a24241, 0x207d7115, 0xc337d024,
0x3817ef9a, 0xe9f12ccf, 0x4d67fc7d, 0x3da57a2b, 0x000e09a5, 0xe739c5a2, 0x7b7e1613, 0x23d576fe,
0x6941a210, 0x57521190, 0xdc4359c0, 0xd8eed2f8, 0x7862904f, 0xfc179a41, 0xeee2716e, 0x362cf76a,
0x0a087072, 0x3e6e2fa9, 0xaf2a0efb, 0x221d513f, 0xf054d856, 0xc3297367, 0x1c0998c8, 0xa664172f,
0xe2637c8e, 0xc17ac7d4, 0x0e041f43, 0x0d9c0ae4, 0x9346dacf, 0x7fb2a015, 0xe92276c2, 0x21478bfe,
0x119e2d0c, 0x5f76aeaf, 0xbe21aaec, 0x63174d5f, 0x13b796c3, 0x0fa0eba1, 0xe2f7277a, 0x3f555b42,
0x0215c7e4, 0x96266efa, 0x2953a4d1, 0xadfc171a, 0x396234a7, 0x560c0279, 0xefa6d2c6, 0xf48d9b5a,
0x4131c7b1, 0x9e302f70, 0x637c9f23, 0x22637330, 0x09927e76, 0x0898d1d6, 0x1b797274, 0x9ad491a2,
0xa2df3627, 0x012c3ed0, 0xc19c09d7, 0xa2fdaf56, 0x5b91f8fd, 0x3b7c49c9, 0x25694d29, 0xd7b42e9c,
0xa7be0053, 0xa91f1761, 0xd89e8b2a, 0x67846097, 0x76bd4006, 0xb8eb0712, 0x859bf877, 0xca42d70c,
0x24e80a69, 0xd92bc598, 0x55498c1e, 0x86deba8b, 0xf7c340b7, 0xa36caa12, 0x0631ddec, 0xc0146fe8,
0x2f959ef3, 0xf8400f0c, 0x58f676a0, 0x4ae4fe13, 0x9c4af056, 0x9e6f19d6, 0x12a9eb69, 0x1aeed54e,
0x34c91114, 0x97128045, 0x920d1f59, 0xffe7fbaa, 0x2db4a671, 0x6e6ff7aa, 0xd40d46bd, 0x1578f939,
0x15c5cbc6, 0xff356fd0, 0xd5d1680c, 0x5b11d14d, 0xe75541c0, 0x0fe2e2ba, 0x3ad55308, 0x8f036a69,
0xa9bfc3cd, 0x87685338, 0x510092b4, 0x1f66622a, 0x996337b2, 0xc531891f, 0x98371a93, 0xd9630100,
0x513ff133, 0xcf8381da, 0xed12e8e9, 0xe3ce7c7b, 0x8f731ab5, 0x511ba7c2, 0x9d754e87, 0x244603ac,
0xfd9985e1, 0xc1581765, 0x84e50a12, 0xa0ab0034, 0x63ee60c2, 0xdf5ab248, 0x09b42202, 0xca87f896,
0xca6ae5f0, 0xa569d829, 0x977cf29b, 0xd56a2a2f, 0x85ad1532, 0xfa2a131a, 0x00784081, 0x81f0e466,
0xebd340d3, 0xc37ad0e4, 0xd0aa6d7a, 0x36d2551f, 0xd6ff8448, 0xc7b89445, 0xa43421ad, 0x3be75400,
0x557a61ef, 0x0f519b14, 0x56503579, 0x1c8d164d, 0x0dcef35b, 0x3d9f1f2a, 0x56d056f2, 0x5d8fd4ec,
0xa481a350, 0x7cadd9c0, 0x70375ce2, 0x83263d2a, 0x5826ea3b, 0xfa523ce7, 0x50c9438b, 0x74fca95d,
0x62967ef5, 0x11fd6429, 0xcbb8e28c, 0x67fb9e81, 0xdc9e1147, 0xa29672f7, 0x1cf310f7, 0xb1e1d8e6,
0x3f862ff3, 0x6ade0327, 0xa92f3686, 0xed79f165, 0x359e1620, 0x36c68936, 0xe46fe521, 0x0c5e36b0,
0x6d9d9cdb, 0xc095eecd, 0x566dd305, 0x6d96cd36, 0x5d115a80, 0x2a9489a8, 0xdd067488, 0x73acf831,
0x7392c0f0, 0x30707838, 0x92826042, 0x67c54548, 0xf830434d, 0xebe67854, 0xaefc9a41, 0xcabf703f,
0x5242c77f, 0x1f3867a9, 0x48174739, 0x8657c39e, 0xa11247e2, 0xb4e6624d, 0xc7ffe78a, 0x1e11a841,
0x6690244b, 0x8dcc9292, 0x5ce4dcc4, 0xebcba02d, 0x2ef6503d, 0x4fb880bc, 0xb949a759, 0x7bb18a1e,
0x5973d2e8, 0x577ad8a6, 0xa9d4992e, 0x1a248a0c, 0xcc4450ed, 0x7e0178d3, 0xe98a8f3f, 0x209fb330,
0xf7bf40fc, 0x632231b3, 0x7055fdaf, 0x7719e655, 0xf8d49413, 0xc200aa04, 0x8a41183a, 0xdfa217c1,
0xcd0c165d, 0x08fec61c, 0xef608048, 0xe19fae2c, 0xedc6f3ea, 0x859a69f9, 0x5f96c76d, 0x571aec69,
0x9cfe7fa4, 0x692baf70, 0xbb143cb4, 0xe8968678, 0xfcb77411, 0x02d3268d, 0xcdc3daa3, 0x514e78e9,
0xa231a480, 0x8ac10400, 0xe19a2ca1, 0xfa790fe1, 0x808fec9c, 0xe4760960, 0x62e9d051, 0x5c4b006b,
0x22eb9703, 0x426b5907, 0xfa1cd338, 0xa3b4811a, 0xad6185c1, 0x349efbc0, 0xeee28d42, 0x02531fc5,
0xd11b2c4d, 0x5b3bf865, 0xf4823687, 0x4f92b6b7, 0xfb641c60, 0x0c526fa9, 0x42438de8, 0xd5cbf7a0,
0x54ad0d1f, 0xb4e63f09, 0x666285eb, 0xe7ec0275, 0x57e7225a, 0xafe6b0e3, 0x17431cd7, 0x33bc9204,
0x8a9cbdde, 0x94d8fe7d, 0xc943f36c, 0x1348c3c6, 0x43cf9b8c, 0x5a84ae20, 0x6d372dea, 0xdb0b3c92,
0xf0f2a72d, 0x473a1fe7, 0x062416df, 0x0a12c61c, 0x3680c102, 0x8d0189db, 0x0824325f, 0xffb97ead,
0x0d8d353f, 0x4a4e6ec2, 0x76243bb7, 0xdabfbeee, 0xcd8410d7, 0xa30f17c3, 0x2b59ceef, 0xda27f7c0,
0x791d813b, 0xc0516741, 0xb363e4ff, 0x31ddbfb7, 0x49db1590, 0xd843513c, 0x8d317a75, 0xb24387df,
0x63fd4066, 0xa0fce498, 0x7b42de97, 0x30eddc0c, 0x071ad222, 0x3a9054c4, 0x5ce35298, 0x375be64b,
0x10af32c8, 0xa999ade1, 0xfa9f4d31, 0xfbe24a2a, 0x4c92714b, 0xcce3056a, 0xa81d616a, 0x3bb49213,
0x72fd2b0e, 0x1b46d17e, 0x92159bc7, 0x7462e172, 0x4fdc3e05, 0xf309c063, 0x9133532c, 0xe62d9341,
0x681a4871, 0xb1598525, 0x498ca388, 0x96a7ea81, 0x791c8a85, 0x2a33a1e2, 0x1e6abc87, 0xb21a4878,
0x65fac53b, 0x59162ae1, 0x22858a30, 0x40f4e569, 0xe5cb0023, 0x626cd2a0, 0xfe6d8fc8, 0xbb7ed7c3,
0x9a557393, 0xd0ff5e60, 0x2a20ed9b, 0x4eaafb5a, 0xbe9425bd, 0x63620ce1, 0x31ea24ed, 0x082e426a,
0x7ff35a73, 0xa67fbaa9, 0xd2e3c5b9, 0x1a90e96a, 0x71f19184, 0xb836b88b, 0xe51fa187, 0x42576438,
0x58d28776, 0x47bd92a3, 0x09816862, 0x295138ef, 0x23ab2bb1, 0xd7c584e0, 0x1793062f, 0xcc47e852,
0xc2eb9703, 0xe6812d93, 0xa4aa4d2e, 0x7f635b79, 0xa7407b29, 0x9724c087, 0x406e08ce, 0x6bf1d8b7,
0x9ef5b815, 0xf2c6f094, 0x86269ca2, 0x17fdaa4f, 0x9b645b61, 0x701bbbeb, 0x8de7bcb7, 0xd468266a,
0x48df44ae, 0x570b08ca, 0x7a5ba43b, 0xfc927312, 0x3461a3dd, 0x0ffe5943, 0x87060375, 0x8d8afed7,
0x83d20387, 0x77eabb51, 0xf86d045b, 0x71a47537, 0xa4485ea8, 0xfd2b6ac3, 0xb4ba1fcf, 0x31dcee82,
0x8b41cdf6, 0xeacde42b, 0x02de5fbb, 0xb6311aa8, 0x1596ee5d, 0x355cc39d, 0xbe1a87c1, 0x01e1df07,
0xfe413d46, 0x5e5e13ab, 0x30233fd6, 0x99449292, 0x34955dcc, 0x1f37d394, 0xd43639bd, 0x65c98eee,
0x67b85593, 0x1660b2a1, 0xfd86e9a0, 0x33bb6e5a, 0xdd5892fb, 0xa6832091, 0xd077d216, 0x353bfe9a,
0xb4a10726, 0xca1a536e, 0xed8af6c1, 0x41d167d1, 0x5f554941, 0x93f4032a, 0x83d83ae5, 0xc8866a05,
0xc36d1e1f, 0x95a082c5, 0xd85e6cad, 0x302bc384, 0x41fb8717, 0x61221cc8, 0xce9a44cd, 0x2884ec21,
0x9712152d, 0x419e4939, 0x32367b47, 0x238ee432, 0xd27f0b8e, 0xa3eaed24, 0x1eefd0a9, 0xf38a2400,
0x72c0d4b2, 0x8bdbdec1, 0x563a2b59, 0x0d50177b, 0xb01576ef, 0x7dd9f33e, 0x7905c120, 0x461712d6,
0x78265e93, 0x54a91f0b, 0xb88eb9c0, 0x9d8997af, 0xcb1d1296, 0xfa0a3a77, 0x5bb26dd9, 0xf6da78df,
0x53b8e80c, 0xc55cdaf6, 0x871a3971, 0x0bd8d322, 0xfa9e0a9c, 0x95949e0e, 0xe94f0edb, 0x15e06b25,
0x8b3e34cc, 0x980261a9, 0x3a8fe440, 0xc72330aa, 0xbff5c8b6, 0x486a08e6, 0x6b3f0668, 0x53c90761,
0x1dc2374b, 0xba623bb6, 0x720d9fff, 0x8454fada, 0x29f09563, 0x6512330e, 0x84370042, 0xda55c14b,
0xe6397b27, 0xdb03bcc7, 0xd6e27986, 0x483ad4f2, 0xe0e2c39a, 0x459e6792, 0x03c120ec, 0x13df7847,
0xc3ee77e1, 0xbcee7cd4, 0xdb3734ec, 0x0e19ebb2, 0x1501517a, 0x815190f7, 0xea30ba2c, 0xed58523c,
0x9dc64c08, 0x58d8753f, 0x1fa771c5, 0x7721fb09, 0xc64d1f60, 0xf407dc18, 0x6fdb1e33, 0x89abccb8,
0x2fab8715, 0xd8ee352e, 0x41bfa764, 0xda0267ee, 0x65794080, 0xe3095d65, 0x08e2148b, 0x173103b5,
0x55673978, 0x8d76b213, 0x6ed42e4b, 0xbe589395, 0xcf4c4d8a, 0xd331b237, 0x0af2f4cb, 0x202be7fa,
0x2e87bc27, 0x140a95df, 0xa0d1ef7e, 0x1031da30, 0x630f3ea6, 0x0e3b0991, 0xba7c0462, 0xca8a192c,
0x668417e2, 0x2c6e8ec5, 0x3f2e4372, 0x310927e9, 0xa87b5f4e, 0x21e3f285, 0x66aab4be, 0x96804f73,
0x097c363b, 0x76445811, 0xaf92fb77, 0x660010b7, 0x3ff5abbb, 0xdaa505d0, 0x17dc3488, 0x45dac66a,
0xa834d6eb, 0xacf0641f, 0x05576174, 0x28bf1858, 0x08829e92, 0xd3c5d530, 0x6acd00b2, 0xf36c0645,
0x4385cae7, 0x93b11f88, 0x3dfe1da7, 0x2d5df9d8, 0xd51d498f, 0x1d122b84, 0x2ca7619f, 0x670fba3a,
0xa59f3019, 0xd25ade01, 0x43ef2f88, 0x05cf6af4, 0x6fc3b5e0, 0x305a309e, 0xb7bce57b, 0x49c55693,
0xd59bd6d0, 0xdf13274c, 0xa5640917, 0xb8e88520, 0xf81fb865, 0x245967cf, 0x64420112, 0x97720fd0,
0x0ef913f8, 0x9fcf14f4, 0x99a86a60, 0x150ae075, 0x1b4be51e, 0x12fe7368, 0x23781feb, 0x3657b0c3,
0x90f84f92, 0x082f626d, 0xf057cef1, 0xf04fc2c1, 0x8767f311, 0x240ab838, 0x160564c0, 0x96f4460d,
0x2c7e5c83, 0xb44e6da1, 0x43f86ae1, 0xe3afdf03, 0x34173462, 0x197d8030, 0xb02d6ae7, 0x0cec076c,
0x0fb9d05e, 0x1fa74d99, 0x03f9636e, 0x03afa44d, 0x79ceb46c, 0x8b9e3158, 0xad87d846, 0xaf794612,
0xdd00ae31, 0xde8d63de, 0x229c5e66, 0x2df46e14, 0x3cbb35d1, 0x9832a55b, 0xaff3c01c, 0xaf4cc2be,
0x05095c2b, 0xee6be44f, 0x7b9bd378, 0x09a5f11f, 0xfddc340a, 0x010da0fa, 0x60874e63, 0x9f03a38b,
0xddfe1c05, 0x8dadcc16, 0x6df97114, 0xe0779adc, 0x8de82987, 0x83cca69c, 0x38b19e7c, 0xebc30d07,
0xb36f46cc, 0xee4d1453, 0x7522c310, 0x3a43d376, 0xab400f15, 0x4fedfa99, 0x02e7323e, 0x4c57f680,
0xe4190ae5, 0x6a5bba49, 0xd3c223d8, 0x1b87ab96, 0xaef4795f, 0xf457cd2d, 0x2bae8689, 0xa229c48f,
0x41bd5e74, 0x25cb3da8, 0xfd47e4d0, 0x0a241ffc, 0x16c0dba7, 0x6f1469fd, 0x810c16da, 0x66a7b33c,
0xe6c9e001, 0x9ccefde6, 0xd24f7adc, 0x1bcc8980, 0x37084252, 0xb779d5cd, 0x52e456d0, 0x313ba4de,
0xffb09943, 0x0e9d4e1f, 0x5a3c51ac, 0x6f055f04, 0xb2ac9a26, 0xb7fac64f, 0x27cc0c8d, 0x342bbac3
};
public void testReference1() {
final ISAACRandom isaacRandom = new ISAACRandom(SEED_1);
final int[] actualSequence = getActualSequence(isaacRandom);
Assert.assertArrayEquals(EXPECTED_SEQUENCE_1, actualSequence);
public void testReference2() {
final ISAACRandom isaacRandom = new ISAACRandom(SEED_2);
final int[] actualSequence = getActualSequence(isaacRandom);
Assert.assertArrayEquals(EXPECTED_SEQUENCE_2, actualSequence);
private int[] getActualSequence(ISAACRandom isaacRandom) {
final int[] actualSequence = new int[1024];
for (int i = 0; i < actualSequence.length; i++) {
actualSequence[i] = isaacRandom.nextInt();
return actualSequence;
package org.apache.commons.math4.rng.internal.source32;
public class JDKRandomTest {
public void testReferenceCode() {
final long refSeed = -1357111213L;
final JDKRandom rng = new JDKRandom(refSeed);
final Random jdk = new Random(refSeed);
final int numRepeats = 1000;
for (int r = 0; r < numRepeats; r++) {
Assert.assertEquals(r + " nextInt", jdk.nextInt(), rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class MersenneTwisterTest {
public void testMakotoNishimura() {
final MersenneTwister rng = new MersenneTwister(new int[] { 0x123, 0x234, 0x345, 0x456 });
final int[] refInt = {
0x3fa23623, 0x38fa935f, 0x1c72dc38, 0xf4cf2f5f, 0xfc110f5c, 
0xc75677aa, 0xc802152f, 0xd9155da, 0x304aacd1, 0x9a73f337, 
0x989a7a43, 0xc1483a50, 0x268c922d, 0x582fa6ba, 0xfd0cc411, 
0x44267b5e, 0xe64aeede, 0xbffce512, 0x69b7263d, 0x43df2416, 
0x54c06fe4, 0x4bb1636f, 0xaa772159, 0x692b9302, 0xe6f6290f, 
0xec59faf1, 0x453050b, 0x8e18c8c2, 0x9afc3045, 0xc0f8369c, 
0xa6784b64, 0x2b3baca5, 0x241c69b2, 0x102b153e, 0x2aa0204a, 
0xc4937ab0, 0x4edada28, 0xfc1a4165, 0x5327669e, 0xdeaa3938, 
0x7d45d251, 0xde57ac80, 0xafdc0e1a, 0x630eea2f, 0xac9709be, 
0x8d4b2277, 0x3bd93aca, 0x85eff969, 0x7dd7008b, 0xc0f5f7ef, 
0xf354dbb7, 0xd19a749, 0x9245ad51, 0xdd1bbe7b, 0x31ce56ca, 
0x8fc36f3b, 0xa307eaa6, 0x2d16123c, 0x81a710e8, 0x6fb0ece0, 
0xa4a8ed5d, 0xf81025ee, 0xc7bdb7cc, 0xacbd297, 0xc2e69738, 
0x2e414667, 0x8436773b, 0xb2eb0184, 0x6f458090, 0x7f2c9350, 
0x213f68e, 0x470b7a6d, 0xb8e983ba, 0xadd68783, 0x3c580a4a, 
0x8239e155, 0xfdc2c299, 0xacd2d0b2, 0xe39381d6, 0xb4a5ad7e, 
0x4c6c3bdd, 0x1908bf3a, 0x8aaa5fe5, 0xa3674b65, 0x4c2d0c3f, 
0xdf2ba5a5, 0x1032fcf8, 0x9c8a9da2, 0x989f1b17, 0xb62684e4, 
0xfc56810e, 0x4937dc5d, 0xd6502fba, 0x403fad7e, 0x8ecf04fa, 
0x6e622af6, 0xb3a12932, 0x7735265b, 0xb3397c02, 0x3e92651e, 
0x58bca8af, 0xd02046e6, 0x6394b11, 0x91ed9821, 0xb75225a3, 
0xe6cf1b38, 0x35297ffe, 0xeaa2f3af, 0x8740f423, 0x9cf755ec, 
0x3e71ab47, 0x9b3f3b19, 0xa17cb981, 0x745c768b, 0xc5fa06c, 
0xa9ddfe32, 0x27fb2a2d, 0x83c11cc4, 0x1be0b4bd, 0xfadc6d9, 
0xd4c4cf4b, 0x3e2019a7, 0xe6489797, 0x5746fcb5, 0xa468a4c8, 
0xe1f303c8, 0x892aba04, 0xb92617d6, 0x79af91, 0xa6719544, 
0x2123c124, 0x250f6867, 0x4ed30865, 0x32e1592c, 0x28f2364b, 
0x56bb6094, 0x39162749, 0x6b68d894, 0x3ce35fee, 0xcfc8dc4f, 
0x71602f12, 0xdc9ae288, 0xf8ef2ed7, 0x6b06d07a, 0x216e06f0, 
0xdec994b2, 0xbb3a7736, 0x5c9957e9, 0xc8bca92a, 0x2a6955f6, 
0x93876aff, 0xfac9a03, 0xefc4f05, 0xb1a05dc2, 0x6bae0207, 
0x39c9d223, 0xd25d4245, 0xa3194800, 0xb20d013e, 0x6249fe2f, 
0x837f9243, 0xb5af74d1, 0xda4d5e81, 0xbb17131c, 0x9e8e92bc, 
0x631fa28c, 0x6c4862df, 0x188d56e3, 0xe7b5f3c2, 0x8be50cef, 
0x3c846d8b, 0x47bd5cf0, 0x816608b6, 0x99263fac, 0x3082b3dd, 
0x41e2e09e, 0x554d804b, 0xd25a3b7, 0xfcf0b24b, 0xf91f82af, 
0x9b6ad24b, 0xb83703f9, 0x10d431ab, 0x675e6dc2, 0x52f58561, 
0x3badef9a, 0x31592d6b, 0x70748fc3, 0xea8cd203, 0x9cdde8aa, 
0xe8c41002, 0x696ec53, 0x91e8d6be, 0xdd90041f, 0xc4fb23f3, 
0xdee5fd0f, 0xb65694ac, 0x38dba6c3, 0x9a6226c2, 0x4380bf2d, 
0xe23c29cf, 0xa62df7dd, 0x3a8a7f47, 0xcef7d974, 0x3341ae98, 
0x9fcced1f, 0x89117a75, 0x2697345b, 0xdec75a6, 0x243febfb, 
0xdbe6ab5d, 0x6e41602c, 0x5fded1ce, 0xec854a95, 0xa0839470, 
0xa9fc1f3c, 0xeb51cb9, 0xd58d7944, 0xc6767655, 0xf096123e, 
0x3c60b5b2, 0x38abc388, 0xec0546a8, 0x974f331d, 0xb68e0fe, 
0x9e7008a7, 0xc3496c73, 0xae81ba8c, 0x499065db, 0x727d51f3, 
0xd2c437c1, 0x5b879655, 0x822f5cf7, 0xc3525dae, 0x198a3598, 
0x8dc3afd0, 0xf1fb2ace, 0xe9470165, 0xa2d922ee, 0x3d634c3, 
0xdfdafa3a, 0x323cb60d, 0xa8142cc2, 0x8fedaffd, 0x3c344d7e, 
0x6da7d412, 0x8faa6de0, 0x91b26b9, 0xcfb90648, 0xf4811a08, 
0xaa091e50, 0x3472e158, 0x6a650e2e, 0xa3cf7e2f, 0x50c01ec0, 
0xc2c67020, 0x87402425, 0xb2e34cb9, 0xbd87d91b, 0x3563a6d3, 
0x339cf74e, 0xffcc2cf9, 0x5537400, 0x57ae171b, 0xf5396a89, 
0xbed9b927, 0xaaea3a07, 0x92add60c, 0xd6cec30b, 0x85729ab0, 
0xc5326ca8, 0x7b83f953, 0xa43ff0cf, 0xe0eea920, 0x65de4954, 
0xff454bcb, 0xa3af3b3a, 0xa8d5900a, 0x19d5c121, 0xbd4a89ac, 
0x19084ae, 0x98130311, 0xaeba10a, 0xe80fa57c, 0x72ed83fd, 
0x4fb367f3, 0xcc63dc6a, 0xc3372454, 0x6a37e254, 0xfe2da32c, 
0x6fda8ee3, 0xffaf02b4, 0xc027d10e, 0x6709f3e9, 0xf27c7cfe, 
0xaaefc51f, 0x446a04a8, 0x120d944c, 0x6723ed43, 0x72ab3b17, 
0x465e7e94, 0x5d910b0f, 0xbd96427, 0x216d0655, 0x7d9b8ad4, 
0xa14a22ac, 0xcd90160a, 0xdb3f890b, 0x2d37dcc3, 0x34b8c67f, 
0x1cfd3624, 0x69ca4cc3, 0xe756cff2, 0x9d122b27, 0x46667c33, 
0x59ee9c5c, 0xbd7b82d1, 0x5f0576e1, 0x499ef4c9, 0x1370277c, 
0x8954bac1, 0x37da5236, 0xa02eb689, 0xbe47fedc, 0x776ea717, 
0x6cb476ac, 0xa47b4a6a, 0x999efe, 0x5b639436, 0xf650de88, 
0x4e8fd98, 0x191216d2, 0xceaed09b, 0x204794eb, 0xd2c25028, 
0x87bd221d, 0xc68852c5, 0xbfaafd1e, 0xf534182b, 0xfaa3297f, 
0x80e14a8d, 0xc204c912, 0x84449c0d, 0xb184ee7d, 0xf3f7b53, 
0xaa6e3294, 0xb89cbf37, 0x992ad523, 0x6efb1e90, 0xad46858f, 
0xa217c69e, 0x3b8123f6, 0x9651ad17, 0x8f4c0a9a, 0xf76fc20, 
0x7c62f8c3, 0x6da9dc30, 0x70dd3d5d, 0x96ae2e55, 0x58c655e4, 
0xaa853035, 0x48e81ea, 0x87002693, 0x2c667e97, 0x9a2f4d5b, 
0x52933a95, 0x3f72a82, 0x6c6d501a, 0x713505ec, 0x7d0f9784, 
0x6aebb0b6, 0x107a7e37, 0x15773151, 0xf90a74da, 0x2377363c, 
0xa8de6de, 0xa6e5d5a2, 0x5dca95f2, 0x5c53d917, 0x168ec0cf, 
0x570dfc18, 0x4288fe6b, 0xb9833a27, 0xdd1e7904, 0x315a4474, 
0xd5631e5f, 0x7213cfd6, 0x249938a9, 0xff052817, 0x718eb33c, 
0x2b4dec3, 0xc4964842, 0x469f5baa, 0xd941297a, 0xe9dded03, 
0x60fac145, 0xdb37f217, 0x39cd8ee4, 0x452c33d1, 0x5abe9be8, 
0x1af69e0d, 0x5b0bd6d7, 0x319ecd5f, 0x3bcd235c, 0x3fdbfa77, 
0xac550eb4, 0x3a0a346c, 0xf39919d4, 0x6e1f71ee, 0xe832ed0e, 
0x84c9d733, 0x60a2537d, 0xabbdd4b3, 0xd598dffd, 0xd13c8592, 
0x32a03cc7, 0x336e5faf, 0x2f8e590a, 0xaaeec5d4, 0xa8295b34, 
0xc30ce8ca, 0xee4c5501, 0xc77d054, 0x6b982f24, 0x678195, 
0xa849138f, 0x2f3dd18e, 0xfe23a88a, 0x2e47871d, 0xe263d69f, 
0xaa1419fe, 0xa2b0fa92, 0x3fe37d3d, 0x4f37161e, 0x4cd9b682, 
0xc65860f6, 0x77e4edc3, 0x4c71a18, 0x36fb25b8, 0x451411f4, 
0x635fecf1, 0x92b03a64, 0x9b7fd167, 0x171906d3, 0xc76604e6, 
0x59257d37, 0xf444dead, 0xbc26a68d, 0xd225e427, 0xf675b085, 
0x1aa04db0, 0x7f683b77, 0xd79d3278, 0x308425a0, 0x4504d28a, 
0xde9ae465, 0x64275e5a, 0xbd910789, 0xd13421f7, 0x84ce54b4, 
0x3c166b93, 0x1d040e83, 0x337c6ae7, 0xbe1630aa, 0x3e9a6e14, 
0xe125a856, 0xffce8ca5, 0x324f5b19, 0x5050a29f, 0xa878afad, 
0x2c6ee4b4, 0x7a891b36, 0xfdeda343, 0x8e420be9, 0xb1a90f55, 
0x1aa82dfc, 0x7bd87288, 0x497d36dd, 0xefca266c, 0x536338b5, 
0xbb314af9, 0x99c64a66, 0xe230edff, 0x35b07a32, 0xac172bc3, 
0x66890dcd, 0xc8b7e513, 0x9f14818d, 0x38f45e55, 0xe39d2420, 
0x41e7b802, 0xe7d097d7, 0x87bde5db, 0xa3b40719, 0x6903a4f1, 
0x8fe17270, 0xa00bc9ad, 0xfcbd3397, 0x458ad6f3, 0xfb3f1663, 
0xb7b4fe23, 0xec0fda7a, 0x6324016b, 0x7c6c5059, 0xf81c1522, 
0x957286ba, 0x5e27c862, 0x2dbb10a2, 0x39db5731, 0x1d567daa, 
0x55ee48f2, 0x4e5e0742, 0xc27142ca, 0xcbacae9e, 0x5d1a105a, 
0xb37e6bbc, 0x4457de32, 0xc2731190, 0x51f2e26b, 0x616f5ec8, 
0x4c524088, 0x84eb772e, 0x18fe5f9c, 0xc27be658, 0x25f0b8e, 
0x61d91e60, 0x65599112, 0x839a9784, 0x9942f04b, 0x907c8596, 
0x2e824b62, 0xa1d696d8, 0xca1de87f, 0x9b97e72, 0x89a8b34e, 
0x6edda0f8, 0x21202673, 0x10b55868, 0x5fa7c76b, 0xa1b56faf, 
0x670e4131, 0xd8f5502e, 0x25233991, 0xe43445a3, 0xfed6a20a, 
0xd19733f7, 0x8bb5db5b, 0x90e132fc, 0x25e17e90, 0xe697ac65, 
0x302fda43, 0xb7064f65, 0xff3caaf3, 0x7cc369c7, 0x789d0230, 
0x5d7fe246, 0xcbfd430c, 0xf66fcdee, 0xb3d37457, 0xc24547aa, 
0xac23da09, 0xbddb1df4, 0xfdd7d1fb, 0x4b8987b3, 0x3cf260e1, 
0x30a24d85, 0x375fb86c, 0xb287e74a, 0xc8f1b360, 0xd70e2779, 
0x784fa37b, 0x7477485, 0xa787685e, 0x541fbaf2, 0x49d05a21, 
0x46bcecac, 0xbc1c4443, 0x85b0917e, 0x693c3ac2, 0x10a30d08, 
0xff192733, 0x61d88012, 0xe2474eaf, 0xcbb899, 0x62b8b3a, 
0x5ff1fcdb, 0x20dde01f, 0x94a3ef59, 0x4e75b597, 0xea677d68, 
0xf9b9c06b, 0x1b9ee46c, 0xaf1a479a, 0x6e9a7611, 0x9c9284f6, 
0x348a296, 0xe3e3b5ab, 0x2ce8b80a, 0xf11a7efc, 0x4bf1a59c, 
0x4301a8f0, 0x57c6a80, 0x7ebd7550, 0x1963d609, 0x17064918, 
0x9a5e486f, 0x767ada6e, 0xf379835d, 0x817d0eed, 0xc8a9fc9f, 
0xd6c0e87d, 0x8dc9a94f, 0xacf56951, 0xdd8bd5ee, 0xdd248898, 
0x9e286bc3, 0xced01226, 0xb88ffe3c, 0xea662cad, 0x9ab07c59, 
0x13032ac1, 0xbb873d74, 0x32e0776e, 0x89b5f90, 0xe09d5b09, 
0x2ea60da1, 0x80cfe80b, 0x21fa1ce2, 0x706dc2f1, 0xd96e10, 
0x84f75f04, 0x5fa97783, 0xea2b6877, 0xe9c417ed, 0x807f00ac, 
0x802442e, 0x19a90570, 0x72ae16ca, 0x107e4fa1, 0xbb6135e, 
0xd775a370, 0x5ff6f941, 0x6a707d8a, 0x32be82f8, 0xe02e92e3, 
0xadf9e5ba, 0xc88902f1, 0xb38bd032, 0xdeae3543, 0x9d8b53e4, 
0xe138fc67, 0x4565a728, 0xc45115d, 0xab6dfd67, 0xd0d19d8a, 
0xb77c9c49, 0xcef31821, 0x683e0485, 0xa35e3a23, 0x12d6a276, 
0x62f81a9c, 0xa10fe92, 0x38fb7c97, 0xed7c6de5, 0x21c46edb, 
0x3babb813, 0x488587af, 0xaff84a55, 0xe48cce39, 0xe5098cad, 
0x9310cf58, 0xece52930, 0xc21bcc91, 0x540108c4, 0x4f44bcdb, 
0x898a9365, 0xba470a57, 0xd7f15ff8, 0xe473ab14, 0xe76833ff, 
0x89997b1b, 0x9e7f7c54, 0x5673fcd9, 0xd289f943, 0xbdeb72e2, 
0x490d3961, 0x4302a415, 0xa7aa0c1, 0xb35bde2f, 0xa6b2690f, 
0xd9acf25b, 0x9950b7e, 0x71621b83, 0x653f519c, 0x43a66e3d, 
0x1da1d26a, 0xc4db0a37, 0xf1d8513e, 0xd6c9840b, 0xf39e866b, 
0x197fe72c, 0x11196229, 0x311007b0, 0x61028494, 0xdf40c6a7, 
0x9a54746c, 0xfa75ce2e, 0x3bf7309, 0xc33d7966, 0xeda6af60, 
0xa6672387, 0x72411b87, 0x9a211f11, 0x51f56dc7, 0x53a684e0, 
0x397541a, 0xe33486f2, 0xb4186699, 0x9bbf1cb2, 0x1f86e0f1, 
0xa459fea9, 0xc729c354, 0x9c466f44, 0x10479afe, 0xef53e2d2, 
0xb8769c4a, 0x60a7fa28, 0x8b551da9, 0x6b17bf70, 0x4b0a4a73, 
0xfcd67534, 0x7f77d788, 0xb422f68f, 0xf8ccf23c, 0x1ad3e613, 
0xc33054e4, 0x24c8f64a, 0xa135d8b9, 0x5799da51, 0x4ff771cb, 
0x15430a3f, 0x46db7ec8, 0x87d4c88f, 0x694bb4c8, 0xa6a5ff3b, 
0x37255c0, 0xac77403c, 0x49a7a6d5, 0x61326bcb, 0xea1febca, 
0x19905ce4, 0x6c208616, 0x88601b2b, 0xf5ecddc0, 0xec8475d1, 
0xd3853b52, 0x3d21610b, 0x53b3a29c, 0x77575565, 0x5825b57, 
0x89ebfb88, 0x8f3c2f00, 0xb32ead1a, 0xd44f8744, 0x63a692b2, 
0x69697bae, 0x6b7fe1c9, 0x325b5bf1, 0xb32e0e11, 0x54187523, 
0x4501dc49, 0x7eb3aed1, 0x6ab0eb88, 0x6b3e94bf, 0x2c2d293b, 
0x8f668ba5, 0x2db81bb2, 0x9e43c4ae, 0xda5b5b13, 0x81763a88, 
0x95b90733, 0x642b0bca, 0xdd1dd3a, 0x44d79c88, 0x95e327f, 
0x56abfd80, 0xd0f75ce3, 0x730607c6, 0x89a6fd0e, 0x7fc09cd8, 
0xb078f466, 0x184ba518, 0xaf1ff8e1, 0x99e25f5f, 0x201e00a3, 
0x8ba1ae03, 0x19a9942b, 0x2c1e6198, 0x737f2878, 0xc59a2b1c, 
0x7c4f8850, 0xf0409a77, 0x2da9101d, 0xd1aaf46f, 0x291c51af, 
0x4d234c8a, 0x68810c4a, 0xfa7e9b84, 0x75b5dcb8, 0x1fe8b9f, 
0xd4acb1ef, 0xbb6ff83b, 0x64805089, 0xf6763925, 0xb327edc3, 
0xd688dbca, 0x196cf19e, 0x2cf2b856, 0xda34c994, 0x7518948f, 
0x3170a8d1, 0x30f86e08, 0x681c6bac, 0x3bfddb0c, 0x5f168b17, 
0x4ae631b1, 0x3d105d00, 0x7116b018, 0xad06c9a1, 0x293be0e9, 
0x3dd73c5b, 0xbd5a98e8, 0x75536a9f, 0x818d1508, 0x40e9aa2e, 
0x68367be3, 0xaf51e5f2, 0x39b8ccc2, 0x6c67fb45, 0xb13771e2, 
0xe706549e, 0x42b7fc98, 0xedbd44eb, 0x622d9985, 0x85107f0a, 
0xcfc9061b, 0xd9e6d66b, 0xe011bb5e, 0x327eb11e, 0x407ecdd9, 
0x3afad29e, 0xab283ffb, 0xbe83d61e, 0xea3e7a46, 0x273b2541, 
0xda729e01, 0x81a62472, 0x8359eedb, 0xa4457261, 0x926ad13f, 
0xe7e0c4fe, 0x4d1da2d8, 0xa8b3aed0, 0xb658ec23, 0xf7e24a58, 
0x5d154e58, 0x9a2bf0ba, 0x2eb455b0, 0x50cb61f3, 0x1e095a2, 
0xe1de399f, 0xc71cbd35, 0x7cb90a7e, 0x356e4628, 0x280991f0, 
0xd26e64a1, 0xd6c9df5a, 0x3ef127a4, 0xcd2d747b, 0x595f8ee8, 
0xba946959, 0xd8ee7838, 0x10f24d0, 0x86b0eaec, 0x1d078587, 
0xfbf516ea, 0xdc2a79f8, 0x7015e404, 0xe9efdc2c, 0x16bca751, 
0xef7b9df7, 0x9227157f, 0xa31e6f81, 0x83b7e291, 0x7ee5c10b, 
0x1a196d7c, 0x23829142, 0x263fe2c2, 0x618461ac, 0xe8681ba5, 
0x258b3130, 0xd60cf96a, 0x14fadac6, 0x9d48a438, 0x8bfa6a79, 
0x8b920d34, 0x7e98a7fc, 0x88cc57d, 0x5af407f0, 0x15bc4713, 
0x23b64b00, 0x37f96d03, 0x5ac72f49, 0x65a9a89, 0x16724cac, 
0x503ea2fc, 0x4d548e23, 0x2d92d724, 0xdefe753f, 0x37a36c6a, 
0x70708d68, 0xbfe7aba8, 0x1f510c48, 0xb3a995e3, 0x1342df6d, 
0x7986ddb9, 0xf4630113, 0xa9f9b81d, 0xb1dca7ae, 0x70915ce7, 
0x780e2c35, 0xd1859a18, 0xf92e7d5a, 0xce573f6b, 0x9d79a6e9, 
0xbd7f3425, 0xacfd81c7, 0x8429a008, 0xf0da82bb, 0x6a5fb409, 
0xc567b073, 0x5371eda, 0xa417042a, 0x9d162579, 0xa8c0eb06, 
0xdb7a6342, 0xae0c5575, 0xe0e256a8, 0xa7de78a0, 0x12797538, 
0x8e154606, 0x93b23bf, 0x16f4562d, 0x47067058, 0x6db6dc93, 
0x33fc94d2, 0xae60549d, 0x4e1b4fcb, 0x7d4aff37, 0x59b050d1, 
0xd50b787e, 0x4700ba54, 0xc6848ba2, 0xbd8f6801, 0xd2f62909, 
0x289cde1e, 0xc5003778, 0xd973a07d, 0x38a099d8, 0xf8bedbdd, 
0x68e9601d, 0x1e86cf6d, 0x2899e89c, 0x229ab04a, 0x45b7a393, 
0xef508cd2, 0xa03448ed, 0x29b47253, 0x9f5a48ac, 0x43c89eec, 
0x75dfc10, 0x1c2c3184, 0x3ecca1e3, 0x3c5cc91e, 0xcf7cd58b, 
0xe014d295, 0xed503a24, 0xe452210e, 0x6fe3ac6f, 0xd99dca00, 
0x3ae4ac67, 0xd189afe0, 0xf3ba5df0, 0x84a10e38, 0x4a7b85e4, 
0x9d8b4bf7, 0xe83b5b67, 0x90106e3d, 0x534fbf99, 0xce3bcd2e, 
};
for (int i = 0; i < refInt.length; ++i) {
final int r = rng.nextInt();
Assert.assertEquals(refInt[i], r);
package org.apache.commons.math4.rng.internal.source32;
public class Well1024aTest {
public void testReferenceCode() {
final Well1024a rng = new Well1024a(new int[] {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,
-595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,
-1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869
});
final int[] refInt = {
-1478749726,  -1645579484,  -2075363835,  -2063444174,  -1834148336,  -1769045872,    -40711346,   1717441026,
2130656771,    783441285,    570433609,   1560023451,    653233971,   1368672434,    -72036215,   1071111800,
933776492,     26114960,     49888778,   1808107515,   1092989296,    754848337,   1336994364,  -1987450448,
-691190146,  -1803870839,   1110716866,   1173269113,   -391000050,   2014216908,    180756301,   -382891013,
-1908154585,   1580737629,   1080267957,   -125532248,   2094530239,   2132964485,   -438596348,   -760299445,
1058181869,   2050816800,  -1534429037,    -62552782,    824524142,   -818590371,  -1857695907,   -684762866,
-156556543,   -902759995,   -880795194,  -1387351132,  -1263017515,    448006597,    201038266,   1929826313,
-455367306,    672963027,   2000073013,  -1546842042,    446341090,   1001696686,   -779919012,   -347722602,
-1342821677,   1639571150,   -835315755,   1505585376,    367004975,  -2035864404,  -1786623553,   1249724913,
182435312,   1444514513,   1815333708,   1333772382,    299664001,   -284691169,   2034403374,   1423310887,
-1319051884,   1557286441,   -445198266,   -251809030,   1602786123,    944036382,  -1020529634,    258344235,
685254367,   1838964943,   -156674528,   -979736602,   -538312836,    234643178,    211152102,   -635498640,
-1036733933,  -1347589147,   -565609042,  -1358714165,    508618483,   -786364693,   2071450261,   1206956772,
-678931458,    167690617,    144698821,   1719720781,   1575869280,  -1343221123,  -1766469944,    284991647,
-717305514,    892653651,  -1368347075,   -615701972,   -730369849,   1360396003,  -1869287623,   1778269052,
-586061545,   -699517114,     61530249,  -1860611767,   -519660852,   1841085925,   1555610093,   -399979337,
-790345742,    422355947,   2007965433,   2044952550,  -1712164595,   -102915702,   -693865324,  -1894042487,
-1285020072,   -215883074,     95833252,   1625818040,  -1055951680,    513067085,   1825246558,   -553461652,
-1923361799,  -1869480206,    567232636,  -1751727150,  -1832301399,   -108136455,  -1312244126,     14006795,
850221366,   -382389732,  -1741556188,  -1317464467,   1948314870,    753994471,   1028235947,    342494132,
-1862256693,    723808794,   -234257642,   1609928369,   -802733456,   1315831915,   1436072885,   1224767136,
2144557791,  -1839965886,    224821018,  -1461697757,  -1080386760,   1638573498,  -1188173812,   -325181523,
-1750676219,  -1780415850,    698793362,   -908352052,    299746482,   -161660934,   1938166833,    800297005,
56640033,  -1214932666,  -1248124842,   1822796868,   1777615881,   -718517774,   1908159957,   1733053281,
1851844331,   1283519375,  -1771494956,   2060179999,   1666129209,   1919453531,   -498145770,    697567008,
1855487148,  -1587163491,    565216434,  -1477877933,   -925662919,   -806492585,  -1201439047,  -1424534232,
1788616523,     69414717,    655893636,  -1175978556,     24787512,   -861550001,    439525754,   -190433174,
-383811606,   -508589783,   1441608687,    608181366,   1539467064,    925903122,    697209654,   1878283393,
-1967567432,  -1659677763,   -249658183,    847096354,    397741956,   -125334541,  -1286840731,   1016461908,
-997968592,   1795331475,   1856856501,  -1716726445,   -582181331,   -887091847,    426964855,   -609219941,
-1456232632,   -483467616,   1069260754,    972242064,  -1406786247,   1954194029,     52627891,   1212755081,
2117436668,    281073392,    741537353,   -483063506,   1850906286,   -244876135,   -270818140,   1817568823
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class Well19937aTest {
public void testReferenceCode() {
final int[] base = {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,
-595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,
-1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869
};
final int[] init = new int[624];
for (int i = 0; i < init.length; ++i) {
init[i] = base[i % base.length] + i;
final Well19937a rng = new Well19937a(init);
final int[] refInt = {
-612874471,   -354976292,  -1838197125,  -1781560577,    278390997,   1214938280,  -1752615390,   -760835246,  -1712883765,   -241205782,   -145390202,    495649160,   -514388259,  -1271015916,  -1640000013,    849273623,
-549729394,  -1206917255,   -545909692,    811925434,  -1665729633,  -1525292882,   1416246482,   -153220826,   1148868872,   -326143196,   1724979062,   1790931148,  -1648679618,   -439051683,    112482777,  -1484051520,
-1881272572,  -1270447031,  -1216102401,   1579107248,  -1224395621,   2144411988,   -416216641,  -1529222361,   1628987080,    164445245,   1506928916,    928145916,   1436000427,    862025970,    560077705,  -1887251027,
-514360858,   1735094506,    475624879,   1755802355,    295448361,   -155399225,      3972415,   1368201076,   -465126094,  -1622687259,   -246099304,   1798631152,  -1937269102,  -1700560396,   -293352622,   -896632303,
-2088933220,   -194382452,   -480218162,  -1618517785,  -1925031481,   -150217434,   1678937261,   2130832364,   -485546678,  -1499224981,   1430390884,  -1895417302,    210514746,   1781140999,  -1940853105,  -1238099647,
485922557,   -103223212,    633481679,   -632946979,    695235541,  -1661735272,    277603567,   -958341538,    256982285,   1850270018,   -327388076,   -219053874,   1380560653,  -1221689980,   1335863752,   -545032383,
-575291735,  -1295623907,   -140058298,   1063302709,  -1290702617,   -790401546,   -170630961,  -1203114473,   1458063108,  -1212753301,   1546428514,   2112636413,  -1463028928,  -1812598032,   -883529486,   1131084094,
62042165,   2135819802,  -1192342739,     98361522,  -1341042205,   -475283063,  -1632033747,   1745196892,    168608689,   -914987039,    274428907,   -881357258,    167940012,  -1975737532,   -903960486,  -1370984244,
-589352935,   1783633514,   -570111010,     71495377,    194463285,  -1243905021,  -1398490898,    221691209,    -55728834,   -638916786,   -770622372,  -1911651810,   -295233027,    301467998,   2058638784,    681490183,
-1547865078,  -1668135684,   1299261826,   1649468635,    287995017,  -2076844852,   1193468826,   -853948258,    120082777,   1051829542,  -1288514343,   -159456430,    275748820,   -480127107,   -604943233,  -2138088332,
1202614819,   1427201263,  -1906344469,  -1230779533,   1690367192,    733159097,    794410312,  -1114452505,  -1601554413,    976747949,   1517787154,   2091780205,   1052078906,   1919282771,   -191013374,   1805397142,
736939268,  -1056272823,   -727464316,   -659459005,    797803875,  -1104633884,   1042342081,    -24514837,   1919469940,   1903722546,   -814157872,   1605407665,   -262351256,   -288949635,    729204844,  -1132605534,
745453338,    387915035,   1094173337,   2100279147,    156863702,   -257377544,   -719587984,  -1496015613,   1908993744,   2016957554,    918749666,   -135963651,  -1356808639,  -1711185741,   1472589240,   -398100149,
628791415,  -1381837652,  -1820702771,   -593586943,  -1456631279,  -1837975351,  -1394249972,   -556916726,    833231177,     43449750,   1029237092,  -2086437337,   -459463076,   -533031784,  -1739648287,  -1374722961,
2024908394,   1389678488,      2018558,  -1391707864,   -795935743,    904816957,    836583280,   1766194531,  -1374431014,   -904437876,   2030248636,   -265724199,   2056758426,   -810499837,    887193593,    -77811488,
1496312336,  -1874348275,   -456193866,  -2137130942,    868120387,     29025455,  -1999867716,   2001322335,   -579152815,   -390892056,   1592011837,   -306394879,     93636886,   -190879994,   1923358153,    269052141,
-396050253,   -987531729,    480350991,   1276744541,  -1445571957,   -957571005,  -2046270221,  -1715395752,   1113585628,  -1782113514,   -697560146,    835320000,   1014320959,  -2119834109,    460056841,  -1464772991,
-1282790418,  -2120806165,     86176097,   -731086307,    832497517,  -1876684928,    541008240,    551124479,   -450919132,    647860281,  -2115397586,    979247589,   1095559204,   1927958688,    169497703,   1999579054,
2019745038,   1656022059,  -1109662138,    375237154,   1450814436,    919988416,    849761266,   1457057327,   1771166577,  -1639880487,   -852488298,   1767063646,    657295386,   -585561879,    740792583,   1664558308,
-654749506,   1109275990,    182597559,   1106789745,  -1806628480,     25948116,   1748374299,    196057325,   -164213209,   1687024594,    782029276,   1879737947,  -1528219611,    412585737,   1190325629,   1985821911,
-1272945202,  -1238637137,    465818730,  -1537670961,   1131953615,    905623579,    609183424,   1138422991,   1522974699,    589719061,  -1310894604,    890952933,   -885204790,   -393535694,   1238408670,   1780660354,
677803525,  -1121509064,   1553148616,   1109165936,  -1450120385,   1525252521,  -1354897489,   -595402189,  -1274551767,   -869281409,   1788815975,   2020262116,   1124100185,   -400839020,    310574108,   1354413045,
-1310514485,   1895732085,    626639054,   1667355357,   2065637178,  -1889009143,   -440157749,   1762849463,  -1693853642,    -56602956,   -930874188,   -398470740,    778356402,  -2113156881,     42854964,   1844399604,
-2098310302,  -1812029757,   1441188713,    899579267,   1266994172,   1841370863,   -660740252,    -43254718,   1124500192,   1884907320,    879997211,   1775139845,  -1360112721,   1630490057,    362567879,   1113475029,
290319279,  -1209506867,    398146039,   -957742350,   1185761854,   1519676447,   -912689915,  -1117128973,   -305563462,  -1928033363,  -1766324543,   1702753492,   1696951912,  -1895072395,    932663591,   -566548128,
991675996,     56529814,    980735023,    718166662,   -650028466,   -886842051,   1857048587,   -569023569,  -1820572202,   -851452711,   -958700452,   -621825633,    -65649888,   -510143183,    761267599,  -1692108035,
1729071710,   1623630864,    -53498654,    267235687,    659201413,   1152882627,   -824194574,    356636960,   -502391121,   -538453360,     66115376,  -1633290370,  -1522088932,    268949070,    684499443,   -859474501,
1586764345,  -1515639709,    319695602,   -307025150,     69076508,   1050726785,  -1340930110,    552191600,   -207852941,   -273572993,   -539580440,    710343120,   1957076127,  -1107172811,   -561518280,  -1775022699,
1978792904,   1935531451,  -2084046304,   -419742902,   -737652926,    614022023,   1676952428,    769892939,  -1092786807,  -1117113223,   -266029995,   -350150999,    207738542,   1964896575,     48805284,   1736500159,
551289617,  -1847923501,   1856609505,   2007480480,   -681860219,  -1198106493,   1483591043,   -523895316,  -1814473078,  -1521087404,  -1348859926,   1298056897,   1813789478,    946683654,     79196400,   1766250931,
472737685,   1764634332,  -1844726079,   -130619045,   -508713868,  -1762537125,   1010108863,    170107098,   1705386380,  -1139681802,    183739097,   1662699401,   1842694501,   1714633805,     46208876,    616720693,
-252553427,   1986302230,   -103130254,   1943225981,    110746655,    553260552,   1588938073,  -1934623163,  -2144781332,  -2086217416,   1941265852,   -781953226,   1216234254,    605543697,   -710872598,   2048636577,
-1986927728,  -1007017623,   1243051501,   -614249563,  -2128221291,    581579813,   1173464240,  -1906830937,    261329601,  -1805974103,    769823490,   1858731164,   -561762071,    516417430,  -1221329437,   -825500715,
1091364656,   -993658663,  -1475434188,  -1070804384,  -1876492082,    899494424,    683486936,    878807455,     56642807,  -1268202879,   1379172046,  -1386869373,  -1158233876,   1759190552,   1597629789,   1411151497,
-1254268471,   1075936979,   -918778269,  -2132675184,    953140888,   1906982077,   1154200766,   -365384600,  -1142488826,    708535121,  -2134869964,  -1531201665,  -2100526761,   1268256467,   2071480803,    193135243,
1374158182,    989505347,   -933612202,  -2134839213,  -1302795271,  -2092029041,   1812014826,   2090855917,   2005348528,    606434393,    -60141386,     11156360,    539516285,   -122485034,   -893237911,   -978127424,
1509901816,   -451029719,    428544700,  -1622965963,  -1993611605,  -1989324583,   1104111587,   -795138585,   -899552401,  -2110167769,   -234502445,   1586963605,   -503778455,    529261062,    325327284,   -106186403,
65369563,  -1475700698,   -228624261,    715975009,   1099352363,  -1796883396,   1376542700,   -308942420,   -344940451,   -395389249,  -1562737166,   1869802677,   1273494710,   2075587668,   -789570273,   1563347596,
1142901755,   1676422422,  -1729157809,  -1399423717,  -1814262429,  -1809707284,   1393992342,   -570246212,   1065528749,   -781643849,   1218667301,  -1097949471,   1305629790,    901301039,   -704762030,    360582612,
1411910672,   1848068741,   -614500891,   -146889637,   -913903597,    723527277,   -147033328,   -199273155,    734997691,  -2072735286,   2129258691,  -1385074104,    931616624,   1065477319,  -1543474555,   -531410292,
-2123119121,  -1538464113,  -1153585193,   1559931968,   -654877011,    879865200,   1489681397,   1998864644,  -1964160144,    163671782,   -858364148,   -323324233,    801208648,    705864113,    436184243,    643773864,
2087594507,    134637265,   -749956494,  -1657343972,  -1828172168,    -27357303,  -1145161336,  -1192513644,    216148260,    611393153,    -13752671,   -358631090,  -1211920749,    593572064,    657629904,  -1445961088,
-250704995,   1797542707,  -2122311891,   -316774825,   -296303057,   -868002056,    -86697533,   2020588145,   1203427903,  -1371839056,    669531557,  -2031033836,   1323994690,     13703036,    785437772,  -1465821554,
-694756014,  -2131068154,  -1745448876,  -1095891733,    936594025,  -1119068454,    855423970,   1705079340,   -905640608,    162297141,   1336619311,   -344353769,    -92608588,  -1080573824,   2002293105,  -2088030765,
-1684198727,   -129054718,   -949437132,   -127983221,   -216664110,   1700146143,   -711174649,   1500113839,   1212236226,  -2017364219,  -1263597675,    511929344,   -323998524,  -2021313185,   1803000924,    927670608,
336267187,   1244256964,  -1665390108,    991395134,   -251232188,   1267445783,   1547951569,    740269916,   1776431169,   1687220659,    228229817,    271386089,   -682906779,   -438090344,   1190436796,   -744272540,
1879221151,   1145200306,  -1730983338,  -1119209309,     90826726,   1567861540,   1638852830,  -1645384932,   1566909531,   1088584561,   1030555565,  -1872052014,    720320695,   -885053674,   -321216789,    739907579,
368580703,   -443635520,   1232705619,  -1355949988,  -1047211249,  -1571429448,    599299852,   1036970439,   1513838571,    -51797291,    -26647565,  -1262878942,   -916262582,   1579082269,   -292007383,   1289013866,
-1612184284,   1451738668,    448608569,    476432992,  -1229609565,    786372409,    929928149,   -150100614,    448155944,  -1322320576,   -856549627,   1057443268,  -1536809554,    577508258,    584906122,    275295163,
-604262071,   -236043234,  -1866434954,  -2072447013,    646132876,    847562546,   -310005953,  -1104162658,    393261203,   -730102354,    440824482,   1654535035,  -1296359745,   1487359328,   -977776604,   -775827779,
-1298695106,    519080622,   1697162240,    227873031,   -371123123,   1273702312,  -1710063656,  -2138342344,   1139555478,   1531578907,  -1498880699,   1183507362,   1875307493,  -1649740413,   2135386504,   -962458407,
424161768,    504272962,    202204247,   1783466420,   2015579232,   -676642965,   2067456450,    914480415,   -620398841,   1880405399,   1406637142,   1951104977,    633496157,    224861869,    -58659291,    994942775,
-479000645,   1421449115,    100168104,    249754169,  -1219011494,   1736303638,    364013694,  -1750035055,   -479217141,   1652913106,  -2109452331,   1633842910,  -1547663337,    936627493,  -1152799743,    896955899,
-1407742850,   -523769014,    357161414,    872293304,    744895980,    720829676,   -240843156,   -111779524,   1292836315,  -1792141538,   1946959925,   1181751089,  -1120674052,   1185192575,  -1387002557,   1973209255,
-120887476,   -766577735,   -443913073,    786620227,    428564781,   -101232106,   -425959852,    198082021,   1173272226,  -1744840378,  -1621135606,  -1539498583,  -1101274572,     43399711,  -1256764602,   1201920787,
2049426139,    846545551,  -2121520873,  -1202939675,   -470425740,    321987390,   1862019060,   -951540342,   -894238318,   -430407175,  -1662746491,    656574776,   1580373777,   -431290218,   1645824323,  -1953526979,
-374682356,    474291752,   1071558425,    511038981,   -760598678,   -567797285,  -1176476266,   -268409005,  -2130644484,    -67970563,   1756046948,   1429860462,  -1130984739,   -124916495,  -1544436836,  -1863524031,
1024916487,  -1388636482,  -1573205065,    892628956,   1831270021,   1176430590,   1158914682,  -2006787098,  -1228130033,   1516111488,  -1499151347,    470546266,   1642603981,   1425140838,  -1823071475,  -1775267236,
-1009380612,    164746986,   1129677098,   1842642579,   -482342932,   -507480364,   1656012309,   1981601761,   -881042120,   -511987083,    342447017,    381192578,    983008095,    741012865,  -1877136350,   -199211983,
-452784912,   1929572576,  -1678291139,   -864375281,  -1610561247,  -1936356726,   -749553767,   -865893512,   -567081879,  -1303973729,   -939636958,   -622974563,    428284937,   1049237414,    852280765,     86648946,
-1353851401,  -1045422335,    898035731,  -1636093996,  -1083174191,    245046915,   -359768226,  -1028491655,   1051575118,   1774289451,   1839389415,  -1594053468,    736707953,   1873556950,    401186168,   -583669552,
-88375334,   2002752071,    264506453,  -1304812107,   -759203942,   -114958524,  -1878903503,    841613720,   1910863820,  -1738114003,    701455920,   1791058048,  -1850960547,   1672292671,   1172188809,    604848896,
-1607489375,    305370478,   -948153885,  -1971080100,  -1848966954,   -584538365,     39416319,  -1689119162,    944942598,   1777111075,   1534005553,   2022718432,    -25820385,      3077695,   -315950520,   1859184648,
-1397829266,  -1666371809,    858913807,   -610818620,   1554973298,    580023809,  -1662988256,   -408630026,   1316681876,    738204271,    942829881,   -758486983,    780345857,    667165037,  -2086803585,    789741324
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class Well19937cTest {
public void testReferenceCode() {
final int[] base = {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,
-595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,
-1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869
};
final int[] init = new int[624];
for (int i = 0; i < init.length; ++i) {
init[i] = base[i % base.length] + i;
final Well19937c rng = new Well19937c(init);
final int[] refInt = {
2128528153,    327121884,    935445371,    -83026433,  -1041143083,   2084595880,  -1073535198,  -1678863790,   -523636021,  -1514837782,   -736786810,   1527711112,  -1051227939,    978703380,    410322163,   1727815703,
-648426354,    636056441,   1954420292,     17754810,   -958628705,  -1091307602,   1793078738,  -1680336346,   1792171272,    941973796,  -2066152330,  -1248758068,  -1061211586,    262020189,   1276960217,   -233886784,
1767509252,  -1811939255,   -406116097,   -742435920,  -1349799525,    240329556,   -332161345,   1488943143,   -332244280,   2093328957,    674753300,  -1930135556,    257111467,     63793650,  -1964335223,   1315849133,
-797349146,   1372022250,  -1451892049,  -1325138957,   -870401239,  -1294317369,     91490879,    386205044,   -704074702,  -1230679067,   1513674392,   -262996240,   1196007314,   1398903796,    803719762,  -1750926831,
-1268814180,   1233515404,   1498313934,   -970591257,    611113671,   -261632474,   1834097325,   1709440492,   -150396854,   2120561003,    -62645660,    479080234,   1535125050,   1823378695,  -1129289329,  -1095198399,
2092564733,     78836308,   -692015409,   1647147229,  -1847922219,   1838279320,   -848333841,  -1375151778,    920238861,   1512628290,   -749439404,    288851918,   -427218675,    679640964,    425700808,  -2077624511,
-1929434455,   -647176419,    650437190,  -1926749131,  -1564744729,    734494454,    108193743,    246246679,    810042628,   1952337771,   1089253730,  -1874275331,   1428419392,   -492969232,   1945270770,   -201265602,
-755490251,   -624426214,   -699605715,   -113446478,    809091299,  -1521531511,   1136505389,   -523660964,    132928433,   1926559713,  -1485314325,   -508322506,     46307756,  -1627479740,   -589386406,  -1855555892,
584299545,   1272841066,   -597242658,    925134545,   1102566453,   -753335037,     -9523218,  -1778632375,    568963646,    764338254,   1259944540,  -2000124642,   1307414525,   -151384482,    807294400,   1993749511,
-15503094,   -709471492,   2104830082,   1387684315,  -1929056119,    224254668,   -733550950,   -889466978,  -1987783335,   -437144026,    995905753,  -1021386158,  -1096313388,  -1014152835,  -1303258241,   1201884788,
-1845042397,   1421462511,    980805867,   2143771251,    481226968,   1790544569,    328448328,   1995857639,    -66668269,  -1411421267,   -222586606,    866950765,   -308713926,  -1048350893,    993222402,  -1139265642,
-871837948,   1145571913,    381928580,     35386691,   1640961123,  -1192981020,    775971009,    594246635,   1603197812,   -575106766,   2023682000,  -1636301903,   -718093720,  -1666421635,  -2146115988,    320593570,
287355418,    454400027,   1112753817,   1751196267,    782077910,  -1478447368,  -1007557264,   -862315517,  -2035355952,   2123515250,   -557641502,  -1789932035,    879640129,     44167603,    791148984,   1382939723,
-2135684233,   1825489580,    937345485,  -1839983359,  -1536880111,  -1472578359,   1548052748,  -1471535862,    -14508727,   1509621398,  -2134967452,   -787485401,    815341660,   -327905128,   1028096737,    866906991,
-1585990806,    859229080,    234806270,    998518056,  -1897890815,   -900923587,   1179856752,   1529572451,    620486106,   1119836556,   1661285564,   2097404633,  -1437490790,    265306115,   -984880135,   1326751968,
1280043536,    680210701,    155786166,   1550973250,   -325781949,   -597789777,     -1939780,   1345275487,   1930450001,    941449704,    669301309,    693651713,   -990721514,    582968326,    976132553,  -1892942099,
-1065070157,   -711990993,   -688974833,  -1026091683,   1115346827,  -1305730749,  -1733626381,   -364566696,    -21761572,    -37152746,   -262011730,   1302722752,  -1806313409,   -767072509,    764112137,   1671157377,
1837645038,  -1021606421,  -1781898911,   -232127459,   -310742675,  -1818095744,  -1128320656,   -705565953,   -354445532,   -523172807,   -433877202,    131904485,    -64292316,    381829280,    229820263,   1797992622,
1359665678,    978481451,   -885267130,  -1415988446,   -356533788,   -961419072,   1938703090,    708344111,    679299953,    744615129,   1328811158,   1257588574,    569216282,   -753296151,  -1519838713,   2016884452,
1062684606,   1561736790,   2028643511,  -1353001615,    886376832,   1466953172,   1664783899,   1290079981,    -57483993,  -1176112430,   1634916316,   1976304475,   1374136869,   -648738039,   1058175869,   -909000745,
-1526439218,    726626991,   2066596202,     64980943,    -26166577,   -885900005,  -1821546816,  -1103727665,    730606315,  -1324948459,   -696956940,  -1300869403,   1171578314,    797249074,  -1600611618,   1928247682,
307164165,  -1482476232,  -1886179640,   1306433392,   1945271359,  -1272113751,  -1285984081,  -2057145549,    795047465,   1262569087,  -1239828121,   1426641636,   -786371495,   2120199316,   1273690652,     74457589,
-1033394229,    338952565,     46122958,   1225741533,   2115308090,    678200841,  -1618264885,   -101162569,  -1628976330,  -1232839500,    468709044,   1876019116,     92723122,    233398255,   -554960844,     38494196,
-406437278,   2083528643,  -1106878615,   -340722557,  -2123964932,    223183343,    108918116,  -1014629054,   -901344544,   -838896840,  -1908460517,  -1763508731,   -926890833,   1703791049,   -667755577,   1694418389,
791641263,   1095689677,   1119202039,  -1419111438,  -2012259010,    188017439,  -1775110395,  -1971099661,  -1688113734,    131472813,   -776304959,   1511388884,   2080864872,  -1733824651,   1992147495,   1119828320,
1065336924,  -1357606762,    462963503,   1180719494,   -202678962,   -892646595,    605869323,   1144255663,    878462678,  -1051371303,    872374876,    631322271,   -172600544,  -1552071375,  -1939570033,    151973117,
1640861022,    310682640,     34192866,   2057773671,  -2004476027,  -1879238973,    582736114,    900581664,   -427390545,  -1232348528,   -535115984,   1321853054,     69386780,  -1729375922,   1418473715,   1022091451,
496799289,    -80757405,  -1903543310,  -1128846846,      1703964,   1984450945,    856753858,   -812919184,    775486323,  -1376056193,    638628840,    314243536,   1030626207,    644050997,     73923896,    362270613,
236584904,   1463240891,   -223614432,    435371594,   -751940030,   -124274553,  -1991092884,   1579624267,   1249632649,    157589625,   -345229739,   -366245207,  -1399995986,   1651729983,   1965074340,  -1108970305,
1163690769,   1732013523,  -1461252895,    669755552,   -476503675,   -264578685,    -32813949,    288222188,    -25734262,    106040916,   1654395626,   -365148479,   2014455846,  -2040447994,   1351639280,   -919975757,
-1970412139,    -47306532,    222377665,   -363434917,  -1091717516,   2090685531,  -1221091649,  -1729649190,  -1239406708,   1064945398,   -105437479,   -419675255,     74701669,    -12862899,   -498269844,   1566898997,
-1872838355,   1596887574,    485902962,    469225597,   -881763553,   1307841032,  -1642872487,   1388543045,    379792876,   1095683384,    840780732,   1934378038,   1851278350,  -1359389423,    130868458,   -313448799,
-663624816,   1031714153,   -608443411,   -205137499,  -1849464427,   1973593637,   1068741808,  -1420655961,   1188762305,    954044841,   -995454462,  -1818101092,  -1937201943,   -324541290,  -1520603933,    572873173,
-554764496,   1051557081,  -1245136076,   -985349536,    329320398,   1787901464,    -37803304,  -1759310177,  -1463492617,  -1861729663,   1251768782,    256937091,   -779036948,  -2049893864,   1256022877,   1228075657,
-1550195255,   -611319853,   1190797155,   2047604112,   -576077160,  -1532843331,  -1324899394,   -159729560,   -622525946,  -1080302767,   -236033484,   1895243903,   -410123689,  -1944154157,   -681781021,   1208453003,
579595878,   1303914051,   -145607082,   -131567277,  -1917288455,    894217359,   -175688726,  -1585480723,    663691440,  -1140068263,   -641711178,   1596080008,    629197693,    976422358,  -1570451095,    525923776,
895046136,   -504151767,   1602553020,  -1233054923,  -1798474837,  -1488857895,   1055782627,    261863143,   1879276655,    488240679,   1910982611,  -1919441259,    370435945,   1265230086,  -1293284428,  -1503576227,
2076963035,  -1379628250,   1157098875,   1984461153,  -1947837397,   1705880124,   1453607404,  -1233649748,   1479943773,   -863878721,   -862415630,   -736723275,    940306358,  -1596000684,  -1174889953,   -615723892,
-885006597,  -1796723178,   1844159055,   -188942309,   2107251811,  -1675486996,  -1009475178,   -859263556,   -431866963,     -9593673,  -1878920923,   -104853791,  -1535224994,    -69315537,    586690130,  -1292234796,
1378749456,   -301873019,   -319297563,   1677205851,    292450579,  -1289441171,   1788113680,   1907606333,   1464711611,  -1372023606,  -1978832445,  -1772259768,   1949124464,   1818322887,  -1138036603,   1249727628,
-1474866449,  -1868013169,  -1384567593,    717007936,    954189997,  -1900561040,    738470389,   -158973180,   1732860784,   1936031206,  -1133354740,  -1173166665,   1432976712,    852636081,   1732064691,  -1831788120,
1273933579,    455403217,   1988395890,    106493468,    506092152,   -610530423,   1698053512,   1311747476,   1969503012,  -1887461759,   1613543073,    903200334,   -737865837,    325656800,  -1234001200,   1492148864,
2009861533,   -368262605,   1091338541,   2076108119,   -961392337,   1835877112,    316250307,   -853333391,  -2125443777,    815363504,   -798707803,   -158146540,    690786114,   -530775684,   1203556940,   1611485582,
-1661412270,    -53184506,   2126287444,   -232222229,   1559486057,    283532250,   1202760418,    932144172,   1082594656,   -570104011,    413509167,   -995027177,   -996477516,      -540544,   -745537167,   -712135469,
-996294983,   -592787198,   1889840948,   1314628747,   -394266926,   -682316577,    456447239,   1728806063,   -396279614,    -43387643,   1915717013,   -861574144,  -1078710588,   -561401249,   1111464540,     63643984,
-1693870413,   -968369980,  -1053148188,    708799038,   1883537988,    373371671,   -156410415,  -1596483236,  -1846890431,    888692915,  -1025632583,  -1666477591,   -343066267,  -2059058792,    641501628,  -1744347292,
1648632991,   1743540146,   2020952406,    164014499,    990508262,   1706408228,  -1236471842,   -347116260,   1843634523,    827255665,    300519853,  -1265974830,   -547247177,   -583064554,  -1995437077,    689210107,
-93151393,    835365056,   1706367315,  -1605902756,    200954895,    431093688,   -277573364,   -928486713,   -552221973,    145432789,   1128919795,   1675095586,   1930359882,   1215849501,  -1447770583,    657776490,
1885869860,  -1629237204,   -868897479,  -1258169760,   1828140195,   -883850439,    463933909,   -347361158,   1478116648,    801176896,  -1501915899,   1017335748,  -1654508882,    123994786,   1588785290,    791166651,
-1523108535,    340411166,   -496474762,  -1189711141,     -7392628,   2045171250,  -1245366209,    834787230,  -1346883181,   2034209454,    737043362,    898803323,   1983089087,  -1845404320,      9585188,  -1180608323,
1665100606,   1949474222,   -211115008,   1151308295,  -2132174259,    913126312,  -2085061672,   1419864120,  -1134542954,    -53833957,   -246913211,    468382370,  -1759479323,   1136686211,   1307012488,  -2036299559,
-1346099736,    314743106,  -1683101865,   -947151948,   -234529696,  -2103334293,   -279256894,     -1484257,  -1053953017,   1801205399,    941594454,   -874119215,   -672865187,    762284205,  -1494975451,    486607927,
-898264389,  -1711861093,   -212572760,   2106484281,  -1610786470,   1352525590,   -837779586,   1568282001,   -593019125,  -1146260782,  -1595879979,   -640781858,   1107692311,   1547132709,  -1928385535,  -2057772805,
634887038,    329772618,    942136006,   -864405576,    501883884,   1537141484,  -1180626836,   1123055420,   1090885851,    421662750,   2033111605,   1710917425,  -1118058244,     74321279,    257328195,  -1199940697,
208625996,   -442341447,    808119183,   1166827075,   1177417517,  -1856155370,  -1464837036,    -60624923,  -1306220638,    -91104698,  -1434621430,    548899241,     37351476,   1478278431,  -1255061434,    248470035,
-104642597,  -1865169521,   1418373655,  -1660810523,  -2129015436,    154612798,    276575732,   1930338442,    179503250,   -929294855,    -39452027,  -1377657544,   1442322193,   1137511318,   -432158653,   -984801987,
743099148,  -1118893528,   -904123623,  -1273146363,  -1884800406,   -803169061,   1254123158,   -484252077,    317646844,    404246525,  -1230293916,   1121445742,    -19657507,    652967153,  -1055406692,   -468950719,
-1493532921,  -1447624258,  -1369679689,  -1517000228,   -145853307,   1518006526,   1591195514,  -1475557146,   -909722097,   2103182976,   -406830579,  -2124025254,  -1804819507,  -1357512858,    567321869,    409048156,
567805180,   1749009386,   1762759722,  -1770324077,   1271140844,    468219092,    955792405,   1911965665,   1876314424,   -718200715,  -1278883927,   1392281730,   -120519585,    851473793,    245054754,    -33369039,
-284877584,   -479534880,   -212346563,   -122017521,  -1461429983,   1331007370,   1788621721,   1739036536,   1446350953,  -1985448033,    685528610,  -1386434659,   1368233993,   2021786790,   1596478397,  -1716635278,
-2011083017,    171876097,   -311529197,    687812052,    377000657,  -1055547517,  -1499047842,  -1818434951,   -120863666,     33888043,  -1387509273,   -541540700,   1162597745,  -1331415338,   1931708792,   -850270000,
663845594,   1536495943,   -322924971,  -1380272203,    261190298,   -204874428,  -2104974031,    883819928,    155808204,  -1454446035,   1323388464,  -1696505728,   1549800285,   1018150463,  -1327715703,  -1582480640,
1013659809,  -1820360082,   1666498787,   1406120540,   -196541482,   1248470531,  -1250433281,    836375878,    177646854,  -1927020253,   2145878321,    689712096,   -596605921,    348283199,   1916993096,    481356808,
-339687826,   1219340319,    718895887,  -2007521340,  -1859185806,   2042164737,    -58146784,    742449142,   1930754708,    780832111,    715056441,  -1393886151,     -8150527,   -599607443,   -537300865,  -1212516084
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class Well44497aTest {
public void testReferenceCode() {
final int[] base = {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,
-595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,
-1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869
};
final int[] init = new int[1391];
for (int i = 0; i < init.length; ++i) {
init[i] = base[i % base.length] + i;
final Well44497a rng = new Well44497a(init);
final int[] refInt = {
-1464956854,  -1524360321,    986845646,   -182050548,   -818943186,  -1744848370,   1392434650,   -182648505,  -2026593838,   1254866610,   -410459761,  -1392048371,   -968730026,   1485793687,   -728749746,   -112685463,
275126404,  -1101838984,   1193096287,    443511615,   -510869213,    549869992,   1974458428,  -1217587840,   -335835016,  -2048974745,   1066947099,   -611611187,   1978925459,    688164478,   -463344808,     56995910,
699288809,    606392470,    117418673,   1948706703,   -485598135,    385841705,   1725261146,   -919553921,     70643668,   2128611684,   1720197347,    738706713,   1162026860,   -611442152,   1469145601,   2051653750,
609067755,  -1971782890,   -971114565,    776260144,   1619791127,  -1547233838,   1502505722,    913168193,   1761269649,     81782996,     62251540,   1519079156,   1239007000,    489633356,   -800433470,  -2107278046,
495320431,    269446836,  -2013306553,   1074614697,   1645125348,    584369930,   -405429577,   1211134012,  -2060113546,     -2047824,   -443978800,    271218497,  -1002185964,   1519315874,   -695096464,    -79101601,
-1521653608,    192426133,   1159511202,  -1354494985,   -477280535,    583522228,   -661741458,  -1251175621,   -369487281,  -2015449518,  -2102058930,   -645264919,   -925270025,  -1674575999,   1363844609,   -831732660,
-1668989157,  -1861246633,     83763283,  -1056074975,   -519054258,  -1546386261,   1691674654,   -885968657,  -1189571815,   2095154843,   1686743191,  -1859471265,   -261593938,   1721982136,   -491120252,   -949699153,
642525852,  -2005306625,  -1004765905,    742736856,   1653443876,    788423835,   1536155740,    879514143,  -1510757104,    115238646,     28600662,   1485490803,   1272460710,    523153480,   -766782926,   1332478031,
528775440,    302965264,  -2046891123,   1108139271,   1611601128,    550846467,   -439082190,   1244786747,    941120547,    -35568474,   1756370964,    304870369,   1902684028,   -408710726,   1673189520,   1180987663,
-1488131864,    158973303,    154514890,  -1387953397,   1453732833,  -1342263302,   -628153633,      4710424,    619931109,    721411332,  -2135645486,   1688696681,   -891749588,  -1641122924,   1397432310,   -865254619,
-1635468227,  -1827787970,  -1311416657,  -1022618057,   1411688086,  -1579840139,   -637954674,   2115653281,  -1155985079,  -1043532593,   -374286955,  -1825883832,   -227940643,   1688394137,   -524577925,   -983222470,
-1955769926,    626525757,  -2009760930,  -1855453635,   -676923169,    754966926,   -291202391,  -2126042921,  -1477304277,  -1409345382,  -1264640578,   -441993991,    -17611930,  -1576809974,   2137694350,   1299022733,
-762509116,  -1087399293,    819303572,    -14571174,   -719035481,  -1644675278,   1492736905,    -15038081,    974773023,   1087127339,   1790024863,  -1493135734,   1936273291,   -442361741,   1639666948,   1147532756,
174955156,  -1537685747,    187972574,    275303083,   1420277149,  -1375787574,   1873043153,     38164241,    653451946,    687758113,    899667071,   1722219976,   2146668333,    587401069,    -26582672,   2034645447,
1401801794,   1043291001,  -1277898614,   2116116828,   1445274301,    150534325,    469242183,   -937704471,    171074779,   -204638071,   1269913689,   -771734064,    -12280461,  -1182158859,   1704390140,   -263303749,
-848503723,  -1822849148,   -634064465,   1130988864,  -1515750310,   -908815400,   1487214333,    994482967,    853103628,   1711185413,   1520342001,   1067859186,   1693632130,   -603831333,    292236742,   -800655385,
-1467184928,    221125007,  -1697377800,   1293953144,   1730537111,   1073329737,    519625212,    689636032,   1127394154,  -1496469136,  -1214585810,    822152197,  -1572579275,   -527866383,   -996792678,  -2058452887,
-1133767559,    576275042,   1579109209,   -295089371,   1502267384,   -724281876,   -911879875,   1131096177,    333026744,   1238706603,   1067340063,   -745697708,   -973992204,   1560446744,   -664017057,   -616056490,
1099714049,    674159948,    383625825,   1411443110,   1862818263,  -1896254899,   1322476914,   -719144734,  -1540101945,    988154902,    781856577,   2013381051,  -2059071359,   -142073207,     60252832,   2052050421,
-666391497,    376633738,   1663011481,  -1706886481,  -1870003191,   1003819645,    898131216,    778824906,   -656875645,  -1730811011,  -1751653787,   2056079904,    231977636,   1831419220,   -465545074,  -1505266471,
1034419975,   -133864043,   1876779821,   1879792902,   -100100435,   -959264741,   -472668436,    203584096,    -46980157,  -1478047098,   -979669209,    809008494,   1279644171,   2055793632,   1385672419,  -1756428826,
-1790481031,  -2089665073,  -1608595011,    457322987,   1267418945,    -19541848,   -796352273,  -1049973752,     30940894,   -539710199,  -1097391703,   -779353550,  -1328320498,   -735447662,   -918513196,   1516945649,
1218919237,   -251287485,   1826366637,    353082340,    889839220,    399638904,  -1462573609,   -618450466,   1429903706,   2095548034,   1486594475,  -1053248922,     74346322,   -357998703,   1790710495,   -146359619,
1581657509,   -797737661,   -920778913,    608399665,    646679359,   1861775150,  -1014371223,    476735306,  -1577737028,    383018939,   1234592859,    344770283,   -472763155,    187217985,   1245828866,   1936329359,
61243025,  -1979390025,    903671173,    302699505,  -1677126111,  -1194113496,    835857595,    706998946,     70931462,   1374113464,  -1464459699,   -231081598,   1366205112,    396990527,  -1615015619,   -968458597,
457632575,     24361353,  -1120685182,   2101590608,   1654666456,  -1208442054,    579414359,   1078056578,    217408674,  -1560683025,    815178420,   1219326466,    450032327,    774403237,     54597342,   -664057229,
447132403,     50603973,    435640301,  -1224073863,  -1339908037,   1775470944,  -1378119263,  -1375189988,  -1287971162,     29816317,  -1313418882,  -1824967031,    443540716,     11064217,  -1463969487,   1967601549,
124474667,   1230898256,  -1741455555,    561643750,    933295231,   -923145874,    245538199,    289478386,    200552280,   -268887021,  -1598221376,   1236123270,    318325803,    773964550,    191670680,    158043961,
-762639146,   -416703928,   -721969492,   1664330785,   -584949010,   1509045840,  -2066001147,   1728613092,  -1103375821,  -1262079070,  -2034789427,   -418216342,   -546365126,   1235751589,   1639799329,   2085089663,
-697590049,  -2007054256,   -147701903,    209371702,  -1868450893,   1241065116,   1537364837,  -1035970557,    318040217,    150492098,   1841159805,   -491979749,  -1275490577,  -1759443566,   -697538216,  -1589624976,
-678703557,   -189067001,   1539472677,  -1396089831,    271512148,    180483983,    483714313,    703861378,   2122114992,   -600097045,    522009268,    160429181,   -744428886,   1541223403,  -1211039718,  -1167643980,
1551471162,   -816207368,  -1429258613,   1350901561,   1934120609,   -961643277,   -214772286,  -2128270227,  -1561239720,   1493926966,   1376671007,     94966082,    221846150,   -164351411,    -51309876,    497148497,
1233668542,    266257753,   -773473851,    953946385,    420815294,  -1390653175,   1834391782,      4704447,   -891751440,   -744104272,  -1082756642,   1431640408,  -1912055536,   -159789461,   -704946016,   1956368139,
642279822,   -374415338,   1562655802,   -272964020,   1071498305,    667364168,  -1546405154,    341389690,   1360662999,    377696332,   -437020076,  -1668574556,   1242655350,   -756555890,    645954261,   1914624235,
2134904445,   -247737098,    143667521,    -17668806,   1804148531,    414247300,   1030053929,  -1595215075,    887532426,    553113691,   1173830167,   -303724353,   -280418143,  -1143962122,  -1898518451,     36464746,
1189572700,  -1549967582,   1093341440,   -452303819,   -731023001,   1111173883,   1678013973,   -836458212,   -842956392,    212774049,   -845621791,    966282353,   -823130040,    700410571,    619075141,   -304785045,
-1816233676,  -1789653997,   -166914694,    690663021,   -669570330,   1098624444,   -987380984,    452844935,  -1089825546,   1221160503,   1217375341,    512281644,  -1106887134,   1665404458,  -1462594714,   -207498587,
-789271490,   -723469709,    512055365,   1445951882,   1692473633,   -996873493,   1445046730,    993087194,  -1666188562,   -897427329,   1008869698,   1236029718,   1499207233,   1704947182,  -1815799281,    686399988,
-475436580,   1588892458,    884859588,   -471913926,   -487416631,   1323960741,  -1257612174,   -468909314,  -1866654496,  -1417895838,   1707647971,    997140465,  -1358794225,   1929422460,   -605622778,  -1587468566,
469149623,   1121515927,    748484204,   1201983830,  -1906623591,     76398473,    261109068,   -796025669,  -1964466661,   1739898262,   -756850622,   1581369453,   1484675811,    484136467,   -705983890,  -1357931714,
548520423,    741992908,   1017931838,  -2078503520,   2097871343,    569233897,    -91903627,   1864053450,   -876129714,    336670307,  -1950420274,   -872316480,   -662220291,    275724295,    703565412,   1334248646,
-217559198,   1044090753,    743502488,  -1518545318,     20614180,   -768582053,    976522354,    -25129962,   -983639284,     71722595,   -119236393,    368844119,   -795808244,    696073964,   1379765302,    235083623,
666280330,  -1313689346,   -643870520,    534522699,   -250414377,  -1239276164,    159264592,  -1119503518,   1168161619,  -1366518946,  -1335653301,    248092140,   1390152547,   2051602724,  -1023547981,  -1479782621,
-1785785862,   1609789158,   -919124123,   1703200068,   -852553456,   1573706142,   -376011685,    305068766,  -1231775451,  -1536883494,   -125122369,   -896696968,    852651567,   -458154391,    747781704,   1173040469,
-1569200836,    312506093,  -1680530410,    117086271,    794587661,  -1231003908,  -1048955503,   2119305423,   1636729108,   -522378372,   1627421730,    545077470,  -1683264872,   1486496559,  -1793064672,   1908368749,
-1226052295,   1399248776,   -588193954,  -1289386125,    534647065,   2126245059,   -238362987,  -1244573058,  -1571832269,  -2052693379,   1494767731,   -528668449,   -980826491,   -151282847,  -1468523556,   1876349941,
-301654558,   1467960576,   -741720848,   -612158589,     92376910,    987915105,   1037689578,    793773489,  -1387669541,    349490139,    564784004,  -1161242130,    619703053,   2063233129,    190888106,     81845991,
-1482466066,    283234313,    114355492,  -1879406787,  -1283370924,  -1378903370,   -730141747,   1570738286,   -281348873,   2131743196,    795654462,   -497365688,    437612465,   1928618254,   1433118279,  -1801292119,
-2059248836,   -221673230,    163637697,   -411319468,    244353317,    786753178,    489172932,    464627154,   1258915212,   -229028334,   -994675463,   1931657329,   1784181437,    -97111947,   1728952452,  -1329133577,
-1606156362,   1341196121,   1679632329,   -796545286,  -1021125869,   1427825468,   -214986389,    250791528,   1029777000,     90661677,    602529506,   2068040879,   1483801763,      2332097,   -457467017,    672399614,
1542769193,   1781253216,  -1967165705,  -2052227925,  -1248173215,  -1676554121,    292413596,    209649573,   1750689340,   1946874730,   -832845570,   1774178655,   -450175610,   -431901779,    613330756,   1969434259,
1251099237,  -1320908513,    -50659188,    273178515,   -296290724,   1195998469,   1329813722,    759419114,   1003396150,   -274557619,   -548886303,  -2055397788,   -766678640,   -464045978,  -1835907569,   -169406709,
820751456,   1778613303,  -1582073956,  -1728391771,  -2075389498,  -1606584632,  -1702107251,    -15724560,     45610235,  -1967510298,   -671487775,  -1841110041,   -913365944,    869680052,   -798103472,  -1564096927,
-918899909,   -810066882,    428829752,  -1413487973,   -844240890,   1343914280,   -689285374,   1827745702,   -799686631,   1696465705,   -726159000,  -1381157526,   1649221296,   1791106481,  -1872852642,   -485685063,
1534949133,  -1611901907,   -581776031,    242740701,   -382394666,    668419384,    388297992,    748818886,    713804061,  -1783774172,  -1823401590,  -1009098384,   2071462929,   1154475522,   1309810666,  -1734475040,
1212095416,    988288210,  -1457428115,   1699730041,  -1804729443,  -1922824494,   1000076038,   -226555981,    131425181,  -1071582828,    357680377,   1574190179,    996651958,    965704429,    -47651768,    243931978,
808955117,   -652323633,    544967309,  -1199510217,    702795379,    997685748,   1593927308,   2119371055,   1451401230,    -41992913,   2033816081,  -1030495962,   1764010175,    457470691,  -2001190141,   -373358035,
-1950331268,  -1291674220,    642934467,  -1825725718,  -1555687487,   1664472129,    -24722338,   1899539596,     78519318,   1662555805,   1744711308,  -2142888582,  -1597853572,    118030659,   1596713428,    404304267,
-1350880388,    648702031,   1185458591,   1798138033,    819516445,  -1466759682,   -751277607,   -879817426,  -1931050435,   1465603177,  -1402344216,    768491239,  -1404853657,  -1915685264,  -1845859847,    313163207,
1239598382,   1988767047,   -555152530,  -1925665864,   -182399255,  -1392390808,     64861291,   -511875035,   1879964459,    918905020,   -840773616,    459610189,  -1522352470,  -1821396360,    977274705,    -60616465,
-1846727880,   1208592937,   -515359427,   1127607806,   -395032287,    491869604,   2053794084,    568321750,   1597027438,   1355613070,  -2069482724,   1899252555,    844726247,   -625112193,   1146099491,  -1037855139,
1203928737,   1875686061,    994108281,   1471873396,   2026801570,      4941446,  -1066074241,   -983738686,   2037429697,   -836521112,   -633388883,   1221918725,   2137035208,   -369891832,    372509548,   -110916409,
80517712,   -658056946,    727893428,  -1353651002,   -475459562,   -291323023,   1059377566,    591801919,   1018232602,   -348255729,   1863827426,    246032476,  -1026132864,  -1356383176,  -1224690998,    262442981,
1257773681,  -1738604660,     77131430,  -1320261233,     -2342727,  -1817187590,  -1883997191,   1367221809,  -1863623746,  -1132606249,    149024763,  -1228275128,   -578030399,    356914163,   2109691820,   -880313621
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class Well44497bTest {
public void testReferenceCode() {
final int[] base = {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,
-595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,
-1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869
};
final int[] init = new int[1391];
for (int i = 0; i < init.length; ++i) {
init[i] = base[i % base.length] + i;
final Well44497b rng = new Well44497b(init);
final int[] refInt = {
-102003638,  -1254584449,    836441550,   1949705484,    653000494,   1579400718,    699652570,   -140738233,   1164288466,    419933874,    366568847,    780567309,   1867405910,   -350557801,   -964350642,  -1323492759,
191502468,    398676344,   1568976991,   1005053759,    199053603,     31083944,     74697788,  -1343941248,  -1205631880,  -1637961625,    361813531,  -1706096179,   -403340909,   1666226814,  -2034962600,   1237102662,
-1833248535,   1584255126,   1295661745,  -1753848945,   1208145993,    930278953,   -733716134,    192752767,   1692463060,   1727273316,   2122952931,   -809025255,   -992081044,   -895539688,   -419372543,  -1835478922,
2089629419,   1646590742,  -1261083717,  -1005462992,   1619627287,  -1437723182,   1619689210,   1319393089,  -1816963183,   -150214444,   -513482220,   1897815796,  -1861960936,  -1766444468,   2034653890,    585657634,
1867016559,    696942260,  -1536237241,   -527055447,  -1554805020,  -1063992566,   1024799415,   1782080572,  -1884276362,    129028272,   1427925968,  -1154222271,  -1383146732,  -1580532830,  -1907049616,   -104299169,
-1780913000,  -2090815339,  -1789809502,  -1521443849,   1226625769,   1126090676,  -2117094290,   -449575109,   -218982833,   -695554478,     35923022,   1386126825,    -95031305,   -168657023,    436674049,  -1137917876,
-2045134053,  -1025629865,    133144659,     64226081,  -1966942130,    700813483,    344058910,   -910646033,   -212789479,    740360859,  -1269028713,   1517763679,   -664178514,   -683718472,    -71951996,     86583727,
-1235669348,  -1426987265,   -166598353,    214190040,  -1436967644,    233824411,    710927452,  -1939548641,   -433607408,  -1075939594,  -1549702826,  -1310827917,   -640604762,   -696863672,  -1282162126,   -546470833,
-1516734192,   -513809904,   -458526835,    708926727,   -476643096,  -2108375037,     -2870478,  -1460116421,    436587555,   -948939610,   1891375124,   1944216545,    959034236,  -1267038790,  -1695098736,   1853748495,
1594424552,   1270099319,   1139585482,   1837434635,   -709909535,   -457524230,   -887118113,   -241703912,  -1888225819,   -751575804,   1122280146,   1194255209,    949350188,    892826516,   -791212042,   -151203035,
-859297731,  -1979039938,    323603119,  -1022065097,  -1804294506,   -385802891,  -2127523442,   -720380255,  -1315859127,    999649487,    335041941,  -1732821688,  -1833409827,    535715225,  -1285355653,   1206723386,
-1141619270,    759796285,  -1599504546,  -1988521411,   1056668895,   -852564594,   1056509609,  -1831687977,    754168875,  -1301144422,    922880446,  -1502666503,   -949791898,  -1043870198,  -1136941938,  -1649670259,
1342769348,   1692605059,   -132279148,  -1108038310,    -14355545,  -1611387086,   1651826569,    877600127,   1356160799,   -759125205,  -1300490081,   -414938486,   -201479285,   1958709363,   1513313540,  -1396836908,
1352702612,   1142506253,     52969438,   -365142357,  -1619054179,  -1368514102,   1470750417,  -1420830959,   -843909462,  -1679570143,   1447444607,    234551752,  -1507452115,  -1433234579,   -680890000,   -497305145,
860408898,    263376761,   1537070218,   -592353956,   1587852989,   1756653749,  -2081320633,  -1547020311,    723771611,   -883819383,   1899879513,   -268417584,   1058606451,   1665941493,  -1630340612,   -614737477,
891313237,   1368950660,  -1166187089,    296322368,  -1908770726,  -2120378408,   1245479677,   1879710487,  -1705947124,   1018371589,  -1715010575,  -1096078094,  -1749891454,   2130888667,    318647750,    554592231,
-489121568,  -1809605233,  -1697905160,   -953926536,  -2013960553,   -148884919,   1822739964,  -1466301760,    141999978,   1946526064,   1323036718,    864390149,  -2141665227,   1510602225,   1468408474,   1277039721,
-1368096647,    180965986,   2140852057,   -688071899,    819713016,   -154385940,  -1182972611,   1257224305,   1392607672,   1364245931,  -1768434401,    323522132,   -555278604,    474186520,  -1178901665,  -2137343658,
1636421121,   1398987084,   1276656225,   1013316006,   -955917865,  -1537149363,   -179145358,    342862050,   1172728007,    736300054,  -1114656959,  -1831840325,  -1882353535,   -442915191,  -1206488416,  -1818534411,
25312311,   2100297098,  -1562767719,   1762553519,  -1853194231,  -1152612739,  -2020055792,   -809572150,    848584579,   -535789699,   1817604709,   1343773216,   -602234204,   1739930964,   -833790834,    501215449,
-730104057,   1217783189,   -681773267,   -611951354,    978387629,  -1516811237,    974303980,  -1389665696,   2091099075,   -727528826,   2116026151,    271935854,    613242379,  -2100429856,    190004963,  -1629612570,
-1362888327,    175094223,   -917873219,  -2008308245,   -401946815,    504218792,  -1966525201,      4106248,    164895454,    226502921,    655865257,   -610528718,    189428750,   1055978898,     17603028,    591024369,
1127922501,  -1546639293,   1994174637,   -724136988,   -673919372,  -1665002120,   -612145705,   -793102882,  -1904763558,    757565058,  -2091240021,  -2123324826,  -1518702766,   -802889839,   -223045921,  -1509216579,
1195556261,   2079259971,   -903969953,  -1781800655,   1834950463,   -956531922,  -1152550807,  -1116052662,   -348802884,  -1395330117,    -91758501,    -19115285,   1926930669,  -1015793599,    545904386,   1617858191,
716963473,   1917089719,   -980914811,   -212646927,  -1634695647,  -1857924568,  -1462257477,   1273750178,   1060328454,   -361604424,    867932749,    451213698,    405780152,   1165233215,   1877230909,   2103114395,
1644330815,   1252998537,   1961603970,  -1533101488,   1790456024,    -38226118,  -1306744489,    713676418,  -1535871838,   1378109935,   -338185548,   1647669762,   -477465913,    203482277,  -1949756706,   -503326093,
-638704909,    320186309,  -1435581459,    907446649,    -77384645,    537368928,   -335347295,  -1912061924,    547819174,   -225549827,   1089455486,    463516297,   -240127764,    -85895271,   2053179697,   -287394931,
921878827,   -933362608,  -1178670275,  -1200942874,   -672571265,    574422382,   1441734039,  -1814493454,    165751640,   -176907245,  -1170992192,  -2123252090,  -1435971541,   1591853830,   -885477992,   -792847559,
1359875286,   1038392904,  -2027255124,    687291425,   -165513490,   1391146576,  -1387080955,    794663652,   -807189965,    667820962,   -545384499,  -1371368854,   -689031878,   1504805541,   -752825823,  -1920047745,
-1884874017,   -350566320,   -197152911,   -181743050,   -798415949,   -915922276,   1790690149,   -363997181,   1923116185,  -1326427198,  -1621079427,  -1997440997,   1798118127,  -2053110382,   -159879848,  -1286787216,
1046436411,   1832030471,   -389092059,     71686169,    -76025260,   1914270607,   1854169353,    872157826,  -1774323792,   -575165717,  -1919931724,   2051498109,  -1176174934,   -883578901,  -1253047270,  -1310573900,
245466682,  -1784824328,  -1319912821,   1377340217,   1364313761,   -408687373,    142333378,  -1952335763,  -1703126184,    316314678,   2030555423,    488640834,  -1783293306,   2116925005,   -428337460,    -42966447,
-476226114,   -325172903,  -1690748475,    852791569,     26490302,     85251337,  -1374975770,   -376283969,    982639600,    595119792,    376403422,   1574509912,  -1509664496,  -1901241749,    -59019104,    358566667,
341667214,    184541206,   -550950854,  -1897143732,   1595753537,  -1236127928,   2014297822,  -2033179270,   -669806121,  -1927596980,   1010735700,   -581795164,   1922398838,  -1456743538,  -1633813803,    323177707,
2002098813,  -2099067658,    277393729,   -671911622,   -384463053,   2028267908,    367391785,   1270052637,   -172839030,   -650486693,   -831800809,  -1255138113,   -137512799,   1904317942,     -8229811,    707361898,
-276859812,     50417442,   1487081728,   1577776181,   1994451303,   1237303035,   -602016235,  -1905218276,  -1895725672,   1172978849,    801129953,  -1819485071,   -587985848,  -2010386741,  -1645226427,   -850866837,
816998708,    357665811,   1955856762,   1617902189,  -1013761306,    146782652,    904185608,   -500146809,   2085848310,   1917713975,  -1823786899,   1994184748,    789196322,   1766857258,   1770685286,     58213029,
-1699628994,    346827379,  -1274423227,     -5079670,   -193099487,   1020296939,  -1795904054,  -1951053094,    -43782418,   -375403393,   1026761026,   -207269610,   1364563521,   1578793454,    457809423,   -534138380,
-1052938788,  -1897101526,   1449976516,   2052800058,  -1145169719,   1476303269,    370625650,   -325249282,      2165984,   1631432802,   1032336355,  -1292978191,  -1810172401,    725725820,  -1162678778,    702624490,
1387673527,    981825943,   -556408212,  -1108487850,  -1782136935,   1582316425,  -1752682164,    307235003,   1386486299,  -1343636074,   1936875586,  -1265279891,   -345847069,    928241171,    239050350,   1859358526,
-664776217,   -823267892,    346651710,   -867656288,  -1907921425,   1362445801,    541145461,   -192727350,   1649366606,    244694627,   -488180018,    214008256,   2032125437,  -1678591993,   -264593820,   1309017286,
-652451998,   1845366657,   -703990120,   -550186406,   -630285276,   1782372955,   1650564210,  -1127904234,  -1407983860,  -1119422877,  -1565976361,  -1913545385,    549841420,  -1410323732,  -1964467146,    228296551,
-421026422,   1929094398,   -266906424,    264810315,  -2008122665,  -1088278148,    141242192,   1871293282,    234634067,   1724159838,   1638271051,   -837713428,   -657941661,    168093988,    708605363,  -1881612509,
-1810496006,   -193495322,   1889982309,  -2050702012,   -693694192,  -1249780322,    718733403,    -76349730,   -188217051,    920912090,  -1814078273,   2013358456,  -1948845521,   -198407575,  -1248904632,   1182772565,
1236791612,  -1297489171,  -1958468586,   1437011007,    390460941,    113068796,   1247982993,   2102889679,  -1563524844,   -128174212,   -754095070,  -1461699362,    943615640,  -1013270737,    221253920,   1514140013,
1596946745,    674222984,    616356702,   1811224435,  -1764322023,  -1653707581,  -1702404459,    390678142,   -209506765,  -1398278531,   -117061517,   1625861343,    659048069,  -1490678943,    846536668,    210715637,
1855458786,   1727745280,   1086729456,   1109111683,   -985298098,  -1813777567,   -954599702,  -1522494031,   1166103515,   -191868965,  -1048777852,   -661271058,   1161457421,   1509090409,   -919753558,   -155431193,
-1774302994,   -366390263,   2090138916,   -693431491,  -1693888428,   1846774454,    925855693,    474383470,    208889079,    382195164,   -283005634,  -2095134392,    579927985,   1390765326,  -1766119865,    900457129,
-1503703236,    974952690,   -107714111,    381338452,   1187256613,   -860560742,    524103620,   1499506130,    197755276,   -790802926,   -406920967,  -1972219791,   -665721155,   -113336203,   1037154436,  -1185441801,
-745541706,   -546274471,   1988928457,  -1975403782,  -1167172845,    777779004,  -1560935061,   -140258712,  -1243598232,  -1394149587,   -785002782,    311842991,  -1025469277,   -605350463,  -1251538057,    537203966,
597777961,  -1845767072,  -1556349193,  -1491015509,  -1935936671,   2093498487,   1908270236,   -315396187,   1356362300,  -2025658518,    630119678,    276190559,    510123398,  -1266145363,   -170152124,   -151540077,
-477900187,   1895894303,   1870333068,  -1169891437,    353366620,   2111175941,   1691245786,   1318765802,    -90993610,    921309517,    118241505,    367005284,   1624861072,   2010785894,    865255951,   1717799691,
-80757664,   -644944841,    136999836,   -341686875,  -1908076090,  -1968934200,   -346397811,   -184213520,   -511811333,  -2118173466,  -1086490399,   1795322855,   -635494328,    415716276,    851044432,   -904636831,
-1972230341,    -64337858,    571177016,   1248814747,  -1351030778,    457872680,   1843549954,   1718960038,    815088665,   1812961065,    360686952,  -1356586646,   1657802416,   1776192945,   -786723490,   -342254407,
-236653811,    771014701,    906386785,   -308057635,   1907957462,    206000440,    -42143480,    900403654,   -917549795,   -310520796,  -1713627766,   2061136240,   -377977839,    891282946,   -821163030,    328143584,
1503793080,    551621842,  -2086273683,  -2070526343,     91195293,  -1654389038,  -1035734266,   -336619597,  -1220221027,  -1468468844,   2105626873,   -841372573,   -122707018,  -2013073683,    494461000,  -2054807734,
-67946259,   1914163407,   1941835405,  -1027244745,   -768123277,    419129844,   -275750260,   -171533009,     97756174,    -17651409,  -1578102255,    995291430,  -1587462977,    692904675,    951632643,   1882101293,
-1546298756,   2018418068,  -1790777661,   1542305514,  -1437624383,    469587009,  -1647853474,  -1318279028,    497228822,    726733469,   1693133452,  -2091185798,   -209017732,    126386499,   1056958932,  -2105494133,
754067324,     96463951,     83701151,   1101658289,   1485852701,    553783806,   1898769881,  -1072031442,   1438062141,   1992540265,   1152252136,   1019391719,   -175951257,     -6691216,    989789689,    968359367,
-1330392786,   1704963399,   -998432914,   -948060232,  -1921688855,   -975840920,   1360273515,   -872810459,     12676907,  -1908050756,    883609616,     65641549,   -200365398,   1386653304,  -1203665071,   1878689007,
426262328,    315375145,   1900325181,    703658494,   -765404895,   1070155172,   1399748900,   -804264234,  -1619419026,   1347225486,    230635292,   1093717835,     14020583,  -2107039873,   -968325341,  -1679158691,
1959784097,   1065690797,   1090615161,   1311445364,    865835426,    870016646,    574122879,   1842697922,  -1289210431,  -1914001560,   1672467629,   -900366331,  -1524066872,    136503816,  -1910431892,  -1431958329,
-830367152,  -1316233970,   -801974860,   1560669382,    -81784810,    401822577,   -949103202,    943897151,   -722666726,    -96825841,  -1092898846,    230567004,    -70355840,  -1398069192,   -312953142,   1475420133,
-622491023,   1661205388,    -19071322,      6024591,   1473041593,   2053897978,  -1346768903,   1484764721,  -1552461890,   1287146711,   1613069307,    902497864,  -1504480063,    375292915,   -836353108,   2047602411
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source32;
public class Well512aTest {
public void testReferenceCode() {
final Well512a rng = new Well512a(new int[] {
740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,
-1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000
});
final int[] refInt = {
1634813289,   1876773016,   -973836208,  -2130023652,  -1045460084,  -1834384857,   1691032973,    609714289,
2033920362,    555915483,      6680992,   1958127415,   1866469645,  -1471336965,   2049178762,   -192324811,
-2056050066,    810879705,   1405046309,   -781317118,   1012782311,  -1045081032,    728377508,   1473511660,
290489070,    326666761,   2018299979,  -1876688058,   1239968501,   1464625040,   2025151042,   -101397407,
1387902041,    210959839,   1366359326,   -476473433,    153180037,  -1607631523,   -506743495,     17888738,
313865008,   -340504498,    586684079,   1243699375,    753162229,   -646761694,   -739189655,   -210120185,
-1856358726,   -628255542,  -1812798197,   1416288088,   1077967722,   -846846208,   1379850409,   -580183344,
-1858959,    210859778,    295841424,   1492774865,  -1415543680,   -344870570,  -1942779197,   1549510646,
-389544849,    314254218,     11784988,  -1311757368,   1719514841,   -764610517,   1296788970,   -994707050,
783854563,    422654144,    387639079,   1219688425,   2144352572,   -834212874,  -1036550358,    935909479,
-568610842,   1327498837,   -588933178,   1910065754,    -40851599,   -182063170,   1302731458,    541311559,
-1647345522,    805224371,  -1721196679,   1518507830,   -952689880,   -433276260,    509675254,   -777259954,
1277810106,    284054896,    936042202,   2036836351,   1956412426,  -1186403024,    287795400,   2135311211,
720485927,   1500695024,   -281656583,  -1277937322,  -1628968482,   1242814831,  -2030700974,   1473867890,
440813549,  -1357033971,     28384076,   1602731216,   -641465746,   -609054347,    635938444,   1472898176,
1476894555,   -747974186,  -1590337055,   -884242108,   -389736197,  -2066984505,   1087103272,  -1236446290,
31657463,   1835715432,   -468439078,  -2132633204,   -434609235,    258308151,   1851926761,  -1630139159,
-1344617241,   1969204215,    619463174,   -174392624,    207475487,  -1619828078,   1327980298,    -83968178,
445951782,  -1786230541,      6279288,   -580982231,   1550645552,   2006533941,    275746007,    455676647,
2019637349,   1115547704,  -1313120106,   -516213449,     73752461,  -1382448112,    398589620,   1319888048,
-1595572334,   1566934536,  -1735685764,  -1509545339,   1458173912,   -549395819,   -618827040,   1516624531,
1900757187,  -1454200688,    965524719,    488355065,  -1869294316,   -810641680,  -2059428251,   1454656431,
1329120541,   -232185900,   -994996943,   1855980910,   -452077812,   1565630611,    759842266,   1241435187,
-1390456063,   1946400597,  -2032319771,    683667881,    905911106,   1983310786,    120010546,    526018017,
-1946881912,    205004987,  -1307250612,   2130980818,   2052864161,    189839787,   1789478047,    406168885,
-1145186347,      8507675,   1277188815,   1492619042,   2009819675,  -1627411598,   -851016743,  -1828234956,
1962622506,   2140398255,    236935165,   -337237772,   1263419111,    516775236,   -335741025,   1391328225,
455979249,  -1457534664,   -657606241,    485648133,   1762116343,   1194889600,    817834937,    321150162,
131159182,    290277758,  -1876924740,  -1770401129,   1291602973,  -1003642974,  -1580211929,   1520422021,
-399171579,    -24315308,    453805396,   -659197747,   -205656847,    466526550,   1444397201,   1178091401,
-1157268826,   -602394028,  -1370668795,   1614896435,   1699071659,   1864753793,   1888518358,  -1721244514,
1812776767,    668822227,   -297283057,   2130183333,  -1169618692,    912860240,  -2028253096,   1244694278
};
for (int i = 0; i < refInt.length; ++i) {
Assert.assertEquals(refInt[i], rng.nextInt());
package org.apache.commons.math4.rng.internal.source64;
public class MersenneTwister64Test {
public void testMakotoNishimura() {
final MersenneTwister64 rng = new MersenneTwister64(new long[] { 0x12345L, 0x23456L, 0x34567L, 0x45678L });
final long[] refLong = {
0x64d79b552a559d7fL, 0x44a572665a6ee240L, 0xeb2bf6dc3d72135cL, 0xe3836981f9f82ea0L, 0x43a38212350ee392L, 
0xce77502bffcacf8bL, 0x5d8a82d90126f0e7L, 0xc0510c6f402c1e3cL, 0x48d895bf8b69f77bL, 0x8d9fbb371f1de07fL, 
0x1126b97be8c91ce2L, 0xf05e1c9dc2674be2L, 0xe4d5327a12874c1eL, 0x7c1951ea43a7500dL, 0xbba2bbfbecbc239aL, 
0xc5704350b17f0215L, 0x823a67c5f88337e7L, 0xd9bf140bfeb4c1a9L, 0x9fbe3cfcd1f08059L, 0xdc29309412e352b9L, 
0x5a0ff7908b1b3c57L, 0x46f39cb43b126c55L, 0x9648168491f3b126L, 0xdd3e72538fd39a1cL, 0xd65a3663fc9b0898L, 
0x421ee7823c2af2ebL, 0xcba3a4b69b6ed152L, 0x348399b7d2b8428L, 0xbdb750bf00c34a38L, 0xcf36d95eae514f52L, 
0x7b9231d5308d7534L, 0xb225e28cfc5aa663L, 0xa833f6d5c72448a4L, 0xdaa565f5815de899L, 0x4b051d1e4cc78eb8L, 
0x97fcd1b4d342e575L, 0xef6a48be001729c7L, 0x3982f1fa31afeab8L, 0xfdc570ba2fe979fbL, 0xb57697121dfdfe93L, 
0x96524e209b767c29L, 0x55aad0ebca994043L, 0xb22687b88856b63eL, 0xb313b667a4d999d6L, 0x7c7fa1bd6fd7deaL, 
0xee9f4c15c57e92aL, 0xc5fb71b8f4bf5f56L, 0xa251f93a4b335492L, 0xb9bad7f9e5b07befL, 0x62fc9ac35ccde7aaL, 
0x933792382b0218a3L, 0x7d497d2f7a15eaf8L, 0xb2f0624214f522a2L, 0xd9895bbb810ec3d6L, 0x22d91b683f251121L, 
0xc8fe9a347247affdL, 0x3462898a2ae7b001L, 0x468bc3a10a34890cL, 0x84ff6ce56552b185L, 0xed95ff232c511188L, 
0x4869be47a8137c83L, 0x934606951e6fcd81L, 0x1ab5e8e453bde710L, 0x6386b61b30fa1157L, 0x97f3a778e242d0cfL, 
0xd870d281b293af3dL, 0xc3a5f903a836fafdL, 0x88bd6a24d49cd77L, 0x4e38ddc2719162a5L, 0xf48286b4f22cad94L, 
0x80f6f650c337557L, 0x5e6daf6aae1ad59L, 0x7450f7229f336762L, 0xb75b43fb4c81784aL, 0xebd37a514f153148L, 
0xd4b3a39e0bc52c7L, 0x562f36fae610a2e1L, 0xe0e413e555bd736L, 0xd452549efe08402dL, 0xf2e2ff7be2c75e21L, 
0xf2385606c18aaf0dL, 0xdb609b507d8c6b8bL, 0x74ac5663c6c4f45bL, 0xd84c9a356858060L, 0x19d5b3643bc029b6L, 
0xdd8131e97ffc842L, 0xfa7303606bfffc05L, 0xf98c6d63ff48a16eL, 0x34df46aa2d610767L, 0x83490ef054537f7eL, 
0xe071f833e55ebfe6L, 0xd4b94537ed4a6aaL, 0x3cf85e4e333966fdL, 0xba15364649384016L, 0xc0e6bd623ca72405L, 
0xdae6e879b8eab74aL, 0xe4a41f17e70d3e0aL, 0x56e10c00dd580f70L, 0xa9a66bb41781d872L, 0x58e42dbdffe21573L, 
0x69450e1ce9674e6aL, 0x47fe345a350aa605L, 0xac958aa80455a5a4L, 0xbc1abca3fbeeb2f3L, 0x8f760d9228900a4L, 
0x9e1eb8a2dfec4387L, 0xe91bd1321f5fdc89L, 0xda11a24c514b9dc7L, 0xb1f63d976e0e639bL, 0x41c11098f6123861L, 
0x3d7736979f978f68L, 0x820685b38c926beL, 0xe8c3dcab075b112L, 0x5e37299d89089ba4L, 0xa1f735eb8235b32fL, 
0x2289d719e7b146eeL, 0x1c9c9d0284d96719L, 0x5f8b358546775be8L, 0x317e34c009a07a39L, 0xb16b073eb0ee0a19L, 
0x423b36fd459f2a66L, 0x5f45053666f3f84fL, 0x63e7074f03c73d92L, 0x22080cf23288e895L, 0xba4e71bf61dac16fL, 
0x9643b3707db2cfb5L, 0x98e2db6c665e7178L, 0xcbc57de0ef3eabb6L, 0x6239a2197582a8a8L, 0xf2ae968e55fda13dL, 
0x36e7ac11d1f3a617L, 0x508f0acb609bd756L, 0x6f42d435193a1ac2L, 0x2df2cab9d65e0b00L, 0x4584c1fde5f1ad55L, 
0x602c500bdc8317c2L, 0xc80d5b04f6337337L, 0x98abcf971892a773L, 0x5d33cf557e6c4475L, 0x5b5a78be74ccd40L, 
0x3ec2cce5290785f4L, 0x2eef1e9c4b36828bL, 0xdd274241a0ce8c55L, 0x3c4cb919b35c221cL, 0xc1fd68d779db9923L, 
0x7ff345b4eb7f3639L, 0x804d5881b2eefef3L, 0xa15f9c2826cb34dbL, 0x64822b68adefa772L, 0x761e92f8d279850dL, 
0xa5d049ab1061dba3L, 0x5f46fb02d10d2219L, 0xc1cdaa5f9ca79b19L, 0xdd713a74701ebe60L, 0x6b626ec963951798L, 
0x1d3ec8d78b96d16dL, 0xdb885d52960e7f34L, 0xe39849cf3ea178f8L, 0xc1e37acdf807130bL, 0x3645880ebf333913L, 
0x3af81a7bec346c22L, 0x871c563e94324804L, 0xac55fb5e2817db4cL, 0x35b04c42565ebe2L, 0x5094cafab11cbc3aL, 
0x94d40a57481346b5L, 0xf91a8492df723e3L, 0x126a70b84f779accL, 0x4409e9a5d5c3f133L, 0xb1655339864151efL, 
0x6564e506d11e9de1L, 0xd9a06f7b8860b488L, 0xd493e410b68b6c6L, 0x4e6fbf4b3b985a07L, 0x71c1b0ba9e52a2deL, 
0x5775784ad3cb99d9L, 0xbab84cec312107a6L, 0xd9066f5ccd59cf9eL, 0x8c656651dbb3ed84L, 0xa7448d0059484568L, 
0x2819237e5e8cb03aL, 0xd57eaf5239931b4bL, 0x6cd436fd5f7c1e73L, 0xf03b845f2a584931L, 0x8847b9f1f2d55b7aL, 
0xd49a38f8e59db8faL, 0xd5052cc47685dbfaL, 0x91e060fb399ecf2cL, 0x5748fbea12dd2869L, 0xd0cee85adb889226L, 
0xa35e9dfa5a64f56aL, 0x3118398bd0e3cbf0L, 0x5e650b9a3cb34308L, 0xf575ccbebf49b91cL, 0xb3f8dd73257c80e2L, 
0x13d7954e8294819bL, 0x90b57ccd00f1591dL, 0xa8b13ef52ca7e284L, 0xe482d24e5b239833L, 0xb0648475f2b4d63fL, 
0x847e8fc889e2389bL, 0xa8b501ee1fc59ba6L, 0x29702f6acba4379eL, 0xfaba9600f3d2cd0fL, 0x52ed7d9f45c6b578L, 
0xa02b167546d6e2d0L, 0x9a41cb166618a390L, 0x83d464d7349d9f3aL, 0x805485c9d2c70c6cL, 0x332f7ce3e077ecceL, 
0x1ead372c068ebb04L, 0xd6866c5b3b5eb82cL, 0x5b057c64bda94a33L, 0x11e1388f59653c66L, 0xffd2aca771c0abb8L, 
0x2fabdd0e8e8ba606L, 0xe974ffd57219e5e6L, 0x2b4e5c1e5f98e506L, 0xe7819b2cb44db4c0L, 0x6cbd78c408376520L, 
0x244285f39307f083L, 0xd152927f3a3af853L, 0x5b799885a8ba66e3L, 0x9300da64ea1a0644L, 0x67399bf8688a0cabL, 
0x47c301af4a94bb2L, 0x6750ecdf35c8471bL, 0x7598ae5c876d4080L, 0x269e0cf307467534L, 0x2ef4d8dcaedbc549L, 
0x2c6983c911c958afL, 0xb2fd7c07ae0bfa60L, 0x3220a56d67450e80L, 0x7385883420eb9f69L, 0xdb1fd2951f15b047L, 
0xf08b35df55977bcL, 0x42939b9f2e58127eL, 0x4d1d77e72414aa9aL, 0xfd8137f8b59bd084L, 0x167cc7f46a511504L, 
0x263de0c6b50290dL, 0x2a1c2feb488ffab8L, 0x1194815038360d85L, 0x36374630d0ecb4e8L, 0x609d38e22c59a974L, 
0xee23867f7c9b5f54L, 0x40e53a7804b0ef15L, 0x8f287f1a3be6e458L, 0xba7334b0f0af9e75L, 0x9f003e8e0e9c6c0L, 
0xc02dd0d35c42bc56L, 0x63dca83acd6be04aL, 0x9617b58a79fdd826L, 0x563d25e6f891bb33L, 0xe3c3d3f3f6d58588L, 
0x359977baa315b1b4L, 0xdf431301d9e6bc5L, 0x4074bb10d0003ca5L, 0xf440159140f2b453L, 0x3a6cc6e14820f5e2L, 
0x4b352bdacf3a37c4L, 0x9ef3b8df89ea4c29L, 0x8a1b2495a1414892L, 0x670b7f423f78b7c9L, 0x7513c7ccf6ee3c3aL, 
0x9ba96cb53c24408bL, 0x3316c3dc4ec859f0L, 0x501337e1a7f1e218L, 0x9a1544a6029c1eb5L, 0x9b43b15859c3e96fL, 
0x58011e22698bd4bL, 0x589b8eaea60d54a4L, 0x68ccb8c6cd7ec24dL, 0xe55beb5896455705L, 0xba6069cf90a8f1e2L, 
0x896a18c3eb90a6d6L, 0x870d3d80ae0b9323L, 0x48688d8b457f501bL, 0x8f1a8c1b84b3ba62L, 0xd1b7b64dc136f6b3L, 
0x3c6a7025428547e9L, 0x199bcc50a190fb6fL, 0xa5de0eed4bda0979L, 0x31041667821cddb5L, 0xe9df34e2678fb4e3L, 
0xdd7222eaee54e524L, 0xaae6488b26c7af56L, 0xe8a560dbbd2eb6b3L, 0xe37c99a7f5defceaL, 0x1572be8d78f3afacL, 
0xf69ffb64131633aeL, 0xa837ae34963616fbL, 0xaf0a9f03d137c170L, 0xd3e02b464018a48L, 0x11753aea03bb0ecdL, 
0x32d9cca610dceb34L, 0x2622bb6a6e7a11e3L, 0xdc99a44c515ec8b3L, 0xd7d720ad0a770b28L, 0xe322f742d6d051c2L, 
0x745f2b6e3ea9cd2bL, 0x951f21478e6b9662L, 0x227f21d8c0713385L, 0xcb729235e6876eeL, 0xd323b857d9721a53L, 
0xb2f5f599eb743346L, 0xefb30babe65a283L, 0x94c1190da321d470L, 0x117c63209fba9efeL, 0x738cf92baa4bc2cdL, 
0xc3bdd29b33277165L, 0xd78a2fab38f6dc46L, 0x35c44aafdefb91e2L, 0x321e26bf321fb60bL, 0x12db436288b37172L, 
0x158a2d49e51c261aL, 0xc9202ac8ba71c873L, 0xd02fa93dc97cc7b7L, 0x1f8bd11b747e901eL, 0xf7a17b2f74aa321cL, 
0x284d02d7552a3e90L, 0xeb86a8251533c574L, 0xb3fd774eaf4e77f8L, 0x31df2951c3ff37b1L, 0x86e38546195a69e7L, 
0x6737aaf165a1389aL, 0x2e2e925079feee0fL, 0xf7bd5a988596c1bbL, 0xccf835db6a10d2dfL, 0x6f42700f37c94701L, 
0xa6e86f7ba2779a5cL, 0xa43a4f7036d1ec2L, 0xd798bd6d52ad26daL, 0x218f6912af38b818L, 0xd48684f266f2e186L, 
0x8f675048b7b012e5L, 0xe5e469aac68eaf1dL, 0xe2740035697de79eL, 0xc22d6bd6d08baf1dL, 0x341774636bdc8f41L, 
0x7dfc6b73f7ba322bL, 0x7566343607bb525bL, 0xae94d116ccf1e74bL, 0x6ca1b59934cc2697L, 0x4c2fb1c45b749cedL, 
0x989999bbdd2ec893L, 0xcc4e27afa81bc8a8L, 0x6ddadf15ebf85830L, 0x38fa9cb2ce72bc16L, 0xacdaffe39db4bbdaL, 
0xbcc4682ebd095d93L, 0x483f539d354559adL, 0x45de92e997e2915cL, 0x7ec5c881c5344a55L, 0x9d1844fffa091545L, 
0xcd9b08d4dcda27baL, 0x1f7495a5f36c34ceL, 0x4f0fc9647d99afd7L, 0x5ac375ec59321cf2L, 0x5c07ce6df7e1d9a2L, 
0x49f211880d688b4cL, 0xf85fdd8ccad0867aL, 0x7d510164d8f197a8L, 0xc64108c5732cfa0eL, 0xb262d660d3a2c648L, 
0xd5d5614571dd2efaL, 0xec1a6d0dd5d5391L, 0xbf07d939d2535f02L, 0x35bce3021e51045L, 0x423ae115ec99d154L, 
0x22ea1d3abd893838L, 0x517fc1107eaa6a83L, 0xc5967cdf353aeac6L, 0x96ae2c3dff65ce6L, 0xab1b908b97dc911bL, 
0xf3d84c286f22611cL, 0x256823815030d8a2L, 0x3bd9b119887342e4L, 0x59926f3401f437d4L, 0x74edf41038d3986fL, 
0xe2b35bf615038253L, 0x4d09740a6b44db89L, 0xa37edaf089c0eeabL, 0x8263ba2c23e2d62dL, 0x8784aff57d390c3cL, 
0xfb49ab0635d66c3aL, 0xdeba73c2562bff1cL, 0xe2e6bf8cb6e29717L, 0xe70431c63d86e46L, 0x20d717e16aae6010L, 
0x31af57cdcf2cd36L, 0xd55fbeef1c5357feL, 0xd361d871f4e393feL, 0xb3416e718d32d214L, 0x7b351f93f909fc00L, 
0x16916de7b96a26bdL, 0x4fec1248b5dedb65L, 0xfae1aa9a62bfa096L, 0x92e7910a6b0084a9L, 0xd12bba8672e8aaa9L, 
0x316558d69efc8f6bL, 0xb0dde29eb96fee87L, 0x2125a2be5bf67eb3L, 0x5905903f46531fe4L, 0x2a9927e8175ff60fL, 
0x794376f2bb5d6d96L, 0xfa9f65d2b4848b12L, 0x2b92665a263a5091L, 0xabcaccfab8464c65L, 0x5b2fb2a46d1a0bdL, 
0xa879920d28c0d54cL, 0x50394088a8ea4953L, 0x61b0c87f0084129dL, 0x29ebcd1078d6e2b0L, 0x2440c652f6bacf89L, 
0xbd74d596cf4c8eb1L, 0xe4b009e5c334766bL, 0x7db26843cf72cb8L, 0x4171d5edd5468876L, 0x608d5c2c348c143cL, 
0xa19e0a2b81da6eb5L, 0xb65a7be9354c1390L, 0xf4f4c437cb9bb324L, 0xfc24806650c823bdL, 0x4c2331521e7f2966L, 
0x54f66e42eb73bafeL, 0xf06c11f3d2fe29aeL, 0x8ba8d0f28cbb0fcbL, 0xf3617850d1ae7976L, 0x96463b47cd9a7286L, 
0x8edc2133b35c3779L, 0xae43f70f181d9371L, 0xe7628d75c9a3c2e7L, 0x978499ba4193b333L, 0x99bb4bf79b0a46c1L, 
0x4c52676d7e4d0a58L, 0x2064ee3910693deeL, 0xfc43514d16633997L, 0x1bc1741ce05c4cceL, 0x6e9588d40f3396f6L, 
0x146fe816bb3a3708L, 0x2b3db8ee05eefa87L, 0x6ec21a91189ec0c0L, 0xa8a907b34108faf1L, 0x708b80912235684fL, 
0x2bc8ba70edfe680cL, 0x4d118826481266efL, 0x8f93a3a5de887175L, 0x3308e9133a950fe3L, 0x939ed8b0d7e91f87L, 
0x666beee64002b6b0L, 0xc8f129ec69ce7811L, 0xd57593c68ce93ea0L, 0x2d6a3e66edcc862L, 0xbe1d00d16a2271a6L, 
0x34fbeaf95e0c673fL, 0x9845ab59483a0e86L, 0x257d47d5abf88962L, 0x28af39f39319545bL, 0xe3fce03abd8171eeL, 
0xa4c5f606dccc96f1L, 0x4d414846267c4962L, 0x6ccf77f81d9dbf70L, 0x947bf43c729a71ecL, 0xfd656c39c4fa824cL, 
0x8f652cf2d1e04fd6L, 0x8cb11929a65b6aeeL, 0x94948f16a8064daL, 0x7434e703a4d03d5fL, 0x9361d3f63af4aa35L, 
0xa998c1eeec3fb422L, 0x51eb94754b5992a2L, 0x6e109c0347ef6979L, 0xe3c9738d67c582e2L, 0x9c735e3857ec57bfL, 
0xbe6415659e12c64bL, 0x73924584e31b9099L, 0x8f676821e60b0945L, 0x5614e3a695d5289dL, 0x7ecd448787517ebaL, 
0xc96db02038dbaf5bL, 0x69299ed774fa6c8L, 0xb4ace5a8ea16ac8L, 0xbf2f4f23a6c92295L, 0x90bdc4f1e931656cL, 
0x7cd5b0b95ac34d3aL, 0x2032bc59d3dc1710L, 0x702c1a0cd5609379L, 0x609d33abc01ff3feL, 0x8ae5d8f283b2748bL, 
0x2cf3778fa7eaae1dL, 0xe8a0d7b1919df9e3L, 0xe487894f6d602a0bL, 0x929858549609626aL, 0x46e540cd86bf46e7L, 
0xd1daf4382128d9eaL, 0xc47239c06b22ef75L, 0x8b7aad8ffea1b991L, 0xd6c1d2e315273fa0L, 0x2fda11cd74177e6bL, 
0x333cb0a145919fd7L, 0x5970b31a49f37b16L, 0x7890bc68793bb959L, 0x2a060f45a1719347L, 0xeb298f0264bf379dL, 
0xd7c4fd7921707400L, 0x374635e7713ed165L, 0xc60c008df0296d05L, 0xbf13739a8d3c7dbbL, 0xbfb945ef1cf94d1dL, 
0x75fe953c3a3a8315L, 0x9f83064f4150c02L, 0x6784a3b452055343L, 0x73ed26d185738f51L, 0x6c59094e8c998390L, 
0xeade93e19d60d4b5L, 0x8cf7cc8e62bc869dL, 0x22f85626f7f69298L, 0x6679c449ac22edc0L, 0x7017d0003e897435L, 
0x308fc450a6c62bf8L, 0x2578b45bc6f34cabL, 0xcbb936c9d253db39L, 0xc4e70e5bbc5e002cL, 0x29db6985be6c9459L, 
0x96afe876f5f6250cL, 0x829f766f138f95e6L, 0x4369632017c8fa0dL, 0xda90c817ca890a2L, 0x38d160dd675e2376L, 
0x20df15ad986408eaL, 0xd192623c3d9b3f41L, 0xd846f79123baf4aaL, 0x6cb058a0edfbf056L, 0x1b192f0be8dc77a7L, 
0x3a11b3dfcc81a441L, 0xe914410093ad7767L, 0x3126257e578bdf60L, 0xd5d5e470410cb6eaL, 0x4e1bf5d4209248aeL, 
0xe1e4c2924f35192eL, 0xac9944825cb7ef5eL, 0x8d2cbe6996eb3475L, 0x1bc05d2a079592d7L, 0x564a9f06755e71f3L, 
0x9bb767d68e9f2537L, 0xe4b045acf13978a2L, 0x4b7519cb9028ac83L, 0x9df655284198b85cL, 0xdc32ab4d421a2b61L, 
0x4c5d7f5323c1960cL, 0xe4273ff318f5c7b3L, 0xd73ef5ea88a3e99eL, 0xda2ffb6a863c850bL, 0x9555a4144e05ad82L, 
0x950104dc15092ebfL, 0x39d121a61f19dbfeL, 0xc6804e29d60d7814L, 0x7e98bec5ba17d58bL, 0x8b2c6b0e6c3b749aL, 
0x301a07c84aaccdbL, 0x93dee719932225a3L, 0x381611a50bac0ae1L, 0x572a8816f6e407b4L, 0x420efe85aa75232L, 
0xc1f53f78b9ffcf4dL, 0xbeda53bc95b96ec3L, 0x9f357114059c8eabL, 0xe38239260b584150L, 0xccbca17f4eed2ad0L, 
0x1528080b61f54198L, 0x5b8cdc4c40d49f30L, 0x1617db48eb6640d0L, 0x6fed27f88a516c99L, 0x37056e05b4724179L, 
0xec7bc122da9538d8L, 0x9fbfe01ca2c0fd57L, 0x2fc96b31dccafd9fL, 0xe26a72009daa1249L, 0xe9fb2e3998d16a25L, 
0x4a87dc39d24133aeL, 0xd5340e98fde806deL, 0x272b62b5dd0d7fe3L, 0xca4625581bf9dbe1L, 0x8677af77de374a90L, 
0x27dbec9e28f857edL, 0xb4aefc44d036612aL, 0xcf2e8ebdb0f6bb11L, 0x76023506c94e0532L, 0x864e72d4488c7a7aL, 
0xb81058fdac18fd3L, 0xdf93ee5b6674a0f4L, 0xdb30565511789d77L, 0xcf5fe22dc0375f30L, 0xa6e62e6e4edb4043L, 
0xbce383957a728669L, 0xfe4dd4e9633db2c6L, 0x24e68818b2a6d6cdL, 0x48a89c5424b4cdbL, 0x7fc7bc75bbbe5768L, 
0x79596343191e0ff2L, 0x5510b9cd8306839fL, 0xff2668b4eae7bb53L, 0xb4c03e6363c9e244L, 0xc9e3c0c1c015eb6fL, 
0x52531f5f898a744fL, 0x484005b2a805083L, 0x31673b70c6f23c53L, 0x5bffe158f323a7c2L, 0xc742bc0d0c55f125L, 
0xd95c32fe7e18379dL, 0xc1f2f613ee3c2e21L, 0x3217a43ff0daaa0eL, 0x3a9fa27258257e53L, 0x80b42af5a393bcf2L, 
0xb6967fd6a302f65eL, 0xfdc07bc592dbb125L, 0xcb83b8b9f64c3c3bL, 0x9cb572b041015355L, 0xc12dc512aedc530cL, 
0xc8db824276c083ceL, 0x86923b0e2903627fL, 0x1385cf2be22827cdL, 0x21b7616ced869ef1L, 0xc74d497d079901e6L, 
0x9e03c843bb13f658L, 0x915b89077a81ec7fL, 0x288a10b00768d244L, 0xd88eb6745a557569L, 0xb3c98071a3d13b20L, 
0x8f23aff44d352f03L, 0x2bf39ca10e45bdbbL, 0xf1bea47e2c68a4cL, 0xf8d5ab01c1ad6b55L, 0x679e0601953d1e31L, 
0xd793f3aacb3c520fL, 0x96fc350ccdb76eabL, 0x9fa0178362df447bL, 0xc11c63febf83598aL, 0x3aa88df3a1a71323L, 
0xab2f8338a09ca82aL, 0x32a2133050a71357L, 0xffecf97ca3ff65e1L, 0xfb6fd13318f5cb79L, 0x3acf76875acad366L, 
0xc577ffff529f74cfL, 0x368a90182031dd12L, 0xafbf2311ad656d52L, 0x80cd4f9f23fcafddL, 0x451717a061972d1fL, 
0xbbcbdae779cfbf3L, 0x133ca541293fd40dL, 0x6f241a21fc40b108L, 0x9adecbcf0c28110bL, 0xfab528d93bac6d3aL, 
0xf4ea3d459b0654aaL, 0x7e2e9ef35a5aafbaL, 0x28730469eded0fc7L, 0x3cbae97a12632fbeL, 0xded6960c0be007a8L, 
0x2a11758a7c52c43eL, 0x289de4875bda262dL, 0x6e13eea58caf3fa7L, 0x20c8ed0d5d673c1L, 0xdb4b3e7719d523b6L, 
0x49143c819d111fc3L, 0xe07479f9ddf45d8eL, 0x68f4654bcc07435bL, 0x513bd537af510064L, 0xcf956c3a3933ba38L, 
0x97e1eaa33f88eeccL, 0x18be860a2504a1c5L, 0x84408412fc0bf397L, 0xb6bdba7e154bdf7L, 0x1d8f8b446b544be6L, 
0x6f06b3dcdef17a03L, 0x30c6e14df59f8cefL, 0x1c97ba9910219cfL, 0x33ddcc087d1aeb5cL, 0xe31b94300cfbcbcfL, 
0xadeb8a98786bb28L, 0x3f69d5b0e3ec8f17L, 0x99f5a15f635296a6L, 0xce9fac7526862e86L, 0x3a88964201bd7524L, 
0xec94d643ea71be51L, 0xc4257084d97ab1c5L, 0xf369b10a73b4d382L, 0xac02bb473dbc5fd1L, 0x4fe73a86d95d7222L, 
0x858806616fe3d553L, 0x10680debcb0693e4L, 0xcaa9aac77c954093L, 0xf29c7530415d71e5L, 0xc32b319e09de9e48L, 
0x1c67107ed497ebc4L, 0x731da71593324021L, 0x49774770588c055aL, 0xf978dfdc28084220L, 0x58b3f2780b5a7ecL, 
0xe4ebf2ca21410715L, 0xd3841ed97708421fL, 0xdbc9401dc51eb4eL, 0xf47a96de499aa2e1L, 0x224da94d8542ba0cL, 
0xa3426a80b4dd0a4aL, 0x857caef48ef7e5b6L, 0x11356ad6ede44bf5L, 0x1a32471bd26acd7aL, 0x199396e31de7b358L, 
0xb7ca7950dbbb4a92L, 0x6ab23720409790a7L, 0x2abfdb93a3159d10L, 0x23913b403946c4a7L, 0xac7c9f339a822344L, 
0x12cffe9625cbe744L, 0x89558b98548b1946L, 0x77be65945c191139L, 0x3ba8d1fc701f4347L, 0xb143664560327f20L, 
0x48baccc3ef2081ffL, 0x450c379d24beb8e9L, 0x1990b609485db827L, 0x6c6a565d7129ccb4L, 0xf9724a82872bd619L, 
0xcfe629aa56717e20L, 0xfde48d87e844ec93L, 0xb32f79e5dc9ce4c1L, 0x7c9d88364238519fL, 0xe943aceba65150f9L, 
0x5301e8550cbdd076L, 0xabb8392364453b3cL, 0xdfb4b4a3cf84aa2dL, 0x269e45f7a6b48a42L, 0xd6783043ab383fcfL, 
0xe4ec475d296a69e5L, 0xe2e273ef65555361L, 0x6bd3084210a75af7L, 0xf2ebc493b909d8c7L, 0x4d20f3d435e9bc94L, 
0xa465e41c3c36d433L, 0xc1b259456f4341c0L, 0x260093703d6cf2ebL, 0xda68d9dea0aa9bdaL, 0x5662a12a210b2a47L, 
0x54675bd1a1b4b467L, 0x9dbd416302ec2468L, 0x3c7130a5032d823aL, 0xabfdef2d9a4fd92fL, 0xd4034e276021451fL, 
0x13834d3d0e43ab73L, 0xdc181442b438b2d6L, 0x1736ffb392c25e23L, 0x289b94003a946252L, 0x99705629b221ca37L, 
0xa7b22a5bb26775d6L, 0x2dc12f9f04435661L, 0xaadd48b556bc9e7cL, 0xf6992e8e94b68a49L, 0xd50420466c9456e3L, 
0xea8305ecdfb1266L, 0xfe0b1d7e4f0ef297L, 0x563de834c4e56a46L, 0xc62b8099b5b264c6L, 0xf6e76aeaf533c784L, 
0xd4680470b790968L, 0x288a50754707431eL, 0x8ad167ed38df547eL, 0x9052fed81a8ca4faL, 0x5975ac56f0548ef1L, 
0x588bf7d0130111aeL, 0x9ec02036a6688a24L, 0x8c9a454af9e09984L, 0x333ee6727bd12dcbL, 0x9847468f925dc38cL, 
0x446ed5203696abacL, 0x71fddf9ef5b5def6L, 0xd4d61614cc333541L, 0xd08a0694cd7f72a7L, 0x686cfe3ea1889281L, 
0xf039404e0dd3333fL, 0x52c620eb18b4246L, 0x4e4de47f86d84713L, 0xfe0450396b209851L, 0x99d6e893b01ed92bL, 
0xd94cf8705f8eba86L, 0x763451110c00291bL, 0xdf4f60b9aa45d064L, 0xf473d4bfd86ad526L, 0x41b9e3fa1a6dba94L, 
0xbaa7cdeb00796a4aL, 0xf668194c40626450L, 0xb894e0ae40a9c87fL, 0x5bc1eea8587d3ddbL, 0xc4c0ecb91bb50d75L, 
0x819fdfd17ff2917bL, 0x681484e54b6b12f7L, 0x2f510aa2f8977995L, 0x7d1582a293b8fa3dL, 0x3dad5a0f0da45470L, 
0x33c113aefb480520L, 0xbd524b2da7ce6c1fL, 0xe4cc051d00d8ddc0L, 0x2995950e206efa90L, 0x8b0e5dca588e3f50L, 
0xaabb3583f7f87082L, 0x75dbbecfa34cb4d6L, 0xf195977068849ae8L, 0x9223ca6fbb72767cL, 0xda7211029d59f04eL, 
0x18d9987c6566405cL, 0x57833aa39ef75a04L, 0xd1750e36481f654bL, 0xce2b66bc8796acbL, 0xc7e79aa76c96b057L, 
0x68f95b6b3c5cdc1dL, 0x2f5725cf5fc583aeL, 0x6b973013fd4484a6L, 0xaaeb2687f2d8bb96L, 0xad29cce061ba3934L, 
0xcb60dd1c437eb1d9L, 0x5cd6f46b78181bb4L, 0x1561cdc95ace24d9L, 0xbb774e6705806245L, 0xdc29c8df29b2e975L, 
0x6ee5ba502839dccdL, 0x670869bb64c60f69L, 0x8ca2931e927ae7L, 0x35cf6c0a27d8de77L, 0x94a3d86209af3920L, 
0x4095a276475df5b7L, 0x1119e4c257ccf7fbL, 0x33376166d9064fe8L, 0xd68c2399f968b905L, 0xb7bf2902f40fc101L, 
0x4ec18604cfd551e0L, 0xeb8e7fe1b6678e99L, 0xdcfe68fc0e042fa6L, 0xd2e58dfb1a8e3866L, 0xf4322bc57fb9a35aL, 
0xe0c665c8cf1fb49bL, 0x60de1f1050684297L, 0xf400c04cb00784cdL, 0xfc2a216f12016984L, 0xa808b477fd65fb4aL, 
0xd9b614adfcb5d0f1L, 0x50afdbc66e3efad2L, 0x82337b3f1764851cL, 0xdc98850eb93ef45eL, 0xe1c314bbc2c6af27L, 
0xd35614ba27e74a71L, 0xa5d592e04a31bb6fL, 0x3f143cd0bc243fbeL, 0x81641ac25408b21L, 0xd4166b32a26fc1c6L, 
0xccd088ee4d4a1f67L, 0x698c913d46c1ec99L, 0xf6b9086a5b986abL, 0x4a73c05ef72e3595L, 0x307aeeb350ab081L, 
0x43e20045bcb06b0eL, 0x3f58d1d6cd3aa0dcL, 0xd71cd7c996faba80L, 0x4431d8268eebfb71L, 0x254246df109e3dd5L, 
0xa7ca1449a238b06aL, 0x49b40e7b082493e7L, 0x45d80e6bd330d613L, 0xaf3d8a578b6d6232L, 0xa4b98341785262d1L, 
0xf4f1f424af963102L, 0xa84a986395146774L, 0x90da037fb61d5c88L, 0xb645534b2cf5b89fL, 0x3fdb3073310934b4L, 
0x1a0307d01f57f514L, 0x509c9b87a4a1e66cL, 0xbf320cf0888d8aa8L, 0x45a51f76c5f76892L, 0x23eb7a2b99a64402L, 
0x4c600e5675dd7757L, 0x4896757aa01a5c34L, 0xb808dbbda7a8a1daL, 0x762c21058ba50349L, 0x99b0a9d5deeebb37L, 
0xd6d98ef70a1e465dL, 0xb052f2c1163894f6L, 0xc55e73526f8bc8faL, 0xb31a0537f5b3b269L, 0xf09c1819c0c7f78aL, 
0xc36d4e2187e430f8L, 0xf141831a47299c7bL, 0x62f938047903ef34L, 0xf2a0dd678f92e0a5L, 0xc7fe6a53efaaa65L, 
0xcc539fcdcc466310L, 0x55199357cdc55491L, 0x6917fb45babb399eL, 0xb098da3c7b012b1aL, 0x54916438f426c41L, 
0x1a5ff3356d77d43bL, 0x74e71995e0aacf1aL, 0x6562a8da6b5e69eeL, 0xacbc2b8d1fb16ea8L, 0x400ea8e1f3f5535eL, 
0x2ea792dad3a4538fL, 0xf580fe481db60b5cL, 0xcb101198dd0aba9fL, 0x259acbe0461cb837L, 0x30033c3964b56a40L, 
0x6c15d4283eeb6fa6L, 0xdea7b626998ea3eeL, 0xdbb2e1b8c0c2abdbL, 0x3a856a6742b6edc2L, 0x777ed6b1683f48bL, 
0xde72fd7d6db3bb63L, 0xc8766969b599dc68L, 0xb39a5b76dce26160L, 0x97464948ce81d8a2L, 0xae20fda5af404ae6L, 
0xde1100c4f1ae3265L, 0x5a94d43bf60f574L, 0xc087a2116f52d0fcL, 0xfacb3be87e615d89L, 0xe184cb9fba7b0feL, 
0x824779bede6d84ffL, 0xa0852e96875da152L, 0x620046e8ba89baefL, 0x247c32c5f34b08ddL, 0x49294468356e7298L, 
0xaf6d6e0f8b5009ebL, 0x8c25bfcdb8abd77fL, 0x4f5464a1bc417e38L, 0x2df8fbe8993f8c9fL, 0x6540566281dd6d91L, 
0xb90690dcfb03a83L, 0xe270b7c7f8fab463L, 0x898ead41792a7f87L, 0xa1b1248822b7c292L, 0xfa2c0d61dd383eabL, 
0x5574c091830bd677L, 0x43640e20702986e5L, 0x622d0a1c860d0302L, 0x9528ea0051990eb9L, 0x28f057ef30af388fL, 
0x88320e974a2721a0L, 0x8a12cb33cdd88b60L, 0xd91a9763f991780dL, 0xdf22e332867c0e97L, 0xad95801b6c801f10L, 
0xb34e21d4afe2c4a0L, 0xd5465bf172494dd3L, 0x16594af34f1b5767L, 0xa675dceaee1591e6L, 0x53db891db5e1d768L, 
0x39a80f5d365c71afL, 0xdce01c73eac54372L, 0x1087fb03e5ce69e9L, 0x67cac3905594378L, 0x275d24c9aa1607f0L, 
0x9163a77a53e361b8L, 0x17d10f8254fa7f0bL, 0x49efeab6642e9e45L, 0x376e24839b1df1beL, 0xc46221cc408546fL, 
0x98eb5bb7001ebf5cL, 0xc6c4d56e3c9a78efL, 0x23c0723e123a899L, 0x145912ec44b57548L, 0x488a34fe824ff4c3L, 
0xac3bc6de9929c707L, 0x1dbac6e98813a70fL, 0xf566054941858266L, 0x18e0a3a2a8b8f2f1L, 0xcc6245a26564a399L, 
0x14416ca0e1a84a9aL, 0x4eaf095631a6e7bfL, 0xf2f89f104c9d0b8dL, 0x8fb278a5953e52d8L, 0x8fcee83a30a8be30L, 
0xb66850da1a0ceb33L, 0x5f37d31bad76f4dcL, 0xff4d956ffea8dea4L, 0x78c583b396635b3L, 0xad268fb5b1105028L, 
0xa480149a0dcbc5f4L, 0xb0e8d69c8b15c864L, 0x6ed49c46f19bb8eaL, 0x7f1871fdf321818dL, 0x1ec5816f5a9843eaL, 
0x77c8da91b5313675L, 0x4cdb66ad515e0717L, 0x2ec4712b0bfdfcd6L, 0x6c6f5767fff27330L, 0x71083b972d80c0cL, 
0x8d8325e82c4fdcdcL, 0xb47a658dad8e13a4L, 0x88710bf005fda027L, 0x69bd3edaf7111200L, 0xdccdd0c65c810ffL, 
};
for (int i = 0; i < refLong.length; ++i) {
Assert.assertEquals(refLong[i], rng.nextLong());
package org.apache.commons.math4.rng.internal.source64;
public class SplitMix64Test {
public void testReferenceCode() {
final long refSeed = 0x1a2b3c4d5e6f7531L;
final SplitMix64 rng = new SplitMix64(refSeed);
final long[] refValues = {
0x4141302768c9e9d0L, 0x64df48c4eab51b1aL, 0x4e723b53dbd901b3L, 0xead8394409dd6454L,
0x3ef60e485b412a0aL, 0xb2a23aee63aecf38L, 0x6cc3b8933c4fa332L, 0x9c9e75e031e6fccbL,
0x0fddffb161c9f30fL, 0x2d1d75d4e75c12a3L, 0xcdcf9d2dde66da2eL, 0x278ba7d1d142cfecL,
0x4ca423e66072e606L, 0x8f2c3c46ebc70bb7L, 0xc9def3b1eeae3e21L, 0x8e06670cd3e98bceL,
0x2326dee7dd34747fL, 0x3c8fff64392bb3c1L, 0xfc6aa1ebe7916578L, 0x3191fb6113694e70L,
0x3453605f6544dac6L, 0x86cf93e5cdf81801L, 0x0d764d7e59f724dfL, 0xae1dfb943ebf8659L,
0x012de1babb3c4104L, 0xa5a818b8fc5aa503L, 0xb124ea2b701f4993L, 0x18e0374933d8c782L,
0x2af8df668d68ad55L, 0x76e56f59daa06243L, 0xf58c016f0f01e30fL, 0x8eeafa41683dbbf4L,
0x7bf121347c06677fL, 0x4fd0c88d25db5ccbL, 0x99af3be9ebe0a272L, 0x94f2b33b74d0bdcbL,
0x24b5d9d7a00a3140L, 0x79d983d781a34a3cL, 0x582e4a84d595f5ecL, 0x7316fe8b0f606d20L,
};
for (int i = 0; i < refValues.length; ++i) {
Assert.assertEquals(refValues[i], rng.nextLong());
package org.apache.commons.math4.rng.internal.source64;
public class TwoCmresTest {
public void testAsymmetric() {
final int index1 = 2;
final int index2 = 5;
final int seed = -123456789;
final TwoCmres rng1 = new TwoCmres(seed, index1, index2);
final TwoCmres rng2 = new TwoCmres(seed, index2, index1);
final int n = 1000;
for (int i = 0; i < n; i++) {
Assert.assertNotEquals("i=" + i, rng1.nextLong(), rng2.nextLong());
public void testSubcycleGeneratorsMustBeDifferent() {
final int max = TwoCmres.numberOfSubcycleGenerators();
for (int i = 0; i < max; i++) {
new TwoCmres(-97845, i, i);
Assert.fail("Exception expected");
} catch (InsufficientDataException e) {
package org.apache.commons.math4.rng.internal.source64;
public class XorShift1024StarTest {
public void testReferenceCode() {
final long[] refSeed = new long[] {
0x012de1babb3c4104L, 0xa5a818b8fc5aa503L, 0xb124ea2b701f4993L, 0x18e0374933d8c782L,
0x2af8df668d68ad55L, 0x76e56f59daa06243L, 0xf58c016f0f01e30fL, 0x8eeafa41683dbbf4L,
0x7bf121347c06677fL, 0x4fd0c88d25db5ccbL, 0x99af3be9ebe0a272L, 0x94f2b33b74d0bdcbL,
0x24b5d9d7a00a3140L, 0x79d983d781a34a3cL, 0x582e4a84d595f5ecL, 0x7316fe8b0f606d20L,
};
final XorShift1024Star rng = new XorShift1024Star(refSeed);
final long[] refValues = {
0xd85e9fc0855614cdL, 0xaf4965c9c1ac6a3dL, 0x067da398791111d8L, 0x2771c41db58d7644L,
0xf71a471e1ac2b03eL, 0x953449ae275f7409L, 0x8aa570c72de0af5eL, 0xae59db2acdae32beL,
0x3d46f316b8f97301L, 0x72dc8399b7a70957L, 0xf5624d788b3b6f4eL, 0xb7a79275f6c0e7b1L,
0xf79354208377d498L, 0x0e5d2f2ac2b4f28fL, 0x0f8f57edc8aa802fL, 0x5e918ea72ece0c36L,
0xeeb8dbdb00ac7a5aL, 0xf16f88dfef0d6047L, 0x1244c29e0e0d8d2dL, 0xaa94f1cc42691eb7L,
0xd06425dd329e5de5L, 0x968b1c2e016f159cL, 0x6aadff7055065295L, 0x3bce2efcb0d00876L,
0xb28d5b69ad8fb719L, 0x1e4040c451376920L, 0x6b0801a8a00de7d7L, 0x891ba2cbe2a4675bL,
0x6355008481852527L, 0x7a47bcd9960126f3L, 0x07f72fcd4ebe3580L, 0x4658b29c126840ccL,
0xdc7b36d3037c7539L, 0x9e30aab0410122e8L, 0x7215126e0fce932aL, 0xda63f12a489fc8deL,
0x769997671b2a0158L, 0xfa9cd84e0ffc174dL, 0x34df1cd959dca211L, 0xccea41a33ec1f763L,
};
for (int i = 0; i < refValues.length; ++i) {
Assert.assertEquals(refValues[i], rng.nextLong());
package org.apache.commons.math4.rng.internal.util;
public class NumberFactoryTest {
final int INT_SIZE = 4;
final int LONG_SIZE = 8;
private static final long[] LONG_TEST_VALUES = new long[] {
0L,
1L,
-1L,
19337L,
1234567891011213L,
-11109876543211L,
Long.valueOf(Integer.MAX_VALUE),
Long.valueOf(Integer.MIN_VALUE),
Long.MAX_VALUE,
Long.MIN_VALUE,
};
private static final int[] INT_TEST_VALUES = new int[] {
0,
1,
-1,
19337,
1234567891,
-1110987656,
Integer.MAX_VALUE,
Integer.MIN_VALUE,
};
public void testMakeIntFromLong() {
for (long v : LONG_TEST_VALUES) {
final int vL = NumberFactory.extractLo(v);
final int vH = NumberFactory.extractHi(v);
final long actual = (((long) vH) << 32) | (vL & 0xffffffffL);
Assert.assertEquals(v, actual);
public void testLong2Long() {
for (long v : LONG_TEST_VALUES) {
final int vL = NumberFactory.extractLo(v);
final int vH = NumberFactory.extractHi(v);
Assert.assertEquals(v, NumberFactory.makeLong(vH, vL));
public void testLongFromByteArray2Long() {
for (long expected : LONG_TEST_VALUES) {
final byte[] b = NumberFactory.makeByteArray(expected);
Assert.assertEquals(expected, NumberFactory.makeLong(b));
public void testLongArrayFromByteArray2LongArray() {
final byte[] b = NumberFactory.makeByteArray(LONG_TEST_VALUES);
Assert.assertArrayEquals(LONG_TEST_VALUES,
NumberFactory.makeLongArray(b));
public void testIntFromByteArray2Int() {
for (int expected : INT_TEST_VALUES) {
final byte[] b = NumberFactory.makeByteArray(expected);
Assert.assertEquals(expected, NumberFactory.makeInt(b));
public void testIntArrayFromByteArray2IntArray() {
final byte[] b = NumberFactory.makeByteArray(INT_TEST_VALUES);
Assert.assertArrayEquals(INT_TEST_VALUES,
NumberFactory.makeIntArray(b));
public void testMakeIntPrecondition1() {
for (int i = 0; i <= 10; i++) {
NumberFactory.makeInt(new byte[i]);
if (i != INT_SIZE) {
Assert.fail("Exception expected");
} catch (DimensionMismatchException e) {
public void testMakeIntArrayPrecondition1() {
for (int i = 0; i <= 20; i++) {
NumberFactory.makeIntArray(new byte[i]);
if (i != 0 && (i % INT_SIZE != 0)) {
Assert.fail("Exception expected");
} catch (DimensionMismatchException e) {
public void testMakeLongPrecondition1() {
for (int i = 0; i <= 10; i++) {
NumberFactory.makeLong(new byte[i]);
if (i != LONG_SIZE) {
Assert.fail("Exception expected");
} catch (DimensionMismatchException e) {
public void testMakeLongArrayPrecondition1() {
for (int i = 0; i <= 20; i++) {
NumberFactory.makeLongArray(new byte[i]);
if (i != 0 && (i % LONG_SIZE != 0)) {
Assert.fail("Exception expected");
} catch (DimensionMismatchException e) {
package org.apache.commons.math4.rng.internal.util;
public class SeedFactoryTest {
public void testCreateLong() {
final Map<Long, Integer> values = new HashMap<>();
final int n = 100000;
for (int i = 0; i < n; i++) {
final long v = SeedFactory.createLong();
Integer count = values.get(v);
if (count == null) {
count = 0;
values.put(v, count + 1);
assertDifferentValues(values);
public void testCreateLongArray() {
final Map<Long, Integer> values = new HashMap<>();
final int n = 100000;
final long[] array = SeedFactory.createLongArray(n);
Assert.assertEquals(n, array.length);
for (long v : array) {
Integer count = values.get(v);
if (count == null) {
count = 0;
values.put(v, count + 1);
assertDifferentValues(values);
public void testCreateIntArray() {
final Map<Long, Integer> values = new HashMap<>();
for (int i = 0; i < 50000; i++) {
final int[] a = SeedFactory.createIntArray(2);
final long v = NumberFactory.makeLong(a[0], a[1]); 
Integer count = values.get(v);
if (count == null) {
count = 0;
values.put(v, count + 1);
assertDifferentValues(values);
private static <T> void assertDifferentValues(Map<T, Integer> map) {
final StringBuilder sb = new StringBuilder();
int duplicates = 0;
for (Map.Entry<T, Integer> entry : map.entrySet()) {
final int count = entry.getValue();
if (count <= 0) {
throw new IllegalStateException();
if (count > 1) {
duplicates += count - 1;
sb.append(entry.getKey() + ": " + count + "\n");
if (duplicates > 0) {
Assert.fail(duplicates + " duplicates\n" + sb);
final IntegerDistribution.Sampler size =
new UniformIntegerDistribution(10, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
327652));
final RealDistribution.Sampler randomData
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));;
final double[] out = AbstractRealDistribution.sample(sampleSize, randomData);
final IntegerDistribution.Sampler sampler =
new UniformIntegerDistribution(cur, length - 1).createSampler(RandomSource.create(RandomSource.WELL_512_A));
next = sampler.sample();
final IntegerDistribution.Sampler weightDist =
new UniformIntegerDistribution(1, 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,
234878544L));
final RealDistribution.Sampler valueDist =
new NormalDistribution(mu, sigma).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
final RealDistribution.Sampler sampler =
distribution.createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1000));
data = AbstractRealDistribution.sample(VERY_LARGE, sampler);
data = AbstractRealDistribution.sample(LARGE, sampler);
data = AbstractRealDistribution.sample(VERY_BIG, sampler);
data = AbstractRealDistribution.sample(BIG, sampler);
data = AbstractRealDistribution.sample(STANDARD, sampler);
data = AbstractRealDistribution.sample(MEDIUM, sampler);
data = AbstractRealDistribution.sample(NOMINAL, sampler);
data = AbstractRealDistribution.sample(SMALL, sampler);
data = AbstractRealDistribution.sample(TINY, sampler);
doDistributionTest(new NormalDistribution(4000, 50));
doDistributionTest(new LogNormalDistribution(4000, 50));
final RealDistribution.Sampler sampler =
new NormalDistribution(4000, 50).createSampler(RandomSource.create(RandomSource.JDK,
Long.MAX_VALUE));
for (final int sampleSize : sampleSizes) {
final double[] data = AbstractRealDistribution.sample(sampleSize, sampler);
for (final double p : new double[] { 50d, 95d }) {
final double storedDataResult = pStoredData.evaluate();
Assert.assertEquals("Sample=" + sampleSize + ", P=" + p + " e=" + e,
storedDataResult,
pDirect.evaluate(data), 0d);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
public void testFillBooleanArrayRandomlyWithFixedNumberTrueValues() throws Exception {
Method method = KolmogorovSmirnovTest.class.getDeclaredMethod("fillBooleanArrayRandomlyWithFixedNumberTrueValues",
boolean[].class, Integer.TYPE, UniformRandomProvider.class);
method.setAccessible(true);
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 0);
method.invoke(KolmogorovSmirnovTest.class, b, numberOfTrueValues, rng);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 2000);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest(RandomSource.WELL_19937_C, 1000);
Assert.assertArrayEquals(fixedY, yP, 0);
double[].class, double[].class);
double[].class, double[].class);
MathArrays.shuffle(list, start, MathArrays.Position.TAIL,
RandomSource.create(RandomSource.WELL_19937_C, 7654321L));
MathArrays.shuffle(list, start, MathArrays.Position.HEAD,
RandomSource.create(RandomSource.WELL_19937_C, 1234567L));
final RealDistribution.Sampler u
= new UniformRealDistribution(i + 0.5, i + 0.75).createSampler(RandomSource.create(RandomSource.WELL_512_A,
64925784252L));
final IntegerDistribution.Sampler randomData =
new UniformIntegerDistribution(100, 1000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));
final IntegerDistribution.Sampler randomData =
new UniformIntegerDistribution(100, 3000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));
package org.apache.commons.math4.userguide.rng;
public class GeneratorsList implements Iterable<UniformRandomProvider> {
private final List<UniformRandomProvider> list = new ArrayList<>();
public GeneratorsList() {
list.add(RandomSource.create(RandomSource.JDK));
list.add(RandomSource.create(RandomSource.MT));
list.add(RandomSource.create(RandomSource.WELL_512_A));
list.add(RandomSource.create(RandomSource.WELL_1024_A));
list.add(RandomSource.create(RandomSource.WELL_19937_A));
list.add(RandomSource.create(RandomSource.WELL_19937_C));
list.add(RandomSource.create(RandomSource.WELL_44497_A));
list.add(RandomSource.create(RandomSource.WELL_44497_B));
list.add(RandomSource.create(RandomSource.ISAAC));
list.add(RandomSource.create(RandomSource.MT_64));
list.add(RandomSource.create(RandomSource.SPLIT_MIX_64));
list.add(RandomSource.create(RandomSource.XOR_SHIFT_1024_S));
list.add(RandomSource.create(RandomSource.TWO_CMRES));
public Iterator<UniformRandomProvider> iterator() {
return list.iterator();
package org.apache.commons.math4.userguide.rng;
public class RandomStressTester {
private static final String C = "# ";
private static final String N = "\n";
private final List<String> cmdLine;
private final String fileOutputPrefix;
private RandomStressTester(List<String> cmd,
String outputPrefix) {
final File exec = new File(cmd.get(0));
if (!exec.exists() ||
!exec.canExecute()) {
throw new RuntimeException("Program is not executable: " + exec);
cmdLine = new ArrayList<String>(cmd);
fileOutputPrefix = outputPrefix;
final File reportDir = new File(fileOutputPrefix).getParentFile();
if (!reportDir.exists() ||
!reportDir.isDirectory() ||
!reportDir.canWrite()) {
throw new RuntimeException("Invalid output directory: " + reportDir);
public static void main(String[] args) throws Exception {
final String output = args[0];
final int numThreads = Integer.valueOf(args[1]);
final Iterable<UniformRandomProvider> rngList = createGeneratorsList(args[2]);
final List<String> cmdLine = new ArrayList<>();
cmdLine.addAll(Arrays.asList(Arrays.copyOfRange(args, 3, args.length)));
final RandomStressTester app = new RandomStressTester(cmdLine, output);
app.run(rngList, numThreads);
private void run(Iterable<UniformRandomProvider> generators,
int numConcurrentTasks)
throws IOException {
final ExecutorService service = Executors.newFixedThreadPool(numConcurrentTasks);
final List<Future<?>> execOutput = new ArrayList<Future<?>>();
int count = 0;
for (UniformRandomProvider rng : generators) {
final File output = new File(fileOutputPrefix + (++count));
final Runnable r = new Task(rng, output);
execOutput.add(service.submit(r));
for (Future<?> f : execOutput) {
f.get();
} catch (ExecutionException e) {
System.err.println(e.getCause().getMessage());
} catch (InterruptedException ignored) {}
service.shutdown();
private static Iterable<UniformRandomProvider> createGeneratorsList(String name)
throws ClassNotFoundException,
InstantiationException,
IllegalAccessException {
return (Iterable<UniformRandomProvider>) Class.forName(name).newInstance();
private class Task implements Runnable {
private final File output;
private final UniformRandomProvider rng;
public Task(UniformRandomProvider random,
File report) {
rng = random;
output = report;
public void run() {
printHeader(output, rng);
final ProcessBuilder builder = new ProcessBuilder(cmdLine);
builder.redirectOutput(ProcessBuilder.Redirect.appendTo(output));
final Process testingProcess = builder.start();
final DataOutputStream sink = new DataOutputStream(testingProcess.getOutputStream());
final long startTime = System.nanoTime();
while (true) {
sink.writeInt(rng.nextInt());
} catch (IOException e) {
final long endTime = System.nanoTime();
printFooter(output, endTime - startTime);
} catch (IOException e) {
throw new RuntimeException("Failed to start task: " + e.getMessage());
private void printHeader(File output,
UniformRandomProvider rng)
throws IOException {
final StringBuilder sb = new StringBuilder();
sb.append(C).append(N);
sb.append(C).append("RNG: ").append(rng.toString()).append(N);
sb.append(C).append(N);
sb.append(C).append("Java: ").append(System.getProperty("java.version")).append(N);
sb.append(C).append("Runtime: ").append(System.getProperty("java.runtime.version", "?")).append(N);
sb.append(C).append("JVM: ").append(System.getProperty("java.vm.name"))
.append(" ").append(System.getProperty("java.vm.version")).append(N);
sb.append(C).append("OS: ").append(System.getProperty("os.name"))
.append(" ").append(System.getProperty("os.version"))
.append(" ").append(System.getProperty("os.arch")).append(N);
sb.append(C).append(N);
sb.append(C).append("Analyzer: ");
for (String s : cmdLine) {
sb.append(s).append(" ");
sb.append(N);
sb.append(C).append(N);
final PrintWriter w = new PrintWriter(new FileWriter(output, true));
w.print(sb.toString());
w.close();
private void printFooter(File output,
long nanoTime)
throws IOException {
final PrintWriter w = new PrintWriter(new FileWriter(output, true));
w.println(C);
final double duration = ((double) nanoTime) * 1e-9 / 60;
w.println(C + "Test duration: " + duration + " minutes");
w.println(C);
w.close();if (getIterations() > 0) {double x = 0x1.fffffffffffffp-2;
assertTrue(x == Math.round(x));final double[] values = MathArrays.unique(MathArrays.concatenate(x,y));
if (values.length == x.length + y.length) {
return;  // There are no ties
double minDelta = 1;
double prev = values[0];
double delta = 1;
for (int i = 1; i < values.length; i++) {
delta = prev - values[i];
if (delta < minDelta) {
minDelta = delta;
prev = values[i];
minDelta /= 2;
final UniformRandomProvider rng = RandomSource.create(RandomSource.TWO_CMRES, 654321);
int ct = 0;
boolean ties = true;
do {
jitter(x, rng, minDelta);
jitter(y, rng, minDelta);
ties = hasTies(x, y);
ct++;
minDelta *= 2;
} while (ties && ct < 1000);
if (ties) {
throw new MathInternalError(); // Should never happen.
final HashSet<Double> values = new HashSet<>();
for (int i = 0; i < x.length; i++) {
if (!values.add(x[i])) {
return true;
for (int i = 0; i < y.length; i++) {
if (!values.add(y[i])) {
return true;
return false;
private static void jitter(final double[] data, final UniformRandomProvider rng, final double delta) {
final double d = delta * (2 * rng.nextDouble() - 1);
data[i] += d;
0.000000, 0.000000, 1.000000,
1.000000, 1.500000, 1.600000,
1.700000, 1.800000, 1.900000, 2.000000, 2.000000000000001
0.000000, 0.000000, 10.000000,
10.000000, 11.000000, 11.000000,
11.000000, 15.000000, 16.000000,
17.000000, 18.000000, 19.000000, 20.000000, 20.000000000000001
Assert.assertEquals(1.12173015e-5, test.kolmogorovSmirnovTest(x, y), 1e-6);centered[i] = values[i] - getMeans()[i];
public interface Vector<S extends Space> {
Space getSpace();
boolean isNaN();
double distance(Vector<S> v);
public class Cartesian1D implements Point<Euclidean1D>, Vector<Euclidean1D> {
public static final Cartesian1D ZERO = new Cartesian1D(0.0);
public static final Cartesian1D ONE  = new Cartesian1D(1.0);
public static final Cartesian1D NaN = new Cartesian1D(Double.NaN);
public static final Cartesian1D POSITIVE_INFINITY =
new Cartesian1D(Double.POSITIVE_INFINITY);
public static final Cartesian1D NEGATIVE_INFINITY =
new Cartesian1D(Double.NEGATIVE_INFINITY);
public Cartesian1D(double x) {
public Cartesian1D(double a, Cartesian1D u) {
public Cartesian1D(double a1, Cartesian1D u1, double a2, Cartesian1D u2) {
public Cartesian1D(double a1, Cartesian1D u1, double a2, Cartesian1D u2,
double a3, Cartesian1D u3) {
public Cartesian1D(double a1, Cartesian1D u1, double a2, Cartesian1D u2,
double a3, Cartesian1D u3, double a4, Cartesian1D u4) {
public Cartesian1D getZero() {
public Cartesian1D add(Vector<Euclidean1D> v) {
Cartesian1D v1 = (Cartesian1D) v;
return new Cartesian1D(x + v1.getX());
public Cartesian1D add(double factor, Vector<Euclidean1D> v) {
Cartesian1D v1 = (Cartesian1D) v;
return new Cartesian1D(x + factor * v1.getX());
public Cartesian1D subtract(Vector<Euclidean1D> p) {
Cartesian1D p3 = (Cartesian1D) p;
return new Cartesian1D(x - p3.x);
public Cartesian1D subtract(double factor, Vector<Euclidean1D> v) {
Cartesian1D v1 = (Cartesian1D) v;
return new Cartesian1D(x - factor * v1.getX());
public Cartesian1D normalize() throws MathArithmeticException {
public Cartesian1D negate() {
return new Cartesian1D(-x);
public Cartesian1D scalarMultiply(double a) {
return new Cartesian1D(a * x);
Cartesian1D p1 = (Cartesian1D) p;
final double dx = FastMath.abs(p1.x - x);
return distance((Cartesian1D) p);
public double distance(Vector<Euclidean1D> v) {
return distance((Cartesian1D) v);
public double distance(Cartesian1D c) {
final double dx = c.x - x;
Cartesian1D p1 = (Cartesian1D) p;
final double dx = FastMath.abs(p1.x - x);
Cartesian1D p1 = (Cartesian1D) p;
final double dx = p1.x - x;
final Cartesian1D v1 = (Cartesian1D) v;
public static double distance(Cartesian1D p1, Cartesian1D p2) {
public static double distanceInf(Cartesian1D p1, Cartesian1D p2) {
public static double distanceSq(Cartesian1D p1, Cartesian1D p2) {
if (other instanceof Cartesian1D) {
final Cartesian1D rhs = (Cartesian1D)other;
new OrientedPoint(new Cartesian1D(upper), true, tolerance).wholeHyperplane();
new OrientedPoint(new Cartesian1D(lower), false, tolerance).wholeHyperplane();
new OrientedPoint(new Cartesian1D(upper), true, tolerance).wholeHyperplane();
setBarycenter((Point<Euclidean1D>) Cartesian1D.NaN);
setBarycenter((Point<Euclidean1D>) Cartesian1D.NaN);
setBarycenter((Point<Euclidean1D>) new Cartesian1D(sum / size));
final double x = ((Cartesian1D) point).getX();
private Cartesian1D finiteOrNullPoint(final double x) {
return Double.isInfinite(x) ? null : new Cartesian1D(x);
private final Cartesian1D location;
public OrientedPoint(final Cartesian1D location, final boolean direct, final double tolerance) {
final double delta = ((Cartesian1D) point).getX() - location.getX();
public Cartesian1D getLocation() {
final Cartesian1D p1 = (Cartesian1D) vector;
public Cartesian1D parse(final String source) throws MathParseException {
Cartesian1D result = parse(source, parsePosition);
Cartesian1D.class);
public Cartesian1D parse(final String source, final ParsePosition pos) {
return new Cartesian1D(coordinates[0]);
public class Cartesian3D implements Serializable, Point<Euclidean3D>, Vector<Euclidean3D> {
public static final Cartesian3D ZERO   = new Cartesian3D(0, 0, 0);
public static final Cartesian3D PLUS_I = new Cartesian3D(1, 0, 0);
public static final Cartesian3D MINUS_I = new Cartesian3D(-1, 0, 0);
public static final Cartesian3D PLUS_J = new Cartesian3D(0, 1, 0);
public static final Cartesian3D MINUS_J = new Cartesian3D(0, -1, 0);
public static final Cartesian3D PLUS_K = new Cartesian3D(0, 0, 1);
public static final Cartesian3D MINUS_K = new Cartesian3D(0, 0, -1);
public static final Cartesian3D NaN = new Cartesian3D(Double.NaN, Double.NaN, Double.NaN);
public static final Cartesian3D POSITIVE_INFINITY =
new Cartesian3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
public static final Cartesian3D NEGATIVE_INFINITY =
new Cartesian3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
public Cartesian3D(double x, double y, double z) {
public Cartesian3D(double[] v) throws DimensionMismatchException {
public Cartesian3D(double alpha, double delta) {
public Cartesian3D(double a, Cartesian3D u) {
public Cartesian3D(double a1, Cartesian3D u1, double a2, Cartesian3D u2) {
public Cartesian3D(double a1, Cartesian3D u1, double a2, Cartesian3D u2,
double a3, Cartesian3D u3) {
public Cartesian3D(double a1, Cartesian3D u1, double a2, Cartesian3D u2,
double a3, Cartesian3D u3, double a4, Cartesian3D u4) {
public Cartesian3D getZero() {
public Cartesian3D add(final Vector<Euclidean3D> v) {
final Cartesian3D v3 = (Cartesian3D) v;
return new Cartesian3D(x + v3.x, y + v3.y, z + v3.z);
public Cartesian3D add(double factor, final Vector<Euclidean3D> v) {
return new Cartesian3D(1, this, factor, (Cartesian3D) v);
public Cartesian3D subtract(final Vector<Euclidean3D> v) {
final Cartesian3D v3 = (Cartesian3D) v;
return new Cartesian3D(x - v3.x, y - v3.y, z - v3.z);
public Cartesian3D subtract(final double factor, final Vector<Euclidean3D> v) {
return new Cartesian3D(1, this, -factor, (Cartesian3D) v);
public Cartesian3D normalize() throws MathArithmeticException {
public Cartesian3D orthogonal() throws MathArithmeticException {
return new Cartesian3D(0, inverse * z, -inverse * y);
return new Cartesian3D(-inverse * z, 0, inverse * x);
return new Cartesian3D(inverse * y, -inverse * x, 0);
public static double angle(Cartesian3D v1, Cartesian3D v2) throws MathArithmeticException {
Cartesian3D v3 = crossProduct(v1, v2);
public Cartesian3D negate() {
return new Cartesian3D(-x, -y, -z);
public Cartesian3D scalarMultiply(double a) {
return new Cartesian3D(a * x, a * y, a * z);
if (other instanceof Cartesian3D) {
final Cartesian3D rhs = (Cartesian3D)other;
final Cartesian3D v3 = (Cartesian3D) v;
public Cartesian3D crossProduct(final Vector<Euclidean3D> v) {
final Cartesian3D v3 = (Cartesian3D) v;
return new Cartesian3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),
final Cartesian3D v3 = (Cartesian3D) v;
public double distance(Point<Euclidean3D> p) {
return distance((Cartesian3D) p);
public double distance(Vector<Euclidean3D> v) {
return distance((Cartesian3D) v);
public double distance(Cartesian3D c) {
final double dx = c.x - x;
final double dy = c.y - y;
final double dz = c.z - z;
final Cartesian3D v3 = (Cartesian3D) v;
final Cartesian3D v3 = (Cartesian3D) v;
public static double dotProduct(Cartesian3D v1, Cartesian3D v2) {
public static Cartesian3D crossProduct(final Cartesian3D v1, final Cartesian3D v2) {
public static double distance1(Cartesian3D v1, Cartesian3D v2) {
public static double distance(Cartesian3D v1, Cartesian3D v2) {
public static double distanceInf(Cartesian3D v1, Cartesian3D v2) {
public static double distanceSq(Cartesian3D v1, Cartesian3D v2) {
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_I);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_J);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v1 = applyTo(Cartesian3D.PLUS_K);
FieldVector3D<T> v2 = applyInverseTo(Cartesian3D.PLUS_K);
public FieldVector3D<T> applyTo(final Cartesian3D u) {
public FieldVector3D<T> applyInverseTo(final Cartesian3D u) {
public FieldVector3D(final T a, final Cartesian3D u) {
public FieldVector3D(final T a1, final Cartesian3D u1,
final T a2, final Cartesian3D u2) {
public FieldVector3D(final T a1, final Cartesian3D u1,
final T a2, final Cartesian3D u2,
final T a3, final Cartesian3D u3) {
public FieldVector3D(final T a1, final Cartesian3D u1,
final T a2, final Cartesian3D u2,
final T a3, final Cartesian3D u3,
final T a4, final Cartesian3D u4) {
public Cartesian3D toVector3D() {
return new Cartesian3D(x.getReal(), y.getReal(), z.getReal());
public FieldVector3D<T> add(final Cartesian3D v) {
public FieldVector3D<T> add(final T factor, final Cartesian3D v) {
public FieldVector3D<T> add(final double factor, final Cartesian3D v) {
public FieldVector3D<T> subtract(final Cartesian3D v) {
public FieldVector3D<T> subtract(final T factor, final Cartesian3D v) {
public FieldVector3D<T> subtract(final double factor, final Cartesian3D v) {
public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Cartesian3D v2)
public static <T extends RealFieldElement<T>> T angle(final Cartesian3D v1, final FieldVector3D<T> v2)
public T dotProduct(final Cartesian3D v) {
public FieldVector3D<T> crossProduct(final Cartesian3D v) {
public T distance1(final Cartesian3D v) {
public T distance(final Cartesian3D v) {
public T distanceInf(final Cartesian3D v) {
public T distanceSq(final Cartesian3D v) {
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> T dotProduct(final Cartesian3D v1,
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Cartesian3D v1,
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> T distance1(final Cartesian3D v1,
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> T distance(final Cartesian3D v1,
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> T distanceInf(final Cartesian3D v1,
final Cartesian3D v2) {
public static <T extends RealFieldElement<T>> T distanceSq(final Cartesian3D v1,
private Cartesian3D direction;
private Cartesian3D zero;
public Line(final Cartesian3D p1, final Cartesian3D p2, final double tolerance)
public void reset(final Cartesian3D p1, final Cartesian3D p2) throws MathIllegalArgumentException {
final Cartesian3D delta = p2.subtract(p1);
this.direction = new Cartesian3D(1.0 / FastMath.sqrt(norm2), delta);
zero = new Cartesian3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);
public Cartesian3D getDirection() {
public Cartesian3D getOrigin() {
public double getAbscissa(final Cartesian3D point) {
public Cartesian3D pointAt(final double abscissa) {
return new Cartesian3D(1.0, zero, abscissa, direction);
public Cartesian1D toSubSpace(Vector<Euclidean3D> vector) {
public Cartesian3D toSpace(Vector<Euclidean1D> vector) {
public Cartesian1D toSubSpace(final Point<Euclidean3D> point) {
return toSubSpace((Cartesian3D) point);
public Cartesian3D toSpace(final Point<Euclidean1D> point) {
return toSpace((Cartesian1D) point);
public Cartesian1D toSubSpace(final Cartesian3D point) {
return new Cartesian1D(getAbscissa(point));
public Cartesian3D toSpace(final Cartesian1D point) {
return pointAt(point.getX());
final double angle = Cartesian3D.angle(direction, line.direction);
public boolean contains(final Cartesian3D p) {
public double distance(final Cartesian3D p) {
final Cartesian3D d = p.subtract(zero);
final Cartesian3D n = new Cartesian3D(1.0, d, -d.dotProduct(direction), direction);
final Cartesian3D normal = Cartesian3D.crossProduct(direction, line.direction);
public Cartesian3D closestPoint(final Line line) {
final Cartesian3D delta0 = line.zero.subtract(zero);
return new Cartesian3D(1, zero, (a - b * cos) / n, direction);
public Cartesian3D intersection(final Line line) {
final Cartesian3D closest = closestPoint(line);
private final Cartesian3D u;
private final Cartesian3D v;
private final Cartesian3D w;
public OutlineExtractor(final Cartesian3D u, final Cartesian3D v) {
w = Cartesian3D.crossProduct(u, v);
public Cartesian2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {
final Cartesian2D[][] outline = projected.getVertices();
final Cartesian2D[] rawLoop = outline[i];
outline[i] = new Cartesian2D[end];
private boolean pointIsBetween(final Cartesian2D[] loop, final int n, final int i) {
final Cartesian2D previous = loop[(i + n - 1) % n];
final Cartesian2D current  = loop[i];
final Cartesian2D next     = loop[(i + 1) % n];
Cartesian2D[][] vertices =
final Cartesian2D[][] newVertices = new Cartesian2D[vertices.length][];
final Cartesian2D[] loop = vertices[i];
final Cartesian2D[] newLoop = new Cartesian2D[loop.length];
for (Cartesian2D[] loop : vertices) {
Cartesian3D previous3D  = plane.toSpace(loop[previous]);
Cartesian2D pPoint       = new Cartesian2D(previous3D.dotProduct(u),
final Cartesian3D current3D = plane.toSpace((Point<Euclidean2D>) loop[current]);
final Cartesian2D  cPoint    = new Cartesian2D(current3D.dotProduct(u),
private Cartesian3D origin;
private Cartesian3D u;
private Cartesian3D v;
private Cartesian3D w;
public Plane(final Cartesian3D normal, final double tolerance)
public Plane(final Cartesian3D p, final Cartesian3D normal, final double tolerance)
public Plane(final Cartesian3D p1, final Cartesian3D p2, final Cartesian3D p3, final double tolerance)
public void reset(final Cartesian3D p, final Cartesian3D normal) throws MathArithmeticException {
private void setNormal(final Cartesian3D normal) throws MathArithmeticException {
w = new Cartesian3D(1.0 / norm, normal);
origin = new Cartesian3D(-originOffset, w);
v = Cartesian3D.crossProduct(w, u);
public Cartesian3D getOrigin() {
public Cartesian3D getNormal() {
public Cartesian3D getU() {
public Cartesian3D getV() {
final Cartesian3D tmp = u;
public Cartesian2D toSubSpace(Vector<Euclidean3D> vector) {
return toSubSpace((Cartesian3D) vector);
public Cartesian3D toSpace(Vector<Euclidean2D> vector) {
return toSpace((Cartesian2D) vector);
public Cartesian2D toSubSpace(final Point<Euclidean3D> point) {
return toSubSpace((Cartesian3D) point);
public Cartesian3D toSpace(final Point<Euclidean2D> point) {
return toSpace((Cartesian2D) point);
public Cartesian2D toSubSpace(final Cartesian3D point) {
return new Cartesian2D(point.dotProduct(u), point.dotProduct(v));
public Cartesian3D toSpace(final Cartesian2D point) {
return new Cartesian3D(point.getX(), u, point.getY(), v, -originOffset, w);
public Cartesian3D getPointAt(final Cartesian2D inPlane, final double offset) {
return new Cartesian3D(inPlane.getX(), u, inPlane.getY(), v, offset - originOffset, w);
final double angle = Cartesian3D.angle(w, plane.w);
public Plane rotate(final Cartesian3D center, final Rotation rotation) {
final Cartesian3D delta = origin.subtract(center);
public Plane translate(final Cartesian3D translation) {
public Cartesian3D intersection(final Line line) {
final Cartesian3D direction = line.getDirection();
final Cartesian3D point = line.toSpace(Cartesian1D.ZERO);
return new Cartesian3D(1.0, point, k, direction);
final Cartesian3D direction = Cartesian3D.crossProduct(w, other.w);
final Cartesian3D point = intersection(this, other, new Plane(direction, tolerance));
public static Cartesian3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {
return new Cartesian3D(
public boolean contains(final Cartesian3D p) {
return ((Cartesian3D) point).dotProduct(w) + originOffset;
public PolyhedronsSet(final List<Cartesian3D> vertices, final List<int[]> facets,
final Plane pxMin = new Plane(new Cartesian3D(xMin, 0,    0),   Cartesian3D.MINUS_I, tolerance);
final Plane pxMax = new Plane(new Cartesian3D(xMax, 0,    0),   Cartesian3D.PLUS_I,  tolerance);
final Plane pyMin = new Plane(new Cartesian3D(0,    yMin, 0),   Cartesian3D.MINUS_J, tolerance);
final Plane pyMax = new Plane(new Cartesian3D(0,    yMax, 0),   Cartesian3D.PLUS_J,  tolerance);
final Plane pzMin = new Plane(new Cartesian3D(0,    0,   zMin), Cartesian3D.MINUS_K, tolerance);
final Plane pzMax = new Plane(new Cartesian3D(0,    0,   zMax), Cartesian3D.PLUS_K,  tolerance);
private static List<SubHyperplane<Euclidean3D>> buildBoundary(final List<Cartesian3D> vertices,
final Cartesian3D vi = vertices.get(i);
if (Cartesian3D.distance(vi, vertices.get(j)) <= tolerance) {
final Cartesian3D start = vertices.get(vA);
final Cartesian3D end   = vertices.get(vB);
final Cartesian2D[] two2Points = new Cartesian2D[facet.length];
final Cartesian3D v = vertices.get(facet[i]);
private static int[][] findReferences(final List<Cartesian3D> vertices, final List<int[]> facets) {
private static int[][] successors(final List<Cartesian3D> vertices, final List<int[]> facets,
final Cartesian3D start = vertices.get(v);
final Cartesian3D end   = vertices.get(successors[v][k]);
setBarycenter((Point<Euclidean3D>) Cartesian3D.NaN);
setBarycenter((Point<Euclidean3D>) new Cartesian3D(1.0 / (4 * getSize()), (Cartesian3D) getBarycenter()));
setBarycenter((Point<Euclidean3D>) new Cartesian3D(0, 0, 0));
setBarycenter((Point<Euclidean3D>) Cartesian3D.NaN);
final Cartesian3D facetB = plane.toSpace(polygon.getBarycenter());
setBarycenter((Point<Euclidean3D>) new Cartesian3D(1.0, (Cartesian3D) getBarycenter(), scaled, facetB));
public SubHyperplane<Euclidean3D> firstIntersection(final Cartesian3D point, final Line line) {
final Cartesian3D point,
final Cartesian3D hit3D = plane.intersection(line);
private SubHyperplane<Euclidean3D> boundaryFacet(final Cartesian3D point,
final Cartesian2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace(point);
public PolyhedronsSet rotate(final Cartesian3D center, final Rotation rotation) {
private final Cartesian3D   center;
RotationTransform(final Cartesian3D center, final Rotation rotation) {
public Cartesian3D apply(final Point<Euclidean3D> point) {
final Cartesian3D delta = ((Cartesian3D) point).subtract(center);
return new Cartesian3D(1.0, center, 1.0, rotation.applyTo(delta));
final Cartesian3D p00    = oPlane.getOrigin();
final Cartesian3D p10    = oPlane.toSpace(new Cartesian2D(1.0, 0.0));
final Cartesian3D p01    = oPlane.toSpace(new Cartesian2D(0.0, 1.0));
final Cartesian2D tP00   = tPlane.toSubSpace(apply(p00));
final Cartesian2D tP10   = tPlane.toSubSpace(apply(p10));
final Cartesian2D tP01   = tPlane.toSubSpace(apply(p01));
public PolyhedronsSet translate(final Cartesian3D translation) {
private final Cartesian3D   translation;
TranslationTransform(final Cartesian3D translation) {
public Cartesian3D apply(final Point<Euclidean3D> point) {
return new Cartesian3D(1.0, (Cartesian3D) point, 1.0, translation);
final Cartesian2D shift  = tPlane.toSubSpace(apply(oPlane.getOrigin()));
public Rotation(Cartesian3D axis, double angle) throws MathIllegalArgumentException {
public Rotation(final Cartesian3D axis, final double angle, final RotationConvention convention)
public Rotation(Cartesian3D u1, Cartesian3D u2, Cartesian3D v1, Cartesian3D v2)
final Cartesian3D u3 = u1.crossProduct(u2).normalize();
final Cartesian3D v3 = v1.crossProduct(v2).normalize();
public Rotation(Cartesian3D u, Cartesian3D v) throws MathArithmeticException {
Cartesian3D w = u.orthogonal();
Cartesian3D q = v.crossProduct(u);
public Cartesian3D getAxis() {
public Cartesian3D getAxis(final RotationConvention convention) {
return convention == RotationConvention.VECTOR_OPERATOR ? Cartesian3D.PLUS_I : Cartesian3D.MINUS_I;
return new Cartesian3D(q1 * inverse, q2 * inverse, q3 * inverse);
return new Cartesian3D(q1 * inverse, q2 * inverse, q3 * inverse);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_I);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_I);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_J);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_J);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
Cartesian3D v1 = applyTo(Cartesian3D.PLUS_K);
Cartesian3D v2 = applyInverseTo(Cartesian3D.PLUS_K);
public Cartesian3D applyTo(Cartesian3D u) {
return new Cartesian3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,
public Cartesian3D applyInverseTo(Cartesian3D u) {
return new Cartesian3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,
new RotationOrder("XYZ", Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, Cartesian3D.PLUS_K);
new RotationOrder("XZY", Cartesian3D.PLUS_I, Cartesian3D.PLUS_K, Cartesian3D.PLUS_J);
new RotationOrder("YXZ", Cartesian3D.PLUS_J, Cartesian3D.PLUS_I, Cartesian3D.PLUS_K);
new RotationOrder("YZX", Cartesian3D.PLUS_J, Cartesian3D.PLUS_K, Cartesian3D.PLUS_I);
new RotationOrder("ZXY", Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J);
new RotationOrder("ZYX", Cartesian3D.PLUS_K, Cartesian3D.PLUS_J, Cartesian3D.PLUS_I);
new RotationOrder("XYX", Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, Cartesian3D.PLUS_I);
new RotationOrder("XZX", Cartesian3D.PLUS_I, Cartesian3D.PLUS_K, Cartesian3D.PLUS_I);
new RotationOrder("YXY", Cartesian3D.PLUS_J, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J);
new RotationOrder("YZY", Cartesian3D.PLUS_J, Cartesian3D.PLUS_K, Cartesian3D.PLUS_J);
new RotationOrder("ZXZ", Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_K);
new RotationOrder("ZYZ", Cartesian3D.PLUS_K, Cartesian3D.PLUS_J, Cartesian3D.PLUS_K);
private final Cartesian3D a1;
private final Cartesian3D a2;
private final Cartesian3D a3;
final Cartesian3D a1, final Cartesian3D a2, final Cartesian3D a3) {
public Cartesian3D getA1() {
public Cartesian3D getA2() {
public Cartesian3D getA3() {
private final Cartesian3D start;
private final Cartesian3D end;
public Segment(final Cartesian3D start, final Cartesian3D end, final Line line) {
public Cartesian3D getStart() {
public Cartesian3D getEnd() {
public class SphereGenerator implements SupportBallGenerator<Euclidean3D, Cartesian3D> {
public EnclosingBall<Euclidean3D, Cartesian3D> ballOnSupport(final List<Cartesian3D> support) {
return new EnclosingBall<>(Cartesian3D.ZERO, Double.NEGATIVE_INFINITY);
final Cartesian3D vA = support.get(0);
final Cartesian3D vB = support.get(1);
return new EnclosingBall<>(new Cartesian3D(0.5, vA, 0.5, vB),
final Cartesian3D vC = support.get(2);
final EnclosingBall<Euclidean2D, Cartesian2D> disk =
final Cartesian3D vD = support.get(3);
return new EnclosingBall<>(new Cartesian3D(centerX.doubleValue(),
private final Cartesian3D v;
public SphericalCoordinates(final Cartesian3D v) {
this.v  = new Cartesian3D(r * cosTheta * sinPhi,
public Cartesian3D getCartesian() {
return new SphericalCoordinates(new Cartesian3D(x, y, z));
public SubLine(final Cartesian3D start, final Cartesian3D end, final double tolerance)
final Cartesian3D start = line.toSpace(new Cartesian1D(interval.getInf()));
final Cartesian3D end   = line.toSpace(new Cartesian1D(interval.getSup()));
public Cartesian3D intersection(final SubLine subLine, final boolean includeEndPoints) {
Cartesian3D v1D = line.intersection(subLine.line);
private static IntervalsSet buildIntervalSet(final Cartesian3D start, final Cartesian3D end, final double tolerance)
Cartesian2D p = thisPlane.toSubSpace(inter.toSpace(Cartesian1D.ZERO));
Cartesian2D q = thisPlane.toSubSpace(inter.toSpace(Cartesian1D.ONE));
Cartesian3D crossP = Cartesian3D.crossProduct(inter.getDirection(), thisPlane.getNormal());
final Cartesian2D tmp = p;
final Cartesian3D v3 = (Cartesian3D) vector;
public Cartesian3D parse(final String source) throws MathParseException {
Cartesian3D result = parse(source, parsePosition);
Cartesian3D.class);
public Cartesian3D parse(final String source, final ParsePosition pos) {
return new Cartesian3D(coordinates[0], coordinates[1], coordinates[2]);
public class Cartesian2D implements Point<Euclidean2D>, Vector<Euclidean2D> {
public static final Cartesian2D ZERO   = new Cartesian2D(0, 0);
public static final Cartesian2D NaN = new Cartesian2D(Double.NaN, Double.NaN);
public static final Cartesian2D POSITIVE_INFINITY =
new Cartesian2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
public static final Cartesian2D NEGATIVE_INFINITY =
new Cartesian2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
public Cartesian2D(double x, double y) {
public Cartesian2D(double[] v) throws DimensionMismatchException {
public Cartesian2D(double a, Cartesian2D u) {
public Cartesian2D(double a1, Cartesian2D u1, double a2, Cartesian2D u2) {
public Cartesian2D(double a1, Cartesian2D u1, double a2, Cartesian2D u2,
double a3, Cartesian2D u3) {
public Cartesian2D(double a1, Cartesian2D u1, double a2, Cartesian2D u2,
double a3, Cartesian2D u3, double a4, Cartesian2D u4) {
public Cartesian2D getZero() {
public Cartesian2D add(Vector<Euclidean2D> v) {
Cartesian2D v2 = (Cartesian2D) v;
return new Cartesian2D(x + v2.getX(), y + v2.getY());
public Cartesian2D add(double factor, Vector<Euclidean2D> v) {
Cartesian2D v2 = (Cartesian2D) v;
return new Cartesian2D(x + factor * v2.getX(), y + factor * v2.getY());
public Cartesian2D subtract(Vector<Euclidean2D> p) {
Cartesian2D p3 = (Cartesian2D) p;
return new Cartesian2D(x - p3.x, y - p3.y);
public Cartesian2D subtract(double factor, Vector<Euclidean2D> v) {
Cartesian2D v2 = (Cartesian2D) v;
return new Cartesian2D(x - factor * v2.getX(), y - factor * v2.getY());
public Cartesian2D normalize() throws MathArithmeticException {
public static double angle(Cartesian2D v1, Cartesian2D v2) throws MathArithmeticException {
public Cartesian2D negate() {
return new Cartesian2D(-x, -y);
public Cartesian2D scalarMultiply(double a) {
return new Cartesian2D(a * x, a * y);
Cartesian2D p3 = (Cartesian2D) p;
return distance((Cartesian2D) p);
public double distance(Vector<Euclidean2D> v) {
return distance((Cartesian2D) v);
public double distance(Cartesian2D c) {
final double dx = c.x - x;
final double dy = c.y - y;
Cartesian2D p3 = (Cartesian2D) p;
Cartesian2D p3 = (Cartesian2D) p;
final Cartesian2D v2 = (Cartesian2D) v;
public double crossProduct(final Cartesian2D p1, final Cartesian2D p2) {
public static double distance(Cartesian2D p1, Cartesian2D p2) {
public static double distanceInf(Cartesian2D p1, Cartesian2D p2) {
public static double distanceSq(Cartesian2D p1, Cartesian2D p2) {
if (other instanceof Cartesian2D) {
final Cartesian2D rhs = (Cartesian2D)other;
public class DiskGenerator implements SupportBallGenerator<Euclidean2D, Cartesian2D> {
public EnclosingBall<Euclidean2D, Cartesian2D> ballOnSupport(final List<Cartesian2D> support) {
return new EnclosingBall<>(Cartesian2D.ZERO, Double.NEGATIVE_INFINITY);
final Cartesian2D vA = support.get(0);
final Cartesian2D vB = support.get(1);
return new EnclosingBall<>(new Cartesian2D(0.5, vA, 0.5, vB),
final Cartesian2D vC = support.get(2);
return new EnclosingBall<>(new Cartesian2D(centerX.doubleValue(),
public Line(final Cartesian2D p1, final Cartesian2D p2, final double tolerance) {
public Line(final Cartesian2D p, final double angle, final double tolerance) {
public void reset(final Cartesian2D p1, final Cartesian2D p2) {
public void reset(final Cartesian2D p, final double alpha) {
public Cartesian1D toSubSpace(Vector<Euclidean2D> vector) {
return toSubSpace((Cartesian2D) vector);
public Cartesian2D toSpace(Vector<Euclidean1D> vector) {
return toSpace((Cartesian1D) vector);
public Cartesian1D toSubSpace(final Point<Euclidean2D> point) {
return toSubSpace((Cartesian2D) point);
public Cartesian2D toSpace(final Point<Euclidean1D> point) {
return toSpace((Cartesian1D) point);
public Cartesian1D toSubSpace(final Cartesian2D cartesian) {
return new Cartesian1D(MathArrays.linearCombination(cos, cartesian.getX(), sin, cartesian.getY()));
public Cartesian2D toSpace(Cartesian1D cartesian) {
final double abscissa = cartesian.getX();
return new Cartesian2D(MathArrays.linearCombination(abscissa, cos, -originOffset, sin),
public Cartesian2D intersection(final Line other) {
return new Cartesian2D(MathArrays.linearCombination(cos, other.originOffset, -other.cos, originOffset) / d,
return getOffset((Cartesian2D) vector);
return getOffset((Cartesian2D) point);
public double getOffset(Cartesian2D cartesian) {
return MathArrays.linearCombination(sin, cartesian.getX(), -cos, cartesian.getY(), 1.0, originOffset);
public Cartesian2D getPointAt(final Cartesian1D abscissa, final double offset) {
return new Cartesian2D(MathArrays.linearCombination(x, cos,  dOffset, sin),
public boolean contains(final Cartesian2D p) {
public double distance(final Cartesian2D p) {
public void translateToPoint(final Cartesian2D p) {
public Cartesian2D apply(final Point<Euclidean2D> point) {
final Cartesian2D p2D = (Cartesian2D) point;
return new Cartesian2D(MathArrays.linearCombination(cXX, x, cXY, y, cX1, 1),
final Cartesian1D newLoc =
private Cartesian2D[] loop;
private NestedLoops(final Cartesian2D[] loop, final double tolerance)
Cartesian2D current = loop[loop.length - 1];
final Cartesian2D previous = current;
public void add(final Cartesian2D[] bLoop) throws MathIllegalArgumentException {
final Cartesian2D tmp = loop[min];
private Cartesian2D[][] vertices;
public PolygonsSet(final double hyperplaneThickness, final Cartesian2D ... vertices) {
final Cartesian2D minMin = new Cartesian2D(xMin, yMin);
final Cartesian2D minMax = new Cartesian2D(xMin, yMax);
final Cartesian2D maxMin = new Cartesian2D(xMax, yMin);
final Cartesian2D maxMax = new Cartesian2D(xMax, yMax);
final Cartesian2D ... vertices) {
private final Cartesian2D location;
Vertex(final Cartesian2D location) {
public Cartesian2D getLocation() {
final Cartesian2D[][] v = getVertices();
setBarycenter((Point<Euclidean2D>) Cartesian2D.NaN);
setBarycenter((Point<Euclidean2D>) new Cartesian2D(0, 0));
setBarycenter((Point<Euclidean2D>) Cartesian2D.NaN);
for (Cartesian2D[] loop : v) {
for (final Cartesian2D point : loop) {
setBarycenter((Point<Euclidean2D>) Cartesian2D.NaN);
setBarycenter((Point<Euclidean2D>) new Cartesian2D(sumX / (3 * sum), sumY / (3 * sum)));
public Cartesian2D[][] getVertices() {
vertices = new Cartesian2D[0][];
vertices = new Cartesian2D[loops.size()][];
vertices[i++] = new Cartesian2D[] {
line.toSpace(new Cartesian1D(-Float.MAX_VALUE)),
line.toSpace(new Cartesian1D(+Float.MAX_VALUE))
final Cartesian2D[] array = new Cartesian2D[loop.size() + 2];
double x = segment.getLine().toSubSpace(segment.getEnd()).getX();
array[j++] = segment.getLine().toSpace(new Cartesian1D(x));
double x = segment.getLine().toSubSpace(segment.getStart()).getX();
array[j++] = segment.getLine().toSpace(new Cartesian1D(x));
final Cartesian2D[] array = new Cartesian2D[loop.size()];
final Cartesian2D end = segment.getEnd();
final double distance = Cartesian2D.distance(end, candidateNext.getStart());
ConnectableSegment(final Cartesian2D start, final Cartesian2D end, final Line line,
final Cartesian2D startV = Double.isInfinite(i.getInf()) ?
null : line.toSpace(new Cartesian1D(i.getInf()));
final Cartesian2D endV   = Double.isInfinite(i.getSup()) ?
null : line.toSpace(new Cartesian1D(i.getSup()));
private BSPTree<Euclidean2D> selectClosest(final Cartesian2D point, final Iterable<BSPTree<Euclidean2D>> candidates) {
private final Cartesian2D start;
private final Cartesian2D end;
public Segment(final Cartesian2D start, final Cartesian2D end, final Line line) {
public Cartesian2D getStart() {
public Cartesian2D getEnd() {
public double distance(final Cartesian2D p) {
final Cartesian2D interPt = new Cartesian2D(px, py);
public SubLine(final Cartesian2D start, final Cartesian2D end, final double tolerance) {
final Cartesian2D start = line.toSpace(new Cartesian1D(interval.getInf()));
final Cartesian2D end   = line.toSpace(new Cartesian1D(interval.getSup()));
public Cartesian2D intersection(final SubLine subLine, final boolean includeEndPoints) {
Cartesian2D v2D = line1.intersection(line2);
private static IntervalsSet buildIntervalSet(final Cartesian2D start, final Cartesian2D end, final double tolerance) {
return new IntervalsSet(line.toSubSpace(start).getX(),
line.toSubSpace(end).getX(),
final Cartesian2D crossing = thisLine.intersection(otherLine);
final Cartesian1D x      = thisLine.toSubSpace(crossing);
final Cartesian2D p2 = (Cartesian2D) vector;
public Cartesian2D parse(final String source) throws MathParseException {
Cartesian2D result = parse(source, parsePosition);
Cartesian2D.class);
public Cartesian2D parse(final String source, final ParsePosition pos) {
return new Cartesian2D(coordinates[0], coordinates[1]);
public ConvexHull2D generate(final Collection<Cartesian2D> points)
Collection<Cartesian2D> hullVertices = null;
return new ConvexHull2D(hullVertices.toArray(new Cartesian2D[hullVertices.size()]),
protected abstract Collection<Cartesian2D> findHullVertices(Collection<Cartesian2D> points);
public static Collection<Cartesian2D> reducePoints(final Collection<Cartesian2D> points) {
Cartesian2D minX = null;
Cartesian2D maxX = null;
Cartesian2D minY = null;
Cartesian2D maxY = null;
for (Cartesian2D p : points) {
final List<Cartesian2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);
final List<Cartesian2D> reducedPoints = new ArrayList<>(quadrilateral);
for (final Cartesian2D p : points) {
private static List<Cartesian2D> buildQuadrilateral(final Cartesian2D... points) {
List<Cartesian2D> quadrilateral = new ArrayList<>();
for (Cartesian2D p : points) {
private static boolean insideQuadrilateral(final Cartesian2D point,
final List<Cartesian2D> quadrilateralPoints) {
Cartesian2D p1 = quadrilateralPoints.get(0);
Cartesian2D p2 = quadrilateralPoints.get(1);
public class ConvexHull2D implements ConvexHull<Euclidean2D, Cartesian2D>, Serializable {
private final Cartesian2D[] vertices;
public ConvexHull2D(final Cartesian2D[] vertices, final double tolerance)
private boolean isConvex(final Cartesian2D[] hullVertices) {
final Cartesian2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];
final Cartesian2D p2 = hullVertices[i];
final Cartesian2D p3 = hullVertices[i == hullVertices.length - 1 ? 0 : i + 1];
final Cartesian2D d1 = p2.subtract(p1);
final Cartesian2D d2 = p3.subtract(p2);
public Cartesian2D[] getVertices() {
final Cartesian2D p1 = vertices[0];
final Cartesian2D p2 = vertices[1];
Cartesian2D firstPoint = null;
Cartesian2D lastPoint = null;
for (Cartesian2D point : vertices) {
public interface ConvexHullGenerator2D extends ConvexHullGenerator<Euclidean2D, Cartesian2D> {
ConvexHull2D generate(Collection<Cartesian2D> points) throws NullArgumentException, ConvergenceException;
public Collection<Cartesian2D> findHullVertices(final Collection<Cartesian2D> points) {
final List<Cartesian2D> pointsSortedByXAxis = new ArrayList<>(points);
Collections.sort(pointsSortedByXAxis, new Comparator<Cartesian2D>() {
public int compare(final Cartesian2D o1, final Cartesian2D o2) {
final List<Cartesian2D> lowerHull = new ArrayList<>();
for (Cartesian2D p : pointsSortedByXAxis) {
final List<Cartesian2D> upperHull = new ArrayList<>();
final Cartesian2D p = pointsSortedByXAxis.get(idx);
final List<Cartesian2D> hullVertices = new ArrayList<>(lowerHull.size() + upperHull.size() - 2);
private void updateHull(final Cartesian2D point, final List<Cartesian2D> hull) {
final Cartesian2D p1 = hull.get(0);
final Cartesian2D p1 = hull.get(size - 2);
final Cartesian2D p2 = hull.get(size - 1);
public static final S1Point NaN = new S1Point(Double.NaN, Cartesian2D.NaN);
private final Cartesian2D vector;
new Cartesian2D(FastMath.cos(alpha), FastMath.sin(alpha)));
private S1Point(final double alpha, final Cartesian2D vector) {
public Cartesian2D getVector() {
return Cartesian2D.angle(p1.vector, p2.vector);
private Cartesian3D pole;
private Cartesian3D x;
private Cartesian3D y;
public Circle(final Cartesian3D pole, final double tolerance) {
private Circle(final Cartesian3D pole, final Cartesian3D x, final Cartesian3D y,
public void reset(final Cartesian3D newPole) {
this.y    = Cartesian3D.crossProduct(newPole, x).normalize();
public double getPhase(final Cartesian3D direction) {
public Cartesian3D getPointAt(final double alpha) {
return new Cartesian3D(FastMath.cos(alpha), x, FastMath.sin(alpha), y);
public Cartesian3D getXAxis() {
public Cartesian3D getYAxis() {
public Cartesian3D getPole() {
public double getOffset(final Cartesian3D direction) {
return Cartesian3D.angle(pole, direction) - 0.5 * FastMath.PI;
return Cartesian3D.dotProduct(pole, otherC.pole) >= 0.0;
public Cartesian3D getPointAt(final double alpha) {
final Cartesian3D edgeStart = edge.getStart().getLocation().getVector();
final double gap         = Cartesian3D.angle(point.getVector(), edgeStart);
final Cartesian3D previousStart = previous.getStart().getLocation().getVector();
if (Cartesian3D.angle(point.getVector(), previousStart) <= tolerance) {
private Cartesian3D summedBarycenter;
private final List<Cartesian3D> convexCellsInsidePoints;
this.summedBarycenter       = Cartesian3D.ZERO;
final Cartesian3D barycenter = convexCellBarycenter(boundary.get(0));
summedBarycenter = new Cartesian3D(1, summedBarycenter, area, barycenter);
final Cartesian3D previousPole = e.getCircle().getPole();
final Cartesian3D nextPole     = e.getEnd().getOutgoing().getCircle().getPole();
final Cartesian3D point        = e.getEnd().getLocation().getVector();
double alpha = FastMath.atan2(Cartesian3D.dotProduct(nextPole, Cartesian3D.crossProduct(point, previousPole)),
-Cartesian3D.dotProduct(nextPole, previousPole));
private Cartesian3D convexCellBarycenter(final Vertex start) {
Cartesian3D sumB = Cartesian3D.ZERO;
sumB = new Cartesian3D(1, sumB, e.getLength(), e.getCircle().getPole());
public List<Cartesian3D> getConvexCellsInsidePoints() {
public static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Cartesian3D.PLUS_I);
public static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Cartesian3D.PLUS_J);
public static final S2Point PLUS_K = new S2Point(0, 0, Cartesian3D.PLUS_K);
public static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Cartesian3D.MINUS_I);
public static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Cartesian3D.MINUS_J);
public static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Cartesian3D.MINUS_K);
public static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Cartesian3D.NaN);
private final Cartesian3D vector;
public S2Point(final Cartesian3D vector) throws MathArithmeticException {
this(FastMath.atan2(vector.getY(), vector.getX()), Cartesian3D.angle(Cartesian3D.PLUS_K, vector),
private S2Point(final double theta, final double phi, final Cartesian3D vector) {
private static Cartesian3D vector(final double theta, final double phi)
return new Cartesian3D(cosTheta * sinPhi, sinTheta * sinPhi, cosPhi);
public Cartesian3D getVector() {
return Cartesian3D.angle(p1.vector, p2.vector);
public SphericalPolygonsSet(final Cartesian3D pole, final double tolerance) {
public SphericalPolygonsSet(final Cartesian3D center, final Cartesian3D meridian,
private static S2Point[] createRegularPolygonVertices(final Cartesian3D center, final Cartesian3D meridian,
final Rotation r0 = new Rotation(Cartesian3D.crossProduct(center, meridian),
Cartesian3D.angle(start.getLocation().getVector(),
final List<Cartesian3D> points = getInsidePoints();
final WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> enclosing3D = encloser.enclose(points);
final Cartesian3D[] support3D = enclosing3D.getSupport();
for (Cartesian3D outsidePoint : getOutsidePoints()) {
private List<Cartesian3D> getInsidePoints() {
private List<Cartesian3D> getOutsidePoints() {
final double angle = Cartesian3D.angle(thisCircle.getPole(), otherCircle.getPole());
final Cartesian3D vectorA = new Cartesian3D(qA.getVectorPart());
final Cartesian3D vectorB = new Cartesian3D(qB.getVectorPart());
final Cartesian3D vectorResult = new Cartesian3D(qResult.getVectorPart());
final double scalarPartRef = qA.getScalarPart() * qB.getScalarPart() - Cartesian3D.dotProduct(vectorA, vectorB);
final Cartesian3D vectorPartRef = ((vectorA.scalarMultiply(qB.getScalarPart())).add(vectorB.scalarMultiply(qA
.getScalarPart()))).add(Cartesian3D.crossProduct(vectorA, vectorB));
final double scalarPartRefQxV = -Cartesian3D.dotProduct(new Cartesian3D(vectorQ), new Cartesian3D(vector));
final Cartesian3D vectorPartRefQxV = (new Cartesian3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Cartesian3D
.crossProduct(new Cartesian3D(vectorQ), new Cartesian3D(vector)));
final double normQxV = (new Cartesian3D(vectorResultQxV).subtract(vectorPartRefQxV)).getNorm();
final double scalarPartRefVxQ = -Cartesian3D.dotProduct(new Cartesian3D(vectorQ), new Cartesian3D(vector));
final Cartesian3D vectorPartRefVxQ = (new Cartesian3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Cartesian3D
.crossProduct(new Cartesian3D(vector), new Cartesian3D(vectorQ)));
final double normVxQ = (new Cartesian3D(vectorResultVxQ).subtract(vectorPartRefVxQ)).getNorm();
Cartesian2D center = new Cartesian2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
Cartesian2D center = new Cartesian2D(optimum.getPoint().getEntry(0), optimum.getPoint().getEntry(1));
private ArrayList<Cartesian2D> points;
points.add(new Cartesian2D(px, py));
public double getRadius(Cartesian2D center) {
for (Cartesian2D point : points) {
Cartesian2D center = new Cartesian2D(params[0], params[1]);
final Cartesian2D center = new Cartesian2D(params[0], params[1]);
for (Cartesian2D pk : points) {
final Cartesian2D pi = points.get(i);
Plane span = new Plane(Cartesian3D.ZERO, new Cartesian3D(1, 2, -3), new Cartesian3D(2, 1, 0), TOl);
double expected = FastMath.abs(span.getOffset(new Cartesian3D(1, 1, 1)));
for (Cartesian2D p : factory.generate(numPoints)) {
for (Cartesian2D p : factory.generate(numPoints)) {
public Cartesian2D[] generate(int n) {
final Cartesian2D[] cloud = new Cartesian2D[n];
private Cartesian2D create() {
return new Cartesian2D(pX, pY);
WelzlEncloser<Euclidean2D, Cartesian2D> encloser =
EnclosingBall<Euclidean2D, Cartesian2D> ball = encloser.enclose(null);
WelzlEncloser<Euclidean2D, Cartesian2D> encloser =
EnclosingBall<Euclidean2D, Cartesian2D> ball = encloser.enclose(new ArrayList<Cartesian2D>());
List<Cartesian2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54, 11, 15);
List<Cartesian2D> list = buildList(22, 26, 30, 38, 64, 28,  8, 54);
List<Cartesian2D> list = buildList(0.05380958511396061, 0.57332359658700000,
List<Cartesian2D> list = buildList(0.016930586154703, 0.333955448537779,
List<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(x, y));
private List<Cartesian2D> buildList(final double ... coordinates) {
List<Cartesian2D> list = new ArrayList<>(coordinates.length / 2);
list.add(new Cartesian2D(coordinates[i], coordinates[i + 1]));
private void checkDisk(List<Cartesian2D> points, List<Cartesian2D> refSupport) {
EnclosingBall<Euclidean2D, Cartesian2D> disk = checkDisk(points);
EnclosingBall<Euclidean2D, Cartesian2D> expected = generator.ballOnSupport(refSupport);
for (Cartesian2D s : disk.getSupport()) {
for (Cartesian2D rs : refSupport) {
List<Cartesian2D> reducedSupport = new ArrayList<>();
for (Cartesian2D s : disk.getSupport()) {
EnclosingBall<Euclidean2D, Cartesian2D> reducedDisk = generator.ballOnSupport(reducedSupport);
private EnclosingBall<Euclidean2D, Cartesian2D> checkDisk(List<Cartesian2D> points) {
WelzlEncloser<Euclidean2D, Cartesian2D> encloser =
EnclosingBall<Euclidean2D, Cartesian2D> disk = encloser.enclose(points);
for (Cartesian2D v : points) {
for (Cartesian2D v : points) {
for (Cartesian2D s : disk.getSupport()) {
WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> ball = encloser.enclose(null);
WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> ball = encloser.enclose(new ArrayList<Cartesian3D>());
List<Cartesian3D> list =
Arrays.asList(new Cartesian3D(-7.140397329568118, -16.571661242582177,  11.714458961735405),
new Cartesian3D(-7.137986707455888, -16.570767323375720,  11.708602108715928),
new Cartesian3D(-7.139185068549035, -16.570891204702250,  11.715554057357394),
new Cartesian3D(-7.142682716997507, -16.571609818234290,  11.710787934580328),
new Cartesian3D(-7.139018392423351, -16.574405614157020,  11.710518716711425),
new Cartesian3D(-7.140870659936730, -16.567993074240455,  11.710914678204503),
new Cartesian3D(-7.136350173659562, -16.570498228820930,  11.713965225900928),
new Cartesian3D(-7.141675762759172, -16.572852471407028,  11.714033471449508),
new Cartesian3D(-7.140453077221105, -16.570212820780647,  11.708624578004980),
new Cartesian3D(-7.140322188726825, -16.574152894557717,  11.710305611121410),
new Cartesian3D(-7.141116131477088, -16.574061164624560,  11.712938509321699));
WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> ball = encloser.enclose(list);
List<Cartesian3D> list =
Arrays.asList(new Cartesian3D( -0.89227075512164380,  -2.89317694645713900,  14.84572323743355500),
new Cartesian3D( -0.92099498940693580,  -2.31086108263908940,  12.92071026467688300),
new Cartesian3D( -0.85227999411005200,  -3.06314731441320730,  15.40163831651287000),
new Cartesian3D( -1.77399413020785970,  -3.65630391378114260,  14.13190097751873400),
new Cartesian3D(  0.33157833272465354,  -2.22813591757792160,  14.21225234159008200),
new Cartesian3D( -1.53065579165484400,  -1.65692084770139570,  14.61483055714788500),
new Cartesian3D( -1.08457093941217140,  -1.96100325935602980,  13.09265170575555000),
new Cartesian3D(  0.30029469589708850,  -3.05470831395667370,  14.56352400426342600),
new Cartesian3D( -0.95007443938638460,  -1.86810946486118360,  15.14491234340057000),
new Cartesian3D( -1.89661503804130830,  -2.17004080885185860,  14.81235128513927000),
new Cartesian3D( -0.72193328761607530,  -1.44513142833618270,  14.52355724218561800),
new Cartesian3D( -0.26895980939606550,  -3.69512371522084140,  14.72272846327652000),
new Cartesian3D( -1.53501693431786170,  -3.25055166611021900,  15.15509062584274800),
new Cartesian3D( -0.71727553535519410,  -3.62284279460799100,  13.26256700929380700),
new Cartesian3D( -0.30220950676137365,  -3.25410412500779070,  13.13682612771606000),
new Cartesian3D( -0.04543996608267075,  -1.93081853923797750,  14.79497997883171400),
new Cartesian3D( -1.53348892951571640,  -3.66688919703524900,  14.73095600812074200),
new Cartesian3D( -0.98034899533935820,  -3.34004481162763960,  13.03245014017556800));
WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> ball = encloser.enclose(list);
Cartesian3D refCenter = new Cartesian3D(d, new Cartesian3D(sr.nextVector()));
List<Cartesian3D> points = new ArrayList<>();
points.add(new Cartesian3D(1.0, refCenter, r, new Cartesian3D(sr.nextVector())));
private void checkSphere(List<Cartesian3D> points, double refRadius) {
EnclosingBall<Euclidean3D, Cartesian3D> sphere = checkSphere(points);
List<Cartesian3D> reducedSupport = new ArrayList<>();
for (Cartesian3D s : sphere.getSupport()) {
EnclosingBall<Euclidean3D, Cartesian3D> reducedSphere =
private EnclosingBall<Euclidean3D, Cartesian3D> checkSphere(List<Cartesian3D> points) {
WelzlEncloser<Euclidean3D, Cartesian3D> encloser =
EnclosingBall<Euclidean3D, Cartesian3D> Sphere = encloser.enclose(points);
for (Cartesian3D v : points) {
for (Cartesian3D v : points) {
for (Cartesian3D s : Sphere.getSupport()) {
Assert.assertEquals(4.0, ((Cartesian1D) set.getBarycenter()).getX(), 1.0e-10);
Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Cartesian1D(2.3)));
Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Cartesian1D(5.7)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(1.2)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(8.7)));
Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Cartesian1D(3.0)));
Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Cartesian1D(9.0)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(8.4)));
set.checkPoint(new Cartesian1D(FastMath.pow(10.0, e))));
Assert.assertEquals(5.9, ((Cartesian1D) set.getBarycenter()).getX(), 1.0e-10);
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(0.0)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(4.0)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(8.0)));
Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Cartesian1D(12.0)));
Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Cartesian1D(1.2)));
Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Cartesian1D(5.9)));
Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Cartesian1D(9.01)));
Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Cartesian1D(5.0)));
Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Cartesian1D(11.0)));
Assert.assertEquals(1.0, ((Cartesian1D) set.getBarycenter()).getX(), Precision.EPSILON);
Cartesian1D c = new Cartesian1D(1);
Cartesian1D c = new Cartesian1D(1.23);
Cartesian1D c = new Cartesian1D(1.232323232323);
Cartesian1D c = new Cartesian1D(-1.232323232323);
Cartesian1D c = new Cartesian1D(1);
Cartesian1D c = new Cartesian1D(232.22222222222);
Cartesian1D c = Cartesian1D.NaN;
Cartesian1D c = Cartesian1D.POSITIVE_INFINITY;
Cartesian1D c = Cartesian1D.NEGATIVE_INFINITY;
Cartesian1D expected = new Cartesian1D(1);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(1);
Cartesian1D expected = new Cartesian1D(1.23);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(1.2323);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(-1.2323);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(1.2323);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(1.2323);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(-1.2323);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(0.0);
Cartesian1D actual = vector1DFormat.parse(source);
Cartesian1D expected = new Cartesian1D(1.2323);
Cartesian1D actual = vector1DFormatSquare.parse(source);
Cartesian1D actual = vector1DFormat.parse(source);
Assert.assertEquals(Cartesian1D.NaN, actual);
Cartesian1D actual = vector1DFormat.parse(source);
Assert.assertEquals(Cartesian1D.POSITIVE_INFINITY, actual);
Cartesian1D actual = vector1DFormat.parse(source);
Assert.assertEquals(Cartesian1D.NEGATIVE_INFINITY, actual);
checkVector(new Cartesian1D(3, new Cartesian1D(FastMath.PI / 3)),
checkVector(new Cartesian1D(2, Cartesian1D.ONE, -3, new Cartesian1D(2)),
checkVector(new Cartesian1D(2, Cartesian1D.ONE,
5, new Cartesian1D(2),
-3, new Cartesian1D(3)),
checkVector(new Cartesian1D(2, Cartesian1D.ONE,
5, new Cartesian1D(2),
5, new Cartesian1D(-2),
-3, new Cartesian1D(-3)),
Space space = new Cartesian1D(1).getSpace();
Assert.assertEquals(0, new Cartesian1D(1).getZero().getNorm(), 1.0e-15);
Cartesian1D u1 = new Cartesian1D(1);
Cartesian1D u2 = new Cartesian1D(1);
Assert.assertFalse(u1.equals(new Cartesian1D(1 + 10 * Precision.EPSILON)));
Assert.assertTrue(new Cartesian1D(Double.NaN).equals(new Cartesian1D(Double.NaN)));
Assert.assertEquals(new Cartesian1D(Double.NaN).hashCode(), new Cartesian1D(Double.NaN).hashCode());
Cartesian1D u = new Cartesian1D(1);
Cartesian1D v = new Cartesian1D(1 + 10 * Precision.EPSILON);
Assert.assertTrue(new Cartesian1D(Double.NEGATIVE_INFINITY).isInfinite());
Assert.assertTrue(new Cartesian1D(Double.POSITIVE_INFINITY).isInfinite());
Assert.assertFalse(new Cartesian1D(1).isInfinite());
Assert.assertFalse(new Cartesian1D(Double.NaN).isInfinite());
Assert.assertTrue(new Cartesian1D(Double.NaN).isNaN());
Assert.assertFalse(new Cartesian1D(1).isNaN());
Assert.assertFalse(new Cartesian1D(Double.NEGATIVE_INFINITY).isNaN());
Assert.assertEquals("{3}", new Cartesian1D(3).toString());
Assert.assertEquals("{3.000}", new Cartesian1D(3).toString(format));
Cartesian1D v = new Cartesian1D(1);
Assert.assertEquals(0.0, Cartesian1D.ZERO.getNorm1(), 0);
Assert.assertEquals(6.0, new Cartesian1D(6).getNorm1(), 0);
Assert.assertEquals(0.0, Cartesian1D.ZERO.getNorm(), 0);
Assert.assertEquals(3.0, new Cartesian1D(-3).getNorm(), 1.0e-12);
Assert.assertEquals(0.0, new Cartesian1D(0).getNormSq(), 0);
Assert.assertEquals(9.0, new Cartesian1D(-3).getNormSq(), 1.0e-12);
Assert.assertEquals(0.0, Cartesian1D.ZERO.getNormInf(), 0);
Assert.assertEquals(3.0, new Cartesian1D(-3).getNormInf(), 0);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-4);
Assert.assertEquals(0.0, new Cartesian1D(-1).distance1(new Cartesian1D(-1)), 0);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-4);
Assert.assertEquals(0.0, Cartesian1D.distance(new Cartesian1D(-1), new Cartesian1D(-1)), 0);
Assert.assertEquals(5.0, Cartesian1D.distance(v1, v2), 1.0e-12);
Assert.assertEquals(v1.subtract(v2).getNorm(), Cartesian1D.distance(v1, v2), 1.0e-12);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-4);
Assert.assertEquals(0.0, Cartesian1D.distanceSq(new Cartesian1D(-1), new Cartesian1D(-1)), 0);
Assert.assertEquals(25.0, Cartesian1D.distanceSq(v1, v2), 1.0e-12);
Assert.assertEquals(Cartesian1D.distance(v1, v2) * Cartesian1D.distance(v1, v2),
Cartesian1D.distanceSq(v1, v2), 1.0e-12);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-4);
Assert.assertEquals(0.0, Cartesian1D.distanceInf(new Cartesian1D(-1), new Cartesian1D(-1)), 0);
Assert.assertEquals(5.0, Cartesian1D.distanceInf(v1, v2), 1.0e-12);
Assert.assertEquals(v1.subtract(v2).getNormInf(), Cartesian1D.distanceInf(v1, v2), 1.0e-12);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-3);
Cartesian1D v1 = new Cartesian1D(1);
Cartesian1D v2 = new Cartesian1D(-3);
Cartesian1D v = new Cartesian1D(1);
Assert.assertEquals(1.0, new Cartesian1D(5).normalize().getNorm(), 1.0e-12);
Cartesian1D.ZERO.normalize();
checkVector(new Cartesian1D(0.1).negate(), -0.1);
private void checkVector(Cartesian1D v, double x) {
Cartesian3D   u     = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(unit1[0], unit1[1], unit1[2]),
Cartesian3D a      = new Cartesian3D(kx / n, ky / n, kz / n);
Cartesian3D   u = new Cartesian3D(x, y, z);
double dot     = Cartesian3D.dotProduct(u, a);
Cartesian3D cross = Cartesian3D.crossProduct(a, u);
Cartesian3D rt    = new Cartesian3D(cosTheta, u, c2, a, sinTheta, cross);
Cartesian3D dvdTheta =
new Cartesian3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);
Cartesian3D   u     = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(unit1[0], unit1[1], unit1[2]),
new Cartesian3D(1, 0,  0)),
new Cartesian3D(1, 0,  0),
new Cartesian3D(0, 0, -1)),
new Cartesian3D(1, 0,  0),
new Cartesian3D(0, 1,  0),
new Cartesian3D(0, 0, -1)),
new Cartesian3D(1, 0,  0),
new Cartesian3D(0, 1,  0),
new Cartesian3D(0, -1,  0),
new Cartesian3D(0, 0, -1)),
distance = FieldVector3D.distance1(v1, new Cartesian3D(-4, 2, 0));
distance = FieldVector3D.distance1(new Cartesian3D(-4, 2, 0), v1);
distance = FieldVector3D.distance(v1, new Cartesian3D(-4, 2, 0));
distance = FieldVector3D.distance(new Cartesian3D(-4, 2, 0), v1);
distanceSq = FieldVector3D.distanceSq(v1, new Cartesian3D(-4, 2, 0));
distanceSq = FieldVector3D.distanceSq(new Cartesian3D(-4, 2, 0), v1);
distance = FieldVector3D.distanceInf(v1, new Cartesian3D(-4, 2, 0));
distance = FieldVector3D.distanceInf(new Cartesian3D(-4, 2, 0), v1);
FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), new Cartesian3D(-4,  2, 0)).getReal(),
FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), new Cartesian3D(-4, 0,  2)).getReal(),
FieldVector3D.distanceInf(createVector(-2,  1, 3, 3), new Cartesian3D( 2, -4, 0)).getReal(),
FieldVector3D.distanceInf(createVector(-2, 3,  1, 3), new Cartesian3D( 2, 0, -4)).getReal(),
FieldVector3D.distanceInf(createVector(3, -2,  1, 3), new Cartesian3D(0,  2, -4)).getReal(),
FieldVector3D.distanceInf(createVector(3,  1, -2, 3), new Cartesian3D(0, -4,  2)).getReal(),
checkVector(v2.subtract(new Cartesian3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
checkVector(v2.subtract(3, new Cartesian3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1);
checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Cartesian3D(4, 4, 4)),
checkVector(v2.add(new Cartesian3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1);
checkVector(v2.add(3, new Cartesian3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1);
checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Cartesian3D(-2, 0, 2)),
FieldVector3D.angle(v1, Cartesian3D.ZERO);
Cartesian3D v = new Cartesian3D(vx, vy, vz);
Cartesian3D cNaive = new Cartesian3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
Cartesian3D v = new Cartesian3D(vx, vy, vz);
Cartesian3D p1 = new Cartesian3D(0, 0, 1);
Line l = new Line(p1, new Cartesian3D(0, 0, 2), 1.0e-10);
Assert.assertTrue(l.contains(new Cartesian3D(1.0, p1, 0.3, l.getDirection())));
Cartesian3D u = l.getDirection().orthogonal();
Cartesian3D v = Cartesian3D.crossProduct(l.getDirection(), u);
Assert.assertTrue(! l.contains(p1.add(new Cartesian3D(FastMath.cos(alpha), u,
Cartesian3D p1  = new Cartesian3D (1.2, 3.4, -5.8);
Cartesian3D p2  = new Cartesian3D (3.4, -5.8, 1.2);
Line l = new Line(new Cartesian3D(0, 1, 1), new Cartesian3D(0, 2, 2), 1.0e-10);
Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Cartesian3D(1, 0, 1)), 1.0e-10);
Assert.assertEquals(0, l.distance(new Cartesian3D(0, -4, -4)), 1.0e-10);
Line l = new Line(new Cartesian3D(0, 1, 1), new Cartesian3D(0, 2, 2), 1.0e-10);
l.distance(new Line(new Cartesian3D(1, 0, 1), new Cartesian3D(1, 0, 2), 1.0e-10)),
l.distance(new Line(new Cartesian3D(-0.5, 0, 0), new Cartesian3D(-0.5, -1, -1), 1.0e-10)),
l.distance(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -5, -5), 1.0e-10)),
l.distance(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -3, -4), 1.0e-10)),
l.distance(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(1, -4, -4), 1.0e-10)),
l.distance(new Line(new Cartesian3D(0, -4, 0), new Cartesian3D(1, -4, 0), 1.0e-10)),
Line l = new Line(new Cartesian3D(0, 1, 1), new Cartesian3D(0, 2, 2), 1.0e-10);
l.closestPoint(new Line(new Cartesian3D(1, 0, 1), new Cartesian3D(1, 0, 2), 1.0e-10)).distance(new Cartesian3D(0, 0, 0)),
l.closestPoint(new Line(new Cartesian3D(-0.5, 0, 0), new Cartesian3D(-0.5, -1, -1), 1.0e-10)).distance(new Cartesian3D(-0.5, 0, 0)),
l.closestPoint(l).distance(new Cartesian3D(0, 0, 0)),
l.closestPoint(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -5, -5), 1.0e-10)).distance(new Cartesian3D(0, 0, 0)),
l.closestPoint(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -3, -4), 1.0e-10)).distance(new Cartesian3D(0, -4, -4)),
l.closestPoint(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(1, -4, -4), 1.0e-10)).distance(new Cartesian3D(0, -4, -4)),
l.closestPoint(new Line(new Cartesian3D(0, -4, 0), new Cartesian3D(1, -4, 0), 1.0e-10)).distance(new Cartesian3D(0, -2, -2)),
Line l = new Line(new Cartesian3D(0, 1, 1), new Cartesian3D(0, 2, 2), 1.0e-10);
Assert.assertNull(l.intersection(new Line(new Cartesian3D(1, 0, 1), new Cartesian3D(1, 0, 2), 1.0e-10)));
Assert.assertNull(l.intersection(new Line(new Cartesian3D(-0.5, 0, 0), new Cartesian3D(-0.5, -1, -1), 1.0e-10)));
l.intersection(l).distance(new Cartesian3D(0, 0, 0)),
l.intersection(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -5, -5), 1.0e-10)).distance(new Cartesian3D(0, 0, 0)),
l.intersection(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(0, -3, -4), 1.0e-10)).distance(new Cartesian3D(0, -4, -4)),
l.intersection(new Line(new Cartesian3D(0, -4, -4), new Cartesian3D(1, -4, -4), 1.0e-10)).distance(new Cartesian3D(0, -4, -4)),
Assert.assertNull(l.intersection(new Line(new Cartesian3D(0, -4, 0), new Cartesian3D(1, -4, 0), 1.0e-10)));
Line line = new Line(new Cartesian3D(1653345.6696423641, 6170370.041579291, 90000),
new Cartesian3D(1650757.5050732433, 6160710.879908984, 0.9),
Cartesian3D expected = line.getDirection().negate();
private Cartesian3D[] vertices;
vertices = new Cartesian3D[nbVertices];
vertices[i] = new Cartesian3D(Double.parseDouble(fields.get(xIndex).getValue()),
public List<Cartesian3D> getVertices() {
Plane p = new Plane(new Cartesian3D(0, 0, 1), new Cartesian3D(0, 0, 1), 1.0e-10);
Assert.assertTrue(p.contains(new Cartesian3D(0, 0, 1)));
Assert.assertTrue(p.contains(new Cartesian3D(17, -32, 1)));
Assert.assertTrue(! p.contains(new Cartesian3D(17, -32, 1.001)));
Cartesian3D p1 = new Cartesian3D(1, 1, 1);
Plane p = new Plane(p1, new Cartesian3D(0.2, 0, 0), 1.0e-10);
Assert.assertEquals(-5.0, p.getOffset(new Cartesian3D(-4, 0, 0)), 1.0e-10);
Assert.assertEquals(+5.0, p.getOffset(new Cartesian3D(6, 10, -12)), 1.0e-10);
p.getOffset(new Cartesian3D(1.0, p1, 0.3, p.getNormal())),
p.getOffset(new Cartesian3D(1.0, p1, -0.3, p.getNormal())),
Plane p = new Plane(new Cartesian3D(2, -3, 1), new Cartesian3D(1, 4, 9), 1.0e-10);
Cartesian3D p1 = new Cartesian3D(1.2, 3.4, -5.8);
Cartesian3D p2 = new Cartesian3D(3.4, -5.8, 1.2);
Cartesian3D p3 = new Cartesian3D(-2.0, 4.3, 0.7);
Cartesian3D p1 = new Cartesian3D(1.2, 3.4, -5.8);
Cartesian3D p2 = new Cartesian3D(3.4, -5.8, 1.2);
Cartesian3D p3 = new Cartesian3D(-2.0, 4.3, 0.7);
Cartesian3D oldNormal = p.getNormal();
Cartesian3D p1 = new Cartesian3D(1.2, 3.4, -5.8);
Cartesian3D p2 = new Cartesian3D(3.4, -5.8, 1.2);
Cartesian3D p3 = new Cartesian3D(-2.0, 4.3, 0.7);
p = p.translate(new Cartesian3D(2.0, p.getU(), -1.5, p.getV()));
p = p.translate(new Cartesian3D(-1.2, p.getNormal()));
p = p.translate(new Cartesian3D(+1.2, p.getNormal()));
Plane p = new Plane(new Cartesian3D(1, 2, 3), new Cartesian3D(-4, 1, -5), 1.0e-10);
Line  l = new Line(new Cartesian3D(0.2, -3.5, 0.7), new Cartesian3D(1.2, -2.5, -0.3), 1.0e-10);
Cartesian3D point = p.intersection(l);
Assert.assertNull(p.intersection(new Line(new Cartesian3D(10, 10, 10),
new Cartesian3D(10, 10, 10).add(p.getNormal().orthogonal()),
Cartesian3D p1  = new Cartesian3D (1.2, 3.4, -5.8);
Cartesian3D p2  = new Cartesian3D (3.4, -5.8, 1.2);
Plane    pA  = new Plane(p1, p2, new Cartesian3D (-2.0, 4.3, 0.7), 1.0e-10);
Plane    pB  = new Plane(p1, new Cartesian3D (11.4, -3.8, 5.1), p2, 1.0e-10);
Cartesian3D reference = new Cartesian3D (1.2, 3.4, -5.8);
Plane p1 = new Plane(reference, new Cartesian3D(1, 3, 3), 1.0e-10);
Plane p2 = new Plane(reference, new Cartesian3D(-2, 4, 0), 1.0e-10);
Plane p3 = new Plane(reference, new Cartesian3D(7, 0, -4), 1.0e-10);
Cartesian3D p = Plane.intersection(p1, p2, p3);
Cartesian3D p1  = new Cartesian3D (1.2, 3.4, -5.8);
Cartesian3D p2  = new Cartesian3D (3.4, -5.8, 1.2);
Cartesian3D p3  = new Cartesian3D (-2.0, 4.3, 0.7);
Plane    pB  = new Plane(p1, new Cartesian3D (11.4, -3.8, 5.1), p2, 1.0e-10);
Cartesian3D shift = new Cartesian3D(0.3, pA.getNormal());
Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();
Assert.assertEquals(expected, tree.checkPoint(new Cartesian3D(x, y, z)));
checkPoints(Region.Location.BOUNDARY, tree, new Cartesian3D[] {
new Cartesian3D(0.0, 0.5, 0.5),
new Cartesian3D(1.0, 0.5, 0.5),
new Cartesian3D(0.5, 0.0, 0.5),
new Cartesian3D(0.5, 1.0, 0.5),
new Cartesian3D(0.5, 0.5, 0.0),
new Cartesian3D(0.5, 0.5, 1.0)
checkPoints(Region.Location.OUTSIDE, tree, new Cartesian3D[] {
new Cartesian3D(0.0, 1.2, 1.2),
new Cartesian3D(1.0, 1.2, 1.2),
new Cartesian3D(1.2, 0.0, 1.2),
new Cartesian3D(1.2, 1.0, 1.2),
new Cartesian3D(1.2, 1.2, 0.0),
new Cartesian3D(1.2, 1.2, 1.0)
Cartesian3D vertex1 = new Cartesian3D(1, 2, 3);
Cartesian3D vertex2 = new Cartesian3D(2, 2, 4);
Cartesian3D vertex3 = new Cartesian3D(2, 3, 3);
Cartesian3D vertex4 = new Cartesian3D(1, 3, 4);
Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();
checkPoints(Region.Location.BOUNDARY, tree, new Cartesian3D[] {
new Cartesian3D(third, vertex1, third, vertex2, third, vertex3),
new Cartesian3D(third, vertex2, third, vertex3, third, vertex4),
new Cartesian3D(third, vertex3, third, vertex4, third, vertex1),
new Cartesian3D(third, vertex4, third, vertex1, third, vertex2)
checkPoints(Region.Location.OUTSIDE, tree, new Cartesian3D[] {
new Cartesian3D(1, 2, 4),
new Cartesian3D(2, 2, 3),
new Cartesian3D(2, 3, 4),
new Cartesian3D(1, 3, 3)
Cartesian3D vertex1 = new Cartesian3D(1.1, 2.2, 3.3);
Cartesian3D vertex2 = new Cartesian3D(2.0, 2.4, 4.2);
Cartesian3D vertex3 = new Cartesian3D(2.8, 3.3, 3.7);
Cartesian3D vertex4 = new Cartesian3D(1.0, 3.6, 4.5);
Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();
Cartesian3D s = new Cartesian3D(10.2, 4.3, -6.7);
Cartesian3D c = new Cartesian3D(-0.2, 2.1, -3.2);
Rotation r = new Rotation(new Cartesian3D(6.2, -4.4, 2.1), 0.12, RotationConvention.VECTOR_OPERATOR);
Cartesian3D newB =
new Cartesian3D(1.0, s,
final Cartesian3D[] expectedV = new Cartesian3D[] {
new Cartesian3D(1.0, s,
new Cartesian3D(1.0, s,
new Cartesian3D(1.0, s,
new Cartesian3D(1.0, s,
Cartesian2D[][] vertices =
Cartesian3D v = plane.toSpace(vertices[0][i]);
Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();
Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();
Cartesian3D v_1 = new Cartesian3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);
Cartesian3D v_2 = new Cartesian3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);
Cartesian3D v_3 = new Cartesian3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);
Cartesian3D[] vertices = {v_1, v_2, v_3};
Cartesian2D[] projPts = new Cartesian2D[vertices.length];
ps.checkPoint(Cartesian3D.ZERO);
Cartesian3D[] verts=new Cartesian3D[8];
verts[0]=new Cartesian3D(xmin,ymin,zmin);
verts[1]=new Cartesian3D(xmax,ymin,zmin);
verts[2]=new Cartesian3D(xmax,ymax,zmin);
verts[3]=new Cartesian3D(xmin,ymax,zmin);
verts[4]=new Cartesian3D(xmin,ymin,zmax);
verts[5]=new Cartesian3D(xmax,ymin,zmax);
verts[6]=new Cartesian3D(xmax,ymax,zmax);
verts[7]=new Cartesian3D(xmin,ymax,zmax);
checkError(Arrays.asList(Cartesian3D.ZERO, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, Cartesian3D.PLUS_K),
private void checkError(final List<Cartesian3D> vertices, final List<int[]> facets,
Cartesian3D origin    = Cartesian3D.ZERO;
Cartesian3D direction = new Cartesian3D(2 * random.nextDouble() - 1,
Cartesian3D intersectionPoint = ((Plane)plane.getHyperplane()).intersection(line);
private void checkPoints(Region.Location expected, PolyhedronsSet tree, Cartesian3D[] points) {
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);
Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_I);
checkVector(r.getAxis(), new Cartesian3D(s, s, s));
new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3);
r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI);
checkVector(r.getAxis(), new Cartesian3D(0, 0, -1));
r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI);
checkVector(r.getAxis(), Cartesian3D.PLUS_J);
checkVector(Rotation.IDENTITY.getAxis(), Cartesian3D.PLUS_I);
Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_I);
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D( s,  s,  s));
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(-s, -s, -s));
new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);
r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.VECTOR_OPERATOR);
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(0, 0, -1));
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(0, 0, +1));
r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_J);
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_J);
checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_I);
checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_I);
Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_I);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_J);
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D( s,  s,  s));
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(-s, -s, -s));
new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);
r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.FRAME_TRANSFORM);
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(0, 0, -1));
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(0, 0, +1));
r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI, RotationConvention.FRAME_TRANSFORM);
checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.PLUS_J);
checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.MINUS_J);
checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_I);
checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_I);
Cartesian3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
Cartesian3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),
Cartesian3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),
Cartesian3D u = new Cartesian3D(3, 2, 1);
Cartesian3D v = new Cartesian3D(-4, 2, 2);
new Rotation(u, Cartesian3D.ZERO);
Cartesian3D u1 = new Cartesian3D(3, 0, 0);
Cartesian3D u2 = new Cartesian3D(0, 5, 0);
Cartesian3D v1 = new Cartesian3D(0, 0, 2);
Cartesian3D v2 = new Cartesian3D(-2, 0, 2);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.MINUS_I);
Cartesian3D axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);
if (Cartesian3D.dotProduct(axis, Cartesian3D.PLUS_K) > 0) {
checkVector(axis, Cartesian3D.PLUS_K);
checkVector(axis, Cartesian3D.MINUS_K);
r = new Rotation(Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,
new Cartesian3D(0.5, 0.5,  sqrt),
new Cartesian3D(0.5, 0.5, -sqrt));
r = new Rotation(u1, u2, u1, Cartesian3D.crossProduct(u1, u2));
new Rotation(u1, u2, Cartesian3D.ZERO, v2);
checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);
checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_I);
checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_J);
checkVector(r.applyTo(Cartesian3D.PLUS_I),
new Cartesian3D(m3[0][0], m3[1][0], m3[2][0]));
checkVector(r.applyTo(Cartesian3D.PLUS_J),
new Cartesian3D(m3[0][1], m3[1][1], m3[2][1]));
checkVector(r.applyTo(Cartesian3D.PLUS_K),
new Cartesian3D(m3[0][2], m3[1][2], m3[2][2]));
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);
Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);
Cartesian3D u = new Cartesian3D(x, y, z);
Rotation r = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(x, y, z);
Cartesian3D v = r.applyTo(u);
Rotation r = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),
Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),
r = new Rotation(Cartesian3D.PLUS_K, FastMath.PI, RotationConvention.VECTOR_OPERATOR);
Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),
Cartesian3D u1 = new Cartesian3D(-1321008684645961.0 /  268435456.0,
Cartesian3D u2 =new Cartesian3D( -5712344449280879.0 /    2097152.0,
Rotation rot = new Rotation(u1, u2, Cartesian3D.PLUS_I,Cartesian3D.PLUS_K);
Cartesian3D u1 = new Cartesian3D(0.9999988431610581, -0.0015210774290851095, 0.0);
Cartesian3D u2 = new Cartesian3D(0.0, 0.0, 1.0);
Cartesian3D v1 = new Cartesian3D(0.9999999999999999, 0.0, 0.0);
Cartesian3D v2 = new Cartesian3D(0.0, 0.0, -1.0);
Assert.assertEquals(0.0, Cartesian3D.angle(v1, quat.applyTo(u1)), 1.0e-14);
Assert.assertEquals(0.0, Cartesian3D.angle(v2, quat.applyTo(u2)), 1.0e-14);
final Cartesian3D startingVector = Cartesian3D.PLUS_I;
Cartesian3D appliedIndividually = startingVector;
final Cartesian3D bad = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, yRotation, xRotation).applyTo(startingVector);
final Cartesian3D startingVector = Cartesian3D.PLUS_I;
Cartesian3D appliedIndividually = startingVector;
final Cartesian3D good = composite.applyTo(startingVector);
private void checkVector(Cartesian3D v1, Cartesian3D v2) {
List<Cartesian3D> support = Arrays.asList(new Cartesian3D[0]);
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
List<Cartesian3D> support = Arrays.asList(new Cartesian3D(1, 2, 3));
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
Assert.assertFalse(sphere.contains(new Cartesian3D(support.get(0).getX() + 0.1,
Assert.assertTrue(sphere.contains(new Cartesian3D(support.get(0).getX() + 0.1,
List<Cartesian3D> support = Arrays.asList(new Cartesian3D(1, 0, 0),
new Cartesian3D(3, 0, 0));
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
for (Cartesian3D v : support) {
Assert.assertTrue(sphere.contains(new Cartesian3D(2, 0.9, 0)));
Assert.assertFalse(sphere.contains(Cartesian3D.ZERO));
Assert.assertEquals(0.0, new Cartesian3D(2, 0, 0).distance(sphere.getCenter()), 1.0e-10);
List<Cartesian3D> support = Arrays.asList(new Cartesian3D(1, 0, 0),
new Cartesian3D(3, 0, 0),
new Cartesian3D(2, 2, 0));
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
for (Cartesian3D v : support) {
Assert.assertTrue(sphere.contains(new Cartesian3D(2, 0.9, 0)));
Assert.assertFalse(sphere.contains(new Cartesian3D(0.9,  0, 0)));
Assert.assertFalse(sphere.contains(new Cartesian3D(3.1,  0, 0)));
Assert.assertTrue(sphere.contains(new Cartesian3D(2.0, -0.499, 0)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2.0, -0.501, 0)));
Assert.assertTrue(sphere.contains(new Cartesian3D(2.0, 3.0 / 4.0, -1.249)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2.0, 3.0 / 4.0, -1.251)));
Assert.assertEquals(0.0, new Cartesian3D(2.0, 3.0 / 4.0, 0).distance(sphere.getCenter()), 1.0e-10);
List<Cartesian3D> support = Arrays.asList(new Cartesian3D(17, 14,  18),
new Cartesian3D(11, 14,  22),
new Cartesian3D( 2, 22,  17),
new Cartesian3D(22, 11, -10));
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
for (Cartesian3D v : support) {
Assert.assertTrue(sphere.contains (new Cartesian3D(-22.999, 2, 2)));
Assert.assertFalse(sphere.contains(new Cartesian3D(-23.001, 2, 2)));
Assert.assertTrue(sphere.contains (new Cartesian3D( 26.999, 2, 2)));
Assert.assertFalse(sphere.contains(new Cartesian3D( 27.001, 2, 2)));
Assert.assertTrue(sphere.contains (new Cartesian3D(2, -22.999, 2)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2, -23.001, 2)));
Assert.assertTrue(sphere.contains (new Cartesian3D(2,  26.999, 2)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2,  27.001, 2)));
Assert.assertTrue(sphere.contains (new Cartesian3D(2, 2, -22.999)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2, 2, -23.001)));
Assert.assertTrue(sphere.contains (new Cartesian3D(2, 2,  26.999)));
Assert.assertFalse(sphere.contains(new Cartesian3D(2, 2,  27.001)));
Assert.assertEquals(0.0, new Cartesian3D(2.0, 2.0, 2.0).distance(sphere.getCenter()), 1.0e-10);
Cartesian3D refCenter = new Cartesian3D(d, new Cartesian3D(sr.nextVector()));
List<Cartesian3D> support = new ArrayList<>();
support.add(new Cartesian3D(1.0, refCenter, refRadius, new Cartesian3D(sr.nextVector())));
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
final List<Cartesian3D> support =
Arrays.asList(new Cartesian3D(FastMath.scalb(-8039905610797991.0, -50),   //   -7.140870659936730
new Cartesian3D(FastMath.scalb(-8036658568968473.0, -50),   //   -7.137986707455888
new Cartesian3D(FastMath.scalb(-8037820142977230.0, -50),   //   -7.139018392423351
new Cartesian3D(FastMath.scalb(-8038007803611611.0, -50),   //   -7.139185068549035
EnclosingBall<Euclidean3D, Cartesian3D> sphere = new SphereGenerator().ballOnSupport(support);
for (Cartesian3D v : support) {
Assert.assertEquals(0, sc1.getCartesian().distance(new Cartesian3D(2, 0, 0)), 1.0e-10);
Assert.assertEquals(0, sc2.getCartesian().distance(new Cartesian3D(0, 2, 0)), 1.0e-10);
Assert.assertEquals(0, sc3.getCartesian().distance(new Cartesian3D(-2, 0, 0)), 1.0e-10);
Assert.assertEquals(0, sc4.getCartesian().distance(new Cartesian3D(0, -2, 0)), 1.0e-10);
Assert.assertEquals(0, sc5.getCartesian().distance(new Cartesian3D(0, 0, 2)), 1.0e-10);
Assert.assertEquals(0, sc6.getCartesian().distance(new Cartesian3D(0, 0, -2)), 1.0e-10);
SphericalCoordinates sc1 = new SphericalCoordinates(new Cartesian3D(2, 0, 0));
SphericalCoordinates sc2 = new SphericalCoordinates(new Cartesian3D(0, 2, 0));
SphericalCoordinates sc3 = new SphericalCoordinates(new Cartesian3D(-2, 0, 0));
SphericalCoordinates sc4 = new SphericalCoordinates(new Cartesian3D(0, -2, 0));
SphericalCoordinates sc5 = new SphericalCoordinates(new Cartesian3D(0, 0, 2));
SphericalCoordinates sc6 = new SphericalCoordinates(new Cartesian3D(0, 0, -2));
Cartesian3D refCGradient = new Cartesian3D(cvalue.getPartialDerivative(1, 0, 0),
Cartesian3D testCGradient = new Cartesian3D(sc.toCartesianGradient(sGradient));
Cartesian3D p1 = new Cartesian3D(-1, -7, 2);
Cartesian3D p2 = new Cartesian3D(7, -1, 0);
Assert.assertEquals(0.0, new Cartesian3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10);
SubLine wholeLine = new Line(new Cartesian3D(-1, 7, 2), new Cartesian3D(7, 1, 0), 1.0e-10).wholeLine();
SubLine empty = new SubLine(new Line(new Cartesian3D(-1, -7, 2), new Cartesian3D(7, -1, 0), 1.0e-10),
SubLine twoSubs = new SubLine(new Line(new Cartesian3D(-1, -7, 2), new Cartesian3D(7, -1, 0), 1.0e-10),
SubLine empty = new SubLine(new Line(new Cartesian3D(-1, -7, 2), new Cartesian3D(7, -1, -2), 1.0e-10),
Assert.assertEquals(0.0, new Cartesian3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10);
SubLine empty = new SubLine(new Line(new Cartesian3D(-1, -7, 2), new Cartesian3D(7, -1, -2), 1.0e-10),
Assert.assertEquals(0.0, new Cartesian3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(3, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 2, 2), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
Assert.assertEquals(0.0, new Cartesian3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(3, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 1, 1), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(3, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 0.5, 0.5), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(2, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 1, 1), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(2, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 0.5, 0.5), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(1.5, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 0, 0), new Cartesian3D(2, 0.5, 0.5), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian3D(1, 1, 1), new Cartesian3D(1.5, 1, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian3D(2, 3, 0), new Cartesian3D(2, 3, 0.5), 1.0e-10);
Cartesian3D c = new Cartesian3D(1, 1, 1);
Cartesian3D c = new Cartesian3D(1.23, 1.43, 1.63);
Cartesian3D c = new Cartesian3D(1.232323232323, 1.434343434343, 1.633333333333);
Cartesian3D c = new Cartesian3D(-1.232323232323, 1.43, 1.63);
Cartesian3D c = new Cartesian3D(1.23, -1.434343434343, 1.63);
Cartesian3D c = new Cartesian3D(1.23, 1.43, -1.633333333333);
Cartesian3D c = new Cartesian3D(1, 1, 1);
Cartesian3D c = new Cartesian3D(232.22222222222, -342.3333333333, 432.44444444444);
Cartesian3D c = Cartesian3D.NaN;
Cartesian3D c = Cartesian3D.POSITIVE_INFINITY;
Cartesian3D c = Cartesian3D.NEGATIVE_INFINITY;
Cartesian3D expected = new Cartesian3D(1, 1, 1);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(1, 1, 1);
Cartesian3D expected = new Cartesian3D(1.23, 1.43, 1.63);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(1.2323, 1.4343, 1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(-1.2323, 1.4343, 1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(1.2323, -1.4343, 1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(1.2323, 1.4343, -1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(-1.2323, -1.4343, -1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(0.0, -1.4343, 1.6333);
Cartesian3D actual = vector3DFormat.parse(source);
Cartesian3D expected = new Cartesian3D(1.2323, 1.4343, 1.6333);
Cartesian3D actual = vector3DFormatSquare.parse(source);
Cartesian3D actual = vector3DFormat.parse(source);
Assert.assertEquals(Cartesian3D.NaN, actual);
Cartesian3D actual = vector3DFormat.parse(source);
Assert.assertEquals(Cartesian3D.POSITIVE_INFINITY, actual);
Cartesian3D actual = vector3DFormat.parse(source);
Assert.assertEquals(Cartesian3D.NEGATIVE_INFINITY, actual);
checkVector(new Cartesian3D(2, new Cartesian3D(FastMath.PI / 3, -FastMath.PI / 4)),
checkVector(new Cartesian3D(2, Cartesian3D.PLUS_I,
-3, Cartesian3D.MINUS_K),
checkVector(new Cartesian3D(2, Cartesian3D.PLUS_I,
5, Cartesian3D.PLUS_J,
-3, Cartesian3D.MINUS_K),
checkVector(new Cartesian3D(2, Cartesian3D.PLUS_I,
5, Cartesian3D.PLUS_J,
5, Cartesian3D.MINUS_J,
-3, Cartesian3D.MINUS_K),
checkVector(new Cartesian3D(new double[] { 2,  5,  -3 }),
Space space = new Cartesian3D(1, 2, 2).getSpace();
Assert.assertEquals(0, new Cartesian3D(1, 2, 2).getZero().getNorm(), 1.0e-15);
Cartesian3D u1 = new Cartesian3D(1, 2, 3);
Cartesian3D u2 = new Cartesian3D(1, 2, 3);
Assert.assertFalse(u1.equals(new Cartesian3D(1, 2, 3 + 10 * Precision.EPSILON)));
Assert.assertFalse(u1.equals(new Cartesian3D(1, 2 + 10 * Precision.EPSILON, 3)));
Assert.assertFalse(u1.equals(new Cartesian3D(1 + 10 * Precision.EPSILON, 2, 3)));
Assert.assertTrue(new Cartesian3D(0, Double.NaN, 0).equals(new Cartesian3D(0, 0, Double.NaN)));
Assert.assertEquals(new Cartesian3D(0, Double.NaN, 0).hashCode(), new Cartesian3D(0, 0, Double.NaN).hashCode());
Cartesian3D u = new Cartesian3D(1, 2, 3);
Cartesian3D v = new Cartesian3D(1, 2, 3 + 10 * Precision.EPSILON);
Assert.assertTrue(new Cartesian3D(1, 1, Double.NEGATIVE_INFINITY).isInfinite());
Assert.assertTrue(new Cartesian3D(1, Double.NEGATIVE_INFINITY, 1).isInfinite());
Assert.assertTrue(new Cartesian3D(Double.NEGATIVE_INFINITY, 1, 1).isInfinite());
Assert.assertFalse(new Cartesian3D(1, 1, 2).isInfinite());
Assert.assertFalse(new Cartesian3D(1, Double.NaN, Double.NEGATIVE_INFINITY).isInfinite());
Assert.assertTrue(new Cartesian3D(1, 1, Double.NaN).isNaN());
Assert.assertTrue(new Cartesian3D(1, Double.NaN, 1).isNaN());
Assert.assertTrue(new Cartesian3D(Double.NaN, 1, 1).isNaN());
Assert.assertFalse(new Cartesian3D(1, 1, 2).isNaN());
Assert.assertFalse(new Cartesian3D(1, 1, Double.NEGATIVE_INFINITY).isNaN());
Assert.assertEquals("{3; 2; 1}", new Cartesian3D(3, 2, 1).toString());
Assert.assertEquals("{3.000; 2.000; 1.000}", new Cartesian3D(3, 2, 1).toString(format));
new Cartesian3D(new double[] { 2,  5 });
Cartesian3D v = new Cartesian3D(1, 2, 3);
Assert.assertEquals(0.0, Cartesian3D.ZERO.getNorm1(), 0);
Assert.assertEquals(6.0, new Cartesian3D(1, -2, 3).getNorm1(), 0);
Assert.assertEquals(0.0, Cartesian3D.ZERO.getNorm(), 0);
Assert.assertEquals(FastMath.sqrt(14), new Cartesian3D(1, 2, 3).getNorm(), 1.0e-12);
Assert.assertEquals(0.0, new Cartesian3D(0, 0, 0).getNormSq(), 0);
Assert.assertEquals(14, new Cartesian3D(1, 2, 3).getNormSq(), 1.0e-12);
Assert.assertEquals(0.0, Cartesian3D.ZERO.getNormInf(), 0);
Assert.assertEquals(3.0, new Cartesian3D(1, -2, 3).getNormInf(), 0);
Cartesian3D v1 = new Cartesian3D(1, -2, 3);
Cartesian3D v2 = new Cartesian3D(-4, 2, 0);
Assert.assertEquals(0.0, Cartesian3D.distance1(Cartesian3D.MINUS_I, Cartesian3D.MINUS_I), 0);
Assert.assertEquals(12.0, Cartesian3D.distance1(v1, v2), 1.0e-12);
Assert.assertEquals(v1.subtract(v2).getNorm1(), Cartesian3D.distance1(v1, v2), 1.0e-12);
Cartesian3D v1 = new Cartesian3D(1, -2, 3);
Cartesian3D v2 = new Cartesian3D(-4, 2, 0);
Assert.assertEquals(0.0, Cartesian3D.distance(Cartesian3D.MINUS_I, Cartesian3D.MINUS_I), 0);
Assert.assertEquals(FastMath.sqrt(50), Cartesian3D.distance(v1, v2), 1.0e-12);
Assert.assertEquals(v1.subtract(v2).getNorm(), Cartesian3D.distance(v1, v2), 1.0e-12);
Cartesian3D v1 = new Cartesian3D(1, -2, 3);
Cartesian3D v2 = new Cartesian3D(-4, 2, 0);
Assert.assertEquals(0.0, Cartesian3D.distanceSq(Cartesian3D.MINUS_I, Cartesian3D.MINUS_I), 0);
Assert.assertEquals(50.0, Cartesian3D.distanceSq(v1, v2), 1.0e-12);
Assert.assertEquals(Cartesian3D.distance(v1, v2) * Cartesian3D.distance(v1, v2),
Cartesian3D.distanceSq(v1, v2), 1.0e-12);
Cartesian3D v1 = new Cartesian3D(1, -2, 3);
Cartesian3D v2 = new Cartesian3D(-4, 2, 0);
Assert.assertEquals(0.0, Cartesian3D.distanceInf(Cartesian3D.MINUS_I, Cartesian3D.MINUS_I), 0);
Assert.assertEquals(5.0, Cartesian3D.distanceInf(v1, v2), 1.0e-12);
Assert.assertEquals(v1.subtract(v2).getNormInf(), Cartesian3D.distanceInf(v1, v2), 1.0e-12);
Cartesian3D v1 = new Cartesian3D(1, 2, 3);
Cartesian3D v2 = new Cartesian3D(-3, -2, -1);
Cartesian3D v1 = new Cartesian3D(1, 2, 3);
Cartesian3D v2 = new Cartesian3D(-3, -2, -1);
Cartesian3D v = new Cartesian3D(1, 2, 3);
Cartesian3D v1 = new Cartesian3D(2, 1, -4);
Cartesian3D v2 = new Cartesian3D(3, 1, -1);
Assert.assertTrue(FastMath.abs(Cartesian3D.dotProduct(v1, v2) - 11) < 1.0e-12);
Cartesian3D v3 = Cartesian3D.crossProduct(v1, v2);
Assert.assertTrue(FastMath.abs(Cartesian3D.dotProduct(v1, v3)) < 1.0e-12);
Assert.assertTrue(FastMath.abs(Cartesian3D.dotProduct(v2, v3)) < 1.0e-12);
Cartesian3D v1 = new Cartesian3D(9070467121.0, 4535233560.0, 1);
Cartesian3D v2 = new Cartesian3D(9070467123.0, 4535233561.0, 1);
checkVector(Cartesian3D.crossProduct(v1, v2), -1, 2, 1);
Cartesian3D big1   = new Cartesian3D(scale, v1);
Cartesian3D small2 = new Cartesian3D(1 / scale, v2);
checkVector(Cartesian3D.crossProduct(big1, small2), -1, 2, 1);
Assert.assertEquals(0,           Cartesian3D.PLUS_I.getAlpha(), 1.0e-10);
Assert.assertEquals(0,           Cartesian3D.PLUS_I.getDelta(), 1.0e-10);
Assert.assertEquals(FastMath.PI / 2, Cartesian3D.PLUS_J.getAlpha(), 1.0e-10);
Assert.assertEquals(0,           Cartesian3D.PLUS_J.getDelta(), 1.0e-10);
Assert.assertEquals(0,           Cartesian3D.PLUS_K.getAlpha(), 1.0e-10);
Assert.assertEquals(FastMath.PI / 2, Cartesian3D.PLUS_K.getDelta(), 1.0e-10);
Cartesian3D u = new Cartesian3D(-1, 1, -1);
Cartesian3D v1 = new Cartesian3D(2, -1, 4);
Cartesian3D  k = v1.normalize();
Cartesian3D  i = k.orthogonal();
Cartesian3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));
Assert.assertTrue(FastMath.abs(Cartesian3D.angle(v1, v2) - 1.2) < 1.0e-12);
Assert.assertEquals(1.0, new Cartesian3D(5, -4, 2).normalize().getNorm(), 1.0e-12);
Cartesian3D.ZERO.normalize();
checkVector(new Cartesian3D(0.1, 2.5, 1.3).negate(), -0.1, -2.5, -1.3);
Cartesian3D v1 = new Cartesian3D(0.1, 2.5, 1.3);
Assert.assertEquals(0.0, Cartesian3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);
Cartesian3D v2 = new Cartesian3D(2.3, -0.003, 7.6);
Assert.assertEquals(0.0, Cartesian3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);
Cartesian3D v3 = new Cartesian3D(-1.7, 1.4, 0.2);
Assert.assertEquals(0.0, Cartesian3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);
Cartesian3D v4 = new Cartesian3D(4.2, 0.1, -1.8);
Assert.assertEquals(0.0, Cartesian3D.dotProduct(v4, v4.orthogonal()), 1.0e-12);
new Cartesian3D(0, 0, 0).orthogonal();
Cartesian3D.angle(new Cartesian3D(1, 2, 3), new Cartesian3D(4, 5, 6)),
Cartesian3D.angle(new Cartesian3D(1, 2, 3), new Cartesian3D(2, 4, 6.000001)),
Cartesian3D.angle(new Cartesian3D(1, 2, 3), new Cartesian3D(-2, -4, -6.000001)),
Cartesian3D.angle(Cartesian3D.ZERO, Cartesian3D.PLUS_I);
Cartesian3D u1 = new Cartesian3D(-1321008684645961.0 /  268435456.0,
Cartesian3D u2 = new Cartesian3D(-5712344449280879.0 /    2097152.0,
double sAccurate = new Cartesian3D(ux, uy, uz).dotProduct(new Cartesian3D(vx, vy, vz));
final Cartesian3D u1 = new Cartesian3D(-1321008684645961.0 /   268435456.0,
final Cartesian3D u2 = new Cartesian3D( 1796571811118507.0 /  2147483648.0,
final Cartesian3D u3 = new Cartesian3D(12753243807587107.0 / 18446744073709551616.0,
Cartesian3D cNaive = new Cartesian3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(),
Cartesian3D cAccurate = u1.crossProduct(u2);
Cartesian3D cNaive = new Cartesian3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
Cartesian3D cAccurate = new Cartesian3D(ux, uy, uz).crossProduct(new Cartesian3D(vx, vy, vz));
private void checkVector(Cartesian3D v, double x, double y, double z) {
List<Cartesian2D> support = Arrays.asList(new Cartesian2D[0]);
EnclosingBall<Euclidean2D, Cartesian2D> disk = new DiskGenerator().ballOnSupport(support);
List<Cartesian2D> support = Arrays.asList(new Cartesian2D(1, 2));
EnclosingBall<Euclidean2D, Cartesian2D> disk = new DiskGenerator().ballOnSupport(support);
Assert.assertFalse(disk.contains(new Cartesian2D(support.get(0).getX() + 0.1,
Assert.assertTrue(disk.contains(new Cartesian2D(support.get(0).getX() + 0.1,
List<Cartesian2D> support = Arrays.asList(new Cartesian2D(1, 0),
new Cartesian2D(3, 0));
EnclosingBall<Euclidean2D, Cartesian2D> disk = new DiskGenerator().ballOnSupport(support);
for (Cartesian2D v : support) {
Assert.assertTrue(disk.contains(new Cartesian2D(2, 0.9)));
Assert.assertFalse(disk.contains(Cartesian2D.ZERO));
Assert.assertEquals(0.0, new Cartesian2D(2, 0).distance(disk.getCenter()), 1.0e-10);
List<Cartesian2D> support = Arrays.asList(new Cartesian2D(1, 0),
new Cartesian2D(3, 0),
new Cartesian2D(2, 2));
EnclosingBall<Euclidean2D, Cartesian2D> disk = new DiskGenerator().ballOnSupport(support);
for (Cartesian2D v : support) {
Assert.assertTrue(disk.contains(new Cartesian2D(2, 0.9)));
Assert.assertFalse(disk.contains(new Cartesian2D(0.9,  0)));
Assert.assertFalse(disk.contains(new Cartesian2D(3.1,  0)));
Assert.assertTrue(disk.contains(new Cartesian2D(2.0, -0.499)));
Assert.assertFalse(disk.contains(new Cartesian2D(2.0, -0.501)));
Assert.assertEquals(0.0, new Cartesian2D(2.0, 3.0 / 4.0).distance(disk.getCenter()), 1.0e-10);
Cartesian2D refCenter = new Cartesian2D(d, new Cartesian2D(sr.nextVector()));
List<Cartesian2D> support = new ArrayList<>();
support.add(new Cartesian2D(1.0, refCenter, refRadius, new Cartesian2D(sr.nextVector())));
EnclosingBall<Euclidean2D, Cartesian2D> disk = new DiskGenerator().ballOnSupport(support);
Line l = new Line(new Cartesian2D(0, 1), new Cartesian2D(1, 2), 1.0e-10);
Assert.assertTrue(l.contains(new Cartesian2D(0, 1)));
Assert.assertTrue(l.contains(new Cartesian2D(1, 2)));
Assert.assertTrue(l.contains(new Cartesian2D(7, 8)));
Assert.assertTrue(! l.contains(new Cartesian2D(8, 7)));
Line l = new Line(new Cartesian2D(2, 1), new Cartesian2D(-2, -2), 1.0e-10);
(l.toSubSpace(new Cartesian2D(-3,  4))).getX(),
(l.toSubSpace(new Cartesian2D( 3, -4))).getX(),
(l.toSubSpace(new Cartesian2D( 7, -1))).getX(),
Assert.assertEquals(5.0,
(l.toSubSpace(new Cartesian2D(-1, -7))).getX(),
Line l = new Line(new Cartesian2D(2, 1), new Cartesian2D(-2, -2), 1.0e-10);
Assert.assertEquals(-5.0, l.getOffset(new Cartesian2D(5, -3)), 1.0e-10);
Assert.assertEquals(+5.0, l.getOffset(new Cartesian2D(-5, 2)), 1.0e-10);
Line l = new Line(new Cartesian2D(2, 1), new Cartesian2D(-2, -2), 1.0e-10);
Assert.assertEquals(+5.0, l.distance(new Cartesian2D(5, -3)), 1.0e-10);
Assert.assertEquals(+5.0, l.distance(new Cartesian2D(-5, 2)), 1.0e-10);
Line l = new Line(new Cartesian2D(2, 1), new Cartesian2D(-2, -2), 1.0e-10);
Point<Euclidean1D> pA = new Cartesian1D(a);
point = l.getPointAt((Cartesian1D) pA, o);
Line l1 = new Line(new Cartesian2D(0, 1), new Cartesian2D(1, 2), 1.0e-10);
Line l2 = new Line(new Cartesian2D(1, 2), new Cartesian2D(0, 1), 1.0e-10);
Line l1 = new Line(new Cartesian2D(0, 1), new Cartesian2D(1, 2), 1.0e-10);
Line l2 = new Line(new Cartesian2D(2, 2), new Cartesian2D(3, 3), 1.0e-10);
Line l3 = new Line(new Cartesian2D(1, 0), new Cartesian2D(0.5, -0.5), 1.0e-10);
Line l4 = new Line(new Cartesian2D(1, 0), new Cartesian2D(0.5, -0.51), 1.0e-10);
Line l1 = new Line(new Cartesian2D(1.0 ,1.0), new Cartesian2D(4.0 ,1.0), 1.0e-10);
Line l2 = new Line(new Cartesian2D(0.0, 0.0), new Cartesian2D(1.0, 1.0), 1.0e-10);
Line    l1 = new Line(new Cartesian2D( 0, 1), new Cartesian2D(1, 2), 1.0e-10);
Line    l2 = new Line(new Cartesian2D(-1, 2), new Cartesian2D(2, 1), 1.0e-10);
Cartesian2D p  = l1.intersection(l2);
Cartesian2D oneOne = new Cartesian2D(1.0, 1.0);
Cartesian2D oneNegativeOne = new Cartesian2D(1.0, -1.0);
Cartesian2D negativeOneNegativeOne = new Cartesian2D(-1.0, -1.0);
Cartesian2D negativeOneOne = new Cartesian2D(-1.0, 1.0);
Cartesian2D origin = new Cartesian2D(0, 0);
Cartesian2D [] vertices = new Cartesian2D[]{
Cartesian2D[] loop = (Cartesian2D []) loopField.get(surrounded.get(0));
Set<Cartesian2D> vertexSet = new HashSet<>(Arrays.asList(loop));
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(36.0, 22.0),
new Cartesian2D(39.0, 32.0),
new Cartesian2D(19.0, 32.0),
new Cartesian2D( 6.0, 16.0),
new Cartesian2D(31.0, 10.0),
new Cartesian2D(42.0, 16.0),
new Cartesian2D(34.0, 20.0),
new Cartesian2D(29.0, 19.0),
new Cartesian2D(23.0, 22.0),
new Cartesian2D(33.0, 25.0)
Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Cartesian2D(50.0, 30.0)));
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(30.0, 15.0),
new Cartesian2D(15.0, 20.0),
new Cartesian2D(24.0, 25.0),
new Cartesian2D(35.0, 30.0),
new Cartesian2D(19.0, 17.0)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(50.0, 30.0),
new Cartesian2D(30.0, 35.0),
new Cartesian2D(10.0, 25.0),
new Cartesian2D(10.0, 10.0),
new Cartesian2D(40.0, 10.0),
new Cartesian2D(50.0, 15.0),
new Cartesian2D(30.0, 22.0)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(30.0, 32.0),
new Cartesian2D(34.0, 20.0)
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0, 0.0),
new Cartesian2D( 0.0, 2.0),
new Cartesian2D(-0.1, 2.0),
new Cartesian2D(-0.1, 1.0),
new Cartesian2D(-0.3, 1.0),
new Cartesian2D(-0.3, 1.5),
new Cartesian2D(-1.3, 1.5),
new Cartesian2D(-1.3, 2.0),
new Cartesian2D(-1.8, 2.0),
new Cartesian2D(-1.8 - 1.0 / FastMath.sqrt(2.0),
empty.projectToBoundary(new Cartesian2D(x, y)).getOffset(),
empty.projectToBoundary(new Cartesian2D(x, y)).getOffset(),
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(0.0, 0.0),
new Cartesian2D(3.0, 0.0),
new Cartesian2D(3.0, 3.0),
new Cartesian2D(0.0, 3.0)
}, new Cartesian2D[] {
new Cartesian2D(1.0, 2.0),
new Cartesian2D(2.0, 2.0),
new Cartesian2D(2.0, 1.0),
new Cartesian2D(1.0, 1.0)
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(0.5, 0.5),
new Cartesian2D(1.5, 0.5),
new Cartesian2D(2.5, 0.5),
new Cartesian2D(0.5, 1.5),
new Cartesian2D(2.5, 1.5),
new Cartesian2D(0.5, 2.5),
new Cartesian2D(1.5, 2.5),
new Cartesian2D(2.5, 2.5),
new Cartesian2D(0.5, 1.0)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(1.5, 1.5),
new Cartesian2D(3.5, 1.0),
new Cartesian2D(4.0, 1.5),
new Cartesian2D(6.0, 6.0)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(1.5, 0.0),
new Cartesian2D(1.5, 1.0),
new Cartesian2D(1.5, 2.0),
new Cartesian2D(1.5, 3.0),
new Cartesian2D(3.0, 3.0)
Cartesian2D v = new Cartesian2D(x, x + 0.5);
Cartesian2D p = (Cartesian2D) projection.getProjected();
Assert.assertEquals(+v.distance(Cartesian2D.ZERO), projection.getOffset(), 1.0e-10);
Assert.assertEquals(+v.distance(new Cartesian2D(3, 3)), projection.getOffset(), 1.0e-10);
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(0.0, 1.0),
new Cartesian2D(2.0, 1.0),
new Cartesian2D(1.0, 2.0)
}, new Cartesian2D[] {
new Cartesian2D(4.0, 0.0),
new Cartesian2D(5.0, 1.0),
new Cartesian2D(3.0, 1.0)
Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Cartesian2D(1.0, 1.5)));
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.5),
new Cartesian2D(4.5, 0.8)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(1.0, 0.0),
new Cartesian2D(3.5, 1.2),
new Cartesian2D(2.5, 1.0),
new Cartesian2D(3.0, 4.0)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(3.5, 0.5),
new Cartesian2D(0.0, 1.0)
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(1.0, 0.0),
new Cartesian2D(2.0, 1.0),
new Cartesian2D(3.0, 1.0),
new Cartesian2D(2.0, 2.0),
new Cartesian2D(1.0, 1.0),
new Cartesian2D(0.0, 1.0)
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 1.0,  0.0),
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 0.0,  1.0),
new Cartesian2D( 0.0,  0.0),
new Cartesian2D(-1.0,  0.0),
new Cartesian2D(-1.0, -1.0),
new Cartesian2D( 0.0, -1.0)
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0),
new Cartesian2D( 1.0,  2.0),
new Cartesian2D( 0.0,  2.0)
Line l1 = new Line(new Cartesian2D(-1.5, 0.0), FastMath.PI / 4, 1.0e-10);
Cartesian2D p10Lower = l1.toSpace(new Cartesian1D(v10.getInf()));
Cartesian2D p10Upper = l1.toSpace(new Cartesian1D(v10.getSup()));
Cartesian2D p11Lower = l1.toSpace(new Cartesian1D(v11.getInf()));
Cartesian2D p11Upper = l1.toSpace(new Cartesian1D(v11.getSup()));
Line l2 = new Line(new Cartesian2D(-1.0, 2.0), 0, 1.0e-10);
Cartesian2D p20Lower = l2.toSpace(new Cartesian1D(v20.getInf()));
Cartesian2D p20Upper = l2.toSpace(new Cartesian1D(v20.getSup()));
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(0.0, 0.0),
new Cartesian2D(4.0, 0.0),
new Cartesian2D(1.4, 1.5),
new Cartesian2D(0.0, 3.5)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(1.4,  0.2),
new Cartesian2D(2.8, -1.2),
new Cartesian2D(2.5,  0.6)
checkVertices(set.getVertices(), new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(0.0,  0.0),
new Cartesian2D(1.6,  0.0),
new Cartesian2D(2.8, -1.2),
new Cartesian2D(2.6,  0.0),
new Cartesian2D(4.0,  0.0),
new Cartesian2D(1.4,  1.5),
new Cartesian2D(0.0,  3.5)
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 0.0,  2.0)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0)
checkVertices(set.getVertices(), new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0),
new Cartesian2D( 1.0,  2.0),
new Cartesian2D( 0.0,  2.0)
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(0.5, 0.5),
new Cartesian2D(2.0, 2.0),
new Cartesian2D(2.5, 2.5),
new Cartesian2D(0.5, 1.5),
new Cartesian2D(1.5, 1.5),
new Cartesian2D(1.5, 0.5),
new Cartesian2D(1.5, 2.5),
new Cartesian2D(2.5, 1.5),
new Cartesian2D(2.5, 2.5)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(-0.5, 0.5),
new Cartesian2D( 0.5, 2.5),
new Cartesian2D( 2.5, 0.5),
new Cartesian2D( 3.5, 2.5)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(0.0, 0.0),
new Cartesian2D(0.5, 2.0),
new Cartesian2D(2.0, 0.5),
new Cartesian2D(2.5, 1.0),
new Cartesian2D(3.0, 2.5)
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 0.0,  2.0)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0)
checkVertices(set.getVertices(), new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 2.0,  1.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 1.0,  2.0)
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(1.5, 1.5)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(0.5, 1.5),
new Cartesian2D(2.5, 1.5),
new Cartesian2D(1.5, 0.5),
new Cartesian2D(0.5, 0.5)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(2.0, 2.0),
new Cartesian2D(1.0, 1.5),
new Cartesian2D(1.5, 2.0)
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 0.0,  2.0)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0)
checkVertices(set.getVertices(), new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0),
new Cartesian2D( 1.0,  2.0),
new Cartesian2D( 0.0,  2.0)
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 1.0,  2.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 2.0,  1.0)
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(0.5, 0.5),
new Cartesian2D(2.5, 2.5),
new Cartesian2D(0.5, 1.5),
new Cartesian2D(1.5, 0.5),
new Cartesian2D(1.5, 2.5),
new Cartesian2D(2.5, 1.5),
new Cartesian2D(2.5, 2.5)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(-0.5, 0.5),
new Cartesian2D( 0.5, 2.5),
new Cartesian2D( 2.5, 0.5),
new Cartesian2D( 1.5, 1.5),
new Cartesian2D( 3.5, 2.5)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(2.0, 2.0),
new Cartesian2D(1.5, 1.0),
new Cartesian2D(2.0, 1.5),
new Cartesian2D(0.0, 0.0),
new Cartesian2D(0.5, 2.0),
new Cartesian2D(2.0, 0.5),
new Cartesian2D(2.5, 1.0),
new Cartesian2D(3.0, 2.5)
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  2.0),
new Cartesian2D( 0.0,  2.0)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 3.0,  1.0),
new Cartesian2D( 3.0,  3.0),
new Cartesian2D( 1.0,  3.0)
checkVertices(set.getVertices(), new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.0,  0.0),
new Cartesian2D( 2.0,  0.0),
new Cartesian2D( 2.0,  1.0),
new Cartesian2D( 1.0,  1.0),
new Cartesian2D( 1.0,  2.0),
new Cartesian2D( 0.0,  2.0)
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(0.5, 0.5),
new Cartesian2D(0.5, 1.5),
new Cartesian2D(1.5, 0.5)
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D( 2.5, 2.5),
new Cartesian2D(-0.5, 0.5),
new Cartesian2D( 0.5, 2.5),
new Cartesian2D( 2.5, 0.5),
new Cartesian2D( 1.5, 1.5),
new Cartesian2D( 3.5, 2.5),
new Cartesian2D( 1.5, 2.5),
new Cartesian2D( 2.5, 1.5),
new Cartesian2D( 2.0, 1.5),
new Cartesian2D( 2.0, 2.0),
new Cartesian2D( 2.5, 1.0),
new Cartesian2D( 2.5, 2.5),
new Cartesian2D( 3.0, 2.5)
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(1.0, 1.0),
new Cartesian2D(1.5, 1.0),
new Cartesian2D(0.0, 0.0),
new Cartesian2D(0.5, 2.0),
new Cartesian2D(2.0, 0.5)
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.5, 3.5),
new Cartesian2D( 0.5, 4.5),
new Cartesian2D(-0.5, 4.5),
new Cartesian2D(-0.5, 3.5)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 1.0, 2.0),
new Cartesian2D( 1.0, 8.0),
new Cartesian2D(-1.0, 8.0),
new Cartesian2D(-1.0, 2.0)
new Line(new Cartesian2D(   0.0, 1.0),  5 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 1.0),  7 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 1.0),  9 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 0.0), 11 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(   0.0, 0.0), 13 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(   0.0, 1.0),  3 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane()
new Line(new Cartesian2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane();
slice.checkPoint(new Cartesian2D(0.1, 0.5)));
Cartesian2D[][] vertices1 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.00, 0.1 * h),
new Cartesian2D( 0.05, 0.1 * h),
new Cartesian2D( 0.10, 0.2 * h),
new Cartesian2D( 0.05, 0.3 * h),
new Cartesian2D(-0.05, 0.3 * h),
new Cartesian2D(-0.10, 0.2 * h),
new Cartesian2D(-0.05, 0.1 * h)
Cartesian2D[][] vertices2 = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D( 0.00, 0.0 * h),
new Cartesian2D( 0.10, 0.0 * h),
new Cartesian2D( 0.20, 0.2 * h),
new Cartesian2D( 0.10, 0.4 * h),
new Cartesian2D(-0.10, 0.4 * h),
new Cartesian2D(-0.20, 0.2 * h),
new Cartesian2D(-0.10, 0.0 * h)
new BSPTree<>(buildSegment(new Cartesian2D(0.85, -0.05),
new Cartesian2D(0.90, -0.10)),
new BSPTree<>(buildSegment(new Cartesian2D(0.85, -0.10),
new Cartesian2D(0.90, -0.10)),
new BSPTree<>(buildSegment(new Cartesian2D(0.90, -0.05),
new Cartesian2D(0.85, -0.05)),
new BSPTree<>(buildSegment(new Cartesian2D(0.82, -0.05),
new Cartesian2D(0.82, -0.08)),
new BSPTree<>(buildHalfLine(new Cartesian2D(0.85, -0.05),
new Cartesian2D(0.80, -0.05),
new BSPTree<>(buildSegment(new Cartesian2D(0.82, -0.08),
new Cartesian2D(0.82, -0.18)),
new BSPTree<>(buildHalfLine(new Cartesian2D(0.82, -0.18),
new Cartesian2D(0.85, -0.15),
new BSPTree<>(buildHalfLine(new Cartesian2D(0.85, -0.05),
new Cartesian2D(0.82, -0.08),
new BSPTree<>(buildLine(new Cartesian2D(0.85, -0.25),
new Cartesian2D(0.85,  0.05)),
new BSPTree<>(buildLine(new Cartesian2D(0.90,  0.05),
new Cartesian2D(0.90, -0.50)),
new BSPTree<>(buildSegment(new Cartesian2D(0.92, -0.12),
new Cartesian2D(0.92, -0.08)),
new BSPTree<>(buildHalfLine(new Cartesian2D(0.92, -0.08),
new Cartesian2D(0.90, -0.10),
new BSPTree<>(buildSegment(new Cartesian2D(0.92, -0.18),
new Cartesian2D(0.92, -0.12)),
new BSPTree<>(buildSegment(new Cartesian2D(0.85, -0.15),
new Cartesian2D(0.90, -0.20)),
new BSPTree<>(buildSegment(new Cartesian2D(0.95, -0.15),
new Cartesian2D(0.85, -0.05)),
new BSPTree<>(buildHalfLine(new Cartesian2D(0.85, -0.05),
new Cartesian2D(0.85, -0.25),
new BSPTree<>(buildLine(new Cartesian2D(0.0, -1.10),
new Cartesian2D(1.0, -0.10)),
checkPoints(Region.Location.INSIDE, c, new Cartesian2D[] {
new Cartesian2D(0.83, -0.06),
new Cartesian2D(0.83, -0.15),
new Cartesian2D(0.88, -0.15),
new Cartesian2D(0.88, -0.09),
new Cartesian2D(0.88, -0.07),
new Cartesian2D(0.91, -0.18),
new Cartesian2D(0.91, -0.10)
checkPoints(Region.Location.OUTSIDE, c, new Cartesian2D[] {
new Cartesian2D(0.80, -0.10),
new Cartesian2D(0.83, -0.50),
new Cartesian2D(0.83, -0.20),
new Cartesian2D(0.83, -0.02),
new Cartesian2D(0.87, -0.50),
new Cartesian2D(0.87, -0.20),
new Cartesian2D(0.87, -0.02),
new Cartesian2D(0.91, -0.20),
new Cartesian2D(0.91, -0.08),
new Cartesian2D(0.93, -0.15)
new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(0.85, -0.15),
new Cartesian2D(0.90, -0.20),
new Cartesian2D(0.92, -0.18),
new Cartesian2D(0.92, -0.08),
new Cartesian2D(0.90, -0.10),
new Cartesian2D(0.90, -0.05),
new Cartesian2D(0.82, -0.05),
new Cartesian2D(0.82, -0.18),
new Line(new Cartesian2D(0.0, 0.625000007541172),
new Cartesian2D(1.0, 0.625000007541172), 1.0e-10),
new Line(new Cartesian2D(-0.19204433621902645, 0.0),
new Cartesian2D(-0.19204433621902645, 1.0), 1.0e-10),
new Line(new Cartesian2D(-0.40303524786887,  0.4248364535319128),
new Cartesian2D(-1.12851149797877, -0.2634107480798909), 1.0e-10),
new Line(new Cartesian2D(0.0, 2.0),
new Cartesian2D(1.0, 2.0), 1.0e-10)
new Cartesian2D(-6, -4), new Cartesian2D(-8, -8), new Cartesian2D(  8, -8),
new Cartesian2D( 6, -4), new Cartesian2D(10,  4), new Cartesian2D(-10,  4));
Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Cartesian2D(0, 6)));
Cartesian2D[] vertices1 = new Cartesian2D[] {
new Cartesian2D( 90.13595870833188,  38.33604606376991),
new Cartesian2D( 90.14047850603913,  38.34600084496253),
new Cartesian2D( 90.11045289492762,  38.36801537312368),
new Cartesian2D( 90.10871471476526,  38.36878044144294),
new Cartesian2D( 90.10424901707671,  38.374300101757),
new Cartesian2D( 90.0979455456843,   38.373578376172475),
new Cartesian2D( 90.09081227075944,  38.37526295920463),
new Cartesian2D( 90.09081378927135,  38.375193883266434)
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.12,  38.32)));
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.135, 38.355)));
Cartesian2D[] vertices1 = new Cartesian2D[] {
new Cartesian2D( 90.08714908223715,  38.370299337260235),
new Cartesian2D( 90.08709517675004,  38.3702895991413),
new Cartesian2D( 90.08401538704919,  38.368849330127944),
new Cartesian2D( 90.08258210430711,  38.367634558585564),
new Cartesian2D( 90.08251455106665,  38.36763409247078),
new Cartesian2D( 90.08106599752608,  38.36761621664249),
new Cartesian2D( 90.08249585300035,  38.36753627557965),
new Cartesian2D( 90.09075743352184,  38.35914647644972),
new Cartesian2D( 90.09099945896571,  38.35896264724079),
new Cartesian2D( 90.09269383800086,  38.34595756121246),
new Cartesian2D( 90.09638631543191,  38.3457988093121),
new Cartesian2D( 90.09666417351019,  38.34523360999418),
new Cartesian2D( 90.1297082145872,  38.337670454923625),
new Cartesian2D( 90.12971687748956,  38.337669827794684),
new Cartesian2D( 90.1240820219179,  38.34328502001131),
new Cartesian2D( 90.13084259656404,  38.34017811765017),
new Cartesian2D( 90.13378567942857,  38.33860579180606),
new Cartesian2D( 90.13519557833206,  38.33621054663689),
new Cartesian2D( 90.13545616732307,  38.33614965452864),
new Cartesian2D( 90.13553111202748,  38.33613962818305),
new Cartesian2D( 90.1356903436448,  38.33610227127048),
new Cartesian2D( 90.13576283227428,  38.33609255422783),
new Cartesian2D( 90.13595870833188,  38.33604606376991),
new Cartesian2D( 90.1361556630693,  38.3360024198866),
new Cartesian2D( 90.13622408795709,  38.335987048115726),
new Cartesian2D( 90.13696189099994,  38.33581914328681),
new Cartesian2D( 90.13746655304897,  38.33616706665265),
new Cartesian2D( 90.13845973716064,  38.33650776167099),
new Cartesian2D( 90.13950901827667,  38.3368469456463),
new Cartesian2D( 90.14393814424852,  38.337591835857495),
new Cartesian2D( 90.14483839716831,  38.337076122362475),
new Cartesian2D( 90.14565474433601,  38.33769000964429),
new Cartesian2D( 90.14569421179482,  38.3377117256905),
new Cartesian2D( 90.14577067124333,  38.33770883625908),
new Cartesian2D( 90.14600350631684,  38.337714326520995),
new Cartesian2D( 90.14600355139731,  38.33771435193319),
new Cartesian2D( 90.14600369112401,  38.33771443882085),
new Cartesian2D( 90.14600382486884,  38.33771453466096),
new Cartesian2D( 90.14600395205912,  38.33771463904344),
new Cartesian2D( 90.14600407214999,  38.337714751520764),
new Cartesian2D( 90.14600418462749,  38.337714871611695),
new Cartesian2D( 90.14600422249327,  38.337714915811034),
new Cartesian2D( 90.14867838361471,  38.34113888210675),
new Cartesian2D( 90.14923750157374,  38.341582537502575),
new Cartesian2D( 90.14877083250991,  38.34160685841391),
new Cartesian2D( 90.14816667319519,  38.34244232585684),
new Cartesian2D( 90.14797696744586,  38.34248455284745),
new Cartesian2D( 90.14484318014337,  38.34385573215269),
new Cartesian2D( 90.14477919958296,  38.3453797747614),
new Cartesian2D( 90.14202393306448,  38.34464324839456),
new Cartesian2D( 90.14198920640195,  38.344651155237216),
new Cartesian2D( 90.14155207025175,  38.34486424263724),
new Cartesian2D( 90.1415196143314,  38.344871730519),
new Cartesian2D( 90.14128611910814,  38.34500196593859),
new Cartesian2D( 90.14047850603913,  38.34600084496253),
new Cartesian2D( 90.14045907000337,  38.34601860032171),
new Cartesian2D( 90.14039496493928,  38.346223030432384),
new Cartesian2D( 90.14037626063737,  38.346240203360026),
new Cartesian2D( 90.14030005823724,  38.34646920000705),
new Cartesian2D( 90.13799164754806,  38.34903093011013),
new Cartesian2D( 90.11045289492762,  38.36801537312368),
new Cartesian2D( 90.10871471476526,  38.36878044144294),
new Cartesian2D( 90.10424901707671,  38.374300101757),
new Cartesian2D( 90.10263482039932,  38.37310041316073),
new Cartesian2D( 90.09834601753448,  38.373615053823414),
new Cartesian2D( 90.0979455456843,  38.373578376172475),
new Cartesian2D( 90.09086514328669,  38.37527884194668),
new Cartesian2D( 90.09084931407364,  38.37590801712463),
new Cartesian2D( 90.09081227075944,  38.37526295920463),
new Cartesian2D( 90.09081378927135,  38.375193883266434)
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0905,  38.3755)));
Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.09084, 38.3755)));
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0913,  38.3755)));
Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.1042,  38.3739)));
Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.1111,  38.3673)));
Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0959,  38.3457)));
Cartesian2D[] vertices2 = new Cartesian2D[] {
new Cartesian2D( 90.13067558880044,  38.36977255037573),
new Cartesian2D( 90.12907570488,  38.36817308242706),
new Cartesian2D( 90.1342774136516,  38.356886880294724),
new Cartesian2D( 90.13090330629757,  38.34664392676211),
new Cartesian2D( 90.13078571364593,  38.344904617518466),
new Cartesian2D( 90.1315602208914,  38.3447185040846),
new Cartesian2D( 90.1316336226821,  38.34470643148342),
new Cartesian2D( 90.134020944832,  38.340936644972885),
new Cartesian2D( 90.13912536387306,  38.335497255122334),
new Cartesian2D( 90.1396178806582,  38.334878075552126),
new Cartesian2D( 90.14083049696671,  38.33316530644106),
new Cartesian2D( 90.14145252901329,  38.33152722916191),
new Cartesian2D( 90.1404779335565,  38.32863516047786),
new Cartesian2D( 90.14282712131586,  38.327504432532066),
new Cartesian2D( 90.14616669875488,  38.3237354115015),
new Cartesian2D( 90.14860976050608,  38.315714862457924),
new Cartesian2D( 90.14999277782437,  38.3164932507504),
new Cartesian2D( 90.15005207194997,  38.316534677663356),
new Cartesian2D( 90.15508513859612,  38.31878731691609),
new Cartesian2D( 90.15919938519221,  38.31852743183782),
new Cartesian2D( 90.16093758658837,  38.31880662005153),
new Cartesian2D( 90.16099420184912,  38.318825953291594),
new Cartesian2D( 90.1665411125756,  38.31859497874757),
new Cartesian2D( 90.16999653861313,  38.32505772048029),
new Cartesian2D( 90.17475243391698,  38.32594398441148),
new Cartesian2D( 90.17940844844992,  38.327427213761325),
new Cartesian2D( 90.20951909541378,  38.330616833491774),
new Cartesian2D( 90.2155400467941,  38.331746223670336),
new Cartesian2D( 90.21559881391778,  38.33175551425302),
new Cartesian2D( 90.21916646426041,  38.332584299620805),
new Cartesian2D( 90.23863749852285,  38.34778978875795),
new Cartesian2D( 90.25459855175802,  38.357790570608984),
new Cartesian2D( 90.25964298227257,  38.356918010203174),
new Cartesian2D( 90.26024593994703,  38.361692743151366),
new Cartesian2D( 90.26146187570015,  38.36311080550837),
new Cartesian2D( 90.26614159359622,  38.36510808579902),
new Cartesian2D( 90.26621342936448,  38.36507942500333),
new Cartesian2D( 90.26652190211962,  38.36494042196722),
new Cartesian2D( 90.26621240678867,  38.365113172030874),
new Cartesian2D( 90.26614057102057,  38.365141832826794),
new Cartesian2D( 90.26380080055299,  38.3660381760273),
new Cartesian2D( 90.26315345241,  38.36670658276421),
new Cartesian2D( 90.26251574942881,  38.367490323488084),
new Cartesian2D( 90.26247873448426,  38.36755266444749),
new Cartesian2D( 90.26234628016698,  38.36787989125406),
new Cartesian2D( 90.26214559424784,  38.36945909356126),
new Cartesian2D( 90.25861728442555,  38.37200753430875),
new Cartesian2D( 90.23905557537864,  38.375405314295904),
new Cartesian2D( 90.22517251874075,  38.38984691662256),
new Cartesian2D( 90.22549955153215,  38.3911564273979),
new Cartesian2D( 90.22434386063355,  38.391476432092134),
new Cartesian2D( 90.22147729457276,  38.39134652252034),
new Cartesian2D( 90.22142070120117,  38.391349167741964),
new Cartesian2D( 90.20665060751588,  38.39475580900313),
new Cartesian2D( 90.20042268367109,  38.39842558622888),
new Cartesian2D( 90.17423771242085,  38.402727751805344),
new Cartesian2D( 90.16756796257476,  38.40913898597597),
new Cartesian2D( 90.16728283954308,  38.411255399912875),
new Cartesian2D( 90.16703538220418,  38.41136059866693),
new Cartesian2D( 90.16725865657685,  38.41013618805954),
new Cartesian2D( 90.16746107640665,  38.40902614307544),
new Cartesian2D( 90.16122795307462,  38.39773101873203)
Cartesian2D[][] vertices = set.getVertices();
new Cartesian2D(4.267199999996532, -11.928637756014894),
new Cartesian2D(4.267200000026445, -14.12360595809307),
new Cartesian2D(9.144000000273694, -14.12360595809307),
new Cartesian2D(9.144000000233383, -11.928637756020067));
new Cartesian2D(2.56735636510452512E-9, -11.933116461089332),
new Cartesian2D(2.56735636510452512E-9, -12.393225665247766),
new Cartesian2D(2.56735636510452512E-9, -27.785625665247778),
new Cartesian2D(4.267200000030211,      -27.785625665247778),
new Cartesian2D(4.267200000030211,      -11.933116461089332));
Cartesian2D pA = new Cartesian2D(0.0,        1.0);
Cartesian2D pB = new Cartesian2D(0.0,        0.0);
Cartesian2D pC = new Cartesian2D(1.0 / 64.0, 0.0);
Cartesian2D pD = new Cartesian2D(1.0 / 64.0, 1.0);
new RegionFactory<Euclidean2D>().buildConvex(new Line(new Cartesian2D(0, 0), new Cartesian2D(0, 1), tolerance),
new Line(new Cartesian2D(1, 1), new Cartesian2D(1, 0), tolerance));
new Cartesian2D(0, 0),
new Cartesian2D(1, 0),
new Cartesian2D(1, 1),
new Cartesian2D(0, 1));
Cartesian2D[][] squareBoundary = square.getVertices();
SubLine cut = new Line(new Cartesian2D(0.5, 0.5), 0.0, square.getTolerance()).wholeHyperplane();
Cartesian2D[][] splitBoundary = splitSquare.getVertices();
private PolygonsSet buildSet(Cartesian2D[][] vertices) {
private SubHyperplane<Euclidean2D> buildLine(Cartesian2D start, Cartesian2D end) {
Cartesian2D p = l0.intersection(l1);
private SubHyperplane<Euclidean2D> buildHalfLine(Cartesian2D start, Cartesian2D end,
private SubHyperplane<Euclidean2D> buildSegment(Cartesian2D start, Cartesian2D end) {
Cartesian2D[] points) {
private boolean checkInSegment(Cartesian2D p,
Cartesian2D p1, Cartesian2D p2,
private void checkVertices(Cartesian2D[][] rebuiltVertices,
Cartesian2D[][] vertices) {
Cartesian2D p = rebuiltVertices[i][j];
Cartesian2D[] loop = vertices[k];
Cartesian2D start = new Cartesian2D(2, 2);
Cartesian2D end = new Cartesian2D(-2, -2);
Assert.assertEquals(FastMath.sqrt(2), segment.distance(new Cartesian2D(1, -1)), 1.0e-10);
Assert.assertEquals(FastMath.sin(Math.PI / 4.0), segment.distance(new Cartesian2D(0, -1)), 1.0e-10);
Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Cartesian2D(0, 4)), 1.0e-10);
Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Cartesian2D(0, -4)), 1.0e-10);
Cartesian2D p1 = new Cartesian2D(-1, -7);
Cartesian2D p2 = new Cartesian2D(7, -1);
Assert.assertEquals(0.0, new Cartesian2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10);
SubLine wholeLine = new Line(new Cartesian2D(-1, 7), new Cartesian2D(7, 1), 1.0e-10).wholeHyperplane();
SubLine empty = new SubLine(new Line(new Cartesian2D(-1, -7), new Cartesian2D(7, -1), 1.0e-10),
SubLine twoSubs = new SubLine(new Line(new Cartesian2D(-1, -7), new Cartesian2D(7, -1), 1.0e-10),
SubLine empty = new SubLine(new Line(new Cartesian2D(-1, -7), new Cartesian2D(7, -1), 1.0e-10),
Assert.assertEquals(0.0, new Cartesian2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10);
SubLine empty = new SubLine(new Line(new Cartesian2D(-1, -7), new Cartesian2D(7, -1), 1.0e-10),
Assert.assertEquals(0.0, new Cartesian2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(3, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 2), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
Assert.assertEquals(0.0, new Cartesian2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(3, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 1), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(3, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 0.5), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(2, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 1), 1.0e-10);
Assert.assertEquals(0.0, new Cartesian2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(2, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 0.5), 1.0e-10);
SubLine sub1 = new SubLine(new Cartesian2D(1, 1), new Cartesian2D(1.5, 1), 1.0e-10);
SubLine sub2 = new SubLine(new Cartesian2D(2, 0), new Cartesian2D(2, 0.5), 1.0e-10);
final SubLine sub1 = new SubLine(new Cartesian2D(0, 1), new Cartesian2D(0, 2), 1.0e-10);
final SubLine sub2 = new SubLine(new Cartesian2D(66, 3), new Cartesian2D(66, 4), 1.0e-10);
Cartesian2D c = new Cartesian2D(1, 1);
Cartesian2D c = new Cartesian2D(1.23, 1.43);
Cartesian2D c = new Cartesian2D(1.232323232323, 1.434343434343);
Cartesian2D c = new Cartesian2D(-1.232323232323, 1.43);
Cartesian2D c = new Cartesian2D(1.23, -1.434343434343);
Cartesian2D c = new Cartesian2D(1.23, 1.43);
Cartesian2D c = new Cartesian2D(1, 1);
Cartesian2D c = new Cartesian2D(232.22222222222, -342.3333333333);
Cartesian2D c = Cartesian2D.NaN;
Cartesian2D c = Cartesian2D.POSITIVE_INFINITY;
Cartesian2D c = Cartesian2D.NEGATIVE_INFINITY;
Cartesian2D expected = new Cartesian2D(1, 1);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(1, 1);
Cartesian2D expected = new Cartesian2D(1.23, 1.43);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(1.2323, 1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(-1.2323, 1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(1.2323, -1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(1.2323, 1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(-1.2323, -1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(0.0, -1.4343);
Cartesian2D actual = vector2DFormat.parse(source);
Cartesian2D expected = new Cartesian2D(1.2323, 1.4343);
Cartesian2D actual = vector2DFormatSquare.parse(source);
Cartesian2D actual = vector2DFormat.parse(source);
Assert.assertEquals(Cartesian2D.NaN, actual);
Cartesian2D actual = vector2DFormat.parse(source);
Assert.assertEquals(Cartesian2D.POSITIVE_INFINITY, actual);
Cartesian2D actual = vector2DFormat.parse(source);
Assert.assertEquals(Cartesian2D.NEGATIVE_INFINITY, actual);
Cartesian2D oneOne = new Cartesian2D(1.0,1.0);
Cartesian2D oneTwo = new Cartesian2D(1.0,2.0);
Cartesian2D oneThree = new Cartesian2D(1.0,3.0);
Cartesian2D tripleCombo = new Cartesian2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree);
Cartesian2D oneOne = new Cartesian2D(1.0, 1.0);
Cartesian2D oneTwo = new Cartesian2D(1.0, 2.0);
Cartesian2D oneThree = new Cartesian2D(1.0, 3.0);
Cartesian2D oneFour = new Cartesian2D(1.0, 4.0);
Cartesian2D tripleCombo = new Cartesian2D(3.0, oneOne, 1.0, oneTwo, 2.5, oneThree, 2.0, oneFour);
new Cartesian2D(v);
Cartesian2D oneTwo = new Cartesian2D(1.0, 2.0);
Cartesian2D zero = (new Cartesian2D(1.0, 1.0)).getZero();
Cartesian2D oneTwo = new Cartesian2D(-1.0, 2.0);
Cartesian2D oneTwo = new Cartesian2D(-1.0, 2.0);
Cartesian2D oneTwo = new Cartesian2D(-1.0, 2.0);
Cartesian2D minusOneTwo = new Cartesian2D(-1.0,2.0);
Cartesian2D threeFive = new Cartesian2D(3.0,5.0);
Cartesian2D addition = minusOneTwo.add(threeFive);
Cartesian2D minusOneTwo = new Cartesian2D(-1.0,2.0);
Cartesian2D threeFive = new Cartesian2D(3.0,5.0);
Cartesian2D addition = minusOneTwo.add(2.0, threeFive);
Cartesian2D minusOneTwo = new Cartesian2D(-1.0,2.0);
Cartesian2D threeFive = new Cartesian2D(3.0,5.0);
Cartesian2D addition = minusOneTwo.subtract(threeFive);
Cartesian2D minusOneTwo = new Cartesian2D(-1.0,2.0);
Cartesian2D threeFive = new Cartesian2D(3.0,5.0);
Cartesian2D addition = minusOneTwo.subtract(2.0, threeFive);
Cartesian2D minusOneTwo = new Cartesian2D(-1.0,2.0);
Cartesian2D normalizedMinusOneTwo = minusOneTwo.normalize();
Cartesian2D zero = minusOneTwo.getZero();
Cartesian2D oneOne = new Cartesian2D(1.0, 1.0);
Cartesian2D.angle(oneOne.getZero(), oneOne.getZero());
Cartesian2D oneZero = new Cartesian2D(1.0,0.0);
double angle = Cartesian2D.angle(oneOne, oneZero);
Assert.assertEquals(0.004999958333958323, Cartesian2D.angle(new Cartesian2D(20.0,0.0), new Cartesian2D(20.0,0.1)), EPS);
Cartesian2D oneOne = new Cartesian2D(1.0,1.0);
Cartesian2D negated = oneOne.negate();
Cartesian2D oneOne = new Cartesian2D(1.0, 1.0);
Cartesian2D infiniteVector = new Cartesian2D(Double.POSITIVE_INFINITY, 0.0);
Cartesian2D oneOne = new Cartesian2D(1.0,1.0);
Cartesian2D fiveEleven = new Cartesian2D(5.0,11.0);
Cartesian2D oneOne = new Cartesian2D(1.0,1.0);
Cartesian2D fiveEleven = new Cartesian2D(5.0,11.0);
double staticDistanceInf = Cartesian2D.distanceInf(oneOne, fiveEleven);
Cartesian2D oneFive = new Cartesian2D(1.0, 5.0);
Cartesian2D fourOne = new Cartesian2D(4.0, 1.0);
double staticDistanceSq = Cartesian2D.distanceSq(oneFive, fourOne);
int hashCode = (new Cartesian2D(1.0,1.0)).hashCode();
Assert.assertEquals(542, (new Cartesian2D(Double.NaN, Double.NaN)).hashCode());
Assert.assertEquals("{1; 2}", (new Cartesian2D(1.0,2.0)).toString());
Cartesian2D p1 = new Cartesian2D(1, 1);
Cartesian2D p2 = new Cartesian2D(2, 2);
Cartesian2D p3 = new Cartesian2D(3, 3);
Cartesian2D p4 = new Cartesian2D(1, 2);
Cartesian2D p5 = new Cartesian2D(2, 1);
protected Collection<Cartesian2D> reducePoints(Collection<Cartesian2D> points) {
protected Collection<Cartesian2D> reducePoints(Collection<Cartesian2D> points) {
ConvexHull2D hull = generator.generate(Collections.<Cartesian2D>emptyList());
List<Cartesian2D> points = createRandomPoints(1);
List<Cartesian2D> points = createRandomPoints(2);
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(1, 1));
List<Cartesian2D> points = createRandomPoints(size);
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(4, 1));
points.add(new Cartesian2D(10, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(10, 1));
points.add(new Cartesian2D(4, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(4, 1));
points.add(new Cartesian2D(10, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(10, 1));
points.add(new Cartesian2D(4, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(4, 1));
points.add(new Cartesian2D(1, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(4, 1));
points.add(new Cartesian2D(1, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(2, 2));
points.add(new Cartesian2D(2, 4));
points.add(new Cartesian2D(4, 1));
points.add(new Cartesian2D(1.00001, 1));
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(7.3152, 34.7472));
points.add(new Cartesian2D(6.400799999999997, 34.747199999999985));
points.add(new Cartesian2D(5.486399999999997, 34.7472));
points.add(new Cartesian2D(4.876799999999999, 34.7472));
points.add(new Cartesian2D(4.876799999999999, 34.1376));
points.add(new Cartesian2D(4.876799999999999, 30.48));
points.add(new Cartesian2D(6.0959999999999965, 30.48));
points.add(new Cartesian2D(6.0959999999999965, 34.1376));
points.add(new Cartesian2D(7.315199999999996, 34.1376));
points.add(new Cartesian2D(7.3152, 30.48));
List<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(16.078200000000184, -36.52519999989808));
points.add(new Cartesian2D(19.164300000000186, -36.52519999989808));
points.add(new Cartesian2D(19.1643, -25.28136477910407));
points.add(new Cartesian2D(19.1643, -17.678400000004157));
points.add(new Cartesian2D(0, -29.959696875));
points.add(new Cartesian2D(0, -31.621809375));
points.add(new Cartesian2D(0, -28.435696875));
points.add(new Cartesian2D(0, -33.145809375));
points.add(new Cartesian2D(3.048, -33.145809375));
points.add(new Cartesian2D(3.048, -31.621809375));
points.add(new Cartesian2D(3.048, -29.959696875));
points.add(new Cartesian2D(4.572, -33.145809375));
points.add(new Cartesian2D(4.572, -28.435696875));
List<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(line[0], line[1]));
Cartesian2D[] referenceHull = new Cartesian2D[] {
new Cartesian2D(-11.0, -1.0),
new Cartesian2D(-10.0, -3.0),
new Cartesian2D( -6.0, -7.0),
new Cartesian2D( -3.0, -8.0),
new Cartesian2D(  3.0, -8.0),
new Cartesian2D(  6.0, -7.0),
new Cartesian2D( 10.0, -3.0),
new Cartesian2D( 11.0, -1.0),
new Cartesian2D( 11.0,  1.0),
new Cartesian2D( 10.0,  3.0),
new Cartesian2D(  6.0,  7.0),
new Cartesian2D(  3.0,  8.0),
new Cartesian2D( -3.0,  8.0),
new Cartesian2D( -6.0,  7.0),
new Cartesian2D(-10.0,  3.0),
new Cartesian2D(-11.0,  1.0),
perimeter += Cartesian2D.distance(referenceHull[i],
protected final List<Cartesian2D> createRandomPoints(int size) {
List<Cartesian2D> points = new ArrayList<>(size);
points.add(new Cartesian2D(random.nextDouble() * 2.0 - 1.0, random.nextDouble() * 2.0 - 1.0));
protected final void checkConvexHull(final Collection<Cartesian2D> points, final ConvexHull2D hull) {
protected final void checkConvexHull(final Collection<Cartesian2D> points, final ConvexHull2D hull,
protected final void checkConvexHull(final Collection<Cartesian2D> points, final ConvexHull2D hull,
final Cartesian2D[] points = hull.getVertices();
Cartesian2D p1 = points[i == 0 ? points.length - 1 : i - 1];
Cartesian2D p2 = points[i];
Cartesian2D p3 = points[i == points.length - 1 ? 0 : i + 1];
Cartesian2D d1 = p2.subtract(p1);
Cartesian2D d2 = p3.subtract(p2);
protected final void checkPointsInsideHullRegion(final Collection<Cartesian2D> points,
final Collection<Cartesian2D> hullVertices = Arrays.asList(hull.getVertices());
for (final Cartesian2D p : points) {
final Collection<Cartesian2D> points = new ArrayList<>();
points.add(new Cartesian2D(1, 1));
points.add(new Cartesian2D(1, 5));
points.add(new Cartesian2D(0, 7));
points.add(new Cartesian2D(1, 10));
points.add(new Cartesian2D(1, 20));
points.add(new Cartesian2D(20, 20));
points.add(new Cartesian2D(20, 40));
points.add(new Cartesian2D(40, 1));
final Cartesian2D p = h.toSpace(Cartesian1D.ZERO);
final Cartesian3D p = h.toSpace(Cartesian2D.ZERO);
return new Circle(new Cartesian3D(getNumber(), getNumber(), getNumber()), getNumber());
return new OrientedPoint(new Cartesian1D(getNumber()), getBoolean(), getNumber());
return new Line(new Cartesian2D(getNumber(), getNumber()), getNumber(), getNumber());
return new Plane(new Cartesian3D(getNumber(), getNumber(), getNumber()),
new Cartesian3D(getNumber(), getNumber(), getNumber()),
Circle circle = new Circle(new Cartesian3D(0, 0, 1000), 1.0e-10).copySelf();
Assert.assertEquals(Cartesian3D.PLUS_K, circle.getPole());
Assert.assertEquals(Cartesian3D.MINUS_K, circle.getPole());
Assert.assertEquals(Cartesian3D.PLUS_K, circle.getReverse().getPole());
Assert.assertEquals(Cartesian3D.MINUS_K, circle.getPole());
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(circle.getXAxis(), circle.getYAxis()), 1.0e-10);
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(circle.getXAxis(), circle.getPole()), 1.0e-10);
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(circle.getPole(), circle.getYAxis()), 1.0e-10);
circle.getPole().distance(Cartesian3D.crossProduct(circle.getXAxis(), circle.getYAxis())),
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(reversed.getXAxis(), reversed.getYAxis()), 1.0e-10);
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(reversed.getXAxis(), reversed.getPole()), 1.0e-10);
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(reversed.getPole(), reversed.getYAxis()), 1.0e-10);
reversed.getPole().distance(Cartesian3D.crossProduct(reversed.getXAxis(), reversed.getYAxis())),
Assert.assertEquals(0, Cartesian3D.angle(circle.getXAxis(), reversed.getXAxis()), 1.0e-10);
Assert.assertEquals(FastMath.PI, Cartesian3D.angle(circle.getYAxis(), reversed.getYAxis()), 1.0e-10);
Assert.assertEquals(FastMath.PI, Cartesian3D.angle(circle.getPole(), reversed.getPole()), 1.0e-10);
Cartesian3D p = new Cartesian3D(1, 2, -4);
Cartesian3D samePhase = circle.getPointAt(circle.getPhase(p));
Cartesian3D.angle(Cartesian3D.crossProduct(circle.getPole(), p),
Cartesian3D.crossProduct(circle.getPole(), samePhase)),
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(circle.getPole(), samePhase), 1.0e-10);
Cartesian3D p = new Cartesian3D(1, 2, -4);
Cartesian3D p = new Cartesian3D(FastMath.cos(alpha), circle.getXAxis(),
Cartesian3D q = circle.toSpace(new S1Point(alpha)).getVector();
Assert.assertEquals(0.5 * FastMath.PI, Cartesian3D.angle(circle.getPole(), q), 1.0e-10);
Circle circle = new Circle(Cartesian3D.PLUS_K, 1.0e-10);
Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Cartesian3D.PLUS_I)),  1.0e-10);
Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Cartesian3D.MINUS_I)), 1.0e-10);
Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Cartesian3D.PLUS_J)),  1.0e-10);
Assert.assertEquals(0.0,                circle.getOffset(new S2Point(Cartesian3D.MINUS_J)), 1.0e-10);
Assert.assertEquals(-0.5 * FastMath.PI, circle.getOffset(new S2Point(Cartesian3D.PLUS_K)),  1.0e-10);
Assert.assertEquals(0.5 * FastMath.PI, circle.getOffset(new S2Point(Cartesian3D.MINUS_K)), 1.0e-10);
Circle c1 = new Circle(new Cartesian3D(sphRandom.nextVector()), 1.0e-10);
Circle c2 = new Circle(new Cartesian3D(sphRandom.nextVector()), 1.0e-10);
Rotation r = new Rotation(new Cartesian3D(sphRandom.nextVector()),
S2Point  p = new S2Point(new Cartesian3D(sphRandom.nextVector()));
Circle  c = new Circle(new Cartesian3D(sphRandom.nextVector()), 1.0e-10);
Cartesian3D psub = c.getPointAt(((LimitAngle) sub.getHyperplane()).getLocation().getAlpha());
Cartesian3D ptsub = tc.getPointAt(((LimitAngle) tsub.getHyperplane()).getLocation().getAlpha());
Cartesian3D v = new Cartesian3D(random.nextVector());
Cartesian3D v = new Cartesian3D(random.nextVector());
SphericalPolygonsSet south = new SphericalPolygonsSet(Cartesian3D.MINUS_K, tol);
Cartesian3D v = new Cartesian3D(random.nextVector());
SphericalPolygonsSet plusX = new SphericalPolygonsSet(Cartesian3D.PLUS_I, tol);
SphericalPolygonsSet plusY = new SphericalPolygonsSet(Cartesian3D.PLUS_J, tol);
SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Cartesian3D.PLUS_K, tol);
Cartesian3D v = new Cartesian3D(random.nextVector());
xPFound = xPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_I) < 1.0e-10;
yPFound = yPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_J) < 1.0e-10;
zPFound = zPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_K) < 1.0e-10;
xVFound = xVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I) < 1.0e-10;
yVFound = yVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J) < 1.0e-10;
zVFound = zVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K) < 1.0e-10;
((S2Point) octant.getBarycenter()).distance(new S2Point(new Cartesian3D(1, 1, 1))),
Assert.assertEquals(0, reversedCap.getCenter().distance(new S2Point(new Cartesian3D(-1, -1, -1))), 1.0e-10);
Cartesian3D v = new Cartesian3D(random.nextVector());
SphericalPolygonsSet plusX = new SphericalPolygonsSet(Cartesian3D.PLUS_I, tol);
SphericalPolygonsSet plusY = new SphericalPolygonsSet(Cartesian3D.PLUS_J, tol);
SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Cartesian3D.PLUS_K, tol);
Cartesian3D v = new Cartesian3D(random.nextVector());
if (e.getCircle().getPole().distance(Cartesian3D.MINUS_I) < 1.0e-10) {
} else if (e.getCircle().getPole().distance(Cartesian3D.MINUS_J) < 1.0e-10) {
Assert.assertEquals(0.0, e.getCircle().getPole().distance(Cartesian3D.PLUS_K), 1.0e-10);
xVFound = xVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I) < 1.0e-10;
yVFound = yVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J) < 1.0e-10;
zVFound = zVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K) < 1.0e-10;
boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.PLUS_I,  Cartesian3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.PLUS_K,  Cartesian3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.PLUS_J,  Cartesian3D.MINUS_I, tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.MINUS_J, Cartesian3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1,  1,  1).normalize())));
Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1,  1,  1).normalize())));
Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1, -1,  1).normalize())));
Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D( 1, -1,  1).normalize())));
Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1,  1, -1).normalize())));
Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D(-1,  1, -1).normalize())));
Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1, -1, -1).normalize())));
Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1, -1, -1).normalize())));
pXFound = pXFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I)  < 1.0e-10;
mXFound = mXFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_I) < 1.0e-10;
pYFound = pYFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J)  < 1.0e-10;
mYFound = mYFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_J) < 1.0e-10;
pZFound = pZFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K)  < 1.0e-10;
mZFound = mZFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_K) < 1.0e-10;
boundary.add(create(Cartesian3D.PLUS_J,  Cartesian3D.PLUS_K,  Cartesian3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,  Cartesian3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));
boundary.add(create(Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, Cartesian3D.MINUS_I,  tol, 0.0, 0.5 * FastMath.PI));
Cartesian3D v = new Cartesian3D(random.nextVector());
S2Point center = new S2Point(new Cartesian3D(1, 1, 1));
SphericalPolygonsSet hexa = new SphericalPolygonsSet(center.getVector(), Cartesian3D.PLUS_K, alpha, 6, tol);
Cartesian3D center = new Cartesian3D(1, 1, 1);
SphericalPolygonsSet hexaOut   = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.9,  6, tol);
SphericalPolygonsSet hexaIn    = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.8,  6, tol);
SphericalPolygonsSet pentaOut  = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.7,  5, tol);
SphericalPolygonsSet pentaIn   = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.6,  5, tol);
SphericalPolygonsSet quadriOut = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.5,  4, tol);
SphericalPolygonsSet quadriIn  = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.4,  4, tol);
SphericalPolygonsSet triOut    = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.25, 3, tol);
SphericalPolygonsSet triIn     = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.15, 3, tol);
Cartesian3D enclosingCenter = ((S2Point) enclosing.getCenter()).getVector();
Cartesian3D p = v.getOutgoing().getPointAt(i * step);
Assert.assertTrue(Cartesian3D.angle(p, enclosingCenter) <= enclosing.getRadius());
Cartesian3D continentalCenter = ((S2Point) continentalInscribed.getCenter()).getVector();
Cartesian3D p = v.getOutgoing().getPointAt(i * step);
Assert.assertTrue(Cartesian3D.angle(p, continentalCenter) <= continentalInscribed.getRadius());
Cartesian3D corsicaCenter = ((S2Point) corsicaInscribed.getCenter()).getVector();
Cartesian3D p = v.getOutgoing().getPointAt(i * step);
Assert.assertTrue(Cartesian3D.angle(p, corsicaCenter) <= corsicaInscribed.getRadius());
private SubCircle create(Cartesian3D pole, Cartesian3D x, Cartesian3D y,
Circle circle = new Circle(Cartesian3D.PLUS_K, 1.0e-10);
Circle xzPlane = new Circle(Cartesian3D.PLUS_J, 1.0e-10);
SubCircle sc1 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
SubCircle sc2 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 1.0, 3.0);
SubCircle sc3 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 5.0, 6.0);
SubCircle sc4 = create(Cartesian3D.PLUS_J, Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, 1.0e-10, 5.0, 6.0);
SubCircle sc5 = create(Cartesian3D.MINUS_J, Cartesian3D.PLUS_I, Cartesian3D.PLUS_K, 1.0e-10, 5.0, 6.0);
Circle xzPlane = new Circle(Cartesian3D.PLUS_J, 1.0e-10);
SubCircle sc1 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 1.0, 3.0, 5.0, 6.0);
SubCircle sc2 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 1.0, 3.0);
SubCircle sc3 = create(Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, 1.0e-10, 5.0, 6.0);
SubCircle sc4 = create(Cartesian3D.PLUS_J, Cartesian3D.PLUS_K, Cartesian3D.PLUS_I, 1.0e-10, 5.0, 6.0);
SubCircle sc5 = create(Cartesian3D.MINUS_J, Cartesian3D.PLUS_I, Cartesian3D.PLUS_K, 1.0e-10, 5.0, 6.0);
Circle hyperplane = new Circle(new Cartesian3D(9.738804529764676E-5, -0.6772824575010357, -0.7357230887208355),
SubCircle sub = new SubCircle(new Circle(new Cartesian3D(2.1793884139073498E-4, 0.9790647032675541, -0.20354915700704285),
private SubCircle create(Cartesian3D pole, Cartesian3D x, Cartesian3D y,
Cartesian2D center = new Cartesian2D(o.getPointRef()[0], o.getPointRef()[1]);
private ArrayList<Cartesian2D> points;
points.add(new Cartesian2D(px, py));
public double getRadius(Cartesian2D center) {
for (Cartesian2D point : points) {
Cartesian2D center = new Cartesian2D(params[0], params[1]);
for (Cartesian2D point : points) {
Cartesian2D center = new Cartesian2D(params[0], params[1]);
for (Cartesian2D pk : points) {
Cartesian2D center = new Cartesian2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);pTotal += 2 * pLow;for (int j = 0; j < qrt[i].length; j++) {final double zSquared = FastMath.pow(z, 2);
final double factor = 1.0 / (1 + (1.0 / numberOfTrials) * zSquared);
final double modifiedSuccessRatio = mean + (1.0 / (2 * numberOfTrials)) * zSquared;
(1.0 / (4 * FastMath.pow(numberOfTrials, 2)) * zSquared));final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());
if (global < -1.0e-10) {
return new SplitSubHyperplane<>(null, this);
} else if (global > 1.0e-10) {
return new SplitSubHyperplane<>(this, null);
return new SplitSubHyperplane<>(null, null);if (loop.get(0).getStart() == null) {
for (int i = 0; i < loop.size(); ++i) {
final Segment previous = loop.get(i);
int j = (i + 1) % loop.size();
final Segment next = loop.get(j);
if (next != null &&
Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {
loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));
loop.remove(i--);
BSPTree<Euclidean2D> selected = null;
double min = Double.POSITIVE_INFINITY;
for (final BSPTree<Euclidean2D> node : candidates) {
final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));
if (distance < min) {
selected = node;
min      = distance;
return min <= tolerance ? selected : null;getTree(true).visit(new FacetsContributionVisitor());
if (getSize() < 0) {
} else {
setSize(getSize() / 3.0);
setBarycenter((Point<Euclidean3D>) new Cartesian3D(1.0 / (4 * getSize()), (Cartesian3D) getBarycenter()));
private class FacetsContributionVisitor implements BSPTreeVisitor<Euclidean3D> {
FacetsContributionVisitor() {
setSize(0);
setBarycenter((Point<Euclidean3D>) new Cartesian3D(0, 0, 0));
final double area    = polygon.getSize();
setSize(Double.POSITIVE_INFINITY);
setBarycenter((Point<Euclidean3D>) Cartesian3D.NaN);
final Plane    plane  = (Plane) facet.getHyperplane();
final Cartesian3D facetB = plane.toSpace(polygon.getBarycenter());
double   scaled = area * facetB.dotProduct(plane.getNormal());
scaled = -scaled;
setSize(getSize() + scaled);
setBarycenter((Point<Euclidean3D>) new Cartesian3D(1.0, (Cartesian3D) getBarycenter(), scaled, facetB));final double mu = getNumericalMean();
final double sigma = FastMath.sqrt(getNumericalVariance());
IntegerDistribution.Sampler sampler) {
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
implements RealDistribution, Serializable {
final double mu = getNumericalMean();
final double sig = FastMath.sqrt(getNumericalVariance());
RealDistribution.Sampler sampler) {
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
package org.apache.commons.math4.distribution;
public class BetaDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double alpha;
private final double beta;
private final double z;
private final double solverAbsoluteAccuracy;
public BetaDistribution(double alpha, double beta) {
this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public BetaDistribution(double alpha,
double beta,
double inverseCumAccuracy) {
this.alpha = alpha;
this.beta = beta;
z = LogGamma.value(alpha) + LogGamma.value(beta) - LogGamma.value(alpha + beta);
solverAbsoluteAccuracy = inverseCumAccuracy;
public double getAlpha() {
return alpha;
public double getBeta() {
return beta;
public double density(double x) {
final double logDensity = logDensity(x);
return logDensity == Double.NEGATIVE_INFINITY ? 0 : FastMath.exp(logDensity);
public double logDensity(double x) {
if (x < 0 || x > 1) {
return Double.NEGATIVE_INFINITY;
} else if (x == 0) {
if (alpha < 1) {
throw new NumberIsTooSmallException(LocalizedFormats.CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA,
alpha, 1, false);
return Double.NEGATIVE_INFINITY;
} else if (x == 1) {
if (beta < 1) {
throw new NumberIsTooSmallException(LocalizedFormats.CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA,
beta, 1, false);
return Double.NEGATIVE_INFINITY;
} else {
double logX = FastMath.log(x);
double log1mX = FastMath.log1p(-x);
return (alpha - 1) * logX + (beta - 1) * log1mX - z;
public double cumulativeProbability(double x)  {
if (x <= 0) {
return 0;
} else if (x >= 1) {
return 1;
} else {
return RegularizedBeta.value(x, alpha, beta);
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
final double a = getAlpha();
return a / (a + getBeta());
public double getNumericalVariance() {
final double a = getAlpha();
final double b = getBeta();
final double alphabetasum = a + b;
return (a * b) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return 1;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new ChengBetaSampler(rng, alpha, beta);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class BinomialDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 6751309484392813623L;
private final int numberOfTrials;
private final double probabilityOfSuccess;
public BinomialDistribution(int trials,
double p) {
if (trials < 0) {
throw new NotPositiveException(LocalizedFormats.NUMBER_OF_TRIALS,
trials);
if (p < 0 || p > 1) {
throw new OutOfRangeException(p, 0, 1);
probabilityOfSuccess = p;
numberOfTrials = trials;
public int getNumberOfTrials() {
return numberOfTrials;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
final double logProbability = logProbability(x);
return logProbability == Double.NEGATIVE_INFINITY ? 0 : FastMath.exp(logProbability);
public double logProbability(int x) {
if (numberOfTrials == 0) {
return (x == 0) ? 0. : Double.NEGATIVE_INFINITY;
double ret;
if (x < 0 || x > numberOfTrials) {
ret = Double.NEGATIVE_INFINITY;
} else {
ret = SaddlePointExpansion.logBinomialProbability(x,
numberOfTrials, probabilityOfSuccess,
1.0 - probabilityOfSuccess);
return ret;
public double cumulativeProbability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
} else if (x >= numberOfTrials) {
ret = 1.0;
} else {
ret = 1.0 - RegularizedBeta.value(probabilityOfSuccess,
x + 1.0, numberOfTrials - x);
return ret;
public double getNumericalMean() {
return numberOfTrials * probabilityOfSuccess;
public double getNumericalVariance() {
final double p = probabilityOfSuccess;
return numberOfTrials * p * (1 - p);
public int getSupportLowerBound() {
return probabilityOfSuccess < 1.0 ? 0 : numberOfTrials;
public int getSupportUpperBound() {
return probabilityOfSuccess > 0.0 ? numberOfTrials : 0;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class CauchyDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double median;
private final double scale;
private final double solverAbsoluteAccuracy;
public CauchyDistribution() {
this(0, 1);
public CauchyDistribution(double median,
double scale) {
this(median, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public CauchyDistribution(double median,
double scale,
double inverseCumAccuracy) {
if (scale <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);
this.scale = scale;
this.median = median;
solverAbsoluteAccuracy = inverseCumAccuracy;
public double cumulativeProbability(double x) {
return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);
public double getMedian() {
return median;
public double getScale() {
return scale;
public double density(double x) {
final double dev = x - median;
return (1 / FastMath.PI) * (scale / (dev * dev + scale * scale));
public double inverseCumulativeProbability(double p) throws OutOfRangeException {
double ret;
if (p < 0 || p > 1) {
throw new OutOfRangeException(p, 0, 1);
} else if (p == 0) {
ret = Double.NEGATIVE_INFINITY;
} else  if (p == 1) {
ret = Double.POSITIVE_INFINITY;
} else {
ret = median + scale * FastMath.tan(FastMath.PI * (p - .5));
return ret;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
return Double.NaN;
public double getNumericalVariance() {
return Double.NaN;
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class ChiSquaredDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final GammaDistribution gamma;
private final double solverAbsoluteAccuracy;
public ChiSquaredDistribution(double degreesOfFreedom) {
this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public ChiSquaredDistribution(double degreesOfFreedom,
double inverseCumAccuracy) {
gamma = new GammaDistribution(degreesOfFreedom / 2, 2);
solverAbsoluteAccuracy = inverseCumAccuracy;
public double getDegreesOfFreedom() {
return gamma.getShape() * 2.0;
public double density(double x) {
return gamma.density(x);
public double logDensity(double x) {
return gamma.logDensity(x);
public double cumulativeProbability(double x)  {
return gamma.cumulativeProbability(x);
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
return getDegreesOfFreedom();
public double getNumericalVariance() {
return 2 * getDegreesOfFreedom();
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class ConstantRealDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = -4157745166772046273L;
private final double value;
public ConstantRealDistribution(double value) {
this.value = value;
public double density(double x) {
return x == value ? 1 : 0;
public double cumulativeProbability(double x)  {
return x < value ? 0 : 1;
public double inverseCumulativeProbability(final double p)
throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0, 1);
return value;
public double getNumericalMean() {
return value;
public double getNumericalVariance() {
return 0;
public double getSupportLowerBound() {
return value;
public double getSupportUpperBound() {
return value;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
public double sample() {
return value;
};
public class EmpiricalDistribution extends AbstractRealDistribution {
final RealDistribution kernel = getKernel(binStats.get(binIndex));
final RealDistribution kernel = k(x);
if (kernel instanceof ConstantRealDistribution) {
if (x < kernel.getNumericalMean()) {
final RealDistribution kernel = getKernel(binStats.get(i));
public double getNumericalMean() {
public double getNumericalVariance() {
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
final RealDistribution kernel = getKernel(binStats.get(i));
private RealDistribution k(double x) {
protected RealDistribution getKernel(SummaryStatistics bStats) {
return new ConstantRealDistribution(bStats.getMean());
return new NormalDistribution(bStats.getMean(), bStats.getStandardDeviation(),
NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
private final UniformRandomProvider random;
random = rng;
final double randomValue = random.nextDouble();
int index = Arrays.binarySearch(cumulativeProbabilities, randomValue);
if (index < 0) {
index = -index - 1;
if (index >= 0 &&
index < probabilities.length &&
randomValue < cumulativeProbabilities[index]) {
return singletons.get(index);
return singletons.get(singletons.size() - 1);
public double getNumericalMean() {
public double getNumericalVariance() {
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
public class EnumeratedRealDistribution extends AbstractRealDistribution {
public double getNumericalMean() {
public double getNumericalVariance() {
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
package org.apache.commons.math4.distribution;
public class ExponentialDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double mean;
private final double logMean;
private final double solverAbsoluteAccuracy;
public ExponentialDistribution(double mean) {
this(mean, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public ExponentialDistribution(double mean,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (mean <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);
this.mean = mean;
logMean = FastMath.log(mean);
solverAbsoluteAccuracy = inverseCumAccuracy;
public double getMean() {
return mean;
public double density(double x) {
final double logDensity = logDensity(x);
return logDensity == Double.NEGATIVE_INFINITY ? 0 : FastMath.exp(logDensity);
public double logDensity(double x) {
if (x < 0) {
return Double.NEGATIVE_INFINITY;
return -x / mean - logMean;
public double cumulativeProbability(double x)  {
double ret;
if (x <= 0.0) {
ret = 0.0;
} else {
ret = 1.0 - FastMath.exp(-x / mean);
return ret;
public double inverseCumulativeProbability(double p) throws OutOfRangeException {
double ret;
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0.0, 1.0);
} else if (p == 1.0) {
ret = Double.POSITIVE_INFINITY;
} else {
ret = -mean * FastMath.log(1.0 - p);
return ret;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
return getMean();
public double getNumericalVariance() {
final double m = getMean();
return m * m;
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new AhrensDieterExponentialSampler(rng, mean);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class FDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = -8516354193418641566L;
private final double numeratorDegreesOfFreedom;
private final double denominatorDegreesOfFreedom;
private final double solverAbsoluteAccuracy;
private double numericalVariance = Double.NaN;
private boolean numericalVarianceIsCalculated = false;
public FDistribution(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom)
throws NotStrictlyPositiveException {
this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,
DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public FDistribution(double numeratorDegreesOfFreedom,
double denominatorDegreesOfFreedom,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (numeratorDegreesOfFreedom <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
numeratorDegreesOfFreedom);
if (denominatorDegreesOfFreedom <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
denominatorDegreesOfFreedom);
this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;
this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;
solverAbsoluteAccuracy = inverseCumAccuracy;
public double density(double x) {
return FastMath.exp(logDensity(x));
public double logDensity(double x) {
final double nhalf = numeratorDegreesOfFreedom / 2;
final double mhalf = denominatorDegreesOfFreedom / 2;
final double logx = FastMath.log(x);
final double logn = FastMath.log(numeratorDegreesOfFreedom);
final double logm = FastMath.log(denominatorDegreesOfFreedom);
final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +
denominatorDegreesOfFreedom);
return nhalf * logn + nhalf * logx - logx +
mhalf * logm - nhalf * lognxm - mhalf * lognxm -
LogBeta.value(nhalf, mhalf);
public double cumulativeProbability(double x)  {
double ret;
if (x <= 0) {
ret = 0;
} else {
double n = numeratorDegreesOfFreedom;
double m = denominatorDegreesOfFreedom;
ret = RegularizedBeta.value((n * x) / (m + n * x),
0.5 * n,
0.5 * m);
return ret;
public double getNumeratorDegreesOfFreedom() {
return numeratorDegreesOfFreedom;
public double getDenominatorDegreesOfFreedom() {
return denominatorDegreesOfFreedom;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
final double denominatorDF = getDenominatorDegreesOfFreedom();
if (denominatorDF > 2) {
return denominatorDF / (denominatorDF - 2);
return Double.NaN;
public double getNumericalVariance() {
if (!numericalVarianceIsCalculated) {
numericalVariance = calculateNumericalVariance();
numericalVarianceIsCalculated = true;
return numericalVariance;
protected double calculateNumericalVariance() {
final double denominatorDF = getDenominatorDegreesOfFreedom();
if (denominatorDF > 4) {
final double numeratorDF = getNumeratorDegreesOfFreedom();
final double denomDFMinusTwo = denominatorDF - 2;
return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /
( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );
return Double.NaN;
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class GammaDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final double LANCZOS_G = LanczosApproximation.g();
private static final long serialVersionUID = 20160311L;
private final double shape;
private final double scale;
private final double shiftedShape;
private final double densityPrefactor1;
private final double logDensityPrefactor1;
private final double densityPrefactor2;
private final double logDensityPrefactor2;
private final double minY;
private final double maxLogY;
private final double solverAbsoluteAccuracy;
public GammaDistribution(double shape, double scale)
throws NotStrictlyPositiveException {
this(shape, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public GammaDistribution(double shape,
double scale,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (shape <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);
if (scale <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);
this.shape = shape;
this.scale = scale;
this.solverAbsoluteAccuracy = inverseCumAccuracy;
this.shiftedShape = shape + LANCZOS_G + 0.5;
final double aux = FastMath.E / (2.0 * FastMath.PI * shiftedShape);
this.densityPrefactor2 = shape * FastMath.sqrt(aux) / LanczosApproximation.value(shape);
this.logDensityPrefactor2 = FastMath.log(shape) + 0.5 * FastMath.log(aux) -
FastMath.log(LanczosApproximation.value(shape));
this.densityPrefactor1 = this.densityPrefactor2 / scale *
FastMath.pow(shiftedShape, -shape) *
FastMath.exp(shape + LANCZOS_G);
this.logDensityPrefactor1 = this.logDensityPrefactor2 - FastMath.log(scale) -
FastMath.log(shiftedShape) * shape +
shape + LANCZOS_G;
this.minY = shape + LANCZOS_G - FastMath.log(Double.MAX_VALUE);
this.maxLogY = FastMath.log(Double.MAX_VALUE) / (shape - 1.0);
public double getShape() {
return shape;
public double getScale() {
return scale;
public double density(double x) {
if (x < 0) {
return 0;
final double y = x / scale;
if ((y <= minY) || (FastMath.log(y) >= maxLogY)) {
final double aux1 = (y - shiftedShape) / shiftedShape;
final double aux2 = shape * (FastMath.log1p(aux1) - aux1);
final double aux3 = -y * (LANCZOS_G + 0.5) / shiftedShape + LANCZOS_G + aux2;
return densityPrefactor2 / x * FastMath.exp(aux3);
return densityPrefactor1 * FastMath.exp(-y) * FastMath.pow(y, shape - 1);
public double logDensity(double x) {
if (x < 0) {
return Double.NEGATIVE_INFINITY;
final double y = x / scale;
if ((y <= minY) || (FastMath.log(y) >= maxLogY)) {
final double aux1 = (y - shiftedShape) / shiftedShape;
final double aux2 = shape * (FastMath.log1p(aux1) - aux1);
final double aux3 = -y * (LANCZOS_G + 0.5) / shiftedShape + LANCZOS_G + aux2;
return logDensityPrefactor2 - FastMath.log(x) + aux3;
return logDensityPrefactor1 - y + FastMath.log(y) * (shape - 1);
public double cumulativeProbability(double x) {
double ret;
if (x <= 0) {
ret = 0;
} else {
ret = RegularizedGamma.P.value(shape, x / scale);
return ret;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
return shape * scale;
public double getNumericalVariance() {
return shape * scale * scale;
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new AhrensDieterMarsagliaTsangGammaSampler(rng, scale, shape);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class GeometricDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 20160318L;
private final double probabilityOfSuccess;
private final double logProbabilityOfSuccess;
private final double log1mProbabilityOfSuccess;
public GeometricDistribution(double p) {
if (p <= 0 || p > 1) {
throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_LEFT, p, 0, 1);
probabilityOfSuccess = p;
logProbabilityOfSuccess = FastMath.log(p);
log1mProbabilityOfSuccess = FastMath.log1p(-p);
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
if (x < 0) {
return 0.0;
} else {
return FastMath.exp(log1mProbabilityOfSuccess * x) * probabilityOfSuccess;
public double logProbability(int x) {
if (x < 0) {
return Double.NEGATIVE_INFINITY;
} else {
return x * log1mProbabilityOfSuccess + logProbabilityOfSuccess;
public double cumulativeProbability(int x) {
if (x < 0) {
return 0.0;
} else {
return -FastMath.expm1(log1mProbabilityOfSuccess * (x + 1));
public double getNumericalMean() {
return (1 - probabilityOfSuccess) / probabilityOfSuccess;
public double getNumericalVariance() {
return (1 - probabilityOfSuccess) / (probabilityOfSuccess * probabilityOfSuccess);
public int getSupportLowerBound() {
return 0;
public int getSupportUpperBound() {
return Integer.MAX_VALUE;
public boolean isSupportConnected() {
return true;
public int inverseCumulativeProbability(double p) throws OutOfRangeException {
if (p < 0 || p > 1) {
throw new OutOfRangeException(p, 0, 1);
if (p == 1) {
return Integer.MAX_VALUE;
if (p == 0) {
return 0;
return Math.max(0, (int) Math.ceil(FastMath.log1p(-p)/log1mProbabilityOfSuccess-1));
package org.apache.commons.math4.distribution;
public class GumbelDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20160311L;
private static final double EULER = FastMath.PI / (2 * FastMath.E);
private final double mu;
private final double beta;
public GumbelDistribution(double mu, double beta) {
if (beta <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, beta);
this.beta = beta;
this.mu = mu;
public double getLocation() {
return mu;
public double getScale() {
return beta;
public double density(double x) {
final double z = (x - mu) / beta;
final double t = FastMath.exp(-z);
return FastMath.exp(-z - t) / beta;
public double cumulativeProbability(double x) {
final double z = (x - mu) / beta;
return FastMath.exp(-FastMath.exp(-z));
public double inverseCumulativeProbability(double p) throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0.0, 1.0);
} else if (p == 0) {
return Double.NEGATIVE_INFINITY;
} else if (p == 1) {
return Double.POSITIVE_INFINITY;
return mu - FastMath.log(-FastMath.log(p)) * beta;
public double getNumericalMean() {
return mu + EULER * beta;
public double getNumericalVariance() {
return (MathUtils.PI_SQUARED) / 6.0 * (beta * beta);
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class HypergeometricDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 20160318L;
private final int numberOfSuccesses;
private final int populationSize;
private final int sampleSize;
private double numericalVariance = Double.NaN;
private boolean numericalVarianceIsCalculated = false;
public HypergeometricDistribution(int populationSize,
int numberOfSuccesses,
int sampleSize)
throws NotPositiveException,
NotStrictlyPositiveException,
NumberIsTooLargeException {
if (populationSize <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,
populationSize);
if (numberOfSuccesses < 0) {
throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,
numberOfSuccesses);
if (sampleSize < 0) {
throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
sampleSize);
if (numberOfSuccesses > populationSize) {
throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,
numberOfSuccesses, populationSize, true);
if (sampleSize > populationSize) {
throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,
sampleSize, populationSize, true);
this.numberOfSuccesses = numberOfSuccesses;
this.populationSize = populationSize;
this.sampleSize = sampleSize;
public double cumulativeProbability(int x) {
double ret;
int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);
if (x < domain[0]) {
ret = 0.0;
} else if (x >= domain[1]) {
ret = 1.0;
} else {
ret = innerCumulativeProbability(domain[0], x, 1);
return ret;
private int[] getDomain(int n, int m, int k) {
return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };
private int getLowerDomain(int n, int m, int k) {
return FastMath.max(0, m - (n - k));
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public int getPopulationSize() {
return populationSize;
public int getSampleSize() {
return sampleSize;
private int getUpperDomain(int m, int k) {
return FastMath.min(k, m);
public double probability(int x) {
final double logProbability = logProbability(x);
return logProbability == Double.NEGATIVE_INFINITY ? 0 : FastMath.exp(logProbability);
public double logProbability(int x) {
double ret;
int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);
if (x < domain[0] || x > domain[1]) {
ret = Double.NEGATIVE_INFINITY;
} else {
double p = (double) sampleSize / (double) populationSize;
double q = (double) (populationSize - sampleSize) / (double) populationSize;
double p1 = SaddlePointExpansion.logBinomialProbability(x,
numberOfSuccesses, p, q);
double p2 =
SaddlePointExpansion.logBinomialProbability(sampleSize - x,
populationSize - numberOfSuccesses, p, q);
double p3 =
SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);
ret = p1 + p2 - p3;
return ret;
public double upperCumulativeProbability(int x) {
double ret;
final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);
if (x <= domain[0]) {
ret = 1.0;
} else if (x > domain[1]) {
ret = 0.0;
} else {
ret = innerCumulativeProbability(domain[1], x, -1);
return ret;
private double innerCumulativeProbability(int x0, int x1, int dx) {
double ret = probability(x0);
while (x0 != x1) {
x0 += dx;
ret += probability(x0);
return ret;
public double getNumericalMean() {
return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
public double getNumericalVariance() {
if (!numericalVarianceIsCalculated) {
numericalVariance = calculateNumericalVariance();
numericalVarianceIsCalculated = true;
return numericalVariance;
protected double calculateNumericalVariance() {
final double N = getPopulationSize();
final double m = getNumberOfSuccesses();
final double n = getSampleSize();
return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));
public int getSupportLowerBound() {
return FastMath.max(0,
getSampleSize() + getNumberOfSuccesses() - getPopulationSize());
public int getSupportUpperBound() {
return FastMath.min(getNumberOfSuccesses(), getSampleSize());
public boolean isSupportConnected() {
return true;
public interface IntegerDistribution {
double logProbability(int x);
double probability(int x);
double probability(int x0, int x1) throws NumberIsTooLargeException;
double cumulativeProbability(int x);
int inverseCumulativeProbability(double p) throws OutOfRangeException;
double getNumericalMean();
double getNumericalVariance();
int getSupportLowerBound();
int getSupportUpperBound();
boolean isSupportConnected();
Sampler createSampler(UniformRandomProvider rng);
interface Sampler {
int sample();
package org.apache.commons.math4.distribution;
public class LaplaceDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20160311L;
private final double mu;
private final double beta;
public LaplaceDistribution(double mu, double beta) {
if (beta <= 0.0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_SCALE, beta);
this.mu = mu;
this.beta = beta;
public double getLocation() {
return mu;
public double getScale() {
return beta;
public double density(double x) {
return FastMath.exp(-FastMath.abs(x - mu) / beta) / (2.0 * beta);
public double cumulativeProbability(double x) {
if (x <= mu) {
return FastMath.exp((x - mu) / beta) / 2.0;
} else {
return 1.0 - FastMath.exp((mu - x) / beta) / 2.0;
public double inverseCumulativeProbability(double p) throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0.0, 1.0);
} else if (p == 0) {
return Double.NEGATIVE_INFINITY;
} else if (p == 1) {
return Double.POSITIVE_INFINITY;
double x = (p > 0.5) ? -Math.log(2.0 - 2.0 * p) : Math.log(2.0 * p);
return mu + beta * x;
public double getNumericalMean() {
return mu;
public double getNumericalVariance() {
return 2.0 * beta * beta;
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class LevyDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20630311L;
private final double mu;
private final double c;  // Setting this to 1 returns a cumProb of 1.0
private final double halfC;
public LevyDistribution(final double mu, final double c) {
this.mu = mu;
this.c = c;
this.halfC = 0.5 * c;
public double density(final double x) {
if (x < mu) {
return Double.NaN;
final double delta = x - mu;
final double f     = halfC / delta;
return FastMath.sqrt(f / FastMath.PI) * FastMath.exp(-f) /delta;
public double logDensity(double x) {
if (x < mu) {
return Double.NaN;
final double delta = x - mu;
final double f     = halfC / delta;
return 0.5 * FastMath.log(f / FastMath.PI) - f - FastMath.log(delta);
public double cumulativeProbability(final double x) {
if (x < mu) {
return Double.NaN;
return Erfc.value(FastMath.sqrt(halfC / (x - mu)));
public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0, 1);
final double t = InverseErfc.value(p);
return mu + halfC / (t * t);
public double getScale() {
return c;
public double getLocation() {
return mu;
public double getNumericalMean() {
return Double.POSITIVE_INFINITY;
public double getNumericalVariance() {
return Double.POSITIVE_INFINITY;
public double getSupportLowerBound() {
return mu;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class LogNormalDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20120112;
private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);
private static final double SQRT2 = FastMath.sqrt(2.0);
private final double scale;
private final double shape;
private final double logShapePlusHalfLog2Pi;
private final double solverAbsoluteAccuracy;
public LogNormalDistribution() {
this(0, 1);
public LogNormalDistribution(double scale, double shape)
throws NotStrictlyPositiveException {
this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public LogNormalDistribution(double scale,
double shape,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (shape <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);
this.scale = scale;
this.shape = shape;
this.logShapePlusHalfLog2Pi = FastMath.log(shape) + 0.5 * FastMath.log(2 * FastMath.PI);
this.solverAbsoluteAccuracy = inverseCumAccuracy;
public double getScale() {
return scale;
public double getShape() {
return shape;
public double density(double x) {
if (x <= 0) {
return 0;
final double x0 = FastMath.log(x) - scale;
final double x1 = x0 / shape;
return FastMath.exp(-0.5 * x1 * x1) / (shape * SQRT2PI * x);
public double logDensity(double x) {
if (x <= 0) {
return Double.NEGATIVE_INFINITY;
final double logX = FastMath.log(x);
final double x0 = logX - scale;
final double x1 = x0 / shape;
return -0.5 * x1 * x1 - (logShapePlusHalfLog2Pi + logX);
public double cumulativeProbability(double x)  {
if (x <= 0) {
return 0;
final double dev = FastMath.log(x) - scale;
if (FastMath.abs(dev) > 40 * shape) {
return dev < 0 ? 0.0d : 1.0d;
return 0.5 + 0.5 * Erf.value(dev / (shape * SQRT2));
public double probability(double x0,
double x1)
throws NumberIsTooLargeException {
if (x0 > x1) {
throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,
x0, x1, true);
if (x0 <= 0 || x1 <= 0) {
return super.probability(x0, x1);
final double denom = shape * SQRT2;
final double v0 = (FastMath.log(x0) - scale) / denom;
final double v1 = (FastMath.log(x1) - scale) / denom;
return 0.5 * ErfDifference.value(v0, v1);
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
double s = shape;
return FastMath.exp(scale + (s * s / 2));
public double getNumericalVariance() {
final double s = shape;
final double ss = s * s;
return (FastMath.expm1(ss)) * FastMath.exp(2 * scale + ss);
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new LogNormalSampler(new ZigguratNormalizedGaussianSampler(rng), scale, shape);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class LogisticDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20160311L;
private final double mu;
private final double s;
public LogisticDistribution(double mu,
double s) {
if (s <= 0.0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_SCALE, s);
this.mu = mu;
this.s = s;
public double getLocation() {
return mu;
public double getScale() {
return s;
public double density(double x) {
double z = (x - mu) / s;
double v = FastMath.exp(-z);
return 1 / s * v / ((1.0 + v) * (1.0 + v));
public double cumulativeProbability(double x) {
double z = 1 / s * (x - mu);
return 1.0 / (1.0 + FastMath.exp(-z));
public double inverseCumulativeProbability(double p) throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0.0, 1.0);
} else if (p == 0) {
return 0.0;
} else if (p == 1) {
return Double.POSITIVE_INFINITY;
return s * Math.log(p / (1.0 - p)) + mu;
public double getNumericalMean() {
return mu;
public double getNumericalVariance() {
return (MathUtils.PI_SQUARED / 3.0) * (1.0 / (s * s));
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
private final RealDistribution.Sampler gauss = new NormalDistribution().createSampler(rng);
package org.apache.commons.math4.distribution;
public class NakagamiDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double mu;
private final double omega;
private final double inverseAbsoluteAccuracy;
public NakagamiDistribution(double mu,
double omega) {
this(mu, omega, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public NakagamiDistribution(double mu,
double omega,
double inverseAbsoluteAccuracy) {
if (mu < 0.5) {
throw new NumberIsTooSmallException(mu, 0.5, true);
if (omega <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_SCALE, omega);
this.mu = mu;
this.omega = omega;
this.inverseAbsoluteAccuracy = inverseAbsoluteAccuracy;
public double getShape() {
return mu;
public double getScale() {
return omega;
protected double getSolverAbsoluteAccuracy() {
return inverseAbsoluteAccuracy;
public double density(double x) {
if (x <= 0) {
return 0.0;
return 2.0 * FastMath.pow(mu, mu) / (Gamma.value(mu) * FastMath.pow(omega, mu)) *
FastMath.pow(x, 2 * mu - 1) * FastMath.exp(-mu * x * x / omega);
public double cumulativeProbability(double x) {
return RegularizedGamma.P.value(mu, mu * x * x / omega);
public double getNumericalMean() {
return Gamma.value(mu + 0.5) / Gamma.value(mu) * FastMath.sqrt(omega / mu);
public double getNumericalVariance() {
double v = Gamma.value(mu + 0.5) / Gamma.value(mu);
return omega * (1 - 1 / mu * v * v);
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class NormalDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 8589540077390120676L;
private static final double SQRT2 = FastMath.sqrt(2.0);
private final double mean;
private final double standardDeviation;
private final double logStandardDeviationPlusHalfLog2Pi;
private final double solverAbsoluteAccuracy;
public NormalDistribution() {
this(0, 1);
public NormalDistribution(double mean,
double sd)
throws NotStrictlyPositiveException {
this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public NormalDistribution(double mean,
double sd,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (sd <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);
this.mean = mean;
standardDeviation = sd;
logStandardDeviationPlusHalfLog2Pi = FastMath.log(sd) + 0.5 * FastMath.log(2 * FastMath.PI);
solverAbsoluteAccuracy = inverseCumAccuracy;
public double getMean() {
return mean;
public double getStandardDeviation() {
return standardDeviation;
public double density(double x) {
return FastMath.exp(logDensity(x));
public double logDensity(double x) {
final double x0 = x - mean;
final double x1 = x0 / standardDeviation;
return -0.5 * x1 * x1 - logStandardDeviationPlusHalfLog2Pi;
public double cumulativeProbability(double x)  {
final double dev = x - mean;
if (FastMath.abs(dev) > 40 * standardDeviation) {
return dev < 0 ? 0.0d : 1.0d;
return 0.5 * Erfc.value(-dev / (standardDeviation * SQRT2));
public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0, 1);
return mean + standardDeviation * SQRT2 * InverseErf.value(2 * p - 1);
public double probability(double x0,
double x1)
throws NumberIsTooLargeException {
if (x0 > x1) {
throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,
x0, x1, true);
final double denom = standardDeviation * SQRT2;
final double v0 = (x0 - mean) / denom;
final double v1 = (x1 - mean) / denom;
return 0.5 * ErfDifference.value(v0, v1);
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
return getMean();
public double getNumericalVariance() {
final double s = getStandardDeviation();
return s * s;
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new GaussianSampler(new MarsagliaNormalizedGaussianSampler(rng),
mean, standardDeviation);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class ParetoDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double scale;
private final double shape;
private final double solverAbsoluteAccuracy;
public ParetoDistribution() {
this(1, 1);
public ParetoDistribution(double scale,
double shape)
throws NotStrictlyPositiveException {
this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public ParetoDistribution(double scale,
double shape,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (scale <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);
if (shape <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);
this.scale = scale;
this.shape = shape;
this.solverAbsoluteAccuracy = inverseCumAccuracy;
public double getScale() {
return scale;
public double getShape() {
return shape;
public double density(double x) {
if (x < scale) {
return 0;
return FastMath.pow(scale, shape) / FastMath.pow(x, shape + 1) * shape;
public double logDensity(double x) {
if (x < scale) {
return Double.NEGATIVE_INFINITY;
return FastMath.log(scale) * shape - FastMath.log(x) * (shape + 1) + FastMath.log(shape);
public double cumulativeProbability(double x)  {
if (x <= scale) {
return 0;
return 1 - FastMath.pow(scale / x, shape);
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
if (shape <= 1) {
return Double.POSITIVE_INFINITY;
return shape * scale / (shape - 1);
public double getNumericalVariance() {
if (shape <= 2) {
return Double.POSITIVE_INFINITY;
double s = shape - 1;
return scale * scale * shape / (s * s) / (shape - 2);
public double getSupportLowerBound() {
return scale;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new InverseTransformParetoSampler(rng, scale, shape);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class PascalDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 6751309484392813623L;
private final int numberOfSuccesses;
private final double probabilityOfSuccess;
private final double logProbabilityOfSuccess;
private final double log1mProbabilityOfSuccess;
public PascalDistribution(int r,
double p)
throws NotStrictlyPositiveException,
OutOfRangeException {
if (r <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,
r);
if (p < 0 || p > 1) {
throw new OutOfRangeException(p, 0, 1);
numberOfSuccesses = r;
probabilityOfSuccess = p;
logProbabilityOfSuccess = FastMath.log(p);
log1mProbabilityOfSuccess = FastMath.log1p(-p);
public int getNumberOfSuccesses() {
return numberOfSuccesses;
public double getProbabilityOfSuccess() {
return probabilityOfSuccess;
public double probability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
} else {
ret = BinomialCoefficientDouble.value(x +
numberOfSuccesses - 1, numberOfSuccesses - 1) *
FastMath.pow(probabilityOfSuccess, numberOfSuccesses) *
FastMath.pow(1.0 - probabilityOfSuccess, x);
return ret;
public double logProbability(int x) {
double ret;
if (x < 0) {
ret = Double.NEGATIVE_INFINITY;
} else {
ret = LogBinomialCoefficient.value(x +
numberOfSuccesses - 1, numberOfSuccesses - 1) +
logProbabilityOfSuccess * numberOfSuccesses +
log1mProbabilityOfSuccess * x;
return ret;
public double cumulativeProbability(int x) {
double ret;
if (x < 0) {
ret = 0.0;
} else {
ret = RegularizedBeta.value(probabilityOfSuccess,
numberOfSuccesses, x + 1.0);
return ret;
public double getNumericalMean() {
final double p = getProbabilityOfSuccess();
final double r = getNumberOfSuccesses();
return (r * (1 - p)) / p;
public double getNumericalVariance() {
final double p = getProbabilityOfSuccess();
final double r = getNumberOfSuccesses();
return r * (1 - p) / (p * p);
public int getSupportLowerBound() {
return 0;
public int getSupportUpperBound() {
return Integer.MAX_VALUE;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class PoissonDistribution extends AbstractIntegerDistribution {
private static final int DEFAULT_MAX_ITERATIONS = 10000000;
private static final double DEFAULT_EPSILON = 1e-12;
private static final long serialVersionUID = -3349935121172596109L;
private final NormalDistribution normal;
private final double mean;
private final int maxIterations;
private final double epsilon;
public PoissonDistribution(double p)
throws NotStrictlyPositiveException {
this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);
public PoissonDistribution(double p,
double epsilon,
int maxIterations)
throws NotStrictlyPositiveException {
if (p <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
mean = p;
this.epsilon = epsilon;
this.maxIterations = maxIterations;
normal = new NormalDistribution(p, FastMath.sqrt(p),
NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public PoissonDistribution(double p, double epsilon)
throws NotStrictlyPositiveException {
this(p, epsilon, DEFAULT_MAX_ITERATIONS);
public PoissonDistribution(double p, int maxIterations) {
this(p, DEFAULT_EPSILON, maxIterations);
public double getMean() {
return mean;
public double probability(int x) {
final double logProbability = logProbability(x);
return logProbability == Double.NEGATIVE_INFINITY ? 0 : FastMath.exp(logProbability);
public double logProbability(int x) {
double ret;
if (x < 0 || x == Integer.MAX_VALUE) {
ret = Double.NEGATIVE_INFINITY;
} else if (x == 0) {
ret = -mean;
} else {
ret = -SaddlePointExpansion.getStirlingError(x) -
SaddlePointExpansion.getDeviancePart(x, mean) -
0.5 * FastMath.log(MathUtils.TWO_PI) - 0.5 * FastMath.log(x);
return ret;
public double cumulativeProbability(int x) {
if (x < 0) {
return 0;
if (x == Integer.MAX_VALUE) {
return 1;
return RegularizedGamma.Q.value((double) x + 1, mean, epsilon,
maxIterations);
public double normalApproximateProbability(int x)  {
return normal.cumulativeProbability(x + 0.5);
public double getNumericalMean() {
return getMean();
public double getNumericalVariance() {
return getMean();
public int getSupportLowerBound() {
return 0;
public int getSupportUpperBound() {
return Integer.MAX_VALUE;
public boolean isSupportConnected() {
return true;
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final DiscreteSampler sampler =
new PoissonSampler(rng, mean);
public int sample() {
return sampler.sample();
};
public interface RealDistribution {
double probability(double x);
double probability(double x0, double x1) throws NumberIsTooLargeException;
double density(double x);
double logDensity(double x);
double cumulativeProbability(double x);
double inverseCumulativeProbability(double p) throws OutOfRangeException;
double getNumericalMean();
double getNumericalVariance();
double getSupportLowerBound();
double getSupportUpperBound();
boolean isSupportConnected();
Sampler createSampler(UniformRandomProvider rng);
interface Sampler {
double sample();
package org.apache.commons.math4.distribution;
final class SaddlePointExpansion {
private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(MathUtils.TWO_PI);
private static final double[] EXACT_STIRLING_ERRORS = { 0.0, /* 0.0 */
0.1534264097200273452913848, /* 0.5 */
0.0810614667953272582196702, /* 1.0 */
0.0548141210519176538961390, /* 1.5 */
0.0413406959554092940938221, /* 2.0 */
0.03316287351993628748511048, /* 2.5 */
0.02767792568499833914878929, /* 3.0 */
0.02374616365629749597132920, /* 3.5 */
0.02079067210376509311152277, /* 4.0 */
0.01848845053267318523077934, /* 4.5 */
0.01664469118982119216319487, /* 5.0 */
0.01513497322191737887351255, /* 5.5 */
0.01387612882307074799874573, /* 6.0 */
0.01281046524292022692424986, /* 6.5 */
0.01189670994589177009505572, /* 7.0 */
0.01110455975820691732662991, /* 7.5 */
0.010411265261972096497478567, /* 8.0 */
0.009799416126158803298389475, /* 8.5 */
0.009255462182712732917728637, /* 9.0 */
0.008768700134139385462952823, /* 9.5 */
0.008330563433362871256469318, /* 10.0 */
0.007934114564314020547248100, /* 10.5 */
0.007573675487951840794972024, /* 11.0 */
0.007244554301320383179543912, /* 11.5 */
0.006942840107209529865664152, /* 12.0 */
0.006665247032707682442354394, /* 12.5 */
0.006408994188004207068439631, /* 13.0 */
0.006171712263039457647532867, /* 13.5 */
0.005951370112758847735624416, /* 14.0 */
0.005746216513010115682023589, /* 14.5 */
0.005554733551962801371038690 /* 15.0 */
};
private SaddlePointExpansion() {
super();
double ret;
if (z < 15.0) {
double z2 = 2.0 * z;
if (FastMath.floor(z2) == z2) {
ret = EXACT_STIRLING_ERRORS[(int) z2];
} else {
ret = LogGamma.value(z + 1.0) - (z + 0.5) * FastMath.log(z) +
z - HALF_LOG_2_PI;
} else {
double z2 = z * z;
ret = (0.083333333333333333333 -
(0.00277777777777777777778 -
(0.00079365079365079365079365 -
(0.000595238095238095238095238 -
0.0008417508417508417508417508 /
z2) / z2) / z2) / z2) / z;
return ret;
double ret;
if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {
double d = x - mu;
double v = d / (x + mu);
double s1 = v * d;
double s = Double.NaN;
double ej = 2.0 * x * v;
v *= v;
int j = 1;
while (s1 != s) {
s = s1;
ej *= v;
s1 = s + ej / ((j * 2) + 1);
++j;
ret = s1;
} else {
if (x == 0) {
return mu;
ret = x * FastMath.log(x / mu) + mu - x;
return ret;
double ret;
if (x == 0) {
if (p < 0.1) {
ret = -getDeviancePart(n, n * q) - n * p;
} else {
if (n == 0) {
return 0;
ret = n * FastMath.log(q);
} else if (x == n) {
if (q < 0.1) {
ret = -getDeviancePart(n, n * p) - n * q;
} else {
ret = n * FastMath.log(p);
} else {
ret = getStirlingError(n) - getStirlingError(x) -
getStirlingError(n - x) - getDeviancePart(x, n * p) -
getDeviancePart(n - x, n * q);
double f = (MathUtils.TWO_PI * x * (n - x)) / n;
ret = -0.5 * FastMath.log(f) + ret;
return ret;
package org.apache.commons.math4.distribution;
public class TDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double degreesOfFreedom;
private final double solverAbsoluteAccuracy;
private final double factor;
public TDistribution(double degreesOfFreedom)
throws NotStrictlyPositiveException {
this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public TDistribution(double degreesOfFreedom,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (degreesOfFreedom <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,
degreesOfFreedom);
this.degreesOfFreedom = degreesOfFreedom;
solverAbsoluteAccuracy = inverseCumAccuracy;
final double n = degreesOfFreedom;
final double nPlus1Over2 = (n + 1) / 2;
factor = LogGamma.value(nPlus1Over2) -
0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -
LogGamma.value(n / 2);
public double getDegreesOfFreedom() {
return degreesOfFreedom;
public double density(double x) {
return FastMath.exp(logDensity(x));
public double logDensity(double x) {
final double n = degreesOfFreedom;
final double nPlus1Over2 = (n + 1) / 2;
return factor - nPlus1Over2 * FastMath.log(1 + x * x / n);
public double cumulativeProbability(double x) {
double ret;
if (x == 0) {
ret = 0.5;
} else {
double t =
RegularizedBeta.value(degreesOfFreedom / (degreesOfFreedom + (x * x)),
0.5 * degreesOfFreedom,
0.5);
if (x < 0.0) {
ret = 0.5 * t;
} else {
ret = 1.0 - 0.5 * t;
return ret;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
final double df = getDegreesOfFreedom();
if (df > 1) {
return 0;
return Double.NaN;
public double getNumericalVariance() {
final double df = getDegreesOfFreedom();
if (df > 2) {
return df / (df - 2);
if (df > 1 && df <= 2) {
return Double.POSITIVE_INFINITY;
return Double.NaN;
public double getSupportLowerBound() {
return Double.NEGATIVE_INFINITY;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class TriangularDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20160311L;
private final double a;
private final double b;
private final double c;
private final double solverAbsoluteAccuracy;
public TriangularDistribution(double a,
double c,
double b)
throws NumberIsTooLargeException,
NumberIsTooSmallException {
if (a >= b) {
throw new NumberIsTooLargeException(
LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
a, b, false);
if (c < a) {
throw new NumberIsTooSmallException(
LocalizedFormats.NUMBER_TOO_SMALL, c, a, true);
if (c > b) {
throw new NumberIsTooLargeException(
LocalizedFormats.NUMBER_TOO_LARGE, c, b, true);
this.a = a;
this.c = c;
this.b = b;
solverAbsoluteAccuracy = FastMath.max(FastMath.ulp(a), FastMath.ulp(b));
public double getMode() {
return c;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double density(double x) {
if (x < a) {
return 0;
if (a <= x && x < c) {
double divident = 2 * (x - a);
double divisor = (b - a) * (c - a);
return divident / divisor;
if (x == c) {
return 2 / (b - a);
if (c < x && x <= b) {
double divident = 2 * (b - x);
double divisor = (b - a) * (b - c);
return divident / divisor;
return 0;
public double cumulativeProbability(double x)  {
if (x < a) {
return 0;
if (a <= x && x < c) {
double divident = (x - a) * (x - a);
double divisor = (b - a) * (c - a);
return divident / divisor;
if (x == c) {
return (c - a) / (b - a);
if (c < x && x <= b) {
double divident = (b - x) * (b - x);
double divisor = (b - a) * (b - c);
return 1 - (divident / divisor);
return 1;
public double getNumericalMean() {
return (a + b + c) / 3;
public double getNumericalVariance() {
return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
public double getSupportLowerBound() {
return a;
public double getSupportUpperBound() {
return b;
public boolean isSupportConnected() {
return true;
public double inverseCumulativeProbability(double p)
throws OutOfRangeException {
if (p < 0 || p > 1) {
throw new OutOfRangeException(p, 0, 1);
if (p == 0) {
return a;
if (p == 1) {
return b;
if (p < (c - a) / (b - a)) {
return a + FastMath.sqrt(p * (b - a) * (c - a));
return b - FastMath.sqrt((1 - p) * (b - a) * (b - c));
package org.apache.commons.math4.distribution;
public class UniformIntegerDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 20160308L;
private final int lower;
private final int upper;
private final double upperPlusLower;
private final double upperMinusLower;
public UniformIntegerDistribution(int lower,
int upper)
throws NumberIsTooLargeException {
if (lower > upper) {
throw new NumberIsTooLargeException(
LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
lower, upper, true);
this.lower = lower;
this.upper = upper;
upperPlusLower = (double) upper + (double) lower;
upperMinusLower = (double) upper - (double) lower;
public double probability(int x) {
if (x < lower || x > upper) {
return 0;
return 1.0 / (upperMinusLower + 1);
public double cumulativeProbability(int x) {
if (x < lower) {
return 0;
if (x > upper) {
return 1;
return (x - lower + 1.0) / (upperMinusLower + 1.0);
public double getNumericalMean() {
return 0.5 * upperPlusLower;
public double getNumericalVariance() {
double n = upperMinusLower + 1;
return (n * n - 1) / 12.0;
public int getSupportLowerBound() {
return lower;
public int getSupportUpperBound() {
return upper;
public boolean isSupportConnected() {
return true;
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final DiscreteSampler sampler =
new DiscreteUniformSampler(rng, lower, upper);
public int sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class UniformRealDistribution extends AbstractRealDistribution {
private static final long serialVersionUID = 20160311L;
private final double lower;
private final double upper;
public UniformRealDistribution() {
this(0, 1);
public UniformRealDistribution(double lower,
double upper)
throws NumberIsTooLargeException {
if (lower >= upper) {
throw new NumberIsTooLargeException(
LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
lower, upper, false);
this.lower = lower;
this.upper = upper;
public double density(double x) {
if (x < lower || x > upper) {
return 0.0;
return 1 / (upper - lower);
public double cumulativeProbability(double x)  {
if (x <= lower) {
return 0;
if (x >= upper) {
return 1;
return (x - lower) / (upper - lower);
public double inverseCumulativeProbability(final double p)
throws OutOfRangeException {
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0, 1);
return p * (upper - lower) + lower;
public double getNumericalMean() {
return 0.5 * (lower + upper);
public double getNumericalVariance() {
double ul = upper - lower;
return ul * ul / 12;
public double getSupportLowerBound() {
return lower;
public double getSupportUpperBound() {
return upper;
public boolean isSupportConnected() {
return true;
public RealDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new RealDistribution.Sampler() {
private final ContinuousSampler sampler =
new ContinuousUniformSampler(rng, lower, upper);
public double sample() {
return sampler.sample();
};
package org.apache.commons.math4.distribution;
public class WeibullDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20160311L;
private final double shape;
private final double scale;
private final double solverAbsoluteAccuracy;
private double numericalMean = Double.NaN;
private boolean numericalMeanIsCalculated = false;
private double numericalVariance = Double.NaN;
private boolean numericalVarianceIsCalculated = false;
public WeibullDistribution(double alpha, double beta)
throws NotStrictlyPositiveException {
this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
public WeibullDistribution(double alpha,
double beta,
double inverseCumAccuracy)
throws NotStrictlyPositiveException {
if (alpha <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE,
alpha);
if (beta <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.SCALE,
beta);
scale = beta;
shape = alpha;
solverAbsoluteAccuracy = inverseCumAccuracy;
public double getShape() {
return shape;
public double getScale() {
return scale;
public double density(double x) {
if (x < 0) {
return 0;
final double xscale = x / scale;
final double xscalepow = FastMath.pow(xscale, shape - 1);
final double xscalepowshape = xscalepow * xscale;
return (shape / scale) * xscalepow * FastMath.exp(-xscalepowshape);
public double logDensity(double x) {
if (x < 0) {
return Double.NEGATIVE_INFINITY;
final double xscale = x / scale;
final double logxscalepow = FastMath.log(xscale) * (shape - 1);
final double xscalepowshape = FastMath.exp(logxscalepow) * xscale;
return FastMath.log(shape / scale) + logxscalepow - xscalepowshape;
public double cumulativeProbability(double x) {
double ret;
if (x <= 0.0) {
ret = 0.0;
} else {
ret = 1.0 - FastMath.exp(-FastMath.pow(x / scale, shape));
return ret;
public double inverseCumulativeProbability(double p) {
double ret;
if (p < 0.0 || p > 1.0) {
throw new OutOfRangeException(p, 0.0, 1.0);
} else if (p == 0) {
ret = 0.0;
} else  if (p == 1) {
ret = Double.POSITIVE_INFINITY;
} else {
ret = scale * FastMath.pow(-FastMath.log1p(-p), 1.0 / shape);
return ret;
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
public double getNumericalMean() {
if (!numericalMeanIsCalculated) {
numericalMean = calculateNumericalMean();
numericalMeanIsCalculated = true;
return numericalMean;
protected double calculateNumericalMean() {
final double sh = getShape();
final double sc = getScale();
return sc * FastMath.exp(LogGamma.value(1 + (1 / sh)));
public double getNumericalVariance() {
if (!numericalVarianceIsCalculated) {
numericalVariance = calculateNumericalVariance();
numericalVarianceIsCalculated = true;
return numericalVariance;
protected double calculateNumericalVariance() {
final double sh = getShape();
final double sc = getScale();
final double mn = getNumericalMean();
return (sc * sc) * FastMath.exp(LogGamma.value(1 + (2 / sh))) -
(mn * mn);
public double getSupportLowerBound() {
return 0;
public double getSupportUpperBound() {
return Double.POSITIVE_INFINITY;
public boolean isSupportConnected() {
return true;
package org.apache.commons.math4.distribution;
public class ZipfDistribution extends AbstractIntegerDistribution {
private static final long serialVersionUID = 20150501L;
private final int numberOfElements;
private final double exponent;
private final double nthHarmonic;
private double numericalMean = Double.NaN;
private boolean numericalMeanIsCalculated = false;
private double numericalVariance = Double.NaN;
private boolean numericalVarianceIsCalculated = false;
public ZipfDistribution(int numberOfElements,
double exponent)
throws NotStrictlyPositiveException {
if (numberOfElements <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,
numberOfElements);
if (exponent <= 0) {
throw new NotStrictlyPositiveException(LocalizedFormats.EXPONENT,
exponent);
this.numberOfElements = numberOfElements;
this.exponent = exponent;
this.nthHarmonic = generalizedHarmonic(numberOfElements, exponent);
public int getNumberOfElements() {
return numberOfElements;
public double getExponent() {
return exponent;
public double probability(final int x) {
if (x <= 0 || x > numberOfElements) {
return 0.0;
return (1.0 / FastMath.pow(x, exponent)) / nthHarmonic;
public double logProbability(int x) {
if (x <= 0 || x > numberOfElements) {
return Double.NEGATIVE_INFINITY;
return -FastMath.log(x) * exponent - FastMath.log(nthHarmonic);
public double cumulativeProbability(final int x) {
if (x <= 0) {
return 0.0;
} else if (x >= numberOfElements) {
return 1.0;
return generalizedHarmonic(x, exponent) / nthHarmonic;
public double getNumericalMean() {
if (!numericalMeanIsCalculated) {
numericalMean = calculateNumericalMean();
numericalMeanIsCalculated = true;
return numericalMean;
protected double calculateNumericalMean() {
final int N = getNumberOfElements();
final double s = getExponent();
final double Hs1 = generalizedHarmonic(N, s - 1);
final double Hs = nthHarmonic;
return Hs1 / Hs;
public double getNumericalVariance() {
if (!numericalVarianceIsCalculated) {
numericalVariance = calculateNumericalVariance();
numericalVarianceIsCalculated = true;
return numericalVariance;
protected double calculateNumericalVariance() {
final int N = getNumberOfElements();
final double s = getExponent();
final double Hs2 = generalizedHarmonic(N, s - 2);
final double Hs1 = generalizedHarmonic(N, s - 1);
final double Hs = nthHarmonic;
return (Hs2 / Hs) - ((Hs1 * Hs1) / (Hs * Hs));
private double generalizedHarmonic(final int n, final double m) {
double value = 0;
for (int k = n; k > 0; --k) {
value += 1.0 / FastMath.pow(k, m);
return value;
public int getSupportLowerBound() {
return 1;
public int getSupportUpperBound() {
return getNumberOfElements();
public boolean isSupportConnected() {
return true;
public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng) {
return new IntegerDistribution.Sampler() {
private final DiscreteSampler sampler =
new RejectionInversionZipfSampler(rng, numberOfElements, exponent);
public int sample() {
return sampler.sample();
};
return randomize(new UniformRealDistribution(min, max).createSampler(rng),
public static FeatureInitializer randomize(final RealDistribution.Sampler random,
private final RealDistribution.Sampler random;
this.random = new NormalDistribution().createSampler(rng);
public static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data)
public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data)
public static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict)
public static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha)
public double kolmogorovSmirnovTest(RealDistribution distribution, double[] data, boolean exact) {
public double kolmogorovSmirnovStatistic(RealDistribution distribution, double[] data) {
public double kolmogorovSmirnovTest(RealDistribution distribution, double[] data) {
public boolean kolmogorovSmirnovTest(RealDistribution distribution, double[] data, double alpha) {
final RealDistribution.Sampler sampler = new EnumeratedRealDistribution(combined).createSampler(rng);
final NormalDistribution normalDistribution = new NormalDistribution();
final NormalDistribution normalDistribution = new NormalDistribution();
final NormalDistribution normalDistribution = new NormalDistribution();
final RealDistribution.Sampler distX =
new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xval[0], xval[xval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yval[0], yval[yval.length - 1]).createSampler(rng);
final RealDistribution.Sampler distX = new UniformRealDistribution(xValues[0], xValues[xValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distY = new UniformRealDistribution(yValues[0], yValues[yValues.length - 1]).createSampler(rng);
final RealDistribution.Sampler distZ = new UniformRealDistribution(zValues[0], zValues[zValues.length - 1]).createSampler(rng);
public double getNumericalMean() {
public double getNumericalVariance() {
public double getNumericalMean() {
public double getNumericalVariance() {
final double meanX = getNumericalMean();
public double getNumericalMean() {
public double getNumericalVariance() {
final double meanX = getNumericalMean();
package org.apache.commons.math4.distribution;
public class BetaDistributionTest {
public void testCumulative() {
double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};
checkCumulative(0.1, 0.1,
x, new double[]{
0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,
0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,
0.5936149061, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 0.5,
x, new double[]{
0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,
0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,
0.9423662883, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 1.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,
0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,
0.9895192582, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 2.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,
0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,
0.9994144508, 1.0000000000, 1.0000000000});
checkCumulative(0.1, 4.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,
0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,
0.9999967829, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 0.1,
x, new double[]{
0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,
0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,
0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});
checkCumulative(0.5, 0.5,
x, new double[]{
0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,
0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,
0.7951672353, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 1.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,
0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,
0.9486832981, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 2.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,
0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,
0.9961174630, 1.0000000000, 1.0000000000});
checkCumulative(0.5, 4.0,
x, new double[]{
0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,
0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,
0.9999714889, 1.0000000000, 1.0000000000});
checkCumulative(1.0, 0.1,
x, new double[]{
0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,
0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,
0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});
checkCumulative(1.0, 0.5,
x, new double[]{
0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,
0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,
0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});
checkCumulative(1, 1,
x, new double[]{
0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});
checkCumulative(1, 2,
x, new double[]{
0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});
checkCumulative(1, 4,
x, new double[]{
0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,
0.9984, 0.9999, 1.0000, 1.0000});
checkCumulative(2.0, 0.1,
x, new double[]{
0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,
0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,
0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});
checkCumulative(2, 1,
x, new double[]{
0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});
checkCumulative(2.0, 0.5,
x, new double[]{
0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,
0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,
0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});
checkCumulative(2, 2,
x, new double[]{
0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});
checkCumulative(2, 4,
x, new double[]{
0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,
0.96922, 0.99328, 0.99954, 1.00000, 1.00000});
checkCumulative(4.0, 0.1,
x, new double[]{
0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,
3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,
1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});
checkCumulative(4.0, 0.5,
x, new double[]{
0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,
2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,
1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});
checkCumulative(4, 1,
x, new double[]{
0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,
0.4096, 0.6561, 1.0000, 1.0000});
checkCumulative(4, 2,
x, new double[]{
0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,
0.52822, 0.73728, 0.91854, 1.00000, 1.00000});
checkCumulative(4, 4,
x, new double[]{
0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,
0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});
private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) {
BetaDistribution d = new BetaDistribution(alpha, beta);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);
for (int i = 1; i < x.length - 1; i++) {
Assert.assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);
public void testDensity() {
double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};
checkDensity(0.1, 0.1,
x, new double[]{
12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,
1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,
2.639396531e-01, 4.429925026e-01});
checkDensity(0.1, 0.5,
x, new double[]{
2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,
2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,
2.414013907e-01, 3.070567405e-01});
checkDensity(0.1, 1.0,
x, new double[]{
2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,
2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,
1.222414585e-01, 1.099464743e-01});
checkDensity(0.1, 2.0,
x, new double[]{
2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,
1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,
2.689298641e-02, 1.209399123e-02});
checkDensity(0.1, 4.0,
x, new double[]{
2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,
5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,
1.167143939e-03, 1.312171805e-04});
checkDensity(0.5, 0.1,
x, new double[]{
88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,
0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,
0.4203052841, 0.7394649088});
checkDensity(0.5, 0.5,
x, new double[]{
318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,
0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,
0.7957762075, 1.0610376697});
checkDensity(0.5, 1.0,
x, new double[]{
500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,
0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,
0.5590166450, 0.5270459839});
checkDensity(0.5, 2.0,
x, new double[]{
749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,
0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,
0.16770415497, 0.07905610701});
checkDensity(0.5, 4.0,
x, new double[]{
1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,
3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,
9.782644546e-03, 1.152878503e-03});
checkDensity(1.0, 0.1,
x, new double[]{
0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,
0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,
0.7943353837});
checkDensity(1.0, 0.5,
x, new double[]{
0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,
0.7071074883, 0.7905704033, 0.9128724506,
1.1180367838, 1.5811467358});
checkDensity(1, 1,
x, new double[]{
1, 1, 1,
1, 1, 1, 1,
1, 1, 1});
checkDensity(1, 2,
x, new double[]{
1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,
0.599998, 0.399998,
0.199998});
checkDensity(1, 4,
x, new double[]{
3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,
0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,
0.031999520002, 0.003999880001});
checkDensity(2.0, 0.1,
x, new double[]{
1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,
6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,
3.745917198e-01, 7.863929037e-01});
checkDensity(2.0, 0.5,
x, new double[]{
7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,
3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,
1.341645818e+00, 2.134537420613655});
checkDensity(2, 1,
x, new double[]{
0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,
1.400002, 1.600002,
1.800002});
checkDensity(2, 2,
x, new double[]{
5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,
1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,
9.5999640e-01, 5.3999520e-01});
checkDensity(2, 4,
x, new double[]{
0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,
1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,
0.12799824001, 0.01799948000});
checkDensity(4.0, 0.1,
x, new double[]{
1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,
1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,
2.601171405e-01, 6.911229392e-01});
checkDensity(4.0, 0.5,
x, new double[]{
1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,
9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,
1.252205894e+00, 2.52142232809988});
checkDensity(4, 1,
x, new double[]{
4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,
2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,
2.048007680e+00, 2.916009720e+00});
checkDensity(4, 2,
x, new double[]{
1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,
7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,
2.047997440e+00, 1.457990280e+00});
checkDensity(4, 4,
x, new double[]{
1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,
1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,
5.734335488e-01, 1.020572784e-01});
private void checkDensity(double alpha, double beta, double[] x, double[] expected) {
BetaDistribution d = new BetaDistribution(alpha, beta);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);
public void testMoments() {
final double tol = 1e-9;
BetaDistribution dist;
dist = new BetaDistribution(1, 1);
Assert.assertEquals(dist.getNumericalMean(), 0.5, tol);
Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol);
dist = new BetaDistribution(2, 5);
Assert.assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);
Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol);
public void testMomentsSampling() {
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_1024_A,
123456789L);
final int numSamples = 1000;
for (final double alpha : alphaBetas) {
for (final double beta : alphaBetas) {
final BetaDistribution betaDistribution = new BetaDistribution(alpha, beta);
final double[] observed = AbstractRealDistribution.sample(numSamples,
betaDistribution.createSampler(rng));
Arrays.sort(observed);
final String distribution = String.format("Beta(%.2f, %.2f)", alpha, beta);
Assert.assertEquals(String.format("E[%s]", distribution),
betaDistribution.getNumericalMean(),
StatUtils.mean(observed), epsilon);
Assert.assertEquals(String.format("Var[%s]", distribution),
betaDistribution.getNumericalVariance(),
StatUtils.variance(observed), epsilon);
public void testGoodnessOfFit() {
final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_A,
123456789L);
final int numSamples = 1000;
final double level = 0.01;
for (final double alpha : alphaBetas) {
for (final double beta : alphaBetas) {
final BetaDistribution betaDistribution = new BetaDistribution(alpha, beta);
final RealDistribution.Sampler sampler = betaDistribution.createSampler(rng);
final double[] observed = AbstractRealDistribution.sample(numSamples, sampler);
Assert.assertFalse("G goodness-of-fit test rejected null at alpha = " + level,
gTest(betaDistribution, observed) < level);
Assert.assertFalse("KS goodness-of-fit test rejected null at alpha = " + level,
new KolmogorovSmirnovTest().kolmogorovSmirnovTest(betaDistribution, observed) < level);
private double gTest(final RealDistribution expectedDistribution, final double[] values) {
final int numBins = values.length / 30;
final double[] breaks = new double[numBins];
for (int b = 0; b < breaks.length; b++) {
breaks[b] = expectedDistribution.inverseCumulativeProbability((double) b / numBins);
final long[] observed = new long[numBins];
for (final double value : values) {
int b = 0;
do {
b++;
} while (b < numBins && value >= breaks[b]);
observed[b - 1]++;
final double[] expected = new double[numBins];
Arrays.fill(expected, (double) values.length / numBins);
return InferenceTestUtils.gTest(expected, observed);
package org.apache.commons.math4.distribution;
public class BinomialDistributionTest extends IntegerDistributionAbstractTest {
public BinomialDistributionTest() {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
return new BinomialDistribution(10, 0.70);
public int[] makeDensityTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
public double[] makeDensityTestValues() {
return new double[] { 0d, 0.0000059049d, 0.000137781d, 0.0014467005,
0.009001692, 0.036756909, 0.1029193452, 0.200120949, 0.266827932,
0.2334744405, 0.121060821, 0.0282475249, 0d };
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] { 0d, 5.9049e-06, 0.0001436859, 0.0015903864, 0.0105920784,  0.0473489874,
0.1502683326, 0.3503892816, 0.6172172136, 0.8506916541, 0.9717524751, 1d, 1d };
public double[] makeInverseCumulativeTestPoints() {
return new double[] { 0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d,
0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1 };
public int[] makeInverseCumulativeTestValues() {
return new int[] { 0, 2, 3, 4, 5, 5, 10, 10, 10, 9, 9, 10 };
public void testDegenerate0() {
BinomialDistribution dist = new BinomialDistribution(5, 0.0d);
setDistribution(dist);
setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });
setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });
setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });
setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });
setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });
setInverseCumulativeTestValues(new int[] { 0, 0 });
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 0);
Assert.assertEquals(dist.getSupportUpperBound(), 0);
public void testDegenerate1() {
BinomialDistribution dist = new BinomialDistribution(5, 1.0d);
setDistribution(dist);
setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });
setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });
setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });
setInverseCumulativeTestValues(new int[] { 5, 5 });
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 5);
Assert.assertEquals(dist.getSupportUpperBound(), 5);
public void testDegenerate2() {
BinomialDistribution dist = new BinomialDistribution(0, 0.01d);
setDistribution(dist);
setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d, 1d });
setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d, 0d });
setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });
setInverseCumulativeTestValues(new int[] { 0, 0 });
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 0);
Assert.assertEquals(dist.getSupportUpperBound(), 0);
public void testMoments() {
final double tol = 1e-9;
BinomialDistribution dist;
dist = new BinomialDistribution(10, 0.5);
Assert.assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol);
Assert.assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol);
dist = new BinomialDistribution(30, 0.3);
Assert.assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol);
Assert.assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol);
public void testMath718() {
for (int trials = 500000; trials < 20000000; trials += 100000) {
BinomialDistribution dist = new BinomialDistribution(trials, 0.5);
int p = dist.inverseCumulativeProbability(0.5);
Assert.assertEquals(trials / 2, p);
package org.apache.commons.math4.distribution;
public class CauchyDistributionTest extends RealDistributionAbstractTest {
protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;
public void setUp() {
super.setUp();
setTolerance(defaultTolerance);
public CauchyDistribution makeDistribution() {
return new CauchyDistribution(1.2, 2.1);
public double[] makeCumulativeTestPoints() {
return new double[] {-667.24856187, -65.6230835029, -25.4830299460, -12.0588781808,
-5.26313542807, 669.64856187, 68.0230835029, 27.8830299460, 14.4588781808, 7.66313542807};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,
0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437,
1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437};
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testMedian() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
Assert.assertEquals(1.2, distribution.getMedian(), 0.0);
public void testScale() {
CauchyDistribution distribution = (CauchyDistribution) getDistribution();
Assert.assertEquals(2.1, distribution.getScale(), 0.0);
public void testPreconditions() {
new CauchyDistribution(0, 0);
Assert.fail("Cannot have zero scale");
} catch (NotStrictlyPositiveException ex) {
new CauchyDistribution(0, -1);
Assert.fail("Cannot have negative scale");
} catch (NotStrictlyPositiveException ex) {
public void testMoments() {
CauchyDistribution dist;
dist = new CauchyDistribution(10.2, 0.15);
Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));
Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));
dist = new CauchyDistribution(23.12, 2.12);
Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));
Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));
package org.apache.commons.math4.distribution;
public class ChiSquaredDistributionTest extends RealDistributionAbstractTest {
public ChiSquaredDistribution makeDistribution() {
return new ChiSquaredDistribution(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,
20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1};
public double[] makeInverseCumulativeTestValues() {
return new double[] {0, 0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,
20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978,
Double.POSITIVE_INFINITY};
public double[] makeDensityTestValues() {
return new double[] {0.0115379817652, 0.0415948507811, 0.0665060119842, 0.0919455953114, 0.121472591024,
0.000433630076361, 0.00412780610309, 0.00999340341045, 0.0193246438937, 0.0368460089216};
public void setUp() {
super.setUp();
setTolerance(1e-9);
public void testSmallDf() {
setDistribution(new ChiSquaredDistribution(0.1d));
setTolerance(1E-4);
setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,
1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,
0.5318646, 0.1526342});
setInverseCumulativeTestValues(getCumulativeTestPoints());
setInverseCumulativeTestPoints(getCumulativeTestValues());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();
Assert.assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);
public void testDensity() {
double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};
checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});
checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});
checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});
checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});
private void checkDensity(double df, double[] x, double[] expected) {
ChiSquaredDistribution d = new ChiSquaredDistribution(df);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);
public void testMoments() {
final double tol = 1e-9;
ChiSquaredDistribution dist;
dist = new ChiSquaredDistribution(1500);
Assert.assertEquals(dist.getNumericalMean(), 1500, tol);
Assert.assertEquals(dist.getNumericalVariance(), 3000, tol);
dist = new ChiSquaredDistribution(1.12);
Assert.assertEquals(dist.getNumericalMean(), 1.12, tol);
Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol);
package org.apache.commons.math4.distribution;
public class ConstantRealDistributionTest extends RealDistributionAbstractTest {
public void setUp() {
super.setUp();
setTolerance(0);
public ConstantRealDistribution makeDistribution() {
return new ConstantRealDistribution(1);
public double[] makeCumulativeTestPoints() {
return new double[] {0, 0.5, 1};
public double[] makeCumulativeTestValues() {
return new double[] {0, 0, 1};
public double[] makeDensityTestValues() {
return new double[] {0, 0, 1};
public void testInverseCumulativeProbabilities() {
RealDistribution dist = getDistribution();
for (double x : getCumulativeTestValues()) {
Assert.assertEquals(1,dist.inverseCumulativeProbability(x), 0);
public void testMeanVariance() {
ConstantRealDistribution dist;
dist = new ConstantRealDistribution(-1);
Assert.assertEquals(dist.getNumericalMean(), -1, 0d);
Assert.assertEquals(dist.getNumericalVariance(), 0, 0d);
public void testSampler() {
final double value = 12.345;
final RealDistribution.Sampler sampler = new ConstantRealDistribution(value).createSampler(null);
for (int i = 0; i < 10; i++) {
Assert.assertEquals(value, sampler.sample(), 0);
RealDistribution.Sampler sampler
RealDistribution.Sampler sampler
final RealDistribution kernel = findKernel(lower, upper);
final RealDistribution kernel = findKernel(lower, upper);
RealDistribution.Sampler sampler
RealDistribution.Sampler sampler
private RealDistribution findKernel(double lower, double upper) {
RealDistribution.Sampler sampler
RealDistribution.Sampler sampler
protected RealDistribution getKernel(SummaryStatistics bStats) {
return new ConstantRealDistribution(bStats.getMean());
protected RealDistribution getKernel(SummaryStatistics bStats) {
return new UniformRealDistribution(bStats.getMin(), bStats.getMax());
Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);
Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);
final IntegerDistribution.Sampler sampler
Assert.assertEquals(testDistribution.getNumericalMean(),
Assert.assertEquals(testDistribution.getNumericalVariance(),
Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);
Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);
final RealDistribution.Sampler sampler =
Assert.assertEquals(testDistribution.getNumericalMean(),
Assert.assertEquals(testDistribution.getNumericalVariance(),
package org.apache.commons.math4.distribution;
public class ExponentialDistributionTest extends RealDistributionAbstractTest {
public void setUp() {
super.setUp();
setTolerance(1E-9);
public ExponentialDistribution makeDistribution() {
return new ExponentialDistribution(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.00500250166792, 0.0502516792675, 0.126589039921, 0.256466471938,
0.526802578289, 34.5387763949, 23.0258509299, 18.4443972706, 14.9786613678, 11.5129254650};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,
0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {0.1998, 0.198, 0.195, 0.19, 0.18, 0.000200000000000,
0.00200000000002, 0.00499999999997, 0.00999999999994, 0.0199999999999};
public void testCumulativeProbabilityExtremes() {
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testCumulativeProbability2() {
double actual = getDistribution().probability(0.25, 0.75);
Assert.assertEquals(0.0905214, actual, 10e-4);
public void testDensity() {
ExponentialDistribution d1 = new ExponentialDistribution(1);
Assert.assertTrue(Precision.equals(0.0, d1.density(-1e-9), 1));
Assert.assertTrue(Precision.equals(1.0, d1.density(0.0), 1));
Assert.assertTrue(Precision.equals(0.0, d1.density(1000.0), 1));
Assert.assertTrue(Precision.equals(FastMath.exp(-1), d1.density(1.0), 1));
Assert.assertTrue(Precision.equals(FastMath.exp(-2), d1.density(2.0), 1));
ExponentialDistribution d2 = new ExponentialDistribution(3);
Assert.assertTrue(Precision.equals(1/3.0, d2.density(0.0), 1));
Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8);
Assert.assertEquals(0.1711390397, d2.density(2.0), 1e-8);
public void testMeanAccessors() {
ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();
Assert.assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);
public void testPreconditions() {
new ExponentialDistribution(0);
public void testMoments() {
final double tol = 1e-9;
ExponentialDistribution dist;
dist = new ExponentialDistribution(11d);
Assert.assertEquals(dist.getNumericalMean(), 11d, tol);
Assert.assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);
dist = new ExponentialDistribution(10.5d);
Assert.assertEquals(dist.getNumericalMean(), 10.5d, tol);
Assert.assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);
package org.apache.commons.math4.distribution;
public class FDistributionTest extends RealDistributionAbstractTest {
public FDistribution makeDistribution() {
return new FDistribution(5.0, 6.0);
public double[] makeCumulativeTestPoints() {
return new double[] {0.0346808448626, 0.0937009113303, 0.143313661184, 0.202008445998, 0.293728320107,
20.8026639595, 8.74589525602, 5.98756512605, 4.38737418741, 3.10751166664};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {0.0689156576706, 0.236735653193, 0.364074131941, 0.481570789649, 0.595880479994,
0.000133443915657, 0.00286681303403, 0.00969192007502, 0.0242883861471, 0.0605491314658};
public void setUp() {
super.setUp();
setTolerance(1e-9);
public void testCumulativeProbabilityExtremes() {
setCumulativeTestPoints(new double[] {-2, 0});
setCumulativeTestValues(new double[] {0, 0});
verifyCumulativeProbabilities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testDfAccessors() {
FDistribution dist = (FDistribution) getDistribution();
Assert.assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);
Assert.assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);
public void testPreconditions() {
new FDistribution(0, 1);
Assert.fail("Expecting NotStrictlyPositiveException for df = 0");
} catch (NotStrictlyPositiveException ex) {
new FDistribution(1, 0);
Assert.fail("Expecting NotStrictlyPositiveException for df = 0");
} catch (NotStrictlyPositiveException ex) {
public void testLargeDegreesOfFreedom() {
FDistribution fd = new FDistribution(100000, 100000);
double p = fd.cumulativeProbability(.999);
double x = fd.inverseCumulativeProbability(p);
Assert.assertEquals(.999, x, 1.0e-5);
public void testSmallDegreesOfFreedom() {
FDistribution fd = new FDistribution(1, 1);
double p = fd.cumulativeProbability(0.975);
double x = fd.inverseCumulativeProbability(p);
Assert.assertEquals(0.975, x, 1.0e-5);
fd = new FDistribution(1, 2);
p = fd.cumulativeProbability(0.975);
x = fd.inverseCumulativeProbability(p);
Assert.assertEquals(0.975, x, 1.0e-5);
public void testMoments() {
final double tol = 1e-9;
FDistribution dist;
dist = new FDistribution(1, 2);
Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));
Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));
dist = new FDistribution(1, 3);
Assert.assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);
Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));
dist = new FDistribution(1, 5);
Assert.assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);
Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);
public void testMath785() {
double prob = 0.01;
FDistribution f = new FDistribution(200000, 200000);
double result = f.inverseCumulativeProbability(prob);
Assert.assertTrue(result < 1.0);
} catch (Exception e) {
Assert.fail("Failing to calculate inverse cumulative probability");
package org.apache.commons.math4.distribution;
public class GammaDistributionTest extends RealDistributionAbstractTest {
public GammaDistribution makeDistribution() {
return new GammaDistribution(4d, 2d);
public double[] makeCumulativeTestPoints() {
return new double[] {0.857104827257, 1.64649737269, 2.17973074725, 2.7326367935, 3.48953912565,
26.1244815584, 20.0902350297, 17.5345461395, 15.5073130559, 13.3615661365};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {0.00427280075546, 0.0204117166709, 0.0362756163658, 0.0542113174239, 0.0773195272491,
0.000394468852816, 0.00366559696761, 0.00874649473311, 0.0166712508128, 0.0311798227954};
public void setUp() {
super.setUp();
setTolerance(1e-9);
public void testParameterAccessors() {
GammaDistribution distribution = (GammaDistribution) getDistribution();
Assert.assertEquals(4d, distribution.getShape(), 0);
Assert.assertEquals(2d, distribution.getScale(), 0);
public void testPreconditions() {
new GammaDistribution(0, 1);
Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");
} catch (NotStrictlyPositiveException ex) {
new GammaDistribution(1, 0);
Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");
} catch (NotStrictlyPositiveException ex) {
public void testProbabilities() {
testProbability(-1.000, 4.0, 2.0, .0000);
testProbability(15.501, 4.0, 2.0, .9499);
testProbability(0.504, 4.0, 1.0, .0018);
testProbability(10.011, 1.0, 2.0, .9933);
testProbability(5.000, 2.0, 2.0, .7127);
public void testValues() {
testValue(15.501, 4.0, 2.0, .9499);
testValue(0.504, 4.0, 1.0, .0018);
testValue(10.011, 1.0, 2.0, .9933);
testValue(5.000, 2.0, 2.0, .7127);
private void testProbability(double x, double a, double b, double expected) {
GammaDistribution distribution = new GammaDistribution( a, b );
double actual = distribution.cumulativeProbability(x);
Assert.assertEquals("probability for " + x, expected, actual, 10e-4);
private void testValue(double expected, double a, double b, double p) {
GammaDistribution distribution = new GammaDistribution( a, b );
double actual = distribution.inverseCumulativeProbability(p);
Assert.assertEquals("critical value for " + p, expected, actual, 10e-4);
public void testDensity() {
double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};
checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});
checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});
checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});
checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});
checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});
checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});
checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});
checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});
private void checkDensity(double alpha, double rate, double[] x, double[] expected) {
GammaDistribution d = new GammaDistribution(alpha, 1 / rate);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testMoments() {
final double tol = 1e-9;
GammaDistribution dist;
dist = new GammaDistribution(1, 2);
Assert.assertEquals(dist.getNumericalMean(), 2, tol);
Assert.assertEquals(dist.getNumericalVariance(), 4, tol);
dist = new GammaDistribution(1.1, 4.2);
Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);
Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);
private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2.0 * FastMath.PI);
public static double logGamma(double x) {
double ret;
if (Double.isNaN(x) || (x <= 0.0)) {
ret = Double.NaN;
} else {
double sum = LanczosApproximation.value(x);
double tmp = x + LanczosApproximation.g() + .5;
ret = ((x + .5) * FastMath.log(tmp)) - tmp +
HALF_LOG_2_PI + FastMath.log(sum / x);
return ret;
public static double density(final double x, final double shape,
final double scale) {
if (x < 0) {
return 0;
return FastMath.pow(x / scale, shape - 1) / scale *
FastMath.exp(-x / scale) / FastMath.exp(logGamma(shape));
private void doTestMath753(final double shape,
final double meanNoOF, final double sdNoOF,
final double meanOF, final double sdOF,
final String resourceName) throws IOException {
final GammaDistribution distribution = new GammaDistribution(shape, 1.0);
final SummaryStatistics statOld = new SummaryStatistics();
final SummaryStatistics statNewNoOF = new SummaryStatistics();
final SummaryStatistics statNewOF = new SummaryStatistics();
final InputStream resourceAsStream;
resourceAsStream = this.getClass().getResourceAsStream(resourceName);
Assert.assertNotNull("Could not find resource " + resourceName,
resourceAsStream);
final BufferedReader in;
in = new BufferedReader(new InputStreamReader(resourceAsStream));
for (String line = in.readLine(); line != null; line = in.readLine()) {
if (line.startsWith("#")) {
continue;
final String[] tokens = line.split(", ");
Assert.assertTrue("expected two floating-point values",
tokens.length == 2);
final double x = Double.parseDouble(tokens[0]);
final String msg = "x = " + x + ", shape = " + shape +
", scale = 1.0";
final double expected = Double.parseDouble(tokens[1]);
final double ulp = FastMath.ulp(expected);
final double actualOld = density(x, shape, 1.0);
final double actualNew = distribution.density(x);
final double errOld, errNew;
errOld = FastMath.abs((actualOld - expected) / ulp);
errNew = FastMath.abs((actualNew - expected) / ulp);
if (Double.isNaN(actualOld) || Double.isInfinite(actualOld)) {
Assert.assertFalse(msg, Double.isNaN(actualNew));
Assert.assertFalse(msg, Double.isInfinite(actualNew));
statNewOF.addValue(errNew);
} else {
statOld.addValue(errOld);
statNewNoOF.addValue(errNew);
if (statOld.getN() != 0) {
final StringBuilder sb = new StringBuilder("shape = ");
sb.append(shape);
sb.append(", scale = 1.0\n");
sb.append("Old implementation\n");
sb.append("------------------\n");
sb.append(statOld.toString());
sb.append("New implementation\n");
sb.append("------------------\n");
sb.append(statNewNoOF.toString());
final String msg = sb.toString();
final double oldMin = statOld.getMin();
final double newMin = statNewNoOF.getMin();
Assert.assertTrue(msg, newMin <= oldMin);
final double oldMax = statOld.getMax();
final double newMax = statNewNoOF.getMax();
Assert.assertTrue(msg, newMax <= oldMax);
final double oldMean = statOld.getMean();
final double newMean = statNewNoOF.getMean();
Assert.assertTrue(msg, newMean <= oldMean);
final double oldSd = statOld.getStandardDeviation();
final double newSd = statNewNoOF.getStandardDeviation();
Assert.assertTrue(msg, newSd <= oldSd);
Assert.assertTrue(msg, newMean <= meanNoOF);
Assert.assertTrue(msg, newSd <= sdNoOF);
if (statNewOF.getN() != 0) {
final double newMean = statNewOF.getMean();
final double newSd = statNewOF.getStandardDeviation();
final StringBuilder sb = new StringBuilder("shape = ");
sb.append(shape);
sb.append(", scale = 1.0");
sb.append(", max. mean error (ulps) = ");
sb.append(meanOF);
sb.append(", actual mean error (ulps) = ");
sb.append(newMean);
sb.append(", max. sd of error (ulps) = ");
sb.append(sdOF);
sb.append(", actual sd of error (ulps) = ");
sb.append(newSd);
final String msg = sb.toString();
Assert.assertTrue(msg, newMean <= meanOF);
Assert.assertTrue(msg, newSd <= sdOF);
} catch (IOException e) {
Assert.fail(e.getMessage());
} finally {
in.close();
public void testMath753Shape1() throws IOException {
doTestMath753(1.0, 1.5, 0.5, 0.0, 0.0, "gamma-distribution-shape-1.csv");
public void testMath753Shape8() throws IOException {
doTestMath753(8.0, 1.5, 1.0, 0.0, 0.0, "gamma-distribution-shape-8.csv");
public void testMath753Shape10() throws IOException {
doTestMath753(10.0, 1.0, 1.0, 0.0, 0.0, "gamma-distribution-shape-10.csv");
public void testMath753Shape100() throws IOException {
doTestMath753(100.0, 1.5, 1.0, 0.0, 0.0, "gamma-distribution-shape-100.csv");
public void testMath753Shape142() throws IOException {
doTestMath753(142.0, 3.3, 1.6, 40.0, 40.0, "gamma-distribution-shape-142.csv");
public void testMath753Shape1000() throws IOException {
doTestMath753(1000.0, 1.0, 1.0, 160.0, 220.0, "gamma-distribution-shape-1000.csv");
package org.apache.commons.math4.distribution;
public class GeometricDistributionTest extends IntegerDistributionAbstractTest {
public GeometricDistributionTest() {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
return new GeometricDistribution(0.40);
public int[] makeDensityTestPoints() {
return new int[] { -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,
9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
19, 20, 21, 22, 23, 24, 25, 26, 27, 28 };
public double[] makeDensityTestValues() {
return new double[] {
0d, 0.4, 0.24, 0.144, 0.0864, 0.05184, 0.031104, 0.0186624,
0.01119744, 0.006718464, 0.0040310784, 0.00241864704,
0.001451188224,0.0008707129344, 0.00052242776064, 0.000313456656384,
0.00018807399383, 0.000112844396298, 6.77066377789e-05, 4.06239826674e-05,
2.43743896004e-05, 1.46246337603e-05, 8.77478025615e-06, 5.26486815369e-06,
3.15892089221e-06, 1.89535253533e-06, 1.1372115212e-06, 6.82326912718e-07,
4.09396147631e-07, 2.45637688579e-07
};
public double[] makeLogDensityTestValues() {
return new double[] {
Double.NEGATIVE_INFINITY, -0.916290731874155, -1.42711635564015, -1.93794197940614,
-2.44876760317213, -2.95959322693812, -3.47041885070411, -3.9812444744701,
-4.49207009823609, -5.00289572200208, -5.51372134576807, -6.02454696953406,
-6.53537259330005, -7.04619821706604, -7.55702384083203, -8.06784946459802,
-8.57867508836402, -9.08950071213001, -9.600326335896, -10.111151959662,
-10.621977583428, -11.132803207194, -11.64362883096, -12.154454454726,
-12.6652800784919, -13.1761057022579, -13.6869313260239, -14.1977569497899,
-14.7085825735559, -15.2194081973219
};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
final double[] densities = makeDensityTestValues();
final int n = densities.length;
final double[] ret = new double[n];
ret[0] = densities[0];
for (int i = 1; i < n; i++) {
ret[i] = ret[i - 1] + densities[i];
return ret;
public double[] makeInverseCumulativeTestPoints() {
return new double[] {
0.000, 0.005, 0.010, 0.015, 0.020, 0.025, 0.030, 0.035, 0.040,
0.045, 0.050, 0.055, 0.060, 0.065, 0.070, 0.075, 0.080, 0.085,
0.090, 0.095, 0.100, 0.105, 0.110, 0.115, 0.120, 0.125, 0.130,
0.135, 0.140, 0.145, 0.150, 0.155, 0.160, 0.165, 0.170, 0.175,
0.180, 0.185, 0.190, 0.195, 0.200, 0.205, 0.210, 0.215, 0.220,
0.225, 0.230, 0.235, 0.240, 0.245, 0.250, 0.255, 0.260, 0.265,
0.270, 0.275, 0.280, 0.285, 0.290, 0.295, 0.300, 0.305, 0.310,
0.315, 0.320, 0.325, 0.330, 0.335, 0.340, 0.345, 0.350, 0.355,
0.360, 0.365, 0.370, 0.375, 0.380, 0.385, 0.390, 0.395, 0.400,
0.405, 0.410, 0.415, 0.420, 0.425, 0.430, 0.435, 0.440, 0.445,
0.450, 0.455, 0.460, 0.465, 0.470, 0.475, 0.480, 0.485, 0.490,
0.495, 0.500, 0.505, 0.510, 0.515, 0.520, 0.525, 0.530, 0.535,
0.540, 0.545, 0.550, 0.555, 0.560, 0.565, 0.570, 0.575, 0.580,
0.585, 0.590, 0.595, 0.600, 0.605, 0.610, 0.615, 0.620, 0.625,
0.630, 0.635, 0.640, 0.645, 0.650, 0.655, 0.660, 0.665, 0.670,
0.675, 0.680, 0.685, 0.690, 0.695, 0.700, 0.705, 0.710, 0.715,
0.720, 0.725, 0.730, 0.735, 0.740, 0.745, 0.750, 0.755, 0.760,
0.765, 0.770, 0.775, 0.780, 0.785, 0.790, 0.795, 0.800, 0.805,
0.810, 0.815, 0.820, 0.825, 0.830, 0.835, 0.840, 0.845, 0.850,
0.855, 0.860, 0.865, 0.870, 0.875, 0.880, 0.885, 0.890, 0.895,
0.900, 0.905, 0.910, 0.915, 0.920, 0.925, 0.930, 0.935, 0.940,
0.945, 0.950, 0.955, 0.960, 0.965, 0.970, 0.975, 0.980, 0.985,
0.990, 0.995, 1.000
};
public int[] makeInverseCumulativeTestValues() {
return new int[] {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
5, 5, 6, 6, 6, 6, 7, 7, 8, 9, 10, Integer.MAX_VALUE
};
public void testMoments() {
final double tol = 1e-9;
GeometricDistribution dist;
dist = new GeometricDistribution(0.5);
Assert.assertEquals(dist.getNumericalMean(), (1.0d - 0.5d) / 0.5d, tol);
Assert.assertEquals(dist.getNumericalVariance(), (1.0d - 0.5d) / (0.5d * 0.5d), tol);
dist = new GeometricDistribution(0.3);
Assert.assertEquals(dist.getNumericalMean(), (1.0d - 0.3d) / 0.3d, tol);
Assert.assertEquals(dist.getNumericalVariance(), (1.0d - 0.3d) / (0.3d * 0.3d), tol);
package org.apache.commons.math4.distribution;
public class GumbelDistributionTest extends RealDistributionAbstractTest {
public void testParameters() {
GumbelDistribution d = makeDistribution();
Assert.assertEquals(0.5, d.getLocation(), Precision.EPSILON);
Assert.assertEquals(2, d.getScale(), Precision.EPSILON);
public void testSupport() {
GumbelDistribution d = makeDistribution();
Assert.assertTrue(Double.isInfinite(d.getSupportLowerBound()));
Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));
Assert.assertTrue(d.isSupportConnected());
public GumbelDistribution makeDistribution() {
return new GumbelDistribution(0.5, 2);
public double[] makeCumulativeTestPoints() {
return new double[] {
-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5
};
public double[] makeDensityTestValues() {
return new double[] {
1.258262e-06, 3.594689e-04, 9.115766e-03, 5.321100e-02, 1.274352e-01, 1.777864e-01,
1.787177e-01, 1.472662e-01, 1.075659e-01, 7.302736e-02, 4.742782e-02
};
public double[] makeCumulativeTestValues() {
return new double[] {
1.608760e-07, 7.577548e-05, 3.168165e-03, 3.049041e-02, 1.203923e-01, 2.769203e-01,
4.589561e-01, 6.235249e-01, 7.508835e-01, 8.404869e-01, 8.999652e-01
};
package org.apache.commons.math4.distribution;
public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {
public HypergeometricDistributionTest() {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
return new HypergeometricDistribution(10, 5, 5);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};
public double[] makeDensityTestValues() {
return new double[] {0d, 0.00396825396825, 0.0992063492063, 0.396825396825, 0.396825396825,
0.0992063492063, 0.00396825396825, 0d};
public double[] makeLogDensityTestValues() {
return new double[] {Double.NEGATIVE_INFINITY, -5.52942908751142, -2.31055326264322, -0.924258901523332,
-0.924258901523332, -2.31055326264322, -5.52942908751142, Double.NEGATIVE_INFINITY};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0d, 0.00396825396825, 0.103174603175, .5, 0.896825396825, 0.996031746032,
1, 1};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1d};
public int[] makeInverseCumulativeTestValues() {
return new int[] {0, 0, 1, 1, 1, 1, 5, 4, 4, 4, 4, 5};
public void testDegenerateNoFailures() {
HypergeometricDistribution dist = new HypergeometricDistribution(5,5,3);
setDistribution(dist);
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {3, 3});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 3);
Assert.assertEquals(dist.getSupportUpperBound(), 3);
public void testDegenerateNoSuccesses() {
HypergeometricDistribution dist = new HypergeometricDistribution(5,0,3);
setDistribution(dist);
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {0, 0});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 0);
Assert.assertEquals(dist.getSupportUpperBound(), 0);
public void testDegenerateFullSample() {
HypergeometricDistribution dist = new HypergeometricDistribution(5,3,5);
setDistribution(dist);
setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {3, 3});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
Assert.assertEquals(dist.getSupportLowerBound(), 3);
Assert.assertEquals(dist.getSupportUpperBound(), 3);
public void testPreconditions() {
new HypergeometricDistribution(0, 3, 5);
Assert.fail("negative population size. NotStrictlyPositiveException expected");
} catch(NotStrictlyPositiveException ex) {
new HypergeometricDistribution(5, -1, 5);
Assert.fail("negative number of successes. NotPositiveException expected");
} catch(NotPositiveException ex) {
new HypergeometricDistribution(5, 3, -1);
Assert.fail("negative sample size. NotPositiveException expected");
} catch(NotPositiveException ex) {
new HypergeometricDistribution(5, 6, 5);
Assert.fail("numberOfSuccesses > populationSize. NumberIsTooLargeException expected");
} catch(NumberIsTooLargeException ex) {
new HypergeometricDistribution(5, 3, 6);
Assert.fail("sampleSize > populationSize. NumberIsTooLargeException expected");
} catch(NumberIsTooLargeException ex) {
public void testAccessors() {
HypergeometricDistribution dist = new HypergeometricDistribution(5, 3, 4);
Assert.assertEquals(5, dist.getPopulationSize());
Assert.assertEquals(3, dist.getNumberOfSuccesses());
Assert.assertEquals(4, dist.getSampleSize());
public void testLargeValues() {
int populationSize = 3456;
int sampleSize = 789;
int numberOfSucceses = 101;
double[][] data = {
{0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},
{1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},
{2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},
{3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},
{4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},
{5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},
{20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},
{21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},
{22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},
{23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},
{24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},
{25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},
{96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},
{97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},
{98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},
{99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},
{100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},
{101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},
};
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {
HypergeometricDistribution dist = new HypergeometricDistribution(populationSize, numberOfSucceses, sampleSize);
for (int i = 0; i < data.length; ++i) {
int x = (int)data[i][0];
double pmf = data[i][1];
double actualPmf = dist.probability(x);
TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pmf",pmf, actualPmf, 1.0e-9);
double cdf = data[i][2];
double actualCdf = dist.cumulativeProbability(x);
TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf",cdf, actualCdf, 1.0e-9);
double cdf1 = data[i][3];
double actualCdf1 = dist.upperCumulativeProbability(x);
TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf1",cdf1, actualCdf1, 1.0e-9);
public void testMoreLargeValues() {
int populationSize = 26896;
int sampleSize = 895;
int numberOfSucceses = 55;
double[][] data = {
{0.0, 0.155168304750504, 0.155168304750504, 1.0},
{1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},
{2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},
{3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},
{4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},
{5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},
{20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},
{21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},
{22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},
{23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},
{24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},
{25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},
{50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},
{51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},
{52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},
{53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},
{54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},
{55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},
};
testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);
public void testMoments() {
final double tol = 1e-9;
HypergeometricDistribution dist;
dist = new HypergeometricDistribution(1500, 40, 100);
Assert.assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);
Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol);
dist = new HypergeometricDistribution(3000, 55, 200);
Assert.assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);
Assert.assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);
public void testMath644() {
int N = 14761461;  // population
int m = 1035;      // successes in population
int n = 1841;      // number of trials
int k = 0;
final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);
Assert.assertTrue(Precision.compareTo(1.0, dist.upperCumulativeProbability(k), 1) == 0);
Assert.assertTrue(Precision.compareTo(dist.cumulativeProbability(k), 0.0, 1) > 0);
double upper = 1.0 - dist.cumulativeProbability(k) + dist.probability(k);
Assert.assertTrue(Precision.compareTo(1.0, upper, 1) == 0);
public void testZeroTrial() {
final int n = 11; // population
final int m = 4;  // successes in population
final int s = 0;  // number of trials
final HypergeometricDistribution dist = new HypergeometricDistribution(n, m, 0);
for (int i = 1; i <= n; i++) {
final double p = dist.probability(i);
Assert.assertEquals("p=" + p, 0, p, 0d);
public void testMath1356() {
final int n = 11;  // population
final int m = 11;  // successes in population
for (int s = 0; s <= n; s++) {
final HypergeometricDistribution dist = new HypergeometricDistribution(n, m, s);
final double p = dist.probability(s);
Assert.assertEquals("p=" + p, 1, p, 0d);
public void testMath1021() {
final int N = 43130568;
final int m = 42976365;
final int n = 50;
final IntegerDistribution.Sampler dist =
new HypergeometricDistribution(N, m, n).createSampler(RandomSource.create(RandomSource.WELL_512_A));
for (int i = 0; i < 100; i++) {
final int sample = dist.sample();
Assert.assertTrue("sample=" + sample, 0 <= sample);
Assert.assertTrue("sample=" + sample, sample <= n);
package org.apache.commons.math4.distribution;
public class LaplaceDistributionTest extends RealDistributionAbstractTest {
public void testParameters() {
LaplaceDistribution d = makeDistribution();
Assert.assertEquals(0, d.getLocation(), Precision.EPSILON);
Assert.assertEquals(1, d.getScale(), Precision.EPSILON);
public void testSupport() {
LaplaceDistribution d = makeDistribution();
Assert.assertTrue(Double.isInfinite(d.getSupportLowerBound()));
Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));
Assert.assertTrue(d.isSupportConnected());
public LaplaceDistribution makeDistribution() {
return new LaplaceDistribution(0, 1);
public double[] makeCumulativeTestPoints() {
return new double[] {
-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5
};
public double[] makeDensityTestValues() {
return new double[] {
0.003368973, 0.009157819, 0.024893534, 0.067667642, 0.183939721,
0.500000000, 0.183939721, 0.067667642, 0.024893534, 0.009157819, 0.003368973
};
public double[] makeCumulativeTestValues() {
return new double[] {
0.003368973, 0.009157819, 0.024893534, 0.067667642, 0.183939721,
0.500000000, 0.816060279, 0.932332358, 0.975106466, 0.990842181, 0.996631027
};
package org.apache.commons.math4.distribution;
public class LevyDistributionTest extends RealDistributionAbstractTest {
public void testParameters() {
LevyDistribution d = makeDistribution();
Assert.assertEquals(1.2, d.getLocation(), Precision.EPSILON);
Assert.assertEquals(0.4,   d.getScale(),  Precision.EPSILON);
public void testSupport() {
LevyDistribution d = makeDistribution();
Assert.assertEquals(d.getLocation(), d.getSupportLowerBound(), Precision.EPSILON);
Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));
Assert.assertTrue(d.isSupportConnected());
public LevyDistribution makeDistribution() {
return new LevyDistribution(1.2, 0.4);
public double[] makeCumulativeTestPoints() {
return new double[] {
1.2001, 1.21, 1.225, 1.25, 1.3, 1.9, 3.4, 5.6
};
public double[] makeCumulativeTestValues() {
return new double[] {
0, 2.53962850749e-10, 6.33424836662e-05, 0.00467773498105,
0.0455002638964, 0.449691797969, 0.669815357599, 0.763024600553
};
public double[] makeDensityTestValues() {
return new double[] {
0, 5.20056373765e-07, 0.0214128361224, 0.413339707082, 1.07981933026,
0.323749319161, 0.0706032550094, 0.026122839884
};
public double[] makeLogDensityTestValues() {
return new double[] {
-1987.561573341398d, -14.469328620160d, -3.843764717971d,
-0.883485488811d, 0.076793740349d, -1.127785768948d,
-2.650679030597d, -3.644945255983d};
package org.apache.commons.math4.distribution;
public class LogNormalDistributionTest extends RealDistributionAbstractTest {
public LogNormalDistribution makeDistribution() {
return new LogNormalDistribution(2.1, 1.4);
public double[] makeCumulativeTestPoints() {
return new double[] { -2.226325228634938, -1.156887023657177,
-0.643949578356075, -0.2027950777320613,
0.305827808237559, 6.42632522863494,
5.35688702365718, 4.843949578356074,
4.40279507773206, 3.89417219176244 };
public double[] makeCumulativeTestValues() {
return new double[] { 0, 0, 0, 0, 0.00948199951485, 0.432056525076,
0.381648158697, 0.354555726206, 0.329513316888,
0.298422824228 };
public double[] makeDensityTestValues() {
return new double[] { 0, 0, 0, 0, 0.0594218160072, 0.0436977691036,
0.0508364857798, 0.054873528325, 0.0587182664085,
0.0636229042785 };
public double[] makeInverseCumulativeTestPoints() {
double[] points = makeCumulativeTestValues();
double[] points2 = new double[points.length - 4];
System.arraycopy(points, 4, points2, 0, points2.length - 4);
return points2;
public double[] makeInverseCumulativeTestValues() {
double[] points = makeCumulativeTestPoints();
double[] points2 = new double[points.length - 4];
System.arraycopy(points, 4, points2, 0, points2.length - 4);
return points2;
public void setUp() {
super.setUp();
setTolerance(LogNormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
private void verifyQuantiles() {
LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();
double mu = distribution.getScale();
double sigma = distribution.getShape();
setCumulativeTestPoints( new double[] { mu - 2 *sigma, mu - sigma,
mu, mu + sigma, mu + 2 * sigma,
mu + 3 * sigma,mu + 4 * sigma,
mu + 5 * sigma });
verifyCumulativeProbabilities();
public void testQuantiles() {
setCumulativeTestValues(new double[] {0, 0.0396495152787,
0.16601209243, 0.272533253269,
0.357618409638, 0.426488363093,
0.483255136841, 0.530823013877});
setDensityTestValues(new double[] {0, 0.0873055825147, 0.0847676303432,
0.0677935186237, 0.0544105523058,
0.0444614628804, 0.0369750288945,
0.0312206409653});
verifyQuantiles();
verifyDensities();
setDistribution(new LogNormalDistribution(0, 1));
setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.755891404214,
0.864031392359, 0.917171480998,
0.946239689548});
setDensityTestValues(new double[] {0, 0, 0, 0.398942280401,
0.156874019279, 0.07272825614,
0.0381534565119, 0.0218507148303});
verifyQuantiles();
verifyDensities();
setDistribution(new LogNormalDistribution(0, 0.1));
setCumulativeTestValues(new double[] {0, 0, 0, 1.28417563064e-117,
1.39679883412e-58,
1.09839325447e-33,
2.52587961726e-20,
2.0824223487e-12});
setDensityTestValues(new double[] {0, 0, 0, 2.96247992535e-114,
1.1283370232e-55, 4.43812313223e-31,
5.85346445002e-18,
2.9446618076e-10});
verifyQuantiles();
verifyDensities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testGetScale() {
LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();
Assert.assertEquals(2.1, distribution.getScale(), 0);
public void testGetShape() {
LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();
Assert.assertEquals(1.4, distribution.getShape(), 0);
public void testPreconditions() {
new LogNormalDistribution(1, 0);
public void testDensity() {
double [] x = new double[]{-2, -1, 0, 1, 2};
checkDensity(0, 1, x, new double[] { 0.0000000000, 0.0000000000,
0.0000000000, 0.3989422804,
0.1568740193 });
checkDensity(1.1, 1, x, new double[] { 0.0000000000, 0.0000000000,
0.0000000000, 0.2178521770,
0.1836267118});
private void checkDensity(double scale, double shape, double[] x,
double[] expected) {
LogNormalDistribution d = new LogNormalDistribution(scale, shape);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);
public void testExtremeValues() {
LogNormalDistribution d = new LogNormalDistribution(0, 1);
for (int i = 0; i < 1e5; i++) { // make sure no convergence exception
double upperTail = d.cumulativeProbability(i);
if (i <= 72) { // make sure not top-coded
Assert.assertTrue(upperTail < 1.0d);
else { // make sure top coding not reversed
Assert.assertTrue(upperTail > 0.99999);
Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0);
Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0);
Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);
Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);
public void testMeanVariance() {
final double tol = 1e-9;
LogNormalDistribution dist;
dist = new LogNormalDistribution(0, 1);
Assert.assertEquals(dist.getNumericalMean(), 1.6487212707001282, tol);
Assert.assertEquals(dist.getNumericalVariance(),
4.670774270471604, tol);
dist = new LogNormalDistribution(2.2, 1.4);
Assert.assertEquals(dist.getNumericalMean(), 24.046753552064498, tol);
Assert.assertEquals(dist.getNumericalVariance(),
3526.913651880464, tol);
dist = new LogNormalDistribution(-2000.9, 10.4);
Assert.assertEquals(dist.getNumericalMean(), 0.0, tol);
Assert.assertEquals(dist.getNumericalVariance(), 0.0, tol);
public void testTinyVariance() {
LogNormalDistribution dist = new LogNormalDistribution(0, 1e-9);
double t = dist.getNumericalVariance();
Assert.assertEquals(1e-18, t, 1e-20);
package org.apache.commons.math4.distribution;
public class LogisticsDistributionTest extends RealDistributionAbstractTest {
public void testParameters() {
LogisticDistribution d = makeDistribution();
Assert.assertEquals(2, d.getLocation(), Precision.EPSILON);
Assert.assertEquals(5, d.getScale(), Precision.EPSILON);
public void testSupport() {
LogisticDistribution d = makeDistribution();
Assert.assertTrue(Double.isInfinite(d.getSupportLowerBound()));
Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));
Assert.assertTrue(d.isSupportConnected());
public LogisticDistribution makeDistribution() {
return new LogisticDistribution(2, 5);
public double[] makeCumulativeTestPoints() {
return new double[] {
-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5
};
public double[] makeDensityTestValues() {
return new double[] {
0.03173698, 0.03557889, 0.03932239, 0.04278194, 0.04575685, 0.04805215,
0.04950331, 0.05000000, 0.04950331, 0.04805215, 0.04575685
};
public double[] makeCumulativeTestValues() {
return new double[] {
0.1978161, 0.2314752, 0.2689414, 0.3100255, 0.3543437, 0.4013123,
0.4501660, 0.5000000, 0.5498340, 0.5986877, 0.6456563
};
package org.apache.commons.math4.distribution;
public class NakagamiDistributionTest extends RealDistributionAbstractTest {
public void testParameters() {
NakagamiDistribution d = makeDistribution();
Assert.assertEquals(0.5, d.getShape(), Precision.EPSILON);
Assert.assertEquals(1, d.getScale(), Precision.EPSILON);
public void testSupport() {
NakagamiDistribution d = makeDistribution();
Assert.assertEquals(d.getSupportLowerBound(), 0, Precision.EPSILON);
Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));
Assert.assertTrue(d.isSupportConnected());
public NakagamiDistribution makeDistribution() {
return new NakagamiDistribution(0.5, 1);
public double[] makeCumulativeTestPoints() {
return new double[] {
0, 0.2, 0.4, 0.6, 0.8, 1, 1.2, 1.4, 1.6, 1.8, 2
};
public double[] makeDensityTestValues() {
return new double[] {
0.0000000, 0.7820854, 0.7365403, 0.6664492, 0.5793831, 0.4839414,
0.3883721, 0.2994549, 0.2218417, 0.1579003, 0.1079819
};
public double[] makeCumulativeTestValues() {
return new double[] {
0.0000000, 0.1585194, 0.3108435, 0.4514938, 0.5762892, 0.6826895,
0.7698607, 0.8384867, 0.8904014, 0.9281394, 0.9544997
};
package org.apache.commons.math4.distribution;
public class NormalDistributionTest extends RealDistributionAbstractTest {
public NormalDistribution makeDistribution() {
return new NormalDistribution(2.1, 1.4);
public double[] makeCumulativeTestPoints() {
return new double[] {-2.226325228634938d, -1.156887023657177d, -0.643949578356075d, -0.2027950777320613d, 0.305827808237559d,
6.42632522863494d, 5.35688702365718d, 4.843949578356074d, 4.40279507773206d, 3.89417219176244d};
public double[] makeCumulativeTestValues() {
return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d};
public double[] makeDensityTestValues() {
return new double[] {0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380,
0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380};
protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;
public void setUp() {
super.setUp();
setTolerance(defaultTolerance);
private void verifyQuantiles() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
double mu = distribution.getMean();
double sigma = distribution.getStandardDeviation();
setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,
mu, mu + sigma, mu + 2 * sigma,  mu + 3 * sigma, mu + 4 * sigma,
mu + 5 * sigma});
setCumulativeTestValues(new double[] {0.02275013194817921, 0.158655253931457, 0.5, 0.841344746068543,
0.977249868051821, 0.99865010196837, 0.999968328758167,  0.999999713348428});
verifyCumulativeProbabilities();
public void testQuantiles() {
setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808,
0.00316560600853, 9.55930184035e-05, 1.06194251052e-06});
verifyQuantiles();
verifyDensities();
setDistribution(new NormalDistribution(0, 1));
setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132,
0.00443184841194, 0.000133830225765, 1.48671951473e-06});
verifyQuantiles();
verifyDensities();
setDistribution(new NormalDistribution(0, 0.1));
setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519,
0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05});
verifyQuantiles();
verifyDensities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testCumulativeProbability() {
final RealDistribution dist = new NormalDistribution(0, 1);
double x = -10;
double expected = 7.61985e-24;
double v = dist.cumulativeProbability(x);
double tol = 1e-5;
Assert.assertEquals(1, v / expected, 1e-5);
public void testGetMean() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
Assert.assertEquals(2.1, distribution.getMean(), 0);
public void testGetStandardDeviation() {
NormalDistribution distribution = (NormalDistribution) getDistribution();
Assert.assertEquals(1.4, distribution.getStandardDeviation(), 0);
public void testPreconditions() {
new NormalDistribution(1, 0);
public void testDensity() {
double [] x = new double[]{-2, -1, 0, 1, 2};
checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});
checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});
private void checkDensity(double mean, double sd, double[] x, double[] expected) {
NormalDistribution d = new NormalDistribution(mean, sd);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);
public void testExtremeValues() {
NormalDistribution distribution = new NormalDistribution(0, 1);
for (int i = 0; i < 100; i++) { // make sure no convergence exception
double lowerTail = distribution.cumulativeProbability(-i);
double upperTail = distribution.cumulativeProbability(i);
if (i < 9) { // make sure not top-coded
Assert.assertTrue(lowerTail > 0.0d);
Assert.assertTrue(upperTail < 1.0d);
else { // make sure top coding not reversed
Assert.assertTrue(lowerTail < 0.00001);
Assert.assertTrue(upperTail > 0.99999);
Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);
Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);
Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);
Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);
public void testMath280() {
NormalDistribution normal = new NormalDistribution(0,1);
double result = normal.inverseCumulativeProbability(0.9986501019683698);
Assert.assertEquals(3.0, result, defaultTolerance);
result = normal.inverseCumulativeProbability(0.841344746068543);
Assert.assertEquals(1.0, result, defaultTolerance);
result = normal.inverseCumulativeProbability(0.9999683287581673);
Assert.assertEquals(4.0, result, defaultTolerance);
result = normal.inverseCumulativeProbability(0.9772498680518209);
Assert.assertEquals(2.0, result, defaultTolerance);
public void testMoments() {
final double tol = 1e-9;
NormalDistribution dist;
dist = new NormalDistribution(0, 1);
Assert.assertEquals(dist.getNumericalMean(), 0, tol);
Assert.assertEquals(dist.getNumericalVariance(), 1, tol);
dist = new NormalDistribution(2.2, 1.4);
Assert.assertEquals(dist.getNumericalMean(), 2.2, tol);
Assert.assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);
dist = new NormalDistribution(-2000.9, 10.4);
Assert.assertEquals(dist.getNumericalMean(), -2000.9, tol);
Assert.assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);
package org.apache.commons.math4.distribution;
public class ParetoDistributionTest extends RealDistributionAbstractTest {
public ParetoDistribution makeDistribution() {
return new ParetoDistribution(2.1, 1.4);
public double[] makeCumulativeTestPoints() {
return new double[] { -2.226325228634938, -1.156887023657177, -0.643949578356075, -0.2027950777320613, 0.305827808237559,
+6.42632522863494, 5.35688702365718, 4.843949578356074, 4.40279507773206, 3.89417219176244 };
public double[] makeCumulativeTestValues() {
return new double[] { 0, 0, 0, 0, 0, 0.791089998892, 0.730456085931, 0.689667290488, 0.645278794701, 0.578763688757 };
public double[] makeDensityTestValues() {
return new double[] { 0, 0, 0, 0, 0, 0.0455118580441, 0.070444173646, 0.0896924681582, 0.112794186114, 0.151439332084 };
public double[] makeInverseCumulativeTestPoints() {
double[] points = makeCumulativeTestValues();
double[] points2 = new double[points.length - 5];
System.arraycopy(points, 5, points2, 0, points.length - 5);
return points2;
public double[] makeInverseCumulativeTestValues() {
double[] points = makeCumulativeTestPoints();
double[] points2 = new double[points.length - 5];
System.arraycopy(points, 5, points2, 0, points.length - 5);
return points2;
public void setUp() {
super.setUp();
setTolerance(ParetoDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
private void verifyQuantiles() {
ParetoDistribution distribution = (ParetoDistribution)getDistribution();
double mu = distribution.getScale();
double sigma = distribution.getShape();
setCumulativeTestPoints( new double[] { mu - 2 *sigma,  mu - sigma,
mu,             mu + sigma,
mu + 2 * sigma, mu + 3 * sigma,
mu + 4 * sigma, mu + 5 * sigma });
verifyCumulativeProbabilities();
public void testQuantiles() {
setCumulativeTestValues(new double[] {0, 0, 0, 0.510884134236, 0.694625688662, 0.785201995008, 0.837811522357, 0.871634279326});
setDensityTestValues(new double[] {0, 0, 0.666666666, 0.195646346305, 0.0872498032394, 0.0477328899983, 0.0294888141169, 0.0197485724114});
verifyQuantiles();
verifyDensities();
setDistribution(new ParetoDistribution(1, 1));
setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.666666666667, 0.75, 0.8, 0.833333333333});
setDensityTestValues(new double[] {0, 0, 1.0, 0.25, 0.111111111111, 0.0625, 0.04, 0.0277777777778});
verifyQuantiles();
verifyDensities();
setDistribution(new ParetoDistribution(0.1, 0.1));
setCumulativeTestValues(new double[] {0, 0, 0, 0.0669670084632, 0.104041540159, 0.129449436704, 0.148660077479, 0.164041197922});
setDensityTestValues(new double[] {0, 0, 1.0, 0.466516495768, 0.298652819947, 0.217637640824, 0.170267984504, 0.139326467013});
verifyQuantiles();
verifyDensities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(new double[] {2.1, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testGetScale() {
ParetoDistribution distribution = (ParetoDistribution)getDistribution();
Assert.assertEquals(2.1, distribution.getScale(), 0);
public void testGetShape() {
ParetoDistribution distribution = (ParetoDistribution)getDistribution();
Assert.assertEquals(1.4, distribution.getShape(), 0);
public void testPreconditions() {
new ParetoDistribution(1, 0);
public void testDensity() {
double [] x = new double[]{-2, -1, 0, 1, 2};
checkDensity(1, 1, x, new double[] { 0.00, 0.00, 0.00, 1.00, 0.25 });
checkDensity(1.1, 1, x, new double[] { 0.000, 0.000, 0.000, 0.000, 0.275 });
private void checkDensity(double scale, double shape, double[] x,
double[] expected) {
ParetoDistribution d = new ParetoDistribution(scale, shape);
for (int i = 0; i < x.length; i++) {
Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);
public void testExtremeValues() {
ParetoDistribution d = new ParetoDistribution(1, 1);
for (int i = 0; i < 1e5; i++) { // make sure no convergence exception
double upperTail = d.cumulativeProbability(i);
if (i <= 1000) { // make sure not top-coded
Assert.assertTrue(upperTail < 1.0d);
else { // make sure top coding not reversed
Assert.assertTrue(upperTail > 0.999);
Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0);
Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0);
Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);
Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);
public void testMeanVariance() {
final double tol = 1e-9;
ParetoDistribution dist;
dist = new ParetoDistribution(1, 1);
Assert.assertEquals(dist.getNumericalMean(), Double.POSITIVE_INFINITY, tol);
Assert.assertEquals(dist.getNumericalVariance(), Double.POSITIVE_INFINITY, tol);
dist = new ParetoDistribution(2.2, 2.4);
Assert.assertEquals(dist.getNumericalMean(), 3.771428571428, tol);
Assert.assertEquals(dist.getNumericalVariance(), 14.816326530, tol);
package org.apache.commons.math4.distribution;
public class PascalDistributionTest extends IntegerDistributionAbstractTest {
protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;
public void setUp() {
super.setUp();
setTolerance(defaultTolerance);
public IntegerDistribution makeDistribution() {
return new PascalDistribution(10,0.70);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
return new double[] {0, 0.0282475249, 0.0847425747, 0.139825248255, 0.167790297906, 0.163595540458,
0.137420253985, 0.103065190489, 0.070673273478, 0.0450542118422, 0.0270325271053,
0.0154085404500, 0.0084046584273};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0, 0.0282475249, 0.1129900996, 0.252815347855, 0.420605645761, 0.584201186219,
0.721621440204, 0.824686630693, 0.895359904171, 0.940414116013, 0.967446643119,
0.982855183569, 0.991259841996};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0.0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.999,
0.990, 0.975, 0.950, 0.900, 1.0};
public int[] makeInverseCumulativeTestValues() {
return new int[] {0, 0, 0, 0, 1, 1, 14, 11, 10, 9, 8, Integer.MAX_VALUE};
public void testDegenerate0() {
setDistribution(new PascalDistribution(5, 0.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE, Integer.MAX_VALUE});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testDegenerate1() {
setDistribution(new PascalDistribution(5, 1.0d));
setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});
setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});
setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
setInverseCumulativeTestValues(new int[] {0, 0});
verifyDensities();
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
public void testMoments() {
final double tol = 1e-9;
PascalDistribution dist;
dist = new PascalDistribution(10, 0.5);
Assert.assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);
Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol);
dist = new PascalDistribution(25, 0.7);
Assert.assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);
Assert.assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);
package org.apache.commons.math4.distribution;
public class PoissonDistributionTest extends IntegerDistributionAbstractTest {
private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;
public PoissonDistributionTest() {
setTolerance(1e-12);
public IntegerDistribution makeDistribution() {
return new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);
public int[] makeDensityTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
public double[] makeDensityTestValues() {
return new double[] { 0d, 0.0183156388887d,  0.073262555555d,
0.14652511111d, 0.195366814813d, 0.195366814813,
0.156293451851d, 0.00529247667642d, 8.27746364655e-09};
public double[] makeLogDensityTestValues() {
return new double[] { Double.NEGATIVE_INFINITY, -4.000000000000d,
-2.613705638880d, -1.920558458320d, -1.632876385868d,
-1.632876385868d, -1.856019937183d, -5.241468961877d,
-18.609729238356d};
public int[] makeCumulativeTestPoints() {
return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };
public double[] makeCumulativeTestValues() {
return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,
0.238103305554d, 0.433470120367d, 0.62883693518,
0.78513038703d,  0.99716023388d, 0.999999998077 };
public double[] makeInverseCumulativeTestPoints() {
IntegerDistribution dist = getDistribution();
return new double[] { 0d, 0.018315638886d, 0.018315638890d,
0.091578194441d, 0.091578194445d, 0.238103305552d,
0.238103305556d, dist.cumulativeProbability(3),
dist.cumulativeProbability(4), dist.cumulativeProbability(5),
dist.cumulativeProbability(10), dist.cumulativeProbability(20)};
public int[] makeInverseCumulativeTestValues() {
return new int[] { 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 10, 20};
public void testNormalApproximateProbability() {
PoissonDistribution dist = new PoissonDistribution(100);
double result = dist.normalApproximateProbability(110)
- dist.normalApproximateProbability(89);
Assert.assertEquals(0.706281887248, result, 1E-10);
dist = new PoissonDistribution(10000);
result = dist.normalApproximateProbability(10200)
- dist.normalApproximateProbability(9899);
Assert.assertEquals(0.820070051552, result, 1E-10);
public void testDegenerateInverseCumulativeProbability() {
PoissonDistribution dist = new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);
Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));
Assert.assertEquals(0, dist.inverseCumulativeProbability(0d));
public void testNegativeMean() {
new PoissonDistribution(-1);
public void testMean() {
PoissonDistribution dist = new PoissonDistribution(10.0);
Assert.assertEquals(10.0, dist.getMean(), 0.0);
public void testLargeMeanCumulativeProbability() {
double mean = 1.0;
while (mean <= 10000000.0) {
PoissonDistribution dist = new PoissonDistribution(mean);
double x = mean * 2.0;
double dx = x / 10.0;
double p = Double.NaN;
double sigma = FastMath.sqrt(mean);
while (x >= 0) {
p = dist.cumulativeProbability((int) x);
Assert.assertFalse("NaN cumulative probability returned for mean = " +
mean + " x = " + x,Double.isNaN(p));
if (x > mean - 2 * sigma) {
Assert.assertTrue("Zero cum probaility returned for mean = " +
mean + " x = " + x, p > 0);
} catch (Exception ex) {
Assert.fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());
x -= dx;
mean *= 10.0;
public void testCumulativeProbabilitySpecial() {
PoissonDistribution dist;
dist = new PoissonDistribution(9120);
checkProbability(dist, 9075);
checkProbability(dist, 9102);
dist = new PoissonDistribution(5058);
checkProbability(dist, 5044);
dist = new PoissonDistribution(6986);
checkProbability(dist, 6950);
private void checkProbability(PoissonDistribution dist, int x) {
double p = dist.cumulativeProbability(x);
Assert.assertFalse("NaN cumulative probability returned for mean = " +
dist.getMean() + " x = " + x, Double.isNaN(p));
Assert.assertTrue("Zero cum probability returned for mean = " +
dist.getMean() + " x = " + x, p > 0);
public void testLargeMeanInverseCumulativeProbability() {
double mean = 1.0;
while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.
PoissonDistribution dist = new PoissonDistribution(mean);
double p = 0.1;
double dp = p;
while (p < .99) {
int ret = dist.inverseCumulativeProbability(p);
Assert.assertTrue(p <= dist.cumulativeProbability(ret));
Assert.assertTrue(p > dist.cumulativeProbability(ret - 1));
} catch (Exception ex) {
Assert.fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
p += dp;
mean *= 10.0;
public void testMoments() {
final double tol = 1e-9;
PoissonDistribution dist;
dist = new PoissonDistribution(1);
Assert.assertEquals(dist.getNumericalMean(), 1, tol);
Assert.assertEquals(dist.getNumericalVariance(), 1, tol);
dist = new PoissonDistribution(11.23);
Assert.assertEquals(dist.getNumericalMean(), 11.23, tol);
Assert.assertEquals(dist.getNumericalVariance(), 11.23, tol);
final RealDistribution.Sampler sampler =
RealDistribution.Sampler origSampler = distribution.createSampler(RandomSource.create(source, seed));
RealDistribution.Sampler clonedSampler = cloned.createSampler(RandomSource.create(source, seed));
package org.apache.commons.math4.distribution;
public class TDistributionTest extends RealDistributionAbstractTest {
public TDistribution makeDistribution() {
return new TDistribution(5.0);
public double[] makeCumulativeTestPoints() {
return new double[] {-5.89342953136, -3.36492999891, -2.57058183564, -2.01504837333, -1.47588404882,
5.89342953136, 3.36492999891, 2.57058183564, 2.01504837333, 1.47588404882};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,
0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005,
0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005};
public void setUp() {
super.setUp();
setTolerance(1E-9);
public void testCumulativeProbabilityAgainstStackOverflow() {
TDistribution td = new TDistribution(5.);
td.cumulativeProbability(.1);
td.cumulativeProbability(.01);
public void testSmallDf() {
setDistribution(new TDistribution(1d));
setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362,
-6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362,
6.31375151468, 3.07768353718});
setDensityTestValues(new double[] {3.14158231817e-06, 0.000314055924703, 0.00195946145194,
0.00778959736375, 0.0303958893917, 3.14158231817e-06, 0.000314055924703,
0.00195946145194, 0.00778959736375, 0.0303958893917});
setInverseCumulativeTestValues(getCumulativeTestPoints());
verifyCumulativeProbabilities();
verifyInverseCumulativeProbabilities();
verifyDensities();
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0, 1});
setInverseCumulativeTestValues(
new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testCumulativeProbablilityExtremes() {
TDistribution dist;
for (int i = 1; i < 11; i++) {
dist = new TDistribution(i * 5);
Assert.assertEquals(1,
dist.cumulativeProbability(Double.POSITIVE_INFINITY), Double.MIN_VALUE);
Assert.assertEquals(0,
dist.cumulativeProbability(Double.NEGATIVE_INFINITY), Double.MIN_VALUE);
public void testDfAccessors() {
TDistribution dist = (TDistribution) getDistribution();
Assert.assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);
public void testPreconditions() {
new TDistribution(0);
public void testMoments() {
final double tol = 1e-9;
TDistribution dist;
dist = new TDistribution(1);
Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));
Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));
dist = new TDistribution(1.5);
Assert.assertEquals(dist.getNumericalMean(), 0, tol);
Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance()));
dist = new TDistribution(5);
Assert.assertEquals(dist.getNumericalMean(), 0, tol);
Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);
public void nistData(){
double[] prob = new double[]{ 0.10,0.05,0.025,0.01,0.005,0.001};
double[] args2 = new double[]{1.886,2.920,4.303,6.965,9.925,22.327};
double[] args10 = new double[]{1.372,1.812,2.228,2.764,3.169,4.143};
double[] args30 = new double[]{1.310,1.697,2.042,2.457,2.750,3.385};
double[] args100= new double[]{1.290,1.660,1.984,2.364,2.626,3.174};
TestUtils.assertEquals(prob, makeNistResults(args2, 2), 1.0e-4);
TestUtils.assertEquals(prob, makeNistResults(args10, 10), 1.0e-4);
TestUtils.assertEquals(prob, makeNistResults(args30, 30), 1.0e-4);
TestUtils.assertEquals(prob, makeNistResults(args100, 100), 1.0e-4);
return;
private double[] makeNistResults(double[] args, int df){
TDistribution td =  new TDistribution(df);
double[] res  = new double[ args.length ];
for( int i = 0 ; i < res.length ; i++){
res[i] = 1.0 - td.cumulativeProbability(args[i]);
return res;
package org.apache.commons.math4.distribution;
public class TriangularDistributionTest extends RealDistributionAbstractTest {
public void setUp() {
super.setUp();
setTolerance(1e-4);
public TriangularDistribution makeDistribution() {
return new TriangularDistribution(-3, 2, 12);
public double[] makeCumulativeTestPoints() {
return new double[] { -3.0001,                 // below lower limit
-3.0,                    // at lower limit
-2.0, -1.0, 0.0, 1.0,    // on lower side
2.0,                     // at mode
3.0, 4.0, 10.0, 11.0,    // on upper side
12.0,                    // at upper limit
12.0001                  // above upper limit
};
public double[] makeCumulativeTestValues() {
double third = 1 / 3.0;
double left = 18.75;
double area = 56.25;
return new double[] { 0.0,
0.0,
0.75 / area, 3 / area, 6.75 / area, 12 / area,
third,
(left + 7.125) / area, (left + 13.5) / area,
(left + 36) / area, (left + 37.125) / area,
1.0,
1.0
};
public double[] makeInverseCumulativeTestPoints() {
double[] points = makeCumulativeTestValues();
double[] points2 = new double[points.length-2];
System.arraycopy(points, 1, points2, 0, points2.length);
return points2;
public double[] makeInverseCumulativeTestValues() {
double[] points = makeCumulativeTestPoints();
double[] points2 = new double[points.length-2];
System.arraycopy(points, 1, points2, 0, points2.length);
return points2;
public double[] makeDensityTestValues() {
return new double[] { 0,
0,
2 / 75.0, 4 / 75.0, 6 / 75.0, 8 / 75.0,
10 / 75.0,
9 / 75.0, 8 / 75.0, 2 / 75.0, 1 / 75.0,
0,
0
};
public void testGetLowerBound() {
TriangularDistribution distribution = makeDistribution();
Assert.assertEquals(-3.0, distribution.getSupportLowerBound(), 0);
public void testGetUpperBound() {
TriangularDistribution distribution = makeDistribution();
Assert.assertEquals(12.0, distribution.getSupportUpperBound(), 0);
public void testPreconditions1() {
new TriangularDistribution(0, 0, 0);
public void testPreconditions2() {
new TriangularDistribution(1, 1, 0);
public void testPreconditions3() {
new TriangularDistribution(0, 2, 1);
public void testPreconditions4() {
new TriangularDistribution(2, 1, 3);
public void testMeanVariance() {
TriangularDistribution dist;
dist = new TriangularDistribution(0, 0.5, 1.0);
Assert.assertEquals(dist.getNumericalMean(), 0.5, 0);
Assert.assertEquals(dist.getNumericalVariance(), 1 / 24.0, 0);
dist = new TriangularDistribution(0, 1, 1);
Assert.assertEquals(dist.getNumericalMean(), 2 / 3.0, 0);
Assert.assertEquals(dist.getNumericalVariance(), 1 / 18.0, 0);
dist = new TriangularDistribution(-3, 2, 12);
Assert.assertEquals(dist.getNumericalMean(), 3 + (2 / 3.0), 0);
Assert.assertEquals(dist.getNumericalVariance(), 175 / 18.0, 0);
package org.apache.commons.math4.distribution;
public class UniformIntegerDistributionTest extends IntegerDistributionAbstractTest {
public void setUp() {
super.setUp();
setTolerance(1e-9);
public IntegerDistribution makeDistribution() {
return new UniformIntegerDistribution(-3, 5);
public int[] makeDensityTestPoints() {
return new int[] {-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6};
public double[] makeDensityTestValues() {
double d = 1.0 / (5 - -3 + 1);
return new double[] {0, d, d, d, d, d, d, d, d, d, 0};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0, 1 / 9.0, 2 / 9.0, 3 / 9.0, 4 / 9.0, 5 / 9.0,
6 / 9.0, 7 / 9.0, 8 / 9.0, 1, 1};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.200,
0.5, 0.999, 0.990, 0.975, 0.950, 0.900, 1};
public int[] makeInverseCumulativeTestValues() {
return new int[] {-3, -3, -3, -3, -3, -3, -2, 1, 5, 5, 5, 5, 5, 5};
public void testMoments() {
UniformIntegerDistribution dist;
dist = new UniformIntegerDistribution(0, 5);
Assert.assertEquals(dist.getNumericalMean(), 2.5, 0);
Assert.assertEquals(dist.getNumericalVariance(), 35 / 12.0, 0);
dist = new UniformIntegerDistribution(0, 1);
Assert.assertEquals(dist.getNumericalMean(), 0.5, 0);
Assert.assertEquals(dist.getNumericalVariance(), 3 / 12.0, 0);
public void testPreconditionUpperBoundInclusive() {
new UniformIntegerDistribution(1, 0);
} catch (NumberIsTooLargeException e) {
new UniformIntegerDistribution(0, 0);
public void testLargeRangeSubtractionOverflow() {
final int hi = Integer.MAX_VALUE / 2 + 10;
UniformIntegerDistribution dist = new UniformIntegerDistribution(-hi, hi - 1);
final double tol = Math.ulp(1d);
Assert.assertEquals(0.5 / hi, dist.probability(123456), tol);
Assert.assertEquals(0.5, dist.cumulativeProbability(-1), tol);
Assert.assertTrue(Precision.equals((Math.pow(2d * hi, 2) - 1) / 12, dist.getNumericalVariance(), 1));
public void testLargeRangeAdditionOverflow() {
final int hi = Integer.MAX_VALUE / 2 + 10;
UniformIntegerDistribution dist = new UniformIntegerDistribution(hi - 1, hi + 1);
final double tol = Math.ulp(1d);
Assert.assertEquals(1d / 3d, dist.probability(hi), tol);
Assert.assertEquals(2d / 3d, dist.cumulativeProbability(hi), tol);
Assert.assertTrue(Precision.equals(hi, dist.getNumericalMean(), 1));
package org.apache.commons.math4.distribution;
public class UniformRealDistributionTest extends RealDistributionAbstractTest {
public void setUp() {
super.setUp();
setTolerance(1e-4);
public UniformRealDistribution makeDistribution() {
return new UniformRealDistribution(-0.5, 1.25);
public double[] makeCumulativeTestPoints() {
return new double[] {-0.5001, -0.5, -0.4999, -0.25, -0.0001, 0.0,
0.0001, 0.25, 1.0, 1.2499, 1.25, 1.2501};
public double[] makeCumulativeTestValues() {
return new double[] {0.0, 0.0, 0.0001, 0.25/1.75, 0.4999/1.75,
0.5/1.75, 0.5001/1.75, 0.75/1.75, 1.5/1.75,
1.7499/1.75, 1.0, 1.0};
public double[] makeDensityTestValues() {
double d = 1 / 1.75;
return new double[] {0, d, d, d, d, d, d, d, d, d, d, 0};
public void testGetLowerBound() {
UniformRealDistribution distribution = makeDistribution();
Assert.assertEquals(-0.5, distribution.getSupportLowerBound(), 0);
public void testGetUpperBound() {
UniformRealDistribution distribution = makeDistribution();
Assert.assertEquals(1.25, distribution.getSupportUpperBound(), 0);
public void testPreconditions1() {
new UniformRealDistribution(0, 0);
public void testPreconditions2() {
new UniformRealDistribution(1, 0);
public void testMeanVariance() {
UniformRealDistribution dist;
dist = new UniformRealDistribution(0, 1);
Assert.assertEquals(dist.getNumericalMean(), 0.5, 0);
Assert.assertEquals(dist.getNumericalVariance(), 1/12.0, 0);
dist = new UniformRealDistribution(-1.5, 0.6);
Assert.assertEquals(dist.getNumericalMean(), -0.45, 0);
Assert.assertEquals(dist.getNumericalVariance(), 0.3675, 0);
dist = new UniformRealDistribution(-0.5, 1.25);
Assert.assertEquals(dist.getNumericalMean(), 0.375, 0);
Assert.assertEquals(dist.getNumericalVariance(), 0.2552083333333333, 0);
public void testInverseCumulativeDistribution() {
UniformRealDistribution dist = new UniformRealDistribution(0, 1e-9);
Assert.assertEquals(2.5e-10, dist.inverseCumulativeProbability(0.25), 0);
package org.apache.commons.math4.distribution;
public class WeibullDistributionTest extends RealDistributionAbstractTest {
public WeibullDistribution makeDistribution() {
return new WeibullDistribution(1.2, 2.1);
public double[] makeCumulativeTestPoints() {
return new double[] {0.00664355180993, 0.0454328283309, 0.0981162737374, 0.176713524579, 0.321946865392,
10.5115496887, 7.4976304671, 6.23205600701, 5.23968436955, 4.2079028257};
public double[] makeCumulativeTestValues() {
return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};
public double[] makeDensityTestValues() {
return new double[] {0.180535929306, 0.262801138133, 0.301905425199, 0.330899152971,
0.353441418887, 0.000788590320203, 0.00737060094841, 0.0177576041516, 0.0343043442574, 0.065664589369};
public void testInverseCumulativeProbabilitySmallPAccuracy() {
WeibullDistribution dist = new WeibullDistribution(2, 3);
double t = dist.inverseCumulativeProbability(1e-17);
Assert.assertEquals(9.48683298050514e-9, t, 1e-17);
public void testInverseCumulativeProbabilityExtremes() {
setInverseCumulativeTestPoints(new double[] {0.0, 1.0});
setInverseCumulativeTestValues(
new double[] {0.0, Double.POSITIVE_INFINITY});
verifyInverseCumulativeProbabilities();
public void testAlpha() {
WeibullDistribution dist = new WeibullDistribution(1, 2);
Assert.assertEquals(1, dist.getShape(), 0);
new WeibullDistribution(0, 2);
Assert.fail("NotStrictlyPositiveException expected");
} catch (NotStrictlyPositiveException e) {
public void testBeta() {
WeibullDistribution dist = new WeibullDistribution(1, 2);
Assert.assertEquals(2, dist.getScale(), 0);
new WeibullDistribution(1, 0);
Assert.fail("NotStrictlyPositiveException expected");
} catch (NotStrictlyPositiveException e) {
public void testMoments() {
final double tol = 1e-9;
WeibullDistribution dist;
dist = new WeibullDistribution(2.5, 3.5);
Assert.assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(LogGamma.value(1 + (1 / 2.5))), tol);
Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) *
FastMath.exp(LogGamma.value(1 + (2 / 2.5))) -
(dist.getNumericalMean() * dist.getNumericalMean()), tol);
dist = new WeibullDistribution(10.4, 2.222);
Assert.assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(LogGamma.value(1 + (1 / 10.4))), tol);
Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) *
FastMath.exp(LogGamma.value(1 + (2 / 10.4))) -
(dist.getNumericalMean() * dist.getNumericalMean()), tol);
package org.apache.commons.math4.distribution;
public class ZipfDistributionTest extends IntegerDistributionAbstractTest {
public ZipfDistributionTest() {
setTolerance(1e-12);
public void testPreconditions1() {
new ZipfDistribution(0, 1);
public void testPreconditions2() {
new ZipfDistribution(1, 0);
public IntegerDistribution makeDistribution() {
return new ZipfDistribution(10, 1);
public int[] makeDensityTestPoints() {
return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
public double[] makeDensityTestValues() {
return new double[] {0d, 0d, 0.341417152147, 0.170708576074, 0.113805717382, 0.0853542880369, 0.0682834304295,
0.0569028586912, 0.0487738788782, 0.0426771440184, 0.0379352391275, 0.0341417152147, 0};
public double[] makeLogDensityTestValues() {
return new double[] {Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY,
-1.07465022926458, -1.76779740982453, -2.17326251793269, -2.46094459038447,
-2.68408814169868, -2.86640969849264, -3.0205603783199, -3.15409177094442,
-3.2718748066008, -3.37723532225863, Double.NEGATIVE_INFINITY};
public int[] makeCumulativeTestPoints() {
return makeDensityTestPoints();
public double[] makeCumulativeTestValues() {
return new double[] {0, 0, 0.341417152147, 0.512125728221, 0.625931445604, 0.71128573364,
0.77956916407, 0.836472022761, 0.885245901639, 0.927923045658, 0.965858284785, 1d, 1d};
public double[] makeInverseCumulativeTestPoints() {
return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.3413d, 0.3415d, 0.999d,
0.990d, 0.975d, 0.950d, 0.900d, 1d};
public int[] makeInverseCumulativeTestValues() {
return new int[] {1, 1, 1, 1, 1, 1, 2, 10, 10, 10, 9, 8, 10};
public void testMoments() {
final double tol = 1e-9;
ZipfDistribution dist;
dist = new ZipfDistribution(2, 0.5);
Assert.assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);
Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol);
public void testSamplingExtended() {
int sampleSize = 1000;
int[] numPointsValues = {
2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100
};
double[] exponentValues = {
1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 2e-1, 5e-1,
1. - 1e-9, 1.0, 1. + 1e-9, 1.1, 1.2, 1.3, 1.5, 1.6, 1.7, 1.8, 2.0,
2.5, 3.0, 4., 5., 6., 7., 8., 9., 10., 20., 30., 100., 150.
};
for (int numPoints : numPointsValues) {
for (double exponent : exponentValues) {
double weightSum = 0.;
double[] weights = new double[numPoints];
for (int i = numPoints; i>=1; i-=1) {
weights[i-1] = Math.pow(i, -exponent);
weightSum += weights[i-1];
IntegerDistribution.Sampler distribution =
new ZipfDistribution(numPoints, exponent).createSampler(RandomSource.create(RandomSource.WELL_19937_C, 6));
double[] expectedCounts = new double[numPoints];
long[] observedCounts = new long[numPoints];
for (int i = 0; i < numPoints; i++) {
expectedCounts[i] = sampleSize * (weights[i]/weightSum);
int[] sample = AbstractIntegerDistribution.sample(sampleSize, distribution);
for (int s : sample) {
observedCounts[s-1]++;
TestUtils.assertChiSquareAccept(expectedCounts, observedCounts, 0.001);
public void testSamplerPerformance() {
int[] numPointsValues = {1, 2, 5, 10, 100, 1000, 10000};
double[] exponentValues = {1e-3, 1e-2, 1e-1, 1., 2., 5., 10.};
int  numGeneratedSamples = 1000000;
long sum = 0;
for (int numPoints : numPointsValues) {
for (double exponent : exponentValues) {
long start = System.currentTimeMillis();
final int[] randomNumberCounter = new int[1];
final IntegerDistribution.Sampler distribution =
new ZipfDistribution(numPoints, exponent).createSampler(RandomSource.create(RandomSource.WELL_1024_A));
for (int i = 0; i < numGeneratedSamples; ++i) {
sum += distribution.sample();
long end = System.currentTimeMillis();
System.out.println("n = " + numPoints + ", exponent = " + exponent + ", avg number consumed random values = " + (double)(randomNumberCounter[0])/numGeneratedSamples + ", measured time = " + (end-start)/1000. + "s");
System.out.println(sum);
final RealDistribution.Sampler rand = new NormalDistribution().createSampler(RandomSource.create(RandomSource.WELL_19937_C));
final RealDistribution.Sampler rand = new NormalDistribution().createSampler(RandomSource.create(RandomSource.WELL_19937_C));
final RealDistribution.Sampler dist = new NormalDistribution(0, measurementNoise).createSampler(RandomSource.create(RandomSource.WELL_19937_C, 1001));
final RealDistribution.Sampler rng
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
final RealDistribution.Sampler rng
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
final long seed = 59321761414L;
private final RealDistribution.Sampler cX;
private final RealDistribution.Sampler cY;
private final RealDistribution.Sampler tP;
tP = new UniformRealDistribution(0, MathUtils.TWO_PI).createSampler(rng);
private final RealDistribution.Sampler x;
private final RealDistribution.Sampler error;
x = new UniformRealDistribution(lo, hi).createSampler(rng);
RealDistribution.Sampler dist 
RealDistribution.Sampler dist 
RealDistribution.Sampler dist
final RealDistribution u = new UniformRealDistribution(-0.05 * radius, 0.05 * radius);
final IntegerDistribution.Sampler size =
new UniformIntegerDistribution(10, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
final RealDistribution.Sampler randomData
= new UniformRealDistribution(-100, 100).createSampler(RandomSource.create(RandomSource.WELL_512_A,
final IntegerDistribution.Sampler sampler =
new UniformIntegerDistribution(cur, length - 1).createSampler(RandomSource.create(RandomSource.WELL_512_A));
final IntegerDistribution.Sampler weightDist =
new UniformIntegerDistribution(1, 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,
234878544L));
final RealDistribution.Sampler valueDist =
private void doDistributionTest(RealDistribution distribution) {
final RealDistribution.Sampler sampler =
final RealDistribution.Sampler sampler =
final UniformRealDistribution unif = new UniformRealDistribution(-0.5, 0.5);
final UniformRealDistribution unif = new UniformRealDistribution(-0.5, 0.5);
final UniformRealDistribution unif = new UniformRealDistribution(-0.5, 0.5);
final RealDistribution.Sampler gauss = new NormalDistribution().createSampler(rg);
final RealDistribution.Sampler u
= new UniformRealDistribution(i + 0.5, i + 0.75).createSampler(random);
final IntegerDistribution.Sampler randomData =
new UniformIntegerDistribution(100, 1000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));
final IntegerDistribution.Sampler randomData =
new UniformIntegerDistribution(100, 3000).createSampler(RandomSource.create(RandomSource.WELL_19937_C));setBarycenter((Point<Euclidean2D>) new Cartesian2D(0, 0));
PolygonsSet empty = (PolygonsSet) new RegionFactory<Euclidean2D>().getComplement(new PolygonsSet(1.0e-10));
Assert.assertTrue(empty.isEmpty());
Assert.assertEquals(0, empty.getVertices().length);
Assert.assertEquals(0.0, empty.getBoundarySize(), 1.0e-10);
Assert.assertEquals(0.0, empty.getSize(), 1.0e-10);
empty.projectToBoundary(new Cartesian2D(x, y)).getOffset(),
PolygonsSet empty = new PolygonsSet(1.0e-10);
Assert.assertFalse(empty.isEmpty());
Assert.assertEquals(0, empty.getVertices().length);
Assert.assertEquals(0.0, empty.getBoundarySize(), 1.0e-10);
Assert.assertEquals(Double.POSITIVE_INFINITY, empty.getSize(), 1.0e-10);
empty.projectToBoundary(new Cartesian2D(x, y)).getOffset(),
1.0e-10);if (j == (array.length - 1)) {
checkPointsEqual(new Cartesian2D(1, 0), loop[4], tolerance);} else if (j == (array.length - 1)) {
write(node.getClass().getSimpleName() + "@" + System.identityHashCode(node) + " | ");
Line line1 = new Line(new Cartesian2D(0, 0), new Cartesian2D(1, 1), 1e-10);
Line line2 = new Line(new Cartesian2D(1, -1), new Cartesian2D(0, 0), 1e-10);
PolygonsSet poly = new PolygonsSet(boundaries, 1e-10);
Assert.assertEquals(1e-10, poly.getTolerance(), Precision.EPSILON);
Assert.assertEquals(Double.POSITIVE_INFINITY, poly.getSize(), 1e-10);
Assert.assertEquals(Double.POSITIVE_INFINITY, poly.getBoundarySize(), 1e-10);
Assert.assertEquals(false, poly.isEmpty());
Assert.assertEquals(false, poly.isFull());
GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), 1e-10);
Cartesian2D[][] vertices = poly.getVertices();
Assert.assertEquals(1, vertices.length);
Cartesian2D[] loop = vertices[0];
Assert.assertEquals(3, loop.length);
Assert.assertEquals(null, loop[0]);
GeometryTestUtils.assertVectorEquals(line2.toSpace(new Cartesian1D(-Float.MAX_VALUE)), loop[1], 1e-10);
GeometryTestUtils.assertVectorEquals(line2.toSpace(new Cartesian1D(Float.MAX_VALUE)), loop[2], 1e-10);
checkPoints(Region.Location.INSIDE, poly, new Cartesian2D[] {
new Cartesian2D(-Float.MAX_VALUE, Float.MAX_VALUE / 2.0)
});
checkPoints(Region.Location.OUTSIDE, poly, new Cartesian2D[] {
new Cartesian2D(Float.MAX_VALUE, Float.MAX_VALUE / 2.0)
});
checkPoints(Region.Location.BOUNDARY, poly, new Cartesian2D[] { Cartesian2D.ZERO });
public void testSimplyConnected() {
Cartesian2D[][] vertices = new Cartesian2D[][] {
new Cartesian2D[] {
new Cartesian2D(36.0, 22.0),
new Cartesian2D(39.0, 32.0),
new Cartesian2D(19.0, 32.0),
new Cartesian2D( 6.0, 16.0),
new Cartesian2D(31.0, 10.0),
new Cartesian2D(42.0, 16.0),
new Cartesian2D(34.0, 20.0),
new Cartesian2D(29.0, 19.0),
new Cartesian2D(23.0, 22.0),
new Cartesian2D(33.0, 25.0)
};
PolygonsSet set = buildSet(vertices);
Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Cartesian2D(50.0, 30.0)));
checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {
new Cartesian2D(30.0, 15.0),
new Cartesian2D(15.0, 20.0),
new Cartesian2D(24.0, 25.0),
new Cartesian2D(35.0, 30.0),
new Cartesian2D(19.0, 17.0)
});
checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {
new Cartesian2D(50.0, 30.0),
new Cartesian2D(30.0, 35.0),
new Cartesian2D(10.0, 25.0),
new Cartesian2D(10.0, 10.0),
new Cartesian2D(40.0, 10.0),
new Cartesian2D(50.0, 15.0),
new Cartesian2D(30.0, 22.0)
});
checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {
new Cartesian2D(30.0, 32.0),
new Cartesian2D(34.0, 20.0)
});
checkVertices(set.getVertices(), vertices);
public void testBox() {
PolygonsSet box = new PolygonsSet(0, 2, -1, 1, 1.0e-10);
Assert.assertEquals(4.0, box.getSize(), 1.0e-10);
Assert.assertEquals(8.0, box.getBoundarySize(), 1.0e-10);
public void testInfinite() {
PolygonsSet box = new PolygonsSet(new BSPTree<Euclidean2D>(Boolean.TRUE), 1.0e-10);
Assert.assertTrue(Double.isInfinite(box.getSize()));
public void testSingleInfiniteLine() {
double tolerance = 1e-10;
Line line = new Line(new Cartesian2D(0, 0), new Cartesian2D(1, 1), tolerance);
boundaries.add(line.wholeHyperplane());
PolygonsSet polygon = new PolygonsSet(boundaries, tolerance);
Assert.assertTrue(Double.isInfinite(polygon.getSize()));
Cartesian2D[][] vertices = polygon.getVertices();
Assert.assertEquals(1, vertices.length);
Cartesian2D[] loop = vertices[0];
Assert.assertEquals(3, loop.length);
Assert.assertEquals(null, loop[0]);
checkPointsEqual(line.toSpace(new Cartesian1D(-Float.MAX_VALUE)), loop[1], tolerance);
checkPointsEqual(line.toSpace(new Cartesian1D(Float.MAX_VALUE)), loop[2], tolerance);
public void testMixOfFiniteAndInfiniteBoundaries() {
double tolerance = 1e-10;
Line line = new Line(new Cartesian2D(1, 0), new Cartesian2D(1, 1), tolerance);
List<SubHyperplane<Euclidean2D>> boundaries = new ArrayList<SubHyperplane<Euclidean2D>>();
boundaries.add(buildSegment(new Cartesian2D(0, 1), new Cartesian2D(0, 0)));
boundaries.add(buildSegment(new Cartesian2D(0, 0), new Cartesian2D(1, 0)));
boundaries.add(new SubLine(line, new IntervalsSet(0, Double.POSITIVE_INFINITY, tolerance)));
PolygonsSet polygon = new PolygonsSet(boundaries, tolerance);
Assert.assertTrue(Double.isInfinite(polygon.getSize()));
Cartesian2D[][] vertices = polygon.getVertices();
Assert.assertEquals(1, vertices.length);
Cartesian2D[] loop = vertices[0];
Assert.assertEquals(5, loop.length);
Assert.assertEquals(null, loop[0]);
checkPointsEqual(new Cartesian2D(0, 1), loop[1], tolerance);
checkPointsEqual(new Cartesian2D(0, 0), loop[2], tolerance);
checkPointsEqual(new Cartesian2D(1, 0), loop[3], tolerance);
checkPointsEqual(new Cartesian2D(1, 1), loop[4], tolerance);
checkVertices(set.getVertices(), vertices);
Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0), set.getSize(), 1.0e-10);
public void testEmpty() {
PolygonsSet poly = (PolygonsSet) new RegionFactory<Euclidean2D>().getComplement(new PolygonsSet(1e-10));
Assert.assertEquals(1e-10, poly.getTolerance(), Precision.EPSILON);
Assert.assertEquals(0.0, poly.getSize(), 1e-10);
Assert.assertEquals(0.0, poly.getBoundarySize(), 1e-10);
Assert.assertEquals(0, poly.getVertices().length);
Assert.assertTrue(poly.isEmpty());
Assert.assertFalse(poly.isFull());
GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), 1e-10);
checkPoints(Region.Location.OUTSIDE, poly, new Cartesian2D[] {
new Cartesian2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY),
Cartesian2D.ZERO,
new Cartesian2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)});
double offset;
for (double y = -1; y < 1; y += 0.1) {
for (double x = -1; x < 1; x += 0.1) {
offset = poly.projectToBoundary(new Cartesian2D(x, y)).getOffset();
Assert.assertTrue(offset > 0);
Assert.assertTrue(Double.isInfinite(offset));
public void testFull() {
PolygonsSet poly = new PolygonsSet(1e-10);
Assert.assertEquals(1e-10, poly.getTolerance(), Precision.EPSILON);
Assert.assertTrue(poly.getSize() > 0);
Assert.assertTrue(Double.isInfinite(poly.getSize()));
Assert.assertEquals(0.0, poly.getBoundarySize(), 1e-10);
Assert.assertEquals(0, poly.getVertices().length);
Assert.assertFalse(poly.isEmpty());
Assert.assertTrue(poly.isFull());
GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), 1e-10);
checkPoints(Region.Location.INSIDE, poly, new Cartesian2D[] {
new Cartesian2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY),
Cartesian2D.ZERO,
new Cartesian2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)});
double offset;
for (double y = -1; y < 1; y += 0.1) {
for (double x = -1; x < 1; x += 0.1) {
offset = poly.projectToBoundary(new Cartesian2D(x, y)).getOffset();
Assert.assertTrue(offset < 0);
Assert.assertTrue(Double.isInfinite(offset));
checkVertices(set.getVertices(), vertices);
Assert.assertEquals(0.0,      p.getX(), 1.0e-10);
Assert.assertEquals(0.0,      p.getY(), 1.0e-10);
Assert.assertEquals(+v.distance(Cartesian2D.ZERO), projection.getOffset(), 1.0e-10);
Assert.assertEquals(0.0,      p.getX(), 1.0e-10);
Assert.assertEquals(v.getY(), p.getY(), 1.0e-10);
Assert.assertEquals(-v.getX(), projection.getOffset(), 1.0e-10);
Assert.assertEquals(1.0,      p.getX(), 1.0e-10);
Assert.assertEquals(v.getY(), p.getY(), 1.0e-10);
Assert.assertEquals(v.getX() - 1.0, projection.getOffset(), 1.0e-10);
Assert.assertEquals(v.getX(), p.getX(), 1.0e-10);
Assert.assertEquals(2.0,      p.getY(), 1.0e-10);
Assert.assertEquals(2.0 - v.getY(), projection.getOffset(), 1.0e-10);
Assert.assertEquals(v.getX(), p.getX(), 1.0e-10);
Assert.assertEquals(3.0,      p.getY(), 1.0e-10);
Assert.assertEquals(v.getY() - 3.0, projection.getOffset(), 1.0e-10);
Assert.assertEquals(3.0,      p.getX(), 1.0e-10);
Assert.assertEquals(3.0,      p.getY(), 1.0e-10);
Assert.assertEquals(+v.distance(new Cartesian2D(3, 3)), projection.getOffset(), 1.0e-10);
checkVertices(set.getVertices(), vertices);
checkVertices(set.getVertices(), vertices);
checkVertices(set.getVertices(), vertices);
Line l1 = new Line(new Cartesian2D(-1.5, 0.0), FastMath.PI / 4, 1.0e-10);
Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10);
Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10);
Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10);
Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10);
Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10);
Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10);
Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10);
Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10);
Line l2 = new Line(new Cartesian2D(-1.0, 2.0), 0, 1.0e-10);
Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10);
Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10);
Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10);
Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10);
checkVertices(set1.getVertices(), vertices1);
checkVertices(set2.getVertices(), vertices2);
checkVertices(set.getVertices(), new Cartesian2D[][] {
});
checkVertices(set1.getVertices(), vertices1);
checkVertices(set2.getVertices(), vertices2);
checkVertices(set.getVertices(), new Cartesian2D[][] {
});
checkVertices(set1.getVertices(), vertices1);
checkVertices(set2.getVertices(), vertices2);
checkVertices(set.getVertices(), new Cartesian2D[][] {
});
checkVertices(set1.getVertices(), vertices1);
checkVertices(set2.getVertices(), vertices2);
checkVertices(set.getVertices(), new Cartesian2D[][] {
});
checkVertices(set1.getVertices(), vertices1);
checkVertices(set2.getVertices(), vertices2);
checkVertices(set.getVertices(), new Cartesian2D[][] {
});
Assert.assertTrue(new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()).isEmpty());
new Line(new Cartesian2D(   0.0, 1.0),  5 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 1.0),  7 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 1.0),  9 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-sqrt3, 0.0), 11 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(   0.0, 0.0), 13 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(   0.0, 1.0),  3 * pi6, 1.0e-10).wholeHyperplane(),
new Line(new Cartesian2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane()
PolygonsSet set = new PolygonsSet(tree, 1.0e-10);
new Line(new Cartesian2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6, 1.0e-10).wholeHyperplane();
1.0e-10);
Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10);
(PolygonsSet) new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9, 1.0e-10),
new PolygonsSet(b6, 1.0e-10));
checkVertices(c.getVertices(),
new Cartesian2D[][] {
});
new Cartesian2D(1.0, 0.625000007541172), 1.0e-10),
new Cartesian2D(-0.19204433621902645, 1.0), 1.0e-10),
new Cartesian2D(-1.12851149797877, -0.2634107480798909), 1.0e-10),
new Cartesian2D(1.0, 2.0), 1.0e-10)
1.0e-10)),
1.0e-10)),
Double.POSITIVE_INFINITY, 1.0e-10)),
PolygonsSet set = new PolygonsSet(node4, 1.0e-10);
PolygonsSet set = new PolygonsSet(1.0e-10,
PolygonsSet set1 = new PolygonsSet(1.0e-10, vertices1);
new PolygonsSet(0.0, 0.0, 0.0, 10.3206397147574, 1.0e-10).getSize(),
1.0e-10);
PolygonsSet ps = new PolygonsSet(new BSPTree<Euclidean2D>(), 1.0e-10);
PolygonsSet p = new PolygonsSet(1.0e-10,
PolygonsSet w = new PolygonsSet(1.0e-10,
public void testThinRectangle() {
Assert.assertEquals(1.0 / 64.0, accuratePolygon.getSize(), 1.0e-10);
Assert.assertTrue(Double.isInfinite(new RegionFactory<Euclidean2D>().getComplement(accuratePolygon).getSize()));
Assert.assertEquals(2 * (1.0 + 1.0 / 64.0), accuratePolygon.getBoundarySize(), 1.0e-10);
new Line(pA, pB, 1.0 / 16),
new Line(pB, pC, 1.0 / 16),
new Line(pC, pD, 1.0 / 16),
new Line(pD, pA, 1.0 / 16)
};
Assert.assertEquals(0.0, degeneratedPolygon.getSize(), 1.0e-10);
double tolerance = 1.0e-10;
PolygonsSet square = new PolygonsSet(1.0e-10,
return new PolygonsSet(edges, 1.0e-10);
return new Line(start, end, 1.0e-10).wholeHyperplane();
Line   line  = new Line(start, end, 1.0e-10);
return new SubLine(line, new IntervalsSet(lower, upper, 1.0e-10));
Line   line  = new Line(start, end, 1.0e-10);
return new SubLine(line, new IntervalsSet(lower, upper, 1.0e-10));
private void checkPointsEqual(Cartesian2D expected, Cartesian2D actual, double tolerance) {
Assert.assertEquals(expected.getX(), actual.getX(), tolerance);
Assert.assertEquals(expected.getY(), actual.getY(), tolerance);
private void checkPoints(Region.Location expected, PolygonsSet set,
Cartesian2D[] points) {
Assert.assertEquals(expected, set.checkPoint(points[i]));
private boolean checkInSegment(Cartesian2D p,
Cartesian2D p1, Cartesian2D p2,
double tolerance) {
Line line = new Line(p1, p2, 1.0e-10);
if (line.getOffset(p) < tolerance) {
double x  = (line.toSubSpace(p)).getX();
double x1 = (line.toSubSpace(p1)).getX();
double x2 = (line.toSubSpace(p2)).getX();
return (((x - x1) * (x - x2) <= 0.0)
|| (p1.distance(p) < tolerance)
|| (p2.distance(p) < tolerance));
} else {
return false;
private void checkVertices(Cartesian2D[][] rebuiltVertices,
Cartesian2D[][] vertices) {
for (int i = 0; i < rebuiltVertices.length; ++i) {
for (int j = 0; j < rebuiltVertices[i].length; ++j) {
boolean inSegment = false;
Cartesian2D p = rebuiltVertices[i][j];
for (int k = 0; k < vertices.length; ++k) {
Cartesian2D[] loop = vertices[k];
int length = loop.length;
for (int l = 0; (! inSegment) && (l < length); ++l) {
inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10);
Assert.assertTrue(inSegment);
for (int k = 0; k < vertices.length; ++k) {
for (int l = 0; l < vertices[k].length; ++l) {
double min = Double.POSITIVE_INFINITY;
for (int i = 0; i < rebuiltVertices.length; ++i) {
for (int j = 0; j < rebuiltVertices[i].length; ++j) {
min = FastMath.min(vertices[k][l].distance(rebuiltVertices[i][j]),
min);
Assert.assertEquals(0.0, min, 1.0e-10);final double tol = 1e14;value.setEntry(0, function.value(point.toArray()));
point.setEntry(columnFinal, testPoint);
double testPointOutput = function.value(point.toArray());
point.setEntry(columnFinal, originalPoint);  //set it back
return testPointOutput;
}, originalPoint);
RealVector value = new ArrayRealVector(function.value(point.toArray()));
point.setEntry(columnFinal, testPoint);
double[] testPointValue = function.value(point.toArray());
point.setEntry(columnFinal, originalPoint);  //set it back
return testPointValue;
}, originalPoint);