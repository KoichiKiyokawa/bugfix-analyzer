import java.awt.BasicStroke;
g2.setStroke(new BasicStroke(1.0f));
g2.draw(block);TimeZone saved = TimeZone.getDefault();
TimeZone.setDefault(TimeZone.getTimeZone("Europe/Paris"));private Map explodePercentages;
ep = getExplodePercent(section) / mep;
= new TreeMap<Comparable<?>, Number>(this.explodePercentages);import javax.swing.SortOrder;import org.jfree.chart.util.TextUtils;
import org.jfree.chart.util.TextUtils;
Rectangle2D bounds = TextUtils.getTextBounds(text, g2, fm);
package org.jfree.chart.util;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.geom.Rectangle2D;
import org.jfree.chart.ui.TextAnchor;
public class TextUtils {
public static Rectangle2D drawAlignedString(String text,
Graphics2D g2, float x, float y, TextAnchor anchor) {
Rectangle2D textBounds = new Rectangle2D.Double();
float[] adjust = deriveTextBoundsAnchorOffsets(g2, text, anchor,
textBounds);
textBounds.setRect(x + adjust[0], y + adjust[1] + adjust[2],
textBounds.getWidth(), textBounds.getHeight());
g2.drawString(text, x + adjust[0], y + adjust[1]);
return textBounds;
public static Rectangle2D calcAlignedStringBounds(String text,
Graphics2D g2, float x, float y, TextAnchor anchor) {
Rectangle2D textBounds = new Rectangle2D.Double();
float[] adjust = deriveTextBoundsAnchorOffsets(g2, text, anchor,
textBounds);
textBounds.setRect(x + adjust[0], y + adjust[1] + adjust[2],
textBounds.getWidth(), textBounds.getHeight());
return textBounds;
private static float[] deriveTextBoundsAnchorOffsets(Graphics2D g2,
String text, TextAnchor anchor) {
float[] result = new float[2];
FontRenderContext frc = g2.getFontRenderContext();
Font f = g2.getFont();
FontMetrics fm = g2.getFontMetrics(f);
Rectangle2D bounds = getTextBounds(text, fm);
LineMetrics metrics = f.getLineMetrics(text, frc);
float ascent = metrics.getAscent();
float halfAscent = ascent / 2.0f;
float descent = metrics.getDescent();
float leading = metrics.getLeading();
float xAdj = 0.0f;
float yAdj = 0.0f;
if (anchor.isHorizontalCenter()) {
xAdj = (float) -bounds.getWidth() / 2.0f;
else if (anchor.isRight()) {
xAdj = (float) -bounds.getWidth();
if (anchor.isTop()) {
yAdj = -descent - leading + (float) bounds.getHeight();
else if (anchor.isHalfAscent()) {
yAdj = halfAscent;
else if (anchor.isVerticalCenter()) {
yAdj = -descent - leading + (float) (bounds.getHeight() / 2.0);
else if (anchor.isBaseline()) {
yAdj = 0.0f;
else if (anchor.isBottom()) {
yAdj = -metrics.getDescent() - metrics.getLeading();
result[0] = xAdj;
result[1] = yAdj;
return result;
private static float[] deriveTextBoundsAnchorOffsets(Graphics2D g2,
String text, TextAnchor anchor, Rectangle2D textBounds) {
float[] result = new float[3];
FontRenderContext frc = g2.getFontRenderContext();
Font f = g2.getFont();
FontMetrics fm = g2.getFontMetrics(f);
Rectangle2D bounds = getTextBounds(text, fm);
LineMetrics metrics = f.getLineMetrics(text, frc);
float ascent = metrics.getAscent();
result[2] = -ascent;
float halfAscent = ascent / 2.0f;
float descent = metrics.getDescent();
float leading = metrics.getLeading();
float xAdj = 0.0f;
float yAdj = 0.0f;
if (anchor.isHorizontalCenter()) {
xAdj = (float) -bounds.getWidth() / 2.0f;
else if (anchor.isRight()) {
xAdj = (float) -bounds.getWidth();
if (anchor.isTop()) {
yAdj = -descent - leading + (float) bounds.getHeight();
else if (anchor.isHalfAscent()) {
yAdj = halfAscent;
else if (anchor.isHorizontalCenter()) {
yAdj = -descent - leading + (float) (bounds.getHeight() / 2.0);
else if (anchor.isBaseline()) {
yAdj = 0.0f;
else if (anchor.isBottom()) {
yAdj = -metrics.getDescent() - metrics.getLeading();
if (textBounds != null) {
textBounds.setRect(bounds);
result[0] = xAdj;
result[1] = yAdj;
return result;
public static Rectangle2D getTextBounds(String text, FontMetrics fm) {
return getTextBounds(text, 0.0, 0.0, fm);
public static Rectangle2D getTextBounds(String text, double x, double y,
FontMetrics fm) {
ParamChecks.nullNotPermitted(text, "text");
ParamChecks.nullNotPermitted(fm, "fm");
double width = fm.stringWidth(text);
double height = fm.getHeight();
return new Rectangle2D.Double(x, y - fm.getAscent(), width, height);protected void addEntity(EntityCollection entities, Shape area,
XYDataset dataset, int series, int item,
double entityX, double entityY) {
Shape hotspot = area;
if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {
hotspot = new Ellipse2D.Double(entityX - r, entityY - r, w, w);
else {
hotspot = new Ellipse2D.Double(entityY - r, entityX - r, w, w);
transX1, transY1);
addEntity(entities, dataAreaHotspot, dataset, series, item, 0.0, 0.0);
addEntity(entities, block, dataset, series, item, transX, transY);
else {
addEntity(entities, hotspot, dataset, series, item, transX,
transY);
else if (orientation == PlotOrientation.HORIZONTAL) {
if (entities != null) {
addEntity(entities, shape, dataset, series, item, transX1, transY1);
addEntity(entities, null, dataset, series, item, transX1,
transY1);
addEntity(entities, hotspot, dataset, series, item, xx, 
(yyHigh + yyLow) / 2);TimeZone zone) {
new Class[] {Date.class, TimeZone.class});
new Object[] {millisecond, zone});
TimeZone.class});
new Date(latest), TimeZone.getDefault()});if (axis.isInverted()) {
percent = -percent;
axis.pan(percent);
if (axis.isInverted()) {
percent = -percent;
axis.pan(percent);crosshairState.updateCrosshairPoint(x[k], y[k], transX,
crosshairState.updateCrosshairX(transX);
crosshairState.updateCrosshairY(transY);
crosshairState.updateCrosshairPoint(x[k], y[k], transX,
crosshairState.updateCrosshairX(transX);
crosshairState.updateCrosshairY(transY);
private int domainAxisIndex;
private int rangeAxisIndex;
public void updateCrosshairPoint(double x, double y,
double transX, double transY,
PlotOrientation orientation) {
updateCrosshairPoint(x, y, 0, 0, transX, transY, orientation);
public void updateCrosshairPoint(double x, double y, int domainAxisIndex,
int rangeAxisIndex, double transX, double transY,
PlotOrientation orientation) {
if (this.calculateDistanceInDataSpace) {
this.domainAxisIndex = domainAxisIndex;
this.rangeAxisIndex = rangeAxisIndex;
public void updateCrosshairX(double candidateX) {
updateCrosshairX(candidateX, 0);
public void updateCrosshairX(double candidateX, int domainAxisIndex) {
double d = Math.abs(candidateX - this.anchorX);
this.crosshairX = candidateX;
this.domainAxisIndex = domainAxisIndex;
public void updateCrosshairY(double candidateY) {
updateCrosshairY(candidateY, 0);
public void updateCrosshairY(double candidateY, int rangeAxisIndex) {
double d = Math.abs(candidateY - this.anchorY);
this.rangeAxisIndex = rangeAxisIndex;
public int getDomainAxisIndex() {
return this.domainAxisIndex;
public int getRangeAxisIndex() {
return this.rangeAxisIndex;
double x, double y, int domainAxisIndex, int rangeAxisIndex,
crosshairState.updateCrosshairPoint(x, y, domainAxisIndex,
rangeAxisIndex, transX, transY, orientation);
crosshairState.updateCrosshairX(x, domainAxisIndex);
crosshairState.updateCrosshairY(y, rangeAxisIndex);
protected void updateCrosshairValues(CrosshairState crosshairState,
double x, double y, double transX, double transY,
PlotOrientation orientation) {
updateCrosshairValues(crosshairState, x, y, 0, 0, transX, transY,
orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, ph1 + y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, plot.getOrientation());
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x, y, domainAxisIndex,
rangeAxisIndex, transX, transY, orientation);
int l_domainAxisIndex = x_plot.getDomainAxisIndex(x_domainAxis);
int l_rangeAxisIndex  = x_plot.getRangeAxisIndex(x_rangeAxis);
updateCrosshairValues(x_crosshairState, l_x0, l_y0, l_domainAxisIndex,
l_rangeAxisIndex, l_x1, l_y1, l_orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x, y, domainAxisIndex,
rangeAxisIndex, transX, transY, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x, y, domainAxisIndex,
rangeAxisIndex, transX, transY, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);int count = unit.getCount();
calendar.set(Calendar.MILLISECOND, value - 1);
calendar.set(Calendar.SECOND, value - 1);
calendar.set(Calendar.MINUTE, value - 1);
calendar.set(Calendar.HOUR_OF_DAY, value - 1);
calendar.set(Calendar.DATE, value - 1);
month = (Month) month.previous();
calendar.set(Calendar.YEAR, value - 1);ChartViewer viewer = new ChartViewer(chart);= CloneUtils.cloneMapValues(this.itemLabelFontMap);
clone.positiveItemLabelPositionMap = CloneUtils.cloneMapValues(
clone.negativeItemLabelPositionMap = CloneUtils.cloneMapValues(
clone.legendTextFontMap = CloneUtils.cloneMapValues(
yy + halfW));
import static org.junit.Assert.assertTrue;
import org.junit.Before;
public void setUp() {
getTimeline();
r1.setPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setSeriesPaint(0, new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.white));
r2.setSeriesPaint(0, new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.white));
r1.setBasePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setBasePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setFillPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setSeriesFillPaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setSeriesFillPaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setBaseFillPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setBaseFillPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setSeriesOutlinePaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setSeriesOutlinePaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setBaseOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setBaseOutlinePaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setItemLabelPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r2.setItemLabelPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r1.setSeriesItemLabelPaint(0, new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r2.setSeriesItemLabelPaint(0, new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r1.setBaseItemLabelPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r2.setBaseItemLabelPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.gray));
r1.setLegendTextPaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setLegendTextPaint(0, new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setBaseLegendTextPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r2.setBaseLegendTextPaint(new GradientPaint(1.0f, 2.0f, Color.blue,
3.0f, 4.0f, Color.red));
r1.setSeriesPositiveItemLabelPosition(0, new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.CENTER));
r2.setSeriesPositiveItemLabelPosition(0, new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.CENTER));
r2.setSeriesPositiveItemLabelPosition(1, new ItemLabelPosition(ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
r1.setSeriesNegativeItemLabelPosition(0, new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.CENTER));
r2.setSeriesNegativeItemLabelPosition(0, new ItemLabelPosition(ItemLabelAnchor.CENTER, TextAnchor.CENTER));
r2.setSeriesNegativeItemLabelPosition(1, new ItemLabelPosition(ItemLabelAnchor.INSIDE1, TextAnchor.CENTER));
r1.setSeriesPaint(0, Color.black);
r2.setSeriesPaint(0, Color.black);
r1.setSeriesFillPaint(0, Color.yellow);
r2.setSeriesFillPaint(0, Color.yellow);
r1.setSeriesOutlinePaint(0, Color.yellow);
r2.setSeriesOutlinePaint(0, Color.yellow);
r1.setSeriesItemLabelPaint(0, Color.red);
r2.setSeriesItemLabelPaint(0, Color.red);
r1.setLegendTextPaint(3, Color.red);
r2.setLegendTextPaint(3, Color.red);
r1.setBaseLegendTextPaint(Color.green);
r2.setBaseLegendTextPaint(Color.green);
r1.setBasePaint(Color.blue);
r1.setBaseLegendTextPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.blue));
r2.setBasePaint(Color.red);
r.setPaint(Color.orange);
assertEquals(Color.orange, r.getItemPaint(0, 0));
r.setOutlinePaint(Color.orange);
assertEquals(Color.orange, r.getItemOutlinePaint(0, 0));
r.setItemLabelPaint(Color.green);
assertEquals(Color.green, r.getItemLabelPaint(0, 0));
r1.setPaint(Color.red);
r1.setSeriesPaint(0, Color.red);
r1.setBasePaint(Color.red);
r1.setOutlinePaint(Color.red);
r1.setSeriesOutlinePaint(0, Color.red);
r1.setBaseOutlinePaint(Color.red);
r1.setItemLabelPaint(Color.blue);
r1.setSeriesItemLabelPaint(0, Color.blue);
r1.setBaseItemLabelPaint(Color.blue);
r1.setBaseLegendTextPaint(new GradientPaint(1.0f, 2.0f, Color.red,
3.0f, 4.0f, Color.green));
assertEquals(Color.blue, r.getBasePaint());
assertEquals(Color.blue, r.lookupSeriesPaint(0));
assertEquals(Color.white, r.getBaseFillPaint());
assertEquals(Color.white, r.lookupSeriesFillPaint(0));
assertEquals(Color.gray, r.getBaseOutlinePaint());
assertEquals(Color.gray, r.lookupSeriesOutlinePaint(0));clone.positiveItemLabelPositionMap = CloneUtils.cloneMapValues(
clone.negativeItemLabelPositionMap = CloneUtils.cloneMapValues(= CloneUtils.cloneMapValues(this.itemLabelFontMap);
clone.legendTextFontMap = CloneUtils.cloneMapValues(XYPlot plot, XYDataset data, PlotRenderingInfo info) {protected void selectHorizontalAutoTickUnit(Graphics2D g2,
double tickLabelWidth = estimateMaximumTickLabelWidth(g2,
getTickUnit());
TickUnitSource tickUnits = getStandardTickUnits();
TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());
NumberTickUnit unit2 = (NumberTickUnit) tickUnits.getCeilingTickUnit(
guess);
unit2 = (NumberTickUnit) tickUnits.getLargerTickUnit(unit2);
double guess = unit1.getSize();
if (unitHeight > 0) {private long time;
this(new Date());
this(new Date(millisecond));
this.time = time.getTime();public void testrefreshTicksWithZeroTickUnit() {TickUnits t1 = (TickUnits) NumberAxis.createIntegerTickUnits();
TickUnits t1 = (TickUnits) NumberAxis.createIntegerTickUnits();
TickUnits t1 = (TickUnits) NumberAxis.createIntegerTickUnits();
TickUnits t2 = (TickUnits) NumberAxis.createIntegerTickUnits();CategoryAxis result = null;
if (index < this.domainAxes.size()) {
result = (CategoryAxis) this.domainAxes.get(index);
AxisLocation result = null;
if (index < this.domainAxisLocations.size()) {
result = (AxisLocation) this.domainAxisLocations.get(index);
else {
for (int i = 0; i < this.domainAxes.size(); i++) {
CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);
if (axis != null) {
axis.removeChangeListener(this);
for (int i = 0; i < this.domainAxes.size(); i++) {
CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);
if (axis != null) {
axis.configure();
ValueAxis result = null;
if (index < this.rangeAxes.size()) {
result = (ValueAxis) this.rangeAxes.get(index);
ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);
AxisLocation result = null;
if (index < this.rangeAxisLocations.size()) {
result = (AxisLocation) this.rangeAxisLocations.get(index);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);
if (axis != null) {
axis.removeChangeListener(this);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);
if (axis != null) {
axis.configure();
CategoryDataset result = null;
if (this.datasets.size() > index) {
result = (CategoryDataset) this.datasets.get(index);
return result;
int result = -1;
for (int i = 0; i < this.datasets.size(); i++) {
if (dataset == this.datasets.get(i)) {
result = i;
break;
return result;
List axisIndices = new java.util.ArrayList(1);
axisIndices.add(new Integer(axisIndex));
if (index < 0) {
throw new IllegalArgumentException("Requires 'index' >= 0.");
Integer key = new Integer(index);
this.datasetToDomainAxesMap.put(key, new ArrayList(axisIndices));
if (index < 0) {
throw new IllegalArgumentException("Negative 'index'.");
else {
if (index < 0) {
throw new IllegalArgumentException("Requires 'index' >= 0.");
Integer key = new Integer(index);
this.datasetToRangeAxesMap.put(key, new ArrayList(axisIndices));
if (index < 0) {
throw new IllegalArgumentException("Negative 'index'.");
ValueAxis axis = null;
else {
CategoryItemRenderer result = null;
if (this.renderers.size() > index) {
result = (CategoryItemRenderer) this.renderers.get(index);
return result;
CategoryItemRenderer result = null;
for (int i = 0; i < this.datasets.size(); i++) {
if (this.datasets.get(i) == dataset) {
result = (CategoryItemRenderer) this.renderers.get(i);
break;
return result;
int count = this.datasets.size();
for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {
CategoryDataset dataset = getDataset(datasetIndex);
else if (this.orientation == PlotOrientation.VERTICAL) {
else {
int count = this.rangeAxes.size();
for (int axisIndex = 0; axisIndex < count; axisIndex++) {
ValueAxis yAxis = getRangeAxis(axisIndex);
else {
else {
else {
else if (layer == Layer.BACKGROUND) {
else {
else if (layer == Layer.BACKGROUND) {
else {
for(int i = 0; i < this.annotations.size(); i++) {
Rectangle2D plotArea,
AxisSpace space) {
if (this.orientation == PlotOrientation.HORIZONTAL) {
else if (this.orientation == PlotOrientation.VERTICAL) {
for (int i = 0; i < this.domainAxes.size(); i++) {
Axis xAxis = (Axis) this.domainAxes.get(i);
Rectangle2D plotArea,
AxisSpace space) {
if (this.orientation == PlotOrientation.HORIZONTAL) {
else if (this.orientation == PlotOrientation.VERTICAL) {
else {
for (int i = 0; i < this.rangeAxes.size(); i++) {
Axis yAxis = (Axis) this.rangeAxes.get(i);
protected AxisSpace calculateAxisSpace(Graphics2D g2,
Rectangle2D plotArea) {
else {
for (int i = 0; i < this.renderers.size(); i++) {
for (int i = 0; i < this.renderers.size(); i++) {
if (order == DatasetRenderingOrder.FORWARD) {
for (int i = 0; i < this.datasets.size(); i++) {
foundData = render(g2, dataArea, i, state, crosshairState)
else {  // DatasetRenderingOrder.REVERSE
for (int i = this.datasets.size() - 1; i >= 0; i--) {
foundData = render(g2, dataArea, i, state, crosshairState)
|| foundData;
for (int i = 0; i < this.renderers.size(); i++) {
for (int i = 0; i < this.renderers.size(); i++) {
protected Map drawAxes(Graphics2D g2,
Rectangle2D plotArea,
Rectangle2D dataArea,
PlotRenderingInfo plotState) {
for (int index = 0; index < this.domainAxes.size(); index++) {
CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);
for (int index = 0; index < this.rangeAxes.size(); index++) {
ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);
for (int i = 0; i < this.datasets.size(); i++) {
CategoryDataset dataset = this.datasets.get(i);
if (dataset != null) {
result.add(dataset);
if (dataset != null) {
result.add(dataset);
for (int i = 0; i < this.datasets.size(); i++) {
else {
int rangeAxisCount = getRangeAxisCount();
for (int i = 0; i < rangeAxisCount; i++) {
ValueAxis axis = getRangeAxis(i);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);
if (rangeAxis != null) {
if (useAnchor) {
double sourceY = source.getY();
if (this.orientation == PlotOrientation.HORIZONTAL) {
sourceY = source.getX();
double anchorY = rangeAxis.java2DToValue(sourceY,
info.getDataArea(), getRangeAxisEdge());
rangeAxis.resizeRange2(factor, anchorY);
else {
rangeAxis.resizeRange(factor);
PlotRenderingInfo state, Point2D source) {
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);
if (rangeAxis != null) {
rangeAxis.zoomRange(lowerPercent, upperPercent);
for (int i = 0; i < this.domainAxes.size(); i++) {
CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);
int datasetCount = this.datasets.size();
for (int i = 0; i < datasetCount; i++) {
Dataset dataset = (Dataset) this.datasets.get(i);
int rendererCount = this.renderers.size();
for (int i = 0; i < rendererCount; i++) {
CategoryItemRenderer renderer
= (CategoryItemRenderer) this.renderers.get(i);
import org.jfree.data.general.Dataset;
private Map datasetToDomainAxesMap;
private Map datasetToRangeAxesMap;
private List annotations;
ValueAxis result = null;
if (index < this.domainAxes.size()) {
result = (ValueAxis) this.domainAxes.get(index);
for (int i = 0; i < this.domainAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.domainAxes.get(i);
for (int i = 0; i < this.domainAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.domainAxes.get(i);
AxisLocation result = null;
if (index < this.domainAxisLocations.size()) {
result = (AxisLocation) this.domainAxisLocations.get(index);
ValueAxis result = null;
if (index < this.rangeAxes.size()) {
result = (ValueAxis) this.rangeAxes.get(index);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);
AxisLocation result = null;
if (index < this.rangeAxisLocations.size()) {
result = (AxisLocation) this.rangeAxisLocations.get(index);
XYDataset result = null;
if (this.datasets.size() > index) {
result = (XYDataset) this.datasets.get(index);
return result;
int result = -1;
for (int i = 0; i < this.datasets.size(); i++) {
if (dataset == this.datasets.get(i)) {
result = i;
break;
return result;
if (index < 0) {
throw new IllegalArgumentException("Requires 'index' >= 0.");
if (index < 0) {
throw new IllegalArgumentException("Requires 'index' >= 0.");
private void checkAxisIndices(List indices) {
HashSet set = new HashSet();
for (int i = 0; i < count; i++) {
Object item = indices.get(i);
if (!(item instanceof Integer)) {
throw new IllegalArgumentException(
"Indices must be Integer instances.");
XYItemRenderer result = null;
if (this.renderers.size() > index) {
result = (XYItemRenderer) this.renderers.get(index);
return result;
XYItemRenderer result = null;
for (int i = 0; i < this.datasets.size(); i++) {
if (this.datasets.get(i) == dataset) {
result = (XYItemRenderer) this.renderers.get(i);
if (result == null) {
result = getRenderer();
break;
Set keys = this.backgroundDomainMarkers.keySet();
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Integer key = (Integer) iterator.next();
clearDomainMarkers(key.intValue());
Set keys = this.foregroundDomainMarkers.keySet();
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Integer key = (Integer) iterator.next();
clearDomainMarkers(key.intValue());
Set keys = this.backgroundRangeMarkers.keySet();
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Integer key = (Integer) iterator.next();
clearRangeMarkers(key.intValue());
Set keys = this.foregroundRangeMarkers.keySet();
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Integer key = (Integer) iterator.next();
clearRangeMarkers(key.intValue());
for(int i = 0; i < this.annotations.size(); i++){
XYAnnotation annotation = (XYAnnotation) this.annotations.get(i);
for (int i = 0; i < this.domainAxes.size(); i++) {
Axis axis = (Axis) this.domainAxes.get(i);
RectangleEdge edge = getDomainAxisEdge(i);
for (int i = 0; i < this.rangeAxes.size(); i++) {
Axis axis = (Axis) this.rangeAxes.get(i);
RectangleEdge edge = getRangeAxisEdge(i);
for (int i = 0; i < this.renderers.size(); i++) {
drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);
for (int i = 0; i < this.renderers.size(); i++) {
drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);
if (order == DatasetRenderingOrder.FORWARD) {
int rendererCount = this.renderers.size();
for (int i = 0; i < rendererCount; i++) {
XYItemRenderer r = getRenderer(i);
if (r != null) {
r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,
for (int i = 0; i < getDatasetCount(); i++) {
foundData = render(g2, dataArea, i, info, crosshairState)
|| foundData;
for (int i = 0; i < rendererCount; i++) {
XYItemRenderer r = getRenderer(i);
if (r != null) {
ValueAxis domainAxis = getDomainAxisForDataset(i);
ValueAxis rangeAxis = getRangeAxisForDataset(i);
r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,
Layer.FOREGROUND, info);
else if (order == DatasetRenderingOrder.REVERSE) {
int rendererCount = this.renderers.size();
for (int i = rendererCount - 1; i >= 0; i--) {
XYItemRenderer r = getRenderer(i);
if (i >= getDatasetCount()) { // we need the dataset to make
continue;                 // a link to the axes
if (r != null) {
r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,
Layer.BACKGROUND, info);
for (int i = getDatasetCount() - 1; i >= 0; i--) {
foundData = render(g2, dataArea, i, info, crosshairState)
|| foundData;
for (int i = rendererCount - 1; i >= 0; i--) {
XYItemRenderer r = getRenderer(i);
if (i >= getDatasetCount()) { // we need the dataset to make
continue;                 // a link to the axes
if (r != null) {
ValueAxis domainAxis = getDomainAxisForDataset(i);
ValueAxis rangeAxis = getRangeAxisForDataset(i);
r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,
int xAxisIndex = crosshairState.getDomainAxisIndex();
ValueAxis xAxis = getDomainAxis(xAxisIndex);
RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);
int yAxisIndex = crosshairState.getRangeAxisIndex();
ValueAxis yAxis = getRangeAxis(yAxisIndex);
RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);
for (int i = 0; i < this.renderers.size(); i++) {
for (int i = 0; i < this.renderers.size(); i++) {
protected Map drawAxes(Graphics2D g2,
Rectangle2D plotArea,
Rectangle2D dataArea,
PlotRenderingInfo plotState) {
for (int index = 0; index < this.domainAxes.size(); index++) {
ValueAxis axis = (ValueAxis) this.domainAxes.get(index);
axisCollection.add(axis, getDomainAxisEdge(index));
for (int index = 0; index < this.rangeAxes.size(); index++) {
ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);
if (yAxis != null) {
axisCollection.add(yAxis, getRangeAxisEdge(index));
int upper = Math.max(getDatasetCount(), getRendererCount());
if (index < 0 || index >= upper) {
throw new IllegalArgumentException("Index " + index
+ " out of bounds.");
int upper = Math.max(getDatasetCount(), getRendererCount());
if (index < 0 || index >= upper) {
throw new IllegalArgumentException("Index " + index
+ " out of bounds.");
else if ((tick.getTickType() == TickType.MAJOR)
else if ((tick.getTickType() == TickType.MAJOR)
public void drawAnnotations(Graphics2D g2,
Rectangle2D dataArea,
private List getDatasetsMappedToDomainAxis(Integer axisIndex) {
List result = new ArrayList();
for (int i = 0; i < this.datasets.size(); i++) {
List mappedAxes = (List) this.datasetToDomainAxesMap.get(
new Integer(i));
result.add(this.datasets.get(i));
else {
result.add(this.datasets.get(i));
private List getDatasetsMappedToRangeAxis(Integer axisIndex) {
List result = new ArrayList();
for (int i = 0; i < this.datasets.size(); i++) {
List mappedAxes = (List) this.datasetToRangeAxesMap.get(
new Integer(i));
result.add(this.datasets.get(i));
else {
result.add(this.datasets.get(i));
List mappedDatasets = new ArrayList();
List includedAnnotations = new ArrayList();
mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
new Integer(domainIndex)));
mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
new Integer(rangeIndex)));
Iterator iterator = mappedDatasets.iterator();
while (iterator.hasNext()) {
XYDataset d = (XYDataset) iterator.next();
for (int i = 0; i < this.domainAxes.size(); i++) {
ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);
if (domainAxis != null) {
if (useAnchor) {
double sourceX = source.getX();
if (this.orientation == PlotOrientation.HORIZONTAL) {
sourceX = source.getY();
double anchorX = domainAxis.java2DToValue(sourceX,
info.getDataArea(), getDomainAxisEdge());
domainAxis.resizeRange2(factor, anchorX);
else {
domainAxis.resizeRange(factor);
for (int i = 0; i < this.domainAxes.size(); i++) {
ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);
if (domainAxis != null) {
domainAxis.zoomRange(lowerPercent, upperPercent);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);
if (rangeAxis != null) {
if (useAnchor) {
double sourceY = source.getY();
if (this.orientation == PlotOrientation.HORIZONTAL) {
sourceY = source.getX();
double anchorY = rangeAxis.java2DToValue(sourceY,
info.getDataArea(), getRangeAxisEdge());
rangeAxis.resizeRange2(factor, anchorY);
else {
rangeAxis.resizeRange(factor);
for (int i = 0; i < this.rangeAxes.size(); i++) {
ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);
if (rangeAxis != null) {
rangeAxis.zoomRange(lowerPercent, upperPercent);
int count = this.datasets.size();
for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {
XYDataset dataset = getDataset(datasetIndex);
if (dataset != null) {
XYItemRenderer renderer = getRenderer(datasetIndex);
if (renderer == null) {
renderer = getRenderer(0);
if (renderer != null) {
int seriesCount = dataset.getSeriesCount();
for (int i = 0; i < seriesCount; i++) {
if (renderer.isSeriesVisible(i)
&& renderer.isSeriesVisibleInLegend(i)) {
LegendItem item = renderer.getLegendItem(
datasetIndex, i);
if (item != null) {
result.add(item);
int domainAxisCount = this.domainAxes.size();
for (int i = 0; i < domainAxisCount; i++) {
Axis axis = (Axis) this.domainAxes.get(i);
int rangeAxisCount = this.rangeAxes.size();
for (int i = 0; i < rangeAxisCount; i++) {
Axis axis = (Axis) this.rangeAxes.get(i);
int datasetCount = this.datasets.size();
for (int i = 0; i < datasetCount; i++) {
Dataset dataset = (Dataset) this.datasets.get(i);
int rendererCount = this.renderers.size();
for (int i = 0; i < rendererCount; i++) {
XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);private String categoryParameterName = "category";
private String indexParameterName = "pieIndex";
public StandardPieURLGenerator(String prefix,
String categoryParameterName) {
this(prefix, categoryParameterName, "pieIndex");
public StandardPieURLGenerator(String prefix, String categoryParameterName,
String indexParameterName) {
ParamChecks.nullNotPermitted(categoryParameterName, "categoryParameterName");
this.categoryParameterName = categoryParameterName;
this.indexParameterName = indexParameterName;
if (url.indexOf("?") > -1) {
url += "&amp;" + this.categoryParameterName + "="
+ URLUtilities.encode(key.toString(), "UTF-8");
else {
url += "?" + this.categoryParameterName + "="
+ URLUtilities.encode(key.toString(), "UTF-8");
if (this.indexParameterName != null) {
url += "&amp;" + this.indexParameterName + "="
+ String.valueOf(pieIndex);
if (!this.categoryParameterName.equals(that.categoryParameterName)) {
if (!ObjectUtilities.equal(this.indexParameterName,
that.indexParameterName)) {System.err.println("Unable to add cloned data item.");RectangleEdge position,
HorizontalAlignment horizontalAlignment,
VerticalAlignment verticalAlignment,
RectangleInsets padding) {package org.jfree.chart.plot;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.jfree.chart.LegendItemCollection;
import org.jfree.chart.axis.AxisSpace;
import org.jfree.chart.axis.AxisState;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.event.PlotChangeListener;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.util.ParamChecks;
import org.jfree.chart.util.ShadowGenerator;
import org.jfree.data.Range;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.util.ObjectUtilities;
public class CombinedDomainXYPlot extends XYPlot
implements PlotChangeListener {
private static final long serialVersionUID = -7765545541261907383L;
private List subplots;
private double gap = 5.0;
private transient Rectangle2D[] subplotAreas;
public CombinedDomainXYPlot() {
this(new NumberAxis());
public CombinedDomainXYPlot(ValueAxis domainAxis) {
super(null,        // no data in the parent plot
domainAxis,
null,        // no range axis
null);       // no renderer
this.subplots = new java.util.ArrayList();
public String getPlotType() {
return "Combined_Domain_XYPlot";
public void setOrientation(PlotOrientation orientation) {
super.setOrientation(orientation);
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot plot = (XYPlot) iterator.next();
plot.setOrientation(orientation);
public void setShadowGenerator(ShadowGenerator generator) {
setNotify(false);
super.setShadowGenerator(generator);
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot plot = (XYPlot) iterator.next();
plot.setShadowGenerator(generator);
setNotify(true);
public Range getDataRange(ValueAxis axis) {
Range result = null;
if (this.subplots != null) {
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot subplot = (XYPlot) iterator.next();
result = Range.combine(result, subplot.getDataRange(axis));
return result;
public double getGap() {
return this.gap;
public void setGap(double gap) {
this.gap = gap;
fireChangeEvent();
public void add(XYPlot subplot) {
add(subplot, 1);
public void add(XYPlot subplot, int weight) {
ParamChecks.nullNotPermitted(subplot, "subplot");
if (weight <= 0) {
throw new IllegalArgumentException("Require weight >= 1.");
subplot.setParent(this);
subplot.setWeight(weight);
subplot.setInsets(RectangleInsets.ZERO_INSETS, false);
subplot.setDomainAxis(null);
subplot.addChangeListener(this);
this.subplots.add(subplot);
ValueAxis axis = getDomainAxis();
if (axis != null) {
axis.configure();
fireChangeEvent();
public void remove(XYPlot subplot) {
ParamChecks.nullNotPermitted(subplot, "subplot");
int position = -1;
int size = this.subplots.size();
int i = 0;
while (position == -1 && i < size) {
if (this.subplots.get(i) == subplot) {
position = i;
i++;
if (position != -1) {
this.subplots.remove(position);
subplot.setParent(null);
subplot.removeChangeListener(this);
ValueAxis domain = getDomainAxis();
if (domain != null) {
domain.configure();
fireChangeEvent();
public List getSubplots() {
if (this.subplots != null) {
return Collections.unmodifiableList(this.subplots);
else {
return Collections.EMPTY_LIST;
protected AxisSpace calculateAxisSpace(Graphics2D g2,
Rectangle2D plotArea) {
AxisSpace space = new AxisSpace();
PlotOrientation orientation = getOrientation();
AxisSpace fixed = getFixedDomainAxisSpace();
if (fixed != null) {
if (orientation == PlotOrientation.HORIZONTAL) {
space.setLeft(fixed.getLeft());
space.setRight(fixed.getRight());
else if (orientation == PlotOrientation.VERTICAL) {
space.setTop(fixed.getTop());
space.setBottom(fixed.getBottom());
else {
ValueAxis xAxis = getDomainAxis();
RectangleEdge xEdge = Plot.resolveDomainAxisLocation(
getDomainAxisLocation(), orientation);
if (xAxis != null) {
space = xAxis.reserveSpace(g2, this, plotArea, xEdge, space);
Rectangle2D adjustedPlotArea = space.shrink(plotArea, null);
int n = this.subplots.size();
int totalWeight = 0;
for (int i = 0; i < n; i++) {
XYPlot sub = (XYPlot) this.subplots.get(i);
totalWeight += sub.getWeight();
this.subplotAreas = new Rectangle2D[n];
double x = adjustedPlotArea.getX();
double y = adjustedPlotArea.getY();
double usableSize = 0.0;
if (orientation == PlotOrientation.HORIZONTAL) {
usableSize = adjustedPlotArea.getWidth() - this.gap * (n - 1);
else if (orientation == PlotOrientation.VERTICAL) {
usableSize = adjustedPlotArea.getHeight() - this.gap * (n - 1);
for (int i = 0; i < n; i++) {
XYPlot plot = (XYPlot) this.subplots.get(i);
if (orientation == PlotOrientation.HORIZONTAL) {
double w = usableSize * plot.getWeight() / totalWeight;
this.subplotAreas[i] = new Rectangle2D.Double(x, y, w,
adjustedPlotArea.getHeight());
x = x + w + this.gap;
else if (orientation == PlotOrientation.VERTICAL) {
double h = usableSize * plot.getWeight() / totalWeight;
this.subplotAreas[i] = new Rectangle2D.Double(x, y,
adjustedPlotArea.getWidth(), h);
y = y + h + this.gap;
AxisSpace subSpace = plot.calculateRangeAxisSpace(g2,
this.subplotAreas[i], null);
space.ensureAtLeast(subSpace);
return space;
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
PlotState parentState, PlotRenderingInfo info) {
if (info != null) {
info.setPlotArea(area);
RectangleInsets insets = getInsets();
insets.trim(area);
setFixedRangeAxisSpaceForSubplots(null);
AxisSpace space = calculateAxisSpace(g2, area);
Rectangle2D dataArea = space.shrink(area, null);
setFixedRangeAxisSpaceForSubplots(space);
ValueAxis axis = getDomainAxis();
RectangleEdge edge = getDomainAxisEdge();
double cursor = RectangleEdge.coordinate(dataArea, edge);
AxisState axisState = axis.draw(g2, cursor, area, dataArea, edge, info);
if (parentState == null) {
parentState = new PlotState();
parentState.getSharedAxisStates().put(axis, axisState);
for (int i = 0; i < this.subplots.size(); i++) {
XYPlot plot = (XYPlot) this.subplots.get(i);
PlotRenderingInfo subplotInfo = null;
if (info != null) {
subplotInfo = new PlotRenderingInfo(info.getOwner());
info.addSubplotInfo(subplotInfo);
plot.draw(g2, this.subplotAreas[i], anchor, parentState,
subplotInfo);
if (info != null) {
info.setDataArea(dataArea);
public LegendItemCollection getLegendItems() {
LegendItemCollection result = getFixedLegendItems();
if (result == null) {
result = new LegendItemCollection();
if (this.subplots != null) {
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot plot = (XYPlot) iterator.next();
LegendItemCollection more = plot.getLegendItems();
result.addAll(more);
return result;
public void zoomRangeAxes(double factor, PlotRenderingInfo info,
Point2D source) {
zoomRangeAxes(factor, info, source, false);
public void zoomRangeAxes(double factor, PlotRenderingInfo state,
Point2D source, boolean useAnchor) {
XYPlot subplot = findSubplot(state, source);
if (subplot != null) {
subplot.zoomRangeAxes(factor, state, source, useAnchor);
else {
Iterator iterator = getSubplots().iterator();
while (iterator.hasNext()) {
subplot = (XYPlot) iterator.next();
subplot.zoomRangeAxes(factor, state, source, useAnchor);
public void zoomRangeAxes(double lowerPercent, double upperPercent,
PlotRenderingInfo info, Point2D source) {
XYPlot subplot = findSubplot(info, source);
if (subplot != null) {
subplot.zoomRangeAxes(lowerPercent, upperPercent, info, source);
else {
Iterator iterator = getSubplots().iterator();
while (iterator.hasNext()) {
subplot = (XYPlot) iterator.next();
subplot.zoomRangeAxes(lowerPercent, upperPercent, info, source);
public void panRangeAxes(double panRange, PlotRenderingInfo info,
Point2D source) {
XYPlot subplot = findSubplot(info, source);
if (subplot != null) {
PlotRenderingInfo subplotInfo = info.getSubplotInfo(
info.getSubplotIndex(source));
if (subplotInfo == null) {
return;
for (int i = 0; i < subplot.getRangeAxisCount(); i++) {
ValueAxis rangeAxis = subplot.getRangeAxis(i);
rangeAxis.pan(panRange);
public XYPlot findSubplot(PlotRenderingInfo info, Point2D source) {
ParamChecks.nullNotPermitted(info, "info");
ParamChecks.nullNotPermitted(source, "source");
XYPlot result = null;
int subplotIndex = info.getSubplotIndex(source);
if (subplotIndex >= 0) {
result =  (XYPlot) this.subplots.get(subplotIndex);
return result;
public void setRenderer(XYItemRenderer renderer) {
super.setRenderer(renderer);  // not strictly necessary, since the
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot plot = (XYPlot) iterator.next();
plot.setRenderer(renderer);
public void setFixedRangeAxisSpace(AxisSpace space) {
super.setFixedRangeAxisSpace(space);
setFixedRangeAxisSpaceForSubplots(space);
fireChangeEvent();
protected void setFixedRangeAxisSpaceForSubplots(AxisSpace space) {
Iterator iterator = this.subplots.iterator();
while (iterator.hasNext()) {
XYPlot plot = (XYPlot) iterator.next();
plot.setFixedRangeAxisSpace(space, false);
public void handleClick(int x, int y, PlotRenderingInfo info) {
Rectangle2D dataArea = info.getDataArea();
if (dataArea.contains(x, y)) {
for (int i = 0; i < this.subplots.size(); i++) {
XYPlot subplot = (XYPlot) this.subplots.get(i);
PlotRenderingInfo subplotInfo = info.getSubplotInfo(i);
subplot.handleClick(x, y, subplotInfo);
public void plotChanged(PlotChangeEvent event) {
notifyListeners(event);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof CombinedDomainXYPlot)) {
return false;
CombinedDomainXYPlot that = (CombinedDomainXYPlot) obj;
if (this.gap != that.gap) {
return false;
if (!ObjectUtilities.equal(this.subplots, that.subplots)) {
return false;
return super.equals(obj);
public Object clone() throws CloneNotSupportedException {
CombinedDomainXYPlot result = (CombinedDomainXYPlot) super.clone();
result.subplots = (List) ObjectUtilities.deepClone(this.subplots);
for (Iterator it = result.subplots.iterator(); it.hasNext();) {
Plot child = (Plot) it.next();
child.setParent(result);
ValueAxis domainAxis = result.getDomainAxis();
if (domainAxis != null) {
domainAxis.configure();
return result;boolean firstParameter = result.indexOf("?") == -1;
result += this.seriesParameterName + "=" + URLUtilities.encode(
seriesKey.toString(), "UTF-8");
result += this.itemParameterName + "=" + URLUtilities.encode(xValue,
"UTF-8");implements SeriesChangeListener {throws IOException {
boolean encodeAlpha) throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, encodeAlpha);
float quality) throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, quality);
float quality, boolean encodeAlpha)
throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, quality, encodeAlpha);
OutputStream outputStream) throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, quality);
OutputStream outputStream, boolean encodeAlpha) throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, encodeAlpha);
OutputStream outputStream, float quality, boolean encodeAlpha)
throws IOException {
ImageEncoder imageEncoder
= ImageEncoderFactory.newInstance(format, quality, encodeAlpha);= new SimpleDateFormat("yyyy-MM-dd");
protected static final DateFormat
DATE_FORMAT_SHORT = DateFormat.getDateInstance(DateFormat.SHORT);
protected static final DateFormat
DATE_FORMAT_MEDIUM = DateFormat.getDateInstance(DateFormat.MEDIUM);
protected static final DateFormat
DATE_FORMAT_LONG = DateFormat.getDateInstance(DateFormat.LONG);
MonthConstants {
TimeZone zone) {than the period : <pre>x1 - x0 >= period</pre>. Thus, at most a full
<---previous cycle---><-------current cycle-------->
<-------current cycle--------><---previous cycle--->else {import org.jfree.chart.event.PlotChangeEvent;Math.abs(x2 - x1), dataArea.getWidth());boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;
boolean success = false;XYDrawableAnnotation a2 = null;
a2 = (XYDrawableAnnotation) a1.clone();Number high = getHigh(series, item);
if (high != null) {
result = high.doubleValue();
Number low = getLow(series, item);
if (low != null) {
result = low.doubleValue();
Number close = getClose(series, item);
if (close != null) {
result = close.doubleValue();
Number volume = getVolume(series, item);
if (volume != null) {
result = volume.doubleValue();int day = this.day.getDayOfMonth();
calendar.set(year, month, day, this.hour, this.minute, this.second);
int day = this.day.getDayOfMonth();
calendar.set(year, month, day, this.hour, this.minute, 0);
int day = this.day.getDayOfMonth();
calendar.set(year, month, day, this.hour, this.minute, 59);
int day = this.day.getDayOfMonth();
calendar.set(year, month, day, this.hour, this.minute, this.second);newMap = null;public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
Number x = getX(series, item);
if (x != null) {
result = x.doubleValue();
Number y = getY(series, item);
if (y != null) {
result = y.doubleValue();
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
Shape entityArea = null;
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset data,
PlotRenderingInfo info) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
EntityCollection entities = null;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D plotArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
Shape shape = null;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
protected void drawFirstPassShape(Graphics2D g2,
int pass,
int series,
int item,
Shape shape) {
boolean visible = false;
Shape hotspot = null;
Paint p = null;
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset data,
PlotRenderingInfo info) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
double transX0 = 0;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {public CategoryItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
CategoryPlot plot,
int rendererIndex,
PlotRenderingInfo info) {
double aRadius = 0;                 // average radius
double yyAverage = 0.0;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
protected void calculateBarWidth(CategoryPlot plot,
Rectangle2D dataArea,
int rendererIndex,
CategoryItemRendererState state) {
protected double calculateBarW0(CategoryPlot plot,
PlotOrientation orientation,
Rectangle2D dataArea,
CategoryAxis domainAxis,
CategoryItemRendererState state,
int row,
int column) {
double space = 0.0;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
Rectangle2D bar = null;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
protected void calculateBarWidth(CategoryPlot plot,
Rectangle2D dataArea,
int rendererIndex,
CategoryItemRendererState state) {
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset data,
int row,
int column,
int pass) {
double rectHeight = 0.0;
double rectWidth = 0.0;
protected double calculateBarW0(CategoryPlot plot,
PlotOrientation orientation,
Rectangle2D dataArea,
CategoryAxis domainAxis,
CategoryItemRendererState state,
int row,
int column) {
double space = 0.0;
Line2D line = null;
double x = 0.0;
double y = 0.0;
public void drawDomainGridline(Graphics2D g2,
CategoryPlot plot,
Rectangle2D dataArea,
double value) {
public void drawRangeGridline(Graphics2D g2,
CategoryPlot plot,
ValueAxis axis,
Rectangle2D dataArea,
double value) {
public void drawRangeMarker(Graphics2D g2,
CategoryPlot plot,
ValueAxis axis,
Marker marker,
Rectangle2D dataArea) {
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
final int width = shape.getBounds().width;
final int height = shape.getBounds().height;
final GeneralPath path = new GeneralPath(shape);
return new Icon() {
public void paintIcon(Component c, Graphics g, int x, int y) {
Graphics2D g2 = (Graphics2D) g;
path.transform(AffineTransform.getTranslateInstance(x, y));
if (fillPaint != null) {
g2.setPaint(fillPaint);
g2.fill(path);
if (outlinePaint != null) {
g2.setPaint(outlinePaint);
g2.draw(path);
path.transform(AffineTransform.getTranslateInstance(-x, -y));
public int getIconWidth() {
return width;
public int getIconHeight() {
return height;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
Shape entityArea = null;
protected void calculateBarWidth(CategoryPlot plot,
Rectangle2D dataArea,
int rendererIndex,
CategoryItemRendererState state) {
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
Rectangle2D bar = null;
protected void calculateBarWidth(CategoryPlot plot,
Rectangle2D dataArea,
int rendererIndex,
CategoryItemRendererState state) {
int series = 0;
int series = 0;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset data,
int row,
int column,
int pass) {
Line2D line = null;
Line2D line = null;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {AreaRendererEndType t = (AreaRendererEndType) obj;
if (!this.name.equals(t.toString())) {int izV = 0;
int izV = 0;
PlotState parentState,
PlotRenderingInfo info) {
PlotState parentState,
PlotRenderingInfo info) {
int[] xpoints = null;
int[] ypoints = null;
PlotState parentState,
PlotRenderingInfo info) {
public void zoomRangeAxes(double factor,
PlotRenderingInfo info, Point2D source) {
PlotState parentState,
PlotRenderingInfo info) {
double valueP2X = 0;
double valueP2Y = 0;
boolean include = true;
PlotState parentState,
PlotRenderingInfo info) {
DrawingSupplier result = null;
protected void drawItem(Graphics2D g2,
int section,
Rectangle2D dataArea,
PiePlotState state,
int currentPass) {
int seriesCount = 0, catCount = 0;
double v = 0;
Number nV = null;
int row = 0; int col = 0;
String label = null;
String temp = null;
FontMetrics metrics = null;
double cursor = 0;
double major = 0d;
double minor = 0d;
double major = 0d;
double minor = 0d;
Arc2D notch = null;
boolean paintLine = false;Shape d = null;double startY = 0.0;
double topSpace = 0.0;
double bottomSpace = 0.0;
double leftSpace = 0.0;
double rightSpace = 0.0;
double startX = 0.0;
EntityBlockParams ebp = null;
BlockContainer result = null;String result = null;
String result = null;
Object[] items = null;
String result = null;
if (dataset instanceof OHLCDataset) {
OHLCDataset d = (OHLCDataset) dataset;
Number high = d.getHigh(series, item);
Number low = d.getLow(series, item);
Number open = d.getOpen(series, item);
Number close = d.getClose(series, item);
Number x = d.getX(series, item);
result = d.getSeriesKey(series).toString();
if (x != null) {
Date date = new Date(x.longValue());
result = result + "--> Date=" + this.dateFormatter.format(date);
if (high != null) {
result = result + " High=" 
+ this.numberFormatter.format(high.doubleValue());
if (low != null) {
result = result + " Low=" 
+ this.numberFormatter.format(low.doubleValue());
if (open != null) {
result = result + " Open=" 
+ this.numberFormatter.format(open.doubleValue());
if (close != null) {
result = result + " Close=" 
+ this.numberFormatter.format(close.doubleValue());
return result;
= (HighLowItemLabelGenerator) super.clone();
public boolean equals(Object o) {
if (this == o) {
if (!(o instanceof ItemLabelAnchor)) {
ItemLabelAnchor order = (ItemLabelAnchor) o;
if (!this.name.equals(order.toString())) {
String xString = null;
= (StandardContourToolTipGenerator) obj;
String result = null;tabs.insertTab(localizationResources.getString("General1"), null, createPlotPanel(), null, 0);
int index,
boolean isSelected,
boolean cellHasFocus) {
g2.setRenderingHint(
RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF
);public void draw(Graphics2D g2,
Rectangle2D area,
Point2D anchor,
PlotState parentState,
PlotRenderingInfo info) {
int pieCount = 0;
String title = null;
PieDataset piedataset = null;if (Double.isNaN(ys)
if (Double.isNaN(ye)Range result = null;int historyIdx = 0;for (int j = 0; j < result[i].length; j++) {
result[0][j] = result[i][j];
for (int j = 0; j < temp.length; j++) {
result[i][j] = temp[j];
System.out.println("Equation has no solution!");public void draw(Graphics2D g2,
Rectangle2D area,
Point2D anchor,
PlotState parentState,
PlotRenderingInfo info) {
protected AxisSpace calculateAxisSpace(Graphics2D g2,
Rectangle2D plotArea) {public CategoryItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
CategoryPlot plot,
int rendererIndex,
PlotRenderingInfo info) {
protected double calculateBarW0(CategoryPlot plot,
PlotOrientation orientation,
Rectangle2D dataArea,
CategoryAxis domainAxis,
CategoryItemRendererState state,
int row,
int column) {
double space = 0.0;
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
Rectangle2D bar = null;
ItemLabelPosition position = null;import org.jfree.data.general.DatasetUtilities;
Line2D cap1 = null;
Line2D cap2 = null;
Line2D cap1 = null;
Line2D cap2 = null;import org.jfree.data.general.DatasetUtilities;
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset dataset,
PlotRenderingInfo info) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
Rectangle2D body = null;
Rectangle2D hotspot = null;
import org.jfree.data.general.DatasetUtilities;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
import org.jfree.data.general.DatasetUtilities;
LegendItem result = null;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
ItemLabelPosition position = null;
import org.jfree.data.general.DatasetUtilities;
Shape box = null;
Shape box = null;private static long MILLISECONDS_IN_ONE_HOUR = 60 * 60 * 1000L;
private static long MILLISECONDS_IN_ONE_DAY = 24 * MILLISECONDS_IN_ONE_HOUR;ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null;
StringBuffer sb = new StringBuffer();
StringBuffer result = new StringBuffer();
StringBuffer result = new StringBuffer();StringBuffer label = new StringBuffer();StringBuffer result = new StringBuffer();StringBuffer b = new StringBuffer();
StringBuffer b = new StringBuffer();StringBuffer buf = new StringBuffer("TitleEntity: ");
buf.append("tooltip = ");
buf.append(getToolTipText());
return buf.toString();StringBuffer buf = new StringBuffer("PlotEntity: ");
buf.append("tooltip = ");
buf.append(getToolTipText());
return buf.toString();StringBuffer buf = new StringBuffer("JFreeChartEntity: ");
buf.append("tooltip = ");
buf.append(getToolTipText());
return buf.toString();StringBuffer result = new StringBuffer();
StringBuffer tag = new StringBuffer();
StringBuffer buf = new StringBuffer("ChartEntity: ");
buf.append("tooltip = ");
buf.append(this.toolTipText);
return buf.toString();StringBuffer buf = new StringBuffer("CategoryLabelEntity: ");
buf.append("category=");
buf.append(this.key);
buf.append(", tooltip=").append(getToolTipText());
buf.append(", url=").append(getURLText());
return buf.toString();StringBuffer buf = new StringBuffer("AxisEntity: ");
buf.append("tooltip = ");
buf.append(getToolTipText());
return buf.toString();public CategoryItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
CategoryPlot plot,
int rendererIndex,
PlotRenderingInfo info) {
Rectangle2D dataArea) {
public void drawDomainGridline(Graphics2D g2,
CategoryPlot plot,
Rectangle2D dataArea,
double value) {
public void drawRangeMarker(Graphics2D g2,
CategoryPlot plot,
ValueAxis axis,
Marker marker,
Rectangle2D dataArea) {
public void drawItem(Graphics2D g2,
CategoryItemRendererState state,
Rectangle2D dataArea,
CategoryPlot plot,
CategoryAxis domainAxis,
ValueAxis rangeAxis,
CategoryDataset dataset,
int row,
int column,
int pass) {
Rectangle2D bar = null;
GeneralPath bar3dTop = null;public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset, int series, int item,
CrosshairState crosshairState,
int pass) {
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset data,
PlotRenderingInfo info) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
double transDomain = 0.0;
double transRange = 0.0;
EntityCollection entities = null;
entities = info.getOwner().getEntityCollection();
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset data,
PlotRenderingInfo info) {
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
import org.jfree.data.general.DatasetUtilities;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {contentSize = new Size2D(
contentConstraint.getWidth(),
contentConstraint.getHeight()
);
return new Size2D(
calculateTotalWidth(contentSize.getWidth()),
calculateTotalHeight(contentSize.getHeight())
);if (e != null) {
if (e != null) {assertEquals("java.beans.PropertyVetoException: Duplicate key2", 
e.getMessage());(float) regions[0].getMaxX(), Color.white);this.maxY = minIgnoreNaN(this.maxY, yy);return createXYAreaChart(title, xAxisLabel, yAxisLabel, dataset);DefaultKeyedValue clone = (DefaultKeyedValue) super.clone();
return clone;case (DateTickUnit.MILLISECOND) :
case (DateTickUnit.SECOND) :
case (DateTickUnit.MINUTE) :
case (DateTickUnit.HOUR) :
case (DateTickUnit.DAY) :
case (DateTickUnit.MONTH) :
case(DateTickUnit.YEAR) :
case (DateTickUnit.MILLISECOND) :
case (DateTickUnit.SECOND) :
case (DateTickUnit.MINUTE) :
case (DateTickUnit.HOUR) :
case (DateTickUnit.DAY) :
case (DateTickUnit.MONTH) :
case(DateTickUnit.YEAR) :Range r = null;
r = new Range(series.getMinY(), series.getMaxY());import org.jfree.data.category.DefaultCategoryDataset;
e.printStackTrace();import java.awt.Color;import java.awt.geom.Rectangle2D;Rectangle2D.Double entityArea = null;
Rectangle2D.Double rect = null;
double transXm1 = 0.0;
double transXp1 = 0.0;
double transDXm1 = 0.0;
double transY = 0.0;
double transYm1 = 0.0;
double transYp1 = 0.0;
double transDYm1 = 0.0;
double transDY = 0.0;
RectangularShape entityArea = null;
double transX = 0.0;
double transDX = 0.0;
double transY = 0.0;
double transDY = 0.0;
Range range = null;
range = data.getZValueRange(x, y);double result = 0.0;
double labelHeight = 0.0;
double labelWidth = 0.0;
float l = 0.0f;TextTitle subtitle = null;
subtitle = new TextTitle("Bright " + (greenForIncrease ? "red"
: "green") + "=change >=-" + percentDiffForMaxScalereturn;return;
return;return;
return;clone.labelInfo = new PeriodAxisLabelInfo[this.labelInfo.length];
for (int i = 0; i < this.labelInfo.length; i++) {
clone.labelInfo[i] = this.labelInfo[i];  // copy across referencese.printStackTrace();int result = 0;ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null;sb.append("<map id=\"" + htmlEscape(name) + "\" name=\""
+ htmlEscape(name) + "\">");boolean hZoom = false;
boolean vZoom = false;
separator = false;
separator = false;
separator = false;
separator = false;return;
return;e.printStackTrace();
e.printStackTrace();
PeriodAxisLabelInfo info = new PeriodAxisLabelInfo(Day.class, 
Day d = (Day) info.createInstance(new Date(0L), 
TimeZone.getTimeZone("GMT"), Locale.UK);ParamChecks.nullNotPermitted(type, "Null 'type' argument.");
ParamChecks.nullNotPermitted(order, "Null 'order' argument.");g1.add(new Double(1.5), new GradientPaint(1.0f, 2.0f, Color.red, 3.0f,
4.0f, Color.blue));
g2.add(new Double(1.5), new GradientPaint(1.0f, 2.0f, Color.red, 3.0f,
4.0f, Color.blue));
g1.add(new Double(0.5), Color.red);
g2.add(new Double(0.5), Color.red);
g1.add(new Double(1.5), new GradientPaint(1.0f, 2.0f, Color.red, 3.0f,
4.0f, Color.blue));
g1.add(new Double(1.5), new GradientPaint(1.1f, 2.2f, Color.red, 3.3f,
4.4f, Color.blue));
s.add(new Double(50.0), Color.blue);
s.add(new Double(50.0), Color.red);
s.add(new Double(25.0), Color.green);
s.add(new Double(75.0), Color.yellow);buf.append(", tooltip=" + getToolTipText());
buf.append(", url=" + getURLText());
tag.append("<area shape=\"" + getShapeType() + "\"" + " coords=\""
+ getShapeCoords() + "\"");return;
return;
return;Zoomable, AnnotationChangeListener, RendererChangeListener, 
RectangleEdge result = Plot.resolveRangeAxisLocation(location,
this.orientation);
if (result == null) {
result = RectangleEdge.opposite(getRangeAxisEdge(0));
return result;
CategoryAnnotation annotation 
g2.drawImage(shadowImage, (int) dataArea.getX() 
(int) dataArea.getY() 
RectangleEdge result = Plot.resolveDomainAxisLocation(location,
this.orientation);
if (result == null) {
result = RectangleEdge.opposite(getDomainAxisEdge());
return result;
RectangleEdge result = Plot.resolveRangeAxisLocation(location,
this.orientation);
if (result == null) {
result = RectangleEdge.opposite(getRangeAxisEdge());
return result;
g2.drawImage(shadowImage, (int) dataArea.getX() 
(int) dataArea.getY() 
if ((tick.getTickType() == TickType.MINOR) 
else if ((tick.getTickType() == TickType.MAJOR) public static final ResourceBundle getBundle(String baseName) {
public static final ResourceBundle getBundle(String baseName,
Locale locale) {if (this.rows.size() == 0) {if (sectionKeys.size() == 0) {
BufferedImage shadowImage 
g2.drawImage(shadowImage, (int) plotArea.getX() 
(int) plotArea.getY() if (Math.abs(line.getX1() - x1) > epsilon) result = false;
if (Math.abs(line.getY1() - y1) > epsilon) result = false;
if (Math.abs(line.getX2() - x2) > epsilon) result = false;
if (Math.abs(line.getY2() - y2) > epsilon) result = false;if (point0 == null) point0 = point1; //new Point2D.Double(0, 0);
if (point3 == null) point3 = point2; //new Point2D.Double(0, 0);if (subplot == null) {
throw new IllegalArgumentException(" Null 'subplot' argument.");
public void draw(Graphics2D g2,
Rectangle2D area,
Point2D anchor,
PlotState parentState,
PlotRenderingInfo info) {
if (info == null) {
throw new IllegalArgumentException("Null 'info' argument.");
if (source == null) {
throw new IllegalArgumentException("Null 'source' argument.");
if (alpha < 0.0f || alpha > 1.0f)
if (alpha < 0.0f || alpha > 1.0f)
if (alpha < 0.0f || alpha > 1.0f)
double normalizedAngle = (((this.counterClockwise ? -1 : 1) 
TickType.MAJOR.equals(tick.getTickType()))
if (counterClockwise)
if (this.maxValue == DEFAULT_MAX_VALUE)return c.getTimeInMillis();XYDataset dataset1 = createDataset("Series 1", 100.0, new Minute(), 
"Multiple Axis Demo 3", 
"Time of Day", 
dataset1, 
true, 
true, 
TextTitle subtitle = new TextTitle("Four datasets and four range axes.");  
plot.getRangeAxis().setFixedDimension(15.0);
axis2.setFixedDimension(10.0);
XYDataset dataset2 = createDataset("Series 2", 1000.0, new Minute(), 
XYDataset dataset3 = createDataset("Series 3", 10000.0, new Minute(), 
renderer4.setSeriesPaint(0, Color.green);        
private static XYDataset createDataset(String name, double base, 
series.add(period, value);    
public static void main(String[] args) import java.awt.print.PrinterJob;
import org.eclipse.swt.widgets.MessageBox;
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = job.defaultPage();
PageFormat pf2 = job.pageDialog(pf);
if (pf2 != pf) {
job.setPrintable(this, pf2);
if (job.printDialog()) {
try {
job.print();
catch (PrinterException e) {
MessageBox messageBox = new MessageBox(
this.canvas.getShell(), SWT.OK | SWT.ICON_ERROR);
messageBox.setMessage(e.getMessage());
messageBox.open();import java.awt.RenderingHints.Key;
return new BasicStroke(this.gc.getLineWidth(), this.gc.getLineCap(),
this.gc.getLineJoin());
switch (bs.getLineJoin()) {
case BasicStroke.JOIN_BEVEL :
this.gc.setLineJoin(SWT.JOIN_BEVEL);
break;
case BasicStroke.JOIN_MITER :
this.gc.setLineJoin(SWT.JOIN_MITER);
break;
case BasicStroke.JOIN_ROUND :
this.gc.setLineJoin(SWT.JOIN_ROUND);
break;
switch (bs.getEndCap()) {
case BasicStroke.CAP_BUTT :
this.gc.setLineCap(SWT.CAP_FLAT);
break;
case BasicStroke.CAP_ROUND :
this.gc.setLineCap(SWT.CAP_ROUND);
break;
case BasicStroke.CAP_SQUARE :
this.gc.setLineCap(SWT.CAP_SQUARE);
break;double l_slopeA = l_numeratorA / l_denominator;
double l_slopeB = l_numeratorB / l_denominator;
if ((0 < l_slopeA) && (l_slopeA <= 1) && (0 < l_slopeB)
&& (l_slopeB <= 1)) {
double l_xi = l_x1 + (l_slopeA * (l_x2 - l_x1));
double l_yi = l_y1 + (l_slopeA * (l_y2 - l_y1));
l_intersectX            = new Double(l_xi);
l_intersectY            = new Double(l_yi);
b_intersect             = true;
b_minuendAtIntersect    = ((l_xi == l_x2)
&& (l_yi == l_y2));
b_subtrahendAtIntersect = ((l_xi == l_x4)
&& (l_yi == l_y4));
l_minuendCurX    = l_intersectX;
l_minuendCurY    = l_intersectY;
l_subtrahendCurX = l_intersectX;
l_subtrahendCurY = l_intersectY;tickDate = correctTickDateForPosition(tickDate, unit,
this.tickMarkPosition);
tickDate = correctTickDateForPosition(tickDate, unit,result = Range.combine(result, r);e.printStackTrace();
System.err.println("Failed to clone.");
e.printStackTrace();
e.printStackTrace();
e.printStackTrace();
assertTrue(plot != null);double lengthX = maxx - minx;
double lengthY = maxy - miny;
double length = Math.min(lengthX, lengthY);
double midX = minx + lengthX / 2.0;
double midY = miny + lengthY / 2.0;
double axisMax =  axis.getUpperBound();
double xv = length / 2.0 * Math.cos(radians);
double yv = length / 2.0 * Math.sin(radians);
float x = (float) (midX + (xv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
float y = (float) (midY + (yv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
if (counterClockwise)
angleDegrees = -angleDegrees;
double radians = Math.toRadians(angleDegrees + this.angleOffset);
double minx = dataArea.getMinX() + this.margin;
double maxx = dataArea.getMaxX() - this.margin;
double miny = dataArea.getMinY() + this.margin;
double maxy = dataArea.getMaxY() - this.margin;
double lengthX = maxx - minx;
double lengthY = maxy - miny;
double length = Math.min(lengthX, lengthY);
double midX = minx + lengthX / 2.0;
double midY = miny + lengthY / 2.0;
double axisMin = getAxis().getLowerBound();
double axisMax =  getAxis().getUpperBound();
double adjustedRadius = Math.max(radius, axisMin);
double xv = length / 2.0 * Math.cos(radians);
double yv = length / 2.0 * Math.sin(radians);
float x = (float) (midX + (xv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
float y = (float) (midY + (yv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
int ix = Math.round(x);
int iy = Math.round(y);
Point p = new Point(ix, iy);
return p;drawItemLabel(g2, orientation, dataset, row, column, x1, y1,
(value < 0.0));int seriesCount = state.getVisibleSeriesCount() >= 0
? state.getVisibleSeriesCount() : getRowCount();
int categoryCount = getColumnCount();
RectangleEdge domainAxisLocation = plot.getDomainAxisEdge();
rectY = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, domainAxisLocation);
if (seriesCount > 1) {
double seriesGap = dataArea.getHeight() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectY = rectY + visibleRow * (state.getBarWidth() + seriesGap);
else {
rectY = rectY + visibleRow * state.getBarWidth();
rectX = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, domainAxisLocation);
if (seriesCount > 1) {
double seriesGap = dataArea.getWidth() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectX = rectX + visibleRow * (state.getBarWidth() + seriesGap);
else {
rectX = rectX + visibleRow * state.getBarWidth();
double rectY = calculateBarW0(plot, PlotOrientation.HORIZONTAL,
dataArea, domainAxis, state, row, column);
int seriesCount = state.getVisibleSeriesCount() >= 0
? state.getVisibleSeriesCount() : getRowCount();
int categoryCount = getColumnCount();
if (seriesCount > 1) {
double seriesGap = dataArea.getHeight() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectY = rectY + visibleRow * (state.getBarWidth() + seriesGap);
else {
rectY = rectY + visibleRow * state.getBarWidth();
double rectX = calculateBarW0(plot, PlotOrientation.VERTICAL,
dataArea, domainAxis, state, row, column);
int seriesCount = state.getVisibleSeriesCount() >= 0
? state.getVisibleSeriesCount() : getRowCount();
int categoryCount = getColumnCount();
if (seriesCount > 1) {
double seriesGap = dataArea.getWidth() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectX = rectX + visibleRow * (state.getBarWidth() + seriesGap);
else {
rectX = rectX + visibleRow * state.getBarWidth();else {
return DatasetUtilities.findDomainBounds(dataset, includeInterval);
xAxis = plot.getDomainAxisForDataset(index);
else {
return DatasetUtilities.findRangeBounds(dataset, includeInterval);package org.jfree.chart;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Paint;
import java.awt.Stroke;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import org.jfree.chart.annotations.XYAnnotation;
import org.jfree.chart.annotations.XYTextAnnotation;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.PeriodAxis;
import org.jfree.chart.axis.PeriodAxisLabelInfo;
import org.jfree.chart.axis.SubCategoryAxis;
import org.jfree.chart.axis.SymbolAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.block.Block;
import org.jfree.chart.block.BlockContainer;
import org.jfree.chart.block.LabelBlock;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.CombinedDomainCategoryPlot;
import org.jfree.chart.plot.CombinedDomainXYPlot;
import org.jfree.chart.plot.CombinedRangeCategoryPlot;
import org.jfree.chart.plot.CombinedRangeXYPlot;
import org.jfree.chart.plot.DefaultDrawingSupplier;
import org.jfree.chart.plot.DrawingSupplier;
import org.jfree.chart.plot.FastScatterPlot;
import org.jfree.chart.plot.MeterPlot;
import org.jfree.chart.plot.MultiplePiePlot;
import org.jfree.chart.plot.PieLabelLinkStyle;
import org.jfree.chart.plot.PiePlot;
import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PolarPlot;
import org.jfree.chart.plot.SpiderWebPlot;
import org.jfree.chart.plot.ThermometerPlot;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.AbstractRenderer;
import org.jfree.chart.renderer.category.BarPainter;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.chart.renderer.category.BarRenderer3D;
import org.jfree.chart.renderer.category.CategoryItemRenderer;
import org.jfree.chart.renderer.category.GradientBarPainter;
import org.jfree.chart.renderer.category.LineRenderer3D;
import org.jfree.chart.renderer.category.MinMaxCategoryRenderer;
import org.jfree.chart.renderer.category.StatisticalBarRenderer;
import org.jfree.chart.renderer.xy.GradientXYBarPainter;
import org.jfree.chart.renderer.xy.XYBarPainter;
import org.jfree.chart.renderer.xy.XYBarRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.title.CompositeTitle;
import org.jfree.chart.title.LegendTitle;
import org.jfree.chart.title.PaintScaleLegend;
import org.jfree.chart.title.TextTitle;
import org.jfree.chart.title.Title;
import org.jfree.chart.util.DefaultShadowGenerator;
import org.jfree.chart.util.ShadowGenerator;
import org.jfree.io.SerialUtilities;
import org.jfree.ui.RectangleInsets;
import org.jfree.util.PaintUtilities;
import org.jfree.util.PublicCloneable;
public class StandardChartTheme implements ChartTheme, Cloneable,
PublicCloneable, Serializable {
private String name;
private Font extraLargeFont;
private Font largeFont;
private Font regularFont;
private Font smallFont;
private transient Paint titlePaint;
private transient Paint subtitlePaint;
private transient Paint chartBackgroundPaint;
private transient Paint legendBackgroundPaint;
private transient Paint legendItemPaint;
private DrawingSupplier drawingSupplier;
private transient Paint plotBackgroundPaint;
private transient Paint plotOutlinePaint;
private PieLabelLinkStyle labelLinkStyle;
private transient Paint labelLinkPaint;
private transient Paint domainGridlinePaint;
private transient Paint rangeGridlinePaint;
private transient Paint baselinePaint;
private transient Paint crosshairPaint;
private RectangleInsets axisOffset;
private transient Paint axisLabelPaint;
private transient Paint tickLabelPaint;
private transient Paint itemLabelPaint;
private boolean shadowVisible;
private transient Paint shadowPaint;
private BarPainter barPainter;
private XYBarPainter xyBarPainter;
private transient Paint thermometerPaint;
private transient Paint wallPaint;
private transient Paint errorIndicatorPaint;
private transient Paint gridBandPaint = SymbolAxis.DEFAULT_GRID_BAND_PAINT;
private transient Paint gridBandAlternatePaint
= SymbolAxis.DEFAULT_GRID_BAND_ALTERNATE_PAINT;
private ShadowGenerator shadowGenerator;
public static ChartTheme createJFreeTheme() {
return new StandardChartTheme("JFree");
public static ChartTheme createDarknessTheme() {
StandardChartTheme theme = new StandardChartTheme("Darkness");
theme.titlePaint = Color.white;
theme.subtitlePaint = Color.white;
theme.legendBackgroundPaint = Color.black;
theme.legendItemPaint = Color.white;
theme.chartBackgroundPaint = Color.black;
theme.plotBackgroundPaint = Color.black;
theme.plotOutlinePaint = Color.yellow;
theme.baselinePaint = Color.white;
theme.crosshairPaint = Color.red;
theme.labelLinkPaint = Color.lightGray;
theme.tickLabelPaint = Color.white;
theme.axisLabelPaint = Color.white;
theme.shadowPaint = Color.darkGray;
theme.itemLabelPaint = Color.white;
theme.drawingSupplier = new DefaultDrawingSupplier(
new Paint[] {Color.decode("0xFFFF00"),
Color.decode("0x0036CC"), Color.decode("0xFF0000"),
Color.decode("0xFFFF7F"), Color.decode("0x6681CC"),
Color.decode("0xFF7F7F"), Color.decode("0xFFFFBF"),
Color.decode("0x99A6CC"), Color.decode("0xFFBFBF"),
Color.decode("0xA9A938"), Color.decode("0x2D4587")},
new Paint[] {Color.decode("0xFFFF00"),
Color.decode("0x0036CC")},
new Stroke[] {new BasicStroke(2.0f)},
new Stroke[] {new BasicStroke(0.5f)},
DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE);
theme.wallPaint = Color.darkGray;
theme.errorIndicatorPaint = Color.lightGray;
theme.gridBandPaint = new Color(255, 255, 255, 20);
theme.gridBandAlternatePaint = new Color(255, 255, 255, 40);
theme.shadowGenerator = null;
return theme;
public static ChartTheme createLegacyTheme() {
StandardChartTheme theme = new StandardChartTheme("Legacy") {
public void apply(JFreeChart chart) {
return theme;
public StandardChartTheme(String name) {
if (name == null) {
throw new IllegalArgumentException("Null 'name' argument.");
this.name = name;
this.extraLargeFont = new Font("Tahoma", Font.BOLD, 20);
this.largeFont = new Font("Tahoma", Font.BOLD, 14);
this.regularFont = new Font("Tahoma", Font.PLAIN, 12);
this.smallFont = new Font("Tahoma", Font.PLAIN, 10);
this.titlePaint = Color.black;
this.subtitlePaint = Color.black;
this.legendBackgroundPaint = Color.white;
this.legendItemPaint = Color.darkGray;
this.chartBackgroundPaint = Color.white;
this.drawingSupplier = new DefaultDrawingSupplier();
this.plotBackgroundPaint = Color.lightGray;
this.plotOutlinePaint = Color.black;
this.labelLinkPaint = Color.black;
this.labelLinkStyle = PieLabelLinkStyle.CUBIC_CURVE;
this.axisOffset = new RectangleInsets(4, 4, 4, 4);
this.domainGridlinePaint = Color.white;
this.rangeGridlinePaint = Color.white;
this.baselinePaint = Color.black;
this.crosshairPaint = Color.blue;
this.axisLabelPaint = Color.darkGray;
this.tickLabelPaint = Color.darkGray;
this.barPainter = new GradientBarPainter();
this.xyBarPainter = new GradientXYBarPainter();
this.shadowVisible = false;
this.shadowPaint = Color.gray;
this.itemLabelPaint = Color.black;
this.thermometerPaint = Color.white;
this.wallPaint = BarRenderer3D.DEFAULT_WALL_PAINT;
this.errorIndicatorPaint = Color.black;
this.shadowGenerator = new DefaultShadowGenerator();
public Font getExtraLargeFont() {
return this.extraLargeFont;
public void setExtraLargeFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.extraLargeFont = font;
public Font getLargeFont() {
return this.largeFont;
public void setLargeFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.largeFont = font;
public Font getRegularFont() {
return this.regularFont;
public void setRegularFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.regularFont = font;
public Font getSmallFont() {
return this.smallFont;
public void setSmallFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.smallFont = font;
public Paint getTitlePaint() {
return this.titlePaint;
public void setTitlePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.titlePaint = paint;
public Paint getSubtitlePaint() {
return this.subtitlePaint;
public void setSubtitlePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.subtitlePaint = paint;
public Paint getChartBackgroundPaint() {
return this.chartBackgroundPaint;
public void setChartBackgroundPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.chartBackgroundPaint = paint;
public Paint getLegendBackgroundPaint() {
return this.legendBackgroundPaint;
public void setLegendBackgroundPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.legendBackgroundPaint = paint;
public Paint getLegendItemPaint() {
return this.legendItemPaint;
public void setLegendItemPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.legendItemPaint = paint;
public Paint getPlotBackgroundPaint() {
return this.plotBackgroundPaint;
public void setPlotBackgroundPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.plotBackgroundPaint = paint;
public Paint getPlotOutlinePaint() {
return this.plotOutlinePaint;
public void setPlotOutlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.plotOutlinePaint = paint;
public PieLabelLinkStyle getLabelLinkStyle() {
return this.labelLinkStyle;
public void setLabelLinkStyle(PieLabelLinkStyle style) {
if (style == null) {
throw new IllegalArgumentException("Null 'style' argument.");
this.labelLinkStyle = style;
public Paint getLabelLinkPaint() {
return this.labelLinkPaint;
public void setLabelLinkPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.labelLinkPaint = paint;
public Paint getDomainGridlinePaint() {
return this.domainGridlinePaint;
public void setDomainGridlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.domainGridlinePaint = paint;
public Paint getRangeGridlinePaint() {
return this.rangeGridlinePaint;
public void setRangeGridlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.rangeGridlinePaint = paint;
public Paint getBaselinePaint() {
return this.baselinePaint;
public void setBaselinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.baselinePaint = paint;
public Paint getCrosshairPaint() {
return this.crosshairPaint;
public void setCrosshairPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.crosshairPaint = paint;
public RectangleInsets getAxisOffset() {
return this.axisOffset;
public void setAxisOffset(RectangleInsets offset) {
if (offset == null) {
throw new IllegalArgumentException("Null 'offset' argument.");
this.axisOffset = offset;
public Paint getAxisLabelPaint() {
return this.axisLabelPaint;
public void setAxisLabelPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.axisLabelPaint = paint;
public Paint getTickLabelPaint() {
return this.tickLabelPaint;
public void setTickLabelPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.tickLabelPaint = paint;
public Paint getItemLabelPaint() {
return this.itemLabelPaint;
public void setItemLabelPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.itemLabelPaint = paint;
public boolean isShadowVisible() {
return this.shadowVisible;
public void setShadowVisible(boolean visible) {
this.shadowVisible = visible;
public Paint getShadowPaint() {
return this.shadowPaint;
public void setShadowPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.shadowPaint = paint;
public BarPainter getBarPainter() {
return this.barPainter;
public void setBarPainter(BarPainter painter) {
if (painter == null) {
throw new IllegalArgumentException("Null 'painter' argument.");
this.barPainter = painter;
public XYBarPainter getXYBarPainter() {
return this.xyBarPainter;
public void setXYBarPainter(XYBarPainter painter) {
if (painter == null) {
throw new IllegalArgumentException("Null 'painter' argument.");
this.xyBarPainter = painter;
public Paint getThermometerPaint() {
return this.thermometerPaint;
public void setThermometerPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.thermometerPaint = paint;
public Paint getWallPaint() {
return this.wallPaint;
public void setWallPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.wallPaint = paint;
public Paint getErrorIndicatorPaint() {
return this.errorIndicatorPaint;
public void setErrorIndicatorPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.errorIndicatorPaint = paint;
public Paint getGridBandPaint() {
return this.gridBandPaint;
public void setGridBandPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.gridBandPaint = paint;
public Paint getGridBandAlternatePaint() {
return this.gridBandAlternatePaint;
public void setGridBandAlternatePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.gridBandAlternatePaint = paint;
public String getName() {
return this.name;
public DrawingSupplier getDrawingSupplier() {
DrawingSupplier result = null;
if (this.drawingSupplier instanceof PublicCloneable) {
PublicCloneable pc = (PublicCloneable) this.drawingSupplier;
try {
result = (DrawingSupplier) pc.clone();
catch (CloneNotSupportedException e) {
e.printStackTrace();
return result;
public void setDrawingSupplier(DrawingSupplier supplier) {
if (supplier == null) {
throw new IllegalArgumentException("Null 'supplier' argument.");
this.drawingSupplier = supplier;
public void apply(JFreeChart chart) {
if (chart == null) {
throw new IllegalArgumentException("Null 'chart' argument.");
TextTitle title = chart.getTitle();
if (title != null) {
title.setFont(this.extraLargeFont);
title.setPaint(this.titlePaint);
int subtitleCount = chart.getSubtitleCount();
for (int i = 0; i < subtitleCount; i++) {
applyToTitle(chart.getSubtitle(i));
chart.setBackgroundPaint(this.chartBackgroundPaint);
Plot plot = chart.getPlot();
if (plot != null) {
applyToPlot(plot);
protected void applyToTitle(Title title) {
if (title instanceof TextTitle) {
TextTitle tt = (TextTitle) title;
tt.setFont(this.largeFont);
tt.setPaint(this.subtitlePaint);
else if (title instanceof LegendTitle) {
LegendTitle lt = (LegendTitle) title;
if (lt.getBackgroundPaint() != null) {
lt.setBackgroundPaint(this.legendBackgroundPaint);
lt.setItemFont(this.regularFont);
lt.setItemPaint(this.legendItemPaint);
if (lt.getWrapper() != null) {
applyToBlockContainer(lt.getWrapper());
else if (title instanceof PaintScaleLegend) {
PaintScaleLegend psl = (PaintScaleLegend) title;
psl.setBackgroundPaint(this.legendBackgroundPaint);
ValueAxis axis = psl.getAxis();
if (axis != null) {
applyToValueAxis(axis);
else if (title instanceof CompositeTitle) {
CompositeTitle ct = (CompositeTitle) title;
BlockContainer bc = ct.getContainer();
List blocks = bc.getBlocks();
Iterator iterator = blocks.iterator();
while (iterator.hasNext()) {
Block b = (Block) iterator.next();
if (b instanceof Title) {
applyToTitle((Title) b);
protected void applyToBlockContainer(BlockContainer bc) {
Iterator iterator = bc.getBlocks().iterator();
while (iterator.hasNext()) {
Block b = (Block) iterator.next();
applyToBlock(b);
protected void applyToBlock(Block b) {
if (b instanceof Title) {
applyToTitle((Title) b);
else if (b instanceof LabelBlock) {
LabelBlock lb = (LabelBlock) b;
lb.setFont(this.regularFont);
lb.setPaint(this.legendItemPaint);
protected void applyToPlot(Plot plot) {
if (plot == null) {
throw new IllegalArgumentException("Null 'plot' argument.");
if (plot.getDrawingSupplier() != null) {
plot.setDrawingSupplier(getDrawingSupplier());
if (plot.getBackgroundPaint() != null) {
plot.setBackgroundPaint(this.plotBackgroundPaint);
plot.setOutlinePaint(this.plotOutlinePaint);
if (plot instanceof PiePlot) {
applyToPiePlot((PiePlot) plot);
else if (plot instanceof MultiplePiePlot) {
applyToMultiplePiePlot((MultiplePiePlot) plot);
else if (plot instanceof CategoryPlot) {
applyToCategoryPlot((CategoryPlot) plot);
else if (plot instanceof XYPlot) {
applyToXYPlot((XYPlot) plot);
else if (plot instanceof FastScatterPlot) {
applyToFastScatterPlot((FastScatterPlot) plot);
else if (plot instanceof MeterPlot) {
applyToMeterPlot((MeterPlot) plot);
else if (plot instanceof ThermometerPlot) {
applyToThermometerPlot((ThermometerPlot) plot);
else if (plot instanceof SpiderWebPlot) {
applyToSpiderWebPlot((SpiderWebPlot) plot);
else if (plot instanceof PolarPlot) {
applyToPolarPlot((PolarPlot) plot);
protected void applyToPiePlot(PiePlot plot) {
plot.setLabelLinkPaint(this.labelLinkPaint);
plot.setLabelLinkStyle(this.labelLinkStyle);
plot.setLabelFont(this.regularFont);
plot.setShadowGenerator(this.shadowGenerator);
if (plot.getAutoPopulateSectionPaint()) {
plot.clearSectionPaints(false);
if (plot.getAutoPopulateSectionOutlinePaint()) {
plot.clearSectionOutlinePaints(false);
if (plot.getAutoPopulateSectionOutlineStroke()) {
plot.clearSectionOutlineStrokes(false);
protected void applyToMultiplePiePlot(MultiplePiePlot plot) {
apply(plot.getPieChart());
protected void applyToCategoryPlot(CategoryPlot plot) {
plot.setAxisOffset(this.axisOffset);
plot.setDomainGridlinePaint(this.domainGridlinePaint);
plot.setRangeGridlinePaint(this.rangeGridlinePaint);
plot.setRangeZeroBaselinePaint(this.baselinePaint);
plot.setShadowGenerator(this.shadowGenerator);
int domainAxisCount = plot.getDomainAxisCount();
for (int i = 0; i < domainAxisCount; i++) {
CategoryAxis axis = plot.getDomainAxis(i);
if (axis != null) {
applyToCategoryAxis(axis);
int rangeAxisCount = plot.getRangeAxisCount();
for (int i = 0; i < rangeAxisCount; i++) {
ValueAxis axis = (ValueAxis) plot.getRangeAxis(i);
if (axis != null) {
applyToValueAxis(axis);
int rendererCount = plot.getRendererCount();
for (int i = 0; i < rendererCount; i++) {
CategoryItemRenderer r = plot.getRenderer(i);
if (r != null) {
applyToCategoryItemRenderer(r);
if (plot instanceof CombinedDomainCategoryPlot) {
CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot;
Iterator iterator = cp.getSubplots().iterator();
while (iterator.hasNext()) {
CategoryPlot subplot = (CategoryPlot) iterator.next();
if (subplot != null) {
applyToPlot(subplot);
if (plot instanceof CombinedRangeCategoryPlot) {
CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot;
Iterator iterator = cp.getSubplots().iterator();
while (iterator.hasNext()) {
CategoryPlot subplot = (CategoryPlot) iterator.next();
if (subplot != null) {
applyToPlot(subplot);
protected void applyToXYPlot(XYPlot plot) {
plot.setAxisOffset(this.axisOffset);
plot.setDomainZeroBaselinePaint(this.baselinePaint);
plot.setRangeZeroBaselinePaint(this.baselinePaint);
plot.setDomainGridlinePaint(this.domainGridlinePaint);
plot.setRangeGridlinePaint(this.rangeGridlinePaint);
plot.setDomainCrosshairPaint(this.crosshairPaint);
plot.setRangeCrosshairPaint(this.crosshairPaint);
plot.setShadowGenerator(this.shadowGenerator);
int domainAxisCount = plot.getDomainAxisCount();
for (int i = 0; i < domainAxisCount; i++) {
ValueAxis axis = plot.getDomainAxis(i);
if (axis != null) {
applyToValueAxis(axis);
int rangeAxisCount = plot.getRangeAxisCount();
for (int i = 0; i < rangeAxisCount; i++) {
ValueAxis axis = (ValueAxis) plot.getRangeAxis(i);
if (axis != null) {
applyToValueAxis(axis);
int rendererCount = plot.getRendererCount();
for (int i = 0; i < rendererCount; i++) {
XYItemRenderer r = plot.getRenderer(i);
if (r != null) {
applyToXYItemRenderer(r);
Iterator iter = plot.getAnnotations().iterator();
while (iter.hasNext()) {
XYAnnotation a = (XYAnnotation) iter.next();
applyToXYAnnotation(a);
if (plot instanceof CombinedDomainXYPlot) {
CombinedDomainXYPlot cp = (CombinedDomainXYPlot) plot;
Iterator iterator = cp.getSubplots().iterator();
while (iterator.hasNext()) {
XYPlot subplot = (XYPlot) iterator.next();
if (subplot != null) {
applyToPlot(subplot);
if (plot instanceof CombinedRangeXYPlot) {
CombinedRangeXYPlot cp = (CombinedRangeXYPlot) plot;
Iterator iterator = cp.getSubplots().iterator();
while (iterator.hasNext()) {
XYPlot subplot = (XYPlot) iterator.next();
if (subplot != null) {
applyToPlot(subplot);
protected void applyToFastScatterPlot(FastScatterPlot plot) {
plot.setDomainGridlinePaint(this.domainGridlinePaint);
plot.setRangeGridlinePaint(this.rangeGridlinePaint);
ValueAxis xAxis = plot.getDomainAxis();
if (xAxis != null) {
applyToValueAxis(xAxis);
ValueAxis yAxis = plot.getRangeAxis();
if (yAxis != null) {
applyToValueAxis(yAxis);
protected void applyToPolarPlot(PolarPlot plot) {
plot.setAngleLabelFont(this.regularFont);
plot.setAngleLabelPaint(this.tickLabelPaint);
plot.setAngleGridlinePaint(this.domainGridlinePaint);
plot.setRadiusGridlinePaint(this.rangeGridlinePaint);
ValueAxis axis = plot.getAxis();
if (axis != null) {
applyToValueAxis(axis);
protected void applyToSpiderWebPlot(SpiderWebPlot plot) {
plot.setLabelFont(this.regularFont);
plot.setLabelPaint(this.axisLabelPaint);
plot.setAxisLinePaint(this.axisLabelPaint);
protected void applyToMeterPlot(MeterPlot plot) {
plot.setDialBackgroundPaint(this.plotBackgroundPaint);
plot.setValueFont(this.largeFont);
plot.setValuePaint(this.axisLabelPaint);
plot.setDialOutlinePaint(this.plotOutlinePaint);
plot.setNeedlePaint(this.thermometerPaint);
plot.setTickLabelFont(this.regularFont);
plot.setTickLabelPaint(this.tickLabelPaint);
protected void applyToThermometerPlot(ThermometerPlot plot) {
plot.setValueFont(this.largeFont);
plot.setThermometerPaint(this.thermometerPaint);
ValueAxis axis = plot.getRangeAxis();
if (axis != null) {
applyToValueAxis(axis);
protected void applyToCategoryAxis(CategoryAxis axis) {
axis.setLabelFont(this.largeFont);
axis.setLabelPaint(this.axisLabelPaint);
axis.setTickLabelFont(this.regularFont);
axis.setTickLabelPaint(this.tickLabelPaint);
if (axis instanceof SubCategoryAxis) {
SubCategoryAxis sca = (SubCategoryAxis) axis;
sca.setSubLabelFont(this.regularFont);
sca.setSubLabelPaint(this.tickLabelPaint);
protected void applyToValueAxis(ValueAxis axis) {
axis.setLabelFont(this.largeFont);
axis.setLabelPaint(this.axisLabelPaint);
axis.setTickLabelFont(this.regularFont);
axis.setTickLabelPaint(this.tickLabelPaint);
if (axis instanceof SymbolAxis) {
applyToSymbolAxis((SymbolAxis) axis);
if (axis instanceof PeriodAxis) {
applyToPeriodAxis((PeriodAxis) axis);
protected void applyToSymbolAxis(SymbolAxis axis) {
axis.setGridBandPaint(this.gridBandPaint);
axis.setGridBandAlternatePaint(this.gridBandAlternatePaint);
protected void applyToPeriodAxis(PeriodAxis axis) {
PeriodAxisLabelInfo[] info = axis.getLabelInfo();
for (int i = 0; i < info.length; i++) {
PeriodAxisLabelInfo e = info[i];
PeriodAxisLabelInfo n = new PeriodAxisLabelInfo(e.getPeriodClass(),
e.getDateFormat(), e.getPadding(), this.regularFont,
this.tickLabelPaint, e.getDrawDividers(),
e.getDividerStroke(), e.getDividerPaint());
info[i] = n;
axis.setLabelInfo(info);
protected void applyToAbstractRenderer(AbstractRenderer renderer) {
if (renderer.getAutoPopulateSeriesPaint()) {
renderer.clearSeriesPaints(false);
if (renderer.getAutoPopulateSeriesStroke()) {
renderer.clearSeriesStrokes(false);
protected void applyToCategoryItemRenderer(CategoryItemRenderer renderer) {
if (renderer == null) {
throw new IllegalArgumentException("Null 'renderer' argument.");
if (renderer instanceof AbstractRenderer) {
applyToAbstractRenderer((AbstractRenderer) renderer);
renderer.setBaseItemLabelFont(this.regularFont);
renderer.setBaseItemLabelPaint(this.itemLabelPaint);
if (renderer instanceof BarRenderer) {
BarRenderer br = (BarRenderer) renderer;
br.setBarPainter(this.barPainter);
br.setShadowVisible(this.shadowVisible);
br.setShadowPaint(this.shadowPaint);
if (renderer instanceof BarRenderer3D) {
BarRenderer3D br3d = (BarRenderer3D) renderer;
br3d.setWallPaint(this.wallPaint);
if (renderer instanceof LineRenderer3D) {
LineRenderer3D lr3d = (LineRenderer3D) renderer;
lr3d.setWallPaint(this.wallPaint);
if (renderer instanceof StatisticalBarRenderer) {
StatisticalBarRenderer sbr = (StatisticalBarRenderer) renderer;
sbr.setErrorIndicatorPaint(this.errorIndicatorPaint);
if (renderer instanceof MinMaxCategoryRenderer) {
MinMaxCategoryRenderer mmcr = (MinMaxCategoryRenderer) renderer;
mmcr.setGroupPaint(this.errorIndicatorPaint);
protected void applyToXYItemRenderer(XYItemRenderer renderer) {
if (renderer == null) {
throw new IllegalArgumentException("Null 'renderer' argument.");
if (renderer instanceof AbstractRenderer) {
applyToAbstractRenderer((AbstractRenderer) renderer);
renderer.setBaseItemLabelFont(this.regularFont);
renderer.setBaseItemLabelPaint(this.itemLabelPaint);
if (renderer instanceof XYBarRenderer) {
XYBarRenderer br = (XYBarRenderer) renderer;
br.setBarPainter(this.xyBarPainter);
br.setShadowVisible(this.shadowVisible);
protected void applyToXYAnnotation(XYAnnotation annotation) {
if (annotation == null) {
throw new IllegalArgumentException("Null 'annotation' argument.");
if (annotation instanceof XYTextAnnotation) {
XYTextAnnotation xyta = (XYTextAnnotation) annotation;
xyta.setFont(this.smallFont);
xyta.setPaint(this.itemLabelPaint);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof StandardChartTheme)) {
return false;
StandardChartTheme that = (StandardChartTheme) obj;
if (!this.name.equals(that.name)) {
return false;
if (!this.extraLargeFont.equals(that.extraLargeFont)) {
return false;
if (!this.largeFont.equals(that.largeFont)) {
return false;
if (!this.regularFont.equals(that.regularFont)) {
return false;
if (!this.smallFont.equals(that.smallFont)) {
return false;
if (!PaintUtilities.equal(this.titlePaint, that.titlePaint)) {
return false;
if (!PaintUtilities.equal(this.subtitlePaint, that.subtitlePaint)) {
return false;
if (!PaintUtilities.equal(this.chartBackgroundPaint,
that.chartBackgroundPaint)) {
return false;
if (!PaintUtilities.equal(this.legendBackgroundPaint,
that.legendBackgroundPaint)) {
return false;
if (!PaintUtilities.equal(this.legendItemPaint, that.legendItemPaint)) {
return false;
if (!this.drawingSupplier.equals(that.drawingSupplier)) {
return false;
if (!PaintUtilities.equal(this.plotBackgroundPaint,
that.plotBackgroundPaint)) {
return false;
if (!PaintUtilities.equal(this.plotOutlinePaint,
that.plotOutlinePaint)) {
return false;
if (!this.labelLinkStyle.equals(that.labelLinkStyle)) {
return false;
if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
return false;
if (!PaintUtilities.equal(this.domainGridlinePaint,
that.domainGridlinePaint)) {
return false;
if (!PaintUtilities.equal(this.rangeGridlinePaint,
that.rangeGridlinePaint)) {
return false;
if (!PaintUtilities.equal(this.crosshairPaint, that.crosshairPaint)) {
return false;
if (!this.axisOffset.equals(that.axisOffset)) {
return false;
if (!PaintUtilities.equal(this.axisLabelPaint, that.axisLabelPaint)) {
return false;
if (!PaintUtilities.equal(this.tickLabelPaint, that.tickLabelPaint)) {
return false;
if (!PaintUtilities.equal(this.itemLabelPaint, that.itemLabelPaint)) {
return false;
if (this.shadowVisible != that.shadowVisible) {
return false;
if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
return false;
if (!this.barPainter.equals(that.barPainter)) {
return false;
if (!this.xyBarPainter.equals(that.xyBarPainter)) {
return false;
if (!PaintUtilities.equal(this.thermometerPaint,
that.thermometerPaint)) {
return false;
if (!PaintUtilities.equal(this.wallPaint, that.wallPaint)) {
return false;
if (!PaintUtilities.equal(this.errorIndicatorPaint,
that.errorIndicatorPaint)) {
return false;
if (!PaintUtilities.equal(this.gridBandPaint, that.gridBandPaint)) {
return false;
if (!PaintUtilities.equal(this.gridBandAlternatePaint,
that.gridBandAlternatePaint)) {
return false;
return true;
public Object clone() throws CloneNotSupportedException {
return super.clone();
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writePaint(this.titlePaint, stream);
SerialUtilities.writePaint(this.subtitlePaint, stream);
SerialUtilities.writePaint(this.chartBackgroundPaint, stream);
SerialUtilities.writePaint(this.legendBackgroundPaint, stream);
SerialUtilities.writePaint(this.legendItemPaint, stream);
SerialUtilities.writePaint(this.plotBackgroundPaint, stream);
SerialUtilities.writePaint(this.plotOutlinePaint, stream);
SerialUtilities.writePaint(this.labelLinkPaint, stream);
SerialUtilities.writePaint(this.baselinePaint, stream);
SerialUtilities.writePaint(this.domainGridlinePaint, stream);
SerialUtilities.writePaint(this.rangeGridlinePaint, stream);
SerialUtilities.writePaint(this.crosshairPaint, stream);
SerialUtilities.writePaint(this.axisLabelPaint, stream);
SerialUtilities.writePaint(this.tickLabelPaint, stream);
SerialUtilities.writePaint(this.itemLabelPaint, stream);
SerialUtilities.writePaint(this.shadowPaint, stream);
SerialUtilities.writePaint(this.thermometerPaint, stream);
SerialUtilities.writePaint(this.wallPaint, stream);
SerialUtilities.writePaint(this.errorIndicatorPaint, stream);
SerialUtilities.writePaint(this.gridBandPaint, stream);
SerialUtilities.writePaint(this.gridBandAlternatePaint, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.titlePaint = SerialUtilities.readPaint(stream);
this.subtitlePaint = SerialUtilities.readPaint(stream);
this.chartBackgroundPaint = SerialUtilities.readPaint(stream);
this.legendBackgroundPaint = SerialUtilities.readPaint(stream);
this.legendItemPaint = SerialUtilities.readPaint(stream);
this.plotBackgroundPaint = SerialUtilities.readPaint(stream);
this.plotOutlinePaint = SerialUtilities.readPaint(stream);
this.labelLinkPaint = SerialUtilities.readPaint(stream);
this.baselinePaint = SerialUtilities.readPaint(stream);
this.domainGridlinePaint = SerialUtilities.readPaint(stream);
this.rangeGridlinePaint = SerialUtilities.readPaint(stream);
this.crosshairPaint = SerialUtilities.readPaint(stream);
this.axisLabelPaint = SerialUtilities.readPaint(stream);
this.tickLabelPaint = SerialUtilities.readPaint(stream);
this.itemLabelPaint = SerialUtilities.readPaint(stream);
this.shadowPaint = SerialUtilities.readPaint(stream);
this.thermometerPaint = SerialUtilities.readPaint(stream);
this.wallPaint = SerialUtilities.readPaint(stream);
this.errorIndicatorPaint = SerialUtilities.readPaint(stream);
this.gridBandPaint = SerialUtilities.readPaint(stream);
this.gridBandAlternatePaint = SerialUtilities.readPaint(stream);g2.drawImage(source, null, shadowSize, shadowSize);
int left = (shadowSize - 1) >> 1;
int right = shadowSize - left;
int shadowRgb = shadowColor.getRGB() & 0x00FFFFFF;
int[] aHistory = new int[shadowSize];
float sumDivider = shadowOpacity / shadowSize;
for (int x = 0; x < shadowSize; x++, bufferOffset++) {
if (++historyIdx >= shadowSize) {
historyIdx -= shadowSize;
for (int y = 0; y < shadowSize; y++, bufferOffset += dstWidth) {
if (++historyIdx >= shadowSize) {
historyIdx -= shadowSize;RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
double rectY = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, xAxisLocation);
RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
double rectX = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, xAxisLocation);while (current <= end) {
while (current <= end) {true,               // include legend
Rectangle2D savedDataArea = dataArea;
dataArea = new Rectangle(0, 0, dataImage.getWidth(),
dataImage.getHeight());
dataArea = savedDataArea;
g2.drawImage(shadowImage, (int) savedDataArea.getX() 
(int) savedDataArea.getY() 
g2.drawImage(dataImage, (int) savedDataArea.getX(),
(int) savedDataArea.getY(), null);
Rectangle2D savedDataArea = area;
area = new Rectangle(0, 0, dataImage.getWidth(), dataImage.getHeight());
area = savedDataArea;
g2.drawImage(shadowImage, (int) savedDataArea.getX() 
+ this.shadowGenerator.calculateOffsetX(),
(int) savedDataArea.getY()
g2.drawImage(dataImage, (int) savedDataArea.getX(),
(int) savedDataArea.getY(), null);
Rectangle2D savedDataArea = plotArea;
plotArea = new Rectangle(0, 0, dataImage.getWidth(),
dataImage.getHeight());
originalPlotArea = (Rectangle) plotArea.clone();
BufferedImage shadowImage = getShadowGenerator().createDropShadow(dataImage);
plotArea = savedDataArea;
originalPlotArea = savedDataArea;
g2.drawImage(shadowImage, (int) savedDataArea.getX() 
(int) savedDataArea.getY() 
g2.drawImage(dataImage, (int) savedDataArea.getX(),
(int) savedDataArea.getY(), null);
Rectangle2D savedDataArea = dataArea;
dataArea = new Rectangle(0, 0, dataImage.getWidth(),
dataImage.getHeight());
dataArea = savedDataArea;
g2.drawImage(shadowImage, (int) savedDataArea.getX() 
(int) savedDataArea.getY() 
g2.drawImage(dataImage, (int) savedDataArea.getX(),
(int) savedDataArea.getY(), null);d.addItem(null, 2.0, 3.0, "R1", "C1");
d.addItem(1.0, null, null, "R1", "C1");
d.addItem(null, 1.0, null, "R1", "C1");
d.addItem(null, null, 1.0, "R1", "C1");
d.addItem(4.0, null, null, "R2", "C1");import org.jfree.data.xy.XYZDataset;
assertTrue(r1 != r2);
assertTrue(r1.getClass() == r2.getClass());
assertTrue(r1.equals(r2));
assertEquals(1d, range.getLowerBound());
assertEquals(3d, range.getUpperBound());
assertEquals(-3d, range.getLowerBound());
assertEquals(-1d, range.getUpperBound());
assertEquals(-1.2d, range.getLowerBound());
assertEquals(3.8d, range.getUpperBound());package org.jfree.chart.plot;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.labels.PieToolTipGenerator;
import org.jfree.chart.urls.PieURLGenerator;
import org.jfree.data.general.PieDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.ui.RectangleInsets;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PaintUtilities;
import org.jfree.util.Rotation;
import org.jfree.util.ShapeUtilities;
import org.jfree.util.UnitType;
public class RingPlot extends PiePlot implements Cloneable, Serializable {
private static final long serialVersionUID = 1556064784129676620L;
private boolean separatorsVisible;
private transient Stroke separatorStroke;
private transient Paint separatorPaint;
private double innerSeparatorExtension;
private double outerSeparatorExtension;
private double sectionDepth;
public RingPlot() {
this(null);
public RingPlot(PieDataset dataset) {
super(dataset);
this.separatorsVisible = true;
this.separatorStroke = new BasicStroke(0.5f);
this.separatorPaint = Color.gray;
this.innerSeparatorExtension = 0.20;  // twenty percent
this.outerSeparatorExtension = 0.20;  // twenty percent
this.sectionDepth = 0.20; // 20%
public boolean getSeparatorsVisible() {
return this.separatorsVisible;
public void setSeparatorsVisible(boolean visible) {
this.separatorsVisible = visible;
fireChangeEvent();
public Stroke getSeparatorStroke() {
return this.separatorStroke;
public void setSeparatorStroke(Stroke stroke) {
if (stroke == null) {
throw new IllegalArgumentException("Null 'stroke' argument.");
this.separatorStroke = stroke;
fireChangeEvent();
public Paint getSeparatorPaint() {
return this.separatorPaint;
public void setSeparatorPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.separatorPaint = paint;
fireChangeEvent();
public double getInnerSeparatorExtension() {
return this.innerSeparatorExtension;
public void setInnerSeparatorExtension(double percent) {
this.innerSeparatorExtension = percent;
fireChangeEvent();
public double getOuterSeparatorExtension() {
return this.outerSeparatorExtension;
public void setOuterSeparatorExtension(double percent) {
this.outerSeparatorExtension = percent;
fireChangeEvent();
public double getSectionDepth() {
return this.sectionDepth;
public void setSectionDepth(double sectionDepth) {
this.sectionDepth = sectionDepth;
fireChangeEvent();
public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
PiePlot plot, Integer index, PlotRenderingInfo info) {
PiePlotState state = super.initialise(g2, plotArea, plot, index, info);
state.setPassesRequired(3);
return state;
protected void drawItem(Graphics2D g2,
int section,
Rectangle2D dataArea,
PiePlotState state,
int currentPass) {
PieDataset dataset = getDataset();
Number n = dataset.getValue(section);
if (n == null) {
return;
double value = n.doubleValue();
double angle1 = 0.0;
double angle2 = 0.0;
Rotation direction = getDirection();
if (direction == Rotation.CLOCKWISE) {
angle1 = state.getLatestAngle();
angle2 = angle1 - value / state.getTotal() * 360.0;
else if (direction == Rotation.ANTICLOCKWISE) {
angle1 = state.getLatestAngle();
angle2 = angle1 + value / state.getTotal() * 360.0;
else {
throw new IllegalStateException("Rotation type not recognised.");
double angle = (angle2 - angle1);
if (Math.abs(angle) > getMinimumArcAngleToDraw()) {
Comparable key = getSectionKey(section);
double ep = 0.0;
double mep = getMaximumExplodePercent();
if (mep > 0.0) {
ep = getExplodePercent(key) / mep;
Rectangle2D arcBounds = getArcBounds(state.getPieArea(),
state.getExplodedPieArea(), angle1, angle, ep);
Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle,
Arc2D.OPEN);
double depth = this.sectionDepth / 2.0;
RectangleInsets s = new RectangleInsets(UnitType.RELATIVE,
depth, depth, depth, depth);
Rectangle2D innerArcBounds = new Rectangle2D.Double();
innerArcBounds.setRect(arcBounds);
s.trim(innerArcBounds);
Arc2D.Double arc2 = new Arc2D.Double(innerArcBounds, angle1
+ angle, -angle, Arc2D.OPEN);
GeneralPath path = new GeneralPath();
path.moveTo((float) arc.getStartPoint().getX(),
(float) arc.getStartPoint().getY());
path.append(arc.getPathIterator(null), false);
path.append(arc2.getPathIterator(null), true);
path.closePath();
Line2D separator = new Line2D.Double(arc2.getEndPoint(),
arc.getStartPoint());
if (currentPass == 0) {
Paint shadowPaint = getShadowPaint();
double shadowXOffset = getShadowXOffset();
double shadowYOffset = getShadowYOffset();
if (shadowPaint != null && getShadowGenerator() == null) {
Shape shadowArc = ShapeUtilities.createTranslatedShape(
path, (float) shadowXOffset, (float) shadowYOffset);
g2.setPaint(shadowPaint);
g2.fill(shadowArc);
else if (currentPass == 1) {
Paint paint = lookupSectionPaint(key);
g2.setPaint(paint);
g2.fill(path);
Paint outlinePaint = lookupSectionOutlinePaint(key);
Stroke outlineStroke = lookupSectionOutlineStroke(key);
if (outlinePaint != null && outlineStroke != null) {
g2.setPaint(outlinePaint);
g2.setStroke(outlineStroke);
g2.draw(path);
if (state.getInfo() != null) {
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
String tip = null;
PieToolTipGenerator toolTipGenerator
= getToolTipGenerator();
if (toolTipGenerator != null) {
tip = toolTipGenerator.generateToolTip(dataset,
key);
String url = null;
PieURLGenerator urlGenerator = getURLGenerator();
if (urlGenerator != null) {
url = urlGenerator.generateURL(dataset, key,
getPieIndex());
PieSectionEntity entity = new PieSectionEntity(path,
dataset, getPieIndex(), section, key, tip,
url);
entities.add(entity);
else if (currentPass == 2) {
if (this.separatorsVisible) {
Line2D extendedSeparator = extendLine(separator,
this.innerSeparatorExtension,
this.outerSeparatorExtension);
g2.setStroke(this.separatorStroke);
g2.setPaint(this.separatorPaint);
g2.draw(extendedSeparator);
state.setLatestAngle(angle2);
protected double getLabelLinkDepth() {
return Math.min(super.getLabelLinkDepth(), getSectionDepth() / 2);
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (!(obj instanceof RingPlot)) {
return false;
RingPlot that = (RingPlot) obj;
if (this.separatorsVisible != that.separatorsVisible) {
return false;
if (!ObjectUtilities.equal(this.separatorStroke,
that.separatorStroke)) {
return false;
if (!PaintUtilities.equal(this.separatorPaint, that.separatorPaint)) {
return false;
if (this.innerSeparatorExtension != that.innerSeparatorExtension) {
return false;
if (this.outerSeparatorExtension != that.outerSeparatorExtension) {
return false;
if (this.sectionDepth != that.sectionDepth) {
return false;
return super.equals(obj);
private Line2D extendLine(Line2D line, double startPercent,
double endPercent) {
if (line == null) {
throw new IllegalArgumentException("Null 'line' argument.");
double x1 = line.getX1();
double x2 = line.getX2();
double deltaX = x2 - x1;
double y1 = line.getY1();
double y2 = line.getY2();
double deltaY = y2 - y1;
x1 = x1 - (startPercent * deltaX);
y1 = y1 - (startPercent * deltaY);
x2 = x2 + (endPercent * deltaX);
y2 = y2 + (endPercent * deltaY);
return new Line2D.Double(x1, y1, x2, y2);
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writeStroke(this.separatorStroke, stream);
SerialUtilities.writePaint(this.separatorPaint, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.separatorStroke = SerialUtilities.readStroke(stream);
this.separatorPaint = SerialUtilities.readPaint(stream);package org.jfree.experimental.chart.demo;
import java.awt.Font;
import javax.swing.JPanel;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.StandardCategoryToolTipGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.chart.renderer.category.LineAndShapeRenderer;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.experimental.chart.plot.CombinedCategoryPlot;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;
public class CombinedCategoryPlotDemo1 extends ApplicationFrame {
public CombinedCategoryPlotDemo1(String title) {
super(title);
JPanel chartPanel = createDemoPanel();
chartPanel.setPreferredSize(new java.awt.Dimension(500, 270));
setContentPane(chartPanel);
public static CategoryDataset createDataset1() {
DefaultCategoryDataset result = new DefaultCategoryDataset();
String series1 = "First";
String series2 = "Second";
String type1 = "Type 1";
String type2 = "Type 2";
String type3 = "Type 3";
String type4 = "Type 4";
String type5 = "Type 5";
String type6 = "Type 6";
String type7 = "Type 7";
String type8 = "Type 8";
result.addValue(1.0, series1, type1);
result.addValue(4.0, series1, type2);
result.addValue(3.0, series1, type3);
result.addValue(5.0, series1, type4);
result.addValue(5.0, series1, type5);
result.addValue(7.0, series1, type6);
result.addValue(7.0, series1, type7);
result.addValue(8.0, series1, type8);
result.addValue(5.0, series2, type1);
result.addValue(7.0, series2, type2);
result.addValue(6.0, series2, type3);
result.addValue(8.0, series2, type4);
result.addValue(4.0, series2, type5);
result.addValue(4.0, series2, type6);
result.addValue(2.0, series2, type7);
result.addValue(1.0, series2, type8);
return result;
public static CategoryDataset createDataset2() {
DefaultCategoryDataset result = new DefaultCategoryDataset();
String series1 = "Third";
String series2 = "Fourth";
String type1 = "Type 1";
String type2 = "Type 2";
String type3 = "Type 3";
String type4 = "Type 4";
String type5 = "Type 5";
String type6 = "Type 6";
String type7 = "Type 7";
String type8 = "Type 8";
result.addValue(11.0, series1, type1);
result.addValue(14.0, series1, type2);
result.addValue(13.0, series1, type3);
result.addValue(15.0, series1, type4);
result.addValue(15.0, series1, type5);
result.addValue(17.0, series1, type6);
result.addValue(17.0, series1, type7);
result.addValue(18.0, series1, type8);
result.addValue(15.0, series2, type1);
result.addValue(17.0, series2, type2);
result.addValue(16.0, series2, type3);
result.addValue(18.0, series2, type4);
result.addValue(14.0, series2, type5);
result.addValue(14.0, series2, type6);
result.addValue(12.0, series2, type7);
result.addValue(11.0, series2, type8);
return result;
private static JFreeChart createChart() {
CategoryDataset dataset1 = createDataset1();
NumberAxis rangeAxis1 = new NumberAxis("Value");
rangeAxis1.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
LineAndShapeRenderer renderer1 = new LineAndShapeRenderer();
renderer1.setBaseToolTipGenerator(
new StandardCategoryToolTipGenerator());
CategoryPlot subplot1 = new CategoryPlot(dataset1, null, rangeAxis1,
renderer1);
subplot1.setDomainGridlinesVisible(true);
CategoryDataset dataset2 = createDataset2();
NumberAxis rangeAxis2 = new NumberAxis("Value");
rangeAxis2.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
BarRenderer renderer2 = new BarRenderer();
renderer2.setBaseToolTipGenerator(
new StandardCategoryToolTipGenerator());
CategoryPlot subplot2 = new CategoryPlot(dataset2, null, rangeAxis2,
renderer2);
subplot2.setDomainGridlinesVisible(true);
CategoryAxis domainAxis = new CategoryAxis("Category");
CombinedCategoryPlot plot = new CombinedCategoryPlot(
domainAxis, new NumberAxis("Range"));
plot.add(subplot1, 2);
plot.add(subplot2, 1);
JFreeChart result = new JFreeChart(
"Combined Domain Category Plot Demo",
new Font("SansSerif", Font.BOLD, 12), plot, true);
return result;
public static JPanel createDemoPanel() {
JFreeChart chart = createChart();
return new ChartPanel(chart);
public static void main(String[] args) {
String title = "Combined Category Plot Demo 1";
CombinedCategoryPlotDemo1 demo = new CombinedCategoryPlotDemo1(title);
demo.pack();
RefineryUtilities.centerFrameOnScreen(demo);
demo.setVisible(true);
package org.jfree.experimental.chart.demo;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Paint;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import javax.swing.JPanel;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.labels.StandardXYToolTipGenerator;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYBarRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.title.LegendTitle;
import org.jfree.data.time.Month;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.data.xy.IntervalXYDataset;
import org.jfree.data.xy.XYDataset;
import org.jfree.experimental.chart.plot.CombinedXYPlot;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;
public class CombinedXYPlotDemo1 extends ApplicationFrame {
public CombinedXYPlotDemo1(String title) {
super(title);
JPanel panel = createDemoPanel();
panel.setPreferredSize(new java.awt.Dimension(500, 270));
setContentPane(panel);
private static JFreeChart createCombinedChart() {
IntervalXYDataset data1 = createDataset1();
XYItemRenderer renderer1 = new XYLineAndShapeRenderer(true, false);
renderer1.setBaseToolTipGenerator(new StandardXYToolTipGenerator(
StandardXYToolTipGenerator.DEFAULT_TOOL_TIP_FORMAT,
new SimpleDateFormat("d-MMM-yyyy"), new DecimalFormat("0.00")));
renderer1.setSeriesStroke(0, new BasicStroke(4.0f,
BasicStroke.CAP_ROUND, BasicStroke.JOIN_BEVEL));
renderer1.setSeriesPaint(0, Color.blue);
DateAxis domainAxis = new DateAxis("Year");
domainAxis.setLowerMargin(0.0);
domainAxis.setUpperMargin(0.02);
ValueAxis rangeAxis = new NumberAxis("$billion");
XYPlot plot1 = new XYPlot(data1, null, rangeAxis, renderer1);
plot1.setBackgroundPaint(Color.lightGray);
plot1.setDomainGridlinePaint(Color.white);
plot1.setRangeGridlinePaint(Color.white);
IntervalXYDataset data2 = createDataset2();
XYBarRenderer renderer2 = new XYBarRenderer() {
public Paint getItemPaint(int series, int item) {
XYDataset dataset = getPlot().getDataset();
if (dataset.getYValue(series, item) >= 0.0) {
return Color.red;
else {
return Color.green;
renderer2.setSeriesPaint(0, Color.red);
renderer2.setDrawBarOutline(false);
renderer2.setBaseToolTipGenerator(new StandardXYToolTipGenerator(
StandardXYToolTipGenerator.DEFAULT_TOOL_TIP_FORMAT,
new SimpleDateFormat("d-MMM-yyyy"), new DecimalFormat("0.00")));
XYPlot plot2 = new XYPlot(data2, null, new NumberAxis("$billion"),
renderer2);
plot2.setBackgroundPaint(Color.lightGray);
plot2.setDomainGridlinePaint(Color.white);
plot2.setRangeGridlinePaint(Color.white);
CombinedXYPlot cplot = new CombinedXYPlot(domainAxis, rangeAxis);
cplot.add(plot1, 3);
cplot.add(plot2, 2);
cplot.setGap(8.0);
cplot.setDomainGridlinePaint(Color.white);
cplot.setDomainGridlinesVisible(true);
JFreeChart chart = new JFreeChart("CombinedXYPlotDemo1",
JFreeChart.DEFAULT_TITLE_FONT, cplot, false);
chart.setBackgroundPaint(Color.white);
LegendTitle legend = new LegendTitle(cplot);
chart.addSubtitle(legend);
return chart;
private static IntervalXYDataset createDataset1() {
TimeSeries series1 = new TimeSeries("Series 1");
series1.add(new Month(1, 2005), 7627.743);
series1.add(new Month(2, 2005), 7713.138);
series1.add(new Month(3, 2005), 6776.939);
series1.add(new Month(4, 2005), 5764.537);
series1.add(new Month(5, 2005), 4777.880);
series1.add(new Month(6, 2005), 4836.496);
series1.add(new Month(7, 2005), 3887.618);
series1.add(new Month(8, 2005), 3926.933);
series1.add(new Month(9, 2005), 4932.710);
series1.add(new Month(10, 2005), 4027.123);
series1.add(new Month(11, 2005), 8092.322);
series1.add(new Month(12, 2005), 8170.414);
series1.add(new Month(1, 2006), 8196.070);
series1.add(new Month(2, 2006), 8269.886);
series1.add(new Month(3, 2006), 5371.156);
series1.add(new Month(4, 2006), 5355.718);
series1.add(new Month(5, 2006), 5356.777);
series1.add(new Month(6, 2006), 8420.042);
series1.add(new Month(7, 2006), 8444.347);
series1.add(new Month(8, 2006), 8515.034);
series1.add(new Month(9, 2006), 8506.974);
series1.add(new Month(10, 2006), 8584.329);
series1.add(new Month(11, 2006), 8633.246);
series1.add(new Month(12, 2006), 8680.224);
series1.add(new Month(1, 2007), 8707.561);
return new TimeSeriesCollection(series1);
private static IntervalXYDataset createDataset2() {
TimeSeriesCollection dataset = new TimeSeriesCollection();
TimeSeries series1 = new TimeSeries("Series 2");
series1.add(new Month(1, 2005), 1200);
series1.add(new Month(2, 2005), 1400);
series1.add(new Month(3, 2005), 1500);
series1.add(new Month(4, 2005), 1700);
series1.add(new Month(5, 2005), 1600);
series1.add(new Month(6, 2005), 2400);
series1.add(new Month(7, 2005), 2100);
series1.add(new Month(8, 2005), 2200);
series1.add(new Month(9, 2005), 800);
series1.add(new Month(10, 2005), 2350);
series1.add(new Month(11, 2005), 500);
series1.add(new Month(12, 2005), 700);
series1.add(new Month(1, 2006), 900);
series1.add(new Month(2, 2006), 1500);
series1.add(new Month(3, 2006), 2100);
series1.add(new Month(4, 2006), 2200);
series1.add(new Month(5, 2006), 1900);
series1.add(new Month(6, 2006), 3000);
series1.add(new Month(7, 2006), 3780);
series1.add(new Month(8, 2006), 4000);
series1.add(new Month(9, 2006), 4500);
series1.add(new Month(10, 2006), 7000);
series1.add(new Month(11, 2006), 5500);
series1.add(new Month(12, 2006), 6000);
series1.add(new Month(1, 2007), 6500);
dataset.addSeries(series1);
return dataset;
public static JPanel createDemoPanel() {
JFreeChart chart = createCombinedChart();
return new ChartPanel(chart);
public static void main(String[] args) {
CombinedXYPlotDemo1 demo = new CombinedXYPlotDemo1(
"JFreeChart : CombinedXYPlotDemo1");
demo.pack();
RefineryUtilities.centerFrameOnScreen(demo);
demo.setVisible(true);
package org.jfree.experimental.chart.plot;
import java.util.Iterator;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.CombinedDomainCategoryPlot;
import org.jfree.data.Range;
public class CombinedCategoryPlot extends CombinedDomainCategoryPlot {
public CombinedCategoryPlot (CategoryAxis domainAxis, ValueAxis rangeAxis) {
super(domainAxis);
super.setGap(10.0);
super.setRangeAxis(rangeAxis);
public void add(CategoryPlot subplot) {
this.add(subplot, 1);
public void add(CategoryPlot subplot, int weight) {
super.add(subplot, weight);
ValueAxis l_range = super.getRangeAxis();
subplot.setRangeAxis(0, l_range, false);
super.setRangeAxis(l_range);
if (null == l_range) {
return;
l_range.configure();
public Range getDataRange(ValueAxis axis) {
Range l_result = null;
Iterator l_itr = getSubplots().iterator();
while (l_itr.hasNext()) {
CategoryPlot l_subplot = (CategoryPlot) l_itr.next();
l_result = Range.combine(l_result, l_subplot.getDataRange(axis));
return l_result;
public void setRangeAxis(ValueAxis axis) {
Iterator l_itr = getSubplots().iterator();
while (l_itr.hasNext()) {
CategoryPlot l_subplot = (CategoryPlot) l_itr.next();
l_subplot.setRangeAxis(0, axis, false);
super.setRangeAxis(axis);
if (null == axis) {
return;
axis.configure();
package org.jfree.experimental.chart.plot;
import java.util.Iterator;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.CombinedDomainCategoryPlot;
import org.jfree.chart.plot.CombinedDomainXYPlot;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.Range;
public class CombinedXYPlot extends CombinedDomainXYPlot {
public CombinedXYPlot(ValueAxis domainAxis, ValueAxis rangeAxis) {
super(domainAxis);
super.setGap(10.0);
super.setRangeAxis(rangeAxis);
public void add(XYPlot subplot) {
this.add(subplot, 1);
public void add(XYPlot subplot, int weight) {
super.add(subplot, weight);
ValueAxis l_range = super.getRangeAxis();
subplot.setRangeAxis(0, l_range, false);
super.setRangeAxis(l_range);
if (null == l_range) {
return;
l_range.configure();
public Range getDataRange(ValueAxis axis) {
Range l_result = null;
Iterator l_itr = getSubplots().iterator();
while (l_itr.hasNext()) {
XYPlot l_subplot = (XYPlot) l_itr.next();
l_result = Range.combine(l_result, l_subplot.getDataRange(axis));
return l_result;
public void setRangeAxis(ValueAxis axis) {
Iterator l_itr = getSubplots().iterator();
while (l_itr.hasNext()) {
XYPlot l_subplot = (XYPlot) l_itr.next();
l_subplot.setRangeAxis(0, axis, false);
super.setRangeAxis(axis);
if (null == axis) {
return;
axis.configure();package org.jfree.chart.renderer.xy;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Stroke;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import org.jfree.chart.HashUtilities;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.data.xy.XYDataset;
import org.jfree.ui.RectangleEdge;
import org.jfree.util.PublicCloneable;
public class XYStepRenderer extends XYLineAndShapeRenderer
implements XYItemRenderer, Cloneable, PublicCloneable, Serializable {
private static final long serialVersionUID = -8918141928884796108L;
private double stepPoint = 1.0d;
public XYStepRenderer() {
this(null, null);
public XYStepRenderer(XYToolTipGenerator toolTipGenerator,
XYURLGenerator urlGenerator) {
super();
setBaseToolTipGenerator(toolTipGenerator);
setURLGenerator(urlGenerator);
setBaseShapesVisible(false);
public double getStepPoint() {
return this.stepPoint;
public void setStepPoint(double stepPoint) {
if (stepPoint < 0.0d || stepPoint > 1.0d) {
throw new IllegalArgumentException(
"Requires stepPoint in [0.0;1.0]");
this.stepPoint = stepPoint;
fireChangeEvent();
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
if (!getItemVisible(series, item)) {
return;
PlotOrientation orientation = plot.getOrientation();
Paint seriesPaint = getItemPaint(series, item);
Stroke seriesStroke = getItemStroke(series, item);
g2.setPaint(seriesPaint);
g2.setStroke(seriesStroke);
double x1 = dataset.getXValue(series, item);
double y1 = dataset.getYValue(series, item);
RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);
double transY1 = (Double.isNaN(y1) ? Double.NaN
: rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation));
if (pass == 0 && item > 0) {
double x0 = dataset.getXValue(series, item - 1);
double y0 = dataset.getYValue(series, item - 1);
double transX0 = domainAxis.valueToJava2D(x0, dataArea,
xAxisLocation);
double transY0 = (Double.isNaN(y0) ? Double.NaN
: rangeAxis.valueToJava2D(y0, dataArea, yAxisLocation));
if (orientation == PlotOrientation.HORIZONTAL) {
if (transY0 == transY1) {
drawLine(g2, state.workingLine, transY0, transX0, transY1,
transX1);
else {  //this handles the need to perform a 'step'.
double transXs = transX0 + (getStepPoint()
drawLine(g2, state.workingLine, transY0, transX0, transY0,
transXs);
drawLine(g2, state.workingLine, transY0, transXs, transY1,
transXs);
drawLine(g2, state.workingLine, transY1, transXs, transY1,
transX1);
else if (orientation == PlotOrientation.VERTICAL) {
if (transY0 == transY1) { // this represents the situation
drawLine(g2, state.workingLine, transX0, transY0, transX1,
transY1);
else {  //this handles the need to perform a 'step'.
double transXs = transX0 + (getStepPoint()
drawLine(g2, state.workingLine, transX0, transY0, transXs,
transY0);
drawLine(g2, state.workingLine, transXs, transY0, transXs,
transY1);
drawLine(g2, state.workingLine, transXs, transY1, transX1,
transY1);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
addEntity(entities, null, dataset, series, item, transX1,
transY1);
if (pass == 1) {
if (isItemLabelVisible(series, item)) {
double xx = transX1;
double yy = transY1;
if (orientation == PlotOrientation.HORIZONTAL) {
xx = transY1;
yy = transX1;
drawItemLabel(g2, orientation, dataset, series, item, xx, yy,
(y1 < 0.0));
private void drawLine(Graphics2D g2, Line2D line, double x0, double y0,
double x1, double y1) {
if (Double.isNaN(x0) || Double.isNaN(x1) || Double.isNaN(y0)
|| Double.isNaN(y1)) {
return;
line.setLine(x0, y0, x1, y1);
g2.draw(line);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof XYLineAndShapeRenderer)) {
return false;
XYStepRenderer that = (XYStepRenderer) obj;
if (this.stepPoint != that.stepPoint) {
return false;
return super.equals(obj);
public int hashCode() {
return HashUtilities.hashCode(super.hashCode(), this.stepPoint);
public Object clone() throws CloneNotSupportedException {
return super.clone();import org.jfree.chart.renderer.xy.XYItemRenderer;
public double getAngleOffset()
return angleOffset;
public void setAngleOffset(double offset)package org.jfree.chart.renderer;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import java.util.List;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.event.RendererChangeListener;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.PolarPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.data.xy.XYDataset;
public interface PolarItemRenderer {
public void drawSeries(Graphics2D g2, Rectangle2D dataArea,
PlotRenderingInfo info, PolarPlot plot, XYDataset dataset,
int seriesIndex);
public void drawAngularGridLines(Graphics2D g2, PolarPlot plot,
List ticks, Rectangle2D dataArea);
public void drawRadialGridLines(Graphics2D g2, PolarPlot plot,
ValueAxis radialAxis, List ticks, Rectangle2D dataArea);
public LegendItem getLegendItem(int series);
public PolarPlot getPlot();
public void setPlot(PolarPlot plot);
public void addChangeListener(RendererChangeListener listener);
public void removeChangeListener(RendererChangeListener listener);
public XYToolTipGenerator getToolTipGenerator(int row, int column);
public XYToolTipGenerator getSeriesToolTipGenerator(int series);
public void setSeriesToolTipGenerator(int series,
XYToolTipGenerator generator);
public XYToolTipGenerator getBaseToolTipGenerator();
public void setBaseToolTipGenerator(XYToolTipGenerator generator);
public XYURLGenerator getURLGenerator();
public void setURLGenerator(XYURLGenerator urlGenerator);package org.jfree.chart.renderer.xy;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.ItemLabelAnchor;
import org.jfree.chart.labels.ItemLabelPosition;
import org.jfree.chart.labels.XYItemLabelGenerator;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.data.Range;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.xy.IntervalXYDataset;
import org.jfree.data.xy.TableXYDataset;
import org.jfree.data.xy.XYDataset;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.TextAnchor;
public class StackedXYBarRenderer extends XYBarRenderer {
private static final long serialVersionUID = -7049101055533436444L;
private boolean renderAsPercentages;
public StackedXYBarRenderer() {
this(0.0);
public StackedXYBarRenderer(double margin) {
super(margin);
this.renderAsPercentages = false;
ItemLabelPosition p = new ItemLabelPosition(ItemLabelAnchor.CENTER,
TextAnchor.CENTER);
setBasePositiveItemLabelPosition(p);
setBaseNegativeItemLabelPosition(p);
setPositiveItemLabelPositionFallback(null);
setNegativeItemLabelPositionFallback(null);
public boolean getRenderAsPercentages() {
return this.renderAsPercentages;
public void setRenderAsPercentages(boolean asPercentages) {
this.renderAsPercentages = asPercentages;
fireChangeEvent();
public int getPassCount() {
return 3;
public XYItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
XYPlot plot,
XYDataset data,
PlotRenderingInfo info) {
return new XYBarRendererState(info);
public Range findRangeBounds(XYDataset dataset) {
if (dataset != null) {
if (this.renderAsPercentages) {
return new Range(0.0, 1.0);
else {
return DatasetUtilities.findStackedRangeBounds(
(TableXYDataset) dataset);
else {
return null;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
if (!getItemVisible(series, item)) {
return;
if (!(dataset instanceof IntervalXYDataset
&& dataset instanceof TableXYDataset)) {
String message = "dataset (type " + dataset.getClass().getName()
+ ") has wrong type:";
boolean and = false;
if (!IntervalXYDataset.class.isAssignableFrom(dataset.getClass())) {
message += " it is no IntervalXYDataset";
and = true;
if (!TableXYDataset.class.isAssignableFrom(dataset.getClass())) {
if (and) {
message += " and";
message += " it is no TableXYDataset";
throw new IllegalArgumentException(message);
IntervalXYDataset intervalDataset = (IntervalXYDataset) dataset;
double value = intervalDataset.getYValue(series, item);
if (Double.isNaN(value)) {
return;
double total = 0.0;
if (this.renderAsPercentages) {
total = DatasetUtilities.calculateStackTotal(
(TableXYDataset) dataset, item);
value = value / total;
double positiveBase = 0.0;
double negativeBase = 0.0;
for (int i = 0; i < series; i++) {
double v = dataset.getYValue(i, item);
if (!Double.isNaN(v) && isSeriesVisible(i)) {
if (this.renderAsPercentages) {
v = v / total;
if (v > 0) {
positiveBase = positiveBase + v;
else {
negativeBase = negativeBase + v;
double translatedBase;
double translatedValue;
RectangleEdge edgeR = plot.getRangeAxisEdge();
if (value > 0.0) {
translatedBase = rangeAxis.valueToJava2D(positiveBase, dataArea,
edgeR);
translatedValue = rangeAxis.valueToJava2D(positiveBase + value,
dataArea, edgeR);
else {
translatedBase = rangeAxis.valueToJava2D(negativeBase, dataArea,
edgeR);
translatedValue = rangeAxis.valueToJava2D(negativeBase + value,
dataArea, edgeR);
RectangleEdge edgeD = plot.getDomainAxisEdge();
double startX = intervalDataset.getStartXValue(series, item);
if (Double.isNaN(startX)) {
return;
double translatedStartX = domainAxis.valueToJava2D(startX, dataArea,
edgeD);
double endX = intervalDataset.getEndXValue(series, item);
if (Double.isNaN(endX)) {
return;
double translatedEndX = domainAxis.valueToJava2D(endX, dataArea, edgeD);
double translatedWidth = Math.max(1, Math.abs(translatedEndX
- translatedStartX));
double translatedHeight = Math.abs(translatedValue - translatedBase);
if (getMargin() > 0.0) {
double cut = translatedWidth * getMargin();
translatedWidth = translatedWidth - cut;
translatedStartX = translatedStartX + cut / 2;
Rectangle2D bar = null;
PlotOrientation orientation = plot.getOrientation();
if (orientation == PlotOrientation.HORIZONTAL) {
bar = new Rectangle2D.Double(Math.min(translatedBase,
translatedValue), Math.min(translatedEndX,
translatedStartX), translatedHeight, translatedWidth);
else if (orientation == PlotOrientation.VERTICAL) {
bar = new Rectangle2D.Double(Math.min(translatedStartX,
translatedEndX), Math.min(translatedBase, translatedValue),
translatedWidth, translatedHeight);
boolean positive = (value > 0.0);
boolean inverted = rangeAxis.isInverted();
RectangleEdge barBase;
if (orientation == PlotOrientation.HORIZONTAL) {
if (positive && inverted || !positive && !inverted) {
barBase = RectangleEdge.RIGHT;
else {
barBase = RectangleEdge.LEFT;
else {
if (positive && !inverted || !positive && inverted) {
barBase = RectangleEdge.BOTTOM;
else {
barBase = RectangleEdge.TOP;
if (pass == 0) {
if (getShadowsVisible()) {
getBarPainter().paintBarShadow(g2, this, series, item, bar,
barBase, false);
else if (pass == 1) {
getBarPainter().paintBar(g2, this, series, item, bar, barBase);
if (info != null) {
EntityCollection entities = info.getOwner()
.getEntityCollection();
if (entities != null) {
addEntity(entities, bar, dataset, series, item,
bar.getCenterX(), bar.getCenterY());
else if (pass == 2) {
if (isItemLabelVisible(series, item)) {
XYItemLabelGenerator generator = getItemLabelGenerator(series,
item);
drawItemLabel(g2, dataset, series, item, plot, generator, bar,
value < 0.0);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof StackedXYBarRenderer)) {
return false;
StackedXYBarRenderer that = (StackedXYBarRenderer) obj;
if (this.renderAsPercentages != that.renderAsPercentages) {
return false;
return super.equals(obj);
public int hashCode() {
int result = super.hashCode();
result = result * 37 + (this.renderAsPercentages ? 1 : 0);
return result;public void setShapesVisible(boolean shapesVisible) {
this.shapesVisible = shapesVisible;else {
Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2,
Arc2D.OPEN);
Point2D point1 = arc1.getEndPoint();
Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2,
Arc2D.OPEN);
Point2D point2 = arc2.getEndPoint();
double deltaX = (point1.getX() - point2.getX()) * explodePercent;
double deltaY = (point1.getY() - point2.getY()) * explodePercent;
return new Rectangle2D.Double(unexploded.getX() - deltaX,
unexploded.getY() - deltaY, unexploded.getWidth(),
unexploded.getHeight());
else {
return p.getRootPlot();
import org.jfree.chart.axis.AxisLocation;
public boolean isCounterClockwise()
return counterClockwise;package org.jfree.chart.plot;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.QuadCurve2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.TreeMap;
import org.jfree.chart.LegendItem;
import org.jfree.chart.LegendItemCollection;
import org.jfree.chart.PaintMap;
import org.jfree.chart.StrokeMap;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.PieSectionEntity;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.labels.PieSectionLabelGenerator;
import org.jfree.chart.labels.PieToolTipGenerator;
import org.jfree.chart.labels.StandardPieSectionLabelGenerator;
import org.jfree.chart.urls.PieURLGenerator;
import org.jfree.chart.util.DefaultShadowGenerator;
import org.jfree.chart.util.ResourceBundleWrapper;
import org.jfree.chart.util.ShadowGenerator;
import org.jfree.data.DefaultKeyedValues;
import org.jfree.data.KeyedValues;
import org.jfree.data.general.DatasetChangeEvent;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.general.PieDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.text.G2TextMeasurer;
import org.jfree.text.TextBlock;
import org.jfree.text.TextBox;
import org.jfree.text.TextUtilities;
import org.jfree.ui.RectangleAnchor;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PaintUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.Rotation;
import org.jfree.util.ShapeUtilities;
import org.jfree.util.UnitType;
public class PiePlot extends Plot implements Cloneable, Serializable {
private static final long serialVersionUID = -795612466005590431L;
public static final double DEFAULT_INTERIOR_GAP = 0.08;
public static final double MAX_INTERIOR_GAP = 0.40;
public static final double DEFAULT_START_ANGLE = 90.0;
public static final Font DEFAULT_LABEL_FONT = new Font("SansSerif",
Font.PLAIN, 10);
public static final Paint DEFAULT_LABEL_PAINT = Color.black;
public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255,
255, 192);
public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black;
public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke(
0.5f);
public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151,
151, 128);
public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001;
private PieDataset dataset;
private int pieIndex;
private double interiorGap;
private boolean circular;
private double startAngle;
private Rotation direction;
private PaintMap sectionPaintMap;
private transient Paint baseSectionPaint;
private boolean autoPopulateSectionPaint;
private boolean sectionOutlinesVisible;
private PaintMap sectionOutlinePaintMap;
private transient Paint baseSectionOutlinePaint;
private boolean autoPopulateSectionOutlinePaint;
private StrokeMap sectionOutlineStrokeMap;
private transient Stroke baseSectionOutlineStroke;
private boolean autoPopulateSectionOutlineStroke;
private transient Paint shadowPaint = Color.gray;
private double shadowXOffset = 4.0f;
private double shadowYOffset = 4.0f;
private Map explodePercentages;
private PieSectionLabelGenerator labelGenerator;
private Font labelFont;
private transient Paint labelPaint;
private transient Paint labelBackgroundPaint;
private transient Paint labelOutlinePaint;
private transient Stroke labelOutlineStroke;
private transient Paint labelShadowPaint;
private boolean simpleLabels = true;
private RectangleInsets labelPadding;
private RectangleInsets simpleLabelOffset;
private double maximumLabelWidth = 0.14;
private double labelGap = 0.025;
private boolean labelLinksVisible;
private PieLabelLinkStyle labelLinkStyle = PieLabelLinkStyle.STANDARD;
private double labelLinkMargin = 0.025;
private transient Paint labelLinkPaint = Color.black;
private transient Stroke labelLinkStroke = new BasicStroke(0.5f);
private AbstractPieLabelDistributor labelDistributor;
private PieToolTipGenerator toolTipGenerator;
private PieURLGenerator urlGenerator;
private PieSectionLabelGenerator legendLabelGenerator;
private PieSectionLabelGenerator legendLabelToolTipGenerator;
private PieURLGenerator legendLabelURLGenerator;
private boolean ignoreNullValues;
private boolean ignoreZeroValues;
private transient Shape legendItemShape;
private double minimumArcAngleToDraw;
private ShadowGenerator shadowGenerator;
protected static ResourceBundle localizationResources
= ResourceBundleWrapper.getBundle(
"org.jfree.chart.plot.LocalizationBundle");
static final boolean DEBUG_DRAW_INTERIOR = false;
static final boolean DEBUG_DRAW_LINK_AREA = false;
static final boolean DEBUG_DRAW_PIE_AREA = false;
public PiePlot() {
this(null);
public PiePlot(PieDataset dataset) {
super();
this.dataset = dataset;
if (dataset != null) {
dataset.addChangeListener(this);
this.pieIndex = 0;
this.interiorGap = DEFAULT_INTERIOR_GAP;
this.circular = true;
this.startAngle = DEFAULT_START_ANGLE;
this.direction = Rotation.CLOCKWISE;
this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;
this.sectionPaint = null;
this.sectionPaintMap = new PaintMap();
this.baseSectionPaint = Color.gray;
this.autoPopulateSectionPaint = true;
this.sectionOutlinesVisible = true;
this.sectionOutlinePaint = null;
this.sectionOutlinePaintMap = new PaintMap();
this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;
this.autoPopulateSectionOutlinePaint = false;
this.sectionOutlineStroke = null;
this.sectionOutlineStrokeMap = new StrokeMap();
this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;
this.autoPopulateSectionOutlineStroke = false;
this.explodePercentages = new TreeMap();
this.labelGenerator = new StandardPieSectionLabelGenerator();
this.labelFont = DEFAULT_LABEL_FONT;
this.labelPaint = DEFAULT_LABEL_PAINT;
this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;
this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;
this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;
this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;
this.labelLinksVisible = true;
this.labelDistributor = new PieLabelDistributor(0);
this.simpleLabels = false;
this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18,
0.18, 0.18, 0.18);
this.labelPadding = new RectangleInsets(2, 2, 2, 2);
this.toolTipGenerator = null;
this.urlGenerator = null;
this.legendLabelGenerator = new StandardPieSectionLabelGenerator();
this.legendLabelToolTipGenerator = null;
this.legendLabelURLGenerator = null;
this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;
this.ignoreNullValues = false;
this.ignoreZeroValues = false;
this.shadowGenerator = new DefaultShadowGenerator();
public PieDataset getDataset() {
return this.dataset;
public void setDataset(PieDataset dataset) {
PieDataset existing = this.dataset;
if (existing != null) {
existing.removeChangeListener(this);
this.dataset = dataset;
if (dataset != null) {
setDatasetGroup(dataset.getGroup());
dataset.addChangeListener(this);
DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);
datasetChanged(event);
public int getPieIndex() {
return this.pieIndex;
public void setPieIndex(int index) {
this.pieIndex = index;
public double getStartAngle() {
return this.startAngle;
public void setStartAngle(double angle) {
this.startAngle = angle;
fireChangeEvent();
public Rotation getDirection() {
return this.direction;
public void setDirection(Rotation direction) {
if (direction == null) {
throw new IllegalArgumentException("Null 'direction' argument.");
this.direction = direction;
fireChangeEvent();
public double getInteriorGap() {
return this.interiorGap;
public void setInteriorGap(double percent) {
if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {
throw new IllegalArgumentException(
"Invalid 'percent' (" + percent + ") argument.");
if (this.interiorGap != percent) {
this.interiorGap = percent;
fireChangeEvent();
public boolean isCircular() {
return this.circular;
public void setCircular(boolean flag) {
setCircular(flag, true);
public void setCircular(boolean circular, boolean notify) {
this.circular = circular;
if (notify) {
fireChangeEvent();
public boolean getIgnoreNullValues() {
return this.ignoreNullValues;
public void setIgnoreNullValues(boolean flag) {
this.ignoreNullValues = flag;
fireChangeEvent();
public boolean getIgnoreZeroValues() {
return this.ignoreZeroValues;
public void setIgnoreZeroValues(boolean flag) {
this.ignoreZeroValues = flag;
fireChangeEvent();
protected Paint lookupSectionPaint(Comparable key) {
return lookupSectionPaint(key, getAutoPopulateSectionPaint());
protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {
Paint result = getSectionPaint();
if (result != null) {
return result;
result = this.sectionPaintMap.getPaint(key);
if (result != null) {
return result;
if (autoPopulate) {
DrawingSupplier ds = getDrawingSupplier();
if (ds != null) {
result = ds.getNextPaint();
this.sectionPaintMap.put(key, result);
else {
result = this.baseSectionPaint;
else {
result = this.baseSectionPaint;
return result;
public Paint getSectionPaint() {
return this.sectionPaint;
public void setSectionPaint(Paint paint) {
this.sectionPaint = paint;
fireChangeEvent();
protected Comparable getSectionKey(int section) {
Comparable key = null;
if (this.dataset != null) {
if (section >= 0 && section < this.dataset.getItemCount()) {
key = this.dataset.getKey(section);
if (key == null) {
key = new Integer(section);
return key;
public Paint getSectionPaint(Comparable key) {
return this.sectionPaintMap.getPaint(key);
public void setSectionPaint(Comparable key, Paint paint) {
this.sectionPaintMap.put(key, paint);
fireChangeEvent();
public void clearSectionPaints(boolean notify) {
this.sectionPaintMap.clear();
if (notify) {
fireChangeEvent();
public Paint getBaseSectionPaint() {
return this.baseSectionPaint;
public void setBaseSectionPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.baseSectionPaint = paint;
fireChangeEvent();
public boolean getAutoPopulateSectionPaint() {
return this.autoPopulateSectionPaint;
public void setAutoPopulateSectionPaint(boolean auto) {
this.autoPopulateSectionPaint = auto;
fireChangeEvent();
public boolean getSectionOutlinesVisible() {
return this.sectionOutlinesVisible;
public void setSectionOutlinesVisible(boolean visible) {
this.sectionOutlinesVisible = visible;
fireChangeEvent();
protected Paint lookupSectionOutlinePaint(Comparable key) {
return lookupSectionOutlinePaint(key,
getAutoPopulateSectionOutlinePaint());
protected Paint lookupSectionOutlinePaint(Comparable key,
boolean autoPopulate) {
Paint result = getSectionOutlinePaint();
if (result != null) {
return result;
result = this.sectionOutlinePaintMap.getPaint(key);
if (result != null) {
return result;
if (autoPopulate) {
DrawingSupplier ds = getDrawingSupplier();
if (ds != null) {
result = ds.getNextOutlinePaint();
this.sectionOutlinePaintMap.put(key, result);
else {
result = this.baseSectionOutlinePaint;
else {
result = this.baseSectionOutlinePaint;
return result;
public Paint getSectionOutlinePaint(Comparable key) {
return this.sectionOutlinePaintMap.getPaint(key);
public void setSectionOutlinePaint(Comparable key, Paint paint) {
this.sectionOutlinePaintMap.put(key, paint);
fireChangeEvent();
public void clearSectionOutlinePaints(boolean notify) {
this.sectionOutlinePaintMap.clear();
if (notify) {
fireChangeEvent();
public Paint getBaseSectionOutlinePaint() {
return this.baseSectionOutlinePaint;
public void setBaseSectionOutlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.baseSectionOutlinePaint = paint;
fireChangeEvent();
public boolean getAutoPopulateSectionOutlinePaint() {
return this.autoPopulateSectionOutlinePaint;
public void setAutoPopulateSectionOutlinePaint(boolean auto) {
this.autoPopulateSectionOutlinePaint = auto;
fireChangeEvent();
protected Stroke lookupSectionOutlineStroke(Comparable key) {
return lookupSectionOutlineStroke(key,
getAutoPopulateSectionOutlineStroke());
protected Stroke lookupSectionOutlineStroke(Comparable key,
boolean autoPopulate) {
Stroke result = getSectionOutlineStroke();
if (result != null) {
return result;
result = this.sectionOutlineStrokeMap.getStroke(key);
if (result != null) {
return result;
if (autoPopulate) {
DrawingSupplier ds = getDrawingSupplier();
if (ds != null) {
result = ds.getNextOutlineStroke();
this.sectionOutlineStrokeMap.put(key, result);
else {
result = this.baseSectionOutlineStroke;
else {
result = this.baseSectionOutlineStroke;
return result;
public Stroke getSectionOutlineStroke(Comparable key) {
return this.sectionOutlineStrokeMap.getStroke(key);
public void setSectionOutlineStroke(Comparable key, Stroke stroke) {
this.sectionOutlineStrokeMap.put(key, stroke);
fireChangeEvent();
public void clearSectionOutlineStrokes(boolean notify) {
this.sectionOutlineStrokeMap.clear();
if (notify) {
fireChangeEvent();
public Stroke getBaseSectionOutlineStroke() {
return this.baseSectionOutlineStroke;
public void setBaseSectionOutlineStroke(Stroke stroke) {
if (stroke == null) {
throw new IllegalArgumentException("Null 'stroke' argument.");
this.baseSectionOutlineStroke = stroke;
fireChangeEvent();
public boolean getAutoPopulateSectionOutlineStroke() {
return this.autoPopulateSectionOutlineStroke;
public void setAutoPopulateSectionOutlineStroke(boolean auto) {
this.autoPopulateSectionOutlineStroke = auto;
fireChangeEvent();
public Paint getShadowPaint() {
return this.shadowPaint;
public void setShadowPaint(Paint paint) {
this.shadowPaint = paint;
fireChangeEvent();
public double getShadowXOffset() {
return this.shadowXOffset;
public void setShadowXOffset(double offset) {
this.shadowXOffset = offset;
fireChangeEvent();
public double getShadowYOffset() {
return this.shadowYOffset;
public void setShadowYOffset(double offset) {
this.shadowYOffset = offset;
fireChangeEvent();
public double getExplodePercent(Comparable key) {
double result = 0.0;
if (this.explodePercentages != null) {
Number percent = (Number) this.explodePercentages.get(key);
if (percent != null) {
result = percent.doubleValue();
return result;
public void setExplodePercent(Comparable key, double percent) {
if (key == null) {
throw new IllegalArgumentException("Null 'key' argument.");
if (this.explodePercentages == null) {
this.explodePercentages = new TreeMap();
this.explodePercentages.put(key, new Double(percent));
fireChangeEvent();
public double getMaximumExplodePercent() {
if (this.dataset == null) {
return 0.0;
double result = 0.0;
Iterator iterator = this.dataset.getKeys().iterator();
while (iterator.hasNext()) {
Comparable key = (Comparable) iterator.next();
Number explode = (Number) this.explodePercentages.get(key);
if (explode != null) {
result = Math.max(result, explode.doubleValue());
return result;
public PieSectionLabelGenerator getLabelGenerator() {
return this.labelGenerator;
public void setLabelGenerator(PieSectionLabelGenerator generator) {
this.labelGenerator = generator;
fireChangeEvent();
public double getLabelGap() {
return this.labelGap;
public void setLabelGap(double gap) {
this.labelGap = gap;
fireChangeEvent();
public double getMaximumLabelWidth() {
return this.maximumLabelWidth;
public void setMaximumLabelWidth(double width) {
this.maximumLabelWidth = width;
fireChangeEvent();
public boolean getLabelLinksVisible() {
return this.labelLinksVisible;
public void setLabelLinksVisible(boolean visible) {
this.labelLinksVisible = visible;
fireChangeEvent();
public PieLabelLinkStyle getLabelLinkStyle() {
return this.labelLinkStyle;
public void setLabelLinkStyle(PieLabelLinkStyle style) {
if (style == null) {
throw new IllegalArgumentException("Null 'style' argument.");
this.labelLinkStyle = style;
fireChangeEvent();
public double getLabelLinkMargin() {
return this.labelLinkMargin;
public void setLabelLinkMargin(double margin) {
this.labelLinkMargin = margin;
fireChangeEvent();
public Paint getLabelLinkPaint() {
return this.labelLinkPaint;
public void setLabelLinkPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.labelLinkPaint = paint;
fireChangeEvent();
public Stroke getLabelLinkStroke() {
return this.labelLinkStroke;
public void setLabelLinkStroke(Stroke stroke) {
if (stroke == null) {
throw new IllegalArgumentException("Null 'stroke' argument.");
this.labelLinkStroke = stroke;
fireChangeEvent();
protected double getLabelLinkDepth() {
return 0.1;
public Font getLabelFont() {
return this.labelFont;
public void setLabelFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.labelFont = font;
fireChangeEvent();
public Paint getLabelPaint() {
return this.labelPaint;
public void setLabelPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.labelPaint = paint;
fireChangeEvent();
public Paint getLabelBackgroundPaint() {
return this.labelBackgroundPaint;
public void setLabelBackgroundPaint(Paint paint) {
this.labelBackgroundPaint = paint;
fireChangeEvent();
public Paint getLabelOutlinePaint() {
return this.labelOutlinePaint;
public void setLabelOutlinePaint(Paint paint) {
this.labelOutlinePaint = paint;
fireChangeEvent();
public Stroke getLabelOutlineStroke() {
return this.labelOutlineStroke;
public void setLabelOutlineStroke(Stroke stroke) {
this.labelOutlineStroke = stroke;
fireChangeEvent();
public Paint getLabelShadowPaint() {
return this.labelShadowPaint;
public void setLabelShadowPaint(Paint paint) {
this.labelShadowPaint = paint;
fireChangeEvent();
public RectangleInsets getLabelPadding() {
return this.labelPadding;
public void setLabelPadding(RectangleInsets padding) {
if (padding == null) {
throw new IllegalArgumentException("Null 'padding' argument.");
this.labelPadding = padding;
fireChangeEvent();
public boolean getSimpleLabels() {
return this.simpleLabels;
public void setSimpleLabels(boolean simple) {
this.simpleLabels = simple;
fireChangeEvent();
public RectangleInsets getSimpleLabelOffset() {
return this.simpleLabelOffset;
public void setSimpleLabelOffset(RectangleInsets offset) {
if (offset == null) {
throw new IllegalArgumentException("Null 'offset' argument.");
this.simpleLabelOffset = offset;
fireChangeEvent();
public AbstractPieLabelDistributor getLabelDistributor() {
return this.labelDistributor;
public void setLabelDistributor(AbstractPieLabelDistributor distributor) {
if (distributor == null) {
throw new IllegalArgumentException("Null 'distributor' argument.");
this.labelDistributor = distributor;
fireChangeEvent();
public PieToolTipGenerator getToolTipGenerator() {
return this.toolTipGenerator;
public void setToolTipGenerator(PieToolTipGenerator generator) {
this.toolTipGenerator = generator;
fireChangeEvent();
public PieURLGenerator getURLGenerator() {
return this.urlGenerator;
public void setURLGenerator(PieURLGenerator generator) {
this.urlGenerator = generator;
fireChangeEvent();
public double getMinimumArcAngleToDraw() {
return this.minimumArcAngleToDraw;
public void setMinimumArcAngleToDraw(double angle) {
this.minimumArcAngleToDraw = angle;
public Shape getLegendItemShape() {
return this.legendItemShape;
public void setLegendItemShape(Shape shape) {
if (shape == null) {
throw new IllegalArgumentException("Null 'shape' argument.");
this.legendItemShape = shape;
fireChangeEvent();
public PieSectionLabelGenerator getLegendLabelGenerator() {
return this.legendLabelGenerator;
public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {
if (generator == null) {
throw new IllegalArgumentException("Null 'generator' argument.");
this.legendLabelGenerator = generator;
fireChangeEvent();
public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {
return this.legendLabelToolTipGenerator;
public void setLegendLabelToolTipGenerator(
PieSectionLabelGenerator generator) {
this.legendLabelToolTipGenerator = generator;
fireChangeEvent();
public PieURLGenerator getLegendLabelURLGenerator() {
return this.legendLabelURLGenerator;
public void setLegendLabelURLGenerator(PieURLGenerator generator) {
this.legendLabelURLGenerator = generator;
fireChangeEvent();
public ShadowGenerator getShadowGenerator() {
return this.shadowGenerator;
public void setShadowGenerator(ShadowGenerator generator) {
this.shadowGenerator = generator;
fireChangeEvent();
public void handleMouseWheelRotation(int rotateClicks) {
setStartAngle(this.startAngle + rotateClicks * 4.0);
public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
PiePlot plot, Integer index, PlotRenderingInfo info) {
PiePlotState state = new PiePlotState(info);
state.setPassesRequired(2);
if (this.dataset != null) {
state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
plot.getDataset()));
state.setLatestAngle(plot.getStartAngle());
return state;
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
PlotState parentState, PlotRenderingInfo info) {
RectangleInsets insets = getInsets();
insets.trim(area);
if (info != null) {
info.setPlotArea(area);
info.setDataArea(area);
drawBackground(g2, area);
drawOutline(g2, area);
Shape savedClip = g2.getClip();
g2.clip(area);
Composite originalComposite = g2.getComposite();
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
getForegroundAlpha()));
if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {
Graphics2D savedG2 = g2;
Rectangle2D savedDataArea = area;
BufferedImage dataImage = null;
if (this.shadowGenerator != null) {
dataImage = new BufferedImage((int) area.getWidth(),
(int) area.getHeight(), BufferedImage.TYPE_INT_ARGB);
g2 = dataImage.createGraphics();
g2.setRenderingHints(savedG2.getRenderingHints());
area = new Rectangle(0, 0, dataImage.getWidth(), dataImage.getHeight());
drawPie(g2, area, info);
if (this.shadowGenerator != null) {
BufferedImage shadowImage = this.shadowGenerator.createDropShadow(dataImage);
g2 = savedG2;
area = savedDataArea;
g2.drawImage(shadowImage, (int) savedDataArea.getX() 
+ this.shadowGenerator.calculateOffsetX(),
(int) savedDataArea.getY()
+ this.shadowGenerator.calculateOffsetY(), null);
g2.drawImage(dataImage, (int) savedDataArea.getX(),
(int) savedDataArea.getY(), null);
else {
drawNoDataMessage(g2, area);
g2.setClip(savedClip);
g2.setComposite(originalComposite);
drawOutline(g2, area);
protected void drawPie(Graphics2D g2, Rectangle2D plotArea,
PlotRenderingInfo info) {
PiePlotState state = initialise(g2, plotArea, this, null, info);
double labelReserve = 0.0;
if (this.labelGenerator != null && !this.simpleLabels) {
labelReserve = this.labelGap + this.maximumLabelWidth;
double gapHorizontal = plotArea.getWidth() * (this.interiorGap
+ labelReserve) * 2.0;
double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;
if (DEBUG_DRAW_INTERIOR) {
double hGap = plotArea.getWidth() * this.interiorGap;
double vGap = plotArea.getHeight() * this.interiorGap;
double igx1 = plotArea.getX() + hGap;
double igx2 = plotArea.getMaxX() - hGap;
double igy1 = plotArea.getY() + vGap;
double igy2 = plotArea.getMaxY() - vGap;
g2.setPaint(Color.gray);
g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1,
igy2 - igy1));
double linkX = plotArea.getX() + gapHorizontal / 2;
double linkY = plotArea.getY() + gapVertical / 2;
double linkW = plotArea.getWidth() - gapHorizontal;
double linkH = plotArea.getHeight() - gapVertical;
if (this.circular) {
double min = Math.min(linkW, linkH) / 2;
linkX = (linkX + linkX + linkW) / 2 - min;
linkY = (linkY + linkY + linkH) / 2 - min;
linkW = 2 * min;
linkH = 2 * min;
Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW,
linkH);
state.setLinkArea(linkArea);
if (DEBUG_DRAW_LINK_AREA) {
g2.setPaint(Color.blue);
g2.draw(linkArea);
g2.setPaint(Color.yellow);
g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(),
linkArea.getWidth(), linkArea.getHeight()));
double lm = 0.0;
if (!this.simpleLabels) {
lm = this.labelLinkMargin;
double hh = linkArea.getWidth() * lm * 2.0;
double vv = linkArea.getHeight() * lm * 2.0;
Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0,
linkY + vv / 2.0, linkW - hh, linkH - vv);
state.setExplodedPieArea(explodeArea);
double maximumExplodePercent = getMaximumExplodePercent();
double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);
double h1 = explodeArea.getWidth() * percent;
double v1 = explodeArea.getHeight() * percent;
Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX()
+ h1 / 2.0, explodeArea.getY() + v1 / 2.0,
explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);
if (DEBUG_DRAW_PIE_AREA) {
g2.setPaint(Color.green);
g2.draw(pieArea);
state.setPieArea(pieArea);
state.setPieCenterX(pieArea.getCenterX());
state.setPieCenterY(pieArea.getCenterY());
state.setPieWRadius(pieArea.getWidth() / 2.0);
state.setPieHRadius(pieArea.getHeight() / 2.0);
if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {
List keys = this.dataset.getKeys();
double totalValue = DatasetUtilities.calculatePieDatasetTotal(
this.dataset);
int passesRequired = state.getPassesRequired();
for (int pass = 0; pass < passesRequired; pass++) {
double runningTotal = 0.0;
for (int section = 0; section < keys.size(); section++) {
Number n = this.dataset.getValue(section);
if (n != null) {
double value = n.doubleValue();
if (value > 0.0) {
runningTotal += value;
drawItem(g2, section, explodeArea, state, pass);
if (this.simpleLabels) {
drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea,
state);
else {
drawLabels(g2, keys, totalValue, plotArea, linkArea, state);
else {
drawNoDataMessage(g2, plotArea);
protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea,
PiePlotState state, int currentPass) {
Number n = this.dataset.getValue(section);
if (n == null) {
return;
double value = n.doubleValue();
double angle1 = 0.0;
double angle2 = 0.0;
if (this.direction == Rotation.CLOCKWISE) {
angle1 = state.getLatestAngle();
angle2 = angle1 - value / state.getTotal() * 360.0;
else if (this.direction == Rotation.ANTICLOCKWISE) {
angle1 = state.getLatestAngle();
angle2 = angle1 + value / state.getTotal() * 360.0;
else {
throw new IllegalStateException("Rotation type not recognised.");
double angle = (angle2 - angle1);
if (Math.abs(angle) > getMinimumArcAngleToDraw()) {
double ep = 0.0;
double mep = getMaximumExplodePercent();
if (mep > 0.0) {
ep = getExplodePercent(section) / mep;
Rectangle2D arcBounds = getArcBounds(state.getPieArea(),
state.getExplodedPieArea(), angle1, angle, ep);
Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle,
Arc2D.PIE);
if (currentPass == 0) {
if (this.shadowPaint != null && this.shadowGenerator == null) {
Shape shadowArc = ShapeUtilities.createTranslatedShape(
arc, (float) this.shadowXOffset,
(float) this.shadowYOffset);
g2.setPaint(this.shadowPaint);
g2.fill(shadowArc);
else if (currentPass == 1) {
Comparable key = getSectionKey(section);
Paint paint = lookupSectionPaint(key);
g2.setPaint(paint);
g2.fill(arc);
Paint outlinePaint = lookupSectionOutlinePaint(key);
Stroke outlineStroke = lookupSectionOutlineStroke(key);
if (this.sectionOutlinesVisible) {
g2.setPaint(outlinePaint);
g2.setStroke(outlineStroke);
g2.draw(arc);
if (state.getInfo() != null) {
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
String tip = null;
if (this.toolTipGenerator != null) {
tip = this.toolTipGenerator.generateToolTip(
this.dataset, key);
String url = null;
if (this.urlGenerator != null) {
url = this.urlGenerator.generateURL(this.dataset,
key, this.pieIndex);
PieSectionEntity entity = new PieSectionEntity(
arc, this.dataset, this.pieIndex, section, key,
tip, url);
entities.add(entity);
state.setLatestAngle(angle2);
protected void drawSimpleLabels(Graphics2D g2, List keys,
double totalValue, Rectangle2D plotArea, Rectangle2D pieArea,
PiePlotState state) {
Composite originalComposite = g2.getComposite();
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
1.0f));
Rectangle2D labelsArea = this.simpleLabelOffset.createInsetRectangle(
pieArea);
double runningTotal = 0.0;
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Comparable key = (Comparable) iterator.next();
boolean include = true;
double v = 0.0;
Number n = getDataset().getValue(key);
if (n == null) {
include = !getIgnoreNullValues();
else {
v = n.doubleValue();
include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;
if (include) {
runningTotal = runningTotal + v;
double mid = getStartAngle() + (getDirection().getFactor()
Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(),
mid - getStartAngle(), Arc2D.OPEN);
int x = (int) arc.getEndPoint().getX();
int y = (int) arc.getEndPoint().getY();
PieSectionLabelGenerator labelGenerator = getLabelGenerator();
if (labelGenerator == null) {
continue;
String label = labelGenerator.generateSectionLabel(
this.dataset, key);
if (label == null) {
continue;
g2.setFont(this.labelFont);
FontMetrics fm = g2.getFontMetrics();
Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);
Rectangle2D out = this.labelPadding.createOutsetRectangle(
bounds);
Shape bg = ShapeUtilities.createTranslatedShape(out,
x - bounds.getCenterX(), y - bounds.getCenterY());
if (this.labelShadowPaint != null
&& this.shadowGenerator == null) {
Shape shadow = ShapeUtilities.createTranslatedShape(bg,
this.shadowXOffset, this.shadowYOffset);
g2.setPaint(this.labelShadowPaint);
g2.fill(shadow);
if (this.labelBackgroundPaint != null) {
g2.setPaint(this.labelBackgroundPaint);
g2.fill(bg);
if (this.labelOutlinePaint != null
&& this.labelOutlineStroke != null) {
g2.setPaint(this.labelOutlinePaint);
g2.setStroke(this.labelOutlineStroke);
g2.draw(bg);
g2.setPaint(this.labelPaint);
g2.setFont(this.labelFont);
TextUtilities.drawAlignedString(getLabelGenerator()
.generateSectionLabel(getDataset(), key), g2, x, y,
TextAnchor.CENTER);
g2.setComposite(originalComposite);
protected void drawLabels(Graphics2D g2, List keys, double totalValue,
Rectangle2D plotArea, Rectangle2D linkArea,
PiePlotState state) {
Composite originalComposite = g2.getComposite();
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
1.0f));
DefaultKeyedValues leftKeys = new DefaultKeyedValues();
DefaultKeyedValues rightKeys = new DefaultKeyedValues();
double runningTotal = 0.0;
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Comparable key = (Comparable) iterator.next();
boolean include = true;
double v = 0.0;
Number n = this.dataset.getValue(key);
if (n == null) {
include = !this.ignoreNullValues;
else {
v = n.doubleValue();
include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;
if (include) {
runningTotal = runningTotal + v;
double mid = this.startAngle + (this.direction.getFactor()
if (Math.cos(Math.toRadians(mid)) < 0.0) {
leftKeys.addValue(key, new Double(mid));
else {
rightKeys.addValue(key, new Double(mid));
g2.setFont(getLabelFont());
double marginX = plotArea.getX() + this.interiorGap
double gap = plotArea.getWidth() * this.labelGap;
double ww = linkArea.getX() - gap - marginX;
float labelWidth = (float) this.labelPadding.trimWidth(ww);
if (this.labelGenerator != null) {
drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth,
state);
drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth,
state);
g2.setComposite(originalComposite);
protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2,
Rectangle2D plotArea, Rectangle2D linkArea,
float maxLabelWidth, PiePlotState state) {
this.labelDistributor.clear();
double lGap = plotArea.getWidth() * this.labelGap;
double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;
for (int i = 0; i < leftKeys.getItemCount(); i++) {
String label = this.labelGenerator.generateSectionLabel(
this.dataset, leftKeys.getKey(i));
if (label != null) {
TextBlock block = TextUtilities.createTextBlock(label,
this.labelFont, this.labelPaint, maxLabelWidth,
new G2TextMeasurer(g2));
TextBox labelBox = new TextBox(block);
labelBox.setBackgroundPaint(this.labelBackgroundPaint);
labelBox.setOutlinePaint(this.labelOutlinePaint);
labelBox.setOutlineStroke(this.labelOutlineStroke);
if (this.shadowGenerator == null) {
labelBox.setShadowPaint(this.labelShadowPaint);
else {
labelBox.setShadowPaint(null);
labelBox.setInteriorGap(this.labelPadding);
double theta = Math.toRadians(
leftKeys.getValue(i).doubleValue());
double baseY = state.getPieCenterY() - Math.sin(theta)
double hh = labelBox.getHeight(g2);
this.labelDistributor.addPieLabelRecord(new PieLabelRecord(
leftKeys.getKey(i), theta, baseY, labelBox, hh,
lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 1.0
- getLabelLinkDepth()
+ getExplodePercent(leftKeys.getKey(i))));
double hh = plotArea.getHeight();
double gap = hh * getInteriorGap();
this.labelDistributor.distributeLabels(plotArea.getMinY() + gap,
hh - 2 * gap);
for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {
drawLeftLabel(g2, state,
this.labelDistributor.getPieLabelRecord(i));
protected void drawRightLabels(KeyedValues keys, Graphics2D g2,
Rectangle2D plotArea, Rectangle2D linkArea,
float maxLabelWidth, PiePlotState state) {
this.labelDistributor.clear();
double lGap = plotArea.getWidth() * this.labelGap;
double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;
for (int i = 0; i < keys.getItemCount(); i++) {
String label = this.labelGenerator.generateSectionLabel(
this.dataset, keys.getKey(i));
if (label != null) {
TextBlock block = TextUtilities.createTextBlock(label,
this.labelFont, this.labelPaint, maxLabelWidth,
new G2TextMeasurer(g2));
TextBox labelBox = new TextBox(block);
labelBox.setBackgroundPaint(this.labelBackgroundPaint);
labelBox.setOutlinePaint(this.labelOutlinePaint);
labelBox.setOutlineStroke(this.labelOutlineStroke);
if (this.shadowGenerator == null) {
labelBox.setShadowPaint(this.labelShadowPaint);
else {
labelBox.setShadowPaint(null);
labelBox.setInteriorGap(this.labelPadding);
double theta = Math.toRadians(keys.getValue(i).doubleValue());
double baseY = state.getPieCenterY()
- Math.sin(theta) * verticalLinkRadius;
double hh = labelBox.getHeight(g2);
this.labelDistributor.addPieLabelRecord(new PieLabelRecord(
keys.getKey(i), theta, baseY, labelBox, hh,
lGap / 2.0 + lGap / 2.0 * Math.cos(theta),
1.0 - getLabelLinkDepth()
+ getExplodePercent(keys.getKey(i))));
double hh = plotArea.getHeight();
double gap = hh * getInteriorGap();
this.labelDistributor.distributeLabels(plotArea.getMinY() + gap,
hh - 2 * gap);
for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {
drawRightLabel(g2, state,
this.labelDistributor.getPieLabelRecord(i));
public LegendItemCollection getLegendItems() {
LegendItemCollection result = new LegendItemCollection();
if (this.dataset == null) {
return result;
List keys = this.dataset.getKeys();
int section = 0;
Shape shape = getLegendItemShape();
Iterator iterator = keys.iterator();
while (iterator.hasNext()) {
Comparable key = (Comparable) iterator.next();
Number n = this.dataset.getValue(key);
boolean include = true;
if (n == null) {
include = !this.ignoreNullValues;
else {
double v = n.doubleValue();
if (v == 0.0) {
include = !this.ignoreZeroValues;
else {
include = v > 0.0;
if (include) {
String label = this.legendLabelGenerator.generateSectionLabel(
this.dataset, key);
if (label != null) {
String description = label;
String toolTipText = null;
if (this.legendLabelToolTipGenerator != null) {
toolTipText = this.legendLabelToolTipGenerator
.generateSectionLabel(this.dataset, key);
String urlText = null;
if (this.legendLabelURLGenerator != null) {
urlText = this.legendLabelURLGenerator.generateURL(
this.dataset, key, this.pieIndex);
Paint paint = lookupSectionPaint(key);
Paint outlinePaint = lookupSectionOutlinePaint(key);
Stroke outlineStroke = lookupSectionOutlineStroke(key);
LegendItem item = new LegendItem(label, description,
toolTipText, urlText, true, shape, true, paint,
true, outlinePaint, outlineStroke,
false,          // line not visible
new Line2D.Float(), new BasicStroke(), Color.black);
item.setDataset(getDataset());
item.setSeriesIndex(this.dataset.getIndex(key));
item.setSeriesKey(key);
result.add(item);
section++;
else {
section++;
return result;
public String getPlotType() {
return localizationResources.getString("Pie_Plot");
protected Rectangle2D getArcBounds(Rectangle2D unexploded,
Rectangle2D exploded,
double angle, double extent,
double explodePercent) {
if (explodePercent == 0.0) {
return unexploded;
else {
Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2,
Arc2D.OPEN);
Point2D point1 = arc1.getEndPoint();
Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2,
Arc2D.OPEN);
Point2D point2 = arc2.getEndPoint();
double deltaX = (point1.getX() - point2.getX()) * explodePercent;
double deltaY = (point1.getY() - point2.getY()) * explodePercent;
return new Rectangle2D.Double(unexploded.getX() - deltaX,
unexploded.getY() - deltaY, unexploded.getWidth(),
unexploded.getHeight());
protected void drawLeftLabel(Graphics2D g2, PiePlotState state,
PieLabelRecord record) {
double anchorX = state.getLinkArea().getMinX();
double targetX = anchorX - record.getGap();
double targetY = record.getAllocatedY();
if (this.labelLinksVisible) {
double theta = record.getAngle();
double linkX = state.getPieCenterX() + Math.cos(theta)
double linkY = state.getPieCenterY() - Math.sin(theta)
double elbowX = state.getPieCenterX() + Math.cos(theta)
double elbowY = state.getPieCenterY() - Math.sin(theta)
double anchorY = elbowY;
g2.setPaint(this.labelLinkPaint);
g2.setStroke(this.labelLinkStroke);
PieLabelLinkStyle style = getLabelLinkStyle();
if (style.equals(PieLabelLinkStyle.STANDARD)) {
g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));
g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));
g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));
else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) {
QuadCurve2D q = new QuadCurve2D.Float();
q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY);
g2.draw(q);
g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY));
else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) {
CubicCurve2D c = new CubicCurve2D .Float();
c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY,
linkX, linkY);
g2.draw(c);
TextBox tb = record.getLabel();
tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);
protected void drawRightLabel(Graphics2D g2, PiePlotState state,
PieLabelRecord record) {
double anchorX = state.getLinkArea().getMaxX();
double targetX = anchorX + record.getGap();
double targetY = record.getAllocatedY();
if (this.labelLinksVisible) {
double theta = record.getAngle();
double linkX = state.getPieCenterX() + Math.cos(theta)
double linkY = state.getPieCenterY() - Math.sin(theta)
double elbowX = state.getPieCenterX() + Math.cos(theta)
double elbowY = state.getPieCenterY() - Math.sin(theta)
double anchorY = elbowY;
g2.setPaint(this.labelLinkPaint);
g2.setStroke(this.labelLinkStroke);
PieLabelLinkStyle style = getLabelLinkStyle();
if (style.equals(PieLabelLinkStyle.STANDARD)) {
g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));
g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));
g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));
else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) {
QuadCurve2D q = new QuadCurve2D.Float();
q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY);
g2.draw(q);
g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY));
else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) {
CubicCurve2D c = new CubicCurve2D .Float();
c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY,
linkX, linkY);
g2.draw(c);
TextBox tb = record.getLabel();
tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof PiePlot)) {
return false;
if (!super.equals(obj)) {
return false;
PiePlot that = (PiePlot) obj;
if (this.pieIndex != that.pieIndex) {
return false;
if (this.interiorGap != that.interiorGap) {
return false;
if (this.circular != that.circular) {
return false;
if (this.startAngle != that.startAngle) {
return false;
if (this.direction != that.direction) {
return false;
if (this.ignoreZeroValues != that.ignoreZeroValues) {
return false;
if (this.ignoreNullValues != that.ignoreNullValues) {
return false;
if (!PaintUtilities.equal(this.sectionPaint, that.sectionPaint)) {
return false;
if (!ObjectUtilities.equal(this.sectionPaintMap,
that.sectionPaintMap)) {
return false;
if (!PaintUtilities.equal(this.baseSectionPaint,
that.baseSectionPaint)) {
return false;
if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
return false;
if (!PaintUtilities.equal(this.sectionOutlinePaint,
that.sectionOutlinePaint)) {
return false;
if (!ObjectUtilities.equal(this.sectionOutlinePaintMap,
that.sectionOutlinePaintMap)) {
return false;
if (!PaintUtilities.equal(this.baseSectionOutlinePaint,
that.baseSectionOutlinePaint)) {
return false;
if (!ObjectUtilities.equal(this.sectionOutlineStroke,
that.sectionOutlineStroke)) {
return false;
if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap,
that.sectionOutlineStrokeMap)) {
return false;
if (!ObjectUtilities.equal(this.baseSectionOutlineStroke,
that.baseSectionOutlineStroke)) {
return false;
if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
return false;
if (!(this.shadowXOffset == that.shadowXOffset)) {
return false;
if (!(this.shadowYOffset == that.shadowYOffset)) {
return false;
if (!ObjectUtilities.equal(this.explodePercentages,
that.explodePercentages)) {
return false;
if (!ObjectUtilities.equal(this.labelGenerator,
that.labelGenerator)) {
return false;
if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
return false;
if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
return false;
if (!PaintUtilities.equal(this.labelBackgroundPaint,
that.labelBackgroundPaint)) {
return false;
if (!PaintUtilities.equal(this.labelOutlinePaint,
that.labelOutlinePaint)) {
return false;
if (!ObjectUtilities.equal(this.labelOutlineStroke,
that.labelOutlineStroke)) {
return false;
if (!PaintUtilities.equal(this.labelShadowPaint,
that.labelShadowPaint)) {
return false;
if (this.simpleLabels != that.simpleLabels) {
return false;
if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
return false;
if (!this.labelPadding.equals(that.labelPadding)) {
return false;
if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
return false;
if (!(this.labelGap == that.labelGap)) {
return false;
if (!(this.labelLinkMargin == that.labelLinkMargin)) {
return false;
if (this.labelLinksVisible != that.labelLinksVisible) {
return false;
if (!this.labelLinkStyle.equals(that.labelLinkStyle)) {
return false;
if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
return false;
if (!ObjectUtilities.equal(this.labelLinkStroke,
that.labelLinkStroke)) {
return false;
if (!ObjectUtilities.equal(this.toolTipGenerator,
that.toolTipGenerator)) {
return false;
if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
return false;
if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
return false;
if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
return false;
if (!ObjectUtilities.equal(this.legendLabelGenerator,
that.legendLabelGenerator)) {
return false;
if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,
that.legendLabelToolTipGenerator)) {
return false;
if (!ObjectUtilities.equal(this.legendLabelURLGenerator,
that.legendLabelURLGenerator)) {
return false;
if (this.autoPopulateSectionPaint != that.autoPopulateSectionPaint) {
return false;
if (this.autoPopulateSectionOutlinePaint
!= that.autoPopulateSectionOutlinePaint) {
return false;
if (this.autoPopulateSectionOutlineStroke
!= that.autoPopulateSectionOutlineStroke) {
return false;
if (!ObjectUtilities.equal(this.shadowGenerator,
that.shadowGenerator)) {
return false;
return true;
public Object clone() throws CloneNotSupportedException {
PiePlot clone = (PiePlot) super.clone();
if (clone.dataset != null) {
clone.dataset.addChangeListener(clone);
if (this.urlGenerator instanceof PublicCloneable) {
clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(
this.urlGenerator);
clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);
if (this.legendLabelGenerator != null) {
clone.legendLabelGenerator = (PieSectionLabelGenerator)
ObjectUtilities.clone(this.legendLabelGenerator);
if (this.legendLabelToolTipGenerator != null) {
clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator)
ObjectUtilities.clone(this.legendLabelToolTipGenerator);
if (this.legendLabelURLGenerator instanceof PublicCloneable) {
clone.legendLabelURLGenerator = (PieURLGenerator)
ObjectUtilities.clone(this.legendLabelURLGenerator);
return clone;
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writePaint(this.sectionPaint, stream);
SerialUtilities.writePaint(this.baseSectionPaint, stream);
SerialUtilities.writePaint(this.sectionOutlinePaint, stream);
SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);
SerialUtilities.writeStroke(this.sectionOutlineStroke, stream);
SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);
SerialUtilities.writePaint(this.shadowPaint, stream);
SerialUtilities.writePaint(this.labelPaint, stream);
SerialUtilities.writePaint(this.labelBackgroundPaint, stream);
SerialUtilities.writePaint(this.labelOutlinePaint, stream);
SerialUtilities.writeStroke(this.labelOutlineStroke, stream);
SerialUtilities.writePaint(this.labelShadowPaint, stream);
SerialUtilities.writePaint(this.labelLinkPaint, stream);
SerialUtilities.writeStroke(this.labelLinkStroke, stream);
SerialUtilities.writeShape(this.legendItemShape, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.sectionPaint = SerialUtilities.readPaint(stream);
this.baseSectionPaint = SerialUtilities.readPaint(stream);
this.sectionOutlinePaint = SerialUtilities.readPaint(stream);
this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);
this.sectionOutlineStroke = SerialUtilities.readStroke(stream);
this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);
this.shadowPaint = SerialUtilities.readPaint(stream);
this.labelPaint = SerialUtilities.readPaint(stream);
this.labelBackgroundPaint = SerialUtilities.readPaint(stream);
this.labelOutlinePaint = SerialUtilities.readPaint(stream);
this.labelOutlineStroke = SerialUtilities.readStroke(stream);
this.labelShadowPaint = SerialUtilities.readPaint(stream);
this.labelLinkPaint = SerialUtilities.readPaint(stream);
this.labelLinkStroke = SerialUtilities.readStroke(stream);
this.legendItemShape = SerialUtilities.readShape(stream);
private transient Paint sectionPaint;
private transient Paint sectionOutlinePaint;
private transient Stroke sectionOutlineStroke;
public Paint getSectionPaint(int section) {
Comparable key = getSectionKey(section);
return getSectionPaint(key);
public void setSectionPaint(int section, Paint paint) {
Comparable key = getSectionKey(section);
setSectionPaint(key, paint);
public Paint getSectionOutlinePaint() {
return this.sectionOutlinePaint;
public void setSectionOutlinePaint(Paint paint) {
this.sectionOutlinePaint = paint;
fireChangeEvent();
public Paint getSectionOutlinePaint(int section) {
Comparable key = getSectionKey(section);
return getSectionOutlinePaint(key);
public void setSectionOutlinePaint(int section, Paint paint) {
Comparable key = getSectionKey(section);
setSectionOutlinePaint(key, paint);
public Stroke getSectionOutlineStroke() {
return this.sectionOutlineStroke;
public void setSectionOutlineStroke(Stroke stroke) {
this.sectionOutlineStroke = stroke;
fireChangeEvent();
public Stroke getSectionOutlineStroke(int section) {
Comparable key = getSectionKey(section);
return getSectionOutlineStroke(key);
public void setSectionOutlineStroke(int section, Stroke stroke) {
Comparable key = getSectionKey(section);
setSectionOutlineStroke(key, stroke);
public double getExplodePercent(int section) {
Comparable key = getSectionKey(section);
return getExplodePercent(key);
public void setExplodePercent(int section, double percent) {
Comparable key = getSectionKey(section);
setExplodePercent(key, percent);package org.jfree.chart.renderer;
import java.awt.AlphaComposite;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Iterator;
import java.util.List;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.NumberTick;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.XYItemEntity;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYSeriesLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.DrawingSupplier;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.PolarPlot;
import org.jfree.chart.renderer.xy.AbstractXYItemRenderer;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.text.TextUtilities;
import org.jfree.util.BooleanList;
import org.jfree.util.BooleanUtilities;
import org.jfree.util.ObjectList;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.ShapeUtilities;
public class DefaultPolarItemRenderer extends AbstractRenderer
implements PolarItemRenderer {
private PolarPlot plot;
private BooleanList seriesFilled;
private boolean drawOutlineWhenFilled;
private transient Composite fillComposite;
private boolean useFillPaint;
private transient Shape legendLine;
private boolean shapesVisible;
private boolean connectFirstAndLastPoint;
private ObjectList toolTipGeneratorList;
private XYToolTipGenerator baseToolTipGenerator;
private XYURLGenerator urlGenerator;
private XYSeriesLabelGenerator legendItemToolTipGenerator;
private XYSeriesLabelGenerator legendItemURLGenerator;
public DefaultPolarItemRenderer() {
this.seriesFilled = new BooleanList();
this.drawOutlineWhenFilled = true;
this.fillComposite = AlphaComposite.getInstance(
AlphaComposite.SRC_OVER, 0.3f);
this.useFillPaint = false;     // use item paint for fills by default
this.legendLine = new Line2D.Double(-7.0, 0.0, 7.0, 0.0);
this.shapesVisible = true;
this.connectFirstAndLastPoint = true;
this.toolTipGeneratorList = new ObjectList();
this.urlGenerator = null;
this.legendItemToolTipGenerator = null;
this.legendItemURLGenerator = null;
public void setPlot(PolarPlot plot) {
this.plot = plot;
public PolarPlot getPlot() {
return this.plot;
public boolean getDrawOutlineWhenFilled() {
return this.drawOutlineWhenFilled;
public void setDrawOutlineWhenFilled(boolean drawOutlineWhenFilled) {
this.drawOutlineWhenFilled = drawOutlineWhenFilled;
fireChangeEvent();
public Composite getFillComposite() {
return this.fillComposite;
public void setFillComposite(Composite composite) {
if (composite == null) {
throw new IllegalArgumentException("Null 'composite' argument.");
this.fillComposite = composite;
fireChangeEvent();
public boolean getShapesVisible() {
return this.shapesVisible;
public void setShapesVisible(boolean shapesVisible) {
this.shapesVisible = shapesVisible;
fireChangeEvent();
public boolean getConnectFirstAndLastPoint()
return connectFirstAndLastPoint;
public void setConnectFirstAndLastPoint(boolean connect)
this.connectFirstAndLastPoint = connect;
fireChangeEvent();
public DrawingSupplier getDrawingSupplier() {
DrawingSupplier result = null;
PolarPlot p = getPlot();
if (p != null) {
result = p.getDrawingSupplier();
return result;
public boolean isSeriesFilled(int series) {
boolean result = false;
Boolean b = this.seriesFilled.getBoolean(series);
if (b != null) {
result = b.booleanValue();
return result;
public void setSeriesFilled(int series, boolean filled) {
this.seriesFilled.setBoolean(series, BooleanUtilities.valueOf(filled));
public boolean getUseFillPaint() {
return this.useFillPaint;
public void setUseFillPaint(boolean flag) {
this.useFillPaint = flag;
fireChangeEvent();
public Shape getLegendLine() {
return this.legendLine;
public void setLegendLine(Shape line) {
if (line == null) {
throw new IllegalArgumentException("Null 'line' argument.");
this.legendLine = line;
fireChangeEvent();
protected void addEntity(EntityCollection entities, Shape area,
XYDataset dataset, int series, int item,
double entityX, double entityY) {
if (!getItemCreateEntity(series, item)) {
return;
Shape hotspot = area;
if (hotspot == null) {
double r = getDefaultEntityRadius();
double w = r * 2;
if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {
hotspot = new Ellipse2D.Double(entityX - r, entityY - r, w, w);
else {
hotspot = new Ellipse2D.Double(entityY - r, entityX - r, w, w);
String tip = null;
XYToolTipGenerator generator = getToolTipGenerator(series, item);
if (generator != null) {
tip = generator.generateToolTip(dataset, series, item);
String url = null;
if (getURLGenerator() != null) {
url = getURLGenerator().generateURL(dataset, series, item);
XYItemEntity entity = new XYItemEntity(hotspot, dataset, series, item,
tip, url);
entities.add(entity);
public void drawSeries(Graphics2D g2, Rectangle2D dataArea,
PlotRenderingInfo info, PolarPlot plot, XYDataset dataset,
int seriesIndex) {
GeneralPath poly = null;
ValueAxis axis = plot.getAxisForDataset(plot.indexOf(dataset));
final int numPoints = dataset.getItemCount(seriesIndex);
for (int i = 0; i < numPoints; i++) {
double theta = dataset.getXValue(seriesIndex, i);
double radius = dataset.getYValue(seriesIndex, i);
Point p = plot.translateToJava2D(theta, radius, axis, dataArea);
if (poly == null) {
poly = new GeneralPath();
poly.moveTo(p.x, p.y);
else
poly.lineTo(p.x, p.y);
if (getConnectFirstAndLastPoint())
poly.closePath();
g2.setPaint(lookupSeriesPaint(seriesIndex));
g2.setStroke(lookupSeriesStroke(seriesIndex));
if (isSeriesFilled(seriesIndex)) {
Composite savedComposite = g2.getComposite();
g2.setComposite(this.fillComposite);
g2.fill(poly);
g2.setComposite(savedComposite);
if (this.drawOutlineWhenFilled) {
g2.setPaint(lookupSeriesOutlinePaint(seriesIndex));
g2.draw(poly);
else {
g2.draw(poly);
if (this.shapesVisible) {
EntityCollection entities = null;
if (info != null) {
entities = info.getOwner().getEntityCollection();
PathIterator pi = poly.getPathIterator(null);
int i = 0;
while (!pi.isDone()) {
final float[] coords = new float[6];
final int segType = pi.currentSegment(coords);
pi.next();
if (segType != PathIterator.SEG_LINETO &&
segType != PathIterator.SEG_MOVETO)
continue;
final int x = Math.round(coords[0]);
final int y = Math.round(coords[1]);
final Shape shape = ShapeUtilities.createTranslatedShape(
getItemShape(seriesIndex, i++), x,  y);
Paint paint;
if (useFillPaint)
paint = lookupSeriesFillPaint(seriesIndex);
else
paint = lookupSeriesPaint(seriesIndex);
g2.setPaint(paint);
g2.fill(shape);
if (isSeriesFilled(seriesIndex) && drawOutlineWhenFilled) {
g2.setPaint(lookupSeriesOutlinePaint(seriesIndex));
g2.setStroke(lookupSeriesOutlineStroke(seriesIndex));
g2.draw(shape);
if (entities != null &&
AbstractXYItemRenderer.isPointInRect(dataArea, x, y)) {
addEntity(entities, shape, dataset, seriesIndex, i-1, x, y);
public void drawAngularGridLines(Graphics2D g2, PolarPlot plot,
List ticks, Rectangle2D dataArea) {
g2.setFont(plot.getAngleLabelFont());
g2.setStroke(plot.getAngleGridlineStroke());
g2.setPaint(plot.getAngleGridlinePaint());
double axisMin = plot.getAxis().getLowerBound();
double maxRadius = plot.getAxis().getUpperBound();
Point center = plot.translateValueThetaRadiusToJava2D(axisMin, axisMin,
dataArea);
Iterator iterator = ticks.iterator();
while (iterator.hasNext()) {
NumberTick tick = (NumberTick) iterator.next();
double tickVal = tick.getNumber().doubleValue();
Point p = plot.translateValueThetaRadiusToJava2D(
tickVal, maxRadius, dataArea);
g2.setPaint(plot.getAngleGridlinePaint());
g2.drawLine(center.x, center.y, p.x, p.y);
if (plot.isAngleLabelsVisible()) {
int x = p.x;
int y = p.y;
g2.setPaint(plot.getAngleLabelPaint());
TextUtilities.drawAlignedString(tick.getText(), g2, x, y,
tick.getTextAnchor());
public void drawRadialGridLines(Graphics2D g2,
PolarPlot plot,
ValueAxis radialAxis,
List ticks,
Rectangle2D dataArea) {
g2.setFont(radialAxis.getTickLabelFont());
g2.setPaint(plot.getRadiusGridlinePaint());
g2.setStroke(plot.getRadiusGridlineStroke());
double axisMin = radialAxis.getLowerBound();
Point center = plot.translateValueThetaRadiusToJava2D(axisMin, axisMin,
dataArea);
Iterator iterator = ticks.iterator();
while (iterator.hasNext()) {
NumberTick tick = (NumberTick) iterator.next();
double angleDegrees = plot.isCounterClockwise() ? plot.getAngleOffset() : -plot.getAngleOffset();
Point p = plot.translateValueThetaRadiusToJava2D(angleDegrees,
tick.getNumber().doubleValue(), dataArea);
int r = p.x - center.x;
int upperLeftX = center.x - r;
int upperLeftY = center.y - r;
int d = 2 * r;
Ellipse2D ring = new Ellipse2D.Double(upperLeftX, upperLeftY, d, d);
g2.setPaint(plot.getRadiusGridlinePaint());
g2.draw(ring);
public LegendItem getLegendItem(int series) {
LegendItem result = null;
PolarPlot plot = getPlot();
if (plot == null) {
return null;
XYDataset dataset = plot.getDataset(plot.getIndexOf(this));
if (dataset == null) {
return null;
String toolTipText = null;
if (getLegendItemToolTipGenerator() != null) {
toolTipText = getLegendItemToolTipGenerator().generateLabel(
dataset, series);
String urlText = null;
if (getLegendItemURLGenerator() != null) {
urlText = getLegendItemURLGenerator().generateLabel(dataset,
series);
String label = dataset.getSeriesKey(series).toString();
String description = label;
Shape shape = lookupSeriesShape(series);
Paint paint;
if (useFillPaint)
paint = lookupSeriesFillPaint(series);
else
paint = lookupSeriesPaint(series);
Stroke stroke = lookupSeriesStroke(series);
Paint outlinePaint = lookupSeriesOutlinePaint(series);
Stroke outlineStroke = lookupSeriesOutlineStroke(series);
boolean shapeOutlined = isSeriesFilled(series)
&& this.drawOutlineWhenFilled;
result = new LegendItem(label, description, toolTipText, urlText,
getShapesVisible(), shape, /* shapeFilled=*/ true, paint,
shapeOutlined, outlinePaint, outlineStroke, 
result.setToolTipText(toolTipText);
result.setURLText(urlText);
result.setDataset(dataset);
return result;
public XYToolTipGenerator getToolTipGenerator(int series, int item)
XYToolTipGenerator generator
= (XYToolTipGenerator) this.toolTipGeneratorList.get(series);
if (generator == null) {
generator = this.baseToolTipGenerator;
return generator;
public XYToolTipGenerator getSeriesToolTipGenerator(int series)
return (XYToolTipGenerator) this.toolTipGeneratorList.get(series);
public void setSeriesToolTipGenerator(int series,
XYToolTipGenerator generator)
this.toolTipGeneratorList.set(series, generator);
fireChangeEvent();
public XYToolTipGenerator getBaseToolTipGenerator()
return this.baseToolTipGenerator;
public void setBaseToolTipGenerator(XYToolTipGenerator generator)
this.baseToolTipGenerator = generator;
fireChangeEvent();
public XYURLGenerator getURLGenerator()
return this.urlGenerator;
public void setURLGenerator(XYURLGenerator urlGenerator)
this.urlGenerator = urlGenerator;
fireChangeEvent();
public XYSeriesLabelGenerator getLegendItemToolTipGenerator() {
return this.legendItemToolTipGenerator;
public void setLegendItemToolTipGenerator(
XYSeriesLabelGenerator generator) {
this.legendItemToolTipGenerator = generator;
fireChangeEvent();
public XYSeriesLabelGenerator getLegendItemURLGenerator() {
return this.legendItemURLGenerator;
public void setLegendItemURLGenerator(XYSeriesLabelGenerator generator) {
this.legendItemURLGenerator = generator;
fireChangeEvent();
public boolean equals(Object obj) {
if (obj == null) {
return false;
if (!(obj instanceof DefaultPolarItemRenderer)) {
return false;
DefaultPolarItemRenderer that = (DefaultPolarItemRenderer) obj;
if (!this.seriesFilled.equals(that.seriesFilled)) {
return false;
if (this.drawOutlineWhenFilled != that.drawOutlineWhenFilled) {
return false;
if (!ObjectUtilities.equal(this.fillComposite, that.fillComposite)) {
return false;
if (this.useFillPaint != that.useFillPaint) {
return false;
if (!ShapeUtilities.equal(this.legendLine, that.legendLine)) {
return false;
if (this.shapesVisible != that.shapesVisible) {
return false;
if (this.connectFirstAndLastPoint != that.connectFirstAndLastPoint) {
return false;
if (!this.toolTipGeneratorList.equals(that.toolTipGeneratorList)) {
return false;
if (!ObjectUtilities.equal(this.baseToolTipGenerator,
that.baseToolTipGenerator)) {
return false;
if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
return false;
if (!ObjectUtilities.equal(this.legendItemToolTipGenerator,
that.legendItemToolTipGenerator)) {
return false;
if (!ObjectUtilities.equal(this.legendItemURLGenerator,
that.legendItemURLGenerator)) {
return false;
return super.equals(obj);
public Object clone() throws CloneNotSupportedException {
DefaultPolarItemRenderer clone
= (DefaultPolarItemRenderer) super.clone();
if (this.legendLine != null) {
clone.legendLine = ShapeUtilities.clone(this.legendLine);
clone.seriesFilled = (BooleanList) this.seriesFilled.clone();
clone.toolTipGeneratorList
= (ObjectList) this.toolTipGeneratorList.clone();
if (clone.baseToolTipGenerator instanceof PublicCloneable) {
clone.baseToolTipGenerator = (XYToolTipGenerator)
ObjectUtilities.clone(this.baseToolTipGenerator);
if (clone.urlGenerator instanceof PublicCloneable) {
clone.urlGenerator = (XYURLGenerator)
ObjectUtilities.clone(this.urlGenerator);
if (clone.legendItemToolTipGenerator instanceof PublicCloneable) {
clone.legendItemToolTipGenerator = (XYSeriesLabelGenerator)
ObjectUtilities.clone(this.legendItemToolTipGenerator);
if (clone.legendItemURLGenerator instanceof PublicCloneable) {
clone.legendItemURLGenerator = (XYSeriesLabelGenerator)
ObjectUtilities.clone(this.legendItemURLGenerator);
return clone;
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.legendLine = SerialUtilities.readShape(stream);
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writeShape(this.legendLine, stream);package org.jfree.chart.renderer.category;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.renderer.Outlier;
import org.jfree.chart.renderer.OutlierList;
import org.jfree.chart.renderer.OutlierListCollection;
import org.jfree.data.Range;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.ui.RectangleEdge;
import org.jfree.util.PaintUtilities;
import org.jfree.util.PublicCloneable;
public class BoxAndWhiskerRenderer extends AbstractCategoryItemRenderer
implements Cloneable, PublicCloneable, Serializable {
private static final long serialVersionUID = 632027470694481177L;
private transient Paint artifactPaint;
private boolean fillBox;
private double itemMargin;
private double maximumBarWidth;
private boolean medianVisible;
private boolean meanVisible;
private boolean useOutlinePaintForWhiskers;
private double whiskerWidth;
public BoxAndWhiskerRenderer() {
this.artifactPaint = Color.black;
this.fillBox = true;
this.itemMargin = 0.20;
this.maximumBarWidth = 1.0;
this.medianVisible = true;
this.meanVisible = true;
this.useOutlinePaintForWhiskers = false;
this.whiskerWidth = 1.0;
setBaseLegendShape(new Rectangle2D.Double(-4.0, -4.0, 8.0, 8.0));
public Paint getArtifactPaint() {
return this.artifactPaint;
public void setArtifactPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.artifactPaint = paint;
fireChangeEvent();
public boolean getFillBox() {
return this.fillBox;
public void setFillBox(boolean flag) {
this.fillBox = flag;
fireChangeEvent();
public double getItemMargin() {
return this.itemMargin;
public void setItemMargin(double margin) {
this.itemMargin = margin;
fireChangeEvent();
public double getMaximumBarWidth() {
return this.maximumBarWidth;
public void setMaximumBarWidth(double percent) {
this.maximumBarWidth = percent;
fireChangeEvent();
public boolean isMeanVisible() {
return this.meanVisible;
public void setMeanVisible(boolean visible) {
if (this.meanVisible == visible) {
return;
this.meanVisible = visible;
fireChangeEvent();
public boolean isMedianVisible() {
return this.medianVisible;
public void setMedianVisible(boolean visible) {
if (this.medianVisible == visible) {
return;
this.medianVisible = visible;
fireChangeEvent();
public boolean getUseOutlinePaintForWhiskers() {
return useOutlinePaintForWhiskers;
public void setUseOutlinePaintForWhiskers(boolean flag) {
if (this.useOutlinePaintForWhiskers == flag) {
return;
this.useOutlinePaintForWhiskers = flag;
fireChangeEvent();
public double getWhiskerWidth() {
return this.whiskerWidth;
public void setWhiskerWidth(double width) {
if (width < 0 || width > 1) {
throw new IllegalArgumentException(
"Value for whisker width out of range");
if (width == this.whiskerWidth) {
return;
this.whiskerWidth = width;
fireChangeEvent();
public LegendItem getLegendItem(int datasetIndex, int series) {
CategoryPlot cp = getPlot();
if (cp == null) {
return null;
if (!isSeriesVisible(series) || !isSeriesVisibleInLegend(series)) {
return null;
CategoryDataset dataset = cp.getDataset(datasetIndex);
String label = getLegendItemLabelGenerator().generateLabel(dataset,
series);
String description = label;
String toolTipText = null;
if (getLegendItemToolTipGenerator() != null) {
toolTipText = getLegendItemToolTipGenerator().generateLabel(
dataset, series);
String urlText = null;
if (getLegendItemURLGenerator() != null) {
urlText = getLegendItemURLGenerator().generateLabel(dataset,
series);
Shape shape = lookupLegendShape(series);
Paint paint = lookupSeriesPaint(series);
Paint outlinePaint = lookupSeriesOutlinePaint(series);
Stroke outlineStroke = lookupSeriesOutlineStroke(series);
LegendItem result = new LegendItem(label, description, toolTipText,
urlText, shape, paint, outlineStroke, outlinePaint);
result.setLabelFont(lookupLegendTextFont(series));
Paint labelPaint = lookupLegendTextPaint(series);
if (labelPaint != null) {
result.setLabelPaint(labelPaint);
result.setDataset(dataset);
result.setDatasetIndex(datasetIndex);
result.setSeriesKey(dataset.getRowKey(series));
result.setSeriesIndex(series);
return result;
public Range findRangeBounds(CategoryDataset dataset) {
return super.findRangeBounds(dataset, true);
public CategoryItemRendererState initialise(Graphics2D g2,
Rectangle2D dataArea,
CategoryPlot plot,
int rendererIndex,
PlotRenderingInfo info) {
CategoryItemRendererState state = super.initialise(g2, dataArea, plot,
rendererIndex, info);
CategoryAxis domainAxis = getDomainAxis(plot, rendererIndex);
CategoryDataset dataset = plot.getDataset(rendererIndex);
if (dataset != null) {
int columns = dataset.getColumnCount();
int rows = dataset.getRowCount();
double space = 0.0;
PlotOrientation orientation = plot.getOrientation();
if (orientation == PlotOrientation.HORIZONTAL) {
space = dataArea.getHeight();
else if (orientation == PlotOrientation.VERTICAL) {
space = dataArea.getWidth();
double maxWidth = space * getMaximumBarWidth();
double categoryMargin = 0.0;
double currentItemMargin = 0.0;
if (columns > 1) {
categoryMargin = domainAxis.getCategoryMargin();
if (rows > 1) {
currentItemMargin = getItemMargin();
double used = space * (1 - domainAxis.getLowerMargin()
- domainAxis.getUpperMargin()
- categoryMargin - currentItemMargin);
if ((rows * columns) > 0) {
state.setBarWidth(Math.min(used / (dataset.getColumnCount()
else {
state.setBarWidth(Math.min(used, maxWidth));
return state;
public void drawItem(Graphics2D g2, CategoryItemRendererState state,
Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,
ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,
int pass) {
if (!getItemVisible(row, column)) {
return;
if (!(dataset instanceof BoxAndWhiskerCategoryDataset)) {
throw new IllegalArgumentException(
"BoxAndWhiskerRenderer.drawItem() : the data should be "
+ "of type BoxAndWhiskerCategoryDataset only.");
PlotOrientation orientation = plot.getOrientation();
if (orientation == PlotOrientation.HORIZONTAL) {
drawHorizontalItem(g2, state, dataArea, plot, domainAxis,
rangeAxis, dataset, row, column);
else if (orientation == PlotOrientation.VERTICAL) {
drawVerticalItem(g2, state, dataArea, plot, domainAxis,
rangeAxis, dataset, row, column);
public void drawHorizontalItem(Graphics2D g2, 
CategoryItemRendererState state, Rectangle2D dataArea,
CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,
CategoryDataset dataset, int row, int column) {
BoxAndWhiskerCategoryDataset bawDataset
= (BoxAndWhiskerCategoryDataset) dataset;
double categoryEnd = domainAxis.getCategoryEnd(column,
getColumnCount(), dataArea, plot.getDomainAxisEdge());
double categoryStart = domainAxis.getCategoryStart(column,
getColumnCount(), dataArea, plot.getDomainAxisEdge());
double categoryWidth = Math.abs(categoryEnd - categoryStart);
double yy = categoryStart;
int seriesCount = getRowCount();
int categoryCount = getColumnCount();
if (seriesCount > 1) {
double seriesGap = dataArea.getHeight() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
double usedWidth = (state.getBarWidth() * seriesCount)
+ (seriesGap * (seriesCount - 1));
double offset = (categoryWidth - usedWidth) / 2;
yy = yy + offset + (row * (state.getBarWidth() + seriesGap));
else {
double offset = (categoryWidth - state.getBarWidth()) / 2;
yy = yy + offset;
g2.setPaint(getItemPaint(row, column));
Stroke s = getItemStroke(row, column);
g2.setStroke(s);
RectangleEdge location = plot.getRangeAxisEdge();
Number xQ1 = bawDataset.getQ1Value(row, column);
Number xQ3 = bawDataset.getQ3Value(row, column);
Number xMax = bawDataset.getMaxRegularValue(row, column);
Number xMin = bawDataset.getMinRegularValue(row, column);
Shape box = null;
if (xQ1 != null && xQ3 != null && xMax != null && xMin != null) {
double xxQ1 = rangeAxis.valueToJava2D(xQ1.doubleValue(), dataArea,
location);
double xxQ3 = rangeAxis.valueToJava2D(xQ3.doubleValue(), dataArea,
location);
double xxMax = rangeAxis.valueToJava2D(xMax.doubleValue(), dataArea,
location);
double xxMin = rangeAxis.valueToJava2D(xMin.doubleValue(), dataArea,
location);
double yymid = yy + state.getBarWidth() / 2.0;
double halfW = (state.getBarWidth() / 2.0) * this.whiskerWidth;
box = new Rectangle2D.Double(Math.min(xxQ1, xxQ3), yy,
Math.abs(xxQ1 - xxQ3), state.getBarWidth());
if (this.fillBox) {
g2.fill(box);
Paint outlinePaint = getItemOutlinePaint(row, column);
if (this.useOutlinePaintForWhiskers) {
g2.setPaint(outlinePaint);
g2.draw(new Line2D.Double(xxMax, yymid, xxQ3, yymid));
g2.draw(new Line2D.Double(xxMax, yymid - halfW, xxMax,
yymid + halfW));
g2.draw(new Line2D.Double(xxMin, yymid, xxQ1, yymid));
g2.draw(new Line2D.Double(xxMin, yymid - halfW, xxMin,
yy + halfW));
g2.setStroke(getItemOutlineStroke(row, column));
g2.setPaint(outlinePaint);
g2.draw(box);
g2.setPaint(this.artifactPaint);
double aRadius = 0;                 // average radius
if (this.meanVisible) {
Number xMean = bawDataset.getMeanValue(row, column);
if (xMean != null) {
double xxMean = rangeAxis.valueToJava2D(xMean.doubleValue(),
dataArea, location);
aRadius = state.getBarWidth() / 4;
if ((xxMean > (dataArea.getMinX() - aRadius))
&& (xxMean < (dataArea.getMaxX() + aRadius))) {
Ellipse2D.Double avgEllipse = new Ellipse2D.Double(xxMean
- aRadius, yy + aRadius, aRadius * 2, aRadius * 2);
g2.fill(avgEllipse);
g2.draw(avgEllipse);
if (this.medianVisible) {
Number xMedian = bawDataset.getMedianValue(row, column);
if (xMedian != null) {
double xxMedian = rangeAxis.valueToJava2D(xMedian.doubleValue(),
dataArea, location);
g2.draw(new Line2D.Double(xxMedian, yy, xxMedian,
yy + state.getBarWidth()));
if (state.getInfo() != null && box != null) {
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
addItemEntity(entities, dataset, row, column, box);
public void drawVerticalItem(Graphics2D g2, CategoryItemRendererState state,
Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,
ValueAxis rangeAxis, CategoryDataset dataset, int row, int column) {
BoxAndWhiskerCategoryDataset bawDataset
= (BoxAndWhiskerCategoryDataset) dataset;
double categoryEnd = domainAxis.getCategoryEnd(column,
getColumnCount(), dataArea, plot.getDomainAxisEdge());
double categoryStart = domainAxis.getCategoryStart(column,
getColumnCount(), dataArea, plot.getDomainAxisEdge());
double categoryWidth = categoryEnd - categoryStart;
double xx = categoryStart;
int seriesCount = getRowCount();
int categoryCount = getColumnCount();
if (seriesCount > 1) {
double seriesGap = dataArea.getWidth() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
double usedWidth = (state.getBarWidth() * seriesCount)
+ (seriesGap * (seriesCount - 1));
double offset = (categoryWidth - usedWidth) / 2;
xx = xx + offset + (row * (state.getBarWidth() + seriesGap));
else {
double offset = (categoryWidth - state.getBarWidth()) / 2;
xx = xx + offset;
double yyAverage = 0.0;
double yyOutlier;
Paint itemPaint = getItemPaint(row, column);
g2.setPaint(itemPaint);
Stroke s = getItemStroke(row, column);
g2.setStroke(s);
double aRadius = 0;                 // average radius
RectangleEdge location = plot.getRangeAxisEdge();
Number yQ1 = bawDataset.getQ1Value(row, column);
Number yQ3 = bawDataset.getQ3Value(row, column);
Number yMax = bawDataset.getMaxRegularValue(row, column);
Number yMin = bawDataset.getMinRegularValue(row, column);
Shape box = null;
if (yQ1 != null && yQ3 != null && yMax != null && yMin != null) {
double yyQ1 = rangeAxis.valueToJava2D(yQ1.doubleValue(), dataArea,
location);
double yyQ3 = rangeAxis.valueToJava2D(yQ3.doubleValue(), dataArea,
location);
double yyMax = rangeAxis.valueToJava2D(yMax.doubleValue(),
dataArea, location);
double yyMin = rangeAxis.valueToJava2D(yMin.doubleValue(),
dataArea, location);
double xxmid = xx + state.getBarWidth() / 2.0;
double halfW = (state.getBarWidth() / 2.0) * this.whiskerWidth;
box = new Rectangle2D.Double(xx, Math.min(yyQ1, yyQ3),
state.getBarWidth(), Math.abs(yyQ1 - yyQ3));
if (this.fillBox) {
g2.fill(box);
Paint outlinePaint = getItemOutlinePaint(row, column);
if (this.useOutlinePaintForWhiskers) {
g2.setPaint(outlinePaint);
g2.draw(new Line2D.Double(xxmid, yyMax, xxmid, yyQ3));
g2.draw(new Line2D.Double(xx - halfW, yyMax, xx + halfW, yyMax));
g2.draw(new Line2D.Double(xxmid, yyMin, xxmid, yyQ1));
g2.draw(new Line2D.Double(xx - halfW, yyMin, xx + halfW, yyMin));
g2.setStroke(getItemOutlineStroke(row, column));
g2.setPaint(outlinePaint);
g2.draw(box);
g2.setPaint(this.artifactPaint);
if (this.meanVisible) {
Number yMean = bawDataset.getMeanValue(row, column);
if (yMean != null) {
yyAverage = rangeAxis.valueToJava2D(yMean.doubleValue(),
dataArea, location);
aRadius = state.getBarWidth() / 4;
if ((yyAverage > (dataArea.getMinY() - aRadius))
&& (yyAverage < (dataArea.getMaxY() + aRadius))) {
Ellipse2D.Double avgEllipse = new Ellipse2D.Double(
xx + aRadius, yyAverage - aRadius, aRadius * 2,
aRadius * 2);
g2.fill(avgEllipse);
g2.draw(avgEllipse);
if (this.medianVisible) {
Number yMedian = bawDataset.getMedianValue(row, column);
if (yMedian != null) {
double yyMedian = rangeAxis.valueToJava2D(
yMedian.doubleValue(), dataArea, location);
g2.draw(new Line2D.Double(xx, yyMedian, 
xx + state.getBarWidth(), yyMedian));
double maxAxisValue = rangeAxis.valueToJava2D(
rangeAxis.getUpperBound(), dataArea, location) + aRadius;
double minAxisValue = rangeAxis.valueToJava2D(
rangeAxis.getLowerBound(), dataArea, location) - aRadius;
g2.setPaint(itemPaint);
double oRadius = state.getBarWidth() / 3;    // outlier radius
List outliers = new ArrayList();
OutlierListCollection outlierListCollection
= new OutlierListCollection();
List yOutliers = bawDataset.getOutliers(row, column);
if (yOutliers != null) {
for (int i = 0; i < yOutliers.size(); i++) {
double outlier = ((Number) yOutliers.get(i)).doubleValue();
Number minOutlier = bawDataset.getMinOutlier(row, column);
Number maxOutlier = bawDataset.getMaxOutlier(row, column);
Number minRegular = bawDataset.getMinRegularValue(row, column);
Number maxRegular = bawDataset.getMaxRegularValue(row, column);
if (outlier > maxOutlier.doubleValue()) {
outlierListCollection.setHighFarOut(true);
else if (outlier < minOutlier.doubleValue()) {
outlierListCollection.setLowFarOut(true);
else if (outlier > maxRegular.doubleValue()) {
yyOutlier = rangeAxis.valueToJava2D(outlier, dataArea,
location);
outliers.add(new Outlier(xx + state.getBarWidth() / 2.0,
yyOutlier, oRadius));
else if (outlier < minRegular.doubleValue()) {
yyOutlier = rangeAxis.valueToJava2D(outlier, dataArea,
location);
outliers.add(new Outlier(xx + state.getBarWidth() / 2.0,
yyOutlier, oRadius));
Collections.sort(outliers);
for (Iterator iterator = outliers.iterator(); iterator.hasNext();) {
Outlier outlier = (Outlier) iterator.next();
outlierListCollection.add(outlier);
for (Iterator iterator = outlierListCollection.iterator();
iterator.hasNext();) {
OutlierList list = (OutlierList) iterator.next();
Outlier outlier = list.getAveragedOutlier();
Point2D point = outlier.getPoint();
if (list.isMultiple()) {
drawMultipleEllipse(point, state.getBarWidth(), oRadius,
g2);
else {
drawEllipse(point, oRadius, g2);
if (outlierListCollection.isHighFarOut()) {
drawHighFarOut(aRadius / 2.0, g2,
xx + state.getBarWidth() / 2.0, maxAxisValue);
if (outlierListCollection.isLowFarOut()) {
drawLowFarOut(aRadius / 2.0, g2,
xx + state.getBarWidth() / 2.0, minAxisValue);
if (state.getInfo() != null && box != null) {
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
addItemEntity(entities, dataset, row, column, box);
private void drawEllipse(Point2D point, double oRadius, Graphics2D g2) {
Ellipse2D dot = new Ellipse2D.Double(point.getX() + oRadius / 2,
point.getY(), oRadius, oRadius);
g2.draw(dot);
private void drawMultipleEllipse(Point2D point, double boxWidth,
double oRadius, Graphics2D g2)  {
Ellipse2D dot1 = new Ellipse2D.Double(point.getX() - (boxWidth / 2)
+ oRadius, point.getY(), oRadius, oRadius);
Ellipse2D dot2 = new Ellipse2D.Double(point.getX() + (boxWidth / 2),
point.getY(), oRadius, oRadius);
g2.draw(dot1);
g2.draw(dot2);
private void drawHighFarOut(double aRadius, Graphics2D g2, double xx,
double m) {
double side = aRadius * 2;
g2.draw(new Line2D.Double(xx - side, m + side, xx + side, m + side));
g2.draw(new Line2D.Double(xx - side, m + side, xx, m));
g2.draw(new Line2D.Double(xx + side, m + side, xx, m));
private void drawLowFarOut(double aRadius, Graphics2D g2, double xx,
double m) {
double side = aRadius * 2;
g2.draw(new Line2D.Double(xx - side, m - side, xx + side, m - side));
g2.draw(new Line2D.Double(xx - side, m - side, xx, m));
g2.draw(new Line2D.Double(xx + side, m - side, xx, m));
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof BoxAndWhiskerRenderer)) {
return false;
BoxAndWhiskerRenderer that = (BoxAndWhiskerRenderer) obj;
if (this.fillBox != that.fillBox) {
return false;
if (this.itemMargin != that.itemMargin) {
return false;
if (this.maximumBarWidth != that.maximumBarWidth) {
return false;
if (this.meanVisible != that.meanVisible) {
return false;
if (this.medianVisible != that.medianVisible) {
return false;
if (this.useOutlinePaintForWhiskers
!= that.useOutlinePaintForWhiskers) {
return false;
if (this.whiskerWidth != that.whiskerWidth) {
return false;
if (!PaintUtilities.equal(this.artifactPaint, that.artifactPaint)) {
return false;
return super.equals(obj);
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writePaint(this.artifactPaint, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.artifactPaint = SerialUtilities.readPaint(stream);else {
if (Double.isNaN(b)) {
return a;
else {
return Math.min(a, b);
else {
if (Double.isNaN(b)) {
return a;
else {
return Math.max(a, b);
else {
updateByIndex(index, y);import org.jfree.chart.util.DefaultShadowGenerator;package org.jfree.chart.plot;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.ResourceBundle;
import org.jfree.chart.axis.AxisSpace;
import org.jfree.chart.axis.AxisState;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.axis.ValueTick;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.util.ResourceBundleWrapper;
import org.jfree.data.Range;
import org.jfree.io.SerialUtilities;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.util.ArrayUtilities;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PaintUtilities;
public class FastScatterPlot extends Plot implements ValueAxisPlot, Pannable,
Zoomable, Cloneable, Serializable {
private static final long serialVersionUID = 7871545897358563521L;
public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,
BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[]
public static final Paint DEFAULT_GRIDLINE_PAINT = Color.lightGray;
private float[][] data;
private Range xDataRange;
private Range yDataRange;
private ValueAxis domainAxis;
private ValueAxis rangeAxis;
private transient Paint paint;
private boolean domainGridlinesVisible;
private transient Stroke domainGridlineStroke;
private transient Paint domainGridlinePaint;
private boolean rangeGridlinesVisible;
private transient Stroke rangeGridlineStroke;
private transient Paint rangeGridlinePaint;
private boolean domainPannable;
private boolean rangePannable;
protected static ResourceBundle localizationResources
= ResourceBundleWrapper.getBundle(
"org.jfree.chart.plot.LocalizationBundle");
public FastScatterPlot() {
this(null, new NumberAxis("X"), new NumberAxis("Y"));
public FastScatterPlot(float[][] data,
ValueAxis domainAxis, ValueAxis rangeAxis) {
super();
if (domainAxis == null) {
throw new IllegalArgumentException("Null 'domainAxis' argument.");
if (rangeAxis == null) {
throw new IllegalArgumentException("Null 'rangeAxis' argument.");
this.data = data;
this.xDataRange = calculateXDataRange(data);
this.yDataRange = calculateYDataRange(data);
this.domainAxis = domainAxis;
this.domainAxis.setPlot(this);
this.domainAxis.addChangeListener(this);
this.rangeAxis = rangeAxis;
this.rangeAxis.setPlot(this);
this.rangeAxis.addChangeListener(this);
this.paint = Color.red;
this.domainGridlinesVisible = true;
this.domainGridlinePaint = FastScatterPlot.DEFAULT_GRIDLINE_PAINT;
this.domainGridlineStroke = FastScatterPlot.DEFAULT_GRIDLINE_STROKE;
this.rangeGridlinesVisible = true;
this.rangeGridlinePaint = FastScatterPlot.DEFAULT_GRIDLINE_PAINT;
this.rangeGridlineStroke = FastScatterPlot.DEFAULT_GRIDLINE_STROKE;
public String getPlotType() {
return localizationResources.getString("Fast_Scatter_Plot");
public float[][] getData() {
return this.data;
public void setData(float[][] data) {
this.data = data;
fireChangeEvent();
public PlotOrientation getOrientation() {
return PlotOrientation.VERTICAL;
public ValueAxis getDomainAxis() {
return this.domainAxis;
public void setDomainAxis(ValueAxis axis) {
if (axis == null) {
throw new IllegalArgumentException("Null 'axis' argument.");
this.domainAxis = axis;
fireChangeEvent();
public ValueAxis getRangeAxis() {
return this.rangeAxis;
public void setRangeAxis(ValueAxis axis) {
if (axis == null) {
throw new IllegalArgumentException("Null 'axis' argument.");
this.rangeAxis = axis;
fireChangeEvent();
public Paint getPaint() {
return this.paint;
public void setPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.paint = paint;
fireChangeEvent();
public boolean isDomainGridlinesVisible() {
return this.domainGridlinesVisible;
public void setDomainGridlinesVisible(boolean visible) {
if (this.domainGridlinesVisible != visible) {
this.domainGridlinesVisible = visible;
fireChangeEvent();
public Stroke getDomainGridlineStroke() {
return this.domainGridlineStroke;
public void setDomainGridlineStroke(Stroke stroke) {
if (stroke == null) {
throw new IllegalArgumentException("Null 'stroke' argument.");
this.domainGridlineStroke = stroke;
fireChangeEvent();
public Paint getDomainGridlinePaint() {
return this.domainGridlinePaint;
public void setDomainGridlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.domainGridlinePaint = paint;
fireChangeEvent();
public boolean isRangeGridlinesVisible() {
return this.rangeGridlinesVisible;
public void setRangeGridlinesVisible(boolean visible) {
if (this.rangeGridlinesVisible != visible) {
this.rangeGridlinesVisible = visible;
fireChangeEvent();
public Stroke getRangeGridlineStroke() {
return this.rangeGridlineStroke;
public void setRangeGridlineStroke(Stroke stroke) {
if (stroke == null) {
throw new IllegalArgumentException("Null 'stroke' argument.");
this.rangeGridlineStroke = stroke;
fireChangeEvent();
public Paint getRangeGridlinePaint() {
return this.rangeGridlinePaint;
public void setRangeGridlinePaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.rangeGridlinePaint = paint;
fireChangeEvent();
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
PlotState parentState,
PlotRenderingInfo info) {
if (info != null) {
info.setPlotArea(area);
RectangleInsets insets = getInsets();
insets.trim(area);
AxisSpace space = new AxisSpace();
space = this.domainAxis.reserveSpace(g2, this, area,
RectangleEdge.BOTTOM, space);
space = this.rangeAxis.reserveSpace(g2, this, area, RectangleEdge.LEFT,
space);
Rectangle2D dataArea = space.shrink(area, null);
if (info != null) {
info.setDataArea(dataArea);
drawBackground(g2, dataArea);
AxisState domainAxisState = this.domainAxis.draw(g2,
dataArea.getMaxY(), area, dataArea, RectangleEdge.BOTTOM, info);
AxisState rangeAxisState = this.rangeAxis.draw(g2, dataArea.getMinX(),
area, dataArea, RectangleEdge.LEFT, info);
drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());
drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());
Shape originalClip = g2.getClip();
Composite originalComposite = g2.getComposite();
g2.clip(dataArea);
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
getForegroundAlpha()));
render(g2, dataArea, info, null);
g2.setClip(originalClip);
g2.setComposite(originalComposite);
drawOutline(g2, dataArea);
public void render(Graphics2D g2, Rectangle2D dataArea,
PlotRenderingInfo info, CrosshairState crosshairState) {
g2.setPaint(this.paint);
if (this.data != null) {
for (int i = 0; i < this.data[0].length; i++) {
float x = this.data[0][i];
float y = this.data[1][i];
int transX = (int) this.domainAxis.valueToJava2D(x, dataArea,
RectangleEdge.BOTTOM);
int transY = (int) this.rangeAxis.valueToJava2D(y, dataArea,
RectangleEdge.LEFT);
g2.fillRect(transX, transY, 1, 1);
protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,
List ticks) {
if (isDomainGridlinesVisible()) {
Iterator iterator = ticks.iterator();
while (iterator.hasNext()) {
ValueTick tick = (ValueTick) iterator.next();
double v = this.domainAxis.valueToJava2D(tick.getValue(),
dataArea, RectangleEdge.BOTTOM);
Line2D line = new Line2D.Double(v, dataArea.getMinY(), v,
dataArea.getMaxY());
g2.setPaint(getDomainGridlinePaint());
g2.setStroke(getDomainGridlineStroke());
g2.draw(line);
protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,
List ticks) {
if (isRangeGridlinesVisible()) {
Iterator iterator = ticks.iterator();
while (iterator.hasNext()) {
ValueTick tick = (ValueTick) iterator.next();
double v = this.rangeAxis.valueToJava2D(tick.getValue(),
dataArea, RectangleEdge.LEFT);
Line2D line = new Line2D.Double(dataArea.getMinX(), v,
dataArea.getMaxX(), v);
g2.setPaint(getRangeGridlinePaint());
g2.setStroke(getRangeGridlineStroke());
g2.draw(line);
public Range getDataRange(ValueAxis axis) {
Range result = null;
if (axis == this.domainAxis) {
result = this.xDataRange;
else if (axis == this.rangeAxis) {
result = this.yDataRange;
return result;
private Range calculateXDataRange(float[][] data) {
Range result = null;
if (data != null) {
float lowest = Float.POSITIVE_INFINITY;
float highest = Float.NEGATIVE_INFINITY;
for (int i = 0; i < data[0].length; i++) {
float v = data[0][i];
if (v < lowest) {
lowest = v;
if (v > highest) {
highest = v;
if (lowest <= highest) {
result = new Range(lowest, highest);
return result;
private Range calculateYDataRange(float[][] data) {
Range result = null;
if (data != null) {
float lowest = Float.POSITIVE_INFINITY;
float highest = Float.NEGATIVE_INFINITY;
for (int i = 0; i < data[0].length; i++) {
float v = data[1][i];
if (v < lowest) {
lowest = v;
if (v > highest) {
highest = v;
if (lowest <= highest) {
result = new Range(lowest, highest);
return result;
public void zoomDomainAxes(double factor, PlotRenderingInfo info,
Point2D source) {
this.domainAxis.resizeRange(factor);
public void zoomDomainAxes(double factor, PlotRenderingInfo info,
Point2D source, boolean useAnchor) {
if (useAnchor) {
double sourceX = source.getX();
double anchorX = this.domainAxis.java2DToValue(sourceX,
info.getDataArea(), RectangleEdge.BOTTOM);
this.domainAxis.resizeRange2(factor, anchorX);
else {
this.domainAxis.resizeRange(factor);
public void zoomDomainAxes(double lowerPercent, double upperPercent,
PlotRenderingInfo info, Point2D source) {
this.domainAxis.zoomRange(lowerPercent, upperPercent);
public void zoomRangeAxes(double factor,
PlotRenderingInfo info, Point2D source) {
this.rangeAxis.resizeRange(factor);
public void zoomRangeAxes(double factor, PlotRenderingInfo info,
Point2D source, boolean useAnchor) {
if (useAnchor) {
double sourceY = source.getY();
double anchorY = this.rangeAxis.java2DToValue(sourceY,
info.getDataArea(), RectangleEdge.LEFT);
this.rangeAxis.resizeRange2(factor, anchorY);
else {
this.rangeAxis.resizeRange(factor);
public void zoomRangeAxes(double lowerPercent, double upperPercent,
PlotRenderingInfo info, Point2D source) {
this.rangeAxis.zoomRange(lowerPercent, upperPercent);
public boolean isDomainZoomable() {
return true;
public boolean isRangeZoomable() {
return true;
public boolean isDomainPannable() {
return this.domainPannable;
public void setDomainPannable(boolean pannable) {
this.domainPannable = pannable;
public boolean isRangePannable() {
return this.rangePannable;
public void setRangePannable(boolean pannable) {
this.rangePannable = pannable;
public void panDomainAxes(double percent, PlotRenderingInfo info,
Point2D source) {
if (!isDomainPannable() || this.domainAxis == null) {
return;
double length = this.domainAxis.getRange().getLength();
double adj = -percent * length;
if (this.domainAxis.isInverted()) {
adj = -adj;
this.domainAxis.setRange(this.domainAxis.getLowerBound() + adj,
this.domainAxis.getUpperBound() + adj);
public void panRangeAxes(double percent, PlotRenderingInfo info,
Point2D source) {
if (!isRangePannable() || this.rangeAxis == null) {
return;
double length = this.rangeAxis.getRange().getLength();
double adj = percent * length;
if (this.rangeAxis.isInverted()) {
adj = -adj;
this.rangeAxis.setRange(this.rangeAxis.getLowerBound() + adj,
this.rangeAxis.getUpperBound() + adj);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!super.equals(obj)) {
return false;
if (!(obj instanceof FastScatterPlot)) {
return false;
FastScatterPlot that = (FastScatterPlot) obj;
if (this.domainPannable != that.domainPannable) {
return false;
if (this.rangePannable != that.rangePannable) {
return false;
if (!ArrayUtilities.equal(this.data, that.data)) {
return false;
if (!ObjectUtilities.equal(this.domainAxis, that.domainAxis)) {
return false;
if (!ObjectUtilities.equal(this.rangeAxis, that.rangeAxis)) {
return false;
if (!PaintUtilities.equal(this.paint, that.paint)) {
return false;
if (this.domainGridlinesVisible != that.domainGridlinesVisible) {
return false;
if (!PaintUtilities.equal(this.domainGridlinePaint,
that.domainGridlinePaint)) {
return false;
if (!ObjectUtilities.equal(this.domainGridlineStroke,
that.domainGridlineStroke)) {
return false;
if (!this.rangeGridlinesVisible == that.rangeGridlinesVisible) {
return false;
if (!PaintUtilities.equal(this.rangeGridlinePaint,
that.rangeGridlinePaint)) {
return false;
if (!ObjectUtilities.equal(this.rangeGridlineStroke,
that.rangeGridlineStroke)) {
return false;
return true;
public Object clone() throws CloneNotSupportedException {
FastScatterPlot clone = (FastScatterPlot) super.clone();
if (this.data != null) {
clone.data = ArrayUtilities.clone(this.data);
if (this.domainAxis != null) {
clone.domainAxis = (ValueAxis) this.domainAxis.clone();
clone.domainAxis.setPlot(clone);
clone.domainAxis.addChangeListener(clone);
if (this.rangeAxis != null) {
clone.rangeAxis = (ValueAxis) this.rangeAxis.clone();
clone.rangeAxis.setPlot(clone);
clone.rangeAxis.addChangeListener(clone);
return clone;
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writePaint(this.paint, stream);
SerialUtilities.writeStroke(this.domainGridlineStroke, stream);
SerialUtilities.writePaint(this.domainGridlinePaint, stream);
SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);
SerialUtilities.writePaint(this.rangeGridlinePaint, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.paint = SerialUtilities.readPaint(stream);
this.domainGridlineStroke = SerialUtilities.readStroke(stream);
this.domainGridlinePaint = SerialUtilities.readPaint(stream);
this.rangeGridlineStroke = SerialUtilities.readStroke(stream);
this.rangeGridlinePaint = SerialUtilities.readPaint(stream);
if (this.domainAxis != null) {
this.domainAxis.addChangeListener(this);
if (this.rangeAxis != null) {
this.rangeAxis.addChangeListener(this);package org.jfree.chart.plot;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.TreeMap;
import org.jfree.chart.LegendItem;
import org.jfree.chart.LegendItemCollection;
import org.jfree.chart.axis.Axis;
import org.jfree.chart.axis.AxisState;
import org.jfree.chart.axis.NumberTick;
import org.jfree.chart.axis.NumberTickUnit;
import org.jfree.chart.axis.TickUnit;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.event.RendererChangeListener;
import org.jfree.chart.renderer.PolarItemRenderer;
import org.jfree.chart.util.ResourceBundleWrapper;
import org.jfree.data.Range;
import org.jfree.data.general.Dataset;
import org.jfree.data.general.DatasetChangeEvent;
import org.jfree.data.general.DatasetUtilities;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.text.TextUtilities;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.TextAnchor;
import org.jfree.util.ObjectList;
import org.jfree.util.ObjectUtilities;
import org.jfree.util.PaintUtilities;
import org.jfree.util.PublicCloneable;
public class PolarPlot extends Plot implements ValueAxisPlot, Zoomable,
RendererChangeListener, Cloneable, Serializable {
private static final long serialVersionUID = 3794383185924179525L;
private static final int DEFAULT_MARGIN = 20;
private static final double ANNOTATION_MARGIN = 7.0;
public static final double DEFAULT_ANGLE_TICK_UNIT_SIZE = 45.0;
public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(
0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
0.0f, new float[]{2.0f, 2.0f}, 0.0f);
public static final Paint DEFAULT_GRIDLINE_PAINT = Color.gray;
protected static ResourceBundle localizationResources
= ResourceBundleWrapper.getBundle(
"org.jfree.chart.plot.LocalizationBundle");
private List angleTicks;
private ObjectList axes;
private ObjectList axisLocations;
private ObjectList datasets;
private ObjectList renderers;
private TickUnit angleTickUnit;
private boolean angleLabelsVisible = true;
private Font angleLabelFont = new Font("SansSerif", Font.PLAIN, 12);
private transient Paint angleLabelPaint = Color.black;
private boolean angleGridlinesVisible;
private transient Stroke angleGridlineStroke;
private transient Paint angleGridlinePaint;
private boolean radiusGridlinesVisible;
private transient Stroke radiusGridlineStroke;
private transient Paint radiusGridlinePaint;
private List cornerTextItems = new ArrayList();
private int margin;
private LegendItemCollection fixedLegendItems;
private Map datasetToAxesMap;
public PolarPlot() {
this(null, null, null);
public PolarPlot(XYDataset dataset, ValueAxis radiusAxis,
PolarItemRenderer renderer) {
super();
this.datasets = new ObjectList();
this.datasets.set(0, dataset);
if (dataset != null) {
dataset.addChangeListener(this);
this.angleTickUnit = new NumberTickUnit(DEFAULT_ANGLE_TICK_UNIT_SIZE);
this.axes = new ObjectList();
this.axes.set(0, radiusAxis);
if (radiusAxis != null) {
radiusAxis.setPlot(this);
radiusAxis.addChangeListener(this);
this.datasetToAxesMap = new TreeMap();
this.axisLocations = new ObjectList();
this.axisLocations.set(0, PolarAxisLocation.EAST_ABOVE);
this.axisLocations.set(1, PolarAxisLocation.NORTH_LEFT);
this.axisLocations.set(2, PolarAxisLocation.WEST_BELOW);
this.axisLocations.set(3, PolarAxisLocation.SOUTH_RIGHT);
this.axisLocations.set(4, PolarAxisLocation.EAST_BELOW);
this.axisLocations.set(5, PolarAxisLocation.NORTH_RIGHT);
this.axisLocations.set(6, PolarAxisLocation.WEST_ABOVE);
this.axisLocations.set(7, PolarAxisLocation.SOUTH_LEFT);
this.renderers = new ObjectList();
this.renderers.set(0, renderer);
if (renderer != null) {
renderer.setPlot(this);
renderer.addChangeListener(this);
this.angleGridlinesVisible = true;
this.angleGridlineStroke = DEFAULT_GRIDLINE_STROKE;
this.angleGridlinePaint = DEFAULT_GRIDLINE_PAINT;
this.radiusGridlinesVisible = true;
this.radiusGridlineStroke = DEFAULT_GRIDLINE_STROKE;
this.radiusGridlinePaint = DEFAULT_GRIDLINE_PAINT;
this.margin = DEFAULT_MARGIN;
public String getPlotType() {
return PolarPlot.localizationResources.getString("Polar_Plot");
public ValueAxis getAxis() {
return getAxis(0);
public ValueAxis getAxis(int index) {
ValueAxis result = null;
if (index < this.axes.size()) {
result = (ValueAxis) this.axes.get(index);
return result;
public void setAxis(ValueAxis axis) {
setAxis(0, axis);
public void setAxis(int index, ValueAxis axis) {
setAxis(index, axis, true);
public void setAxis(int index, ValueAxis axis, boolean notify) {
ValueAxis existing = getAxis(index);
if (existing != null) {
existing.removeChangeListener(this);
if (axis != null) {
axis.setPlot(this);
this.axes.set(index, axis);
if (axis != null) {
axis.configure();
axis.addChangeListener(this);
if (notify) {
fireChangeEvent();
public PolarAxisLocation getAxisLocation() {
return getAxisLocation(0);
public PolarAxisLocation getAxisLocation(int index) {
PolarAxisLocation result = null;
if (index < this.axisLocations.size()) {
result = (PolarAxisLocation) this.axisLocations.get(index);
return result;
public void setAxisLocation(PolarAxisLocation location) {
setAxisLocation(0, location, true);
public void setAxisLocation(PolarAxisLocation location, boolean notify) {
setAxisLocation(0, location, notify);
public void setAxisLocation(int index, PolarAxisLocation location) {
setAxisLocation(index, location, true);
public void setAxisLocation(int index, PolarAxisLocation location,
boolean notify) {
if (location == null) {
throw new IllegalArgumentException("Null 'location' argument.");
this.axisLocations.set(index, location);
if (notify) {
fireChangeEvent();
public XYDataset getDataset() {
return getDataset(0);
public XYDataset getDataset(int index) {
XYDataset result = null;
if (index < this.datasets.size()) {
result = (XYDataset) this.datasets.get(index);
return result;
public void setDataset(XYDataset dataset) {
setDataset(0, dataset);
public void setDataset(int index, XYDataset dataset) {
XYDataset existing = getDataset(index);
if (existing != null) {
existing.removeChangeListener(this);
this.datasets.set(index, dataset);
if (dataset != null) {
dataset.addChangeListener(this);
DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);
datasetChanged(event);
public int indexOf(XYDataset dataset) {
int result = -1;
for (int i = 0; i < this.datasets.size(); i++) {
if (dataset == this.datasets.get(i)) {
result = i;
break;
return result;
public PolarItemRenderer getRenderer() {
return getRenderer(0);
public PolarItemRenderer getRenderer(int index) {
PolarItemRenderer result = null;
if (index < this.renderers.size()) {
result = (PolarItemRenderer) this.renderers.get(index);
return result;
public void setRenderer(PolarItemRenderer renderer) {
setRenderer(0, renderer);
public void setRenderer(int index, PolarItemRenderer renderer) {
setRenderer(index, renderer, true);
public void setRenderer(int index, PolarItemRenderer renderer,
boolean notify) {
PolarItemRenderer existing = getRenderer(index);
if (existing != null) {
existing.removeChangeListener(this);
this.renderers.set(index, renderer);
if (renderer != null) {
renderer.setPlot(this);
renderer.addChangeListener(this);
if (notify) {
fireChangeEvent();
public TickUnit getAngleTickUnit() {
return this.angleTickUnit;
public void setAngleTickUnit(TickUnit unit) {
if (unit == null) {
throw new IllegalArgumentException("Null 'unit' argument.");
this.angleTickUnit = unit;
fireChangeEvent();
public boolean isAngleLabelsVisible() {
return this.angleLabelsVisible;
public void setAngleLabelsVisible(boolean visible) {
if (this.angleLabelsVisible != visible) {
this.angleLabelsVisible = visible;
fireChangeEvent();
public Font getAngleLabelFont() {
return this.angleLabelFont;
public void setAngleLabelFont(Font font) {
if (font == null) {
throw new IllegalArgumentException("Null 'font' argument.");
this.angleLabelFont = font;
fireChangeEvent();
public Paint getAngleLabelPaint() {
return this.angleLabelPaint;
public void setAngleLabelPaint(Paint paint) {
if (paint == null) {
throw new IllegalArgumentException("Null 'paint' argument.");
this.angleLabelPaint = paint;
fireChangeEvent();
public boolean isAngleGridlinesVisible() {
return this.angleGridlinesVisible;
public void setAngleGridlinesVisible(boolean visible) {
if (this.angleGridlinesVisible != visible) {
this.angleGridlinesVisible = visible;
fireChangeEvent();
public Stroke getAngleGridlineStroke() {
return this.angleGridlineStroke;
public void setAngleGridlineStroke(Stroke stroke) {
this.angleGridlineStroke = stroke;
fireChangeEvent();
public Paint getAngleGridlinePaint() {
return this.angleGridlinePaint;
public void setAngleGridlinePaint(Paint paint) {
this.angleGridlinePaint = paint;
fireChangeEvent();
public boolean isRadiusGridlinesVisible() {
return this.radiusGridlinesVisible;
public void setRadiusGridlinesVisible(boolean visible) {
if (this.radiusGridlinesVisible != visible) {
this.radiusGridlinesVisible = visible;
fireChangeEvent();
public Stroke getRadiusGridlineStroke() {
return this.radiusGridlineStroke;
public void setRadiusGridlineStroke(Stroke stroke) {
this.radiusGridlineStroke = stroke;
fireChangeEvent();
public Paint getRadiusGridlinePaint() {
return this.radiusGridlinePaint;
public void setRadiusGridlinePaint(Paint paint) {
this.radiusGridlinePaint = paint;
fireChangeEvent();
public int getMargin() {
return this.margin;
public void setMargin(int margin) {
this.margin = margin;
fireChangeEvent();
public LegendItemCollection getFixedLegendItems() {
return this.fixedLegendItems;
public void setFixedLegendItems(LegendItemCollection items) {
this.fixedLegendItems = items;
fireChangeEvent();
public void addCornerTextItem(String text) {
if (text == null) {
throw new IllegalArgumentException("Null 'text' argument.");
this.cornerTextItems.add(text);
fireChangeEvent();
public void removeCornerTextItem(String text) {
boolean removed = this.cornerTextItems.remove(text);
if (removed) {
fireChangeEvent();
public void clearCornerTextItems() {
if (this.cornerTextItems.size() > 0) {
this.cornerTextItems.clear();
fireChangeEvent();
protected List refreshAngleTicks() {
List ticks = new ArrayList();
for (double currentTickVal = 0.0; currentTickVal < 360.0;
currentTickVal += this.angleTickUnit.getSize()) {
TextAnchor ta = TextAnchor.CENTER;
if (currentTickVal == 0.0 || currentTickVal == 360.0) {
ta = TextAnchor.BOTTOM_CENTER;
else if (currentTickVal > 0.0 && currentTickVal < 90.0) {
ta = TextAnchor.BOTTOM_LEFT;
else if (currentTickVal == 90.0) {
ta = TextAnchor.CENTER_LEFT;
else if (currentTickVal > 90.0 && currentTickVal < 180.0) {
ta = TextAnchor.TOP_LEFT;
else if (currentTickVal == 180) {
ta = TextAnchor.TOP_CENTER;
else if (currentTickVal > 180.0 && currentTickVal < 270.0) {
ta = TextAnchor.TOP_RIGHT;
else if (currentTickVal == 270) {
ta = TextAnchor.CENTER_RIGHT;
else if (currentTickVal > 270.0 && currentTickVal < 360.0) {
ta = TextAnchor.BOTTOM_RIGHT;
NumberTick tick = new NumberTick(new Double(currentTickVal),
this.angleTickUnit.valueToString(currentTickVal),
ta, TextAnchor.CENTER, 0.0);
ticks.add(tick);
return ticks;
public void mapDatasetToAxis(int index, int axisIndex) {
List axisIndices = new java.util.ArrayList(1);
axisIndices.add(new Integer(axisIndex));
mapDatasetToAxes(index, axisIndices);
public void mapDatasetToAxes(int index, List axisIndices) {
if (index < 0) {
throw new IllegalArgumentException("Requires 'index' >= 0.");
checkAxisIndices(axisIndices);
Integer key = new Integer(index);
this.datasetToAxesMap.put(key, new ArrayList(axisIndices));
datasetChanged(new DatasetChangeEvent(this, getDataset(index)));
private void checkAxisIndices(List indices) {
if (indices == null) {
return;  // OK
int count = indices.size();
if (count == 0) {
throw new IllegalArgumentException("Empty list not permitted.");
HashSet set = new HashSet();
for (int i = 0; i < count; i++) {
Object item = indices.get(i);
if (!(item instanceof Integer)) {
throw new IllegalArgumentException(
"Indices must be Integer instances.");
if (set.contains(item)) {
throw new IllegalArgumentException("Indices must be unique.");
set.add(item);
public ValueAxis getAxisForDataset(int index) {
ValueAxis valueAxis = null;
List axisIndices = (List) this.datasetToAxesMap.get(
new Integer(index));
if (axisIndices != null) {
Integer axisIndex = (Integer) axisIndices.get(0);
valueAxis = getAxis(axisIndex.intValue());
else {
valueAxis = getAxis(0);
return valueAxis;
public int getIndexOf(PolarItemRenderer renderer) {
return this.renderers.indexOf(renderer);
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
PlotState parentState, PlotRenderingInfo info) {
boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);
boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);
if (b1 || b2) {
return;
if (info != null) {
info.setPlotArea(area);
RectangleInsets insets = getInsets();
insets.trim(area);
Rectangle2D dataArea = area;
if (info != null) {
info.setDataArea(dataArea);
drawBackground(g2, dataArea);
int axisCount = this.axes.size();
AxisState state = null;
for (int i = 0; i < axisCount; i++) {
ValueAxis axis = getAxis(i);
if (axis != null) {
PolarAxisLocation location
= (PolarAxisLocation) this.axisLocations.get(i);
AxisState s = this.drawAxis(axis, location, g2, dataArea);
if (i == 0) {
state = s;
Shape originalClip = g2.getClip();
Composite originalComposite = g2.getComposite();
g2.clip(dataArea);
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,
getForegroundAlpha()));
this.angleTicks = refreshAngleTicks();
drawGridlines(g2, dataArea, this.angleTicks, state.getTicks());
render(g2, dataArea, info);
g2.setClip(originalClip);
g2.setComposite(originalComposite);
drawOutline(g2, dataArea);
drawCornerTextItems(g2, dataArea);
protected void drawCornerTextItems(Graphics2D g2, Rectangle2D area) {
if (this.cornerTextItems.isEmpty()) {
return;
g2.setColor(Color.black);
double width = 0.0;
double height = 0.0;
for (Iterator it = this.cornerTextItems.iterator(); it.hasNext();) {
String msg = (String) it.next();
FontMetrics fm = g2.getFontMetrics();
Rectangle2D bounds = TextUtilities.getTextBounds(msg, g2, fm);
width = Math.max(width, bounds.getWidth());
height += bounds.getHeight();
double xadj = ANNOTATION_MARGIN * 2.0;
double yadj = ANNOTATION_MARGIN;
width += xadj;
height += yadj;
double x = area.getMaxX() - width;
double y = area.getMaxY() - height;
g2.drawRect((int) x, (int) y, (int) width, (int) height);
x += ANNOTATION_MARGIN;
for (Iterator it = this.cornerTextItems.iterator(); it.hasNext();) {
String msg = (String) it.next();
Rectangle2D bounds = TextUtilities.getTextBounds(msg, g2,
g2.getFontMetrics());
y += bounds.getHeight();
g2.drawString(msg, (int) x, (int) y);
protected AxisState drawAxis(ValueAxis axis, PolarAxisLocation location,
Graphics2D g2, Rectangle2D plotArea) {
double centerX = plotArea.getCenterX();
double centerY = plotArea.getCenterY();
double r = Math.min(plotArea.getWidth() / 2.0,
plotArea.getHeight() / 2.0) - margin;
double x = centerX - r;
double y = centerY - r;
Rectangle2D dataArea = null;
AxisState result = null;
if (location == PolarAxisLocation.NORTH_RIGHT) {
dataArea = new Rectangle2D.Double(x, y, r, r);
result = axis.draw(g2, centerX, plotArea, dataArea,
RectangleEdge.RIGHT, null);
else if (location == PolarAxisLocation.NORTH_LEFT) {
dataArea = new Rectangle2D.Double(centerX, y, r, r);
result = axis.draw(g2, centerX, plotArea, dataArea,
RectangleEdge.LEFT, null);
else if (location == PolarAxisLocation.SOUTH_LEFT) {
dataArea = new Rectangle2D.Double(centerX, centerY, r, r);
result = axis.draw(g2, centerX, plotArea, dataArea,
RectangleEdge.LEFT, null);
else if (location == PolarAxisLocation.SOUTH_RIGHT) {
dataArea = new Rectangle2D.Double(x, centerY, r, r);
result = axis.draw(g2, centerX, plotArea, dataArea,
RectangleEdge.RIGHT, null);
else if (location == PolarAxisLocation.EAST_ABOVE) {
dataArea = new Rectangle2D.Double(centerX, centerY, r, r);
result = axis.draw(g2, centerY, plotArea, dataArea,
RectangleEdge.TOP, null);
else if (location == PolarAxisLocation.EAST_BELOW) {
dataArea = new Rectangle2D.Double(centerX, y, r, r);
result = axis.draw(g2, centerY, plotArea, dataArea,
RectangleEdge.BOTTOM, null);
else if (location == PolarAxisLocation.WEST_ABOVE) {
dataArea = new Rectangle2D.Double(x, centerY, r, r);
result = axis.draw(g2, centerY, plotArea, dataArea,
RectangleEdge.TOP, null);
else if (location == PolarAxisLocation.WEST_BELOW) {
dataArea = new Rectangle2D.Double(x, y, r, r);
result = axis.draw(g2, centerY, plotArea, dataArea,
RectangleEdge.BOTTOM, null);
return result;
protected void render(Graphics2D g2, Rectangle2D dataArea,
PlotRenderingInfo info) {
boolean hasData = false;
int datasetCount = this.datasets.size();
for (int i = datasetCount - 1; i >= 0; i--) {
XYDataset dataset = getDataset(i);
if (dataset == null) {
continue;
PolarItemRenderer renderer = getRenderer(i);
if (renderer == null) {
continue;
if (!DatasetUtilities.isEmptyOrNull(dataset)) {
hasData = true;
int seriesCount = dataset.getSeriesCount();
for (int series = 0; series < seriesCount; series++) {
renderer.drawSeries(g2, dataArea, info, this, dataset,
series);
if (!hasData) {
drawNoDataMessage(g2, dataArea);
protected void drawGridlines(Graphics2D g2, Rectangle2D dataArea,
List angularTicks, List radialTicks) {
PolarItemRenderer renderer = getRenderer();
if (renderer == null) {
return;
if (isAngleGridlinesVisible()) {
Stroke gridStroke = getAngleGridlineStroke();
Paint gridPaint = getAngleGridlinePaint();
if ((gridStroke != null) && (gridPaint != null)) {
renderer.drawAngularGridLines(g2, this, angularTicks,
dataArea);
if (isRadiusGridlinesVisible()) {
Stroke gridStroke = getRadiusGridlineStroke();
Paint gridPaint = getRadiusGridlinePaint();
if ((gridStroke != null) && (gridPaint != null)) {
renderer.drawRadialGridLines(g2, this, getAxis(),
radialTicks, dataArea);
public void zoom(double percent) {
if (percent > 0.0) {
double radius = getAxis().getUpperBound();
double scaledRadius = radius * percent;
getAxis().setUpperBound(scaledRadius);
getAxis().setAutoRange(false);
else {
getAxis().setAutoRange(true);
public Range getDataRange(ValueAxis axis) {
Range result = null;
if (getDataset() != null) {
result = Range.combine(result,
DatasetUtilities.findRangeBounds(getDataset()));
return result;
public void datasetChanged(DatasetChangeEvent event) {
if (getAxis() != null) {
getAxis().configure();
if (getParent() != null) {
getParent().datasetChanged(event);
else {
super.datasetChanged(event);
public void rendererChanged(RendererChangeEvent event) {
fireChangeEvent();
public LegendItemCollection getLegendItems() {
if (this.fixedLegendItems != null) {
return this.fixedLegendItems;
LegendItemCollection result = new LegendItemCollection();
int count = this.datasets.size();
for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {
XYDataset dataset = getDataset(datasetIndex);
PolarItemRenderer renderer = getRenderer(datasetIndex);
if (dataset != null && renderer != null) {
int seriesCount = dataset.getSeriesCount();
for (int i = 0; i < seriesCount; i++) {
LegendItem item = renderer.getLegendItem(i);
result.add(item);
return result;
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof PolarPlot)) {
return false;
PolarPlot that = (PolarPlot) obj;
if (!this.axes.equals(that.axes)) {
return false;
if (!this.axisLocations.equals(that.axisLocations)) {
return false;
if (!this.renderers.equals(that.renderers)) {
return false;
if (!this.angleTickUnit.equals(that.angleTickUnit)) {
return false;
if (this.angleGridlinesVisible != that.angleGridlinesVisible) {
return false;
if (this.angleLabelsVisible != that.angleLabelsVisible) {
return false;
if (!this.angleLabelFont.equals(that.angleLabelFont)) {
return false;
if (!PaintUtilities.equal(this.angleLabelPaint, that.angleLabelPaint)) {
return false;
if (!ObjectUtilities.equal(this.angleGridlineStroke,
that.angleGridlineStroke)) {
return false;
if (!PaintUtilities.equal(
this.angleGridlinePaint, that.angleGridlinePaint
)) {
return false;
if (this.radiusGridlinesVisible != that.radiusGridlinesVisible) {
return false;
if (!ObjectUtilities.equal(this.radiusGridlineStroke,
that.radiusGridlineStroke)) {
return false;
if (!PaintUtilities.equal(this.radiusGridlinePaint,
that.radiusGridlinePaint)) {
return false;
if (!this.cornerTextItems.equals(that.cornerTextItems)) {
return false;
if (this.margin != that.margin) {
return false;
if (!ObjectUtilities.equal(this.fixedLegendItems,
that.fixedLegendItems)) {
return false;
return super.equals(obj);
public Object clone() throws CloneNotSupportedException {
PolarPlot clone = (PolarPlot) super.clone();
clone.axes = (ObjectList) ObjectUtilities.clone(this.axes);
for (int i = 0; i < this.axes.size(); i++) {
ValueAxis axis = (ValueAxis) this.axes.get(i);
if (axis != null) {
ValueAxis clonedAxis = (ValueAxis) axis.clone();
clone.axes.set(i, clonedAxis);
clonedAxis.setPlot(clone);
clonedAxis.addChangeListener(clone);
clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);
for (int i = 0; i < clone.datasets.size(); ++i) {
XYDataset d = getDataset(i);
if (d != null) {
d.addChangeListener(clone);
clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);
for (int i = 0; i < this.renderers.size(); i++) {
PolarItemRenderer renderer2 = (PolarItemRenderer) this.renderers.get(i);
if (renderer2 instanceof PublicCloneable) {
PublicCloneable pc = (PublicCloneable) renderer2;
PolarItemRenderer rc = (PolarItemRenderer) pc.clone();
clone.renderers.set(i, rc);
rc.setPlot(clone);
rc.addChangeListener(clone);
clone.cornerTextItems = new ArrayList(this.cornerTextItems);
return clone;
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writeStroke(this.angleGridlineStroke, stream);
SerialUtilities.writePaint(this.angleGridlinePaint, stream);
SerialUtilities.writeStroke(this.radiusGridlineStroke, stream);
SerialUtilities.writePaint(this.radiusGridlinePaint, stream);
SerialUtilities.writePaint(this.angleLabelPaint, stream);
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.angleGridlineStroke = SerialUtilities.readStroke(stream);
this.angleGridlinePaint = SerialUtilities.readPaint(stream);
this.radiusGridlineStroke = SerialUtilities.readStroke(stream);
this.radiusGridlinePaint = SerialUtilities.readPaint(stream);
this.angleLabelPaint = SerialUtilities.readPaint(stream);
int rangeAxisCount = this.axes.size();
for (int i = 0; i < rangeAxisCount; i++) {
Axis axis = (Axis) this.axes.get(i);
if (axis != null) {
axis.setPlot(this);
axis.addChangeListener(this);
int datasetCount = this.datasets.size();
for (int i = 0; i < datasetCount; i++) {
Dataset dataset = (Dataset) this.datasets.get(i);
if (dataset != null) {
dataset.addChangeListener(this);
int rendererCount = this.renderers.size();
for (int i = 0; i < rendererCount; i++) {
PolarItemRenderer renderer = (PolarItemRenderer) this.renderers.get(i);
if (renderer != null) {
renderer.addChangeListener(this);
public void zoomDomainAxes(double factor, PlotRenderingInfo state,
Point2D source) {
public void zoomDomainAxes(double factor, PlotRenderingInfo state,
Point2D source, boolean useAnchor) {
public void zoomDomainAxes(double lowerPercent, double upperPercent,
PlotRenderingInfo state, Point2D source) {
public void zoomRangeAxes(double factor, PlotRenderingInfo state,
Point2D source) {
zoom(factor);
public void zoomRangeAxes(double factor, PlotRenderingInfo info,
Point2D source, boolean useAnchor) {
if (useAnchor) {
double sourceX = source.getX();
double anchorX = getAxis().java2DToValue(sourceX,
info.getDataArea(), RectangleEdge.BOTTOM);
getAxis().resizeRange(factor, anchorX);
else {
getAxis().resizeRange(factor);
public void zoomRangeAxes(double lowerPercent, double upperPercent,
PlotRenderingInfo state, Point2D source) {
zoom((upperPercent + lowerPercent) / 2.0);
public boolean isDomainZoomable() {
return false;
public boolean isRangeZoomable() {
return true;
public PlotOrientation getOrientation() {
return PlotOrientation.HORIZONTAL;
public Point translateToJava2D(double angleDegrees, double radius,
ValueAxis axis, Rectangle2D dataArea) {
double radians = Math.toRadians(angleDegrees - 90.0);
double minx = dataArea.getMinX() + this.margin;
double maxx = dataArea.getMaxX() - this.margin;
double miny = dataArea.getMinY() + this.margin;
double maxy = dataArea.getMaxY() - this.margin;
double lengthX = maxx - minx;
double lengthY = maxy - miny;
double length = Math.min(lengthX, lengthY);
double midX = minx + lengthX / 2.0;
double midY = miny + lengthY / 2.0;
double axisMin = axis.getLowerBound();
double axisMax =  axis.getUpperBound();
double adjustedRadius = Math.max(radius, axisMin);
double xv = length / 2.0 * Math.cos(radians);
double yv = length / 2.0 * Math.sin(radians);
float x = (float) (midX + (xv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
float y = (float) (midY + (yv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
int ix = Math.round(x);
int iy = Math.round(y);
Point p = new Point(ix, iy);
return p;
public Point translateValueThetaRadiusToJava2D(double angleDegrees,
double radius, Rectangle2D dataArea) {
double radians = Math.toRadians(angleDegrees - 90.0);
double minx = dataArea.getMinX() + this.margin;
double maxx = dataArea.getMaxX() - this.margin;
double miny = dataArea.getMinY() + this.margin;
double maxy = dataArea.getMaxY() - this.margin;
double lengthX = maxx - minx;
double lengthY = maxy - miny;
double length = Math.min(lengthX, lengthY);
double midX = minx + lengthX / 2.0;
double midY = miny + lengthY / 2.0;
double axisMin = getAxis().getLowerBound();
double axisMax =  getAxis().getUpperBound();
double adjustedRadius = Math.max(radius, axisMin);
double xv = length / 2.0 * Math.cos(radians);
double yv = length / 2.0 * Math.sin(radians);
float x = (float) (midX + (xv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
float y = (float) (midY + (yv * (adjustedRadius - axisMin)
/ (axisMax - axisMin)));
int ix = Math.round(x);
int iy = Math.round(y);
Point p = new Point(ix, iy);
return p;
public double getMaxRadius() {
return getAxis().getUpperBound();
public int getSeriesCount() {
int result = 0;
XYDataset dataset = getDataset(0);
if (dataset != null) {
result = dataset.getSeriesCount();
return result;
protected AxisState drawAxis(Graphics2D g2, Rectangle2D plotArea,
Rectangle2D dataArea) {
return getAxis().draw(g2, dataArea.getMinY(), plotArea, dataArea,
RectangleEdge.TOP, null);package org.jfree.chart.renderer.xy;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.XYItemEntity;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYSeriesLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.util.PublicCloneable;
import org.jfree.util.ShapeUtilities;
public class XYAreaRenderer2 extends AbstractXYItemRenderer
implements XYItemRenderer, PublicCloneable {
private static final long serialVersionUID = -7378069681579984133L;
private boolean showOutline;
private transient Shape legendArea;
public XYAreaRenderer2() {
this(null, null);
public XYAreaRenderer2(XYToolTipGenerator labelGenerator,
XYURLGenerator urlGenerator) {
super();
this.showOutline = false;
setBaseToolTipGenerator(labelGenerator);
setURLGenerator(urlGenerator);
GeneralPath area = new GeneralPath();
area.moveTo(0.0f, -4.0f);
area.lineTo(3.0f, -2.0f);
area.lineTo(4.0f, 4.0f);
area.lineTo(-4.0f, 4.0f);
area.lineTo(-3.0f, -2.0f);
area.closePath();
this.legendArea = area;
public boolean isOutline() {
return this.showOutline;
public void setOutline(boolean show) {
this.showOutline = show;
fireChangeEvent();
public boolean getPlotLines() {
return false;
public Shape getLegendArea() {
return this.legendArea;
public void setLegendArea(Shape area) {
if (area == null) {
throw new IllegalArgumentException("Null 'area' argument.");
this.legendArea = area;
fireChangeEvent();
public LegendItem getLegendItem(int datasetIndex, int series) {
LegendItem result = null;
XYPlot xyplot = getPlot();
if (xyplot != null) {
XYDataset dataset = xyplot.getDataset(datasetIndex);
if (dataset != null) {
XYSeriesLabelGenerator lg = getLegendItemLabelGenerator();
String label = lg.generateLabel(dataset, series);
String description = label;
String toolTipText = null;
if (getLegendItemToolTipGenerator() != null) {
toolTipText = getLegendItemToolTipGenerator().generateLabel(
dataset, series);
String urlText = null;
if (getLegendItemURLGenerator() != null) {
urlText = getLegendItemURLGenerator().generateLabel(
dataset, series);
Paint paint = lookupSeriesPaint(series);
result = new LegendItem(label, description, toolTipText,
urlText, this.legendArea, paint);
result.setLabelFont(lookupLegendTextFont(series));
Paint labelPaint = lookupLegendTextPaint(series);
if (labelPaint != null) {
result.setLabelPaint(labelPaint);
result.setDataset(dataset);
result.setDatasetIndex(datasetIndex);
result.setSeriesKey(dataset.getSeriesKey(series));
result.setSeriesIndex(series);
return result;
public void drawItem(Graphics2D g2,
XYItemRendererState state,
Rectangle2D dataArea,
PlotRenderingInfo info,
XYPlot plot,
ValueAxis domainAxis,
ValueAxis rangeAxis,
XYDataset dataset,
int series,
int item,
CrosshairState crosshairState,
int pass) {
if (!getItemVisible(series, item)) {
return;
double x1 = dataset.getXValue(series, item);
double y1 = dataset.getYValue(series, item);
if (Double.isNaN(y1)) {
y1 = 0.0;
double transX1 = domainAxis.valueToJava2D(x1, dataArea,
plot.getDomainAxisEdge());
double transY1 = rangeAxis.valueToJava2D(y1, dataArea,
plot.getRangeAxisEdge());
double x0 = dataset.getXValue(series, Math.max(item - 1, 0));
double y0 = dataset.getYValue(series, Math.max(item - 1, 0));
if (Double.isNaN(y0)) {
y0 = 0.0;
double transX0 = domainAxis.valueToJava2D(x0, dataArea,
plot.getDomainAxisEdge());
double transY0 = rangeAxis.valueToJava2D(y0, dataArea,
plot.getRangeAxisEdge());
int itemCount = dataset.getItemCount(series);
double x2 = dataset.getXValue(series, Math.min(item + 1,
itemCount - 1));
double y2 = dataset.getYValue(series, Math.min(item + 1,
itemCount - 1));
if (Double.isNaN(y2)) {
y2 = 0.0;
double transX2 = domainAxis.valueToJava2D(x2, dataArea,
plot.getDomainAxisEdge());
double transY2 = rangeAxis.valueToJava2D(y2, dataArea,
plot.getRangeAxisEdge());
double transZero = rangeAxis.valueToJava2D(0.0, dataArea,
plot.getRangeAxisEdge());
GeneralPath hotspot = new GeneralPath();
if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
moveTo(hotspot, transZero, ((transX0 + transX1) / 2.0));
lineTo(hotspot, ((transY0 + transY1) / 2.0),
((transX0 + transX1) / 2.0));
lineTo(hotspot, transY1, transX1);
lineTo(hotspot, ((transY1 + transY2) / 2.0),
((transX1 + transX2) / 2.0));
lineTo(hotspot, transZero, ((transX1 + transX2) / 2.0));
else {  // vertical orientation
moveTo(hotspot, ((transX0 + transX1) / 2.0), transZero);
lineTo(hotspot, ((transX0 + transX1) / 2.0),
((transY0 + transY1) / 2.0));
lineTo(hotspot, transX1, transY1);
lineTo(hotspot, ((transX1 + transX2) / 2.0),
((transY1 + transY2) / 2.0));
lineTo(hotspot, ((transX1 + transX2) / 2.0), transZero);
hotspot.closePath();
PlotOrientation orientation = plot.getOrientation();
Paint paint = getItemPaint(series, item);
Stroke stroke = getItemStroke(series, item);
g2.setPaint(paint);
g2.setStroke(stroke);
g2.fill(hotspot);
if (isOutline()) {
g2.setStroke(lookupSeriesOutlineStroke(series));
g2.setPaint(lookupSeriesOutlinePaint(series));
g2.draw(hotspot);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
if (state.getInfo() != null) {
EntityCollection entities = state.getEntityCollection();
if (entities != null) {
String tip = null;
XYToolTipGenerator generator = getToolTipGenerator(series,
item);
if (generator != null) {
tip = generator.generateToolTip(dataset, series, item);
String url = null;
if (getURLGenerator() != null) {
url = getURLGenerator().generateURL(dataset, series, item);
XYItemEntity entity = new XYItemEntity(hotspot, dataset,
series, item, tip, url);
entities.add(entity);
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof XYAreaRenderer2)) {
return false;
XYAreaRenderer2 that = (XYAreaRenderer2) obj;
if (this.showOutline != that.showOutline) {
return false;
if (!ShapeUtilities.equal(this.legendArea, that.legendArea)) {
return false;
return super.equals(obj);
public Object clone() throws CloneNotSupportedException {
XYAreaRenderer2 clone = (XYAreaRenderer2) super.clone();
clone.legendArea = ShapeUtilities.clone(this.legendArea);
return clone;
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.legendArea = SerialUtilities.readShape(stream);
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writeShape(this.legendArea, stream);package org.jfree.chart.renderer.xy;
import java.awt.BasicStroke;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import org.jfree.chart.HashUtilities;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYSeriesLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.ui.GradientPaintTransformer;
import org.jfree.ui.StandardGradientPaintTransformer;
import org.jfree.util.PublicCloneable;
import org.jfree.util.ShapeUtilities;
public class XYAreaRenderer extends AbstractXYItemRenderer
implements XYItemRenderer, PublicCloneable {
private static final long serialVersionUID = -4481971353973876747L;
static class XYAreaRendererState extends XYItemRendererState {
public GeneralPath area;
public Line2D line;
public XYAreaRendererState(PlotRenderingInfo info) {
super(info);
this.area = new GeneralPath();
this.line = new Line2D.Double();
public static final int SHAPES = 1;
public static final int LINES = 2;
public static final int SHAPES_AND_LINES = 3;
public static final int AREA = 4;
public static final int AREA_AND_SHAPES = 5;
private boolean plotShapes;
private boolean plotLines;
private boolean plotArea;
private boolean showOutline;
private transient Shape legendArea;
private boolean useFillPaint;
private GradientPaintTransformer gradientTransformer;
public XYAreaRenderer() {
this(AREA);
public XYAreaRenderer(int type) {
this(type, null, null);
public XYAreaRenderer(int type, XYToolTipGenerator toolTipGenerator,
XYURLGenerator urlGenerator) {
super();
setBaseToolTipGenerator(toolTipGenerator);
setURLGenerator(urlGenerator);
if (type == SHAPES) {
this.plotShapes = true;
if (type == LINES) {
this.plotLines = true;
if (type == SHAPES_AND_LINES) {
this.plotShapes = true;
this.plotLines = true;
if (type == AREA) {
this.plotArea = true;
if (type == AREA_AND_SHAPES) {
this.plotArea = true;
this.plotShapes = true;
this.showOutline = false;
GeneralPath area = new GeneralPath();
area.moveTo(0.0f, -4.0f);
area.lineTo(3.0f, -2.0f);
area.lineTo(4.0f, 4.0f);
area.lineTo(-4.0f, 4.0f);
area.lineTo(-3.0f, -2.0f);
area.closePath();
this.legendArea = area;
this.useFillPaint = false;
this.gradientTransformer = new StandardGradientPaintTransformer();
public boolean getPlotShapes() {
return this.plotShapes;
public boolean getPlotLines() {
return this.plotLines;
public boolean getPlotArea() {
return this.plotArea;
public boolean isOutline() {
return this.showOutline;
public void setOutline(boolean show) {
this.showOutline = show;
fireChangeEvent();
public Shape getLegendArea() {
return this.legendArea;
public void setLegendArea(Shape area) {
if (area == null) {
throw new IllegalArgumentException("Null 'area' argument.");
this.legendArea = area;
fireChangeEvent();
public boolean getUseFillPaint() {
return this.useFillPaint;
public void setUseFillPaint(boolean use) {
this.useFillPaint = use;
fireChangeEvent();
public GradientPaintTransformer getGradientTransformer() {
return this.gradientTransformer;
public void setGradientTransformer(GradientPaintTransformer transformer) {
if (transformer == null) {
throw new IllegalArgumentException("Null 'transformer' argument.");
this.gradientTransformer = transformer;
fireChangeEvent();
public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea,
XYPlot plot, XYDataset data, PlotRenderingInfo info) {
XYAreaRendererState state = new XYAreaRendererState(info);
state.setProcessVisibleItemsOnly(false);
return state;
public LegendItem getLegendItem(int datasetIndex, int series) {
LegendItem result = null;
XYPlot xyplot = getPlot();
if (xyplot != null) {
XYDataset dataset = xyplot.getDataset(datasetIndex);
if (dataset != null) {
XYSeriesLabelGenerator lg = getLegendItemLabelGenerator();
String label = lg.generateLabel(dataset, series);
String description = label;
String toolTipText = null;
if (getLegendItemToolTipGenerator() != null) {
toolTipText = getLegendItemToolTipGenerator().generateLabel(
dataset, series);
String urlText = null;
if (getLegendItemURLGenerator() != null) {
urlText = getLegendItemURLGenerator().generateLabel(
dataset, series);
Paint paint = lookupSeriesPaint(series);
result = new LegendItem(label, description, toolTipText,
urlText, this.legendArea, paint);
result.setLabelFont(lookupLegendTextFont(series));
Paint labelPaint = lookupLegendTextPaint(series);
if (labelPaint != null) {
result.setLabelPaint(labelPaint);
result.setDataset(dataset);
result.setDatasetIndex(datasetIndex);
result.setSeriesKey(dataset.getSeriesKey(series));
result.setSeriesIndex(series);
return result;
public void drawItem(Graphics2D g2, XYItemRendererState state,
Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot,
ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset,
int series, int item, CrosshairState crosshairState, int pass) {
if (!getItemVisible(series, item)) {
return;
XYAreaRendererState areaState = (XYAreaRendererState) state;
double x1 = dataset.getXValue(series, item);
double y1 = dataset.getYValue(series, item);
if (Double.isNaN(y1)) {
y1 = 0.0;
double transX1 = domainAxis.valueToJava2D(x1, dataArea,
plot.getDomainAxisEdge());
double transY1 = rangeAxis.valueToJava2D(y1, dataArea,
plot.getRangeAxisEdge());
int itemCount = dataset.getItemCount(series);
double x0 = dataset.getXValue(series, Math.max(item - 1, 0));
double y0 = dataset.getYValue(series, Math.max(item - 1, 0));
if (Double.isNaN(y0)) {
y0 = 0.0;
double transX0 = domainAxis.valueToJava2D(x0, dataArea,
plot.getDomainAxisEdge());
double transY0 = rangeAxis.valueToJava2D(y0, dataArea,
plot.getRangeAxisEdge());
double x2 = dataset.getXValue(series, Math.min(item + 1,
itemCount - 1));
double y2 = dataset.getYValue(series, Math.min(item + 1,
itemCount - 1));
if (Double.isNaN(y2)) {
y2 = 0.0;
double transX2 = domainAxis.valueToJava2D(x2, dataArea,
plot.getDomainAxisEdge());
double transY2 = rangeAxis.valueToJava2D(y2, dataArea,
plot.getRangeAxisEdge());
double transZero = rangeAxis.valueToJava2D(0.0, dataArea,
plot.getRangeAxisEdge());
GeneralPath hotspot = new GeneralPath();
if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
moveTo(hotspot, transZero, ((transX0 + transX1) / 2.0));
lineTo(hotspot, ((transY0 + transY1) / 2.0), 
((transX0 + transX1) / 2.0));
lineTo(hotspot, transY1, transX1);
lineTo(hotspot, ((transY1 + transY2) / 2.0), 
((transX1 + transX2) / 2.0));
lineTo(hotspot, transZero, ((transX1 + transX2) / 2.0));
else {  // vertical orientation
moveTo(hotspot, ((transX0 + transX1) / 2.0), transZero);
lineTo(hotspot, ((transX0 + transX1) / 2.0),
((transY0 + transY1) / 2.0));
lineTo(hotspot, transX1, transY1);
lineTo(hotspot, ((transX1 + transX2) / 2.0),
((transY1 + transY2) / 2.0));
lineTo(hotspot, ((transX1 + transX2) / 2.0), transZero);
hotspot.closePath();
if (item == 0) {  // create a new area polygon for the series
areaState.area = new GeneralPath();
double zero = rangeAxis.valueToJava2D(0.0, dataArea,
plot.getRangeAxisEdge());
if (plot.getOrientation() == PlotOrientation.VERTICAL) {
moveTo(areaState.area, transX1, zero);
else if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
moveTo(areaState.area, zero, transX1);
if (plot.getOrientation() == PlotOrientation.VERTICAL) {
lineTo(areaState.area, transX1, transY1);
else if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
lineTo(areaState.area, transY1, transX1);
PlotOrientation orientation = plot.getOrientation();
Paint paint = getItemPaint(series, item);
Stroke stroke = getItemStroke(series, item);
g2.setPaint(paint);
g2.setStroke(stroke);
Shape shape = null;
if (getPlotShapes()) {
shape = getItemShape(series, item);
if (orientation == PlotOrientation.VERTICAL) {
shape = ShapeUtilities.createTranslatedShape(shape, transX1,
transY1);
else if (orientation == PlotOrientation.HORIZONTAL) {
shape = ShapeUtilities.createTranslatedShape(shape, transY1,
transX1);
g2.draw(shape);
if (getPlotLines()) {
if (item > 0) {
if (plot.getOrientation() == PlotOrientation.VERTICAL) {
areaState.line.setLine(transX0, transY0, transX1, transY1);
else if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
areaState.line.setLine(transY0, transX0, transY1, transX1);
g2.draw(areaState.line);
if (getPlotArea() && item > 0 && item == (itemCount - 1)) {
if (orientation == PlotOrientation.VERTICAL) {
lineTo(areaState.area, transX1, transZero);
areaState.area.closePath();
else if (orientation == PlotOrientation.HORIZONTAL) {
lineTo(areaState.area, transZero, transX1);
areaState.area.closePath();
if (this.useFillPaint) {
paint = lookupSeriesFillPaint(series);
if (paint instanceof GradientPaint) {
GradientPaint gp = (GradientPaint) paint;
GradientPaint adjGP = this.gradientTransformer.transform(gp,
dataArea);
g2.setPaint(adjGP);
g2.fill(areaState.area);
if (isOutline()) {
Shape area = areaState.area;
Stroke outlineStroke = lookupSeriesOutlineStroke(series);
if (outlineStroke instanceof BasicStroke) {
BasicStroke bs = (BasicStroke) outlineStroke;
if (bs.getDashArray() != null) {
Area poly = new Area(areaState.area);
Area clip = new Area(new Rectangle2D.Double(
dataArea.getX() - 5.0, dataArea.getY() - 5.0,
dataArea.getWidth() + 10.0,
dataArea.getHeight() + 10.0));
poly.intersect(clip);
area = poly;
g2.setStroke(outlineStroke);
g2.setPaint(lookupSeriesOutlinePaint(series));
g2.draw(area);
int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
rangeAxisIndex, transX1, transY1, orientation);
EntityCollection entities = state.getEntityCollection();
if (entities != null && hotspot != null) {
addEntity(entities, hotspot, dataset, series, item, 0.0, 0.0);
public Object clone() throws CloneNotSupportedException {
XYAreaRenderer clone = (XYAreaRenderer) super.clone();
clone.legendArea = ShapeUtilities.clone(this.legendArea);
return clone;
public boolean equals(Object obj) {
if (obj == this) {
return true;
if (!(obj instanceof XYAreaRenderer)) {
return false;
XYAreaRenderer that = (XYAreaRenderer) obj;
if (this.plotArea != that.plotArea) {
return false;
if (this.plotLines != that.plotLines) {
return false;
if (this.plotShapes != that.plotShapes) {
return false;
if (this.showOutline != that.showOutline) {
return false;
if (this.useFillPaint != that.useFillPaint) {
return false;
if (!this.gradientTransformer.equals(that.gradientTransformer)) {
return false;
if (!ShapeUtilities.equal(this.legendArea, that.legendArea)) {
return false;
return true;
public int hashCode() {
int result = super.hashCode();
result = HashUtilities.hashCode(result, this.plotArea);
result = HashUtilities.hashCode(result, this.plotLines);
result = HashUtilities.hashCode(result, this.plotShapes);
result = HashUtilities.hashCode(result, this.useFillPaint);
return result;
private void readObject(ObjectInputStream stream)
throws IOException, ClassNotFoundException {
stream.defaultReadObject();
this.legendArea = SerialUtilities.readShape(stream);
private void writeObject(ObjectOutputStream stream) throws IOException {
stream.defaultWriteObject();
SerialUtilities.writeShape(this.legendArea, stream);import java.lang.annotation.Annotation;
import org.jfree.chart.LegendItem;if (dataset != null) {XYDataset dataset = getDataset(0);
PolarItemRenderer renderer = getRenderer(0);
if (dataset != null) {
if (renderer != null) {
PolarPlot polarPlot = getPlot();
if (polarPlot != null) {
XYDataset dataset = polarPlot.getDataset();
if (dataset != null) {
String label = dataset.getSeriesKey(series).toString();
String description = label;
Shape shape = lookupSeriesShape(series);
Paint paint = lookupSeriesPaint(series);
Paint outlinePaint = lookupSeriesOutlinePaint(series);
Stroke outlineStroke = lookupSeriesOutlineStroke(series);
result = new LegendItem(label, description, null, null,
shape, paint, outlineStroke, outlinePaint);
result.setDataset(dataset);
ObjectInput in = new ObjectInputStream(
new ByteArrayInputStream(buffer.toByteArray())
);"The 'data' array must contain two arrays with equal length.");if (this.popup != null) {
Plot plot = this.chart.getPlot();
boolean isDomainZoomable = false;
boolean isRangeZoomable = false;
if (plot instanceof Zoomable) {
Zoomable z = (Zoomable) plot;
isDomainZoomable = z.isDomainZoomable();
isRangeZoomable = z.isRangeZoomable();
if (this.zoomInDomainMenuItem != null) {
this.zoomInDomainMenuItem.setEnabled(isDomainZoomable);
if (this.zoomOutDomainMenuItem != null) {
this.zoomOutDomainMenuItem.setEnabled(isDomainZoomable);
if (this.zoomResetDomainMenuItem != null) {
this.zoomResetDomainMenuItem.setEnabled(isDomainZoomable);
if (this.zoomInRangeMenuItem != null) {
this.zoomInRangeMenuItem.setEnabled(isRangeZoomable);
if (this.zoomOutRangeMenuItem != null) {
this.zoomOutRangeMenuItem.setEnabled(isRangeZoomable);
if (this.zoomResetRangeMenuItem != null) {
this.zoomResetRangeMenuItem.setEnabled(isRangeZoomable);
if (this.zoomInBothMenuItem != null) {
this.zoomInBothMenuItem.setEnabled(isDomainZoomable
&& isRangeZoomable);
if (this.zoomOutBothMenuItem != null) {
this.zoomOutBothMenuItem.setEnabled(isDomainZoomable
&& isRangeZoomable);
if (this.zoomResetBothMenuItem != null) {
this.zoomResetBothMenuItem.setEnabled(isDomainZoomable
&& isRangeZoomable);
this.popup.show(this, x, y);this.coefficients = coefficients.clone();
return this.coefficients.clone();try {
i2 = (XYDataItem) i1.clone();
catch (CloneNotSupportedException e) {
System.err.println("XYDataItemTests.testCloning: failed to clone.");
new ByteArrayInputStream(buffer.toByteArray())
);
System.out.println(e.toString());import java.util.Arrays;
import org.jfree.data.function.PolynomialFunction2D;translatedValue), translatedEndX, translatedHeight,
translatedWidth);
bar = new Rectangle2D.Double(translatedStartX,
Math.min(translatedBase, translatedValue),double x0 = dataArea.getX();double rectWidth = state.getBarWidth();
rectWidth = 0.0;Rectangle2D titleArea = new Rectangle2D.Double();ArrayList row = (ArrayList) this.rows.get(0);
row = (ArrayList) this.rows.get(rowNum);double value = Double.NaN;
"JDBCPieDataset - unknown data type"
);Number tempNum = value1;
value1 = value0;
value0 = tempNum;Number tempNum = value1;
value0 = tempNum;arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(),
pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);mid = (low + high) / 2;Paint seriesPaint = getFirstBarPaint();oldt = t;
oldy = y;double transY0 = restrictValueToDataArea(getRangeBase(), plot,
dataArea);double ol = getTickMarkOutsideLength();Point2D pt = RectangleAnchor.coordinates(rect, anchor);cursor = this.colorBar.draw(g2, cursor, adjustedPlotArea, dataArea,double m = Double.NaN;
double sd = Double.NaN;
m = masd.getMeanValue();
sd = masd.getStandardDeviationValue();Object[] v = new Object[] { this.numberFormat.format(
crosshair.getValue()) };List values = Arrays.asList(new double[] {1.0});
values = Arrays.asList(new double[] {2.0, 2.2});
values = Arrays.asList(new double[] {-3.0, -3.2});
values = Arrays.asList(new double[] {6.0});return this.underlying.getStartValue(r, c + this.firstCategoryIndex);setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));if (this.minorTickMarkOutsideLength != that.minorTickMarkOutsideLength) {super(tickType, date.getTime(), label, textAnchor, rotationAnchor, angle);g2.draw(new Line2D.Double(xx, yyMedian, xx + state.getBarWidth(),
yyMedian));throw new IllegalArgumentException("periodCount must be greater " +
"than or equal to 1.");
throw new IllegalArgumentException("periodCount must be greater " +
"than or equal to 2.");return "[" + this.hour + "," + getDayOfMonth() + "/" + getMonth() + "/"
+ getYear() + "]";entities.add(new JFreeChartEntity((Rectangle2D) chartArea.clone(),double ol = (tick.getTickType().equals(TickType.MINOR)) ?
getMinorTickMarkOutsideLength() : getTickMarkOutsideLength();
double il = (tick.getTickType().equals(TickType.MINOR)) ?
getMinorTickMarkInsideLength() : getTickMarkInsideLength();if (getRange().contains(minorTickValue)){
double nextTickValue = lowestTickValue + ((i + 1)* size);
if (getRange().contains(minorTickValue)){
for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++){
if (getRange().contains(minorTickValue)){
double nextTickValue = lowestTickValue + ((i + 1)* size);
minorTick++){
if (getRange().contains(minorTickValue)){throw new IllegalArgumentException("The 'unit' argument has a " +
"value that is not recognised.");return createStandardDateTickUnits(zone, Locale.getDefault());
Locale locale) {
throw new IllegalArgumentException("Null 'locale' argument.");
minorTick++){
minorTick++){sec = new StandardEntityCollection();
sec.add(new TitleEntity(hotspot,this));
if (val instanceof BlockResult){
EntityCollection ec = ((BlockResult) val).getEntityCollection();
if (ec != null && sec != null){
sec.addAll(ec);
((BlockResult) val).setEntityCollection(sec);protected void createAndAddEntity(double cursor, AxisState state,
PlotRenderingInfo plotState){
if (plotState == null || plotState.getOwner() == null) {
Rectangle2D hotspot = null;
if (edge.equals(RectangleEdge.TOP)){
hotspot = new Rectangle2D.Double(dataArea.getX(),
else if(edge.equals(RectangleEdge.BOTTOM)) {
hotspot = new Rectangle2D.Double(dataArea.getX(), cursor,
else if(edge.equals(RectangleEdge.LEFT)) {
hotspot = new Rectangle2D.Double(state.getCursor(),
else if(edge.equals(RectangleEdge.RIGHT)){
hotspot = new Rectangle2D.Double(cursor, dataArea.getY(),
EntityCollection e = plotState.getOwner().getEntityCollection();
if (e != null) {int row = validRows[v];
if (row < rowCount) {
Number n = data.getValue(row, column);
if (n != null) {
total += n.doubleValue();
int col = validCols[v];
if (col < colCount) {
Number n = data.getValue(row, col);
if (n != null) {
total += n.doubleValue();x1 = domainAxis.getCategorySeriesMiddle(column,dataset.getColumnCount(),
visibleRow, visibleRowCount,int visibleRowCount = state.getVisibleSeriesCount();
visibleRow, visibleRowCount,if (this.visibleSeries == null) {
return rowIndex;
int index = -1;
for (int vRow = 0; vRow < this.visibleSeries.length ; vRow++){
if (this.visibleSeries[vRow] == rowIndex) {
index = vRow;
break;
return index;
if (this.visibleSeries == null) {
return -1;
return this.visibleSeries.length;for (int row = 0; row < this.rowCount; row++){
if (isSeriesVisible(row)) {
visibleSeriesTemp[visibleSeriesCount] = row;
visibleSeriesCount++;int visibleRowCount = state.getVisibleSeriesCount();g2.scale(1/this.drawScaleFactor, 1/this.drawScaleFactor);if ((tick.getTickType() == TickType.MINOR) && isDomainMinorGridlinesVisible()){
else if ((tick.getTickType() == TickType.MAJOR) && isDomainGridlinesVisible()){protected void createAndAddEntity(Rectangle2D dataArea,
PlotRenderingInfo plotState, String toolTip, String urlText){
if (plotState != null && plotState.getOwner() != null) {
EntityCollection e = plotState.getOwner().getEntityCollection();
if (e != null) {if (! urls[i].sameFile(codeBase)) {TimeSeries series = new TimeSeries(name, start.getClass());
TimeSeries s1 = new TimeSeries("L&G European Index Trust", Month.class);
TimeSeries s2 = new TimeSeries("L&G UK Index Trust", Month.class);return super.clone();m.invoke(this, this.mouseWheelHandler);dataset, row, column);if ((mods & InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK) {
double wPercent = dx / this.panW;
p.panDomainAxes(wPercent, this.info.getPlotInfo(), this.panLast);
p.panRangeAxes(hPercent, this.info.getPlotInfo(), this.panLast);
p.panDomainAxes(-hPercent, this.info.getPlotInfo(), this.panLast);
p.panRangeAxes(-wPercent, this.info.getPlotInfo(), this.panLast);while (index < itemCount && dataset.getXValue(series, index)
< xLow) {
return Math.max(0, index - 1);
while (index >= 0 && dataset.getXValue(series, index)
> xHigh) {
return Math.min(itemCount - 1, index + 1);
public void testFindLiveItemsLowerBoundUnordered() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{1.0, 2.0}, {2.0, 2.0}});
assertEquals(0, RendererUtilities.findLiveItemsLowerBound(d, 2, 1.0,
assertEquals(0, RendererUtilities.findLiveItemsLowerBound(d, 2, 2.0,
d.addSeries("S4", new double[][] {{1.0, 2.0, 1.5}, {2.0, 2.0, 2.0}});
assertEquals(0, RendererUtilities.findLiveItemsLowerBound(d, 3, 2.0,
d.addSeries("S5", new double[][] {{1.0, 2.0, 1.5, 1.8}, {2.0, 2.0,
2.0, 2.0}});
assertEquals(0, RendererUtilities.findLiveItemsLowerBound(d, 4, 2.0,
public void testFindLiveItemsLowerBoundAscending() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{1.0, 2.0}, {2.0, 2.0}});
d.addSeries("S4", new double[][] {{1.0, 2.0, 3.0}, {2.0, 2.0, 2.0}});
d.addSeries("S5", new double[][] {{1.0, 2.0, 3.0, 4.0}, {2.0, 2.0,
2.0, 2.0}});
d.addSeries("S5", new double[][] {{1.0, 2.0, 2.0, 2.0, 3.0}, {2.0, 2.0,
2.0, 2.0, 2.0}});
public void testFindLiveItemsLowerBoundDescending() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{2.0, 1.0}, {2.0, 2.0}});
d.addSeries("S4", new double[][] {{3.0, 2.0, 1.0}, {2.0, 2.0, 2.0}});
d.addSeries("S5", new double[][] {{4.0, 3.0, 2.0, 1.0}, {2.0, 2.0,
2.0, 2.0}});
d.addSeries("S6", new double[][] {{3.0, 2.0, 2.0, 2.0, 1.0}, {2.0, 2.0,
2.0, 2.0, 2.0}});
public void testFindLiveItemsUpperBoundUnordered() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{1.0, 2.0}, {2.0, 2.0}});
assertEquals(1, RendererUtilities.findLiveItemsUpperBound(d, 2, 0.0,
assertEquals(1, RendererUtilities.findLiveItemsUpperBound(d, 2, 3.0,
d.addSeries("S4", new double[][] {{1.0, 2.0, 1.5}, {2.0, 2.0, 2.0}});
assertEquals(1, RendererUtilities.findLiveItemsUpperBound(d, 3, 0.0,
assertEquals(2, RendererUtilities.findLiveItemsUpperBound(d, 3, 2.0,
assertEquals(2, RendererUtilities.findLiveItemsUpperBound(d, 3, 3.0,
d.addSeries("S5", new double[][] {{1.0, 2.0, 1.5, 1.8}, {2.0, 2.0,
2.0, 2.0}});
assertEquals(1, RendererUtilities.findLiveItemsUpperBound(d, 4, 0.0,
assertEquals(3, RendererUtilities.findLiveItemsUpperBound(d, 4, 2.0,
assertEquals(3, RendererUtilities.findLiveItemsUpperBound(d, 4, 3.0,
assertEquals(3, RendererUtilities.findLiveItemsUpperBound(d, 4, 4.0,
public void testFindLiveItemsUpperBoundAscending() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{1.0, 2.0}, {2.0, 2.0}});
d.addSeries("S4", new double[][] {{1.0, 2.0, 3.0}, {2.0, 2.0, 2.0}});
d.addSeries("S5", new double[][] {{1.0, 2.0, 3.0, 4.0}, {2.0, 2.0,
2.0, 2.0}});
d.addSeries("S5", new double[][] {{1.0, 2.0, 2.0, 2.0, 3.0}, {2.0, 2.0,
2.0, 2.0, 2.0}});
public void testFindLiveItemsUpperBoundDescending() {
d.addSeries("S2", new double[][] {{1.0}, {2.0}});
d.addSeries("S3", new double[][] {{2.0, 1.0}, {2.0, 2.0}});
d.addSeries("S4", new double[][] {{3.0, 2.0, 1.0}, {2.0, 2.0, 2.0}});
d.addSeries("S5", new double[][] {{4.0, 3.0, 2.0, 1.0}, {2.0, 2.0,
2.0, 2.0}});
d.addSeries("S6", new double[][] {{3.0, 2.0, 2.0, 2.0, 1.0}, {2.0, 2.0,
2.0, 2.0, 2.0}});result = Math.min(result, hiY);assertEquals(1.0, xysc.getIntervalWidth());
s1.updateByIndex(0, -5.0);
s1.updateByIndex(0, 1.0);
s1.updateByIndex(0, 2.0);
s1.updateByIndex(0, 0.0);
s1.updateByIndex(1, 2.05);
s1.update(new Double(1.0), 1.0);
s1.update(new Double(1.0), 2.0);import org.jfree.chart.event.ChartChangeEvent;return value;
return labelOutlineStroke;public class DefaultHeatMapDataset extends AbstractDataset 
clone.zValues = DataUtilities.clone(zValues);return minX;
return maxX;
return minY;
return maxY;
this.minY = minIgnoreNaN(this.minY, yy);    return outlineVisible;for (int i = this.firstCategoryIndex; i < last; i++) {calendar.add(unit.getCalendarField(), unit.getCount());TimeSeries series1 = new TimeSeries("Series 1", Month.class);
TimeSeries series1 = new TimeSeries("Series 2", Month.class);drawRangeCrosshair(g2, dataArea, getOrientation(), y, yAxis, stroke, paint);if (pass==0 && item > 0) {new Paint[] { Color.decode("0xFFFF00"),
new Paint[] { Color.decode("0xFFFF00"),
new Stroke[] { new BasicStroke(2.0f)},
new Stroke[] { new BasicStroke(0.5f)},TimeSeriesCollection source, String suffix, int periodCount,
int skip) {
TimeSeries result = new TimeSeries(name, source.getTimePeriodClass());
TimeSeries result = new TimeSeries(name, source.getTimePeriodClass());g2.setFont(getFont());DefaultIntervalCategoryDataset d
= new DefaultIntervalCategoryDataset(starts, ends);
starts, ends);
starts, ends);
starts, ends);assertEquals("1.000", s);double[] stack1 = getStackValues(dataset, row, column);
double[] stack0 = getStackValues(dataset, row, Math.max(column - 1, 0));
itemCount - 1));
int series, int index) {= new DateTickUnit(DateTickUnit.DAY, 1, new SimpleDateFormat());
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 1, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 5,
DateTickUnit.MILLISECOND, 1, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 10,
DateTickUnit.MILLISECOND, 1, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 25,
DateTickUnit.MILLISECOND, 5, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 50,
DateTickUnit.MILLISECOND, 10, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 100,
DateTickUnit.MILLISECOND, 10, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 250,
DateTickUnit.MILLISECOND, 10, f1));
units.add(new DateTickUnit(DateTickUnit.MILLISECOND, 500,
DateTickUnit.MILLISECOND, 50, f1));
units.add(new DateTickUnit(DateTickUnit.SECOND, 1,
DateTickUnit.MILLISECOND, 50, f2));
units.add(new DateTickUnit(DateTickUnit.SECOND, 5,
DateTickUnit.SECOND, 1, f2));
units.add(new DateTickUnit(DateTickUnit.SECOND, 10,
DateTickUnit.SECOND, 1, f2));
units.add(new DateTickUnit(DateTickUnit.SECOND, 30,
DateTickUnit.SECOND, 5, f2));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 1,
DateTickUnit.SECOND, 5, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 2,
DateTickUnit.SECOND, 10, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 5,
DateTickUnit.MINUTE, 1, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 10,
DateTickUnit.MINUTE, 1, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 15,
DateTickUnit.MINUTE, 5, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 20,
DateTickUnit.MINUTE, 5, f3));
units.add(new DateTickUnit(DateTickUnit.MINUTE, 30,
DateTickUnit.MINUTE, 5, f3));
units.add(new DateTickUnit(DateTickUnit.HOUR, 1,
DateTickUnit.MINUTE, 5, f3));
units.add(new DateTickUnit(DateTickUnit.HOUR, 2,
DateTickUnit.MINUTE, 10, f3));
units.add(new DateTickUnit(DateTickUnit.HOUR, 4,
DateTickUnit.MINUTE, 30, f3));
units.add(new DateTickUnit(DateTickUnit.HOUR, 6,
DateTickUnit.HOUR, 1, f3));
units.add(new DateTickUnit(DateTickUnit.HOUR, 12,
DateTickUnit.HOUR, 1, f4));
units.add(new DateTickUnit(DateTickUnit.DAY, 1,
DateTickUnit.HOUR, 1, f5));
units.add(new DateTickUnit(DateTickUnit.DAY, 2,
DateTickUnit.HOUR, 1, f5));
units.add(new DateTickUnit(DateTickUnit.DAY, 7,
DateTickUnit.DAY, 1, f5));
units.add(new DateTickUnit(DateTickUnit.DAY, 15,
DateTickUnit.DAY, 1, f5));
units.add(new DateTickUnit(DateTickUnit.MONTH, 1,
DateTickUnit.DAY, 1, f6));
units.add(new DateTickUnit(DateTickUnit.MONTH, 2,
DateTickUnit.DAY, 1, f6));
units.add(new DateTickUnit(DateTickUnit.MONTH, 3,
DateTickUnit.MONTH, 1, f6));
units.add(new DateTickUnit(DateTickUnit.MONTH, 4,
DateTickUnit.MONTH, 1, f6));
units.add(new DateTickUnit(DateTickUnit.MONTH, 6,
DateTickUnit.MONTH, 1, f6));
units.add(new DateTickUnit(DateTickUnit.YEAR, 1,
DateTickUnit.MONTH, 1, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 2,
DateTickUnit.MONTH, 3, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 5,
DateTickUnit.YEAR, 1, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 10,
DateTickUnit.YEAR, 1, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 25,
DateTickUnit.YEAR, 5, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 50,
DateTickUnit.YEAR, 10, f7));
units.add(new DateTickUnit(DateTickUnit.YEAR, 100,
DateTickUnit.YEAR, 20, f7));if (!ObjectUtilities.equal(this.shape, that.shape)) {
if (!ObjectUtilities.equal(this.baseShape, that.baseShape)) {
r1.setShape(new Rectangle(1, 2, 3, 4));
r2.setShape(new Rectangle(1, 2, 3, 4));
r1.setSeriesShape(1, new Rectangle(1, 2, 3, 4));
r2.setSeriesShape(1, new Rectangle(1, 2, 3, 4));
r1.setBaseShape(new Rectangle(1, 2, 3, 4));
r2.setBaseShape(new Rectangle(1, 2, 3, 4));
r1.setLegendShape(0, new Line2D.Double(1.0, 2.0, 3.0, 4.0));
r2.setLegendShape(0, new Line2D.Double(1.0, 2.0, 3.0, 4.0));
r1.setBaseLegendShape(new Line2D.Double(5.0, 6.0, 7.0, 8.0));
r2.setBaseLegendShape(new Line2D.Double(5.0, 6.0, 7.0, 8.0));return zoomFillPaint;
if (!useBuffer) {int seriesCount = getRowCount();
RectangleEdge domainAxisLocation = plot.getDomainAxisEdge();
rectY = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, domainAxisLocation);
if (seriesCount > 1) {
double seriesGap = dataArea.getHeight() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectY = rectY + row * (state.getBarWidth() + seriesGap);
else {
rectY = rectY + row * state.getBarWidth();
rectX = domainAxis.getCategoryStart(column, getColumnCount(),
dataArea, domainAxisLocation);
if (seriesCount > 1) {
double seriesGap = dataArea.getWidth() * getItemMargin()
/ (categoryCount * (seriesCount - 1));
rectX = rectX + row * (state.getBarWidth() + seriesGap);
else {
rectX = rectX + row * state.getBarWidth();if (item == 0) {
if (this.drawSeriesLineAsPath) {
State s = (State) state;
s.seriesPath.reset();
s.lastPointGood = false;
if (item == dataset.getItemCount(series) - 1) {public ColumnArrangement() {   
public ColumnArrangement(HorizontalAlignment hAlign, 
double hGap, double vGap) {        
return arrangeNN(container, g2);  
throw new RuntimeException("Not implemented.");  
throw new RuntimeException("Not implemented.");  
throw new RuntimeException("Not implemented.");  
return arrangeFF(container, g2, constraint); 
throw new RuntimeException("Not implemented.");  
throw new RuntimeException("Not implemented.");  
return arrangeRF(container, g2, constraint);  
return arrangeRR(container, g2, constraint);  
return new Size2D(x + maxWidth, constraint.getHeight());  
return s;   
height = height + this.verticalGap * (blockCount - 1);   
if (this.horizontalAlignment 
else if (this.horizontalAlignment 
return true;   
return false;   
return false;   
return false;   if (clip == null)
public void setTransform(AffineTransform Tx) {
Transform transform = getSwtTransformFromPool(Tx);
public void transform(AffineTransform Tx) {
swtTransform.multiply(getSwtTransformFromPool(Tx));int index = ((int) Math.floor(direction / 11.25) + 1) / 2; 
public StringBuffer format(double number, StringBuffer toAppendTo, 
public StringBuffer format(long number, StringBuffer toAppendTo, protected static ResourceBundle localizationResources 
TextTitle t = (title != null ? (TextTitle) title 
this.titleFont = SWTUtils.toSwtFontData(getDisplay(), t.getFont(), 
this.showTitleCheckBox.setLayoutData(new GridData(SWT.CENTER, 
this.titleField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, 
this.fontField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, 
dlg.setFontList(new FontData[] { 
SWTTitleEditor.this.titleFont 
final SWTPaintCanvas colorCanvas = new SWTPaintCanvas(general, 
GridData canvasGridData = new GridData(SWT.FILL, SWT.CENTER, true, 
title.setFont(SWTUtils.toAwtFont(getDisplay(), getTitleFont(), public class IntervalMarkerTests 
extends TestCase 
public class ValueMarkerTests 
extends TestCase 
m1.setPaint(new GradientPaint(1.0f, 2.0f, Color.green, 
m2.setPaint(new GradientPaint(1.0f, 2.0f, Color.green, 
m1.setOutlinePaint(new GradientPaint(4.0f, 3.0f, Color.yellow, 
m2.setOutlinePaint(new GradientPaint(4.0f, 3.0f, Color.yellow, 
m1.setLabelPaint(new GradientPaint(1.0f, 2.0f, Color.blue, 
m2.setLabelPaint(new GradientPaint(1.0f, 2.0f, Color.blue, 
ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, point0.x = domainAxis.valueToJava2D(dataset.getXValue(series, 
point0.y = rangeAxis.valueToJava2D(dataset.getYValue(series, 
point3.x = domainAxis.valueToJava2D(dataset.getXValue(series, 
point3.y = rangeAxis.valueToJava2D(dataset.getYValue(series, 
int steps = ((int) ((point2.x - point1.x) / 0.2) < 30) 
Point2D.Double[] points = getBezierCurve(point0, point1, point2, 
public static void getControlPoints(Point2D.Double point0, 
Point2D.Double point1, Point2D.Double point2, 
Point2D.Double point1, Point2D.Double point2, 
getControlPoints(point0, point1, point2, point3, control1, control2, 
Point2D.Double B = new Point2D.Double(3 * (control2.x - control1.x) 
Point2D.Double A = new Point2D.Double(point2.x - point1.x - C.x - B.x, 
res[i] = new Point2D.Double(A.x * Math.pow(step, 3) + B.x public class DefaultPieDatasetTests extends TestCase ); 
assertTrue(e1.equals(e2));  
assertTrue(e1.equals(e2));  
assertTrue(e1.equals(e2));  
assertTrue(e1.equals(e2));  
assertTrue(e1.equals(e2));  
); 
); 
ChartPanel panel = new ChartPanel(null); 
pass = true;    
public class CategoryMarkerTests extends TestCase 
m1 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m2 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m1 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m2 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m1 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m2 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m1 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m2 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m1 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
m2 = new CategoryMarker("A", new GradientPaint(1.0f, 2.0f, Color.white, 
CategoryMarker m1 = new CategoryMarker("A", new GradientPaint(1.0f, 
2.0f, Color.white, 3.0f, 4.0f, Color.yellow), 
CategoryMarker m1 = new CategoryMarker("A", new GradientPaint(1.0f, 
2.0f, Color.white, 3.0f, 4.0f, Color.yellow), public class VectorSeriesTests extends TestCase 
VectorSeries s2 = null;        
assertEquals(0, s1.indexOf(new XYCoordinate(1.0, 1.0)));        
assertEquals(1, s1.indexOf(new XYCoordinate(3.0, 3.0)));        
assertEquals(2, s1.indexOf(new XYCoordinate(2.0, 2.0)));        
assertEquals(3.0, s1.getXValue(0), EPSILON);    
public class XYIntervalSeriesTests extends TestCase  
assertEquals(0, s1.indexOf(new Double(1.0)));        
assertEquals(1, s1.indexOf(new Double(3.0)));        
assertEquals(2, s1.indexOf(new Double(2.0)));        
assertEquals(new Double(3.0), s1.getX(0));    
public class YIntervalSeriesTests extends TestCase   
assertEquals(0, s1.indexOf(new Double(1.0)));        
assertEquals(1, s1.indexOf(new Double(3.0)));        
assertEquals(2, s1.indexOf(new Double(2.0)));        
assertEquals(new Double(3.0), s1.getX(0));    JFreeChart chart1 = new JFreeChart("Title", 
JFreeChart chart2 = new JFreeChart("Title", 
RenderingHints.KEY_TEXT_ANTIALIASING, 
RenderingHints.KEY_TEXT_ANTIALIASING, 
chart1 = new JFreeChart("Title", 
chart2 = new JFreeChart("Title", 
chart2 = new JFreeChart("Title", 
chart1.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.red, 
chart2.setBackgroundPaint(new GradientPaint(1.0f, 2.0f, Color.red, 
JFreeChart chart1 = new JFreeChart("Title", 
JFreeChart chart2 = new JFreeChart("Title", 
JFreeChart chart = ChartFactory.createPieChart("title", dataset, true, 
JFreeChart c1 = ChartFactory.createPieChart("Test", data, true, true, 
JFreeChart c1 = ChartFactory.createTimeSeriesChart("Test", "Date", 
JFreeChart chart = ChartFactory.createPieChart("title", dataset, true, 
JFreeChart chart = ChartFactory.createPieChart("title", dataset, true, 
JFreeChart chart = ChartFactory.createPieChart("title", dataset, true, 
JFreeChart chart = ChartFactory.createPieChart("title", dataset, true, foundData = render(g2, dataArea, i, state) || foundData;
foundData = render(g2, dataArea, i, state) || foundData;
drawRangeCrosshair(g2, dataArea, getOrientation(),
getRangeCrosshairValue(), getRangeAxis(),
getRangeCrosshairStroke(), getRangeCrosshairPaint());
PlotRenderingInfo info) {
plot.draw(g2, this.subplotAreas[i], null, parentState, subplotInfo);
plot.draw(g2, this.subplotArea[i], null, parentState, subplotInfo);
double value = dataValue.doubleValue();
CategoryItemLabelGenerator generator
= getItemLabelGenerator(row, column);
if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
else if (plot.getOrientation() == PlotOrientation.VERTICAL) {private Date lowerDate;
private Date upperDate;
this.lowerDate = lower;
this.upperDate = upper;
this.lowerDate = new Date((long) lower);
this.upperDate = new Date((long) upper);
return this.lowerDate;
return this.upperDate;
return "[" + df.format(this.lowerDate) + " --> "
+ df.format(this.upperDate) + "]";
private Date time;
this.time = time;
return this.time;
long t = this.time.getTime();
long t = this.time.getTime();
return this.time.equals(m.getTime());
return this.time.hashCode();
difference = this.time.getTime() - t1.time.getTime();
return this.time.getTime();
return this.time.getTime();
return this.time.getTime();
return this.time.getTime();
return this.time.getTime();
return this.time.getTime();
return this.time.getTime();
new ByteArrayInputStream(buffer.toByteArray())
);
System.out.println(e.toString());
new ByteArrayInputStream(buffer.toByteArray())
);
System.out.println(e.toString());assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);assertTrue(a1 instanceof PublicCloneable);ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer();buffer.toByteArray()));ThermometerPlot p1 = new ThermometerPlot();
ThermometerPlot p2 = new ThermometerPlot();
assertTrue(p1.equals(p2));
assertTrue(p2.equals(p1));
XYPlot plot = new XYPlot();
assertFalse(plot.removeDomainMarker(new ValueMarker(0.5)));
XYPlot plot = new XYPlot();
assertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));NumberFormat.getInstance());
NumberFormat.getInstance());
new DecimalFormat("0.000"));
new DecimalFormat("0.000"));
HighLowItemLabelGenerator g1 = new HighLowItemLabelGenerator();
HighLowItemLabelGenerator g2 = new HighLowItemLabelGenerator();
new DecimalFormat("0.000"));
new DecimalFormat("0.000"));
new SimpleDateFormat("d-MMM"));
new SimpleDateFormat("d-MMM"));
IntervalCategoryItemLabelGenerator g1
= new IntervalCategoryItemLabelGenerator();
IntervalCategoryItemLabelGenerator g2
= new IntervalCategoryItemLabelGenerator();
MultipleXYSeriesLabelGenerator g1
= new MultipleXYSeriesLabelGenerator();
MultipleXYSeriesLabelGenerator g2
= new MultipleXYSeriesLabelGenerator();
StandardCategoryItemLabelGenerator g1
= new StandardCategoryItemLabelGenerator();
StandardCategoryItemLabelGenerator g2
= new StandardCategoryItemLabelGenerator();
StandardCategorySeriesLabelGenerator g1
= new StandardCategorySeriesLabelGenerator();
StandardCategorySeriesLabelGenerator g2
= new StandardCategorySeriesLabelGenerator();
StandardCategoryToolTipGenerator g1
= new StandardCategoryToolTipGenerator();
StandardCategoryToolTipGenerator g2
= new StandardCategoryToolTipGenerator();
StandardPieSectionLabelGenerator g1
= new StandardPieSectionLabelGenerator();
StandardPieSectionLabelGenerator g2
= new StandardPieSectionLabelGenerator();
StandardPieToolTipGenerator g1
= new StandardPieToolTipGenerator();
StandardPieToolTipGenerator g2
= new StandardPieToolTipGenerator();
StandardXYItemLabelGenerator g1
= new StandardXYItemLabelGenerator();
StandardXYItemLabelGenerator g2
= new StandardXYItemLabelGenerator();
StandardXYSeriesLabelGenerator g1
= new StandardXYSeriesLabelGenerator();
StandardXYSeriesLabelGenerator g2
= new StandardXYSeriesLabelGenerator();
StandardXYToolTipGenerator g1
= new StandardXYToolTipGenerator();
StandardXYToolTipGenerator g2
= new StandardXYToolTipGenerator();
StandardXYZToolTipGenerator g1
= new StandardXYZToolTipGenerator();
StandardXYZToolTipGenerator g2
= new StandardXYZToolTipGenerator();
SymbolicXYItemLabelGenerator g1
= new SymbolicXYItemLabelGenerator();
SymbolicXYItemLabelGenerator g2
= new SymbolicXYItemLabelGenerator();assertFalse(r1.equals(new Double(0.0)));        assertEquals(hd.getYValue(0, 0), 3.0, EPSILON);        
assertEquals(hd.getYValue(0, 1), 3.0, EPSILON);        
assertEquals(hd.getYValue(0, 2), 2.0, EPSILON);        
assertEquals(hd.getYValue(0, 3), 0.0, EPSILON);        
assertEquals(hd.getYValue(0, 4), 1.0, EPSILON);        
d1.addSeries("Series 1", values, 5);   
double[] values = { -5.000000000000286E-5 };
assertTrue(values[0] < d.getEndXValue(0, 630));        assertTrue(Double.isNaN(Statistics.calculateMean(new Number[0], 
Number[] values = new Number[] { new Double(1.0) };
values = new Number[] { new Double(1.0), null };
values = new Number[] { new Double(1.0), new Double(Double.NaN) };
data1[2] = new Double(3);        
data2[2] = new Double(3);    
assertEquals(1.0, r, 0.00000001);        
data1[2] = new Double(62);        
data1[3] = new Double(75);        
data1[4] = new Double(58);        
data1[5] = new Double(60);        
data1[6] = new Double(67);        
data1[7] = new Double(68);        
data1[8] = new Double(71);        
data1[9] = new Double(69);        
data1[10] = new Double(68);        
data1[11] = new Double(67);        
data1[12] = new Double(63);        
data1[13] = new Double(62);        
data1[14] = new Double(60);        
data1[15] = new Double(63);        
data1[16] = new Double(65);        
data1[17] = new Double(67);        
data1[18] = new Double(63);        
data1[19] = new Double(61);        
data2[2] = new Double(3.8);    
data2[3] = new Double(4.4);    
data2[4] = new Double(3.2);    
data2[5] = new Double(3.1);    
data2[6] = new Double(3.8);    
data2[7] = new Double(4.1);    
data2[8] = new Double(4.3);    
data2[9] = new Double(3.7);    
data2[10] = new Double(3.5);    
data2[11] = new Double(3.2);    
data2[12] = new Double(3.7);    
data2[13] = new Double(3.3);    
data2[14] = new Double(3.4);    
data2[15] = new Double(4.0);    
data2[16] = new Double(4.1);    
data2[17] = new Double(3.8);    
data2[18] = new Double(3.4);    
data2[19] = new Double(3.6);    
assertEquals(0.7306356862792885, r, 0.000000000001);        
assertTrue(Double.isNaN(Statistics.getStdDev(new Double[] new DecimalFormat("0.0"));
new DecimalFormat("0.0"));
new DecimalFormat("0.0"));
new DecimalFormat("0.0"));
new DecimalFormat("0.00"));
new SimpleDateFormat("yyyy"), new DecimalFormat("0.0"));
BoxAndWhiskerXYToolTipGenerator g1
= new BoxAndWhiskerXYToolTipGenerator();
BoxAndWhiskerXYToolTipGenerator g2
= new BoxAndWhiskerXYToolTipGenerator();43.0));
Color.red, new BasicStroke(1.0f)));
Color.red, new BasicStroke(1.0f)));
AxisSpace da1 = new AxisSpace();
AxisSpace ra1 = new AxisSpace();
LegendItemCollection c1 = new LegendItemCollection();
new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), true, Color.red,
true, Color.yellow, new BasicStroke(1.0f), true,
new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(1.0f),
Color.green));
true, new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0), true,
Color.red, true, Color.yellow, new BasicStroke(1.0f), true,
new Line2D.Double(1.0, 2.0, 3.0, 4.0), new BasicStroke(1.0f),
Color.green));
CategoryPlot plot = new CategoryPlot();
assertFalse(plot.removeDomainMarker(new CategoryMarker("Category 1")));
CategoryPlot plot = new CategoryPlot();
assertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));ShortTextTitle t1 = new ShortTextTitle("ABC");
ShortTextTitle t2 = new ShortTextTitle("ABC");
ShortTextTitle t1 = new ShortTextTitle("ABC");
ShortTextTitle t1 = new ShortTextTitle("ABC");OHLCDataItem item1 = new OHLCDataItem(new Date(1L), 1.0, 2.0, 3.0, 4.0,
5.0);
OHLCDataItem item2 = new OHLCDataItem(new Date(2L), 6.0, 7.0, 8.0, 9.0,
10.0);
OHLCDataItem[] items = new OHLCDataItem[] {item2, item1};
return new Object[] { new Long(t.getMiddleMillisecond()),
new Integer(dir), new Integer(force) };
SeriesChangeEvent lastEvent;
SeriesChangeEvent lastEvent;
XIntervalSeries s1 = new XIntervalSeries("S1");
XIntervalSeries s1 = new XIntervalSeries("S1");
XIntervalSeries s1 = new XIntervalSeries("S1");
d1.addSeries("S2", new double[][] { {1.0}, {2.0} });
d2.addSeries("S2", new double[][] { {1.0}, {2.0} });Locale saved = Locale.getDefault();
Locale.setDefault(Locale.UK);
try {
finally {
Locale.setDefault(saved);
Locale saved = Locale.getDefault();
Locale.setDefault(Locale.UK);
try {
finally {
Locale.setDefault(saved);
TimeZone zone = TimeZone.getTimeZone("America/Los_Angeles");
Locale.setDefault(saved);(float) size.width, (float) size.height), 
rendererIndex, toolTip, url);BubbleXYItemLabelGenerator g1
= new BubbleXYItemLabelGenerator();
BubbleXYItemLabelGenerator g2
= new BubbleXYItemLabelGenerator();BufferedImage.TYPE_INT_RGB);
BufferedImage.TYPE_INT_RGB);double[][] s1 = new double[][] { x, y, z };
double[][] s2 = new double[][] { x, y, z };
double[][] s3 = new double[][] { x, y, z };
double[][] s4 = new double[][] { x, y, z };
double[][] s5 = new double[][] { x, y, z };
BufferedImage.TYPE_INT_RGB);
assertFalse(g1 instanceof PublicCloneable);
assertFalse(g1 instanceof PublicCloneable);
assertFalse(g1 instanceof PublicCloneable);
dataset.addSeries("Series '1'", new double[][] { {1.0, 2.0},
assertFalse(g1 instanceof PublicCloneable);private AxisChangeEvent lastEvent;
this.lastEvent = event;	
new SimpleDateFormat("MMM"));
new SimpleDateFormat("yyyy"));
PeriodAxis axis = new PeriodAxis("TestAxis");
axis.addChangeListener(this);
this.lastEvent = null;
axis.setRange(new DateRange(0L, 1000L));
assertTrue(this.lastEvent != null);double[] a1 = new double[] { 1.0 };
double[] a2 = new double[] { 1.0 };
double[] a3 = new double[] { 0.5, 1.0 };this.zoomInBothMenuItem.setEnabled(
isDomainZoomable & isRangeZoomable
);
this.canvas.getShell(), SWT.OK | SWT.ICON_ERROR);
this.getBounds().width, this.getBounds().height );
|| s!=null && !s.equals(this.canvas.getToolTipText()))
|| this.chartBufferHeight != available.height ) {
(NumberAxis) axis );
this.otherEditor.updateChartProperties(chart );
if (! validateMaximum(this.maximumRangeValue.getText()))
if (! this.autoRange)
private final static String[] orientationNames = { "Vertical", 
"Horizontal" };
p.setOrientation(this.plotAppearance.getPlotOrientation() );
this.gc.setAlpha((int) (color.getAlpha()*acomp.getAlpha()));
int alpha = (int) (acomp.getAlpha()*0xFF);
this.gc.drawLine(xPoints[npoints-1], yPoints[npoints-1], 
+ "setting paint to uniform black color" );
(int) Math.round(rect2d.getHeight())
);this( 
comp, 
style,
chart,
DEFAULT_WIDTH,
DEFAULT_HEIGHT,
DEFAULT_MINIMUM_DRAW_WIDTH,
DEFAULT_MINIMUM_DRAW_HEIGHT,
DEFAULT_MAXIMUM_DRAW_WIDTH,
DEFAULT_MAXIMUM_DRAW_HEIGHT,
DEFAULT_BUFFER_USED,
true,  // properties
true,  // save
true,  // print
true,  // zoom
true   // tooltips
String[] extensions = { "*.png" };
(selection.y + selection.height/2));
(this.zoomPoint != null ? this.zoomPoint : 
new org.eclipse.swt.graphics.Point(0,0));
(this.zoomPoint != null ? this.zoomPoint : 
new org.eclipse.swt.graphics.Point(0,0));
public void setDisplayToolTips( boolean displayToolTips ) {
MessageBox messageBox = new MessageBox( 
this.canvas.getShell(), SWT.OK | SWT.ICON_ERROR );
messageBox.setMessage( e.getMessage() );
zoomInBoth( e.x, e.y );
zoomInDomain( e.x, e.y );
zoomInRange( e.x, e.y );
zoomOutBoth( e.x, e.y );
zoomOutDomain( e.x, e.y );
zoomOutRange( e.x, e.y );
if ( drawWidth == 0.0 || drawHeight == 0.0 ) return;
this.chartBuffer = new org.eclipse.swt.graphics.Image( 
public static void main( String[] args ) 
chart.setBackgroundPaint( Color.white );
chart.setBorderVisible( true );
chart.setBorderPaint( Color.BLACK );
chart.addSubtitle( subtitle );
public static void main( String[] args ) 
public static void main( String[] args ) 
dlg.setText( localizationResources.getString(
this.showTickMarksCheckBox.setLayoutData(new GridData( SWT.FILL, 
item2.setText(" " + localizationResources.getString( "Plot" ) + " ");
this.autoRangeCheckBox.addSelectionListener( 
new SelectionAdapter() {
public void widgetSelected(SelectionEvent e) { 
toggleAutoRange();
if (! validateMinimum( this.minimumRangeValue.getText()))
general.setText( localizationResources.getString("General"));
this.orientation.addSelectionListener( 
XYPlot p = ( XYPlot ) plot;
this.setData( stroke );
setLayout( layout );
swtTransform.rotate( (float) (theta * 180 / Math.PI));
this.gc.drawString(text, (int) x, (int) ( y - fm ), true);PublicCloneable{CategoryPlot l_subplot = (CategoryPlot)l_itr.next();
XYPlot l_subplot = (XYPlot)l_itr.next();
XYPlot l_subplot = (XYPlot)l_itr.next();import org.jfree.chart.plot.CombinedXYPlot;a1.setMinorTickCount(9);
a2.setMinorTickCount(9);
axis.setRange(50.0, 100.0); 
double y1 = axis.java2DToValue(75.0, dataArea, RectangleEdge.LEFT);  
assertEquals(94.3874312681693, y1, EPSILON); 
double y2 = axis.java2DToValue(75.0, dataArea, RectangleEdge.RIGHT);   
assertEquals(94.3874312681693, y2, EPSILON); 
double x1 = axis.java2DToValue(75.0, dataArea, RectangleEdge.TOP);   
assertEquals(55.961246381405, x1, EPSILON); 
double x2 = axis.java2DToValue(75.0, dataArea, RectangleEdge.BOTTOM);   
assertEquals(55.961246381405, x2, EPSILON); 
double y3 = axis.java2DToValue(75.0, dataArea, RectangleEdge.LEFT);  
assertEquals(52.9731547179647, y3, EPSILON); 
double y4 = axis.java2DToValue(75.0, dataArea, RectangleEdge.RIGHT);   
assertEquals(52.9731547179647, y4, EPSILON); 
double x3 = axis.java2DToValue(75.0, dataArea, RectangleEdge.TOP);   
assertEquals(89.3475453695651, x3, EPSILON); 
double x4 = axis.java2DToValue(75.0, dataArea, RectangleEdge.BOTTOM);   
assertEquals(89.3475453695651, x4, EPSILON); 
"Test", 
false, 
assertEquals(0.0, axis.getLowerBound(), EPSILON);    
assertEquals(2.6066426411261268E7, axis.getUpperBound(), EPSILON); 
assertEquals(96.59363289248458, axis.getLowerBound(), EPSILON);    
assertEquals(207.0529847682752, axis.getUpperBound(), EPSILON);    
assertEquals(895.2712433374774, axis.getLowerBound(), EPSILON);    
assertEquals(1005.2819262292991, axis.getUpperBound(), EPSILON);    
"Test", 
false, 
assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);    
assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);    
"Test", 
false, 
assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);    
assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);    public class CandlestickRenderer extends AbstractXYItemRenderer 
implements XYItemRenderer, 
return this.volumePaint;    
if (paint == null) { 
this.maxCandleWidth = Math.abs(xx2 - xx1); 
for (int series = 0; series < highLowDataset.getSeriesCount(); 
for (int item = 0; item < highLowDataset.getItemCount(series); 
public void drawItem(Graphics2D g2, 
XYPlot plot, 
ValueAxis domainAxis, 
XYDataset dataset, 
int series, 
highLowData.getXValue(series, i), dataArea, 
xxWidth = Math.min(xxWidth, 
IntervalXYDataset intervalXYData 
intervalXYData.getStartXValue(series, item), 
intervalXYData.getEndXValue(series, item), 
body = new Rectangle2D.Double(yyMinOpenClose, xx - stickWidth / 2, 
XYItemEntity entity = new XYItemEntity(body, dataset, series, item, 
if (this.maxCandleWidthInMilliseconds 
private void readObject(ObjectInputStream stream) 
public static PieDataset createPieDatasetForRow(CategoryDataset dataset, 
public static PieDataset createPieDatasetForRow(CategoryDataset dataset, 
public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, 
public static PieDataset createConsolidatedPieDataset(PieDataset source, 
if (otherKeys.contains(currentKey) 
public static CategoryDataset createCategoryDataset(Comparable rowKey, 
public static XYDataset sampleFunction2D(Function2D f, double start, 
throw new IllegalArgumentException("Null 'f' argument.");   
public static Range findDomainBounds(XYDataset dataset, 
public static Range iterateDomainBounds(XYDataset dataset, 
throw new IllegalArgumentException("Null 'dataset' argument.");   
public static Range findRangeBounds(CategoryDataset dataset, 
public static Range findRangeBounds(XYDataset dataset, 
public static Range iterateCategoryRangeBounds(CategoryDataset dataset, 
public static Range iterateRangeBounds(CategoryDataset dataset, 
public static Range iterateRangeBounds(XYDataset dataset, 
if (!Double.isNaN(uvalue)) {     
double uvalue = ohlc.getLowValue(series, item);
if (!Double.isNaN(uvalue)) {     
IntervalXYDataset intervalXYData 
IntervalXYDataset intervalXYData 
IntervalCategoryDataset icd 
IntervalXYDataset intervalXYData 
IntervalCategoryDataset icd 
IntervalXYDataset intervalXYData 
public static Range findStackedRangeBounds(CategoryDataset dataset, 
negative = negative + value;  
);   
positive[groupIndex[series]] 
negative[groupIndex[series]] 
total = total + value;  
public static Range findStackedRangeBounds(TableXYDataset dataset, 
return null;   
boolean allItemsNull = true; // we'll set this to false if there is at 
for (int column = 0; column <= dataset.getColumnCount() - 1; if (isOverlap()) {
adjustInwards();
record1.setAllocatedY(Math.min(minY + height, 
record1.setAllocatedY(Math.max(minY, record0.getLowerY() 
double gap = Math.max(0, height - sumOfLabelHeights);public static XYDataset sampleFunction2D(Function2D f, 
double start, 
double end, 
int samples,
Comparable seriesKey) {
double step = (end - start) / samples;
for (int i = 0; i <= samples; i++) {implements IntervalCategoryDataset {
this.seriesKeys = null;
this.categoryKeys = null;
if (categoryKeys.length != this.startData[0].length) {g2.setClip(this.dialFrame.getWindow(frame));
g2.setClip(this.dialFrame.getWindow(frame));
g2.setClip(this.dialFrame.getWindow(frame));
g2.setClip(this.dialFrame.getWindow(frame));public class XYPlot extends Plot implements ValueAxisPlot,
Zoomable,
RendererChangeListener,
Cloneable, PublicCloneable,
Serializable {
double x = this.quadrantOrigin.getX();
double y = this.quadrantOrigin.getY();this.seriesToGroupMap.getGroup(plot.getDataset().getRowKey(row))
);plot.setFixedRangeAxisSpace(space);
plot.setFixedDomainAxisSpace(space);
notifyListeners(new PlotChangeEvent(this));
notifyListeners(new PlotChangeEvent(this));Object clone = createCopy(0, getItemCount() - 1);item = series.getDataItem(-1);
item = series.getDataItem(1);s1 = new ComparableObjectSeries(null);public class CategoryMarkerTests 
extends TestCase 
implements MarkerChangeListener {Paint seriesPaint = getItemPaint(row, column);
g2.setPaint(seriesPaint);
if (state.getBarWidth() > 3) {
g2.setStroke(getItemStroke(row, column));
g2.setPaint(getItemOutlinePaint(row, column));
g2.draw(bar);
Paint seriesPaint = getItemPaint(row, column);
g2.setPaint(seriesPaint);
if (state.getBarWidth() > 3) {
g2.setStroke(getItemStroke(row, column));
g2.setPaint(getItemOutlinePaint(row, column));
g2.draw(bar);plot.setFixedRangeAxisSpace(space);
plot.setFixedDomainAxisSpace(space);boolean b = e1.equals(e2);import org.jfree.chart.entity.XYItemEntity;System.out.println(sdf.equals("X"));double v = axis.valueToJava2D(value, dataArea, plot.getDomainAxisEdge());series.setValue(key + " (" + (percentChange >= 0 ? "+" : "") 
series.setValue(key + " (" + (percentChange >= 0 ? "+" : "") if (isTickMarksVisible() && tick.getTickType().equals(TickType.MAJOR)) {position.getLabelAnchor(), position.getRotationAnchor(), 
position.getAngle());public StandardXYToolTipGenerator(String formatString, NumberFormat xFormat, 
NumberFormat yFormat) {this.drawShapes = BooleanUtilities.valueOf(r.getBaseShapesVisible());
JButton button = new JButton(localizationResources.getString("Select..."));public String generateURL(PieDataset dataset, Comparable key, int pieIndex) {Arc2D inner = new Arc2D.Double(innerFrame, this.startAngle, this.extent, 
Arc2D.OPEN);this.gradientPaintTransformer = new StandardGradientPaintTransformer();        
p = this.gradientPaintTransformer.transform((GradientPaint) p, view);this.itemMargin, dataArea, plot.getDomainAxisEdge());            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, 
data, row, column);Shape area = new Rectangle((int) (point.getX() - headW), block.draw(g2, (float) area.getCenterX(), (float) area.getCenterY(), 
TextBlockAnchor.CENTER);throw new IllegalArgumentException("Null 'stroke' not permitted.");   
throw new IllegalArgumentException("Null 'annotation' argument.");   protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, 
Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state) {
Rectangle2D out = this.labelPadding.createOutsetRectangle(bounds);return Collections.binarySearch(this.data, new XYDataItem(x, null));   return Collections.binarySearch(this.data, new ComparableObjectItem(x, null));   
ComparableObjectItem item = (ComparableObjectItem) this.data.get(i);
ComparableObjectItem result = (ComparableObjectItem) this.data.remove(index);throw new IllegalArgumentException("Null 'periodClass' argument.");   
throw new IllegalArgumentException("Null 'dateFormat' argument.");   
throw new IllegalArgumentException("Null 'padding' argument.");   
throw new IllegalArgumentException("Null 'labelFont' argument.");   
throw new IllegalArgumentException("Null 'labelPaint' argument.");   
throw new IllegalArgumentException("Null 'dividerStroke' argument.");   
throw new IllegalArgumentException("Null 'dividerPaint' argument.");   this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);                
this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);                        
line = new Line2D.Double(y0, x0, y1, x1);                            EntityCollection entities = info.getOwner().getEntityCollection();? lookupSeriesFillPaint(series) : lookupSeriesPaint(series));throw new RuntimeException("Not yet implemented.");                 
throw new RuntimeException("Not yet implemented.");                 
throw new RuntimeException("Not yet implemented.");                 
entity = new ChartEntity(area, this.toolTipText, this.urlText);    throw new RuntimeException("Not yet implemented.");                 
throw new RuntimeException("Not yet implemented.");                 
throw new RuntimeException("Not yet implemented.");                 if (! (obj instanceof StackedAreaRenderer)) {+ this.extent, - this.extent, Arc2D.OPEN);
+ angleMargin + this.extent, - this.extent - 2 * angleMargin, 
throw new IllegalArgumentException("" +
"The 'radius' must be positive.");markers = (ArrayList)this.backgroundDomainMarkers.get(new Integer(
markers = (ArrayList)this.foregroundRangeMarkers.get(new Integer(
markers = (ArrayList)this.backgroundRangeMarkers.get(new Integer(if (!ObjectUtilities.equal(this.stroke, that.stroke)){double lengthLog = switchedLog10(getRange().getUpperBound()) -
startLog;public HexNumberFormat(){markers = (ArrayList)this.backgroundDomainMarkers.get(new Integer(
markers = (ArrayList)this.foregroundRangeMarkers.get(new Integer(
markers = (ArrayList)this.backgroundRangeMarkers.get(new Integer(if( !this.points. contains(p))result = result * 37 + (this.renderAsPercentages ? 1 : 0 );l_path.moveTo((float)l_x, (float)l_y);
(Double)l_yValues[i]).doubleValue(), x_dataArea, 
l_path.lineTo((float)l_x, (float)l_y);
(Double)l_xValues[0]).doubleValue(), x_dataArea, 
(Double)l_yValues[0]).doubleValue(), x_dataArea, 
l_path.moveTo((float)l_y, (float)l_x);
l_path.lineTo((float)l_y, (float)l_x);Point2D anchorPoint = (Point2D) RectangleAnchor.coordinates(imageRect, Point2D anchorPoint = (Point2D) RectangleAnchor.coordinates(titleRect, label = new Text(general, SWT.BORDER);
label.setText(axis.getLabel());
label.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
labelFontField = new Text(general, SWT.BORDER);
labelFontField.setText(this.labelFont.toString());
labelFontField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, 
false));
dlg.setFontList(new FontData[] { labelFont });
if (font != null) {
font.dispose();
font = new Font(getShell().getDisplay(), 
dlg.getFontList());
labelFontField.setText(
font.getFontData()[0].toString());
labelFont = font.getFontData()[0];
dlg.setRGB(labelPaintColor.getRGB());
labelPaintColor = new Color(getDisplay(), rgb);
colorCanvas.setColor(labelPaintColor);
otherTabs = new TabFolder(other, SWT.NONE);
TabItem item1 = new TabItem(otherTabs, SWT.NONE);
Composite ticks = new Composite(otherTabs, SWT.NONE);
showTickLabelsCheckBox = new Button(ticks, SWT.CHECK);
showTickLabelsCheckBox.setText(localizationResources.getString(
showTickLabelsCheckBox.setSelection(axis.isTickLabelsVisible());
showTickLabelsCheckBox.setLayoutData(new GridData(SWT.FILL, SWT.CENTER,
true, false, 3, 1));
tickLabelFontField = new Text(ticks, SWT.BORDER);
tickLabelFontField.setText(this.tickLabelFont.toString());
tickLabelFontField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, 
dlg.setFontList(new FontData[] {tickLabelFont});
if (font != null) font.dispose();
font = new Font(getShell().getDisplay(), 
dlg.getFontList());
tickLabelFontField.setText(
font.getFontData()[0].toString());
tickLabelFont = font.getFontData()[0];
showTickMarksCheckBox = new Button(ticks, SWT.CHECK);
showTickMarksCheckBox.setText(localizationResources.getString(
showTickMarksCheckBox.setSelection(axis.isTickMarksVisible());
showTickMarksCheckBox.setLayoutData(new GridData( SWT.FILL, SWT.CENTER,
true, false, 3, 1));
return SWTUtils.toAwtFont(getDisplay(), tickLabelFont, true);
axis.setTickMarksVisible(showTickMarksCheckBox.getSelection());
axis.setTickLabelsVisible(showTickLabelsCheckBox.getSelection());
shell = new Shell(display, SWT.DIALOG_TRIM);
shell.setSize(400, 500);
shell.setText(ResourceBundle.getBundle(
shell.setLayout(layout);
Composite main = new Composite(shell, SWT.NONE);
titleEditor = new SWTTitleEditor(tab, SWT.NONE, chart.getTitle());
item1.setControl(titleEditor);
plotEditor = new SWTPlotEditor(tab, SWT.NONE, chart.getPlot());
item2.setControl(plotEditor);
otherEditor = new SWTOtherEditor(tab, SWT.NONE, chart);
item3.setControl(otherEditor);
Button ok = new Button(shell, SWT.PUSH | SWT.OK);
updateChart(chart);
shell.dispose();
Button cancel = new Button(shell, SWT.PUSH);
shell.dispose();
shell.open();
shell.layout();
while (!shell.isDisposed()) {
if (!shell.getDisplay().readAndDispatch()) {
shell.getDisplay().sleep();
autoRangeCheckBox = new Button(range, SWT.CHECK);
autoRangeCheckBox.setText(localizationResources.getString(
autoRangeCheckBox.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, 
autoRangeCheckBox.setSelection(this.autoRange);
autoRangeCheckBox.addSelectionListener( 
class SWTPlotAppearanceEditor extends Composite
SWTPlotAppearanceEditor(Composite parent, int style, Plot plot)
strokeCanvas = new SWTStrokeCanvas(general, SWT.NONE);
strokeCanvas.setStroke(plot.getOutlineStroke());
strokeCanvas.setLayoutData(strokeGridData);
selectStroke = new Spinner(general, SWT.BORDER);
selectStroke.setMinimum(1);
selectStroke.setMaximum(3);
selectStroke.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, 
false));
selectStroke.addSelectionListener(
int w = selectStroke.getSelection();
strokeCanvas.setStroke(new BasicStroke(w));
strokeCanvas.redraw();
outlinePaintCanvas = new SWTPaintCanvas(general, SWT.NONE, 
outlinePaintCanvas.setLayoutData(outlineGridData);
dlg.setRGB(outlinePaintCanvas.getColor().getRGB());
outlinePaintCanvas.setColor(new Color(getDisplay(),
rgb));
backgroundPaintCanvas = new SWTPaintCanvas(general, SWT.NONE, 
backgroundPaintCanvas.setLayoutData(bgGridData);
dlg.setRGB(backgroundPaintCanvas.getColor().getRGB());
backgroundPaintCanvas.setColor(
new Color(getDisplay(), rgb));
orientation = new Combo(general, SWT.DROP_DOWN);
orientation.setItems(orientationNames);
orientation.select(index);
orientation.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, true,
false, 2, 1));
orientation.addSelectionListener( 
switch (orientation.getSelectionIndex()) {
plotOrientation = PlotOrientation.VERTICAL;
plotOrientation 
= PlotOrientation.HORIZONTAL;
plotOrientation = PlotOrientation.VERTICAL;
return backgroundPaintCanvas.getColor();
return outlinePaintCanvas.getColor();
return strokeCanvas.getStroke();
showTitleCheckBox = new Button(general, SWT.CHECK);
showTitleCheckBox.setSelection(this.showTitle);
showTitleCheckBox.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, 
false, false));
showTitleCheckBox.addSelectionListener(
showTitle = showTitleCheckBox.getSelection();
titleField = new Text(general, SWT.BORDER);
titleField.setText(t.getText());
titleField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, 
fontField = new Text(general, SWT.BORDER);
fontField.setText(titleFont.toString());
fontField.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, 
selectFontButton = new Button(general, SWT.PUSH);
selectFontButton.setText(localizationResources.getString("Select..."));
selectFontButton.addSelectionListener(
dlg.setFontList(new FontData[] { titleFont });
if (font != null) font.dispose();
font = new Font(getShell().getDisplay(), 
dlg.getFontList());
fontField.setText(font.getFontData()[0].toString());
titleFont = font.getFontData()[0];
selectColorButton = new Button(general, SWT.PUSH);
selectColorButton.setText(localizationResources.getString("Select..."));
selectColorButton.addSelectionListener(
dlg.setRGB(titleColor.getRGB());
titleColor = new Color(getDisplay(), rgb);
colorCanvas.setColor( titleColor );Object clone = (PeriodAxisLabelInfo) super.clone();public SWTOtherEditor(Composite parent, int style, JFreeChart chart)
antialias = new Button(general, SWT.CHECK);
antialias.setText(localizationResources.getString("Draw_anti-aliased"));
antialias.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, true, false,
3, 1));
antialias.setSelection(chart.getAntiAlias());
backgroundPaintCanvas = new SWTPaintCanvas(general, SWT.NONE, 
backgroundPaintCanvas.setLayoutData(bgGridData);
dlg.setRGB(backgroundPaintCanvas.getColor().getRGB());
backgroundPaintCanvas.setColor(axis.resizeRange(factor);public void addDomainMarker(int index, Marker marker, Layer layer) {
if (marker == null) {
throw new IllegalArgumentException("Null 'marker' not permitted.");
if (layer == null) {
throw new IllegalArgumentException("Null 'layer' not permitted.");
Collection markers;
if (layer == Layer.FOREGROUND) {
markers = (Collection) this.foregroundDomainMarkers.get(
new Integer(index));
if (markers == null) {
markers = new java.util.ArrayList();
this.foregroundDomainMarkers.put(new Integer(index), markers);
markers.add(marker);
else if (layer == Layer.BACKGROUND) {
markers = (Collection) this.backgroundDomainMarkers.get(
new Integer(index));
if (markers == null) {
markers = new java.util.ArrayList();
this.backgroundDomainMarkers.put(new Integer(index), markers);
markers.add(marker);
marker.addChangeListener(this);
notifyListeners(new PlotChangeEvent(this));public class SWTPaintCanvas extends Canvas
e.gc.setBackground(myColor);
myColor.dispose();
return myColor;
myColor.dispose();implements DialLayer, Cloneable, Serializable {
public DialPointer() {
public DialPointer(int datasetIndex) {
this.radius = 0.675;
public static class Pin extends DialPointer implements PublicCloneable {
public static class Pointer extends DialPointer implements PublicCloneable {
this.radius = 0.9;
private double angle;
private double radius;
private String label;
public double getAngle() {
return this.angle;
public void setAngle(double angle) {
this.angle = angle;
notifyListeners(new DialLayerChangeEvent(this));
public double getRadius() {
return this.radius;
public void setRadius(double radius) {
this.radius = radius;
public String getLabel() {
return this.label;
public void setLabel(String label) {
if (label == null) {
throw new IllegalArgumentException("Null 'label' argument.");
this.label = label;
public DialValueIndicator(int datasetIndex, String label) {
DialScale scale = plot.getScaleForDataset(0);
this(0.0, 100.0, 175, -170);
double startAngle, double extent) {
this.tickLabelFont = new Font("Dialog", Font.BOLD, 16);
this.tickLabelPaint = Color.blue;
this.minorTickCount = 4;
this.tickLabelOffset = 0.10;
this.majorTickIncrement = 10.0;
this.tickRadius = 0.70;
this.tickLabelsVisible = true;
this.firstTickLabelVisible = true;
Rectangle2D arcRectInner = DialPlot.rectangleByRadius(frame, 
this.tickRadius - this.minorTickLength, 
this.tickRadius - this.minorTickLength);
arc.setArc(arcRectInner, this.startAngle, valueToAngle(v) 
g2.draw(new Line2D.Double(pt0, pt1));
TextUtilities.drawAlignedString(String.valueOf(v), g2, 
if (this.minorTickCount > 0) {
arc.setArc(arcRectInner, this.startAngle, angle 
g2.setStroke(new BasicStroke(1.0f));
g2.draw(new Line2D.Double(pt0, pt3));
DialValueIndicator i1 = new DialValueIndicator(0, "Label");
DialValueIndicator i2 = new DialValueIndicator(0, "Label");
DialValueIndicator i1 = new DialValueIndicator(0, "Label");
DialValueIndicator i2 = new DialValueIndicator(0, "Label");
DialValueIndicator i1 = new DialValueIndicator(0, "Label");
DialValueIndicator i1 = new DialValueIndicator(0, "Label");
s1 = new StandardDialScale(10.0, 100.0, 0.0, 270.0);
s2 = new StandardDialScale(10.0, 100.0, 0.0, 270.0);
s1 = new StandardDialScale(10.0, 200.0, 0.0, 270.0);
s2 = new StandardDialScale(10.0, 200.0, 0.0, 270.0);
s1 = new StandardDialScale(10.0, 200.0, 20.0, 270.0);
s2 = new StandardDialScale(10.0, 200.0, 20.0, 270.0);
s1 = new StandardDialScale(10.0, 200.0, 20.0, 99.0);
s2 = new StandardDialScale(10.0, 200.0, 20.0, 99.0);resourcePool.add(resource);
for (Iterator it = resourcePool.iterator();it.hasNext();) {
Resource resource = (Resource)it.next();
resourcePool.clear();
colorsPool.clear();
resourcePool.clear();
fontsPool.get(font);
swtFont = new org.eclipse.swt.graphics.Font( 
gc.getDevice(), 
SWTUtils.toSwtFontData(gc.getDevice(), font, true));
fontsPool.put(font, swtFont);
swtColor = SWTUtils.toSwtColor(gc.getDevice(), awtColor);
org.eclipse.swt.graphics.Color bg = gc.getBackground();
org.eclipse.swt.graphics.Color fg = gc.getForeground();
gc.setBackground(fg);
gc.setForeground(bg);
Transform t = new Transform(gc.getDevice());
gc.drawPath(path);
org.eclipse.swt.graphics.Image im 
= new org.eclipse.swt.graphics.Image(gc.getDevice(), 
convertToSWT(image));
gc.drawImage(im, x, y);
gc.drawImage(image, x, y);
float fm = gc.getFontMetrics().getAscent();
gc.drawString(text, x, (int) (y - fm), true);
float fm = gc.getFontMetrics().getAscent();
gc.drawString(text, (int) x, (int) ( y - fm ), true);
gc.setLineWidth((int) bs.getLineWidth());
gc.setLineJoin(SWT.JOIN_BEVEL);
gc.setLineJoin(SWT.JOIN_MITER);
gc.setLineJoin(SWT.JOIN_ROUND);
gc.setLineCap(SWT.CAP_FLAT);
gc.setLineCap(SWT.CAP_ROUND);
gc.setLineCap(SWT.CAP_SQUARE);
gc.setLineStyle(SWT.LINE_SOLID);
gc.setLineDash(swtDashes);
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
gc.setTransform(swtTransform);
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
gc.setTransform(swtTransform);
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
gc.setTransform(swtTransform);
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
Transform shear = new Transform(gc.getDevice(), 1f, (float) shearX, 
gc.setTransform(swtTransform);
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
gc.setTransform(swtTransform);
gc.setTransform(toSwtTransform(Tx));
Transform swtTransform = new Transform(gc.getDevice()); 
gc.getTransform(swtTransform);
return SWTUtils.toAwtColor(gc.getForeground());
gc.getBackground().dispose();
org.eclipse.swt.graphics.Color swtColor = SWTUtils.toSwtColor(gc.getDevice(), color);
gc.setBackground(swtColor);
return SWTUtils.toAwtColor(gc.getBackground());
return new BasicStroke(gc.getLineWidth(), gc.getLineCap(), 
gc.getLineJoin());
FontRenderContext fontRenderContext 
= new FontRenderContext(new AffineTransform(), true, true);
return SWTUtils.toAwtColor(gc.getForeground());
gc.setForeground(swtColor);
FontData[] fontData = gc.getFont().getFontData();
return SWTUtils.toAwtFont(gc.getDevice(), fontData[0], true);
gc.setFont(swtFont);
gc.setClipping(path);
org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
gc.setClipping(clip);
gc.setClipping(x, y, width, height);
return SWTUtils.toAwtRectangle(gc.getClipping());
gc.setClipping(clipPath);
gc.drawLine(x1, y1, x2, y2);
gc.fillRectangle(x, y, width, height);import org.eclipse.swt.widgets.Listener;
public JFreeChart chart;
canvas.addPaintListener(new PaintListener() {
public void paintControl(PaintEvent e) {
Rectangle available = getBounds();
if (chart == null) {
canvas.drawBackground(e.gc, available.x, available.y, 
available.width, available.height);
return;
SWTGraphics2D sg2 = new SWTGraphics2D(e.gc);
boolean scale = false;
int drawWidth = available.width;
int drawHeight = available.height;
if ( drawWidth == 0.0 || drawHeight == 0.0 ) return;
scaleX = 1.0;
scaleY = 1.0;
if (drawWidth < minimumDrawWidth) {
scaleX = (double) drawWidth / minimumDrawWidth;
drawWidth = minimumDrawWidth;
scale = true;
else if (drawWidth > maximumDrawWidth) {
scaleX = (double) drawWidth / maximumDrawWidth;
drawWidth = maximumDrawWidth;
scale = true;
if (drawHeight < minimumDrawHeight) {
scaleY = (double) drawHeight / minimumDrawHeight;
drawHeight = minimumDrawHeight;
scale = true;
else if (drawHeight > maximumDrawHeight) {
scaleY = (double) drawHeight / maximumDrawHeight;
drawHeight = maximumDrawHeight;
scale = true;
if (useBuffer) {
chartBuffer = (org.eclipse.swt.graphics.Image) 
canvas.getData("double-buffer-image");
if (chartBuffer == null
|| chartBufferWidth != available.width
|| chartBufferHeight != available.height ) {
chartBufferWidth = available.width;
chartBufferHeight = available.height;
if (chartBuffer != null) {
chartBuffer.dispose();
chartBuffer = new org.eclipse.swt.graphics.Image( 
getDisplay(), chartBufferWidth, 
chartBufferHeight);
refreshBuffer = true;
if (refreshBuffer) {
GC gci = new GC(chartBuffer);
SWTGraphics2D sg2d = new SWTGraphics2D(gci);
if (scale) {
sg2d.scale(scaleX, scaleY);
chart.draw(sg2d, new Rectangle2D.Double(0, 0, 
drawWidth, drawHeight), getAnchor(), info);                            
chart.draw(sg2d, new Rectangle2D.Double(0, 0, 
drawWidth, drawHeight), getAnchor(), info);                            
canvas.setData("double-buffer-image", chartBuffer);
sg2d.dispose();
gci.dispose();
refreshBuffer = false;
sg2.drawImage(chartBuffer, 0, 0);
else {
chart.draw(sg2, new Rectangle2D.Double(0, 0, 
getBounds().width, getBounds().height), getAnchor(), info);
Rectangle area = getScreenDataArea();
if (verticalAxisTrace && area.x < verticalTraceLineX 
&& area.x + area.width > verticalTraceLineX) 
e.gc.drawLine(verticalTraceLineX, area.y, verticalTraceLineX, area.y + area.height);
if (horizontalAxisTrace && area.y < horizontalTraceLineY 
&& area.y + area.height > horizontalTraceLineY) 
e.gc.drawLine(area.x, horizontalTraceLineY, area.x + area.width, horizontalTraceLineY);
verticalTraceLineX = 0;
horizontalTraceLineY = 0;
if (zoomRectangle != null) e.gc.drawRectangle(zoomRectangle);
sg2.dispose();
Listener listener = new Listener() {
public void handleEvent (Event event) {
switch (event.type) {
case SWT.MouseDown:
Rectangle scaledDataArea = getScreenDataArea(event.x, event.y);
zoomPoint = getPointInRectangle(event.x, event.y, scaledDataArea);
Rectangle insets = getClientArea();
int x = (int) ((event.x - insets.x) / scaleX);
int y = (int) ((event.y - insets.y) / scaleY);
anchor = new Point2D.Double(x, y);
chart.setNotify(true);  // force a redraw 
canvas.redraw();
Object[] listeners = chartMouseListeners.getListeners(
ChartMouseListener.class);
if (listeners.length == 0) {
return;
ChartEntity entity = null;
if (info != null) 
EntityCollection entities 
= info.getEntityCollection();
if (entities != null) {
entity = entities.getEntity(x, y);
java.awt.event.MouseEvent mouseEvent = SWTUtils.toAwtMouseEvent(event); 
ChartMouseEvent chartEvent = new ChartMouseEvent(getChart(), mouseEvent, entity);
for (int i = listeners.length - 1; i >= 0; i -= 1) {
((ChartMouseListener) 
listeners[i]).chartMouseClicked(chartEvent);
break;
case SWT.MouseMove:
if ( horizontalAxisTrace || verticalAxisTrace ) {
horizontalTraceLineY = event.y;
verticalTraceLineX = event.x;
canvas.redraw();
if (displayToolTips) {                            
String s = getToolTipText(new MouseEvent(event));
if (s == null && canvas.getToolTipText() != null
|| s!=null && !s.equals(canvas.getToolTipText()))
canvas.setToolTipText(s);
if (zoomPoint == null) {
return;
scaledDataArea = getScreenDataArea(zoomPoint.x, zoomPoint.y);
org.eclipse.swt.graphics.Point movingPoint 
= getPointInRectangle(event.x, event.y, scaledDataArea);
boolean hZoom = false;
boolean vZoom = false;
if (orientation == PlotOrientation.HORIZONTAL) {
hZoom = rangeZoomable;
vZoom = domainZoomable;
else {
hZoom = domainZoomable;              
vZoom = rangeZoomable;
if (hZoom && vZoom) {
zoomRectangle = new Rectangle(zoomPoint.x, zoomPoint.y, 
movingPoint.x - zoomPoint.x, movingPoint.y - zoomPoint.y);                            
else if (hZoom) {
zoomRectangle = new Rectangle(zoomPoint.x, scaledDataArea.y,
movingPoint.x - zoomPoint.x, scaledDataArea.height);
else if (vZoom) {
zoomRectangle = new Rectangle(
scaledDataArea.x, zoomPoint.y,
scaledDataArea.width, event.y - zoomPoint.y);
canvas.redraw();
break;
case SWT.MouseUp:
if (zoomRectangle == null) {
Rectangle screenDataArea = getScreenDataArea(event.x, event.y);
if (screenDataArea != null) {
zoomPoint = getPointInRectangle(event.x, event.y, screenDataArea);
if (popup != null && event.button == 3) {
org.eclipse.swt.graphics.Point pt = canvas.toDisplay(event.x, event.y);
displayPopupMenu(pt.x, pt.y);
else {
hZoom = false;
vZoom = false;
if (orientation == PlotOrientation.HORIZONTAL) {
hZoom = rangeZoomable;
vZoom = domainZoomable;
else {
hZoom = domainZoomable;              
vZoom = rangeZoomable;
boolean zoomTrigger1 = hZoom 
&& Math.abs(zoomRectangle.width) 
>= zoomTriggerDistance;
boolean zoomTrigger2 = vZoom 
&& Math.abs(zoomRectangle.height) 
>= zoomTriggerDistance;
if (zoomTrigger1 || zoomTrigger2) {
if ((hZoom && (zoomRectangle.x + zoomRectangle.width < zoomPoint.x)) 
|| (vZoom && (zoomRectangle.y + zoomRectangle.height < zoomPoint.y))) 
restoreAutoBounds();
else zoom(zoomRectangle);
canvas.redraw();
zoomPoint = null;
zoomRectangle = null;
break;
default:
zoomPoint = null;
zoomRectangle = null;
canvas.addListener(SWT.MouseDown, listener);
canvas.addListener(SWT.MouseMove, listener);
canvas.addListener(SWT.MouseUp, listener);
(int) (selection.x + selection.width)/2, 
(int) (selection.y + selection.height)/2);
if (p instanceof Zoomable) 
z.zoomDomainAxes(0.0, this.info.getPlotInfo(), SWTUtils.toAwtPoint(this.zoomPoint));
z.zoomRangeAxes(0.0, this.info.getPlotInfo(), SWTUtils.toAwtPoint(this.zoomPoint)); 
if ( properties ) {
if (save) 
"Domain_Axis" ) );
"Range_Axis" ) );
Menu zoomOutMenu = new Menu( result );
this.zoomOutDomainMenuItem.addSelectionListener( this );
public static MouseEvent toAwtMouseEvent(org.eclipse.swt.widgets.Event event) {
(long) event.time, SWT.NONE, event.x, event.y, 1, false);return true;
return true;
this.layers.add(layer);    
public interface DialScale {
return true;
return true;
return true;
return true;
private double increment;
public double getIncrement() {
return this.increment;
public void setIncrement(double increment) {
this.increment = increment;
if (this.increment != that.increment) {
return false;
return true; 
int result = 193;
long temp = Double.doubleToLongBits(this.increment);
result = 37 * result + (int) (temp ^ (temp >>> 32));        
temp = Double.doubleToLongBits(this.lowerBound);
DialLayer, Cloneable, PublicCloneable, Serializable {
if (tickLabelsVisible) {
return true;
TestSuite suite 
= new TestSuite("org.jfree.experimental.chart.plot.dial");
public class DialPlotTests extends TestCase {
assertTrue(i1.equals(i2));        
r1.setIncrement(1.5);
assertFalse(r1.equals(r2));
r2.setIncrement(1.5);
assertTrue(r1.equals(r2));p1.setGapRadius(7);
p2.setGapRadius(7);super(paint, stroke, paint, stroke, alpha);implements StatisticalCategoryDataset, RangeInfo, PublicCloneable {
MeanAndStandardDeviation masd 
= (MeanAndStandardDeviation) this.data.getObject(row, column);
MeanAndStandardDeviation masd
= (MeanAndStandardDeviation) this.data.getObject(rowKey, columnKey);
MeanAndStandardDeviation masd 
= (MeanAndStandardDeviation) this.data.getObject(row, column);
MeanAndStandardDeviation masd
= (MeanAndStandardDeviation) this.data.getObject(rowKey, columnKey);
double m = 0.0;
double sd = 0.0;
if (!Double.isNaN(m)) {
if (Double.isNaN(this.maximumRangeValue) 
|| m > this.maximumRangeValue) {
this.maximumRangeValue = m;
if (!Double.isNaN(m + sd)) {
if (Double.isNaN(this.maximumRangeValueIncStdDev) 
|| (m + sd) > this.maximumRangeValueIncStdDev) {
this.maximumRangeValueIncStdDev = m + sd;
if (!Double.isNaN(m)) {
if (Double.isNaN(this.minimumRangeValue) 
|| m < this.minimumRangeValue) {
this.minimumRangeValue = m;
if (!Double.isNaN(m - sd)) {
if (Double.isNaN(this.minimumRangeValueIncStdDev) 
|| (m - sd) < this.minimumRangeValueIncStdDev) {
this.minimumRangeValueIncStdDev = m - sd;
return this.minimumRangeValue;        
return this.maximumRangeValue;        
= (DefaultStatisticalCategoryDataset) obj;
assertEquals(new Range(Double.NEGATIVE_INFINITY, 
Double.POSITIVE_INFINITY), d.getRangeBounds(false));
assertEquals(new Range(Double.NEGATIVE_INFINITY, 
Double.POSITIVE_INFINITY), d.getRangeBounds(true));private Number minimumRangeValue;
private Number maximumRangeValue;
this.minimumRangeValue = null;
this.maximumRangeValue = null;
if (this.maximumRangeValue == null) {
this.maximumRangeValue = new Double(maxval);
else if (maxval > this.maximumRangeValue.doubleValue()) {
this.maximumRangeValue = new Double(maxval);
if (this.minimumRangeValue == null) {
this.minimumRangeValue = new Double(minval);
else if (minval < this.minimumRangeValue.doubleValue()) {
this.minimumRangeValue = new Double(minval);
this.rangeBounds = new Range(this.minimumRangeValue.doubleValue(),
this.maximumRangeValue.doubleValue());
double result = Double.NaN;
if (this.minimumRangeValue != null) {
result = this.minimumRangeValue.doubleValue();
return result;
double result = Double.NaN;
if (this.maximumRangeValue != null) {
result = this.maximumRangeValue.doubleValue();
return result;= (BooleanList) this.seriesLinesVisible.clone();return new Range(r.getLowerBound() + this.xOffset, 
r.getUpperBound() + this.blockWidth + this.xOffset);
return new Range(r.getLowerBound() + this.yOffset, 
r.getUpperBound() + this.blockHeight + this.yOffset);import org.jfree.chart.renderer.xy.StandardXYItemRenderer;
assertEquals(0.9, r.getLowerBound());
assertEquals(13.1, r.getUpperBound());
assertEquals(0.8, r.getLowerBound());
assertEquals(13.0, r.getUpperBound());
assertEquals(1500.0, r.getLowerBound());
assertEquals(1500.0, r.getUpperBound());
assertEquals(1500.0, r.getLowerBound());
assertEquals(2250.0, r.getUpperBound());  
assertEquals(1000.0, r.getLowerBound());
assertEquals(2000.0, r.getUpperBound());
assertEquals(1000.0, r.getLowerBound());
assertEquals(3000.0, r.getUpperBound());  