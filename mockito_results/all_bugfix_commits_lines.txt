import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
mock.varargs(arg);
verify(mock).varargs(eq(null));
mock.varargs(arg);
verify(mock).varargs(isNull());
mock.varargs(argArray);
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verifyZeroInteractions;
verifyZeroInteractions(mock);realMethod,
return interceptors.containsKey(instance);
return !selfCallInfo.isSelfInvocation(instance) && isMock(instance);
Object previous = selfCallInfo.replace(instance);
try {
return tryInvoke(origin, instance, arguments);
selfCallInfo.set(previous);
Object replace(Object instance) {
set(instance);
boolean isSelfInvocation(Object instance) {
return get() == instance;
final ConcurrentMap<WeakKey<K>, V> target;realMethod,
return instance != interceptors.target && interceptors.containsKey(instance);
return selfCallInfo.checkSuperCall(instance) && isMock(instance);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
Object replace(Object value) {
set(value);
boolean checkSuperCall(Object value) {
if (value == get()) {
set(null);
return false;
return true;
public final ConcurrentMap<WeakKey<K>, V> target;
package org.mockitoinline;
import org.junit.Test;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import static org.mockito.Mockito.spy;
public class RecursionTest {
public void testMockConcurrentHashMap() {
ConcurrentMap<String, String> map = spy(new ConcurrentHashMap<String, String>());
map.putIfAbsent("a", "b");
package org.mockitoinline;
import org.junit.Test;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
public final class SuperCallTest {
public void testSuperMethodCall() {
Dummy d = spy(new Dummy());
d.foo();
verify(d).bar(eq("baz"));
static class Dummy {
public void foo() {
bar("baz");
void bar(String s) {
return;realMethod,
return interceptors.containsKey(instance);
return !selfCallInfo.isSelfInvocation(instance) && isMock(instance);
Object previous = selfCallInfo.replace(instance);
try {
return tryInvoke(origin, instance, arguments);
selfCallInfo.set(previous);
Object replace(Object instance) {
set(instance);
boolean isSelfInvocation(Object instance) {
return get() == instance;
final ConcurrentMap<WeakKey<K>, V> target;import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
mock.varargs(arg);
verify(mock).varargs(eq(null));
mock.varargs(arg);
verify(mock).varargs(isNull());
mock.varargs(argArray);
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verifyZeroInteractions;
verifyZeroInteractions(mock);import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
package org.mockitousage.bugs;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import java.util.ArrayList;
import java.util.Collection;
import static org.mockito.BDDMockito.given;
import static org.mockito.MockitoAnnotations.initMocks;
public class GenericsMockitoAnnotationsTest {
private TestCollectionSourceProvider testCollectionSourceProvider;
public void test() {
given(testCollectionSourceProvider.getCollection(new ArrayList<Integer>())).willReturn(new ArrayList<Integer>());
static class TestCollectionSourceProvider {
<T extends Collection<E>, E> T getCollection(T collection) {
return collection;
public void setUp() throws Exception {
initMocks(this);
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
mock.varargs(arg);
verify(mock).varargs(eq(null));
mock.varargs(arg);
verify(mock).varargs(isNull());
mock.varargs(argArray);
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verifyZeroInteractions;
verifyZeroInteractions(mock);return selfCallInfo.checkSuperCall(instance) && isMock(instance);
return !node.getSort().isResolved() || !node.getRepresentative().asDefined().represents(origin);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(instance);
return tryInvoke(method, instance, arguments);
boolean checkSuperCall(Object value) {
if (current == value) {
set(null);
return false;
return true;
import org.junit.Assert;
try {
new Timer(-1);
Assert.fail("It is forbidden to create timer with negative value of timer's duration.");
Assert.assertTrue(true);
import org.junit.Assert;
try {
Mockito.timeout(-1);
Assert.fail("It is forbidden to invoke Mockito.timeout() with negative value.");
Assert.assertTrue(true);
try {
Mockito.after(-1);
Assert.fail("It is forbidden to invoke Mockito.after() with negative value.");
Assert.assertTrue(true);
import org.junit.Assert;
Assert.assertEquals("Hello", mock.getFoo());
import org.junit.Assert;
Assert.assertNotNull(((Iterable<String>) iterable).iterator());
Assert.assertNotNull(iterable.iterator());
import org.junit.Assert;
Assert.fail();
Assert.fail();
import org.junit.Assert;
Assert.assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());
Assert.assertEquals("REAL_VALUE", mock.value);
Assert.assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());
Assert.assertEquals("FAKE_VALUE", mock.getValue());
import org.junit.Assert;
Assert.fail("Expected behavior was to throw an exception, and never reach this line");import org.junit.Rule;
import org.junit.rules.ExpectedException;
public ExpectedException expectedException = ExpectedException.none();
expectedException.expect(FriendlyReminderException.class);
expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
new Timer(-1);
import org.junit.Rule;
import org.junit.rules.ExpectedException;
public ExpectedException expectedException = ExpectedException.none();
expectedException.expect(FriendlyReminderException.class);
expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
Mockito.timeout(-1);
expectedException.expect(FriendlyReminderException.class);
expectedException.expectMessage("Don't panic! I'm just a friendly reminder!");
Mockito.after(-1);
import static org.junit.Assert.assertEquals;
assertEquals("Hello", mock.getFoo());
import static org.junit.Assert.assertNotNull;
assertNotNull(((Iterable<String>) iterable).iterator());
assertNotNull(iterable.iterator());
import static org.junit.Assert.fail;
fail();
fail();
assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());
assertEquals("REAL_VALUE", mock.value);
assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());
assertEquals("FAKE_VALUE", mock.getValue());
import static org.junit.Assert.fail;
fail("Expected behavior was to throw an exception, and never reach this line");MockSettings withoutAnnotations();
public MockSettings withoutAnnotations() {
stripAnnotations = true;
return this;
settings.getSerializableMode(),
settings.isStripAnnotations()
final boolean stripAnnotations;
private MockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode, boolean stripAnnotations) {
this.stripAnnotations = stripAnnotations;
public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType,
Set<Class<?>> interfaces,
SerializableMode serializableMode,
boolean stripAnnotations) {
return new MockFeatures<T>(mockedType, interfaces, serializableMode, stripAnnotations);
return selfCallInfo.checkSuperCall(instance) && isMock(instance);
return !node.getSort().isResolved() || !node.getRepresentative().asDefined().represents(origin);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(instance);
return tryInvoke(method, instance, arguments);
boolean checkSuperCall(Object value) {
if (current == value) {
set(null);
return false;
return true;
settings.getSerializableMode(),
settings.isStripAnnotations()
import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
import java.lang.annotation.Annotation;
.annotateType(features.stripAnnotations
? new Annotation[0]
: features.mockedType.getAnnotations())
.attribute(features.stripAnnotations
? MethodAttributeAppender.NoOp.INSTANCE
: INCLUDING_RECEIVER)
private final TypeCache<MockitoMockKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<MockitoMockKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
new MockitoMockKey(params.mockedType, params.interfaces, params.serializableMode, params.stripAnnotations),
private static class MockitoMockKey extends TypeCache.SimpleKey {
private final boolean stripAnnotations;
private MockitoMockKey(Class<?> type,
Set<Class<?>> additionalType,
SerializableMode serializableMode,
boolean stripAnnotations) {
this.stripAnnotations = stripAnnotations;
MockitoMockKey that = (MockitoMockKey) object;
return stripAnnotations == that.stripAnnotations
&& serializableMode.equals(that.serializableMode);
result = 31 * result + (stripAnnotations ? 1 : 0);
protected boolean stripAnnotations;
public boolean isStripAnnotations() {
return stripAnnotations;
boolean isStripAnnotations();
SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyHandler());
ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyHandler());
ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyHandler());
SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyHandler());
SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyHandler());
SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyHandler());
OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyHandler());
SerializableClass proxy = mockMaker.createMock(serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC), dummyHandler());
protected static MockHandler dummyHandler() {
import org.mockito.internal.creation.MockSettingsImpl;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
public void mock_type_with_annotations() throws Exception {
MockSettingsImpl<ClassWithAnnotation> mockSettings = new MockSettingsImpl<ClassWithAnnotation>();
mockSettings.setTypeToMock(ClassWithAnnotation.class);
ClassWithAnnotation proxy = mockMaker.createMock(mockSettings, dummyHandler());
assertThat(proxy.getClass().isAnnotationPresent(SampleAnnotation.class)).isTrue();
assertThat(proxy.getClass().getAnnotation(SampleAnnotation.class).value()).isEqualTo("foo");
assertThat(proxy.getClass().getMethod("sampleMethod").isAnnotationPresent(SampleAnnotation.class)).isTrue();
assertThat(proxy.getClass().getMethod("sampleMethod").getAnnotation(SampleAnnotation.class).value()).isEqualTo("bar");
public void mock_type_without_annotations() throws Exception {
MockSettingsImpl<ClassWithAnnotation> mockSettings = new MockSettingsImpl<ClassWithAnnotation>();
mockSettings.setTypeToMock(ClassWithAnnotation.class);
mockSettings.withoutAnnotations();
ClassWithAnnotation proxy = mockMaker.createMock(mockSettings, dummyHandler());
assertThat(proxy.getClass().isAnnotationPresent(SampleAnnotation.class)).isFalse();
assertThat(proxy.getClass().getMethod("sampleMethod").isAnnotationPresent(SampleAnnotation.class)).isFalse();
public @interface SampleAnnotation {
String value();
public static class ClassWithAnnotation {
public void sampleMethod() {
throw new UnsupportedOperationException();
SerializableMode.NONE,
false
SerializableMode.NONE,
false
SerializableMode.NONE,
false
SerializableMode.NONE,
false
SerializableMode.BASIC,
falseimport static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertSame;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import junit.framework.TestCase;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.fail;
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is null!", e.getMessage());
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertSame;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertSame;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
assertEquals(1.0, captor.getValue());
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotSame;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.*;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotSame;
import static junit.framework.TestCase.fail;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.fail;import org.mockito.listeners.VerificationStartedListener;
MockSettings verificationStartedListeners(VerificationStartedListener... listeners);
Object getMock();
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import org.mockito.internal.listeners.VerificationStartedNotifier;
import org.mockito.invocation.MockHandler;
import static org.mockito.internal.exceptions.Reporter.missingMethodInvocation;
import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerify;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedWhenCreatingInOrder;
import static org.mockito.internal.exceptions.Reporter.nullPassedToVerify;
import static org.mockito.internal.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.nullPassedWhenCreatingInOrder;
import static org.mockito.internal.util.MockUtil.createMock;
import static org.mockito.internal.util.MockUtil.getInvocationContainer;
import static org.mockito.internal.util.MockUtil.isMock;
import static org.mockito.internal.util.MockUtil.resetMock;
import static org.mockito.internal.util.MockUtil.typeMockabilityOf;
MockingDetails mockingDetails = mockingDetails(mock);
if (!mockingDetails.isMock()) {
MockHandler handler = mockingDetails.getMockHandler();
mock = (T) VerificationStartedNotifier.notifyVerificationStarted(
handler.getMockSettings().getVerificationStartedListeners(), mockingDetails);
import org.mockito.listeners.VerificationStartedListener;
import static org.mockito.internal.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface;
import static org.mockito.internal.exceptions.Reporter.invocationListenersRequiresAtLeastOneListener;
import static org.mockito.internal.exceptions.Reporter.methodDoesNotAcceptParameter;
addListeners(listeners, invocationListeners, "invocationListeners");
return this;
private static <T> void addListeners(T[] listeners, List<T> container, String method) {
if (listeners == null) {
throw methodDoesNotAcceptParameter(method, "null vararg array.");
for (T listener : listeners) {
throw methodDoesNotAcceptParameter(method, "null listeners.");
container.add(listener);
public MockSettings verificationStartedListeners(VerificationStartedListener... listeners) {
addListeners(listeners, this.verificationStartedListeners, "verificationStartedListeners");
import org.mockito.listeners.InvocationListener;
import org.mockito.listeners.VerificationStartedListener;
import java.util.LinkedList;
protected List<VerificationStartedListener> verificationStartedListeners = new LinkedList<VerificationStartedListener>();
this.verificationStartedListeners = copy.verificationStartedListeners;
public List<VerificationStartedListener> getVerificationStartedListeners() {
return verificationStartedListeners;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
public static MockitoException methodDoesNotAcceptParameter(String method, String parameter) {
return new MockitoException(method + "() does not accept " + parameter + " See the Javadoc.");
package org.mockito.internal.listeners;
import org.mockito.MockingDetails;
import org.mockito.Mockito;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.matchers.text.ValuePrinter;
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import org.mockito.mock.MockCreationSettings;
import java.util.List;
import java.util.Set;
public class VerificationStartedNotifier {
public static Object notifyVerificationStarted(List<VerificationStartedListener> listeners, MockingDetails originalMockingDetails) {
if (listeners.isEmpty()) {
return originalMockingDetails.getMock();
VerificationStartedEvent event = new Event(originalMockingDetails);
for (VerificationStartedListener listener : listeners) {
listener.onVerificationStarted(event);
return event.getMock();
static class Event implements VerificationStartedEvent {
private final MockingDetails originalMockingDetails;
private Object mock;
public Event(MockingDetails originalMockingDetails) {
this.originalMockingDetails = originalMockingDetails;
this.mock = originalMockingDetails.getMock();
public void setMock(Object mock) {
if (mock == null) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "null parameter.");
MockingDetails mockingDetails = Mockito.mockingDetails(mock);
if (!mockingDetails.isMock()) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "parameter which is not a Mockito mock.\n" +
"  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
MockCreationSettings originalMockSettings = this.originalMockingDetails.getMockCreationSettings();
assertCompatibleTypes(mock, originalMockSettings);
this.mock = mock;
public Object getMock() {
return mock;
static void assertCompatibleTypes(Object mock, MockCreationSettings originalSettings) {
Class originalType = originalSettings.getTypeToMock();
if (!originalType.isInstance(mock)) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock",
"parameter which is not the same type as the original mock.\n" +
"  Required type: " + originalType.getName() + "\n" +
"  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
for (Class iface : (Set<Class>) originalSettings.getExtraInterfaces()) {
if (!iface.isInstance(mock)) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock",
"parameter which does not implement all extra interfaces of the original mock.\n" +
"  Required type: " + originalType.getName() + "\n" +
"  Required extra interface: " + iface.getName() + "\n" +
"  Received parameter: " + ValuePrinter.print(mock) + ".\n ");
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.internal.stubbing.answers.ThrowsException;
import org.mockito.internal.util.MockUtil;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Stubber;
import java.util.LinkedList;
import java.util.List;
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
public Object getMock() {
return toInspect;
package org.mockito.listeners;
import org.mockito.Incubating;
public interface VerificationStartedEvent {
void setMock(Object mock);
Object getMock();
package org.mockito.listeners;
import org.mockito.Incubating;
public interface VerificationStartedListener {
void onVerificationStarted(VerificationStartedEvent event);
import org.mockito.listeners.VerificationStartedListener;
List<VerificationStartedListener> getVerificationStartedListeners();
Object[] getConstructorArgs();
throw Reporter.methodDoesNotAcceptParameter("invocationListeners", "null vararg array");
package org.mockito.internal.listeners;
import org.junit.Test;
import org.mockito.MockingDetails;
import org.mockitoutil.TestBase;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static java.util.Collections.emptyList;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockingDetails;
import static org.mockito.Mockito.withSettings;
public class VerificationStartedNotifierTest extends TestBase {
MockingDetails mockingDetails = mockingDetails(mock(List.class));
public void does_not_do_anything_when_list_is_empty() throws Exception {
VerificationStartedNotifier.notifyVerificationStarted((List) emptyList(), mockingDetails);
public void decent_exception_when_setting_non_mock() throws Exception {
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
try {
event.setMock("not a mock");
fail();
assertEquals("VerificationStartedEvent.setMock() does not accept parameter which is not a Mockito mock.\n" +
"  Received parameter: \"not a mock\".\n" +
"  See the Javadoc.", e.getMessage());
public void shows_clean_exception_message_when_illegal_null_arg_is_used() throws Exception {
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
try {
event.setMock(null);
fail();
assertEquals("VerificationStartedEvent.setMock() does not accept null parameter. See the Javadoc.", e.getMessage());
public void decent_exception_when_setting_mock_of_wrong_type() throws Exception {
final Set differentTypeMock = mock(Set.class);
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails);
try {
event.setMock(differentTypeMock);
fail();
assertEquals(filterHashCode("VerificationStartedEvent.setMock() does not accept parameter which is not the same type as the original mock.\n" +
"  Required type: java.util.List\n" +
"  Received parameter: Mock for Set, hashCode: xxx.\n" +
"  See the Javadoc."), filterHashCode(e.getMessage()));
public void decent_exception_when_setting_mock_that_does_not_implement_all_desired_interfaces() throws Exception {
final Set mock = mock(Set.class, withSettings().extraInterfaces(List.class));
final Set missingExtraInterface = mock(Set.class);
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails(mock));
try {
event.setMock(missingExtraInterface);
fail();
assertEquals(filterHashCode("VerificationStartedEvent.setMock() does not accept parameter which does not implement all extra interfaces of the original mock.\n" +
"  Required type: java.util.Set\n" +
"  Required extra interface: java.util.List\n" +
"  Received parameter: Mock for Set, hashCode: xxx.\n" +
"  See the Javadoc."), filterHashCode(e.getMessage()));
public void accepts_replacement_mock_if_all_types_are_compatible() throws Exception {
final Set mock = mock(Set.class, withSettings().extraInterfaces(List.class, Map.class));
final Set compatibleMock = mock(Set.class, withSettings().extraInterfaces(List.class, Map.class));
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event(mockingDetails(mock));
event.setMock(compatibleMock);
assertEquals(compatibleMock, event.getMock());
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockingDetails;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
public void should_provide_original_mock() throws Exception {
assertEquals(mockingDetails(foo).getMock(), foo);
assertEquals(mockingDetails(null).getMock(), null);
import static org.mockito.Mockito.*;
package org.mockitousage.verification;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import org.mockitoutil.TestBase;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
public class VerificationStartedListenerTest extends TestBase {
public void verified_mock_can_be_replaced() throws Exception {
final List mock1 = mock(List.class);
mock1.clear(); //register clear() on mock1
List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
event.setMock(mock1);
List verifiedMock = verify(mock2);
assertEquals(mock1, verifiedMock);
verifiedMock.clear();
public void verification_started_event_contains_correct_mock() throws Exception {
final List<Object> container = new ArrayList<Object>();
List mock = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
verify(mock, never()).clear();
Assertions.assertThat(container).containsExactly(mock);
public void listeners_are_executed_in_sequence() throws Exception {
final List<Object> container = new ArrayList<Object>();
final List mock1 = mock(List.class);
List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
event.setMock(mock1);
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
verify(mock2, never()).clear();
Assertions.assertThat(container).containsExactly(mock2, mock1);
public void shows_clean_exception_when_null_array_passed() throws Exception {
try {
Mockito.withSettings().verificationStartedListeners(null);
fail();
assertEquals("verificationStartedListeners() does not accept null vararg array. See the Javadoc.", e.getMessage());
public void shows_clean_exception_when_null_listener_passed() throws Exception {
try {
Mockito.withSettings().verificationStartedListeners(mock(VerificationStartedListener.class), null);
fail();
assertEquals("verificationStartedListeners() does not accept null listeners. See the Javadoc.", e.getMessage());
public static String filterHashCode(String text) {
return text.replaceAll("hashCode: (\\d)+\\.", "hashCode: xxx.");import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
for (T v: values) {
for (Throwable t: throwables) {
return thenAnswer(new ThrowsExceptionClass(throwableType));
thenThrow((Throwable) null);
for (Class<? extends Throwable> t: nextToBeThrown) {
import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
if (!MockUtil.isMock(mock)) {
throw notAMockPassedToWhenMethod();
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
if(toBeReturned == null) {
if(toBeThrown == null) {
return doThrowClasses(toBeThrown);
return doThrowClasses(toBeThrown).doThrowClasses(nextToBeThrown);
private StubberImpl doThrowClasses(Class<? extends Throwable>... toBeThrown) {
for (Class<? extends Throwable> throwable: toBeThrown) {
answers.add(new ThrowsExceptionClass(throwable));
return this;
package org.mockito.internal.stubbing.answers;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.objenesis.ObjenesisHelper;
import static org.mockito.internal.exceptions.Reporter.notAnException;
import java.io.Serializable;
public class ThrowsExceptionClass implements Answer<Object>, Serializable {
private final Class<? extends Throwable> throwableClass;
private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {
this.throwableClass = checkNonNullThrowable(throwableClass);
private Class<? extends Throwable> checkNonNullThrowable(Class<? extends Throwable> throwableClass) {
if(throwableClass == null || !Throwable.class.isAssignableFrom(throwableClass)) {
throw notAnException();
return throwableClass;
public Object answer(InvocationOnMock invocation) throws Throwable {
Throwable throwable = ObjenesisHelper.newInstance(throwableClass);
throwable.fillInStackTrace();
filter.filter(throwable);
throw throwable;
public Class<? extends Throwable> getThrowableClass() {
return throwableClass;
SimpleMockitoLogger logger = new SimpleMockitoLogger();
UnusedStubbings stubbings = new UnusedStubbings(Arrays.<Stubbing> asList());
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
try {
mock.add("throw");
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
when(mock.get(1)).thenThrow(new ExceptionOne());
try {
when(mock.get(1)).thenThrow(new ExceptionTwo());
fail();
try {
reader.read();
fail();
assertEquals(ioException, e);
try {
mock.add("quake");
fail();
assertEquals(error, e);
public void shouldNotAllowSettingInvalidCheckedException() throws Exception {
public void shouldNotAllowSettingNullThrowable() throws Exception {
public void shouldNotAllowSettingNullThrowableArray() throws Exception {
public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {
when(mock.add("")).thenThrow(NaughtyException.class);
mock.add("");import org.mockito.listeners.VerificationStartedListener;
MockSettings verificationStartedListeners(VerificationStartedListener... listeners);
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
import org.mockito.internal.listeners.VerificationStartedNotifier;
import org.mockito.internal.util.MockitoMock;
import org.mockito.invocation.MockHandler;
import static org.mockito.internal.exceptions.Reporter.missingMethodInvocation;
import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerify;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedWhenCreatingInOrder;
import static org.mockito.internal.exceptions.Reporter.nullPassedToVerify;
import static org.mockito.internal.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions;
import static org.mockito.internal.exceptions.Reporter.nullPassedWhenCreatingInOrder;
import static org.mockito.internal.util.MockUtil.createMock;
import static org.mockito.internal.util.MockUtil.getInvocationContainer;
import static org.mockito.internal.util.MockUtil.getMockitoMock;
import static org.mockito.internal.util.MockUtil.isMock;
import static org.mockito.internal.util.MockUtil.resetMock;
import static org.mockito.internal.util.MockUtil.typeMockabilityOf;
MockitoMock mockitoMock = getMockitoMock(mock);
if (!mockitoMock.isMock()) {
MockHandler handler = mockitoMock.getHandler();
mock = (T) VerificationStartedNotifier.notifyVerificationStarted(
handler.getMockSettings().getVerificationStartedListeners(), mock);
import org.mockito.listeners.VerificationStartedListener;
import static org.mockito.internal.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters;
import static org.mockito.internal.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface;
import static org.mockito.internal.exceptions.Reporter.invocationListenersRequiresAtLeastOneListener;
import static org.mockito.internal.exceptions.Reporter.methodDoesNotAcceptParameter;
addListeners(listeners, invocationListeners, "invocationListeners");
return this;
private static <T> void addListeners(T[] listeners, List<T> container, String method) {
if (listeners == null) {
throw methodDoesNotAcceptParameter(method, "null vararg array");
for (T listener : listeners) {
throw methodDoesNotAcceptParameter(method, "null listeners");
container.add(listener);
public MockSettings verificationStartedListeners(VerificationStartedListener... listeners) {
addListeners(listeners, this.verificationStartedListeners, "verificationStartedListeners");
import org.mockito.listeners.InvocationListener;
import org.mockito.listeners.VerificationStartedListener;
import java.util.LinkedList;
protected List<VerificationStartedListener> verificationStartedListeners = new LinkedList<VerificationStartedListener>();
this.verificationStartedListeners = copy.verificationStartedListeners;
public List<VerificationStartedListener> getVerificationStartedListeners() {
return verificationStartedListeners;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
public static MockitoException methodDoesNotAcceptParameter(String method, String parameter) {
return new MockitoException(method + "() does not accept " + parameter + ". See the Javadoc.");
package org.mockito.internal.listeners;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.util.MockUtil;
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import java.util.List;
public class VerificationStartedNotifier {
public static Object notifyVerificationStarted(List<VerificationStartedListener> listeners, Object mock) {
if (listeners.isEmpty()) {
return mock;
VerificationStartedEvent event = new Event();
event.setMock(mock);
for (VerificationStartedListener listener : listeners) {
listener.onVerificationStarted(event);
return event.getMock();
static class Event implements VerificationStartedEvent {
private Object mock;
public void setMock(Object mock) {
if (mock == null) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "null parameter");
if (!MockUtil.isMock(mock)) {
throw Reporter.methodDoesNotAcceptParameter("VerificationStartedEvent.setMock", "parameter which is not a Mockito mock");
this.mock = mock;
public Object getMock() {
return mock;
import static org.mockito.internal.exceptions.Reporter.notAnException;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.objenesis.ObjenesisHelper.newInstance;
for (T v : values) {
for (Throwable t : throwables) {
if (throwableType == null) {
mockingProgress().reset();
throw notAnException();
return thenThrow(newInstance(throwableType));
thenThrow((Class<Throwable>) null);
for (Class<? extends Throwable> t : nextToBeThrown) {
import java.util.LinkedList;
import java.util.List;
import static org.mockito.internal.exceptions.Reporter.notAMockPassedToWhenMethod;
import static org.mockito.internal.exceptions.Reporter.notAnException;
import static org.mockito.internal.exceptions.Reporter.nullPassedToWhenMethod;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
import static org.mockito.internal.util.MockUtil.isMock;
import static org.objenesis.ObjenesisHelper.newInstance;
if (!isMock(mock)) {
throw notAMockPassedToWhenMethod();
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
if (toBeReturned == null) {
if (toBeThrown == null) {
if (toBeThrown == null) {
mockingProgress().reset();
throw notAnException();
Throwable e;
try {
e = newInstance(toBeThrown);
mockingProgress().reset();
throw instanciationError;
return doThrow(e);
Stubber stubber = doThrow(toBeThrown);
if (nextToBeThrown == null) {
mockingProgress().reset();
throw notAnException();
for (Class<? extends Throwable> next : nextToBeThrown) {
stubber = stubber.doThrow(next);
return stubber;
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
public static MockitoMock getMockitoMock(Object mock) {
return new MockitoMock(mockMaker.getHandler(mock));
package org.mockito.internal.util;
import org.mockito.invocation.MockHandler;
public class MockitoMock {
private final MockHandler handler;
MockitoMock(MockHandler handler) {
this.handler = handler;
public boolean isMock() {
return handler != null;
public MockHandler getHandler() {
return handler;
package org.mockito.listeners;
import org.mockito.Incubating;
public interface VerificationStartedEvent {
void setMock(Object mock);
Object getMock();
package org.mockito.listeners;
import org.mockito.Incubating;
public interface VerificationStartedListener {
void onVerificationStarted(VerificationStartedEvent event);
import org.mockito.listeners.VerificationStartedListener;
List<VerificationStartedListener> getVerificationStartedListeners();
Object[] getConstructorArgs();
throw Reporter.methodDoesNotAcceptParameter("invocationListeners", "null vararg array");
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.Collections;
import static org.assertj.core.api.Assertions.assertThat;
private SimpleMockitoLogger logger = new SimpleMockitoLogger();
UnusedStubbings stubbings = new UnusedStubbings(Collections.<Stubbing>emptyList());
assertThat(filterLineNo(logger.getLoggedInfo())).isIn(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +  //Java <9
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +  //Java 9
"[MockitoHint] 1. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n"
);
package org.mockito.internal.listeners;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.VerificationStartedListener;
import java.util.List;
import java.util.Set;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
public class VerificationStartedNotifierTest {
public void does_not_do_anything_when_list_is_empty() throws Exception {
VerificationStartedNotifier.notifyVerificationStarted((List) emptyList(), null);
public void detects_illegal_null_argument() throws Exception {
try {
VerificationStartedNotifier.notifyVerificationStarted(asList(mock(VerificationStartedListener.class)), null);
fail();
assertEquals("VerificationStartedEvent.setMock() does not accept null parameter. See the Javadoc.", e.getMessage());
public void decent_exception_when_setting_non_mock() throws Exception {
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event();
try {
event.setMock("not a mock");
fail();
assertEquals("VerificationStartedEvent.setMock() does not accept parameter which is not a Mockito mock. See the Javadoc.", e.getMessage());
public void shows_clean_exception_message_when_illegal_null_arg_is_used() throws Exception {
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event();
try {
event.setMock(null);
fail();
assertEquals("VerificationStartedEvent.setMock() does not accept null parameter. See the Javadoc.", e.getMessage());
public void decent_exception_when_setting_mock_of_wrong_type() throws Exception {
final Set differentTypeMock = mock(Set.class);
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event();
try {
event.setMock(differentTypeMock);
fail();
assertEquals("???", e.getMessage());
import java.util.ArrayList;
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
mock.varargs(arg);
verify(mock).varargs(eq(null));
mock.varargs(arg);
verify(mock).varargs(isNull());
mock.varargs(argArray);
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
public ExpectedException exception = ExpectedException.none();
exception.expect(sameInstance(expected));
mock.add("throw");
exception.expect(sameInstance(expected));
mock.clear();
exception.expect(ExceptionTwo.class);
mock.clear();
when(mock.size()).thenThrow(new ExceptionOne());
exception.expect(ExceptionOne.class);
when(mock.size()).thenThrow(new ExceptionTwo());
exception.expect(sameInstance(ioException));
reader.read();
exception.expect(Error.class);
mock.add("quake");
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
exception.expect(NaughtyException.class);
exception.expect(NaughtyException.class);
public void shouldNotAllowSettingInvalidCheckedException() {
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
public void shouldNotAllowSettingNullThrowable() {
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
public void shouldNotAllowSettingNullThrowableArray() {
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
public void shouldNotAllowSettingNullThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow((Class) null);
public void shouldNotAllowSettingNullThrowableClasses() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
public void shouldNotAllowSettingNullVarArgThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
public void doThrowShouldNotAllowSettingNullThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow((Class) null).when(mock).isEmpty();
public void doThrowShouldNotAllowSettingNullThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow(RuntimeException.class, (Class) null).when(mock).isEmpty();
public void doThrowShouldNotAllowSettingNullVarArgThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow(RuntimeException.class, (Class[]) null).when(mock).isEmpty();
public void shouldNotAllowSettingNullVarArgsThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class<RuntimeException>[]) null);
public void shouldNotAllowDifferntCheckedException() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsIOException(0)).thenThrow(CheckedException.class);
public void shouldNotAllowCheckedExceptionWhenErrorIsDeclared() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsError(0)).thenThrow(CheckedException.class);
public void shouldNotAllowCheckedExceptionWhenNothingIsDeclared() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsNothing(true)).thenThrow(CheckedException.class);
verifyZeroInteractions(mock);
private class CheckedException extends Exception {
package org.mockitousage.verification;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import org.mockitoutil.TestBase;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
public class VerificationStartedListenerTest extends TestBase {
public void verified_mock_can_be_replaced() throws Exception {
final List mock1 = mock(List.class);
mock1.clear(); //register clear() on mock1
List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
event.setMock(mock1);
List verifiedMock = verify(mock2);
assertEquals(mock1, verifiedMock);
verifiedMock.clear();
public void verification_started_event_contains_correct_mock() throws Exception {
final List<Object> container = new ArrayList<Object>();
List mock = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
verify(mock, never()).clear();
Assertions.assertThat(container).containsExactly(mock);
public void listeners_are_executed_in_sequence() throws Exception {
final List<Object> container = new ArrayList<Object>();
final List mock1 = mock(List.class);
List mock2 = mock(List.class, Mockito.withSettings().verificationStartedListeners(new VerificationStartedListener() {
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
event.setMock(mock1);
public void onVerificationStarted(VerificationStartedEvent event) {
container.add(event.getMock());
verify(mock2, never()).clear();
Assertions.assertThat(container).containsExactly(mock2, mock1);
public void shows_clean_exception_when_null_array_passed() throws Exception {
try {
Mockito.withSettings().verificationStartedListeners(null);
fail();
assertEquals("verificationStartedListeners() does not accept null vararg array. See the Javadoc.", e.getMessage());
public void shows_clean_exception_when_null_listener_passed() throws Exception {
try {
Mockito.withSettings().verificationStartedListeners(mock(VerificationStartedListener.class), null);
fail();
assertEquals("verificationStartedListeners() does not accept null listeners. See the Javadoc.", e.getMessage());import static org.mockito.Mockito.*;SimpleMockitoLogger logger = new SimpleMockitoLogger();
UnusedStubbings stubbings = new UnusedStubbings(Arrays.<Stubbing> asList());
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));void shouldHaveNoInteractions();
public void shouldHaveNoInteractions() {
verifyNoInteractions(mock);
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
public static void verifyNoInteractions(Object... mocks) {
MOCKITO_CORE.verifyNoInteractions(mocks);
import static org.mockito.internal.verification.VerificationModeFactory.noInteractions;
public void verifyNoInteractions(Object... mocks) {
assertMocksNotEmpty(mocks);
mockingProgress().validateState();
for (Object mock : mocks) {
if (mock == null) {
throw nullPassedToVerifyNoMoreInteractions();
if (!isMock(mock)) {
throw notAMockPassedToVerifyNoMoreInteractions();
InvocationContainerImpl invocations = getInvocationContainer(mock);
VerificationDataImpl data = new VerificationDataImpl(invocations, null);
noInteractions().verify(data);
import java.lang.reflect.Modifier;
sb.append("[Mockito] Unused stubbings of: ").append(mock).append("\n");
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);"
public static MockitoAssertionError noInteractionsWanted(Object mock, List<VerificationAwareInvocation> invocations) {
ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
String scenario = scenarioPrinter.print(invocations);
List<Location> locations = new ArrayList<Location>();
for (VerificationAwareInvocation invocation : invocations) {
locations.add(invocation.getLocation());
return new NoInteractionsWanted(join(
"No interactions wanted here:",
new LocationImpl(),
"But found these interactions on mock '" + safelyGetMockName(mock) + "':",
join("", locations),
scenario
));
import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
for (T v: values) {
for (Throwable t: throwables) {
return thenAnswer(new ThrowsExceptionClass(throwableType));
thenThrow((Throwable) null);
for (Class<? extends Throwable> t: nextToBeThrown) {
import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
if (!MockUtil.isMock(mock)) {
throw notAMockPassedToWhenMethod();
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
if(toBeReturned == null) {
if(toBeThrown == null) {
return doThrowClasses(toBeThrown);
return doThrowClasses(toBeThrown).doThrowClasses(nextToBeThrown);
private StubberImpl doThrowClasses(Class<? extends Throwable>... toBeThrown) {
for (Class<? extends Throwable> throwable: toBeThrown) {
answers.add(new ThrowsExceptionClass(throwable));
return this;
package org.mockito.internal.stubbing.answers;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.objenesis.ObjenesisHelper;
import static org.mockito.internal.exceptions.Reporter.notAnException;
import java.io.Serializable;
public class ThrowsExceptionClass implements Answer<Object>, Serializable {
private final Class<? extends Throwable> throwableClass;
private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {
this.throwableClass = checkNonNullThrowable(throwableClass);
private Class<? extends Throwable> checkNonNullThrowable(Class<? extends Throwable> throwableClass) {
if(throwableClass == null || !Throwable.class.isAssignableFrom(throwableClass)) {
throw notAnException();
return throwableClass;
public Object answer(InvocationOnMock invocation) throws Throwable {
Throwable throwable = ObjenesisHelper.newInstance(throwableClass);
throwable.fillInStackTrace();
filter.filter(throwable);
throw throwable;
public Class<? extends Throwable> getThrowableClass() {
return throwableClass;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return Optional.empty();
return OptionalDouble.empty();
return OptionalInt.empty();
return OptionalLong.empty();
return Stream.empty();
return DoubleStream.empty();
return IntStream.empty();
return LongStream.empty();
package org.mockito.internal.verification;
import java.util.List;
import org.mockito.internal.verification.api.VerificationData;
import org.mockito.invocation.Invocation;
import org.mockito.verification.VerificationMode;
import static org.mockito.internal.exceptions.Reporter.noInteractionsWanted;
public class NoInteractions implements VerificationMode {
public void verify(VerificationData data) {
List<Invocation> invocations = data.getAllInvocations();
if (!invocations.isEmpty()) {
throw noInteractionsWanted(invocations.get(0).getMock(), (List) invocations);
public VerificationMode description(String description) {
return VerificationModeFactory.description(this, description);
public static NoInteractions noInteractions() {
return new NoInteractions();
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
public void shouldValidateMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions("notMock");
public void shouldValidateNullMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions(new Object[] { null });
when(mock.simpleMethod());
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
doAnswer(null);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
verify(mock);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedVerificationException.class);
anyObject();
detectsAndCleansUp(new OnVerifyNoInteractions(), InvalidUseOfMatchersException.class);
private static class OnVerifyNoInteractions implements DetectsInvalidState {
public void detect(IMethods mock) {
verifyNoInteractions(mock);
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static org.assertj.core.api.Assertions.assertThat;
assertTrue(((Number[]) values.returnValueFor(Number[].class)).length == 0);
assertThat((Optional) values.returnValueFor(Optional.class)).isEmpty();
assertThat((OptionalInt) values.returnValueFor(OptionalInt.class)).isEmpty();
assertThat((OptionalLong) values.returnValueFor(OptionalLong.class)).isEmpty();
assertThat((OptionalDouble) values.returnValueFor(OptionalDouble.class)).isEmpty();
public void should_return_empty_Streams() throws Exception {
assertThat((Stream) values.returnValueFor(Stream.class)).isEmpty();
assertThat(((DoubleStream) values.returnValueFor(DoubleStream.class)).count()).isEqualTo(0);
assertThat(((IntStream) values.returnValueFor(IntStream.class)).count()).isEqualTo(0);
assertThat(((LongStream) values.returnValueFor(LongStream.class)).count()).isEqualTo(0);
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
package org.mockito.internal.verification;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.mock;
public class NoInteractionsTest extends TestBase {
public void noInteractionsExceptionMessageShouldDescribeMock() {
NoInteractions n = new NoInteractions();
IMethods mock = mock(IMethods.class, "a mock");
InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
InvocationContainerImpl invocations =
new InvocationContainerImpl( new MockSettingsImpl());
invocations.setInvocationForPotentialStubbing(i);
try {
n.verify(new VerificationDataImpl(invocations, null));
fail();
Assertions.assertThat(e.toString()).contains(mock.toString());
public void shouldRemoveAllInteractionsVerifyNoInteractions() throws Exception {
mock.simpleMethod(1);
reset(mock);
verifyNoInteractions(mock);
public void shouldStubbingNotBeTreatedAsInteractionVerifyNoInteractions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
reset(mock);
verifyNoInteractions(mock);
public void should_validate_that_mock_had_no_interactions() {
then(mock).shouldHaveNoInteractions();
when(mock.oneArg((Object) anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq((Object)null));
verify(mock).simpleMethod(same((Object)null));
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
mock.varargs((Object) arg);
verify(mock).varargs((Object) eq(null));
mock.varargs((Object) arg);
verify(mock).varargs((Object) isNull());
mock.varargs((Object[]) argArray);
verify(mock).varargs((Object[]) isNull());
verify(mock).varargs((Integer) any()); // any() -> VarargMatcher
verify(mock).varargs((Integer) any()); // any() -> VarargMatcher
verify(mock).varargs((Integer) any(), (Integer) any()); // any() -> VarargMatcher
public void shouldRequireArgumentsWhenVerifyingNoInteractions() {
verifyNoInteractions();
public void shouldNotMockObjectMethodsOnInterfaceVerifyNoInteractions() throws Exception {
ObjectLikeInterface inter = mock(ObjectLikeInterface.class);
inter.equals(null);
inter.toString();
inter.hashCode();
verifyNoInteractions(inter);
public void shouldNotMockObjectMethodsOnClassVerifyNoInteractions() throws Exception {
Object clazz = mock(ObjectLikeInterface.class);
clazz.equals(null);
clazz.toString();
clazz.hashCode();
verifyNoInteractions(clazz);
import static org.mockito.Mockito.*;
public void shouldFilterStackTraceOnVerifyNoInteractions() {
mock.oneArg(true);
try {
verifyNoInteractions(mock);
fail();
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoInteractions"));
public void should_stubbing_not_be_treated_as_interaction_verify_no_interactions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
verifyNoInteractions(mock);
public void unfinished_stubbing_cleans_up_the_state_verify_no_interactions() {
reset(mock);
try {
when("").thenReturn("");
fail();
verifyNoInteractions(mock);
import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
try {
mock.add("throw");
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
when(mock.get(1)).thenThrow(new ExceptionOne());
try {
when(mock.get(1)).thenThrow(new ExceptionTwo());
fail();
try {
reader.read();
fail();
assertEquals(ioException, e);
try {
mock.add("quake");
fail();
assertEquals(error, e);
public void shouldNotAllowSettingInvalidCheckedException() throws Exception {
public void shouldNotAllowSettingNullThrowable() throws Exception {
public void shouldNotAllowSettingNullThrowableArray() throws Exception {
verifyNoInteractions(mock);
public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {
when(mock.add("")).thenThrow(NaughtyException.class);
mock.add("");
public void shouldFailOnVerifyNoInteractions() {
verifyNoInteractions(mockOne);
public void should_print_first_unexpected_invocation_when_verifying_no_interactions() {
mock.twoArgumentMethod(1, 2);
mock.threeArgumentMethod(1, "2", "3");
try {
verifyNoInteractions(mock);
fail();
String expected =
"\n" +
"No interactions wanted here:" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expected);
String expectedCause =
"\n" +
"But found these interactions on mock '" + mock + "':" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expectedCause);
verifyNoInteractions(mock);
verifyNoInteractions(mock);
public void shouldFailNoInteractionsVerification() throws Exception {
mock.clear();
try {
verifyNoInteractions(mock);
fail();
public void shouldVerifyOneMockButFailOnOtherVerifyNoInteractions() throws Exception {
List<String> list = mock(List.class);
Map<String, Integer> map = mock(Map.class);
list.add("one");
list.add("one");
map.put("one", 1);
verify(list, times(2)).add("one");
verifyNoMoreInteractions(list);
try {
verifyNoInteractions(map);
fail();
verifyNoInteractions(set);
import static org.mockito.Mockito.verifyNoInteractions;
public void verify__no_interaction_with_parent_mock() throws Exception {
verifyNoInteractions(parentMockField);"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
verifyZeroInteractions(mock);import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
import static org.mockito.internal.exceptions.Reporter.notAnException;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.objenesis.ObjenesisHelper.newInstance;
for (T v : values) {
for (Throwable t : throwables) {
if (throwableType == null) {
mockingProgress().reset();
throw notAnException();
return thenThrow(newInstance(throwableType));
thenThrow((Class<Throwable>) null);
for (Class<? extends Throwable> t : nextToBeThrown) {
import static org.mockito.internal.exceptions.Reporter.notAnException;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.mockito.internal.util.MockUtil.isMock;
import static org.objenesis.ObjenesisHelper.newInstance;
if (!isMock(mock)) {
throw notAMockPassedToWhenMethod();
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
if (toBeReturned == null) {
if (toBeThrown == null) {
if (toBeThrown == null) {
mockingProgress().reset();
throw notAnException();
Throwable e;
try {
e = newInstance(toBeThrown);
mockingProgress().reset();
throw instanciationError;
return doThrow(e);
Stubber stubber = doThrow(toBeThrown);
if (nextToBeThrown == null) {
mockingProgress().reset();
throw notAnException();
for (Class<? extends Throwable> next : nextToBeThrown) {
stubber = stubber.doThrow(next);
return stubber;
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
mock.varargs(arg);
verify(mock).varargs(eq(null));
mock.varargs(arg);
verify(mock).varargs(isNull());
mock.varargs(argArray);
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
public ExpectedException exception = ExpectedException.none();
exception.expect(sameInstance(expected));
mock.add("throw");
exception.expect(sameInstance(expected));
mock.clear();
exception.expect(ExceptionTwo.class);
mock.clear();
when(mock.size()).thenThrow(new ExceptionOne());
exception.expect(ExceptionOne.class);
when(mock.size()).thenThrow(new ExceptionTwo());
exception.expect(sameInstance(ioException));
reader.read();
exception.expect(Error.class);
mock.add("quake");
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
exception.expect(NaughtyException.class);
exception.expect(NaughtyException.class);
public void shouldNotAllowSettingInvalidCheckedException() {
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
public void shouldNotAllowSettingNullThrowable() {
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
public void shouldNotAllowSettingNullThrowableArray() {
exception.expect(MockitoException.class);
exception.expectMessage("Cannot stub with null throwable");
public void shouldNotAllowSettingNullThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow((Class) null);
public void shouldNotAllowSettingNullThrowableClasses() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
public void shouldNotAllowSettingNullVarArgThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
public void doThrowShouldNotAllowSettingNullThrowableClass() {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow((Class) null).when(mock).isEmpty();
public void doThrowShouldNotAllowSettingNullThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow(RuntimeException.class, (Class) null).when(mock).isEmpty();
public void doThrowShouldNotAllowSettingNullVarArgThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
doThrow(RuntimeException.class, (Class[]) null).when(mock).isEmpty();
public void shouldNotAllowSettingNullVarArgsThrowableClasses() throws Exception {
exception.expect(MockitoException.class);
exception.expectMessage("Exception type cannot be null");
when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class<RuntimeException>[]) null);
public void shouldNotAllowDifferntCheckedException() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsIOException(0)).thenThrow(CheckedException.class);
public void shouldNotAllowCheckedExceptionWhenErrorIsDeclared() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsError(0)).thenThrow(CheckedException.class);
public void shouldNotAllowCheckedExceptionWhenNothingIsDeclared() throws Exception {
IMethods mock = mock(IMethods.class);
exception.expect(MockitoException.class);
exception.expectMessage("Checked exception is invalid for this method");
when(mock.throwsNothing(true)).thenThrow(CheckedException.class);
private class CheckedException extends Exception {import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
for (T v: values) {
for (Throwable t: throwables) {
return thenAnswer(new ThrowsExceptionClass(throwableType));
thenThrow((Throwable) null);
for (Class<? extends Throwable> t: nextToBeThrown) {
import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
if (!MockUtil.isMock(mock)) {
throw notAMockPassedToWhenMethod();
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
if(toBeReturned == null) {
if(toBeThrown == null) {
return doThrowClasses(toBeThrown);
return doThrowClasses(toBeThrown).doThrowClasses(nextToBeThrown);
private StubberImpl doThrowClasses(Class<? extends Throwable>... toBeThrown) {
for (Class<? extends Throwable> throwable: toBeThrown) {
answers.add(new ThrowsExceptionClass(throwable));
return this;
package org.mockito.internal.stubbing.answers;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.objenesis.ObjenesisHelper;
import static org.mockito.internal.exceptions.Reporter.notAnException;
import java.io.Serializable;
public class ThrowsExceptionClass implements Answer<Object>, Serializable {
private final Class<? extends Throwable> throwableClass;
private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {
this.throwableClass = checkNonNullThrowable(throwableClass);
private Class<? extends Throwable> checkNonNullThrowable(Class<? extends Throwable> throwableClass) {
if(throwableClass == null || !Throwable.class.isAssignableFrom(throwableClass)) {
throw notAnException();
return throwableClass;
public Object answer(InvocationOnMock invocation) throws Throwable {
Throwable throwable = ObjenesisHelper.newInstance(throwableClass);
throwable.fillInStackTrace();
filter.filter(throwable);
throw throwable;
public Class<? extends Throwable> getThrowableClass() {
return throwableClass;
import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
try {
mock.add("throw");
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
assertEquals(expected, e);
try {
mock.clear();
fail();
when(mock.get(1)).thenThrow(new ExceptionOne());
try {
when(mock.get(1)).thenThrow(new ExceptionTwo());
fail();
try {
reader.read();
fail();
assertEquals(ioException, e);
try {
mock.add("quake");
fail();
assertEquals(error, e);
public void shouldNotAllowSettingInvalidCheckedException() throws Exception {
public void shouldNotAllowSettingNullThrowable() throws Exception {
public void shouldNotAllowSettingNullThrowableArray() throws Exception {
public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {
when(mock.add("")).thenThrow(NaughtyException.class);
mock.add("");MethodGraph.Node node = compiler
.compile(new TypeDescription.ForLoadedType(instance.getClass()))
.locate(new MethodDescription.ForLoadedMethod(origin).asSignatureToken());
return node.getSort().isResolved() && !node.getRepresentative().represents(origin);import org.mockito.invocation.InvocationFactory;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
<T> MockCreationSettings<T> build(Class<T> typeToMock);
import org.mockito.invocation.MockHandler;
import org.mockito.stubbing.Stubbing;
MockHandler getMockHandler();
import org.mockito.internal.InternalMockHandler;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationFactory;
import org.mockito.invocation.MockHandler;
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationFactory;
import org.mockito.plugins.MockitoPlugins;
MockitoPlugins getPlugins();
InvocationFactory getInvocationFactory();
package org.mockito;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
public @interface NotExtensible {
public interface InternalMockHandler<T> extends MockHandler {}
import org.mockito.internal.stubbing.InvocationContainerImpl;
import java.util.Arrays;
import java.util.List;
import static org.mockito.internal.exceptions.Reporter.*;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.mockito.internal.util.MockUtil.*;
import static org.mockito.internal.verification.VerificationModeFactory.noMoreInteractions;
MockCreationSettings<T> creationSettings = impl.build(typeToMock);
getInvocationContainer(m).clearInvocations();
InvocationContainerImpl invocations = getInvocationContainer(mock);
InvocationContainerImpl container = getInvocationContainer(m);
List<Invocation> ins = container.getInvocations();
package org.mockito.internal.configuration.plugins;
import org.mockito.plugins.AnnotationEngine;
import org.mockito.plugins.InstantiatorProvider;
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
import org.mockito.plugins.PluginSwitch;
import org.mockito.plugins.StackTraceCleanerProvider;
import java.util.HashMap;
import java.util.Map;
class DefaultMockitoPlugins implements MockitoPlugins {
private final static Map<String, String> DEFAULT_PLUGINS = new HashMap<String, String>();
static final String INLINE_ALIAS = "mock-maker-inline";
static {
DEFAULT_PLUGINS.put(PluginSwitch.class.getName(), DefaultPluginSwitch.class.getName());
DEFAULT_PLUGINS.put(MockMaker.class.getName(), "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
DEFAULT_PLUGINS.put(StackTraceCleanerProvider.class.getName(), "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
DEFAULT_PLUGINS.put(InstantiatorProvider.class.getName(), "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
DEFAULT_PLUGINS.put(AnnotationEngine.class.getName(), "org.mockito.internal.configuration.InjectingAnnotationEngine");
DEFAULT_PLUGINS.put(INLINE_ALIAS, "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
public <T> T getDefaultPlugin(Class<T> pluginType) {
String className = DEFAULT_PLUGINS.get(pluginType.getName());
return create(pluginType, className);
String getDefaultPluginClass(String classOrAlias) {
return DEFAULT_PLUGINS.get(classOrAlias);
private <T> T create(Class<T> pluginType, String className) {
if (className == null) {
throw new IllegalStateException(
"No default implementation for requested Mockito plugin type: " + pluginType.getName() + "\n"
+ "Is this a valid Mockito plugin type? If yes, please report this problem to Mockito team.\n"
+ "Otherwise, please check if you are passing valid plugin type.\n"
+ "Examples of valid plugin types: MockMaker, StackTraceCleanerProvider.");
try {
return pluginType.cast(Class.forName(className).newInstance());
throw new IllegalStateException("Internal problem occurred, please report it. " +
"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. " +
"Failed to load " + pluginType, e);
public MockMaker getInlineMockMaker() {
return create(MockMaker.class, DEFAULT_PLUGINS.get(INLINE_ALIAS));
private final DefaultMockitoPlugins plugins = new DefaultMockitoPlugins();
private String alias;
PluginLoader withAlias(String name) {
alias = name;
<T> T loadPlugin(final Class<T> pluginType) {
return plugins.getDefaultPlugin(pluginType);
String classOrAlias = new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));
if (classOrAlias != null) {
if (classOrAlias.equals(alias)) {
classOrAlias = plugins.getDefaultPluginClass(alias);
Class<?> pluginClass = loader.loadClass(classOrAlias);
.loadPlugin(PluginSwitch.class);
.withAlias(DefaultMockitoPlugins.INLINE_ALIAS)
.loadPlugin(MockMaker.class);
.loadPlugin(StackTraceCleanerProvider.class);
.loadPlugin(InstantiatorProvider.class);
.loadPlugin(AnnotationEngine.class);
import org.mockito.plugins.MockitoPlugins;
public static MockitoPlugins getPlugins() {
return new DefaultMockitoPlugins();
public <T> MockCreationSettings<T> build(Class<T> typeToMock) {
return validatedSettings(typeToMock, (CreationSettings<T>) this);
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(handler, settings);
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(newHandler, settings);
import org.mockito.internal.invocation.RealMethod;
import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
public class InterceptedInvocation implements Invocation, VerificationAwareInvocation {
private final RealMethod realMethod;
RealMethod realMethod,
this.realMethod = realMethod;
if (!realMethod.isInvokable()) {
return realMethod.invoke();
public final static RealMethod NO_OP = new RealMethod() {
public boolean isInvokable() {
return false;
public Object invoke() throws Throwable {
return null;
import org.mockito.internal.invocation.RealMethod;
RealMethod realMethod;
realMethod = new SerializableRealMethodCall(identifier, origin, instance, arguments);
realMethod = new RealMethodCall(selfCallInfo, origin, instance, arguments);
realMethod,
MethodGraph.Node node = compiler
.compile(new TypeDescription.ForLoadedType(instance.getClass()))
.locate(new MethodDescription.ForLoadedMethod(origin).asSignatureToken());
return node.getSort().isResolved() && !node.getRepresentative().represents(origin);
private static class RealMethodCall implements RealMethod {
private RealMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
private static class SerializableRealMethodCall implements RealMethod {
private SerializableRealMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
import net.bytebuddy.implementation.bind.annotation.AllArguments;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.BindingPriority;
import net.bytebuddy.implementation.bind.annotation.FieldValue;
import net.bytebuddy.implementation.bind.annotation.Origin;
import net.bytebuddy.implementation.bind.annotation.RuntimeType;
import net.bytebuddy.implementation.bind.annotation.StubValue;
import net.bytebuddy.implementation.bind.annotation.SuperCall;
import net.bytebuddy.implementation.bind.annotation.This;
import org.mockito.internal.invocation.RealMethod;
final MockHandler handler;
public MockMethodInterceptor(MockHandler handler, MockCreationSettings mockCreationSettings) {
RealMethod realMethod) throws Throwable {
realMethod,
RealMethod realMethod,
return handler.handle(createInvocation(mock, invokedMethod, arguments, realMethod, mockCreationSettings, location));
public static InterceptedInvocation createInvocation(Object mock, Method invokedMethod, Object[] arguments, RealMethod realMethod, MockCreationSettings settings, Location location) {
return new InterceptedInvocation(
createMockitoMethod(invokedMethod, settings),
realMethod,
);
public static InterceptedInvocation createInvocation(Object mock, Method invokedMethod, Object[] arguments, RealMethod realMethod, MockCreationSettings settings) {
return createInvocation(mock, invokedMethod, arguments, realMethod, settings, new LocationImpl());
private static MockitoMethod createMockitoMethod(Method method, MockCreationSettings settings) {
if (settings.isSerializable()) {
new RealMethod.FromCallable(superCall)
RealMethod.IsIllegal.INSTANCE
import java.lang.reflect.Modifier;
mockAccess.setMockitoInterceptor(new MockMethodInterceptor(handler, settings));
new MockMethodInterceptor(newHandler, settings)
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.invocation.DefaultInvocationFactory;
import org.mockito.invocation.InvocationFactory;
import org.mockito.plugins.MockitoPlugins;
public MockitoPlugins getPlugins() {
return Plugins.getPlugins();
public InvocationFactory getInvocationFactory() {
return new DefaultInvocationFactory();
import org.mockito.invocation.InvocationContainer;
import java.util.List;
import static org.mockito.internal.exceptions.Reporter.invocationListenerThrewException;
class InvocationNotifierHandler<T> implements MockHandler<T> {
private final MockHandler<T> mockHandler;
public InvocationNotifierHandler(MockHandler<T> mockHandler, MockCreationSettings<T> settings) {
import org.mockito.invocation.MockHandler;
public static <T> MockHandler<T> createMockHandler(MockCreationSettings<T> settings) {
MockHandler<T> handler = new MockHandlerImpl<T>(settings);
MockHandler<T> nullResultGuardian = new NullResultGuardian<T>(handler);
import org.mockito.invocation.InvocationContainer;
import org.mockito.invocation.MockHandler;
import java.util.List;
public class MockHandlerImpl<T> implements MockHandler<T> {
InvocationContainerImpl invocationContainer;
this.invocationContainer = new InvocationContainerImpl( mockSettings);
if (invocationContainer.hasAnswersForStubbing()) {
invocationContainer.setMethodForStubbing(invocationMatcher);
VerificationDataImpl data = createVerificationData(invocationContainer, invocationMatcher);
invocationContainer.setInvocationForPotentialStubbing(invocationMatcher);
OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainer);
StubbedInvocationMatcher stubbing = invocationContainer.findAnswerFor(invocation);
notifyStubbedAnswerLookup(invocation, stubbing);
if (stubbing != null) {
stubbing.captureArgumentsFrom(invocation);
return stubbing.answer(invocation);
invocationContainer.resetInvocationForPotentialStubbing(invocationMatcher);
return invocationContainer;
private VerificationDataImpl createVerificationData(InvocationContainerImpl invocationContainer, InvocationMatcher invocationMatcher) {
return new VerificationDataImpl(invocationContainer, invocationMatcher);
import org.mockito.invocation.InvocationContainer;
import org.mockito.invocation.MockHandler;
import static org.mockito.internal.util.Primitives.defaultValue;
class NullResultGuardian<T> implements MockHandler<T> {
private final MockHandler<T> delegate;
public NullResultGuardian(MockHandler<T> delegate) {
package org.mockito.internal.invocation;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationFactory;
import org.mockito.mock.MockCreationSettings;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
public class DefaultInvocationFactory implements InvocationFactory {
public Invocation createInvocation(Object target, MockCreationSettings settings, Method method, Callable realMethod, Object... args) {
RealMethod.FromCallable superMethod = new RealMethod.FromCallable(realMethod);
return MockMethodInterceptor.createInvocation(target, method, args, superMethod, settings);
package org.mockito.internal.invocation;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.invocation.InvocationOnMock;
import java.io.Serializable;
import java.util.concurrent.Callable;
public interface RealMethod extends Serializable {
enum IsIllegal implements RealMethod {
INSTANCE;
public boolean isInvokable() {
return false;
public Object invoke() {
throw new IllegalStateException();
class FromCallable implements RealMethod {
private static final long serialVersionUID = 47957363950483625L;
private final Callable<?> callable;
public FromCallable(Callable<?> callable) {
this.callable = callable;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
try {
return callable.call();
new ConditionalStackTraceFilter().filter(t);
throw t;
boolean isInvokable();
Object invoke() throws Throwable;
import org.mockito.stubbing.Stubbing;
import java.util.LinkedList;
import java.util.List;
List<Stubbing> fromSingleMock = MockUtil.getInvocationContainer(mock).getStubbedInvocations();
for(Stubbing s : fromSingleMock) {
import org.mockito.invocation.InvocationContainer;
import org.mockito.invocation.MatchableInvocation;
import org.mockito.stubbing.Stubbing;
private MatchableInvocation invocationForStubbing;
public void setInvocationForPotentialStubbing(MatchableInvocation invocation) {
public void resetInvocationForPotentialStubbing(MatchableInvocation invocationMatcher) {
public void setMethodForStubbing(MatchableInvocation invocation) {
public List<Stubbing> getStubbedInvocations() {
return (List) stubbed;
public MatchableInvocation getInvocationForStubbing() {
private final InvocationContainerImpl invocationContainer;
public OngoingStubbingImpl(InvocationContainerImpl invocationContainer) {
this.invocationContainer = invocationContainer;
if(!invocationContainer.hasInvocationForPotentialStubbing()) {
invocationContainer.addAnswer(answer);
return new ConsecutiveStubbing<T>(invocationContainer);
return invocationContainer.getInvocations();
return (M) invocationContainer.invokedMock();
import org.mockito.invocation.MatchableInvocation;
public class StubbedInvocationMatcher extends InvocationMatcher implements Serializable, Stubbing {
public StubbedInvocationMatcher(MatchableInvocation invocation, Answer answer) {
MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
import org.mockito.stubbing.Stubbing;
InvocationContainerImpl container = MockUtil.getInvocationContainer(invocation.getMock());
for (Stubbing stubbing : container.getStubbedInvocations()) {
if (container.getInvocationForStubbing().matches(stubbing.getInvocation())) {
return stubbing.answer(invocation);
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockito.invocation.MockHandler;
import org.mockito.stubbing.Stubbing;
return getInvocationContainer().getInvocations();
private InvocationContainerImpl getInvocationContainer() {
assertGoodMock();
return MockUtil.getInvocationContainer(toInspect);
List<? extends Stubbing> stubbings = getInvocationContainer().getStubbedInvocations();
public MockHandler getMockHandler() {
return mockHandler();
private MockHandler<Object> mockHandler() {
return MockUtil.getMockHandler(toInspect);
import org.mockito.internal.stubbing.InvocationContainerImpl;
import static org.mockito.internal.handler.MockHandlerFactory.createMockHandler;
MockHandler oldHandler = getMockHandler(mock);
public static <T> MockHandler<T> getMockHandler(T mock) {
return mockMaker.getHandler(mock);
public static InvocationContainerImpl getInvocationContainer(Object mock) {
return (InvocationContainerImpl) getMockHandler(mock).getInvocationContainer();
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockito.invocation.MatchableInvocation;
import java.util.List;
private final InvocationContainerImpl invocations;
public VerificationDataImpl(InvocationContainerImpl invocations, InvocationMatcher wanted) {
import org.mockito.NotExtensible;
package org.mockito.invocation;
import org.mockito.Incubating;
import org.mockito.NotExtensible;
public interface InvocationContainer {}
package org.mockito.invocation;
import org.mockito.Incubating;
import org.mockito.MockitoFramework;
import org.mockito.mock.MockCreationSettings;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
public interface InvocationFactory {
Invocation createInvocation(Object target, MockCreationSettings settings, Method method, Callable realMethod, Object... args);
import org.mockito.Incubating;
import org.mockito.MockSettings;
import org.mockito.mock.MockCreationSettings;
public interface MockHandler<T> extends Serializable {
MockCreationSettings<T> getMockSettings();
InvocationContainer getInvocationContainer();
import org.mockito.NotExtensible;
package org.mockito.plugins;
import org.mockito.MockitoFramework;
public interface MockitoPlugins {
<T> T getDefaultPlugin(Class<T> pluginType);
MockMaker getInlineMockMaker();
import org.mockito.NotExtensible;
public interface Stubbing extends Answer {
import org.mockito.internal.exceptions.ReporterTest;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
package org.mockito;
import org.junit.Before;
import org.junit.Test;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.MockHandler;
import org.mockitoutil.TestBase;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
public class StaticMockingExperimentTest extends TestBase {
Foo mock = Mockito.mock(Foo.class);
MockHandler handler = Mockito.mockingDetails(mock).getMockHandler();
Method staticMethod;
Callable realMethod = new Callable() {
public Object call() throws Exception {
return null;
staticMethod = Foo.class.getDeclaredMethod("staticMethod", String.class);
public void verify_static_method() throws Throwable {
Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"some arg");
handler.handle(invocation);
verify(mock);
Invocation verification = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"some arg");
handler.handle(verification);
verify(mock, times(0));
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"different arg");
handler.handle(differentArg);
public void verification_failure_static_method() throws Throwable {
Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"foo");
handler.handle(invocation);
verify(mock);
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"different arg");
try {
handler.handle(differentArg);
fail();
public void stubbing_static_method() throws Throwable {
Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"foo");
handler.handle(invocation);
when(null).thenReturn("hey");
assertEquals("hey", handler.handle(invocation));
assertEquals("hey", handler.handle(invocation));
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"different arg");
assertEquals(null, handler.handle(differentArg));
public void do_answer_stubbing_static_method() throws Throwable {
doReturn("hey").when(mock);
Invocation invocation = Mockito.framework().getInvocationFactory()
.createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "foo");
handler.handle(invocation);
assertEquals("hey", handler.handle(invocation));
assertEquals("hey", handler.handle(invocation));
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"different arg");
assertEquals(null, handler.handle(differentArg));
public void verify_no_more_interactions() throws Throwable {
verifyNoMoreInteractions(mock);
Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod,
"foo");
handler.handle(invocation);
try {
verifyNoMoreInteractions(mock);
fail();
public void stubbing_new() throws Throwable {
Constructor<Foo> ctr = Foo.class.getConstructor(String.class);
Method adapter = ConstructorMethodAdapter.class.getDeclaredMethods()[0];
doReturn(new Foo("hey!")).when(mock);
Invocation constructor = Mockito.framework().getInvocationFactory().createInvocation(
mock, withSettings().build(Foo.class), adapter, realMethod, ctr, "foo");
handler.handle(constructor);
Object result = handler.handle(constructor);
assertEquals("foo:hey!", result.toString());
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class),
adapter, realMethod, ctr, "different arg");
Object result2 = handler.handle(differentArg);
assertEquals(null, result2);
public void verifying_new() throws Throwable {
Constructor<Foo> ctr = Foo.class.getConstructor(String.class);
Method adapter = ConstructorMethodAdapter.class.getDeclaredMethods()[0];
Invocation constructor = Mockito.framework().getInvocationFactory().createInvocation(
mock, withSettings().build(Foo.class), adapter, realMethod, ctr, "matching arg");
handler.handle(constructor);
verify(mock);
handler.handle(constructor);
verify(mock);
Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class),
adapter, realMethod, ctr, "different arg");
try {
handler.handle(differentArg);
fail();
assertThat(e.getMessage())
.contains("matching arg")
.contains("different arg");
static class Foo {
private final String arg;
public Foo(String arg) {
this.arg = arg;
public static String staticMethod(String arg) {
return "";
public String toString() {
return "foo:" + arg;
interface ConstructorMethodAdapter {
Object construct(Constructor constructor, Object... args);
package org.mockito.internal.configuration.plugins;
import org.junit.Test;
import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import org.mockito.plugins.MockMaker;
import org.mockitoutil.TestBase;
import static org.junit.Assert.*;
import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.INLINE_ALIAS;
public class DefaultMockitoPluginsTest extends TestBase {
private DefaultMockitoPlugins plugins = new DefaultMockitoPlugins();
public void provides_plugins() throws Exception {
assertEquals("org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker",
plugins.getDefaultPluginClass(INLINE_ALIAS));
assertEquals(InlineByteBuddyMockMaker.class, plugins.getInlineMockMaker().getClass());
assertEquals(ByteBuddyMockMaker.class, plugins.getDefaultPlugin(MockMaker.class).getClass());
import org.mockito.invocation.InvocationContainer;
private static class DummyMockHandler implements MockHandler<Object> {
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.invocation.MockHandler;
MockHandler<?> handler = createMockHandler(settings);
MockHandler<?> handler =  createMockHandler(settings);
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
private Invocation invocation = mock(Invocation.class);
handler.invocationContainer = mock(InvocationContainerImpl.class);
given(handler.invocationContainer.findAnswerFor(any(Invocation.class))).willReturn(value);
import org.mockito.internal.creation.bytebuddy.InterceptedInvocation;
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import static org.mockito.internal.creation.bytebuddy.InterceptedInvocation.NO_OP;
Invocation i = new InterceptedInvocation(mock,
new SerializableMethod(method),
args,
NO_OP,
location == null ? new LocationImpl() : location,
1);
import java.util.ArrayList;
package org.mockito.internal.util;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.mock.MockCreationSettings;
import org.mockitoutil.TestBase;
import java.util.List;
import static org.junit.Assert.assertEquals;
public class MockSettingsTest extends TestBase {
public void public_api_for_creating_settings() throws Exception {
MockCreationSettings<List> settings = Mockito.withSettings()
.name("dummy")
.build(List.class);
assertEquals(List.class, settings.getTypeToMock());
assertEquals("dummy", settings.getMockName().toString());
package org.mockitousage.plugins;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.plugins.AnnotationEngine;
import org.mockito.plugins.InstantiatorProvider;
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
import org.mockito.plugins.PluginSwitch;
import org.mockito.plugins.StackTraceCleanerProvider;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.assertNotNull;
public class MockitoPluginsTest extends TestBase {
private final MockitoPlugins plugins = Mockito.framework().getPlugins();
assertNotNull(plugins.getInlineMockMaker());
assertNotNull(plugins.getDefaultPlugin(MockMaker.class));
assertNotNull(plugins.getDefaultPlugin(StackTraceCleanerProvider.class));
assertNotNull(plugins.getDefaultPlugin(PluginSwitch.class));
assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider.class));
assertNotNull(plugins.getDefaultPlugin(AnnotationEngine.class));
import org.mockito.internal.creation.bytebuddy.InterceptedInvocation;
return new InterceptedInvocation(mock(type), new SerializableMethod(type.getMethod(methodName,
types)), args, InterceptedInvocation.NO_OP, new LocationImpl(), 1);import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import org.mockito.invocation.InvocationContainer;
import org.mockito.stubbing.*;
import org.mockito.verification.*;if (dispatcher == null || !dispatcher.isMocked(mock) || !dispatcher.isOverridden(mock, origin)) {
Class<?> currentType = instance.getClass();
do {
try {
return origin.equals(currentType.getDeclaredMethod(origin.getName(), origin.getParameterTypes()));
currentType = currentType.getSuperclass();
return true;
private static class NonFinalMethod {
public String foo() {
return "foo";
private interface SampleInterface {
String bar();.load(new MultipleParentClassLoader.Builder()
.append(features.mockedType)
.append(features.interfaces)
.append(currentThread().getContextClassLoader())
.append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
.append(MockMethodInterceptor.class,
MockMethodInterceptor.ForHashCode.class,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
loader.getStrategy(features.mockedType))import static org.mockito.BDDMockito.anyObject;
import static org.mockito.BDDMockito.anyVararg;
given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());
given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());
given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());
given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));
public void can_return_based_on_strongly_typed_four_parameter_function() throws Exception {import org.mockito.internal.stubbing.answers.AnswersWithDelay;
public static <T> Answer<T> answersWithDelay(long sleepyTime, Answer<T> answer) {
return (Answer<T>) new AnswersWithDelay(sleepyTime, (Answer<Object>) answer);
import org.mockito.exceptions.base.MockitoException;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringUtil.join;
ClassLoader classLoader = new MultipleParentClassLoader.Builder()
.append(features.mockedType)
.append(features.interfaces)
.append(currentThread().getContextClassLoader())
.append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
.append(MockMethodInterceptor.class,
MockMethodInterceptor.ForHashCode.class,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader());
if (classLoader != features.mockedType.getClassLoader()) {
assertVisibility(features.mockedType);
for (Class<?> iFace : features.interfaces) {
assertVisibility(iFace);
builder = builder.ignoreAlso(isPackagePrivate()
.or(returns(isPackagePrivate()))
.or(hasParameters(whereAny(hasType(isPackagePrivate())))));
.load(classLoader, loader.getStrategy(features.mockedType))
private static void assertVisibility(Class<?> type) {
if (!Modifier.isPublic(type.getModifiers())) {
throw new MockitoException(join("Cannot create mock for " + type,
"",
"The type is not public and its mock class is loaded by a different class loader.",
"This can have multiple reasons:",
" - You are mocking a class with additional interfaces of another class loader",
" - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)",
" - The thread's context class loader is different than the mock's class loader"));
package org.mockito.internal.stubbing.answers;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.ValidableAnswer;
import java.io.Serializable;
import java.util.concurrent.TimeUnit;
public class AnswersWithDelay implements Answer<Object>, ValidableAnswer, Serializable {
private static final long serialVersionUID = 2177950597971260246L;
private final long sleepyTime;
private final Answer<Object> answer;
public AnswersWithDelay(final long sleepyTime, final Answer<Object> answer) {
this.sleepyTime = sleepyTime;
this.answer = answer;
public Object answer(final InvocationOnMock invocation) throws Throwable {
TimeUnit.MILLISECONDS.sleep(sleepyTime);
return answer.answer(invocation);
public void validateFor(final InvocationOnMock invocation) {
if (answer instanceof ValidableAnswer) {
((ValidableAnswer) answer).validateFor(invocation);
package org.mockito.internal.stubbing.answers;
import org.junit.Test;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.invocation.InvocationBuilder;
import java.util.Date;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
public class AnswersWithDelayTest {
public void should_return_value() throws Throwable {
assertThat(new AnswersWithDelay(1, new Returns("value")).answer(new InvocationBuilder().method("oneArg").arg("A").toInvocation())).isEqualTo("value");
public void should_fail_when_contained_answer_should_fail() throws Throwable {
new AnswersWithDelay(1, new Returns("one")).validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
public void should_succeed_when_contained_answer_should_succeed() throws Throwable {
new AnswersWithDelay(1, new Returns("one")).validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_delay() throws Throwable {
final long sleepyTime = 500L;
final AnswersWithDelay testSubject = new AnswersWithDelay(sleepyTime, new Returns("value"));
final Date before = new Date();
testSubject.answer(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
final Date after = new Date();
final long timePassed = after.getTime() - before.getTime();
assertThat(timePassed).isCloseTo(sleepyTime, within(15L));
import static org.assertj.core.api.Assertions.within;
import static org.mockito.AdditionalAnswers.answersWithDelay;
import java.util.Date;
given(iMethods.objectArgMethod(any())).will(returnsFirstArg());
given(iMethods.threeArgumentMethod(eq(0), any(), anyString())).will(returnsSecondArg());
given(iMethods.threeArgumentMethod(eq(1), any(), anyString())).will(returnsLastArg());
public void can_return_after_delay() throws Exception {
final long sleepyTime = 500L;
given(iMethods.objectArgMethod(any())).will(answersWithDelay(sleepyTime, returnsFirstArg()));
final Date before = new Date();
assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
final Date after = new Date();
final long timePassed = after.getTime() - before.getTime();
assertThat(timePassed).isCloseTo(sleepyTime, within(15L));
given(iMethods.varargsObject(eq(1), any())).will(returnsArgAt(3));
public void can_return_based_on_strongly_typed_four_parameter_function() throws Exception {private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
void shouldHaveNoInteractions();
public void shouldHaveNoInteractions() {
verifyNoInteractions(mock);
MockSettings useConstructor();
import org.mockito.quality.Strictness;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
public static void verifyNoInteractions(Object... mocks) {
MOCKITO_CORE.verifyNoInteractions(mocks);
MockitoFramework addListener(MockitoListener listener);
import org.mockito.junit.MockitoRule;
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
public InOrderImpl(List<? extends Object> mocksToBeVerifiedInOrder) {
import static org.mockito.internal.verification.VerificationModeFactory.noInteractions;
import java.util.Set;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.VerificationListener;
public void verifyNoInteractions(Object... mocks) {
assertMocksNotEmpty(mocks);
mockingProgress().validateState();
for (Object mock : mocks) {
if (mock == null) {
throw nullPassedToVerifyNoMoreInteractions();
if (!isMock(mock)) {
throw notAMockPassedToVerifyNoMoreInteractions();
InvocationContainer invocations = getMockHandler(mock).getInvocationContainer();
VerificationDataImpl data = new VerificationDataImpl(invocations, null);
noInteractions().verify(data);
assertNotInterface(instance, field.getType());
field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
.spiedInstance(instance)
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName())));
field.set(testInstance, newSpyInstance(testInstance, field));
private static void assertNotInterface(Object testInstance, Class<?> type) {
type = testInstance != null? testInstance.getClass() : type;
if (type.isInterface()) {
throw new MockitoException("Type '" + type.getSimpleName() + "' is an interface and it cannot be spied on.");
private static Object newSpyInstance(Object testInstance, Field field)
MockSettings settings = withSettings()
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName());
if (!Modifier.isStatic(type.getModifiers())) {
if (enclosing != null) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException("@Spy annotation can only initialize inner classes declared in the test. "
+ "Inner class: '" + type.getSimpleName() + "', "
+ "outer class: '" + enclosing.getSimpleName() + "'.");
return Mockito.mock(type, settings
.useConstructor()
.outerInstance(testInstance));
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has 0-arg constructor.");
if (Modifier.isPrivate(constructor.getModifiers())) {
constructor.setAccessible(true);
return Mockito.mock(type, settings
.spiedInstance(constructor.newInstance()));
return Mockito.mock(type, settings.useConstructor());
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation, Field field, Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());
import org.mockito.internal.util.reflection.SuperTypesLastSorter;
return method.getParameterTypes();
public MockSettings useConstructor() {
import static org.mockito.internal.util.StringJoiner.join;
import org.mockito.plugins.MockMaker;
import static org.mockito.internal.util.StringJoiner.join;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
import java.lang.instrument.UnmodifiableClassException;
import static net.bytebuddy.implementation.MethodDelegation.to;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
import org.mockito.internal.debugging.LocationImpl;
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), arguments);
location = new LocationImpl();
import static org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.hideRecursiveCall;
superMethod));
return handler.handle(new InterceptedInvocation(
createMockitoMethod(invokedMethod),
SequenceNumber.next()
import static org.mockito.internal.util.StringJoiner.join;
.transform(withModifiers(SynchronizationState.PLAIN, Visibility.PUBLIC))
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import static org.mockito.internal.util.StringJoiner.join;
private final Object outerClassInstance;
public ConstructorInstantiator(Object outerClassInstance) {
this.outerClassInstance = outerClassInstance;
if (outerClassInstance == null) {
return noArgConstructor(cls);
return withParams(cls, outerClassInstance);
private static <T> T withParams(Class<T> cls, Object... params) {
return invokeConstructor(constructor, params);
throw paramsException(cls, null);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.")
if (!types[i].isInstance(params[i])) {
private static <T> T noArgConstructor(Class<T> cls) {
try {
return invokeConstructor(cls.getDeclaredConstructor());
throw new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure it has 0-arg constructor which invokes cleanly."),
t);
if (settings != null && settings.isUsingConstructor()) {
return new ConstructorInstantiator(settings.getOuterClassInstance());
sb.append("[Mockito] Unused stubbings of: ").append(mock).append("\n");
stackTraceHolder = new Throwable();
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.internal.junit.JUnitTool;
import org.mockito.internal.util.StringJoiner;
import static org.mockito.internal.util.StringJoiner.join;
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);"
return JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
public static MockitoAssertionError noInteractionsWanted(Object mock, List<VerificationAwareInvocation> invocations) {
ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
String scenario = scenarioPrinter.print(invocations);
List<Location> locations = new ArrayList<Location>();
for (VerificationAwareInvocation invocation : invocations) {
locations.add(invocation.getLocation());
return new NoInteractionsWanted(join(
"No interactions wanted here:",
new LocationImpl(),
"But found these interactions on mock '" + safelyGetMockName(mock) + "':",
join("", locations),
scenario
));
"...it does not make much sense - the test would have passed immediately in concurency",
return new MockitoException(StringJoiner.join(
public static void potentialStubbingProblemByJUnitRule(
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);
parameterTypes = method.getParameterTypes();
return method.getName().equals("matches");
StubbingArgMismatches getStubbingArgMismatches(Iterable<Object> mocks) {
Strictness currentStrictness;
Reporter.potentialStubbingProblemByJUnitRule(invocation, argMismatchStubbings);
package org.mockito.internal.junit;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
class FriendlyExceptionMaker {
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
if (!detector.hasJUnit()) {
return new ArgumentsAreDifferent(message);
try {
Class<?> clazz = Class.forName("org.mockito.exceptions.verification.junit.ArgumentsAreDifferent");
return (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);
return new ArgumentsAreDifferent(message);
package org.mockito.internal.junit;
class JUnitDetector {
private boolean hasJUnit;
JUnitDetector() {
try {
Class.forName("junit.framework.ComparisonFailure");
hasJUnit = true;
hasJUnit = false;
public boolean hasJUnit() {
return hasJUnit;
package org.mockito.internal.junit;
public class JUnitTool {
private static final JUnitDetector detector = new JUnitDetector();
public static boolean hasJUnit() {
return detector.hasJUnit();
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import java.util.*;
class UniversalTestListener implements MockitoTestListener {
UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private static void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null) {
this.stubbingLookupListener.currentStrictness = strictness;
if (unused.size() == 0) {
if (unused.size() > 0) {
import java.util.LinkedList;
private final LinkedList<Object> arguments = new LinkedList<Object>();
if (arguments.isEmpty()) {
throw noArgumentValueWasCaptured();
return (T) arguments.getLast();
return (List) arguments;
this.arguments.add(argument);
import org.mockito.ArgumentMatcher;
import org.mockito.internal.util.Decamelizer;
import org.mockito.internal.util.ObjectMethodsGuru;
return Decamelizer.decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.invocation.Invocation;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
this.target = target;
super.testFinished(description);
"Haven't you forgot @Test annotation?\n"
import org.mockito.internal.stubbing.answers.DoesNothing;
answers.add(new DoesNothing());
public Object answer(InvocationOnMock invocation) throws Throwable {
return this.method.getReturnType() == Void.TYPE;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return Optional.empty();
return OptionalDouble.empty();
return OptionalInt.empty();
return OptionalLong.empty();
return Stream.empty();
return DoubleStream.empty();
return IntStream.empty();
return LongStream.empty();
throw new IllegalArgumentException(checkedValue + " should not be null");
package org.mockito.internal.util;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class Decamelizer {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while(match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
m.getName().equals("toString");
&& method.getName().equals("compareTo")
return String.format("Java               : %s\n" +
package org.mockito.internal.util;
public class RemoveFirstLine {
public String of(String text) {
return text.replaceFirst(".*?\n", "");
package org.mockito.internal.util;
import static java.util.Arrays.asList;
public class StringJoiner {
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Iterable<?> lines) {
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(line.toString()).append("\n");
int lastBreak = out.lastIndexOf("\n");
return out.replace(lastBreak, lastBreak+1, "").toString();
package org.mockito.internal.util.reflection;
import java.lang.reflect.Constructor;
public abstract class Constructors {
public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {
try {
return classToMock.getDeclaredConstructor();
return null;
Type genericInterface = findGenericInteface(match, targetBaseInterface);
private static Type findGenericInteface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInteface(inter, targetBaseInterface);
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.invocation.MatchableInvocation;
import static org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.check;
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import java.util.List;
check( allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.util.ObjectMethodsGuru;
package org.mockito.internal.verification;
import java.util.List;
import org.mockito.internal.verification.api.VerificationData;
import org.mockito.invocation.Invocation;
import org.mockito.verification.VerificationMode;
import static org.mockito.internal.exceptions.Reporter.noInteractionsWanted;
public class NoInteractions implements VerificationMode {
public void verify(VerificationData data) {
List<Invocation> invocations = data.getAllInvocations();
if (!invocations.isEmpty()) {
throw noInteractionsWanted(invocations.get(0).getMock(), (List) invocations);
public VerificationMode description(String description) {
return VerificationModeFactory.description(this, description);
import org.mockito.internal.invocation.InvocationMatcher;
if (invocations.size() != 1 && chunk.size() > 0) {
if (invocations.size() != 1 || chunk.size() == 0) {
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;
import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;
NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();
numberOfInvocations.check(invocations, wanted, wantedCount);
NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();
numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());
public static NoInteractions noInteractions() {
return new NoInteractions();
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
package org.mockito.internal.verification.checkers;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerified;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
public class NonGreedyNumberOfInvocationsInOrderChecker {
private NonGreedyNumberOfInvocationsInOrderChecker() {}
public static void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
package org.mockito.internal.verification.checkers;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
public class NumberOfInvocationsInOrderChecker {
public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.verification.VerificationMode;
import static junit.framework.TestCase.assertFalse;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
public void shouldValidateMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions("notMock");
public void shouldValidateNullMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions(new Object[] { null });
when(mock.simpleMethod());
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
doAnswer(null);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
verify(mock);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedVerificationException.class);
anyObject();
detectsAndCleansUp(new OnVerifyNoInteractions(), InvalidUseOfMatchersException.class);
private static class OnVerifyNoInteractions implements DetectsInvalidState {
public void detect(IMethods mock) {
verifyNoInteractions(mock);
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
throwable = InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
new ConstructorInstantiator(null).newInstance(SomeClass2.class);
"Please ensure it has 0-arg constructor which invokes cleanly.");
public void should_print_stubbed_info_if_availbable() throws Exception {
import static org.mockito.ArgumentMatchers.any;
import java.util.List;
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
import org.assertj.core.api.SoftAssertions;
import org.mockito.internal.stubbing.answers.DoesNothing;
import java.util.Collections;
UnusedStubbings stubbings = new UnusedStubbings(Collections.emptyList());
UnusedStubbings stubbings = new UnusedStubbings(asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
SoftAssertions.assertSoftly(softly -> {
softly.assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
softly.assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
softly.assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
import org.assertj.core.api.Assertions;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
Assertions.assertThat(m.getAllValues()).containsSequence("foo", "bar");
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import org.mockito.internal.invocation.InvocationBuilder;
import static org.assertj.core.api.Assertions.assertThat;
public class DoesNothingTest {
public void should_do_nothing() throws Throwable {
assertThat(new DoesNothing().answer(new InvocationBuilder().method("voidMethod").toInvocation())).isNull();
public void should_fail_when_non_void_method_does_nothing() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_allow_void_return_for_void_method() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
void iAmNotAbstract() {};
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)
.args(parameters).toInvocation();
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isEmpty();
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static org.assertj.core.api.Assertions.assertThat;
assertTrue(((Number[]) values.returnValueFor(Number[].class)).length == 0);
assertThat((Optional) values.returnValueFor(Optional.class)).isEmpty();
assertThat((OptionalInt) values.returnValueFor(OptionalInt.class)).isEmpty();
assertThat((OptionalLong) values.returnValueFor(OptionalLong.class)).isEmpty();
assertThat((OptionalDouble) values.returnValueFor(OptionalDouble.class)).isEmpty();
public void should_return_empty_Streams() throws Exception {
assertThat((Stream) values.returnValueFor(Stream.class)).isEmpty();
assertThat(((DoubleStream) values.returnValueFor(DoubleStream.class)).count()).isEqualTo(0);
assertThat(((IntStream) values.returnValueFor(IntStream.class)).count()).isEqualTo(0);
assertThat(((LongStream) values.returnValueFor(LongStream.class)).count()).isEqualTo(0);
public void should_return_empty_string() {
package org.mockito.internal.util;
import org.junit.Test;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.assertEquals;
import static org.mockito.internal.util.Decamelizer.decamelizeMatcher;
public class DecamelizerTest extends TestBase {
public void shouldProduceDecentDescription() throws Exception {
assertEquals("<Sentence with strong language>", decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", decamelizeMatcher(""));
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.withSettings;
import org.mockito.Mockito;
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
package org.mockito.internal.verification;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.mock;
public class NoInteractionsTest extends TestBase {
public void noInteractionsExceptionMessageShouldDescribeMock() {
NoInteractions n = new NoInteractions();
IMethods mock = mock(IMethods.class, "a mock");
InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
InvocationContainerImpl invocations =
new InvocationContainerImpl( new MockSettingsImpl());
invocations.setInvocationForPotentialStubbing(i);
try {
n.verify(new VerificationDataImpl(invocations, null));
fail();
Assertions.assertThat(e.toString()).contains(mock.toString());
import java.util.Collections;
import static org.junit.Assert.*;
import org.mockito.internal.progress.VerificationModeBuilder;
import org.junit.Before;
import java.util.List;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
private NumberOfInvocationsChecker checker;
public void setup() {
checker = new NumberOfInvocationsChecker();
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 2);
checker.check(invocations, wanted, 1);
checker.check(invocations, wanted, 0);
checker.check(invocations, wanted, 1);
import org.assertj.core.api.Assertions;
private NumberOfInvocationsInOrderChecker checker;
checker = new NumberOfInvocationsInOrderChecker();
checker.check(invocations, wanted, 0, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 4, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 2, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 0, context);
Assertions.assertThat(invocation.isVerified()).isFalse();
checker.check(invocations, wanted, 1, context);
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
package org.mockito;
import java.util.Arrays;
public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.assertj.core.api.Assertions;
import java.util.*;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public void should_prevent_spying_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(withSpy);
fail();
Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
WithSpy withSpy = new WithSpy();
Assertions.assertThat(e.getMessage()).contains("0-arg constructor");
Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");
class WithMockAndSpy {
public void should_report_when_encosing_instance_is_needed() throws Exception {
class Inner {}
static class NestedClassWithoutDefinedConstructor { }
static class NestedClassWithNoArgConstructor {
NestedClassWithNoArgConstructor() { }
NestedClassWithNoArgConstructor(String f) { }
NoValidConstructor(String f) { }
ThrowingConstructor() { throw new RuntimeException("boo!"); }
public void should_not_allow_Spy_and_or_InjectMocks_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(new Object() { @Spy List<?> mock; });
fail();
Assertions.assertThat(me.getMessage()).contains("'List' is an interface");
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.internal.debugging.LocationImpl;
import java.util.concurrent.TimeUnit;
import org.assertj.core.api.Assertions;
public void shouldRemoveAllInteractionsVerifyNoInteractions() throws Exception {
mock.simpleMethod(1);
reset(mock);
verifyNoInteractions(mock);
public void shouldStubbingNotBeTreatedAsInteractionVerifyNoInteractions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
reset(mock);
verifyNoInteractions(mock);
import java.util.List;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.");
public void should_validate_that_mock_had_no_interactions() {
then(mock).shouldHaveNoInteractions();
import org.junit.Assert;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
inThread(new Runnable() {
inThread(new Runnable() {
private static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public void should_not_throw_any_exceptions_when_verifications_are_succesful() {
public void should_only_collect_failures_ignore_succesful_verifications() {
when(mock.oneArg(and(eq((double) 1), eq((double) 1)))).thenReturn("3");
when(mock.oneArg(and(eq((float) 1), eq((float) 1)))).thenReturn("4");
when(mock.oneArg(and(eq((int) 1), eq((int) 1)))).thenReturn("5");
when(mock.oneArg(and(eq((long) 1), eq((long) 1)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 1));
assertEquals("5", mock.oneArg((int) 1));
assertEquals("6", mock.oneArg((long) 1));
when(mock.oneArg(or(eq((double) 1), eq((double) 2)))).thenReturn("3");
when(mock.oneArg(or(eq((float) 1), eq((float) 2)))).thenReturn("4");
when(mock.oneArg(or(eq((int) 1), eq((int) 2)))).thenReturn("5");
when(mock.oneArg(or(eq((long) 1), eq((long) 2)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 1));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 1));
when(mock.oneArg(not(eq((double) 1)))).thenReturn("3");
when(mock.oneArg(not(eq((float) 1)))).thenReturn("4");
when(mock.oneArg(not(eq((int) 1)))).thenReturn("5");
when(mock.oneArg(not(eq((long) 1)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 2));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 2));
when(mock.oneArg(leq((double) 1))).thenReturn("3");
when(mock.oneArg(leq((float) 1))).thenReturn("4");
when(mock.oneArg(leq((int) 1))).thenReturn("5");
when(mock.oneArg(leq((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) -5));
assertEquals("5", mock.oneArg((int) -2));
assertEquals("6", mock.oneArg((long) -3));
when(mock.oneArg(lt((double) 1))).thenReturn("3");
when(mock.oneArg(lt((float) 1))).thenReturn("4");
when(mock.oneArg(lt((int) 1))).thenReturn("5");
when(mock.oneArg(lt((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 0));
assertEquals("4", mock.oneArg((float) -4));
assertEquals("5", mock.oneArg((int) -34));
assertEquals("6", mock.oneArg((long) -6));
when(mock.oneArg(geq((double) 1))).thenReturn("3");
when(mock.oneArg(geq((float) 1))).thenReturn("4");
when(mock.oneArg(geq((int) 1))).thenReturn("5");
when(mock.oneArg(geq((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 3));
assertEquals("5", mock.oneArg((int) 4));
assertEquals("6", mock.oneArg((long) 5));
when(mock.oneArg(gt((double) 1))).thenReturn("3");
when(mock.oneArg(gt((float) 1))).thenReturn("4");
when(mock.oneArg(gt((int) 1))).thenReturn("5");
when(mock.oneArg(gt((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 3));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 5));
assertEquals("matched", mock.forObject((Object) null));
when(mock.oneArg((Object) anyObject())).thenReturn("9");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 889));
assertEquals("5", mock.oneArg((int) 1));
assertEquals("6", mock.oneArg((long) 1));
verify(mock).simpleMethod((Object) eq(null));
verify(mock).simpleMethod((Object) same(null));
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
public void shouldRequireArgumentsWhenVerifyingNoInteractions() {
verifyNoInteractions();
public void shouldNotAllowMockingPrimitves() throws Exception {
public void shouldNotMockObjectMethodsOnInterfaceVerifyNoInteractions() throws Exception {
ObjectLikeInterface inter = mock(ObjectLikeInterface.class);
inter.equals(null);
inter.toString();
inter.hashCode();
verifyNoInteractions(inter);
public void shouldNotMockObjectMethodsOnClassVerifyNoInteractions() throws Exception {
Object clazz = mock(ObjectLikeInterface.class);
clazz.equals(null);
clazz.toString();
clazz.hashCode();
verifyNoInteractions(clazz);
import net.bytebuddy.description.modifier.TypeManifestation;
import static org.mockito.Mockito.*;
public void shouldFilterStackTraceOnVerifyNoInteractions() {
mock.oneArg(true);
try {
verifyNoInteractions(mock);
fail();
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoInteractions"));
public void should_stubbing_not_be_treated_as_interaction_verify_no_interactions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
verifyNoInteractions(mock);
public void unfinished_stubbing_cleans_up_the_state_verify_no_interactions() {
reset(mock);
try {
when("").thenReturn("");
fail();
verifyNoInteractions(mock);
public void should_mix_consecutive_returns_with_excepions() throws Exception {
public void shoudAnswerVoidMethod() throws Exception {
verifyNoInteractions(mock);
public void shouldFailVerifiationAtLeastXTimes() throws Exception {
public void shouldFailOnVerifyNoInteractions() {
verifyNoInteractions(mockOne);
throw new IllegalStateException("This delayed excution did not terminated after 5 seconds");
public void should_print_first_unexpected_invocation_when_verifying_no_interactions() {
mock.twoArgumentMethod(1, 2);
mock.threeArgumentMethod(1, "2", "3");
try {
verifyNoInteractions(mock);
fail();
String expected =
"\n" +
"No interactions wanted here:" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expected);
String expectedCause =
"\n" +
"But found these interactions on mock '" + mock + "':" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expectedCause);
public void shouldWorkFineIfNoInvocatins() throws Exception {
verifyNoInteractions(mock);
verifyNoInteractions(mock);
public void shouldFailNoInteractionsVerification() throws Exception {
mock.clear();
try {
verifyNoInteractions(mock);
fail();
public void shouldVerifyOneMockButFailOnOtherVerifyNoInteractions() throws Exception {
List<String> list = mock(List.class);
Map<String, Integer> map = mock(Map.class);
list.add("one");
list.add("one");
map.put("one", 1);
verify(list, times(2)).add("one");
verifyNoMoreInteractions(list);
try {
verifyNoInteractions(map);
fail();
verifyNoInteractions(set);
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
StringBuilder sb = new StringBuilder("There were " + result.getFailures().size() + " test failures:\n");
int count = 0;
for (Failure f : result.getFailures()) {
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
throw new AssertionError(sb.toString());
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
int count = 1;
StringBuilder out = new StringBuilder("Failures:");
out.append(count++).append(". ").append(f.getTrace());
return out.toString();
Assertions.assertThat(throwable).hasMessageContaining("but was instance of");
protected Invocation getLastInvocation() {
private final MockMaker delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
import java.io.File;
import static org.mockito.internal.util.StringJoiner.join;
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy(target);
import static org.mockito.Mockito.verifyNoInteractions;
public void verify__no_interaction_with_parent_mock() throws Exception {
verifyNoInteractions(parentMockField);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
MockSettings useConstructor(Object... args);
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
return mock(classToMock, withSettings());
public static MockitoSessionBuilder mockitoSession() {
return new DefaultMockitoSessionBuilder();
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.MockitoListener;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public interface MockitoSession {
void finishMocking();
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
package org.mockito.exceptions.misusing;
import org.mockito.MockitoSession;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.session.MockitoSessionBuilder;
public class UnfinishedMockingSessionException extends MockitoException {
public UnfinishedMockingSessionException(String message) {
super(message);
import org.mockito.MockitoSession;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
public InOrderImpl(List<?> mocksToBeVerifiedInOrder) {
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.internal.util.StringUtil.join;
field.set(testInstance, spyInstance(field, instance));
field.set(testInstance, spyNewInstance(testInstance, field));
private static Object spyInstance(Field field, Object instance) {
return Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName()));
private static Object spyNewInstance(Object testInstance, Field field)
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
int modifiers = type.getModifiers();
if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
"",
"You should augment the visibility of this inner class"));
if (typeIsNonStaticInnerClass(type, modifiers)) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + enclosing.getSimpleName() + "'",
""));
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
Constructor<?> constructor = noArgConstructorOf(type);
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
private static Constructor<?> noArgConstructorOf(Class<?> type) {
Constructor<?> constructor;
try {
constructor = type.getDeclaredConstructor();
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
return constructor;
private static boolean typeIsNonStaticInnerClass(Class<?> type, int modifiers) {
return !Modifier.isStatic(modifiers) && type.getEnclosingClass() != null;
private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
private final Class<?>[] parameterTypes;
this.parameterTypes = SuspendMethod.trimSuspendParameterTypes(method.getParameterTypes());
return parameterTypes;
import org.mockito.internal.util.Checks;
import java.util.ArrayList;
import java.util.Arrays;
private Object[] constructorArgs;
public MockSettings useConstructor(Object... constructorArgs) {
Checks.checkNotNull(constructorArgs,
"constructorArgs",
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
this.constructorArgs = constructorArgs;
public Object[] getConstructorArgs() {
if (outerClassInstance == null) {
return constructorArgs;
List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
resultArgs.add(outerClassInstance);
resultArgs.addAll(Arrays.asList(constructorArgs));
return resultArgs.toArray(new Object[constructorArgs.length + 1]);
package org.mockito.internal.creation;
import java.util.Arrays;
public class SuspendMethod {
private static final String KOTLIN_CONTINUATION = "kotlin.coroutines.experimental.Continuation";
public static Class<?>[] trimSuspendParameterTypes(Class<?>[] parameterTypes) {
int n = parameterTypes.length;
if (n > 0 && parameterTypes[n - 1].getName().equals(KOTLIN_CONTINUATION))
return Arrays.copyOf(parameterTypes, n - 1);
return parameterTypes;
import static org.mockito.internal.util.StringUtil.join;
import static org.mockito.internal.util.StringUtil.join;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
import static org.mockito.internal.util.StringUtil.join;
private volatile Throwable lastException;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative()).or(isToString())), false);
Throwable throwable = lastException;
if (throwable != null) {
throw new IllegalStateException(join("Byte Buddy could not instrument all classes within the mock's type hierarchy",
"",
"This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:",
" - Compiled by older versions of scalac",
" - Classes that are part of the Android distribution"), throwable);
lastException = null;
lastException = throwable;
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
Location location,
this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, arguments);
this.location = location;
import org.mockito.internal.debugging.LocationImpl;
import java.util.ArrayList;
import java.util.List;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
Throwable t = new Throwable();
t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
superMethod,
new LocationImpl(t)));
private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
for (int i = 0; i < elements.length; i++) {
StackTraceElement element = elements[i];
list.add(element);
if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
i++;
return list.toArray(new StackTraceElement[list.size()]);
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.invocation.Location;
return doIntercept(
invokedMethod,
new LocationImpl()
);
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod,
Location location) throws Throwable {
return handler.handle(new InterceptedInvocation(
mock,
createMockitoMethod(invokedMethod),
arguments,
superMethod,
location,
SequenceNumber.next()
import static org.mockito.internal.util.StringUtil.join;
.transform(withModifiers(SynchronizationState.PLAIN))
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final Object BOOTSTRAP_LOCK = new Object();
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.util.Primitives;
import static org.mockito.internal.util.StringUtil.join;
private final boolean hasOuterClassInstance;
private final Object[] constructorArgs;
public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
this.hasOuterClassInstance = hasOuterClassInstance;
this.constructorArgs = constructorArgs;
return withParams(cls, constructorArgs);
private <T> T withParams(Class<T> cls, Object... params) {
List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
evaluateConstructor(matchingConstructors, constructor);
if (matchingConstructors.size() == 1) {
return invokeConstructor(matchingConstructors.get(0), params);
if (matchingConstructors.size() == 0) {
throw noMatchingConstructor(cls);
throw multipleMatchingConstructors(cls, matchingConstructors);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
private InstantiationException paramsException(Class<?> cls, Exception e) {
"Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
private String constructorArgTypes() {
int argPos = 0;
if (hasOuterClassInstance) {
++argPos;
String[] constructorArgTypes = new String[constructorArgs.length - argPos];
for (int i = argPos; i < constructorArgs.length; ++i) {
constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
return Arrays.toString(constructorArgTypes);
private InstantiationException noMatchingConstructor(Class<?> cls) {
String constructorString = constructorArgsString();
String outerInstanceHint = "";
if (hasOuterClassInstance) {
outerInstanceHint = " and provided outer instance is correct";
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the target class has " + constructorString + outerInstanceHint + ".")
, null);
private String constructorArgsString() {
String constructorString;
if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
constructorString = "a 0-arg constructor";
constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
return constructorString;
private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
join("", " - ", constructors),
"If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
"See https://github.com/mockito/mockito/issues/685"
), null);
if (params[i] == null) {
if (types[i].isPrimitive()) {
return false;
(types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
boolean newHasBetterParam = false;
boolean existingHasBetterParam = false;
Class<?>[] paramTypes = constructor.getParameterTypes();
for (int i = 0; i < paramTypes.length; ++i) {
Class<?> paramType = paramTypes[i];
if (!paramType.isPrimitive()) {
for (Constructor<?> existingCtor : matchingConstructors) {
Class<?> existingParamType = existingCtor.getParameterTypes()[i];
if (paramType != existingParamType) {
if (paramType.isAssignableFrom(existingParamType)) {
existingHasBetterParam = true;
newHasBetterParam = true;
if (!existingHasBetterParam) {
matchingConstructors.clear();
if (newHasBetterParam || !existingHasBetterParam) {
matchingConstructors.add(constructor);
if (settings != null && settings.getConstructorArgs() != null) {
return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
private Object[] constructorArgs;
this.constructorArgs = copy.getConstructorArgs();
public Object[] getConstructorArgs() {
return constructorArgs;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
this(stackTraceFilter, new Throwable());
public LocationImpl(Throwable stackTraceHolder) {
this(new StackTraceFilter(), stackTraceHolder);
private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
this.stackTraceHolder = stackTraceHolder;
import static org.mockito.internal.util.StringUtil.join;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.*;
import org.mockito.internal.junit.ExceptionFactory;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringUtil.join;
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
"If you need to set the void method to do nothing you can use:",
"    doNothing().when(mock).someVoidMethod();",
"For more information, check out the javadocs for Mockito.doNothing().",
"...it does not make much sense - the test would have passed immediately in concurrency",
return new MockitoException(join(
public static void potentialStubbingProblem(
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
public static void unfinishedMockingSession() {
throw new UnfinishedMockingSessionException(join(
"Unfinished mocking session detected.",
"Previous MockitoSession was not concluded with 'finishMocking()'.",
"For examples of correct usage see javadoc for MockitoSession class."));
package org.mockito.internal.framework;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.RedundantListenerException;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.junit.UniversalTestListener;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.quality.Strictness;
public class DefaultMockitoSession implements MockitoSession {
private final Object testClassInstance;
private final UniversalTestListener listener;
public DefaultMockitoSession(Object testClassInstance, Strictness strictness, MockitoLogger logger) {
this.testClassInstance = testClassInstance;
listener = new UniversalTestListener(strictness, logger);
try {
Mockito.framework().addListener(listener);
Reporter.unfinishedMockingSession();
MockitoAnnotations.initMocks(testClassInstance);
public void finishMocking() {
Mockito.framework().removeListener(listener);
listener.testFinished(new TestFinishedEvent() {
public Throwable getFailure() {
return null;
public Object getTestClassInstance() {
return testClassInstance;
public String getTestMethodName() {
return null;
Mockito.validateMockitoUsage();
import java.util.Arrays;
public static Object[] expandArgs(MockitoMethod method, Object[] args) {
int nParams = method.getParameterTypes().length;
if (args != null && args.length > nParams)
args = Arrays.copyOf(args, nParams); // drop extra args (currently -- Kotlin continuation synthetic arg)
return expandVarArgs(method.isVarArgs(), args);
private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, args);
import org.mockito.internal.creation.SuspendMethod;
parameterTypes = SuspendMethod.trimSuspendParameterTypes(method.getParameterTypes());
return "matches".equals(method.getName());
StubbingArgMismatches getStubbingArgMismatches(Iterable<?> mocks) {
private Strictness currentStrictness;
private boolean mismatchesReported;
mismatchesReported = true;
Reporter.potentialStubbingProblem(invocation, argMismatchStubbings);
void setCurrentStrictness(Strictness currentStrictness) {
this.currentStrictness = currentStrictness;
boolean isMismatchesReported() {
return mismatchesReported;
package org.mockito.internal.junit;
import junit.framework.ComparisonFailure;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactory {
private final static boolean hasJUnit = canLoadJunitClass();
private ExceptionFactory() {
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual) {
if (hasJUnit) {
return createJUnitArgumentsAreDifferent(message, wanted, actual);
return new ArgumentsAreDifferent(message);
private static AssertionError createJUnitArgumentsAreDifferent(String message, String wanted, String actual) {
return JUnitArgsAreDifferent.create(message, wanted, actual);
private static boolean canLoadJunitClass() {
try {
JUnitArgsAreDifferent.create("message", "wanted", "actual");
return false;
return true;
private static class JUnitArgsAreDifferent {
static AssertionError create(String message, String wanted, String actual) {
return new org.mockito.exceptions.verification.junit.ArgumentsAreDifferent(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
public class UniversalTestListener implements MockitoTestListener {
public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
this.stubbingLookupListener.setCurrentStrictness(strictness);
if (unused.isEmpty()) {
if (!unused.isEmpty()) {
import java.util.ArrayList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
private final List<Object> arguments = new ArrayList<Object>();
private final ReadWriteLock lock = new ReentrantReadWriteLock();
private final Lock readLock = lock.readLock();
private final Lock writeLock = lock.writeLock();
readLock.lock();
try {
if (arguments.isEmpty()) {
throw noArgumentValueWasCaptured();
return (T) arguments.get(arguments.size() - 1);
readLock.unlock();
readLock.lock();
try {
return new ArrayList<T>((List) arguments);
readLock.unlock();
writeLock.lock();
try {
this.arguments.add(argument);
writeLock.unlock();
import java.util.NoSuchElementException;
if (!hasNext()) {
throw new NoSuchElementException();
import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
import org.mockito.ArgumentMatcher;
return decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
this.target = target;
private boolean started;
public void testStarted(Description description) throws Exception {
started = true;
if (!started && mockitoTestListener != null) {
Mockito.framework().removeListener(mockitoTestListener);
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
"Is the method annotated with @Test?\n" +
"Is the method public?\n"
package org.mockito.internal.session;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
private Object testClassInstance;
private Strictness strictness;
public MockitoSessionBuilder initMocks(Object testClassInstance) {
this.testClassInstance = testClassInstance;
return this;
public MockitoSessionBuilder strictness(Strictness strictness) {
this.strictness = strictness;
return this;
public MockitoSession startMocking() {
Object effectiveTest = this.testClassInstance == null ? new Object() : this.testClassInstance;
Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
return new DefaultMockitoSession(effectiveTest, effectiveStrictness, new ConsoleMockitoLogger());
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
answers.add(doesNothing());
private static final DoesNothing SINGLETON = new DoesNothing();
private DoesNothing() {}
public static DoesNothing doesNothing(){
return SINGLETON;
public Object answer(InvocationOnMock invocation){
Class<?> returnType = this.method.getReturnType();
return returnType == Void.TYPE|| returnType == Void.class;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
import java.lang.reflect.Method;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility((Invocation) invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
if (wantedArgumentPosition == LAST_ARGUMENT)
return invocation.getArguments().length - 1;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
wantedArgumentPosition == LAST_ARGUMENT,
private void validateArgumentTypeCompatibility(Invocation invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)){
throw wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs() &&
argumentPosition == /* vararg index */ parameterTypes.length - 1 &&
method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferArgumentType(Invocation invocation, int argumentIndex) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
Class<?> argumentType = parameterTypes[argumentIndex];
Object argumentValue = invocation.getArgument(argumentIndex);
if (argumentType.isPrimitive() || argumentValue == null) {
return argumentType;
return argumentValue.getClass();
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentIndex < varargIndex) {
return parameterTypes[argumentIndex];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentIndex)) {
return parameterTypes[argumentIndex]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return checkNotNull(value, checkedValue, null);
public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
String message = checkedValue + " should not be null";
if (additionalMessage != null) {
message += ". " + additionalMessage;
throw new IllegalArgumentException(message);
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
"toString".equals(m.getName());
&& "compareTo".equals(method.getName())
import java.util.Locale;
import static org.mockito.internal.util.StringUtil.join;
public static boolean isAndroid() {
return System.getProperty("java.vendor", "").toLowerCase(Locale.US).contains("android");
public static boolean isAndroidMockMakerRequired() {
return Boolean.getBoolean("org.mockito.mock.android");
String description = String.format("Java               : %s\n" +
if (isAndroid()) {
description = join(
"IMPORTANT INFORMATION FOR ANDROID USERS:",
"",
"The regular Byte Buddy mock makers cannot generate code on an Android VM!",
"To resolve this, please use the 'mockito-android' dependency for your application:",
"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22",
"",
description
);
return description;
package org.mockito.internal.util;
import static java.util.Arrays.asList;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class StringUtil {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
private StringUtil() {}
public static String removeFirstLine(String text) {
return text.replaceFirst(".*?\n", "");
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Collection<?> lines) {
return join(start, "", lines);
public static String join(String start, String linePrefix, Collection<?> lines) {
if (lines.isEmpty()) {
return "";
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(linePrefix).append(line).append("\n");
return out.substring(0, out.length() - 1); //lose last EOL
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while (match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
import java.util.Iterator;
public static <T> T firstOf(Iterable<T> iterable) {
Iterator<T> iterator = iterable.iterator();
if (!iterator.hasNext()) {
throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
return iterator.next();
Type genericInterface = findGenericInterface(match, targetBaseInterface);
private static Type findGenericInterface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInterface(inter, targetBaseInterface);
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
import java.util.List;
import org.mockito.invocation.MatchableInvocation;
checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
if (invocations.size() != 1 && !chunk.isEmpty()) {
if (invocations.size() != 1 || chunk.isEmpty()) {
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
checkNumberOfInvocations(invocations, wanted, wantedCount);
checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.verification.api.InOrderContext;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
private NumberOfInvocationsChecker() {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.quality.MockitoHint;
public Object[] getConstructorArgs();
import org.mockito.MockitoSession;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.junit.MockitoJUnitRunner;
package org.mockito.session;
import org.mockito.Incubating;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
public interface MockitoSessionBuilder {
MockitoSessionBuilder initMocks(Object testClassInstance);
MockitoSessionBuilder strictness(Strictness strictness);
MockitoSession startMocking() throws UnfinishedMockingSessionException;
package org.mockito.internal.creation;
import org.junit.Test;
import org.mockito.Mockito;
import static junit.framework.TestCase.assertEquals;
public class InterfaceOverrideTest {
public interface CloneableInterface extends Cloneable {
CloneableInterface clone();
public void inherit_public_method_from_interface() {
CloneableInterface i = Mockito.mock(CloneableInterface.class);
Mockito.when(i.clone()).thenReturn(i);
assertEquals(i, i.clone());
import java.util.*;
public void should_mock_interface() {
MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
mockSettings.setTypeToMock(Set.class);
mockSettings.defaultAnswer(new Returns(10));
Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
assertThat(proxy.size()).isEqualTo(10);
public void should_mock_interface_to_string() {
MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
mockSettings.setTypeToMock(Set.class);
mockSettings.defaultAnswer(new Returns("foo"));
Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
assertThat(proxy.toString()).isEqualTo("foo");
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
static class SomeClass3 {
SomeClass3(int i) {
assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
public void creates_instances_with_arguments() {
assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_null_arguments() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_primitive_arguments() {
assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
public void fails_when_null_is_passed_for_a_primitive() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
"Please ensure that the target class has a 0-arg constructor.");
public void should_print_stubbed_info_if_available() throws Exception {
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches(asList(mock1, mock2));
package org.mockito.internal.junit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockitoutil.ClassLoaders.excludingClassLoader;
import java.lang.reflect.Method;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactoryTest {
private static ClassLoader classLoaderWithoutJUnit = excludingClassLoader().withCodeSourceUrlOf(ExceptionFactory.class).without("org.junit", "junit").build();
private static Class<?> junitArgumentsAreDifferent;
private static Class<?> nonJunitArgumentsAreDifferent;
public static void init() throws ClassNotFoundException {
nonJunitArgumentsAreDifferent = classLoaderWithoutJUnit.loadClass(ArgumentsAreDifferent.class.getName());
junitArgumentsAreDifferent = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class;
public void createArgumentsAreDifferentException_withoutJUnit() throws Exception {
Class<?> exceptionFactory = classLoaderWithoutJUnit.loadClass(ExceptionFactory.class.getName());
Method m = exceptionFactory.getDeclaredMethod("createArgumentsAreDifferentException", String.class, String.class, String.class);
Object e = m.invoke(null, "message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit() throws Exception {
AssertionError e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit2x() throws Exception {
AssertionError e;
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
import java.util.List;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
UnusedStubbings stubbings = new UnusedStubbings((List) asList());
UnusedStubbings stubbings = new UnusedStubbings((List) asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing())
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import java.util.Iterator;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
assertThat(m.getAllValues()).containsSequence("foo", "bar");
public void should_not_fail_when_used_in_concurrent_tests() throws Exception {
final CapturingMatcher<String> m = new CapturingMatcher<String>();
m.captureFrom("concurrent access");
Iterator<String> iterator = m.getAllValues().iterator();
m.captureFrom("concurrent access");
assertThat(iterator.hasNext()).isTrue();
assertThat(iterator.next()).isEqualTo("concurrent access"); // Potential ConcurrentModificationException
package org.mockito.internal.runners;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.mockito.Mock;
import org.mockito.internal.junit.MockitoTestListener;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.util.Supplier;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
public class DefaultInternalRunnerTest {
private final RunListener runListener = mock(RunListener.class);
private final MockitoTestListener mockitoTestListener = mock(MockitoTestListener.class);
private final Supplier<MockitoTestListener> supplier = new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return mockitoTestListener;
public void does_not_fail_when_tests_succeeds() throws Exception {
new DefaultInternalRunner(SuccessTest.class, supplier)
.run(newNotifier(runListener));
verify(runListener, never()).testFailure(any(Failure.class));
verify(runListener, times(1)).testFinished(any(Description.class));
verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
public void does_not_fail_second_test_when_first_test_fail() throws Exception {
new DefaultInternalRunner(TestFailOnInitialization.class, supplier)
.run(newNotifier(runListener));
verify(runListener, times(1)).testFailure(any(Failure.class));
verify(runListener, never()).testFinished(any(Description.class));
verify(mockitoTestListener, never()).testFinished(any(TestFinishedEvent.class));
reset(runListener);
new DefaultInternalRunner(SuccessTest.class, supplier)
.run(newNotifier(runListener));
verify(runListener, never()).testFailure(any(Failure.class));
verify(runListener, times(1)).testFinished(any(Description.class));
verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
private RunNotifier newNotifier(RunListener listener) {
RunNotifier notifier = new RunNotifier();
notifier.addListener(listener);
return notifier;
public static final class SuccessTest {
public void test() {
assertTrue(true);
public static final class TestFailOnInitialization {
private System system;
public void test() {
assertNotNull(system);
package org.mockito.internal.session;
import org.junit.After;
import org.junit.Test;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
import org.mockitoutil.ThrowableAssert;
public class DefaultMockitoSessionBuilderTest {
new StateMaster().clearMockitoListeners();
new DefaultMockitoSessionBuilder().startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().startMocking();
ThrowableAssert.assertThat(new Runnable() {
public void run() {
new DefaultMockitoSessionBuilder().startMocking();
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
import static org.mockitoutil.TestBase.getLastInvocation;
import org.junit.Before;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
public class DoesNothingTest   {
private IMethods mock;
private Invocation invocation_Void;
private Invocation invocation_void;
private Invocation invocation_String;
public void init(){
mock = mock(IMethods.class);
mock.voidMethod();
invocation_Void = getLastInvocation();
mock.voidReturningMethod();
invocation_void = getLastInvocation();
mock.simpleMethod();
invocation_String = getLastInvocation();
public void answer_returnsNull() throws Throwable {
assertThat(doesNothing().answer(invocation_Void)).isNull();
assertThat(doesNothing().answer(invocation_void)).isNull();
assertThat(doesNothing().answer(invocation_String)).isNull();
public void validateFor_nonVoidReturnType_shouldFail()   {
doesNothing().validateFor(invocation_String);
public void validateFor_voidReturnType_shouldPass()   {
doesNothing().validateFor(invocation_void);
public void validateFor_voidObjectReturnType() throws Throwable {
doesNothing().validateFor(invocation_Void);
import org.mockitousage.IMethods;
import static org.mockito.Mockito.mock;
import static org.mockitoutil.TestBase.getLastInvocation;
public void isVoid_invocationOnVoidMethod_returnTrue(){
mock(IMethods.class).voidMethod();
InvocationInfo voidMethod = new InvocationInfo(getLastInvocation());
assertThat(voidMethod.isVoid()).isTrue();
public void isVoid_invocationOnVoidReturningMethod_returnTrue(){
mock(IMethods.class).voidReturningMethod();
InvocationInfo voidRetuningMethod = new InvocationInfo(getLastInvocation());
assertThat(voidRetuningMethod.isVoid()).isTrue();
public void isVoid_invocationNonVoidMethod_returnFalse(){
mock(IMethods.class).simpleMethod();
InvocationInfo stringReturningMethod = new InvocationInfo(getLastInvocation());
assertThat(stringReturningMethod.isVoid()).isFalse();
void iAmNotAbstract() {}
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
public void shouldNotFailWhenArgumentIsGenericAndCompatibleWithReturnType() throws Exception {
new ReturnsArgumentAt(0 ).validateFor(
new InvocationBuilder().method("genericToString")
.argTypes(Object.class)
.args("anyString")
.toInvocation()
);
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object[] { parameters }).toInvocation(); // one vararg param (sic!)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
import static junit.framework.TestCase.assertTrue;
public void shouldReturnEmptyArray() {
String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());
assertTrue(ret.getClass().isArray());
assertTrue(ret.length == 0);
public void shouldReturnEmptyString() {
package org.mockito.internal.util;
import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
public class ChecksTest {
public ExpectedException expectedException = ExpectedException.none();
public void checkNotNull_not_null() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
public void checkNotNull_not_null_additional_message() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
public void checkNotNull_null() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null");
Checks.checkNotNull(null, "someValue");
public void checkNotNull_null_additonal_message() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null. Oh no!");
Checks.checkNotNull(null, "someValue", "Oh no!");
public void assertEmpty() {
if (loggedInfo.length() != 0) {
throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
package org.mockito.internal.util;
import org.junit.Test;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
public class StringUtilTest  {
public void decamelizes_matcher() throws Exception {
assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
public void joins_empty_list() throws Exception {
assertThat(StringUtil.join()).isEmpty();
assertThat(StringUtil.join("foo", emptyList())).isEmpty();
public void joins_single_line() throws Exception {
assertThat(StringUtil.join("line1")).hasLineCount(2);
public void joins_two_lines() throws Exception {
assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
public void join_has_preceeding_linebreak() throws Exception {
assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
public void removes_first_line() throws Exception {
assertThat(StringUtil.removeFirstLine("line1\nline2")).isEqualTo("line2");
public void joins_with_line_prefix() throws Exception {
assertEquals("Hey!\n" +
" - a\n" +
" - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
assertThat(invocation.isVerified()).isFalse();
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
Void voidReturningMethod();
<T> String genericToString(T arg);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
public Void voidReturningMethod() {
return null;
public <T> String genericToString(T arg) {
return null;
public void shouldScreamWhenMoreThanOneMockitoAnnotation() {
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
public void should_allow_spying_on_interfaces() throws Exception {
List<String> list;
MockitoAnnotations.initMocks(withSpy);
when(withSpy.list.size()).thenReturn(3);
assertEquals(3, withSpy.list.size());
List<String> list = new LinkedList<String>();
assertThat(e.getMessage()).contains("Please ensure that the type")
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
assertThat(e.getMessage()).contains("Unable to create mock instance");
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
public void should_report_private_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivate());
fail();
assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
public void should_report_private_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_report_private_static_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
static class WithInnerPrivateStaticAbstract {
private InnerPrivateStaticAbstract spy_field;
private static abstract class InnerPrivateStaticAbstract {
static class WithInnerPrivateAbstract {
private InnerPrivateAbstract spy_field;
public void some_method() {
new InnerPrivateConcrete();
private abstract class InnerPrivateAbstract {
private class InnerPrivateConcrete extends InnerPrivateAbstract {
static class WithInnerPrivate {
private InnerPrivate spy_field;
private class InnerPrivate {
private class InnerPrivateSub extends InnerPrivate {}
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mockito;
public class EnabledMockingInterfaceCloneMethodTest {
public void ensure_mocking_interface_clone_method_doesnot_throw_IllegalAccessError() {
CloneableInterface ci = Mockito.mock(CloneableInterface.class);
Mockito.when(ci.clone()).thenReturn(ci);
interface CloneableInterface extends Cloneable {
CloneableInterface clone();
package org.mockitousage.bugs;
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.spy;
public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
public abstract class GenericAbstract<T> {
protected abstract String method_to_implement(T value);
public String public_method(T value) {
return method_to_implement(value);
public class ImplementsGenericMethodOfAbstract<T extends Number> extends GenericAbstract<T> {
protected String method_to_implement(T value) {
return "concrete value";
public void should_invoke_method_to_implement() {
GenericAbstract<Number> spy = spy(new ImplementsGenericMethodOfAbstract<Number>());
assertThat(spy.public_method(73L)).isEqualTo("concrete value");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
AbstractMessage(String message) {
this.message = message;
AbstractMessage(int i) {
this.message = String.valueOf(i);
public void can_spy_abstract_classes_with_constructor_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
assertEquals("hello!", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_primitive_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("7", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_casted_null() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_null_varargs() {
try {
mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
public static class ThrowingConstructorClass{
public ThrowingConstructorClass() {
throw new RuntimeException();
public void explains_constructor_exceptions() {
try {
mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
static class Base {}
static class ExtendsBase extends Base {}
static class ExtendsExtendsBase extends ExtendsBase {}
static class UsesBase {
public UsesBase(Base b) {
constructorUsed = "Base";
public UsesBase(ExtendsBase b) {
constructorUsed = "ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
static class UsesTwoBases {
public UsesTwoBases(Base b1, Base b2) {
constructorUsed = "Base,Base";
public UsesTwoBases(ExtendsBase b1, Base b2) {
constructorUsed = "ExtendsBase,Base";
public UsesTwoBases(Base b1, ExtendsBase b2) {
constructorUsed = "Base,ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,ExtendsBase", u.getConstructorUsed());
public void fail_when_multiple_matching_constructors_with_inheritence() {
try {
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
fail();
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
assertThat(e.getCause())
.hasMessageContaining("Multiple constructors could be matched to arguments of types "
+ "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+ "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
.hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
"See https://github.com/mockito/mockito/issues/685");
mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining(
"Please ensure that the target class has a 0-arg constructor"
+ " and provided outer instance is correct.");
public void interface_method_stubbed() {
List<?> list = spy(List.class);
when(list.size()).thenReturn(12);
assertEquals(12, list.size());
public void handles_bridge_methods_correctly() {
SomeConcreteClass<Integer> testBug = spy(new SomeConcreteClass<Integer>());
assertEquals("value", testBug.getValue(0));
public abstract class SomeAbstractClass<T> {
protected abstract String getRealValue(T value);
public String getValue(T value) {
return getRealValue(value);
public class SomeConcreteClass<T extends Number> extends SomeAbstractClass<T> {
protected String getRealValue(T value) {
return "value";
private static class AmbiguousWithPrimitive {
public AmbiguousWithPrimitive(String s, int i) {
data = s;
public AmbiguousWithPrimitive(Object o, int i) {
data = "just an object";
private String data;
public String getData() {
return data;
public void can_spy_ambiguius_constructor_with_primitive() {
AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("String", mock.getData());
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockitoutil.ConcurrentTesting;
ConcurrentTesting.inThread(new Runnable() {
ConcurrentTesting.inThread(new Runnable() {
public void should_not_throw_any_exceptions_when_verifications_are_successful() {
public void should_only_collect_failures_ignore_successful_verifications() {
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
when(mock.oneArg(and(eq(1D), eq(1D)))).thenReturn("3");
when(mock.oneArg(and(eq(1F), eq(1F)))).thenReturn("4");
when(mock.oneArg(and(eq(1), eq(1)))).thenReturn("5");
when(mock.oneArg(and(eq(1L), eq(1L)))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(1F));
assertEquals("5", mock.oneArg(1));
assertEquals("6", mock.oneArg(1L));
when(mock.oneArg(or(eq(1D), eq(2D)))).thenReturn("3");
when(mock.oneArg(or(eq(1F), eq(2F)))).thenReturn("4");
when(mock.oneArg(or(eq(1), eq(2)))).thenReturn("5");
when(mock.oneArg(or(eq(1L), eq(2L)))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(1F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(1L));
when(mock.oneArg(not(eq(1D)))).thenReturn("3");
when(mock.oneArg(not(eq(1F)))).thenReturn("4");
when(mock.oneArg(not(eq(1)))).thenReturn("5");
when(mock.oneArg(not(eq(1L)))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(2F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(2L));
when(mock.oneArg(leq(1D))).thenReturn("3");
when(mock.oneArg(leq(1F))).thenReturn("4");
when(mock.oneArg(leq(1))).thenReturn("5");
when(mock.oneArg(leq(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(-5F));
assertEquals("5", mock.oneArg(-2));
assertEquals("6", mock.oneArg(-3L));
when(mock.oneArg(lt(1D))).thenReturn("3");
when(mock.oneArg(lt(1F))).thenReturn("4");
when(mock.oneArg(lt(1))).thenReturn("5");
when(mock.oneArg(lt(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(0D));
assertEquals("4", mock.oneArg(-4F));
assertEquals("5", mock.oneArg(-34));
assertEquals("6", mock.oneArg(-6L));
when(mock.oneArg(geq(1D))).thenReturn("3");
when(mock.oneArg(geq(1F))).thenReturn("4");
when(mock.oneArg(geq(1))).thenReturn("5");
when(mock.oneArg(geq(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(3F));
assertEquals("5", mock.oneArg(4));
assertEquals("6", mock.oneArg(5L));
when(mock.oneArg(gt(1D))).thenReturn("3");
when(mock.oneArg(gt(1F))).thenReturn("4");
when(mock.oneArg(gt(1))).thenReturn("5");
when(mock.oneArg(gt(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(3F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(5L));
assertEquals("matched", mock.forObject(null));
when(mock.oneArg(anyObject())).thenReturn("9");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(889F));
assertEquals("5", mock.oneArg(1));
assertEquals("6", mock.oneArg(1L));
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
public void shouldNotAllowMockingPrimitives() throws Exception {
package org.mockitousage.session;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
public class MockitoSessionTest {
private JUnitCore junit = new JUnitCore();
Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result)
.failsExactly(AssertionError.class, UnfinishedStubbingException.class);
public static class SessionWithoutAnyConfiguration {
MockitoSession mockito = Mockito.mockitoSession().startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutInitMocksConfigured {
MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutStrictnessConfigured {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
assertNotNull(mock);
public static class SessionWithIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
public static class SessionWithTestFailureAndIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
assertTrue(false);
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.ConcurrentTesting.concurrently;
import static org.mockitoutil.JUnitResultAssert.assertThat;
public class StrictStubbingEndToEndTest {
JUnitCore junit = new JUnitCore();
new StateMaster().clearMockitoListeners();
Result result = junit.run(UnnecessaryStubbing.class);
assertThat(result)
.fails("unnecessary_stubbing", IllegalStateException.class)
.fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
assertThat(result).fails(1, PotentialStubbingProblem.class);
Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
assertThat(result).succeeds(5);
Result result = junit.run(UnfinishedMocking.class);
assertThat(result)
.fails(UnfinishedMockingSessionException.class, "\n" +
"Unfinished mocking session detected.\n" +
"Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
"For examples of correct usage see javadoc for MockitoSession class.");
final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
concurrently(new Runnable() {
public void run() {
results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
public void run() {
results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
);
assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
public static class UnnecessaryStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod("1")).willReturn("one");
throw new IllegalStateException();
public static class ReportMismatchButNotUnusedStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(2);
public static class StrictStubsPassing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(1);
public static class LenientStrictness1 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class LenientStrictness2 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class UnfinishedMocking {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
given(mock.simpleMethod("1")).willReturn("one");
given(mock.simpleMethod("1")).willReturn("one");
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockitoutil.ThrowableAssert.assertThat;
public class StrictStubbingTest {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
mockito.finishMocking();
mock.simpleMethod(100);
mock.otherMethod();
mock.simpleMethod(100);
mock.otherMethod();
verify(mock).simpleMethod(100);
verify(mock).otherMethod();
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- implicitly verified
mock.simpleMethod(200); // <- unverified
assertThat(new Runnable() {
public void run() {
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mock.simpleMethod(200);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mockito.finishMocking();
public void should_mix_consecutive_returns_with_exceptions() throws Exception {
package org.mockitousage.stubbing;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.TestBase.filterLineNo;
public class StubbingWarningsTest {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
MockitoSession mockito = new DefaultMockitoSession(this, Strictness.WARN, logger);
mock.simpleMethod(100);
mock.otherMethod();
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- stubbing is used
mock.simpleMethod(200); // <- other method should not generate arg mismatch
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(200);
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
given(mock.simpleMethod(100)).willReturn("100");
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
import static org.mockito.BDDMockito.anyObject;
import static org.mockito.BDDMockito.anyVararg;
given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());
given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());
given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());
given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));
public void can_return_based_on_strongly_typed_four_parameter_function() throws Exception {
public void shouldAnswerVoidMethod() throws Exception {
verifyZeroInteractions(mock);
public void shouldFailVerificationAtLeastXTimes() throws Exception {
throw new IllegalStateException("This delayed execution did not terminated after 5 seconds");
public void shouldWorkFineIfNoInvocations() throws Exception {
if (declaredField.getType() == field.getType()) { // don't copy this
package org.mockitoutil;
import java.util.LinkedList;
import java.util.List;
public class ConcurrentTesting {
public static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public static void concurrently(Runnable ... runnables) throws InterruptedException {
List<Thread> threads = new LinkedList<Thread>();
for (Runnable r : runnables) {
Thread t = new Thread(r);
t.start();
threads.add(t);
for (Thread t : threads) {
t.join();
import static org.junit.Assert.assertEquals;
import static org.mockito.internal.util.collections.Iterables.firstOf;
import static org.mockitoutil.TestBase.filterLineNo;
private JUnitResultAssert(Result result) {
throw new AssertionError(formatFailures(result.getFailures()));
fails(expectedFailureCount);
for (Failure f : result.getFailures()) {
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
return this;
public JUnitResultAssert fails(int expectedFailureCount) {
return this;
public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
fails(expectedExceptions.length);
int i = 0;
if (!expectedExceptions[i].isInstance(f.getException())) {
throw new AssertionError("Actual failure #" + (i+1)
+ " should be of type: " + expectedExceptions[i].getSimpleName()
+ " but is of type: " + f.getException().getClass().getSimpleName()
+ "\n" + formatFailures(result.getFailures()));
i++;
public JUnitResultAssert fails(Class expectedException, String exceptionMessage) {
fails(1, expectedException);
Failure f = firstOf(result.getFailures());
assertEquals(filterLineNo(exceptionMessage), filterLineNo(f.getException().getMessage()));
return this;
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
"\n" + formatFailures(result.getFailures()));
StringBuilder sb = new StringBuilder("There were " + failures.size() + " test failures:\n");
int count = 0;
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
return sb.toString();
Assertions.assertThat(throwable).hasMessageContaining("but was:");
public static Invocation getLastInvocation() {
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.Platform;
import static org.mockito.internal.util.StringUtil.join;
private final MockMaker delegate;
public AndroidByteBuddyMockMaker() {
if (Platform.isAndroid() || Platform.isAndroidMockMakerRequired()) {
delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
new ConsoleMockitoLogger().log(join(
"IMPORTANT NOTE FROM MOCKITO:",
"",
"You included the 'mockito-android' dependency in a non-Android environment.",
"The Android mock maker was disabled. You should only include the latter in your 'androidTestCompile' configuration",
"If disabling was a mistake, you can set the 'org.mockito.mock.android' property to 'true' to override this detection.",
"",
"Visit https://javadoc.io/page/org.mockito/mockito-core/latest/org/mockito/Mockito.html#0.1 for more information"
));
delegate = new SubclassByteBuddyMockMaker();
import static org.mockito.internal.util.StringUtil.join;
import java.io.File;
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);
package org.mockitoinline;
import org.junit.Test;
import org.mockito.Mockito;
public class FinalClassMockingTest {
public void no_exception_while_mocking_final_class() throws Exception {
Mockito.mock(FinalClass.class);
private static final class FinalClass {
package org.mockitoinline;
import org.junit.Test;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import static org.junit.Assert.*;
public class PluginTest {
public void plugin_type_should_be_inline() throws Exception {
assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);
package org.mockitoinline;
import java.util.Collections;
import java.util.Set;
import org.junit.Test;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.stubbing.Stubbing;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingLocationTest {
public void stubbing_location_should_be_the_correct_point() {
ConcreteClass mock = mock(ConcreteClass.class);
String frame;
when(mock.concreteMethod(frame = Thread.currentThread().getStackTrace()[1].toString())).thenReturn("");
mock.concreteMethod(frame);
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(Collections.singleton(mock));
assertEquals(1, stubbings.size());
String location = stubbings.iterator().next().getInvocation().getLocation().toString();
assertEquals("-> at " + frame, location);
static final class ConcreteClass {
String concreteMethod(String s) {
throw new RuntimeException(s);.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Observer;private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
void shouldHaveNoInteractions();
public void shouldHaveNoInteractions() {
verifyNoInteractions(mock);
MockSettings useConstructor();
import org.mockito.quality.Strictness;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
public static void verifyNoInteractions(Object... mocks) {
MOCKITO_CORE.verifyNoInteractions(mocks);
MockitoFramework addListener(MockitoListener listener);
import org.mockito.junit.MockitoRule;
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import static org.mockito.internal.verification.VerificationModeFactory.noInteractions;
import java.util.Set;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.VerificationListener;
public void verifyNoInteractions(Object... mocks) {
assertMocksNotEmpty(mocks);
mockingProgress().validateState();
for (Object mock : mocks) {
if (mock == null) {
throw nullPassedToVerifyNoMoreInteractions();
if (!isMock(mock)) {
throw notAMockPassedToVerifyNoMoreInteractions();
InvocationContainer invocations = getMockHandler(mock).getInvocationContainer();
VerificationDataImpl data = new VerificationDataImpl(invocations, null);
noInteractions().verify(data);
assertNotInterface(instance, field.getType());
field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
.spiedInstance(instance)
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName())));
field.set(testInstance, newSpyInstance(testInstance, field));
private static void assertNotInterface(Object testInstance, Class<?> type) {
type = testInstance != null? testInstance.getClass() : type;
if (type.isInterface()) {
throw new MockitoException("Type '" + type.getSimpleName() + "' is an interface and it cannot be spied on.");
private static Object newSpyInstance(Object testInstance, Field field)
MockSettings settings = withSettings()
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName());
if (!Modifier.isStatic(type.getModifiers())) {
if (enclosing != null) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException("@Spy annotation can only initialize inner classes declared in the test. "
+ "Inner class: '" + type.getSimpleName() + "', "
+ "outer class: '" + enclosing.getSimpleName() + "'.");
return Mockito.mock(type, settings
.useConstructor()
.outerInstance(testInstance));
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has 0-arg constructor.");
if (Modifier.isPrivate(constructor.getModifiers())) {
constructor.setAccessible(true);
return Mockito.mock(type, settings
.spiedInstance(constructor.newInstance()));
return Mockito.mock(type, settings.useConstructor());
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation, Field field, Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());
import org.mockito.internal.util.reflection.SuperTypesLastSorter;
return method.getParameterTypes();
public MockSettings useConstructor() {
import static org.mockito.internal.util.StringJoiner.join;
import org.mockito.plugins.MockMaker;
import static org.mockito.internal.util.StringJoiner.join;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
import java.lang.instrument.UnmodifiableClassException;
import static net.bytebuddy.implementation.MethodDelegation.to;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
import org.mockito.internal.debugging.LocationImpl;
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), arguments);
location = new LocationImpl();
import static org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.hideRecursiveCall;
superMethod));
return handler.handle(new InterceptedInvocation(
createMockitoMethod(invokedMethod),
SequenceNumber.next()
import static org.mockito.internal.util.StringJoiner.join;
.transform(withModifiers(SynchronizationState.PLAIN, Visibility.PUBLIC))
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import static org.mockito.internal.util.StringJoiner.join;
private final Object outerClassInstance;
public ConstructorInstantiator(Object outerClassInstance) {
this.outerClassInstance = outerClassInstance;
if (outerClassInstance == null) {
return noArgConstructor(cls);
return withParams(cls, outerClassInstance);
private static <T> T withParams(Class<T> cls, Object... params) {
return invokeConstructor(constructor, params);
throw paramsException(cls, null);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.")
if (!types[i].isInstance(params[i])) {
private static <T> T noArgConstructor(Class<T> cls) {
try {
return invokeConstructor(cls.getDeclaredConstructor());
throw new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure it has 0-arg constructor which invokes cleanly."),
t);
if (settings != null && settings.isUsingConstructor()) {
return new ConstructorInstantiator(settings.getOuterClassInstance());
sb.append("[Mockito] Unused stubbings of: ").append(mock).append("\n");
stackTraceHolder = new Throwable();
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.internal.junit.JUnitTool;
import org.mockito.internal.util.StringJoiner;
import static org.mockito.internal.util.StringJoiner.join;
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);",
"    verifyNoInteractions(mockOne, mockTwo);"
return JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
public static MockitoAssertionError noInteractionsWanted(Object mock, List<VerificationAwareInvocation> invocations) {
ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
String scenario = scenarioPrinter.print(invocations);
List<Location> locations = new ArrayList<Location>();
for (VerificationAwareInvocation invocation : invocations) {
locations.add(invocation.getLocation());
return new NoInteractionsWanted(join(
"No interactions wanted here:",
new LocationImpl(),
"But found these interactions on mock '" + safelyGetMockName(mock) + "':",
join("", locations),
scenario
));
"...it does not make much sense - the test would have passed immediately in concurency",
return new MockitoException(StringJoiner.join(
public static void potentialStubbingProblemByJUnitRule(
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);
parameterTypes = method.getParameterTypes();
return method.getName().equals("matches");
Strictness currentStrictness;
Reporter.potentialStubbingProblemByJUnitRule(invocation, argMismatchStubbings);
package org.mockito.internal.junit;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
class FriendlyExceptionMaker {
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
if (!detector.hasJUnit()) {
return new ArgumentsAreDifferent(message);
try {
Class<?> clazz = Class.forName("org.mockito.exceptions.verification.junit.ArgumentsAreDifferent");
return (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);
return new ArgumentsAreDifferent(message);
package org.mockito.internal.junit;
class JUnitDetector {
private boolean hasJUnit;
JUnitDetector() {
try {
Class.forName("junit.framework.ComparisonFailure");
hasJUnit = true;
hasJUnit = false;
public boolean hasJUnit() {
return hasJUnit;
package org.mockito.internal.junit;
public class JUnitTool {
private static final JUnitDetector detector = new JUnitDetector();
public static boolean hasJUnit() {
return detector.hasJUnit();
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import java.util.*;
class UniversalTestListener implements MockitoTestListener {
UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private static void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null) {
this.stubbingLookupListener.currentStrictness = strictness;
if (unused.size() == 0) {
if (unused.size() > 0) {
import org.mockito.ArgumentMatcher;
import org.mockito.internal.util.Decamelizer;
import org.mockito.internal.util.ObjectMethodsGuru;
return Decamelizer.decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.invocation.Invocation;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
this.target = target;
super.testFinished(description);
"Haven't you forgot @Test annotation?\n"
import org.mockito.internal.stubbing.answers.DoesNothing;
answers.add(new DoesNothing());
public Object answer(InvocationOnMock invocation) throws Throwable {
return this.method.getReturnType() == Void.TYPE;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return Optional.empty();
return OptionalDouble.empty();
return OptionalInt.empty();
return OptionalLong.empty();
return Stream.empty();
return DoubleStream.empty();
return IntStream.empty();
return LongStream.empty();
throw new IllegalArgumentException(checkedValue + " should not be null");
package org.mockito.internal.util;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class Decamelizer {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while(match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
m.getName().equals("toString");
&& method.getName().equals("compareTo")
return String.format("Java               : %s\n" +
package org.mockito.internal.util;
public class RemoveFirstLine {
public String of(String text) {
return text.replaceFirst(".*?\n", "");
package org.mockito.internal.util;
import static java.util.Arrays.asList;
public class StringJoiner {
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Iterable<?> lines) {
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(line.toString()).append("\n");
int lastBreak = out.lastIndexOf("\n");
return out.replace(lastBreak, lastBreak+1, "").toString();
package org.mockito.internal.util.reflection;
import java.lang.reflect.Constructor;
public abstract class Constructors {
public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {
try {
return classToMock.getDeclaredConstructor();
return null;
Type genericInterface = findGenericInteface(match, targetBaseInterface);
private static Type findGenericInteface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInteface(inter, targetBaseInterface);
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.invocation.MatchableInvocation;
import static org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.check;
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import java.util.List;
check( allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.util.ObjectMethodsGuru;
package org.mockito.internal.verification;
import java.util.List;
import org.mockito.internal.verification.api.VerificationData;
import org.mockito.invocation.Invocation;
import org.mockito.verification.VerificationMode;
import static org.mockito.internal.exceptions.Reporter.noInteractionsWanted;
public class NoInteractions implements VerificationMode {
public void verify(VerificationData data) {
List<Invocation> invocations = data.getAllInvocations();
if (!invocations.isEmpty()) {
throw noInteractionsWanted(invocations.get(0).getMock(), (List) invocations);
public VerificationMode description(String description) {
return VerificationModeFactory.description(this, description);
import org.mockito.internal.invocation.InvocationMatcher;
if (invocations.size() != 1 && chunk.size() > 0) {
if (invocations.size() != 1 || chunk.size() == 0) {
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;
import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;
NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();
numberOfInvocations.check(invocations, wanted, wantedCount);
NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();
numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());
public static NoInteractions noInteractions() {
return new NoInteractions();
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.invocation.InvocationMatcher;
package org.mockito.internal.verification.checkers;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerified;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
public class NonGreedyNumberOfInvocationsInOrderChecker {
private NonGreedyNumberOfInvocationsInOrderChecker() {}
public static void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
package org.mockito.internal.verification.checkers;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
public class NumberOfInvocationsInOrderChecker {
public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.verification.VerificationMode;
import static junit.framework.TestCase.assertFalse;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
public void shouldValidateMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions("notMock");
public void shouldValidateNullMockWhenVerifyingNoInteractions() {
Mockito.verifyNoInteractions(new Object[] { null });
when(mock.simpleMethod());
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
doAnswer(null);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedStubbingException.class);
verify(mock);
detectsAndCleansUp(new OnVerifyNoInteractions(), UnfinishedVerificationException.class);
anyObject();
detectsAndCleansUp(new OnVerifyNoInteractions(), InvalidUseOfMatchersException.class);
private static class OnVerifyNoInteractions implements DetectsInvalidState {
public void detect(IMethods mock) {
verifyNoInteractions(mock);
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
throwable = InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
new ConstructorInstantiator(null).newInstance(SomeClass2.class);
"Please ensure it has 0-arg constructor which invokes cleanly.");
public void should_print_stubbed_info_if_availbable() throws Exception {
import static org.mockito.ArgumentMatchers.any;
import org.assertj.core.api.SoftAssertions;
import org.mockito.internal.stubbing.answers.DoesNothing;
import java.util.Collections;
UnusedStubbings stubbings = new UnusedStubbings(Collections.emptyList());
UnusedStubbings stubbings = new UnusedStubbings(asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
SoftAssertions.assertSoftly(softly -> {
softly.assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
softly.assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
softly.assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import org.mockito.internal.invocation.InvocationBuilder;
import static org.assertj.core.api.Assertions.assertThat;
public class DoesNothingTest {
public void should_do_nothing() throws Throwable {
assertThat(new DoesNothing().answer(new InvocationBuilder().method("voidMethod").toInvocation())).isNull();
public void should_fail_when_non_void_method_does_nothing() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_allow_void_return_for_void_method() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
void iAmNotAbstract() {};
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)
.args(parameters).toInvocation();
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isEmpty();
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static org.assertj.core.api.Assertions.assertThat;
assertTrue(((Number[]) values.returnValueFor(Number[].class)).length == 0);
assertThat((Optional) values.returnValueFor(Optional.class)).isEmpty();
assertThat((OptionalInt) values.returnValueFor(OptionalInt.class)).isEmpty();
assertThat((OptionalLong) values.returnValueFor(OptionalLong.class)).isEmpty();
assertThat((OptionalDouble) values.returnValueFor(OptionalDouble.class)).isEmpty();
public void should_return_empty_Streams() throws Exception {
assertThat((Stream) values.returnValueFor(Stream.class)).isEmpty();
assertThat(((DoubleStream) values.returnValueFor(DoubleStream.class)).count()).isEqualTo(0);
assertThat(((IntStream) values.returnValueFor(IntStream.class)).count()).isEqualTo(0);
assertThat(((LongStream) values.returnValueFor(LongStream.class)).count()).isEqualTo(0);
public void should_return_empty_string() {
package org.mockito.internal.util;
import org.junit.Test;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.assertEquals;
import static org.mockito.internal.util.Decamelizer.decamelizeMatcher;
public class DecamelizerTest extends TestBase {
public void shouldProduceDecentDescription() throws Exception {
assertEquals("<Sentence with strong language>", decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", decamelizeMatcher(""));
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.withSettings;
import org.mockito.Mockito;
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
package org.mockito.internal.verification;
import org.assertj.core.api.Assertions;
import org.junit.Test;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.mock;
public class NoInteractionsTest extends TestBase {
public void noInteractionsExceptionMessageShouldDescribeMock() {
NoInteractions n = new NoInteractions();
IMethods mock = mock(IMethods.class, "a mock");
InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
InvocationContainerImpl invocations =
new InvocationContainerImpl( new MockSettingsImpl());
invocations.setInvocationForPotentialStubbing(i);
try {
n.verify(new VerificationDataImpl(invocations, null));
fail();
Assertions.assertThat(e.toString()).contains(mock.toString());
import java.util.Collections;
import static org.junit.Assert.*;
import org.mockito.internal.progress.VerificationModeBuilder;
import org.junit.Before;
import java.util.List;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
private NumberOfInvocationsChecker checker;
public void setup() {
checker = new NumberOfInvocationsChecker();
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 2);
checker.check(invocations, wanted, 1);
checker.check(invocations, wanted, 0);
checker.check(invocations, wanted, 1);
import org.assertj.core.api.Assertions;
private NumberOfInvocationsInOrderChecker checker;
checker = new NumberOfInvocationsInOrderChecker();
checker.check(invocations, wanted, 0, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 4, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 2, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 0, context);
Assertions.assertThat(invocation.isVerified()).isFalse();
checker.check(invocations, wanted, 1, context);
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
package org.mockito;
import java.util.Arrays;
public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.assertj.core.api.Assertions;
import java.util.*;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public void should_prevent_spying_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(withSpy);
fail();
Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
WithSpy withSpy = new WithSpy();
Assertions.assertThat(e.getMessage()).contains("0-arg constructor");
Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");
class WithMockAndSpy {
public void should_report_when_encosing_instance_is_needed() throws Exception {
class Inner {}
static class NestedClassWithoutDefinedConstructor { }
static class NestedClassWithNoArgConstructor {
NestedClassWithNoArgConstructor() { }
NestedClassWithNoArgConstructor(String f) { }
NoValidConstructor(String f) { }
ThrowingConstructor() { throw new RuntimeException("boo!"); }
public void should_not_allow_Spy_and_or_InjectMocks_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(new Object() { @Spy List<?> mock; });
fail();
Assertions.assertThat(me.getMessage()).contains("'List' is an interface");
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.internal.debugging.LocationImpl;
import java.util.concurrent.TimeUnit;
import org.assertj.core.api.Assertions;
public void shouldRemoveAllInteractionsVerifyNoInteractions() throws Exception {
mock.simpleMethod(1);
reset(mock);
verifyNoInteractions(mock);
public void shouldStubbingNotBeTreatedAsInteractionVerifyNoInteractions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
reset(mock);
verifyNoInteractions(mock);
import java.util.List;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.");
public void should_validate_that_mock_had_no_interactions() {
then(mock).shouldHaveNoInteractions();
import org.junit.Assert;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
inThread(new Runnable() {
inThread(new Runnable() {
private static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public void should_not_throw_any_exceptions_when_verifications_are_succesful() {
public void should_only_collect_failures_ignore_succesful_verifications() {
when(mock.oneArg(and(eq((double) 1), eq((double) 1)))).thenReturn("3");
when(mock.oneArg(and(eq((float) 1), eq((float) 1)))).thenReturn("4");
when(mock.oneArg(and(eq((int) 1), eq((int) 1)))).thenReturn("5");
when(mock.oneArg(and(eq((long) 1), eq((long) 1)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 1));
assertEquals("5", mock.oneArg((int) 1));
assertEquals("6", mock.oneArg((long) 1));
when(mock.oneArg(or(eq((double) 1), eq((double) 2)))).thenReturn("3");
when(mock.oneArg(or(eq((float) 1), eq((float) 2)))).thenReturn("4");
when(mock.oneArg(or(eq((int) 1), eq((int) 2)))).thenReturn("5");
when(mock.oneArg(or(eq((long) 1), eq((long) 2)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 1));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 1));
when(mock.oneArg(not(eq((double) 1)))).thenReturn("3");
when(mock.oneArg(not(eq((float) 1)))).thenReturn("4");
when(mock.oneArg(not(eq((int) 1)))).thenReturn("5");
when(mock.oneArg(not(eq((long) 1)))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 2));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 2));
when(mock.oneArg(leq((double) 1))).thenReturn("3");
when(mock.oneArg(leq((float) 1))).thenReturn("4");
when(mock.oneArg(leq((int) 1))).thenReturn("5");
when(mock.oneArg(leq((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) -5));
assertEquals("5", mock.oneArg((int) -2));
assertEquals("6", mock.oneArg((long) -3));
when(mock.oneArg(lt((double) 1))).thenReturn("3");
when(mock.oneArg(lt((float) 1))).thenReturn("4");
when(mock.oneArg(lt((int) 1))).thenReturn("5");
when(mock.oneArg(lt((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 0));
assertEquals("4", mock.oneArg((float) -4));
assertEquals("5", mock.oneArg((int) -34));
assertEquals("6", mock.oneArg((long) -6));
when(mock.oneArg(geq((double) 1))).thenReturn("3");
when(mock.oneArg(geq((float) 1))).thenReturn("4");
when(mock.oneArg(geq((int) 1))).thenReturn("5");
when(mock.oneArg(geq((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 3));
assertEquals("5", mock.oneArg((int) 4));
assertEquals("6", mock.oneArg((long) 5));
when(mock.oneArg(gt((double) 1))).thenReturn("3");
when(mock.oneArg(gt((float) 1))).thenReturn("4");
when(mock.oneArg(gt((int) 1))).thenReturn("5");
when(mock.oneArg(gt((long) 1))).thenReturn("6");
assertEquals("3", mock.oneArg((double) 2));
assertEquals("4", mock.oneArg((float) 3));
assertEquals("5", mock.oneArg((int) 2));
assertEquals("6", mock.oneArg((long) 5));
assertEquals("matched", mock.forObject((Object) null));
when(mock.oneArg((Object) anyObject())).thenReturn("9");
assertEquals("3", mock.oneArg((double) 1));
assertEquals("4", mock.oneArg((float) 889));
assertEquals("5", mock.oneArg((int) 1));
assertEquals("6", mock.oneArg((long) 1));
verify(mock).simpleMethod((Object) eq(null));
verify(mock).simpleMethod((Object) same(null));
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
public void shouldRequireArgumentsWhenVerifyingNoInteractions() {
verifyNoInteractions();
public void shouldNotAllowMockingPrimitves() throws Exception {
public void shouldNotMockObjectMethodsOnInterfaceVerifyNoInteractions() throws Exception {
ObjectLikeInterface inter = mock(ObjectLikeInterface.class);
inter.equals(null);
inter.toString();
inter.hashCode();
verifyNoInteractions(inter);
public void shouldNotMockObjectMethodsOnClassVerifyNoInteractions() throws Exception {
Object clazz = mock(ObjectLikeInterface.class);
clazz.equals(null);
clazz.toString();
clazz.hashCode();
verifyNoInteractions(clazz);
import net.bytebuddy.description.modifier.TypeManifestation;
import static org.mockito.Mockito.*;
public void shouldFilterStackTraceOnVerifyNoInteractions() {
mock.oneArg(true);
try {
verifyNoInteractions(mock);
fail();
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoInteractions"));
public void should_stubbing_not_be_treated_as_interaction_verify_no_interactions() {
when(mock.simpleMethod("one")).thenThrow(new RuntimeException());
doThrow(new RuntimeException()).when(mock).simpleMethod("two");
verifyNoInteractions(mock);
public void unfinished_stubbing_cleans_up_the_state_verify_no_interactions() {
reset(mock);
try {
when("").thenReturn("");
fail();
verifyNoInteractions(mock);
public void should_mix_consecutive_returns_with_excepions() throws Exception {
public void shoudAnswerVoidMethod() throws Exception {
verifyNoInteractions(mock);
public void shouldFailVerifiationAtLeastXTimes() throws Exception {
public void shouldFailOnVerifyNoInteractions() {
verifyNoInteractions(mockOne);
throw new IllegalStateException("This delayed excution did not terminated after 5 seconds");
public void should_print_first_unexpected_invocation_when_verifying_no_interactions() {
mock.twoArgumentMethod(1, 2);
mock.threeArgumentMethod(1, "2", "3");
try {
verifyNoInteractions(mock);
fail();
String expected =
"\n" +
"No interactions wanted here:" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expected);
String expectedCause =
"\n" +
"But found these interactions on mock '" + mock + "':" +
"\n" +
"-> at";
assertThat(e).hasMessageContaining(expectedCause);
public void shouldWorkFineIfNoInvocatins() throws Exception {
verifyNoInteractions(mock);
verifyNoInteractions(mock);
public void shouldFailNoInteractionsVerification() throws Exception {
mock.clear();
try {
verifyNoInteractions(mock);
fail();
public void shouldVerifyOneMockButFailOnOtherVerifyNoInteractions() throws Exception {
List<String> list = mock(List.class);
Map<String, Integer> map = mock(Map.class);
list.add("one");
list.add("one");
map.put("one", 1);
verify(list, times(2)).add("one");
verifyNoMoreInteractions(list);
try {
verifyNoInteractions(map);
fail();
verifyNoInteractions(set);
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
StringBuilder sb = new StringBuilder("There were " + result.getFailures().size() + " test failures:\n");
int count = 0;
for (Failure f : result.getFailures()) {
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
throw new AssertionError(sb.toString());
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
int count = 1;
StringBuilder out = new StringBuilder("Failures:");
out.append(count++).append(". ").append(f.getTrace());
return out.toString();
protected Invocation getLastInvocation() {
private final MockMaker delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
import java.io.File;
import static org.mockito.internal.util.StringJoiner.join;
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy(target);
import static org.mockito.Mockito.verifyNoInteractions;
public void verify__no_interaction_with_parent_mock() throws Exception {
verifyNoInteractions(parentMockField);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
MockSettings useConstructor(Object... args);
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
return mock(classToMock, withSettings());
public static MockitoSessionBuilder mockitoSession() {
return new DefaultMockitoSessionBuilder();
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.MockitoListener;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public interface MockitoSession {
void finishMocking();
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
package org.mockito.exceptions.misusing;
import org.mockito.MockitoSession;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.session.MockitoSessionBuilder;
public class UnfinishedMockingSessionException extends MockitoException {
public UnfinishedMockingSessionException(String message) {
super(message);
import org.mockito.MockitoSession;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.internal.util.StringUtil.join;
field.set(testInstance, spyInstance(field, instance));
field.set(testInstance, spyNewInstance(testInstance, field));
private static Object spyInstance(Field field, Object instance) {
return Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName()));
private static Object spyNewInstance(Object testInstance, Field field)
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
int modifiers = type.getModifiers();
if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
"",
"You should augment the visibility of this inner class"));
if (typeIsNonStaticInnerClass(type, modifiers)) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + enclosing.getSimpleName() + "'",
""));
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
Constructor<?> constructor = noArgConstructorOf(type);
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
private static Constructor<?> noArgConstructorOf(Class<?> type) {
Constructor<?> constructor;
try {
constructor = type.getDeclaredConstructor();
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
return constructor;
private static boolean typeIsNonStaticInnerClass(Class<?> type, int modifiers) {
return !Modifier.isStatic(modifiers) && type.getEnclosingClass() != null;
private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
private final Class<?>[] parameterTypes;
this.parameterTypes = SuspendMethod.trimSuspendParameterTypes(method.getParameterTypes());
return parameterTypes;
import org.mockito.internal.util.Checks;
import java.util.ArrayList;
import java.util.Arrays;
private Object[] constructorArgs;
public MockSettings useConstructor(Object... constructorArgs) {
Checks.checkNotNull(constructorArgs,
"constructorArgs",
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
this.constructorArgs = constructorArgs;
public Object[] getConstructorArgs() {
if (outerClassInstance == null) {
return constructorArgs;
List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
resultArgs.add(outerClassInstance);
resultArgs.addAll(Arrays.asList(constructorArgs));
return resultArgs.toArray(new Object[constructorArgs.length + 1]);
package org.mockito.internal.creation;
import java.util.Arrays;
public class SuspendMethod {
private static final String KOTLIN_CONTINUATION = "kotlin.coroutines.experimental.Continuation";
public static Class<?>[] trimSuspendParameterTypes(Class<?>[] parameterTypes) {
int n = parameterTypes.length;
if (n > 0 && parameterTypes[n - 1].getName().equals(KOTLIN_CONTINUATION))
return Arrays.copyOf(parameterTypes, n - 1);
return parameterTypes;
import static org.mockito.internal.util.StringUtil.join;
import static org.mockito.internal.util.StringUtil.join;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
import static org.mockito.internal.util.StringUtil.join;
private volatile Throwable lastException;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
Throwable throwable = lastException;
if (throwable != null) {
throw new IllegalStateException(join("Byte Buddy could not instrument all classes within the mock's type hierarchy",
"",
"This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:",
" - Compiled by older versions of scalac",
" - Classes that are part of the Android distribution"), throwable);
lastException = null;
lastException = throwable;
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
Location location,
this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, arguments);
this.location = location;
import org.mockito.internal.debugging.LocationImpl;
import java.util.ArrayList;
import java.util.List;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
Throwable t = new Throwable();
t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
superMethod,
new LocationImpl(t)));
private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
for (int i = 0; i < elements.length; i++) {
StackTraceElement element = elements[i];
list.add(element);
if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
i++;
return list.toArray(new StackTraceElement[list.size()]);
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.invocation.Location;
return doIntercept(
invokedMethod,
new LocationImpl()
);
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod,
Location location) throws Throwable {
return handler.handle(new InterceptedInvocation(
mock,
createMockitoMethod(invokedMethod),
arguments,
superMethod,
location,
SequenceNumber.next()
import static org.mockito.internal.util.StringUtil.join;
.transform(withModifiers(SynchronizationState.PLAIN))
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final Object BOOTSTRAP_LOCK = new Object();
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.util.Primitives;
import static org.mockito.internal.util.StringUtil.join;
private final boolean hasOuterClassInstance;
private final Object[] constructorArgs;
public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
this.hasOuterClassInstance = hasOuterClassInstance;
this.constructorArgs = constructorArgs;
return withParams(cls, constructorArgs);
private <T> T withParams(Class<T> cls, Object... params) {
List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
evaluateConstructor(matchingConstructors, constructor);
if (matchingConstructors.size() == 1) {
return invokeConstructor(matchingConstructors.get(0), params);
if (matchingConstructors.size() == 0) {
throw noMatchingConstructor(cls);
throw multipleMatchingConstructors(cls, matchingConstructors);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
private InstantiationException paramsException(Class<?> cls, Exception e) {
"Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
private String constructorArgTypes() {
int argPos = 0;
if (hasOuterClassInstance) {
++argPos;
String[] constructorArgTypes = new String[constructorArgs.length - argPos];
for (int i = argPos; i < constructorArgs.length; ++i) {
constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
return Arrays.toString(constructorArgTypes);
private InstantiationException noMatchingConstructor(Class<?> cls) {
String constructorString = constructorArgsString();
String outerInstanceHint = "";
if (hasOuterClassInstance) {
outerInstanceHint = " and provided outer instance is correct";
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the target class has " + constructorString + outerInstanceHint + ".")
, null);
private String constructorArgsString() {
String constructorString;
if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
constructorString = "a 0-arg constructor";
constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
return constructorString;
private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
join("", " - ", constructors),
"If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
"See https://github.com/mockito/mockito/issues/685"
), null);
if (params[i] == null) {
if (types[i].isPrimitive()) {
return false;
(types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
boolean newHasBetterParam = false;
boolean existingHasBetterParam = false;
Class<?>[] paramTypes = constructor.getParameterTypes();
for (int i = 0; i < paramTypes.length; ++i) {
Class<?> paramType = paramTypes[i];
if (!paramType.isPrimitive()) {
for (Constructor<?> existingCtor : matchingConstructors) {
Class<?> existingParamType = existingCtor.getParameterTypes()[i];
if (paramType != existingParamType) {
if (paramType.isAssignableFrom(existingParamType)) {
existingHasBetterParam = true;
newHasBetterParam = true;
if (!existingHasBetterParam) {
matchingConstructors.clear();
if (newHasBetterParam || !existingHasBetterParam) {
matchingConstructors.add(constructor);
if (settings != null && settings.getConstructorArgs() != null) {
return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
private Object[] constructorArgs;
this.constructorArgs = copy.getConstructorArgs();
public Object[] getConstructorArgs() {
return constructorArgs;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
this(stackTraceFilter, new Throwable());
public LocationImpl(Throwable stackTraceHolder) {
this(new StackTraceFilter(), stackTraceHolder);
private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
this.stackTraceHolder = stackTraceHolder;
import static org.mockito.internal.util.StringUtil.join;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.*;
import org.mockito.internal.junit.ExceptionFactory;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringUtil.join;
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);"
return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
"...it does not make much sense - the test would have passed immediately in concurrency",
return new MockitoException(join(
public static void potentialStubbingProblem(
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
public static void unfinishedMockingSession() {
throw new UnfinishedMockingSessionException(join(
"Unfinished mocking session detected.",
"Previous MockitoSession was not concluded with 'finishMocking()'.",
"For examples of correct usage see javadoc for MockitoSession class."));
package org.mockito.internal.framework;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.RedundantListenerException;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.junit.UniversalTestListener;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.quality.Strictness;
public class DefaultMockitoSession implements MockitoSession {
private final Object testClassInstance;
private final UniversalTestListener listener;
public DefaultMockitoSession(Object testClassInstance, Strictness strictness, MockitoLogger logger) {
this.testClassInstance = testClassInstance;
listener = new UniversalTestListener(strictness, logger);
try {
Mockito.framework().addListener(listener);
Reporter.unfinishedMockingSession();
MockitoAnnotations.initMocks(testClassInstance);
public void finishMocking() {
Mockito.framework().removeListener(listener);
listener.testFinished(new TestFinishedEvent() {
public Throwable getFailure() {
return null;
public Object getTestClassInstance() {
return testClassInstance;
public String getTestMethodName() {
return null;
Mockito.validateMockitoUsage();
import java.util.Arrays;
public static Object[] expandArgs(MockitoMethod method, Object[] args) {
int nParams = method.getParameterTypes().length;
if (args != null && args.length > nParams)
args = Arrays.copyOf(args, nParams); // drop extra args (currently -- Kotlin continuation synthetic arg)
return expandVarArgs(method.isVarArgs(), args);
private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, args);
import org.mockito.internal.creation.SuspendMethod;
parameterTypes = SuspendMethod.trimSuspendParameterTypes(method.getParameterTypes());
return "matches".equals(method.getName());
private Strictness currentStrictness;
private boolean mismatchesReported;
mismatchesReported = true;
Reporter.potentialStubbingProblem(invocation, argMismatchStubbings);
void setCurrentStrictness(Strictness currentStrictness) {
this.currentStrictness = currentStrictness;
boolean isMismatchesReported() {
return mismatchesReported;
package org.mockito.internal.junit;
import junit.framework.ComparisonFailure;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactory {
private final static boolean hasJUnit = canLoadJunitClass();
private ExceptionFactory() {
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual) {
if (hasJUnit) {
return createJUnitArgumentsAreDifferent(message, wanted, actual);
return new ArgumentsAreDifferent(message);
private static AssertionError createJUnitArgumentsAreDifferent(String message, String wanted, String actual) {
return JUnitArgsAreDifferent.create(message, wanted, actual);
private static boolean canLoadJunitClass() {
try {
JUnitArgsAreDifferent.create("message", "wanted", "actual");
return false;
return true;
private static class JUnitArgsAreDifferent {
static AssertionError create(String message, String wanted, String actual) {
return new org.mockito.exceptions.verification.junit.ArgumentsAreDifferent(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
public class UniversalTestListener implements MockitoTestListener {
public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
this.stubbingLookupListener.setCurrentStrictness(strictness);
if (unused.isEmpty()) {
if (!unused.isEmpty()) {
import java.util.NoSuchElementException;
if (!hasNext()) {
throw new NoSuchElementException();
import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
import org.mockito.ArgumentMatcher;
return decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
this.target = target;
private boolean started;
public void testStarted(Description description) throws Exception {
started = true;
if (!started && mockitoTestListener != null) {
Mockito.framework().removeListener(mockitoTestListener);
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
"Is the method annotated with @Test?\n" +
"Is the method public?\n"
package org.mockito.internal.session;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
private Object testClassInstance;
private Strictness strictness;
public MockitoSessionBuilder initMocks(Object testClassInstance) {
this.testClassInstance = testClassInstance;
return this;
public MockitoSessionBuilder strictness(Strictness strictness) {
this.strictness = strictness;
return this;
public MockitoSession startMocking() {
Object effectiveTest = this.testClassInstance == null ? new Object() : this.testClassInstance;
Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
return new DefaultMockitoSession(effectiveTest, effectiveStrictness, new ConsoleMockitoLogger());
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
answers.add(doesNothing());
private static final DoesNothing SINGLETON = new DoesNothing();
private DoesNothing() {}
public static DoesNothing doesNothing(){
return SINGLETON;
public Object answer(InvocationOnMock invocation){
Class<?> returnType = this.method.getReturnType();
return returnType == Void.TYPE|| returnType == Void.class;
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return checkNotNull(value, checkedValue, null);
public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
String message = checkedValue + " should not be null";
if (additionalMessage != null) {
message += ". " + additionalMessage;
throw new IllegalArgumentException(message);
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
"toString".equals(m.getName());
&& "compareTo".equals(method.getName())
import java.util.Locale;
import static org.mockito.internal.util.StringUtil.join;
public static boolean isAndroid() {
return System.getProperty("java.vendor", "").toLowerCase(Locale.US).contains("android");
public static boolean isAndroidMockMakerRequired() {
return Boolean.getBoolean("org.mockito.mock.android");
String description = String.format("Java               : %s\n" +
if (isAndroid()) {
description = join(
"IMPORTANT INFORMATION FOR ANDROID USERS:",
"",
"The regular Byte Buddy mock makers cannot generate code on an Android VM!",
"To resolve this, please use the 'mockito-android' dependency for your application:",
"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22",
"",
description
);
return description;
package org.mockito.internal.util;
import static java.util.Arrays.asList;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class StringUtil {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
private StringUtil() {}
public static String removeFirstLine(String text) {
return text.replaceFirst(".*?\n", "");
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Collection<?> lines) {
return join(start, "", lines);
public static String join(String start, String linePrefix, Collection<?> lines) {
if (lines.isEmpty()) {
return "";
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(linePrefix).append(line).append("\n");
return out.substring(0, out.length() - 1); //lose last EOL
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while (match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
import java.util.Iterator;
public static <T> T firstOf(Iterable<T> iterable) {
Iterator<T> iterator = iterable.iterator();
if (!iterator.hasNext()) {
throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
return iterator.next();
Type genericInterface = findGenericInterface(match, targetBaseInterface);
private static Type findGenericInterface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInterface(inter, targetBaseInterface);
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
import java.util.List;
import org.mockito.invocation.MatchableInvocation;
checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
if (invocations.size() != 1 && !chunk.isEmpty()) {
if (invocations.size() != 1 || chunk.isEmpty()) {
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
checkNumberOfInvocations(invocations, wanted, wantedCount);
checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.verification.api.InOrderContext;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
private NumberOfInvocationsChecker() {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.quality.MockitoHint;
public Object[] getConstructorArgs();
import org.mockito.MockitoSession;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.junit.MockitoJUnitRunner;
package org.mockito.session;
import org.mockito.Incubating;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
public interface MockitoSessionBuilder {
MockitoSessionBuilder initMocks(Object testClassInstance);
MockitoSessionBuilder strictness(Strictness strictness);
MockitoSession startMocking() throws UnfinishedMockingSessionException;
package org.mockito.internal.creation;
import org.junit.Test;
import org.mockito.Mockito;
import static junit.framework.TestCase.assertEquals;
public class InterfaceOverrideTest {
public interface CloneableInterface extends Cloneable {
CloneableInterface clone();
public void inherit_public_method_from_interface() {
CloneableInterface i = Mockito.mock(CloneableInterface.class);
Mockito.when(i.clone()).thenReturn(i);
assertEquals(i, i.clone());
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
static class SomeClass3 {
SomeClass3(int i) {
assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
public void creates_instances_with_arguments() {
assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_null_arguments() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_primitive_arguments() {
assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
public void fails_when_null_is_passed_for_a_primitive() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
"Please ensure that the target class has a 0-arg constructor.");
public void should_print_stubbed_info_if_available() throws Exception {
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
package org.mockito.internal.junit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockitoutil.ClassLoaders.excludingClassLoader;
import java.lang.reflect.Method;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactoryTest {
private static ClassLoader classLoaderWithoutJUnit = excludingClassLoader().withCodeSourceUrlOf(ExceptionFactory.class).without("org.junit", "junit").build();
private static Class<?> junitArgumentsAreDifferent;
private static Class<?> nonJunitArgumentsAreDifferent;
public static void init() throws ClassNotFoundException {
nonJunitArgumentsAreDifferent = classLoaderWithoutJUnit.loadClass(ArgumentsAreDifferent.class.getName());
junitArgumentsAreDifferent = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class;
public void createArgumentsAreDifferentException_withoutJUnit() throws Exception {
Class<?> exceptionFactory = classLoaderWithoutJUnit.loadClass(ExceptionFactory.class.getName());
Method m = exceptionFactory.getDeclaredMethod("createArgumentsAreDifferentException", String.class, String.class, String.class);
Object e = m.invoke(null, "message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit() throws Exception {
AssertionError e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit2x() throws Exception {
AssertionError e;
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
import java.util.List;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
UnusedStubbings stubbings = new UnusedStubbings((List) asList());
UnusedStubbings stubbings = new UnusedStubbings((List) asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing())
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
package org.mockito.internal.runners;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.mockito.Mock;
import org.mockito.internal.junit.MockitoTestListener;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.util.Supplier;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
public class DefaultInternalRunnerTest {
private final RunListener runListener = mock(RunListener.class);
private final MockitoTestListener mockitoTestListener = mock(MockitoTestListener.class);
private final Supplier<MockitoTestListener> supplier = new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return mockitoTestListener;
public void does_not_fail_when_tests_succeeds() throws Exception {
new DefaultInternalRunner(SuccessTest.class, supplier)
.run(newNotifier(runListener));
verify(runListener, never()).testFailure(any(Failure.class));
verify(runListener, times(1)).testFinished(any(Description.class));
verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
public void does_not_fail_second_test_when_first_test_fail() throws Exception {
new DefaultInternalRunner(TestFailOnInitialization.class, supplier)
.run(newNotifier(runListener));
verify(runListener, times(1)).testFailure(any(Failure.class));
verify(runListener, never()).testFinished(any(Description.class));
verify(mockitoTestListener, never()).testFinished(any(TestFinishedEvent.class));
reset(runListener);
new DefaultInternalRunner(SuccessTest.class, supplier)
.run(newNotifier(runListener));
verify(runListener, never()).testFailure(any(Failure.class));
verify(runListener, times(1)).testFinished(any(Description.class));
verify(mockitoTestListener, only()).testFinished(any(TestFinishedEvent.class));
private RunNotifier newNotifier(RunListener listener) {
RunNotifier notifier = new RunNotifier();
notifier.addListener(listener);
return notifier;
public static final class SuccessTest {
public void test() {
assertTrue(true);
public static final class TestFailOnInitialization {
private System system;
public void test() {
assertNotNull(system);
package org.mockito.internal.session;
import org.junit.After;
import org.junit.Test;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
import org.mockitoutil.ThrowableAssert;
public class DefaultMockitoSessionBuilderTest {
new StateMaster().clearMockitoListeners();
new DefaultMockitoSessionBuilder().startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().startMocking();
ThrowableAssert.assertThat(new Runnable() {
public void run() {
new DefaultMockitoSessionBuilder().startMocking();
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
import static org.mockitoutil.TestBase.getLastInvocation;
import org.junit.Before;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
public class DoesNothingTest   {
private IMethods mock;
private Invocation invocation_Void;
private Invocation invocation_void;
private Invocation invocation_String;
public void init(){
mock = mock(IMethods.class);
mock.voidMethod();
invocation_Void = getLastInvocation();
mock.voidReturningMethod();
invocation_void = getLastInvocation();
mock.simpleMethod();
invocation_String = getLastInvocation();
public void answer_returnsNull() throws Throwable {
assertThat(doesNothing().answer(invocation_Void)).isNull();
assertThat(doesNothing().answer(invocation_void)).isNull();
assertThat(doesNothing().answer(invocation_String)).isNull();
public void validateFor_nonVoidReturnType_shouldFail()   {
doesNothing().validateFor(invocation_String);
public void validateFor_voidReturnType_shouldPass()   {
doesNothing().validateFor(invocation_void);
public void validateFor_voidObjectReturnType() throws Throwable {
doesNothing().validateFor(invocation_Void);
import org.mockitousage.IMethods;
import static org.mockito.Mockito.mock;
import static org.mockitoutil.TestBase.getLastInvocation;
public void isVoid_invocationOnVoidMethod_returnTrue(){
mock(IMethods.class).voidMethod();
InvocationInfo voidMethod = new InvocationInfo(getLastInvocation());
assertThat(voidMethod.isVoid()).isTrue();
public void isVoid_invocationOnVoidReturningMethod_returnTrue(){
mock(IMethods.class).voidReturningMethod();
InvocationInfo voidRetuningMethod = new InvocationInfo(getLastInvocation());
assertThat(voidRetuningMethod.isVoid()).isTrue();
public void isVoid_invocationNonVoidMethod_returnFalse(){
mock(IMethods.class).simpleMethod();
InvocationInfo stringReturningMethod = new InvocationInfo(getLastInvocation());
assertThat(stringReturningMethod.isVoid()).isFalse();
void iAmNotAbstract() {}
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object[] { parameters }).toInvocation(); // one vararg param (sic!)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
import static junit.framework.TestCase.assertTrue;
public void shouldReturnEmptyArray() {
String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());
assertTrue(ret.getClass().isArray());
assertTrue(ret.length == 0);
public void shouldReturnEmptyString() {
package org.mockito.internal.util;
import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
public class ChecksTest {
public ExpectedException expectedException = ExpectedException.none();
public void checkNotNull_not_null() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
public void checkNotNull_not_null_additional_message() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
public void checkNotNull_null() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null");
Checks.checkNotNull(null, "someValue");
public void checkNotNull_null_additonal_message() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null. Oh no!");
Checks.checkNotNull(null, "someValue", "Oh no!");
public void assertEmpty() {
if (loggedInfo.length() != 0) {
throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
package org.mockito.internal.util;
import org.junit.Test;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
public class StringUtilTest  {
public void decamelizes_matcher() throws Exception {
assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
public void joins_empty_list() throws Exception {
assertThat(StringUtil.join()).isEmpty();
assertThat(StringUtil.join("foo", emptyList())).isEmpty();
public void joins_single_line() throws Exception {
assertThat(StringUtil.join("line1")).hasLineCount(2);
public void joins_two_lines() throws Exception {
assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
public void join_has_preceeding_linebreak() throws Exception {
assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
public void removes_first_line() throws Exception {
assertThat(StringUtil.removeFirstLine("line1\nline2")).isEqualTo("line2");
public void joins_with_line_prefix() throws Exception {
assertEquals("Hey!\n" +
" - a\n" +
" - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
assertThat(invocation.isVerified()).isFalse();
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
Void voidReturningMethod();
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
public Void voidReturningMethod() {
return null;
public void shouldScreamWhenMoreThanOneMockitoAnnotation() {
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
public void should_allow_spying_on_interfaces() throws Exception {
List<String> list;
MockitoAnnotations.initMocks(withSpy);
when(withSpy.list.size()).thenReturn(3);
assertEquals(3, withSpy.list.size());
List<String> list = new LinkedList<String>();
assertThat(e.getMessage()).contains("Please ensure that the type")
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
assertThat(e.getMessage()).contains("Unable to create mock instance");
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
public void should_report_private_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivate());
fail();
assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
public void should_report_private_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_report_private_static_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
static class WithInnerPrivateStaticAbstract {
private InnerPrivateStaticAbstract spy_field;
private static abstract class InnerPrivateStaticAbstract {
static class WithInnerPrivateAbstract {
private InnerPrivateAbstract spy_field;
public void some_method() {
new InnerPrivateConcrete();
private abstract class InnerPrivateAbstract {
private class InnerPrivateConcrete extends InnerPrivateAbstract {
static class WithInnerPrivate {
private InnerPrivate spy_field;
private class InnerPrivate {
private class InnerPrivateSub extends InnerPrivate {}
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mockito;
public class EnabledMockingInterfaceCloneMethodTest {
public void ensure_mocking_interface_clone_method_doesnot_throw_IllegalAccessError() {
CloneableInterface ci = Mockito.mock(CloneableInterface.class);
Mockito.when(ci.clone()).thenReturn(ci);
interface CloneableInterface extends Cloneable {
CloneableInterface clone();
package org.mockitousage.bugs;
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.spy;
public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
public abstract class GenericAbstract<T> {
protected abstract String method_to_implement(T value);
public String public_method(T value) {
return method_to_implement(value);
public class ImplementsGenericMethodOfAbstract<T extends Number> extends GenericAbstract<T> {
protected String method_to_implement(T value) {
return "concrete value";
public void should_invoke_method_to_implement() {
GenericAbstract<Number> spy = spy(new ImplementsGenericMethodOfAbstract<Number>());
assertThat(spy.public_method(73L)).isEqualTo("concrete value");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
AbstractMessage(String message) {
this.message = message;
AbstractMessage(int i) {
this.message = String.valueOf(i);
public void can_spy_abstract_classes_with_constructor_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
assertEquals("hello!", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_primitive_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("7", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_casted_null() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_null_varargs() {
try {
mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
public static class ThrowingConstructorClass{
public ThrowingConstructorClass() {
throw new RuntimeException();
public void explains_constructor_exceptions() {
try {
mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
static class Base {}
static class ExtendsBase extends Base {}
static class ExtendsExtendsBase extends ExtendsBase {}
static class UsesBase {
public UsesBase(Base b) {
constructorUsed = "Base";
public UsesBase(ExtendsBase b) {
constructorUsed = "ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
static class UsesTwoBases {
public UsesTwoBases(Base b1, Base b2) {
constructorUsed = "Base,Base";
public UsesTwoBases(ExtendsBase b1, Base b2) {
constructorUsed = "ExtendsBase,Base";
public UsesTwoBases(Base b1, ExtendsBase b2) {
constructorUsed = "Base,ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,ExtendsBase", u.getConstructorUsed());
public void fail_when_multiple_matching_constructors_with_inheritence() {
try {
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
fail();
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
assertThat(e.getCause())
.hasMessageContaining("Multiple constructors could be matched to arguments of types "
+ "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+ "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
.hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
"See https://github.com/mockito/mockito/issues/685");
mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining(
"Please ensure that the target class has a 0-arg constructor"
+ " and provided outer instance is correct.");
public void interface_method_stubbed() {
List<?> list = spy(List.class);
when(list.size()).thenReturn(12);
assertEquals(12, list.size());
public void handles_bridge_methods_correctly() {
SomeConcreteClass<Integer> testBug = spy(new SomeConcreteClass<Integer>());
assertEquals("value", testBug.getValue(0));
public abstract class SomeAbstractClass<T> {
protected abstract String getRealValue(T value);
public String getValue(T value) {
return getRealValue(value);
public class SomeConcreteClass<T extends Number> extends SomeAbstractClass<T> {
protected String getRealValue(T value) {
return "value";
private static class AmbiguousWithPrimitive {
public AmbiguousWithPrimitive(String s, int i) {
data = s;
public AmbiguousWithPrimitive(Object o, int i) {
data = "just an object";
private String data;
public String getData() {
return data;
public void can_spy_ambiguius_constructor_with_primitive() {
AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("String", mock.getData());
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockitoutil.ConcurrentTesting;
ConcurrentTesting.inThread(new Runnable() {
ConcurrentTesting.inThread(new Runnable() {
public void should_not_throw_any_exceptions_when_verifications_are_successful() {
public void should_only_collect_failures_ignore_successful_verifications() {
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
when(mock.oneArg(and(eq(1D), eq(1D)))).thenReturn("3");
when(mock.oneArg(and(eq(1F), eq(1F)))).thenReturn("4");
when(mock.oneArg(and(eq(1), eq(1)))).thenReturn("5");
when(mock.oneArg(and(eq(1L), eq(1L)))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(1F));
assertEquals("5", mock.oneArg(1));
assertEquals("6", mock.oneArg(1L));
when(mock.oneArg(or(eq(1D), eq(2D)))).thenReturn("3");
when(mock.oneArg(or(eq(1F), eq(2F)))).thenReturn("4");
when(mock.oneArg(or(eq(1), eq(2)))).thenReturn("5");
when(mock.oneArg(or(eq(1L), eq(2L)))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(1F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(1L));
when(mock.oneArg(not(eq(1D)))).thenReturn("3");
when(mock.oneArg(not(eq(1F)))).thenReturn("4");
when(mock.oneArg(not(eq(1)))).thenReturn("5");
when(mock.oneArg(not(eq(1L)))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(2F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(2L));
when(mock.oneArg(leq(1D))).thenReturn("3");
when(mock.oneArg(leq(1F))).thenReturn("4");
when(mock.oneArg(leq(1))).thenReturn("5");
when(mock.oneArg(leq(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(-5F));
assertEquals("5", mock.oneArg(-2));
assertEquals("6", mock.oneArg(-3L));
when(mock.oneArg(lt(1D))).thenReturn("3");
when(mock.oneArg(lt(1F))).thenReturn("4");
when(mock.oneArg(lt(1))).thenReturn("5");
when(mock.oneArg(lt(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(0D));
assertEquals("4", mock.oneArg(-4F));
assertEquals("5", mock.oneArg(-34));
assertEquals("6", mock.oneArg(-6L));
when(mock.oneArg(geq(1D))).thenReturn("3");
when(mock.oneArg(geq(1F))).thenReturn("4");
when(mock.oneArg(geq(1))).thenReturn("5");
when(mock.oneArg(geq(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(3F));
assertEquals("5", mock.oneArg(4));
assertEquals("6", mock.oneArg(5L));
when(mock.oneArg(gt(1D))).thenReturn("3");
when(mock.oneArg(gt(1F))).thenReturn("4");
when(mock.oneArg(gt(1))).thenReturn("5");
when(mock.oneArg(gt(1L))).thenReturn("6");
assertEquals("3", mock.oneArg(2D));
assertEquals("4", mock.oneArg(3F));
assertEquals("5", mock.oneArg(2));
assertEquals("6", mock.oneArg(5L));
assertEquals("matched", mock.forObject(null));
when(mock.oneArg(anyObject())).thenReturn("9");
assertEquals("3", mock.oneArg(1D));
assertEquals("4", mock.oneArg(889F));
assertEquals("5", mock.oneArg(1));
assertEquals("6", mock.oneArg(1L));
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
public void shouldNotAllowMockingPrimitives() throws Exception {
package org.mockitousage.session;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
public class MockitoSessionTest {
private JUnitCore junit = new JUnitCore();
Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result)
.failsExactly(AssertionError.class, UnfinishedStubbingException.class);
public static class SessionWithoutAnyConfiguration {
MockitoSession mockito = Mockito.mockitoSession().startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutInitMocksConfigured {
MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutStrictnessConfigured {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
assertNotNull(mock);
public static class SessionWithIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
public static class SessionWithTestFailureAndIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
assertTrue(false);
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.ConcurrentTesting.concurrently;
import static org.mockitoutil.JUnitResultAssert.assertThat;
public class StrictStubbingEndToEndTest {
JUnitCore junit = new JUnitCore();
new StateMaster().clearMockitoListeners();
Result result = junit.run(UnnecessaryStubbing.class);
assertThat(result)
.fails("unnecessary_stubbing", IllegalStateException.class)
.fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
assertThat(result).fails(1, PotentialStubbingProblem.class);
Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
assertThat(result).succeeds(5);
Result result = junit.run(UnfinishedMocking.class);
assertThat(result)
.fails(UnfinishedMockingSessionException.class, "\n" +
"Unfinished mocking session detected.\n" +
"Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
"For examples of correct usage see javadoc for MockitoSession class.");
final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
concurrently(new Runnable() {
public void run() {
results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
public void run() {
results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
);
assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
public static class UnnecessaryStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod("1")).willReturn("one");
throw new IllegalStateException();
public static class ReportMismatchButNotUnusedStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(2);
public static class StrictStubsPassing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(1);
public static class LenientStrictness1 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class LenientStrictness2 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class UnfinishedMocking {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
given(mock.simpleMethod("1")).willReturn("one");
given(mock.simpleMethod("1")).willReturn("one");
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockitoutil.ThrowableAssert.assertThat;
public class StrictStubbingTest {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
mockito.finishMocking();
mock.simpleMethod(100);
mock.otherMethod();
mock.simpleMethod(100);
mock.otherMethod();
verify(mock).simpleMethod(100);
verify(mock).otherMethod();
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- implicitly verified
mock.simpleMethod(200); // <- unverified
assertThat(new Runnable() {
public void run() {
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mock.simpleMethod(200);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mockito.finishMocking();
public void should_mix_consecutive_returns_with_exceptions() throws Exception {
package org.mockitousage.stubbing;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.TestBase.filterLineNo;
public class StubbingWarningsTest {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
MockitoSession mockito = new DefaultMockitoSession(this, Strictness.WARN, logger);
mock.simpleMethod(100);
mock.otherMethod();
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- stubbing is used
mock.simpleMethod(200); // <- other method should not generate arg mismatch
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(200);
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
given(mock.simpleMethod(100)).willReturn("100");
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
public void shouldAnswerVoidMethod() throws Exception {
verifyZeroInteractions(mock);
public void shouldFailVerificationAtLeastXTimes() throws Exception {
throw new IllegalStateException("This delayed execution did not terminated after 5 seconds");
public void shouldWorkFineIfNoInvocations() throws Exception {
if (declaredField.getType() == field.getType()) { // don't copy this
package org.mockitoutil;
import java.util.LinkedList;
import java.util.List;
public class ConcurrentTesting {
public static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public static void concurrently(Runnable ... runnables) throws InterruptedException {
List<Thread> threads = new LinkedList<Thread>();
for (Runnable r : runnables) {
Thread t = new Thread(r);
t.start();
threads.add(t);
for (Thread t : threads) {
t.join();
import static org.junit.Assert.assertEquals;
import static org.mockito.internal.util.collections.Iterables.firstOf;
import static org.mockitoutil.TestBase.filterLineNo;
private JUnitResultAssert(Result result) {
throw new AssertionError(formatFailures(result.getFailures()));
fails(expectedFailureCount);
for (Failure f : result.getFailures()) {
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
return this;
public JUnitResultAssert fails(int expectedFailureCount) {
return this;
public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
fails(expectedExceptions.length);
int i = 0;
if (!expectedExceptions[i].isInstance(f.getException())) {
throw new AssertionError("Actual failure #" + (i+1)
+ " should be of type: " + expectedExceptions[i].getSimpleName()
+ " but is of type: " + f.getException().getClass().getSimpleName()
+ "\n" + formatFailures(result.getFailures()));
i++;
public JUnitResultAssert fails(Class expectedException, String exceptionMessage) {
fails(1, expectedException);
Failure f = firstOf(result.getFailures());
assertEquals(filterLineNo(exceptionMessage), filterLineNo(f.getException().getMessage()));
return this;
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
"\n" + formatFailures(result.getFailures()));
StringBuilder sb = new StringBuilder("There were " + failures.size() + " test failures:\n");
int count = 0;
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
return sb.toString();
Assertions.assertThat(throwable).hasMessageContaining("but was:");
public static Invocation getLastInvocation() {
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.Platform;
import static org.mockito.internal.util.StringUtil.join;
private final MockMaker delegate;
public AndroidByteBuddyMockMaker() {
if (Platform.isAndroid() || Platform.isAndroidMockMakerRequired()) {
delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
new ConsoleMockitoLogger().log(join(
"IMPORTANT NOTE FROM MOCKITO:",
"",
"You included the 'mockito-android' dependency in a non-Android environment.",
"The Android mock maker was disabled. You should only include the latter in your 'androidTestCompile' configuration",
"If disabling was a mistake, you can set the 'org.mockito.mock.android' property to 'true' to override this detection.",
"",
"Visit https://javadoc.io/page/org.mockito/mockito-core/latest/org/mockito/Mockito.html#0.1 for more information"
));
delegate = new SubclassByteBuddyMockMaker();
import static org.mockito.internal.util.StringUtil.join;
import java.io.File;
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);
package org.mockitoinline;
import org.junit.Test;
import org.mockito.Mockito;
public class FinalClassMockingTest {
public void no_exception_while_mocking_final_class() throws Exception {
Mockito.mock(FinalClass.class);
private static final class FinalClass {
package org.mockitoinline;
import org.junit.Test;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import static org.junit.Assert.*;
public class PluginTest {
public void plugin_type_should_be_inline() throws Exception {
assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);
package org.mockitoinline;
import java.util.Collections;
import java.util.Set;
import org.junit.Test;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.stubbing.Stubbing;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingLocationTest {
public void stubbing_location_should_be_the_correct_point() {
ConcreteClass mock = mock(ConcreteClass.class);
String frame;
when(mock.concreteMethod(frame = Thread.currentThread().getStackTrace()[1].toString())).thenReturn("");
mock.concreteMethod(frame);
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(Collections.singleton(mock));
assertEquals(1, stubbings.size());
String location = stubbings.iterator().next().getInvocation().getLocation().toString();
assertEquals("-> at " + frame, location);
static final class ConcreteClass {
String concreteMethod(String s) {
throw new RuntimeException(s);return method.getParameterTypes();
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), arguments);
public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);
parameterTypes = method.getParameterTypes();
.args(parameters).toInvocation();"...it does not make much sense - the test would have passed immediately in concurency",
Type genericInterface = findGenericInteface(match, targetBaseInterface);
private static Type findGenericInteface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInteface(inter, targetBaseInterface);
public void should_print_stubbed_info_if_availbable() throws Exception {
void iAmNotAbstract() {};
public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {
public void should_not_throw_any_exceptions_when_verifications_are_succesful() {
public void should_only_collect_failures_ignore_succesful_verifications() {
public void shouldNotAllowMockingPrimitves() throws Exception {
public void should_mix_consecutive_returns_with_excepions() throws Exception {
public void shoudAnswerVoidMethod() throws Exception {
public void shouldFailVerifiationAtLeastXTimes() throws Exception {
throw new IllegalStateException("This delayed excution did not terminated after 5 seconds");
public void shouldWorkFineIfNoInvocatins() throws Exception {"...it does not make much sense - the test would have passed immediately in concurency",
Type genericInterface = findGenericInteface(match, targetBaseInterface);
private static Type findGenericInteface(Class<?> sourceClass, Class<?> targetBaseInterface) {
Type deeper = findGenericInteface(inter, targetBaseInterface);
public void should_print_stubbed_info_if_availbable() throws Exception {
void iAmNotAbstract() {};
public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {
public void should_not_throw_any_exceptions_when_verifications_are_succesful() {
public void should_only_collect_failures_ignore_succesful_verifications() {
public void shouldNotAllowMockingPrimitves() throws Exception {
public void should_mix_consecutive_returns_with_excepions() throws Exception {
public void shoudAnswerVoidMethod() throws Exception {
public void shouldFailVerifiationAtLeastXTimes() throws Exception {
throw new IllegalStateException("This delayed excution did not terminated after 5 seconds");
public void shouldWorkFineIfNoInvocatins() throws Exception {return method.getName().equals("matches");
if (unused.size() == 0) {
if (unused.size() > 0) {
m.getName().equals("toString");
&& method.getName().equals("compareTo")
if (invocations.size() != 1 && chunk.size() > 0) {
if (invocations.size() != 1 || chunk.size() == 0) {sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
import org.mockito.internal.util.JavaEightUtil;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
when(mock.oneArg(anyObject())).thenReturn("9");
verify(mock).simpleMethod(eq(null));
verify(mock).simpleMethod(same(null));
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {import org.assertj.core.api.SoftAssertions;
SoftAssertions.assertSoftly(softly -> {
softly.assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
softly.assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
softly.assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [[\\w\\.]+/]*[\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
MockSettings useConstructor(Object... args);
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
return mock(classToMock, withSettings());
public static MockitoSessionBuilder mockitoSession() {
return new DefaultMockitoSessionBuilder();
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.MockitoListener;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public interface MockitoSession {
void finishMocking();
import org.mockito.MockitoSession;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
package org.mockito.exceptions.misusing;
import org.mockito.MockitoSession;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.session.MockitoSessionBuilder;
public class UnfinishedMockingSessionException extends MockitoException {
public UnfinishedMockingSessionException(String message) {
super(message);
import org.mockito.MockitoSession;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.internal.util.StringUtil.join;
field.set(testInstance, spyInstance(field, instance));
field.set(testInstance, spyNewInstance(testInstance, field));
private static Object spyInstance(Field field, Object instance) {
return Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName()));
private static Object spyNewInstance(Object testInstance, Field field)
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
int modifiers = type.getModifiers();
if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
"",
"You should augment the visibility of this inner class"));
if (typeIsNonStaticInnerClass(type, modifiers)) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + enclosing.getSimpleName() + "'",
""));
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
Constructor<?> constructor = noArgConstructorOf(type);
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
private static Constructor<?> noArgConstructorOf(Class<?> type) {
Constructor<?> constructor;
try {
constructor = type.getDeclaredConstructor();
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
return constructor;
private static boolean typeIsNonStaticInnerClass(Class<?> type, int modifiers) {
return !Modifier.isStatic(modifiers) && type.getEnclosingClass() != null;
private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
import org.mockito.internal.util.Checks;
import java.util.ArrayList;
import java.util.Arrays;
private Object[] constructorArgs;
public MockSettings useConstructor(Object... constructorArgs) {
Checks.checkNotNull(constructorArgs,
"constructorArgs",
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
this.constructorArgs = constructorArgs;
public Object[] getConstructorArgs() {
if (outerClassInstance == null) {
return constructorArgs;
List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
resultArgs.add(outerClassInstance);
resultArgs.addAll(Arrays.asList(constructorArgs));
return resultArgs.toArray(new Object[constructorArgs.length + 1]);
import static org.mockito.internal.util.StringUtil.join;
import static org.mockito.internal.util.StringUtil.join;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
Location location,
this.location = location;
import org.mockito.internal.debugging.LocationImpl;
import java.util.ArrayList;
import java.util.List;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
Throwable t = new Throwable();
t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
superMethod,
new LocationImpl(t)));
private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
for (int i = 0; i < elements.length; i++) {
StackTraceElement element = elements[i];
list.add(element);
if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
i++;
return list.toArray(new StackTraceElement[list.size()]);
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.invocation.Location;
return doIntercept(
invokedMethod,
new LocationImpl()
);
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod,
Location location) throws Throwable {
return handler.handle(new InterceptedInvocation(
mock,
createMockitoMethod(invokedMethod),
arguments,
superMethod,
location,
SequenceNumber.next()
import static org.mockito.internal.util.StringUtil.join;
.transform(withModifiers(SynchronizationState.PLAIN))
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final Object BOOTSTRAP_LOCK = new Object();
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.util.Primitives;
import static org.mockito.internal.util.StringUtil.join;
private final boolean hasOuterClassInstance;
private final Object[] constructorArgs;
public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
this.hasOuterClassInstance = hasOuterClassInstance;
this.constructorArgs = constructorArgs;
return withParams(cls, constructorArgs);
private <T> T withParams(Class<T> cls, Object... params) {
List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
evaluateConstructor(matchingConstructors, constructor);
if (matchingConstructors.size() == 1) {
return invokeConstructor(matchingConstructors.get(0), params);
if (matchingConstructors.size() == 0) {
throw noMatchingConstructor(cls);
throw multipleMatchingConstructors(cls, matchingConstructors);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
private InstantiationException paramsException(Class<?> cls, Exception e) {
"Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
private String constructorArgTypes() {
int argPos = 0;
if (hasOuterClassInstance) {
++argPos;
String[] constructorArgTypes = new String[constructorArgs.length - argPos];
for (int i = argPos; i < constructorArgs.length; ++i) {
constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
return Arrays.toString(constructorArgTypes);
private InstantiationException noMatchingConstructor(Class<?> cls) {
String constructorString = constructorArgsString();
String outerInstanceHint = "";
if (hasOuterClassInstance) {
outerInstanceHint = " and provided outer instance is correct";
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the target class has " + constructorString + outerInstanceHint + ".")
, null);
private String constructorArgsString() {
String constructorString;
if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
constructorString = "a 0-arg constructor";
constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
return constructorString;
private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
join("", " - ", constructors),
"If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
"See https://github.com/mockito/mockito/issues/685"
), null);
if (params[i] == null) {
if (types[i].isPrimitive()) {
return false;
(types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
boolean newHasBetterParam = false;
boolean existingHasBetterParam = false;
Class<?>[] paramTypes = constructor.getParameterTypes();
for (int i = 0; i < paramTypes.length; ++i) {
Class<?> paramType = paramTypes[i];
if (!paramType.isPrimitive()) {
for (Constructor<?> existingCtor : matchingConstructors) {
Class<?> existingParamType = existingCtor.getParameterTypes()[i];
if (paramType != existingParamType) {
if (paramType.isAssignableFrom(existingParamType)) {
existingHasBetterParam = true;
newHasBetterParam = true;
if (!existingHasBetterParam) {
matchingConstructors.clear();
if (newHasBetterParam || !existingHasBetterParam) {
matchingConstructors.add(constructor);
if (settings != null && settings.getConstructorArgs() != null) {
return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
private Object[] constructorArgs;
this.constructorArgs = copy.getConstructorArgs();
public Object[] getConstructorArgs() {
return constructorArgs;
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
this(stackTraceFilter, new Throwable());
public LocationImpl(Throwable stackTraceHolder) {
this(new StackTraceFilter(), stackTraceHolder);
private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
this.stackTraceHolder = stackTraceHolder;
import static org.mockito.internal.util.StringUtil.join;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.*;
import org.mockito.internal.junit.ExceptionFactory;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringUtil.join;
return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
return new MockitoException(join(
public static void potentialStubbingProblem(
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
public static void unfinishedMockingSession() {
throw new UnfinishedMockingSessionException(join(
"Unfinished mocking session detected.",
"Previous MockitoSession was not concluded with 'finishMocking()'.",
"For examples of correct usage see javadoc for MockitoSession class."));
package org.mockito.internal.framework;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.RedundantListenerException;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.junit.UniversalTestListener;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.quality.Strictness;
public class DefaultMockitoSession implements MockitoSession {
private final Object testClassInstance;
private final UniversalTestListener listener;
public DefaultMockitoSession(Object testClassInstance, Strictness strictness, MockitoLogger logger) {
this.testClassInstance = testClassInstance;
listener = new UniversalTestListener(strictness, logger);
try {
Mockito.framework().addListener(listener);
Reporter.unfinishedMockingSession();
MockitoAnnotations.initMocks(testClassInstance);
public void finishMocking() {
Mockito.framework().removeListener(listener);
listener.testFinished(new TestFinishedEvent() {
public Throwable getFailure() {
return null;
public Object getTestClassInstance() {
return testClassInstance;
public String getTestMethodName() {
return null;
Mockito.validateMockitoUsage();
private Strictness currentStrictness;
private boolean mismatchesReported;
mismatchesReported = true;
Reporter.potentialStubbingProblem(invocation, argMismatchStubbings);
void setCurrentStrictness(Strictness currentStrictness) {
this.currentStrictness = currentStrictness;
boolean isMismatchesReported() {
return mismatchesReported;
package org.mockito.internal.junit;
import junit.framework.ComparisonFailure;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactory {
private final static boolean hasJUnit = canLoadJunitClass();
private ExceptionFactory() {
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual) {
if (hasJUnit) {
return createJUnitArgumentsAreDifferent(message, wanted, actual);
return new ArgumentsAreDifferent(message);
private static AssertionError createJUnitArgumentsAreDifferent(String message, String wanted, String actual) {
return JUnitArgsAreDifferent.create(message, wanted, actual);
private static boolean canLoadJunitClass() {
try {
JUnitArgsAreDifferent.create("message", "wanted", "actual");
return false;
return true;
private static class JUnitArgsAreDifferent {
static AssertionError create(String message, String wanted, String actual) {
return new org.mockito.exceptions.verification.junit.ArgumentsAreDifferent(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
public class UniversalTestListener implements MockitoTestListener {
public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
this.stubbingLookupListener.setCurrentStrictness(strictness);
import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
import org.mockito.ArgumentMatcher;
return decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
"Is the method annotated with @Test?\n" +
"Is the method public?\n"
package org.mockito.internal.session;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
private Object testClassInstance;
private Strictness strictness;
public MockitoSessionBuilder initMocks(Object testClassInstance) {
this.testClassInstance = testClassInstance;
return this;
public MockitoSessionBuilder strictness(Strictness strictness) {
this.strictness = strictness;
return this;
public MockitoSession startMocking() {
Object effectiveTest = this.testClassInstance == null ? new Object() : this.testClassInstance;
Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
return new DefaultMockitoSession(effectiveTest, effectiveStrictness, new ConsoleMockitoLogger());
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
answers.add(doesNothing());
private static final DoesNothing SINGLETON = new DoesNothing();
private DoesNothing() {}
public static DoesNothing doesNothing(){
return SINGLETON;
public Object answer(InvocationOnMock invocation){
Class<?> returnType = this.method.getReturnType();
return returnType == Void.TYPE|| returnType == Void.class;
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
import org.mockito.internal.util.JavaEightUtil;
import org.mockito.internal.util.ObjectMethodsGuru;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return checkNotNull(value, checkedValue, null);
public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
String message = checkedValue + " should not be null";
if (additionalMessage != null) {
message += ". " + additionalMessage;
throw new IllegalArgumentException(message);
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
import java.util.Locale;
import static org.mockito.internal.util.StringUtil.join;
public static boolean isAndroid() {
return System.getProperty("java.vendor", "").toLowerCase(Locale.US).contains("android");
public static boolean isAndroidMockMakerRequired() {
return Boolean.getBoolean("org.mockito.mock.android");
String description = String.format("Java               : %s\n" +
if (isAndroid()) {
description = join(
"IMPORTANT INFORMATION FOR ANDROID USERS:",
"",
"The regular Byte Buddy mock makers cannot generate code on an Android VM!",
"To resolve this, please use the 'mockito-android' dependency for your application:",
"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22",
"",
description
);
return description;
package org.mockito.internal.util;
import static java.util.Arrays.asList;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class StringUtil {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
private StringUtil() {}
public static String removeFirstLine(String text) {
return text.replaceFirst(".*?\n", "");
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Collection<?> lines) {
return join(start, "", lines);
public static String join(String start, String linePrefix, Collection<?> lines) {
if (lines.isEmpty()) {
return "";
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(linePrefix).append(line).append("\n");
return out.substring(0, out.length() - 1); //lose last EOL
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while (match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
import java.util.Iterator;
public static <T> T firstOf(Iterable<T> iterable) {
Iterator<T> iterator = iterable.iterator();
if (!iterator.hasNext()) {
throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
return iterator.next();
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
import java.util.List;
import org.mockito.invocation.MatchableInvocation;
checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
checkNumberOfInvocations(invocations, wanted, wantedCount);
checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.verification.api.InOrderContext;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
private NumberOfInvocationsChecker() {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.quality.MockitoHint;
public Object[] getConstructorArgs();
import org.mockito.MockitoSession;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.junit.MockitoJUnitRunner;
package org.mockito.session;
import org.mockito.Incubating;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
public interface MockitoSessionBuilder {
MockitoSessionBuilder initMocks(Object testClassInstance);
MockitoSessionBuilder strictness(Strictness strictness);
MockitoSession startMocking() throws UnfinishedMockingSessionException;
package org.mockito.internal.creation;
import org.junit.Test;
import org.mockito.Mockito;
import static junit.framework.TestCase.assertEquals;
public class InterfaceOverrideTest {
public interface CloneableInterface extends Cloneable {
CloneableInterface clone();
public void inherit_public_method_from_interface() {
CloneableInterface i = Mockito.mock(CloneableInterface.class);
Mockito.when(i.clone()).thenReturn(i);
assertEquals(i, i.clone());
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
static class SomeClass3 {
SomeClass3(int i) {
assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
public void creates_instances_with_arguments() {
assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_null_arguments() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_primitive_arguments() {
assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
public void fails_when_null_is_passed_for_a_primitive() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
"Please ensure that the target class has a 0-arg constructor.");
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
package org.mockito.internal.junit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockitoutil.ClassLoaders.excludingClassLoader;
import java.lang.reflect.Method;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactoryTest {
private static ClassLoader classLoaderWithoutJUnit = excludingClassLoader().withCodeSourceUrlOf(ExceptionFactory.class).without("org.junit", "junit").build();
private static Class<?> junitArgumentsAreDifferent;
private static Class<?> nonJunitArgumentsAreDifferent;
public static void init() throws ClassNotFoundException {
nonJunitArgumentsAreDifferent = classLoaderWithoutJUnit.loadClass(ArgumentsAreDifferent.class.getName());
junitArgumentsAreDifferent = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class;
public void createArgumentsAreDifferentException_withoutJUnit() throws Exception {
Class<?> exceptionFactory = classLoaderWithoutJUnit.loadClass(ExceptionFactory.class.getName());
Method m = exceptionFactory.getDeclaredMethod("createArgumentsAreDifferentException", String.class, String.class, String.class);
Object e = m.invoke(null, "message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit() throws Exception {
AssertionError e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit2x() throws Exception {
AssertionError e;
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
import java.util.List;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
UnusedStubbings stubbings = new UnusedStubbings((List) asList());
UnusedStubbings stubbings = new UnusedStubbings((List) asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing())
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
package org.mockito.internal.session;
import org.junit.After;
import org.junit.Test;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
import org.mockitoutil.ThrowableAssert;
public class DefaultMockitoSessionBuilderTest {
new StateMaster().clearMockitoListeners();
new DefaultMockitoSessionBuilder().startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().startMocking();
ThrowableAssert.assertThat(new Runnable() {
public void run() {
new DefaultMockitoSessionBuilder().startMocking();
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
import static org.mockitoutil.TestBase.getLastInvocation;
import org.junit.Before;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
public class DoesNothingTest   {
private IMethods mock;
private Invocation invocation_Void;
private Invocation invocation_void;
private Invocation invocation_String;
public void init(){
mock = mock(IMethods.class);
mock.voidMethod();
invocation_Void = getLastInvocation();
mock.voidReturningMethod();
invocation_void = getLastInvocation();
mock.simpleMethod();
invocation_String = getLastInvocation();
public void answer_returnsNull() throws Throwable {
assertThat(doesNothing().answer(invocation_Void)).isNull();
assertThat(doesNothing().answer(invocation_void)).isNull();
assertThat(doesNothing().answer(invocation_String)).isNull();
public void validateFor_nonVoidReturnType_shouldFail()   {
doesNothing().validateFor(invocation_String);
public void validateFor_voidReturnType_shouldPass()   {
doesNothing().validateFor(invocation_void);
public void validateFor_voidObjectReturnType() throws Throwable {
doesNothing().validateFor(invocation_Void);
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockitoutil.TestBase.getLastInvocation;
public void isVoid_invocationOnVoidMethod_returnTrue(){
mock(IMethods.class).voidMethod();
InvocationInfo voidMethod = new InvocationInfo(getLastInvocation());
assertThat(voidMethod.isVoid()).isTrue();
public void isVoid_invocationOnVoidReturningMethod_returnTrue(){
mock(IMethods.class).voidReturningMethod();
InvocationInfo voidRetuningMethod = new InvocationInfo(getLastInvocation());
assertThat(voidRetuningMethod.isVoid()).isTrue();
public void isVoid_invocationNonVoidMethod_returnFalse(){
mock(IMethods.class).simpleMethod();
InvocationInfo stringReturningMethod = new InvocationInfo(getLastInvocation());
assertThat(stringReturningMethod.isVoid()).isFalse();
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
import static junit.framework.TestCase.assertTrue;
public void shouldReturnEmptyArray() {
String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());
assertTrue(ret.getClass().isArray());
assertTrue(ret.length == 0);
public void shouldReturnEmptyString() {
package org.mockito.internal.util;
import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
public class ChecksTest {
public ExpectedException expectedException = ExpectedException.none();
public void checkNotNull_not_null() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
public void checkNotNull_not_null_additional_message() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
public void checkNotNull_null() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null");
Checks.checkNotNull(null, "someValue");
public void checkNotNull_null_additonal_message() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null. Oh no!");
Checks.checkNotNull(null, "someValue", "Oh no!");
public void assertEmpty() {
if (loggedInfo.length() != 0) {
throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
package org.mockito.internal.util;
import org.junit.Test;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
public class StringUtilTest  {
public void decamelizes_matcher() throws Exception {
assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
public void joins_empty_list() throws Exception {
assertThat(StringUtil.join()).isEmpty();
assertThat(StringUtil.join("foo", emptyList())).isEmpty();
public void joins_single_line() throws Exception {
assertThat(StringUtil.join("line1")).hasLineCount(2);
public void joins_two_lines() throws Exception {
assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
public void join_has_preceeding_linebreak() throws Exception {
assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
public void removes_first_line() throws Exception {
assertThat(StringUtil.removeFirstLine("line1\nline2")).isEqualTo("line2");
public void joins_with_line_prefix() throws Exception {
assertEquals("Hey!\n" +
" - a\n" +
" - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).doesNotContain("\n");
assertThat(printer.getActual().toString()).doesNotContain("\n");
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
assertThat(invocation.isVerified()).isFalse();
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
Void voidReturningMethod();
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
public Void voidReturningMethod() {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
public void should_allow_spying_on_interfaces() throws Exception {
List<String> list;
MockitoAnnotations.initMocks(withSpy);
when(withSpy.list.size()).thenReturn(3);
assertEquals(3, withSpy.list.size());
List<String> list = new LinkedList<String>();
assertThat(e.getMessage()).contains("Please ensure that the type")
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
assertThat(e.getMessage()).contains("Unable to create mock instance");
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
public void should_report_private_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivate());
fail();
assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
public void should_report_private_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_report_private_static_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
static class WithInnerPrivateStaticAbstract {
private InnerPrivateStaticAbstract spy_field;
private static abstract class InnerPrivateStaticAbstract {
static class WithInnerPrivateAbstract {
private InnerPrivateAbstract spy_field;
public void some_method() {
new InnerPrivateConcrete();
private abstract class InnerPrivateAbstract {
private class InnerPrivateConcrete extends InnerPrivateAbstract {
static class WithInnerPrivate {
private InnerPrivate spy_field;
private class InnerPrivate {
private class InnerPrivateSub extends InnerPrivate {}
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.spy;
public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
public abstract class GenericAbstract<T> {
protected abstract String method_to_implement(T value);
public String public_method(T value) {
return method_to_implement(value);
public class ImplementsGenericMethodOfAbstract<T extends Number> extends GenericAbstract<T> {
protected String method_to_implement(T value) {
return "concrete value";
public void should_invoke_method_to_implement() {
GenericAbstract<Number> spy = spy(new ImplementsGenericMethodOfAbstract<Number>());
assertThat(spy.public_method(73L)).isEqualTo("concrete value");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
AbstractMessage(String message) {
this.message = message;
AbstractMessage(int i) {
this.message = String.valueOf(i);
public void can_spy_abstract_classes_with_constructor_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
assertEquals("hello!", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_primitive_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("7", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_casted_null() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_null_varargs() {
try {
mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
public static class ThrowingConstructorClass{
public ThrowingConstructorClass() {
throw new RuntimeException();
public void explains_constructor_exceptions() {
try {
mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
static class Base {}
static class ExtendsBase extends Base {}
static class ExtendsExtendsBase extends ExtendsBase {}
static class UsesBase {
public UsesBase(Base b) {
constructorUsed = "Base";
public UsesBase(ExtendsBase b) {
constructorUsed = "ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
static class UsesTwoBases {
public UsesTwoBases(Base b1, Base b2) {
constructorUsed = "Base,Base";
public UsesTwoBases(ExtendsBase b1, Base b2) {
constructorUsed = "ExtendsBase,Base";
public UsesTwoBases(Base b1, ExtendsBase b2) {
constructorUsed = "Base,ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,ExtendsBase", u.getConstructorUsed());
public void fail_when_multiple_matching_constructors_with_inheritence() {
try {
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
fail();
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
assertThat(e.getCause())
.hasMessageContaining("Multiple constructors could be matched to arguments of types "
+ "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+ "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
.hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
"See https://github.com/mockito/mockito/issues/685");
mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining(
"Please ensure that the target class has a 0-arg constructor"
+ " and provided outer instance is correct.");
public void interface_method_stubbed() {
List<?> list = spy(List.class);
when(list.size()).thenReturn(12);
assertEquals(12, list.size());
public void handles_bridge_methods_correctly() {
SomeConcreteClass<Integer> testBug = spy(new SomeConcreteClass<Integer>());
assertEquals("value", testBug.getValue(0));
public abstract class SomeAbstractClass<T> {
protected abstract String getRealValue(T value);
public String getValue(T value) {
return getRealValue(value);
public class SomeConcreteClass<T extends Number> extends SomeAbstractClass<T> {
protected String getRealValue(T value) {
return "value";
private static class AmbiguousWithPrimitive {
public AmbiguousWithPrimitive(String s, int i) {
data = s;
public AmbiguousWithPrimitive(Object o, int i) {
data = "just an object";
private String data;
public String getData() {
return data;
public void can_spy_ambiguius_constructor_with_primitive() {
AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("String", mock.getData());
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockitoutil.ConcurrentTesting;
ConcurrentTesting.inThread(new Runnable() {
ConcurrentTesting.inThread(new Runnable() {
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
package org.mockitousage.session;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
public class MockitoSessionTest {
private JUnitCore junit = new JUnitCore();
Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result)
.failsExactly(AssertionError.class, UnfinishedStubbingException.class);
public static class SessionWithoutAnyConfiguration {
MockitoSession mockito = Mockito.mockitoSession().startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutInitMocksConfigured {
MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutStrictnessConfigured {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
assertNotNull(mock);
public static class SessionWithIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
public static class SessionWithTestFailureAndIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
assertTrue(false);
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.ConcurrentTesting.concurrently;
import static org.mockitoutil.JUnitResultAssert.assertThat;
public class StrictStubbingEndToEndTest {
JUnitCore junit = new JUnitCore();
new StateMaster().clearMockitoListeners();
Result result = junit.run(UnnecessaryStubbing.class);
assertThat(result)
.fails("unnecessary_stubbing", IllegalStateException.class)
.fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
assertThat(result).fails(1, PotentialStubbingProblem.class);
Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
assertThat(result).succeeds(5);
Result result = junit.run(UnfinishedMocking.class);
assertThat(result)
.fails(UnfinishedMockingSessionException.class, "\n" +
"Unfinished mocking session detected.\n" +
"Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
"For examples of correct usage see javadoc for MockitoSession class.");
final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
concurrently(new Runnable() {
public void run() {
results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
public void run() {
results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
);
assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
public static class UnnecessaryStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod("1")).willReturn("one");
throw new IllegalStateException();
public static class ReportMismatchButNotUnusedStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(2);
public static class StrictStubsPassing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(1);
public static class LenientStrictness1 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class LenientStrictness2 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class UnfinishedMocking {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
given(mock.simpleMethod("1")).willReturn("one");
given(mock.simpleMethod("1")).willReturn("one");
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockitoutil.ThrowableAssert.assertThat;
public class StrictStubbingTest {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
mockito.finishMocking();
mock.simpleMethod(100);
mock.otherMethod();
mock.simpleMethod(100);
mock.otherMethod();
verify(mock).simpleMethod(100);
verify(mock).otherMethod();
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- implicitly verified
mock.simpleMethod(200); // <- unverified
assertThat(new Runnable() {
public void run() {
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mock.simpleMethod(200);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mockito.finishMocking();
package org.mockitousage.stubbing;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.TestBase.filterLineNo;
public class StubbingWarningsTest {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
MockitoSession mockito = new DefaultMockitoSession(this, Strictness.WARN, logger);
mock.simpleMethod(100);
mock.otherMethod();
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- stubbing is used
mock.simpleMethod(200); // <- other method should not generate arg mismatch
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(200);
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
given(mock.simpleMethod(100)).willReturn("100");
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
if (declaredField.getType() == field.getType()) { // don't copy this
package org.mockitoutil;
import java.util.LinkedList;
import java.util.List;
public class ConcurrentTesting {
public static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public static void concurrently(Runnable ... runnables) throws InterruptedException {
List<Thread> threads = new LinkedList<Thread>();
for (Runnable r : runnables) {
Thread t = new Thread(r);
t.start();
threads.add(t);
for (Thread t : threads) {
t.join();
import static org.junit.Assert.assertEquals;
import static org.mockito.internal.util.collections.Iterables.firstOf;
import static org.mockitoutil.TestBase.filterLineNo;
private JUnitResultAssert(Result result) {
throw new AssertionError(formatFailures(result.getFailures()));
fails(expectedFailureCount);
for (Failure f : result.getFailures()) {
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
return this;
public JUnitResultAssert fails(int expectedFailureCount) {
return this;
public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
fails(expectedExceptions.length);
int i = 0;
if (!expectedExceptions[i].isInstance(f.getException())) {
throw new AssertionError("Actual failure #" + (i+1)
+ " should be of type: " + expectedExceptions[i].getSimpleName()
+ " but is of type: " + f.getException().getClass().getSimpleName()
+ "\n" + formatFailures(result.getFailures()));
i++;
public JUnitResultAssert fails(Class expectedException, String exceptionMessage) {
fails(1, expectedException);
Failure f = firstOf(result.getFailures());
assertEquals(filterLineNo(exceptionMessage), filterLineNo(f.getException().getMessage()));
return this;
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
"\n" + formatFailures(result.getFailures()));
StringBuilder sb = new StringBuilder("There were " + failures.size() + " test failures:\n");
int count = 0;
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
return sb.toString();
public static Invocation getLastInvocation() {
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.Platform;
import static org.mockito.internal.util.StringUtil.join;
private final MockMaker delegate;
public AndroidByteBuddyMockMaker() {
if (Platform.isAndroid() || Platform.isAndroidMockMakerRequired()) {
delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
new ConsoleMockitoLogger().log(join(
"IMPORTANT NOTE FROM MOCKITO:",
"",
"You included the 'mockito-android' dependency in a non-Android environment.",
"The Android mock maker was disabled. You should only include the latter in your 'androidTestCompile' configuration",
"If disabling was a mistake, you can set the 'org.mockito.mock.android' property to 'true' to override this detection.",
"",
"Visit https://javadoc.io/page/org.mockito/mockito-core/latest/org/mockito/Mockito.html#0.1 for more information"
));
delegate = new SubclassByteBuddyMockMaker();
import static org.mockito.internal.util.StringUtil.join;
import java.io.File;
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);
package org.mockitoinline;
import org.junit.Test;
import org.mockito.Mockito;
public class FinalClassMockingTest {
public void no_exception_while_mocking_final_class() throws Exception {
Mockito.mock(FinalClass.class);
private static final class FinalClass {
package org.mockitoinline;
import org.junit.Test;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import static org.junit.Assert.*;
public class PluginTest {
public void plugin_type_should_be_inline() throws Exception {
assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);
package org.mockitoinline;
import java.util.Collections;
import java.util.Set;
import org.junit.Test;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.stubbing.Stubbing;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingLocationTest {
public void stubbing_location_should_be_the_correct_point() {
ConcreteClass mock = mock(ConcreteClass.class);
String frame;
when(mock.concreteMethod(frame = Thread.currentThread().getStackTrace()[1].toString())).thenReturn("");
mock.concreteMethod(frame);
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(Collections.singleton(mock));
assertEquals(1, stubbings.size());
String location = stubbings.iterator().next().getInvocation().getLocation().toString();
assertEquals("-> at " + frame, location);
static final class ConcreteClass {
String concreteMethod(String s) {
throw new RuntimeException(s);private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
MockSettings useConstructor();
import org.mockito.quality.Strictness;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
MockitoFramework addListener(MockitoListener listener);
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
import org.mockito.internal.util.RemoveFirstLine;
return new RemoveFirstLine().of(super.toString());
assertNotInterface(instance, field.getType());
field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
.spiedInstance(instance)
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName())));
field.set(testInstance, newSpyInstance(testInstance, field));
private static void assertNotInterface(Object testInstance, Class<?> type) {
type = testInstance != null? testInstance.getClass() : type;
if (type.isInterface()) {
throw new MockitoException("Type '" + type.getSimpleName() + "' is an interface and it cannot be spied on.");
private static Object newSpyInstance(Object testInstance, Field field)
MockSettings settings = withSettings()
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName());
if (!Modifier.isStatic(type.getModifiers())) {
if (enclosing != null) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException("@Spy annotation can only initialize inner classes declared in the test. "
+ "Inner class: '" + type.getSimpleName() + "', "
+ "outer class: '" + enclosing.getSimpleName() + "'.");
return Mockito.mock(type, settings
.useConstructor()
.outerInstance(testInstance));
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has 0-arg constructor.");
if (Modifier.isPrivate(constructor.getModifiers())) {
constructor.setAccessible(true);
return Mockito.mock(type, settings
.spiedInstance(constructor.newInstance()));
return Mockito.mock(type, settings.useConstructor());
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation, Field field, Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());
public MockSettings useConstructor() {
import static org.mockito.internal.util.StringJoiner.join;
import static org.mockito.internal.util.StringJoiner.join;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
location = new LocationImpl();
import static org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.hideRecursiveCall;
superMethod));
return handler.handle(new InterceptedInvocation(
createMockitoMethod(invokedMethod),
SequenceNumber.next()
import static org.mockito.internal.util.StringJoiner.join;
.transform(withModifiers(SynchronizationState.PLAIN, Visibility.PUBLIC))
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import static org.mockito.internal.util.StringJoiner.join;
private final Object outerClassInstance;
public ConstructorInstantiator(Object outerClassInstance) {
this.outerClassInstance = outerClassInstance;
if (outerClassInstance == null) {
return noArgConstructor(cls);
return withParams(cls, outerClassInstance);
private static <T> T withParams(Class<T> cls, Object... params) {
return invokeConstructor(constructor, params);
throw paramsException(cls, null);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.")
if (!types[i].isInstance(params[i])) {
private static <T> T noArgConstructor(Class<T> cls) {
try {
return invokeConstructor(cls.getDeclaredConstructor());
throw new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure it has 0-arg constructor which invokes cleanly."),
t);
if (settings != null && settings.isUsingConstructor()) {
return new ConstructorInstantiator(settings.getOuterClassInstance());
sb.append("[Mockito] Unused stubbings of: ").append(mock).append("\n");
stackTraceHolder = new Throwable();
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.internal.junit.JUnitTool;
import org.mockito.internal.util.StringJoiner;
import static org.mockito.internal.util.StringJoiner.join;
return JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
return new MockitoException(StringJoiner.join(
public static void potentialStubbingProblemByJUnitRule(
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
Strictness currentStrictness;
Reporter.potentialStubbingProblemByJUnitRule(invocation, argMismatchStubbings);
package org.mockito.internal.junit;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
class FriendlyExceptionMaker {
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
if (!detector.hasJUnit()) {
return new ArgumentsAreDifferent(message);
try {
Class<?> clazz = Class.forName("org.mockito.exceptions.verification.junit.ArgumentsAreDifferent");
return (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);
return new ArgumentsAreDifferent(message);
package org.mockito.internal.junit;
class JUnitDetector {
private boolean hasJUnit;
JUnitDetector() {
try {
Class.forName("junit.framework.ComparisonFailure");
hasJUnit = true;
hasJUnit = false;
public boolean hasJUnit() {
return hasJUnit;
package org.mockito.internal.junit;
public class JUnitTool {
private static final JUnitDetector detector = new JUnitDetector();
public static boolean hasJUnit() {
return detector.hasJUnit();
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import java.util.*;
class UniversalTestListener implements MockitoTestListener {
UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private static void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null) {
this.stubbingLookupListener.currentStrictness = strictness;
import org.mockito.ArgumentMatcher;
import org.mockito.internal.util.Decamelizer;
import org.mockito.internal.util.ObjectMethodsGuru;
return Decamelizer.decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.invocation.Invocation;
"Haven't you forgot @Test annotation?\n"
import org.mockito.internal.stubbing.answers.DoesNothing;
answers.add(new DoesNothing());
public Object answer(InvocationOnMock invocation) throws Throwable {
return this.method.getReturnType() == Void.TYPE;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
return Optional.empty();
return OptionalDouble.empty();
return OptionalInt.empty();
return OptionalLong.empty();
return Stream.empty();
return DoubleStream.empty();
return IntStream.empty();
return LongStream.empty();
throw new IllegalArgumentException(checkedValue + " should not be null");
return String.format("Java               : %s\n" +
package org.mockito.internal.util;
public class RemoveFirstLine {
public String of(String text) {
return text.replaceFirst(".*?\n", "");
package org.mockito.internal.util;
import static java.util.Arrays.asList;
public class StringJoiner {
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Iterable<?> lines) {
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(line.toString()).append("\n");
int lastBreak = out.lastIndexOf("\n");
return out.replace(lastBreak, lastBreak+1, "").toString();
package org.mockito.internal.util.reflection;
import java.lang.reflect.Constructor;
public abstract class Constructors {
public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {
try {
return classToMock.getDeclaredConstructor();
return null;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.invocation.MatchableInvocation;
import static org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.check;
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import java.util.List;
check( allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;
import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;
NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();
numberOfInvocations.check(invocations, wanted, wantedCount);
NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();
numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());
package org.mockito.internal.verification.checkers;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerified;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
public class NonGreedyNumberOfInvocationsInOrderChecker {
private NonGreedyNumberOfInvocationsInOrderChecker() {}
public static void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
throwable = InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(InlineByteBuddyMockMaker.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
new ConstructorInstantiator(null).newInstance(SomeClass2.class);
"Please ensure it has 0-arg constructor which invokes cleanly.");
import java.util.regex.Pattern;
import static org.assertj.core.api.Assertions.assertThat;
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
import org.mockito.internal.invocation.InvocationBuilder;
import static org.assertj.core.api.Assertions.assertThat;
public class DoesNothingTest {
public void should_do_nothing() throws Throwable {
assertThat(new DoesNothing().answer(new InvocationBuilder().method("voidMethod").toInvocation())).isNull();
public void should_fail_when_non_void_method_does_nothing() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_allow_void_return_for_void_method() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isEmpty();
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertTrue;
import static org.assertj.core.api.Assertions.assertThat;
assertTrue(((Number[]) values.returnValueFor(Number[].class)).length == 0);
assertThat((Optional) values.returnValueFor(Optional.class)).isEmpty();
assertThat((OptionalInt) values.returnValueFor(OptionalInt.class)).isEmpty();
assertThat((OptionalLong) values.returnValueFor(OptionalLong.class)).isEmpty();
assertThat((OptionalDouble) values.returnValueFor(OptionalDouble.class)).isEmpty();
public void should_return_empty_Streams() throws Exception {
assertThat((Stream) values.returnValueFor(Stream.class)).isEmpty();
assertThat(((DoubleStream) values.returnValueFor(DoubleStream.class)).count()).isEqualTo(0);
assertThat(((IntStream) values.returnValueFor(IntStream.class)).count()).isEqualTo(0);
assertThat(((LongStream) values.returnValueFor(LongStream.class)).count()).isEqualTo(0);
public void should_return_empty_string() {
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
assertThat(printer.getWanted()).contains("\n");
assertThat(printer.getActual()).contains("\n");
assertThat(printer.getWanted()).contains("\n");
assertThat(printer.getActual()).contains("\n");
assertThat(printer.getWanted()).contains("\n");
assertThat(printer.getActual()).contains("\n");
assertThat(printer.getWanted()).doesNotContain("\n");
assertThat(printer.getActual()).doesNotContain("\n");
import org.junit.Before;
import java.util.List;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
private NumberOfInvocationsChecker checker;
public void setup() {
checker = new NumberOfInvocationsChecker();
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 100);
checker.check(invocations, wanted, 2);
checker.check(invocations, wanted, 1);
checker.check(invocations, wanted, 0);
checker.check(invocations, wanted, 1);
import org.assertj.core.api.Assertions;
private NumberOfInvocationsInOrderChecker checker;
checker = new NumberOfInvocationsInOrderChecker();
checker.check(invocations, wanted, 0, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 4, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 100, context);
checker.check(invocations, wanted, 2, context);
checker.check(invocations, wanted, 1, context);
checker.check(invocations, wanted, 0, context);
Assertions.assertThat(invocation.isVerified()).isFalse();
checker.check(invocations, wanted, 1, context);
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
package org.mockito;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.assertj.core.api.Assertions;
import java.util.*;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public void should_prevent_spying_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(withSpy);
fail();
Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
WithSpy withSpy = new WithSpy();
Assertions.assertThat(e.getMessage()).contains("0-arg constructor");
Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");
class WithMockAndSpy {
public void should_report_when_encosing_instance_is_needed() throws Exception {
class Inner {}
static class NestedClassWithoutDefinedConstructor { }
static class NestedClassWithNoArgConstructor {
NestedClassWithNoArgConstructor() { }
NestedClassWithNoArgConstructor(String f) { }
NoValidConstructor(String f) { }
ThrowingConstructor() { throw new RuntimeException("boo!"); }
public void should_not_allow_Spy_and_or_InjectMocks_on_interfaces() throws Exception {
try {
MockitoAnnotations.initMocks(new Object() { @Spy List<?> mock; });
fail();
Assertions.assertThat(me.getMessage()).contains("'List' is an interface");
import java.util.List;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.");
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
inThread(new Runnable() {
inThread(new Runnable() {
private static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
StringBuilder sb = new StringBuilder("There were " + result.getFailures().size() + " test failures:\n");
int count = 0;
for (Failure f : result.getFailures()) {
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
throw new AssertionError(sb.toString());
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
int count = 1;
StringBuilder out = new StringBuilder("Failures:");
out.append(count++).append(". ").append(f.getTrace());
return out.toString();
protected Invocation getLastInvocation() {
private final MockMaker delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
import java.io.File;
import static org.mockito.internal.util.StringJoiner.join;
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy(target);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
return mock(classToMock, withSettings());
public static MockitoSessionBuilder mockitoSession() {
return new DefaultMockitoSessionBuilder();
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.MockitoListener;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public interface MockitoSession {
void finishMocking();
import org.mockito.MockitoSession;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
package org.mockito.exceptions.misusing;
import org.mockito.MockitoSession;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.session.MockitoSessionBuilder;
public class UnfinishedMockingSessionException extends MockitoException {
public UnfinishedMockingSessionException(String message) {
super(message);
import org.mockito.MockitoSession;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.internal.util.StringUtil.join;
field.set(testInstance, spyInstance(field, instance));
field.set(testInstance, spyNewInstance(testInstance, field));
type = testInstance != null ? testInstance.getClass() : type;
private Object spyInstance(Field field, Object instance) {
return Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName()));
private static Object spyNewInstance(Object testInstance, Field field)
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
int modifiers = type.getModifiers();
if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
"",
"You should augment the visibility of this inner class"));
if (typeIsNonStaticInnerClass(type, modifiers)) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + enclosing.getSimpleName() + "'",
""));
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
Constructor<?> constructor = noArgConstructorOf(type);
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
private static Constructor<?> noArgConstructorOf(Class<?> type) {
Constructor<?> constructor;
try {
constructor = type.getDeclaredConstructor();
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
return constructor;
private static boolean typeIsNonStaticInnerClass(Class<?> type, int modifiers) {
return !Modifier.isStatic(modifiers) && type.getEnclosingClass() != null;
private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
import static org.mockito.internal.util.StringUtil.join;
import static org.mockito.internal.util.StringUtil.join;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
import static org.mockito.internal.util.StringUtil.join;
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final Object BOOTSTRAP_LOCK = new Object();
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import static org.mockito.internal.util.StringUtil.join;
throw noMatchingConstructor(cls);
private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
cause);
private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Unable to find a matching 1-arg constructor for the outer instance.")
, null);
t);
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
import static org.mockito.internal.util.StringUtil.join;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringUtil.join;
return new MockitoException(join(
public static void potentialStubbingProblem(
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
public static void unfinishedMockingSession() {
throw new UnfinishedMockingSessionException(join(
"Unfinished mocking session detected.",
"Previous MockitoSession was not concluded with 'finishMocking()'.",
"For examples of correct usage see javadoc for MockitoSession class."));
package org.mockito.internal.framework;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.RedundantListenerException;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.junit.UniversalTestListener;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.quality.Strictness;
public class DefaultMockitoSession implements MockitoSession {
private final Object testClassInstance;
private final UniversalTestListener listener;
public DefaultMockitoSession(Object testClassInstance, Strictness strictness, MockitoLogger logger) {
this.testClassInstance = testClassInstance;
listener = new UniversalTestListener(strictness, logger);
try {
Mockito.framework().addListener(listener);
Reporter.unfinishedMockingSession();
MockitoAnnotations.initMocks(testClassInstance);
public void finishMocking() {
Mockito.framework().removeListener(listener);
listener.testFinished(new TestFinishedEvent() {
public Throwable getFailure() {
return null;
public Object getTestClassInstance() {
return testClassInstance;
public String getTestMethodName() {
return null;
Mockito.validateMockitoUsage();
private Strictness currentStrictness;
private boolean mismatchesReported;
mismatchesReported = true;
Reporter.potentialStubbingProblem(invocation, argMismatchStubbings);
void setCurrentStrictness(Strictness currentStrictness) {
this.currentStrictness = currentStrictness;
boolean isMismatchesReported() {
return mismatchesReported;
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
public class UniversalTestListener implements MockitoTestListener {
public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
this.stubbingLookupListener.setCurrentStrictness(strictness);
import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
import org.mockito.ArgumentMatcher;
return decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
"Is the method annotated with @Test?\n" +
"Is the method public?\n"
package org.mockito.internal.session;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
private Object testClassInstance;
private Strictness strictness;
public MockitoSessionBuilder initMocks(Object testClassInstance) {
this.testClassInstance = testClassInstance;
return this;
public MockitoSessionBuilder strictness(Strictness strictness) {
this.strictness = strictness;
return this;
public MockitoSession startMocking() {
Object effectiveTest = this.testClassInstance == null ? new Object() : this.testClassInstance;
Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
return new DefaultMockitoSession(effectiveTest, effectiveStrictness, new ConsoleMockitoLogger());
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
answers.add(doesNothing());
private static final DoesNothing SINGLETON = new DoesNothing();
private DoesNothing() {}
public static DoesNothing doesNothing(){
return SINGLETON;
public Object answer(InvocationOnMock invocation){
Class<?> returnType = this.method.getReturnType();
return returnType == Void.TYPE|| returnType == Void.class;
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
import org.mockito.internal.util.JavaEightUtil;
import org.mockito.internal.util.ObjectMethodsGuru;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
package org.mockito.internal.util;
import static java.util.Arrays.asList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class StringUtil {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
private StringUtil() {}
public static String removeFirstLine(String text) {
return text.replaceFirst(".*?\n", "");
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Iterable<?> lines) {
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(line.toString()).append("\n");
int lastBreak = out.lastIndexOf("\n");
return out.replace(lastBreak, lastBreak+1, "").toString();
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while (match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
import java.util.Iterator;
public static <T> T firstOf(Iterable<T> iterable) {
Iterator<T> iterator = iterable.iterator();
if (!iterator.hasNext()) {
throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
return iterator.next();
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
import java.util.List;
import org.mockito.invocation.MatchableInvocation;
checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
checkNumberOfInvocations(invocations, wanted, wantedCount);
checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
import org.mockito.internal.verification.api.InOrderContext;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
private NumberOfInvocationsChecker() {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.quality.MockitoHint;
import org.mockito.MockitoSession;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.junit.MockitoJUnitRunner;
package org.mockito.session;
import org.mockito.Incubating;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
public interface MockitoSessionBuilder {
MockitoSessionBuilder initMocks(Object testClassInstance);
MockitoSessionBuilder strictness(Strictness strictness);
MockitoSession startMocking() throws UnfinishedMockingSessionException;
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), doesNothing())
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
package org.mockito.internal.session;
import org.junit.After;
import org.junit.Test;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
import org.mockitoutil.ThrowableAssert;
public class DefaultMockitoSessionBuilderTest {
new StateMaster().clearMockitoListeners();
new DefaultMockitoSessionBuilder().startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().startMocking();
ThrowableAssert.assertThat(new Runnable() {
public void run() {
new DefaultMockitoSessionBuilder().startMocking();
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
import static org.mockitoutil.TestBase.getLastInvocation;
import org.junit.Before;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
public class DoesNothingTest   {
private IMethods mock;
private Invocation invocation_Void;
private Invocation invocation_void;
private Invocation invocation_String;
public void init(){
mock = mock(IMethods.class);
mock.voidMethod();
invocation_Void = getLastInvocation();
mock.voidReturningMethod();
invocation_void = getLastInvocation();
mock.simpleMethod();
invocation_String = getLastInvocation();
public void answer_returnsNull() throws Throwable {
assertThat(doesNothing().answer(invocation_Void)).isNull();
assertThat(doesNothing().answer(invocation_void)).isNull();
assertThat(doesNothing().answer(invocation_String)).isNull();
public void validateFor_nonVoidReturnType_shouldFail()   {
doesNothing().validateFor(invocation_String);
public void validateFor_voidReturnType_shouldPass()   {
doesNothing().validateFor(invocation_void);
public void validateFor_voidObjectReturnType() throws Throwable {
doesNothing().validateFor(invocation_Void);
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockitoutil.TestBase.getLastInvocation;
public void isVoid_invocationOnVoidMethod_returnTrue(){
mock(IMethods.class).voidMethod();
InvocationInfo voidMethod = new InvocationInfo(getLastInvocation());
assertThat(voidMethod.isVoid()).isTrue();
public void isVoid_invocationOnVoidReturningMethod_returnTrue(){
mock(IMethods.class).voidReturningMethod();
InvocationInfo voidRetuningMethod = new InvocationInfo(getLastInvocation());
assertThat(voidRetuningMethod.isVoid()).isTrue();
public void isVoid_invocationNonVoidMethod_returnFalse(){
mock(IMethods.class).simpleMethod();
InvocationInfo stringReturningMethod = new InvocationInfo(getLastInvocation());
assertThat(stringReturningMethod.isVoid()).isFalse();
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
import static junit.framework.TestCase.assertTrue;
public void shouldReturnEmptyArray() {
String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());
assertTrue(ret.getClass().isArray());
assertTrue(ret.length == 0);
public void shouldReturnEmptyString() {
public void assertEmpty() {
if (loggedInfo.length() != 0) {
throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
package org.mockito.internal.util;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.Test;
public class StringUtilTest  {
public void decamelizeMatcher() throws Exception {
assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
public void join_non() throws Exception {
assertThat(StringUtil.join()).isEmpty();;
public void join_singleLine() throws Exception {
assertThat(StringUtil.join("line1")).hasLineCount(2);
public void join_twoLines() throws Exception {
assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
public void join_hasPreceedingLinebreak() throws Exception {
assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
public void removeFirstLine() throws Exception {
assertThat(StringUtil.removeFirstLine("line1\nline2")).isEqualTo("line2");
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).doesNotContain("\n");
assertThat(printer.getActual().toString()).doesNotContain("\n");
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
assertThat(invocation.isVerified()).isFalse();
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
Void voidReturningMethod();
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
public Void voidReturningMethod() {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
List<String> list;
assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
List<String> list = new LinkedList<String>();
assertThat(e.getMessage()).contains("Please ensure that the type")
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
assertThat(e.getMessage()).contains("Unable to create mock instance");
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
public void should_report_private_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivate());
fail();
assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
public void should_report_private_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_report_private_static_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
static class WithInnerPrivateStaticAbstract {
private InnerPrivateStaticAbstract spy_field;
private static abstract class InnerPrivateStaticAbstract {
static class WithInnerPrivateAbstract {
private InnerPrivateAbstract spy_field;
public void some_method() {
new InnerPrivateConcrete();
private abstract class InnerPrivateAbstract {
private class InnerPrivateConcrete extends InnerPrivateAbstract {
static class WithInnerPrivate {
private InnerPrivate spy_field;
private class InnerPrivate {
private class InnerPrivateSub extends InnerPrivate {}
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.spy;
public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
public abstract class GenericAbstract<T> {
protected abstract String method_to_implement(T value);
public String public_method(T value) {
return method_to_implement(value);
public class ImplementsGenericMethodOfAbstract<T extends Number> extends GenericAbstract<T> {
protected String method_to_implement(T value) {
return "concrete value";
public void should_invoke_method_to_implement() {
GenericAbstract<Number> spy = spy(new ImplementsGenericMethodOfAbstract<Number>());
assertThat(spy.public_method(73L)).isEqualTo("concrete value");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
assertThat(e.getCause()).hasMessageContaining("Unable to find a matching 1-arg constructor for the outer instance.");
public void handles_bridge_methods_correctly() {
SomeConcreteClass<Integer> testBug = spy(new SomeConcreteClass<Integer>());
assertEquals("value", testBug.getValue(0));
public abstract class SomeAbstractClass<T> {
protected abstract String getRealValue(T value);
public String getValue(T value) {
return getRealValue(value);
public class SomeConcreteClass<T extends Number> extends SomeAbstractClass<T> {
protected String getRealValue(T value) {
return "value";
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockitoutil.ConcurrentTesting;
ConcurrentTesting.inThread(new Runnable() {
ConcurrentTesting.inThread(new Runnable() {
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
package org.mockitousage.session;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
public class MockitoSessionTest {
private JUnitCore junit = new JUnitCore();
Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result)
.failsExactly(AssertionError.class, UnfinishedStubbingException.class);
public static class SessionWithoutAnyConfiguration {
MockitoSession mockito = Mockito.mockitoSession().startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutInitMocksConfigured {
MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutStrictnessConfigured {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
assertNotNull(mock);
public static class SessionWithIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
public static class SessionWithTestFailureAndIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
assertTrue(false);
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.ConcurrentTesting.concurrently;
import static org.mockitoutil.JUnitResultAssert.assertThat;
public class StrictStubbingEndToEndTest {
JUnitCore junit = new JUnitCore();
new StateMaster().clearMockitoListeners();
Result result = junit.run(UnnecessaryStubbing.class);
assertThat(result)
.fails("unnecessary_stubbing", IllegalStateException.class)
.fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
assertThat(result).fails(1, PotentialStubbingProblem.class);
Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
assertThat(result).succeeds(5);
Result result = junit.run(UnfinishedMocking.class);
assertThat(result)
.fails(UnfinishedMockingSessionException.class, "\n" +
"Unfinished mocking session detected.\n" +
"Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
"For examples of correct usage see javadoc for MockitoSession class.");
final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
concurrently(new Runnable() {
public void run() {
results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
public void run() {
results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
);
assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
public static class UnnecessaryStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod("1")).willReturn("one");
throw new IllegalStateException();
public static class ReportMismatchButNotUnusedStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(2);
public static class StrictStubsPassing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(1);
public static class LenientStrictness1 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class LenientStrictness2 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class UnfinishedMocking {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
given(mock.simpleMethod("1")).willReturn("one");
given(mock.simpleMethod("1")).willReturn("one");
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockitoutil.ThrowableAssert.assertThat;
public class StrictStubbingTest {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
mockito.finishMocking();
mock.simpleMethod(100);
mock.otherMethod();
mock.simpleMethod(100);
mock.otherMethod();
verify(mock).simpleMethod(100);
verify(mock).otherMethod();
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- implicitly verified
mock.simpleMethod(200); // <- unverified
assertThat(new Runnable() {
public void run() {
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mock.simpleMethod(200);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mockito.finishMocking();
package org.mockitousage.stubbing;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.TestBase.filterLineNo;
public class StubbingWarningsTest {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
MockitoSession mockito = new DefaultMockitoSession(this, Strictness.WARN, logger);
mock.simpleMethod(100);
mock.otherMethod();
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- stubbing is used
mock.simpleMethod(200); // <- other method should not generate arg mismatch
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(200);
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
given(mock.simpleMethod(100)).willReturn("100");
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
if (declaredField.getType() == field.getType()) { // don't copy this
package org.mockitoutil;
import java.util.LinkedList;
import java.util.List;
public class ConcurrentTesting {
public static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public static void concurrently(Runnable ... runnables) throws InterruptedException {
List<Thread> threads = new LinkedList<Thread>();
for (Runnable r : runnables) {
Thread t = new Thread(r);
t.start();
threads.add(t);
for (Thread t : threads) {
t.join();
import static org.junit.Assert.assertEquals;
import static org.mockito.internal.util.collections.Iterables.firstOf;
import static org.mockitoutil.TestBase.filterLineNo;
private JUnitResultAssert(Result result) {
throw new AssertionError(formatFailures(result.getFailures()));
fails(expectedFailureCount);
for (Failure f : result.getFailures()) {
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
return this;
public JUnitResultAssert fails(int expectedFailureCount) {
return this;
public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
fails(expectedExceptions.length);
int i = 0;
if (!expectedExceptions[i].isInstance(f.getException())) {
throw new AssertionError("Actual failure #" + (i+1)
+ " should be of type: " + expectedExceptions[i].getSimpleName()
+ " but is of type: " + f.getException().getClass().getSimpleName()
+ "\n" + formatFailures(result.getFailures()));
i++;
public JUnitResultAssert fails(Class expectedException, String exceptionMessage) {
fails(1, expectedException);
Failure f = firstOf(result.getFailures());
assertEquals(filterLineNo(exceptionMessage), filterLineNo(f.getException().getMessage()));
return this;
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
"\n" + formatFailures(result.getFailures()));
StringBuilder sb = new StringBuilder("There were " + failures.size() + " test failures:\n");
int count = 0;
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
return sb.toString();
public static Invocation getLastInvocation() {
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
import static org.mockito.internal.util.StringUtil.join;
import java.io.File;
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);
package org.mockitoinline;
import org.junit.Test;
import org.mockito.Mockito;
public class FinalClassMockingTest {
public void no_exception_while_mocking_final_class() throws Exception {
Mockito.mock(FinalClass.class);
private static final class FinalClass {
package org.mockitoinline;
import org.junit.Test;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import static org.junit.Assert.*;
public class PluginTest {
public void plugin_type_should_be_inline() throws Exception {
assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);MockSettings useConstructor(Object... args);
private static Object spyInstance(Field field, Object instance) {
private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
import org.mockito.internal.util.Checks;
import java.util.ArrayList;
import java.util.Arrays;
private Object[] constructorArgs;
public MockSettings useConstructor(Object... constructorArgs) {
Checks.checkNotNull(constructorArgs,
"constructorArgs",
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
this.constructorArgs = constructorArgs;
public Object[] getConstructorArgs() {
if (outerClassInstance == null) {
return constructorArgs;
List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
resultArgs.add(outerClassInstance);
resultArgs.addAll(Arrays.asList(constructorArgs));
return resultArgs.toArray(new Object[constructorArgs.length + 1]);
Location location,
this.location = location;
import org.mockito.internal.debugging.LocationImpl;
import java.util.ArrayList;
import java.util.List;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
Throwable t = new Throwable();
t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
superMethod,
new LocationImpl(t)));
private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
for (int i = 0; i < elements.length; i++) {
StackTraceElement element = elements[i];
list.add(element);
if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
i++;
return list.toArray(new StackTraceElement[list.size()]);
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.invocation.Location;
return doIntercept(
invokedMethod,
new LocationImpl()
);
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod,
Location location) throws Throwable {
return handler.handle(new InterceptedInvocation(
mock,
createMockitoMethod(invokedMethod),
arguments,
superMethod,
location,
SequenceNumber.next()
.transform(withModifiers(SynchronizationState.PLAIN))
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.util.Primitives;
private final boolean hasOuterClassInstance;
private final Object[] constructorArgs;
public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
this.hasOuterClassInstance = hasOuterClassInstance;
this.constructorArgs = constructorArgs;
return withParams(cls, constructorArgs);
private <T> T withParams(Class<T> cls, Object... params) {
List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
evaluateConstructor(matchingConstructors, constructor);
if (matchingConstructors.size() == 1) {
return invokeConstructor(matchingConstructors.get(0), params);
if (matchingConstructors.size() == 0) {
throw noMatchingConstructor(cls);
throw multipleMatchingConstructors(cls, matchingConstructors);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
private InstantiationException paramsException(Class<?> cls, Exception e) {
return new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
, e);
private String constructorArgTypes() {
int argPos = 0;
if (hasOuterClassInstance) {
++argPos;
String[] constructorArgTypes = new String[constructorArgs.length - argPos];
for (int i = argPos; i < constructorArgs.length; ++i) {
constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
return Arrays.toString(constructorArgTypes);
private InstantiationException noMatchingConstructor(Class<?> cls) {
String constructorString = constructorArgsString();
String outerInstanceHint = "";
if (hasOuterClassInstance) {
outerInstanceHint = " and provided outer instance is correct";
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the target class has " + constructorString + outerInstanceHint + ".")
private String constructorArgsString() {
String constructorString;
if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
constructorString = "a 0-arg constructor";
constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
return constructorString;
private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
join("", " - ", constructors),
"If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
"See https://github.com/mockito/mockito/issues/685"
), null);
if (params[i] == null) {
if (types[i].isPrimitive()) {
return false;
(types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
boolean newHasBetterParam = false;
boolean existingHasBetterParam = false;
Class<?>[] paramTypes = constructor.getParameterTypes();
for (int i = 0; i < paramTypes.length; ++i) {
Class<?> paramType = paramTypes[i];
if (!paramType.isPrimitive()) {
for (Constructor<?> existingCtor : matchingConstructors) {
Class<?> existingParamType = existingCtor.getParameterTypes()[i];
if (paramType != existingParamType) {
if (paramType.isAssignableFrom(existingParamType)) {
existingHasBetterParam = true;
newHasBetterParam = true;
if (!existingHasBetterParam) {
matchingConstructors.clear();
if (newHasBetterParam || !existingHasBetterParam) {
matchingConstructors.add(constructor);
if (settings != null && settings.getConstructorArgs() != null) {
return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
private Object[] constructorArgs;
this.constructorArgs = copy.getConstructorArgs();
public Object[] getConstructorArgs() {
return constructorArgs;
this(stackTraceFilter, new Throwable());
public LocationImpl(Throwable stackTraceHolder) {
this(new StackTraceFilter(), stackTraceHolder);
private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
this.stackTraceHolder = stackTraceHolder;
import org.mockito.internal.junit.ExceptionFactory;
return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import junit.framework.ComparisonFailure;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactory {
private final static boolean hasJUnit = canLoadJunitClass();
private ExceptionFactory() {
public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual) {
if (hasJUnit) {
return createJUnitArgumentsAreDifferent(message, wanted, actual);
return new ArgumentsAreDifferent(message);
private static AssertionError createJUnitArgumentsAreDifferent(String message, String wanted, String actual) {
return JUnitArgsAreDifferent.create(message, wanted, actual);
private static boolean canLoadJunitClass() {
try {
JUnitArgsAreDifferent.create("message", "wanted", "actual");
return false;
return true;
private static class JUnitArgsAreDifferent {
static AssertionError create(String message, String wanted, String actual) {
return new org.mockito.exceptions.verification.junit.ArgumentsAreDifferent(message, wanted, actual);
return checkNotNull(value, checkedValue, null);
public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
String message = checkedValue + " should not be null";
if (additionalMessage != null) {
message += ". " + additionalMessage;
throw new IllegalArgumentException(message);
import java.util.Locale;
import static org.mockito.internal.util.StringUtil.join;
public static boolean isAndroid() {
return System.getProperty("java.vendor", "").toLowerCase(Locale.US).contains("android");
public static boolean isAndroidMockMakerRequired() {
return Boolean.getBoolean("org.mockito.mock.android");
String description = String.format("Java               : %s\n" +
if (isAndroid()) {
description = join(
"IMPORTANT INFORMATION FOR ANDROID USERS:",
"",
"The regular Byte Buddy mock makers cannot generate code on an Android VM!",
"To resolve this, please use the 'mockito-android' dependency for your application:",
"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22",
"",
description
);
return description;
import java.util.Collection;
public static String join(String start, Collection<?> lines) {
return join(start, "", lines);
public static String join(String start, String linePrefix, Collection<?> lines) {
if (lines.isEmpty()) {
return "";
out.append(linePrefix).append(line).append("\n");
return out.substring(0, out.length() - 1); //lose last EOL
public Object[] getConstructorArgs();
package org.mockito.internal.creation;
import org.junit.Test;
import org.mockito.Mockito;
import static junit.framework.TestCase.assertEquals;
public class InterfaceOverrideTest {
public interface CloneableInterface extends Cloneable {
CloneableInterface clone();
public void inherit_public_method_from_interface() {
CloneableInterface i = Mockito.mock(CloneableInterface.class);
Mockito.when(i.clone()).thenReturn(i);
assertEquals(i, i.clone());
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
static class SomeClass3 {
SomeClass3(int i) {
assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
public void creates_instances_with_arguments() {
assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_null_arguments() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
public void creates_instances_with_primitive_arguments() {
assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
public void fails_when_null_is_passed_for_a_primitive() {
assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
"Please ensure that the target class has a 0-arg constructor.");
package org.mockito.internal.junit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockitoutil.ClassLoaders.excludingClassLoader;
import java.lang.reflect.Method;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
public class ExceptionFactoryTest {
private static ClassLoader classLoaderWithoutJUnit = excludingClassLoader().withCodeSourceUrlOf(ExceptionFactory.class).without("org.junit", "junit").build();
private static Class<?> junitArgumentsAreDifferent;
private static Class<?> nonJunitArgumentsAreDifferent;
public static void init() throws ClassNotFoundException {
nonJunitArgumentsAreDifferent = classLoaderWithoutJUnit.loadClass(ArgumentsAreDifferent.class.getName());
junitArgumentsAreDifferent = org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class;
public void createArgumentsAreDifferentException_withoutJUnit() throws Exception {
Class<?> exceptionFactory = classLoaderWithoutJUnit.loadClass(ExceptionFactory.class.getName());
Method m = exceptionFactory.getDeclaredMethod("createArgumentsAreDifferentException", String.class, String.class, String.class);
Object e = m.invoke(null, "message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit() throws Exception {
AssertionError e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
public void createArgumentsAreDifferentException_withJUnit2x() throws Exception {
AssertionError e;
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
e = ExceptionFactory.createArgumentsAreDifferentException("message", "wanted", "actual");
assertThat(e).isExactlyInstanceOf(junitArgumentsAreDifferent);
package org.mockito.internal.util;
import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
public class ChecksTest {
public ExpectedException expectedException = ExpectedException.none();
public void checkNotNull_not_null() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
public void checkNotNull_not_null_additional_message() throws Exception {
assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
public void checkNotNull_null() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null");
Checks.checkNotNull(null, "someValue");
public void checkNotNull_null_additonal_message() throws Exception {
expectedException.expect(IllegalArgumentException.class);
expectedException.expectMessage("someValue should not be null. Oh no!");
Checks.checkNotNull(null, "someValue", "Oh no!");
import org.junit.Test;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
public void decamelizes_matcher() throws Exception {
public void joins_empty_list() throws Exception {
assertThat(StringUtil.join()).isEmpty();
assertThat(StringUtil.join("foo", emptyList())).isEmpty();
public void joins_single_line() throws Exception {
public void joins_two_lines() throws Exception {
public void join_has_preceeding_linebreak() throws Exception {
public void removes_first_line() throws Exception {
public void joins_with_line_prefix() throws Exception {
assertEquals("Hey!\n" +
" - a\n" +
" - b", StringUtil.join("Hey!\n", " - ", asList("a", "b")));
public void should_allow_spying_on_interfaces() throws Exception {
MockitoAnnotations.initMocks(withSpy);
when(withSpy.list.size()).thenReturn(3);
assertEquals(3, withSpy.list.size());
public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
AbstractMessage(String message) {
this.message = message;
AbstractMessage(int i) {
this.message = String.valueOf(i);
public void can_spy_abstract_classes_with_constructor_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
assertEquals("hello!", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_primitive_args() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("7", mock.getMessage());
public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_casted_null() {
AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
assertNull(mock.getMessage());
public void can_spy_abstract_classes_with_null_varargs() {
try {
mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
"If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
public static class ThrowingConstructorClass{
public ThrowingConstructorClass() {
throw new RuntimeException();
public void explains_constructor_exceptions() {
try {
mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
static class Base {}
static class ExtendsBase extends Base {}
static class ExtendsExtendsBase extends ExtendsBase {}
static class UsesBase {
public UsesBase(Base b) {
constructorUsed = "Base";
public UsesBase(ExtendsBase b) {
constructorUsed = "ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase", u.getConstructorUsed());
static class UsesTwoBases {
public UsesTwoBases(Base b1, Base b2) {
constructorUsed = "Base,Base";
public UsesTwoBases(ExtendsBase b1, Base b2) {
constructorUsed = "ExtendsBase,Base";
public UsesTwoBases(Base b1, ExtendsBase b2) {
constructorUsed = "Base,ExtendsBase";
private String constructorUsed = null;
String getConstructorUsed() {
return constructorUsed;
public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("ExtendsBase,Base", u.getConstructorUsed());
public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
UsesTwoBases u =
mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("Base,ExtendsBase", u.getConstructorUsed());
public void fail_when_multiple_matching_constructors_with_inheritence() {
try {
mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
fail();
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
assertThat(e.getCause())
.hasMessageContaining("Multiple constructors could be matched to arguments of types "
+ "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+ "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
.hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
"Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
"See https://github.com/mockito/mockito/issues/685");
mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining(
"Please ensure that the target class has a 0-arg constructor"
+ " and provided outer instance is correct.");
public void interface_method_stubbed() {
List<?> list = spy(List.class);
when(list.size()).thenReturn(12);
assertEquals(12, list.size());
private static class AmbiguousWithPrimitive {
public AmbiguousWithPrimitive(String s, int i) {
data = s;
public AmbiguousWithPrimitive(Object o, int i) {
data = "just an object";
private String data;
public String getData() {
return data;
public void can_spy_ambiguius_constructor_with_primitive() {
AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
assertEquals("String", mock.getData());
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.Platform;
import static org.mockito.internal.util.StringUtil.join;
private final MockMaker delegate;
public AndroidByteBuddyMockMaker() {
if (Platform.isAndroid() || Platform.isAndroidMockMakerRequired()) {
delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());
new ConsoleMockitoLogger().log(join(
"IMPORTANT NOTE FROM MOCKITO:",
"",
"You included the 'mockito-android' dependency in a non-Android environment.",
"The Android mock maker was disabled. You should only include the latter in your 'androidTestCompile' configuration",
"If disabling was a mistake, you can set the 'org.mockito.mock.android' property to 'true' to override this detection.",
"",
"Visit https://javadoc.io/page/org.mockito/mockito-core/latest/org/mockito/Mockito.html#0.1 for more information"
));
delegate = new SubclassByteBuddyMockMaker();
package org.mockitoinline;
import java.util.Collections;
import java.util.Set;
import org.junit.Test;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.stubbing.Stubbing;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingLocationTest {
public void stubbing_location_should_be_the_correct_point() {
ConcreteClass mock = mock(ConcreteClass.class);
String frame;
when(mock.concreteMethod(frame = Thread.currentThread().getStackTrace()[1].toString())).thenReturn("");
mock.concreteMethod(frame);
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(Collections.singleton(mock));
assertEquals(1, stubbings.size());
String location = stubbings.iterator().next().getInvocation().getLocation().toString();
assertEquals("-> at " + frame, location);
static final class ConcreteClass {
String concreteMethod(String s) {
throw new RuntimeException(s);location = new LocationImpl();
superMethod));
return handler.handle(new InterceptedInvocation(
createMockitoMethod(invokedMethod),
SequenceNumber.next()
stackTraceHolder = new Throwable();matchingConstructors.add(constructor);
"If you believe that Mockito could do a better join deciding on which constructor to use, please let us know.",
public UsesBase(Base b) {}
public UsesBase(ExtendsBase b) {}
public void can_mock_unambigous_constructor_with_inheritence() {
mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
public void exception_message_when_ambiguous_constructor_found_exact_exists() throws Exception {
try {
mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
fail();
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
assertThat(e.getCause()).hasMessageContaining
("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]");
public void fail_when_multiple_matching_constructors() {
mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
.hasMessageContaining("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsExtendsBase]")
.hasMessageContaining("If you believe that Mockito could do a better join deciding on which constructor to use, please let us know.\n" +MockSettings useConstructor();
public MockSettings useConstructor() {
private final Object outerClassInstance;
public ConstructorInstantiator(Object outerClassInstance) {
this.outerClassInstance = outerClassInstance;
if (outerClassInstance == null) {
return noArgConstructor(cls);
return withParams(cls, outerClassInstance);
private static <T> T withParams(Class<T> cls, Object... params) {
return invokeConstructor(constructor, params);
throw noMatchingConstructor(cls);
private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
cause);
private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Unable to find a matching 1-arg constructor for the outer instance.")
if (!types[i].isInstance(params[i])) {
private static <T> T noArgConstructor(Class<T> cls) {
try {
return invokeConstructor(cls.getDeclaredConstructor());
throw new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure it has 0-arg constructor which invokes cleanly."),
t);
if (settings != null && settings.isUsingConstructor()) {
return new ConstructorInstantiator(settings.getOuterClassInstance());
assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
new ConstructorInstantiator(null).newInstance(SomeClass2.class);
"Please ensure it has 0-arg constructor which invokes cleanly.");
assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
assertThat(e.getCause()).hasMessageContaining("Unable to find a matching 1-arg constructor for the outer instance.");.transform(withModifiers(SynchronizationState.PLAIN, Visibility.PUBLIC))return null;       
mockingProgress().getArgumentMatcherStorage().reportAnd(); 
mockingProgress().getArgumentMatcherStorage().reportNot(); 
for(Annotation annotation : field.getAnnotations()) {           
throwIfAlreadyAssigned(field, alreadyAssigned);                    
alreadyAssigned = true;                    
private static Object spyInstance(Field field, Object instance) {
private static void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
return warnings == null || "".equals(warnings); // isEmpty() is in JDK 6+ 
if (!actual.getClass().isInstance(wanted)){ 
return  "iOngoingStubbing: " + ongoingStubbing + 
"Haven't you forgot @Test annotation?\n"
throw new RuntimeException(e);        
stubbing = thenThrow(t);                    
import org.mockito.internal.stubbing.answers.DoesNothing;
answers.add(new DoesNothing());
public Object answer(InvocationOnMock invocation) throws Throwable {
return this.method.getReturnType() == Void.TYPE;
else 
return m.getReturnType() == String.class && 
m.getParameterTypes().length == 0 && 
return String.format("Java               : %s\n" +
list.add(o);        
package org.mockito.internal.util.reflection;
import java.lang.reflect.Constructor;
public abstract class Constructors {
public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {
try {
return classToMock.getDeclaredConstructor();
return null;
public Class<?> getGenericType(Field field) {        
this.inOrder = inOrder;        
if (invocations.size() != 1 && chunk.size() > 0) {            
InOrderContext getOrderingContext(); 
this.wanted = wanted;        
void verifyInOrder(VerificationDataInOrder data);    
&& !safelyMatches(m, arguments[i]) 
public void run(final RunNotifier notifier) {           
public void run(final RunNotifier notifier) {           
public void run(RunNotifier notifier) {        
public void testFailure(final Failure failure) throws Exception {       
new JUnitFailureHacker().appendWarnings(failure, warnings);                              
Stubber doAnswer(Answer answer);    
public void shouldDetectMisplacedArgumentMatcher() {      
"org.mockito.Mockito" 
"org.mockito.Mockito" 
"org.mockito.Mockito", 
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
assertEquals(ex, failure.getException());        
assertEquals(ex, failure.getException());        
import org.mockito.internal.invocation.InvocationBuilder;
import static org.assertj.core.api.Assertions.assertThat;
public class DoesNothingTest {
public void should_do_nothing() throws Throwable {
assertThat(new DoesNothing().answer(new InvocationBuilder().method("voidMethod").toInvocation())).isNull();
public void should_fail_when_non_void_method_does_nothing() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_allow_void_return_for_void_method() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
class Foo {        
private final String isNull = null;        
private final String notNull = "";        
package org.mockito;
String canThrowException() throws CharacterCodingException; 
assertEquals(0, returningDefaults.intReturningMethod()); 
assertEquals(0, noExtraConfig.intReturningMethod());        
class Tested {        
public void should_allow_spying_on_interfaces() throws Exception {
MockitoAnnotations.initMocks(withSpy);
when(withSpy.list.size()).thenReturn(3);
assertEquals(3, withSpy.list.size());
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_not_allow_Spy_and_InjectMocks_on_interfaces() throws Exception {
.name("great mockie"));    
CustomAnswersMustImplementSerializableForSerializationToWork answer = 
foo.varArgs("");        
foo.varArgs((String[]) null);    
public class Foo {      
public void varArgs(String... args) {}       
public void interface_method_stubbed() {
List<?> list = spy(List.class);
when(list.size()).thenReturn(12);
assertEquals(12, list.size());
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree)); 
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo)); 
throw new RuntimeException("Silent rule should not write anything to the logger");        
assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);        
mock(Integer.TYPE); 
verify(mock).oneArg(true); 
fail(); 
IMethods methods = unstubbedMethodInvokedHere(mock); 
verifyNoMoreInteractions(mock);        
String expected = 
"-> at "; 
String expectedCause = 
String expected = 
"-> at"; 
String expectedMessage = 
"iMethods.simpleMethod(999);"; 
String expectedMessage = 
"-> at"; 
String expectedMessage = 
String expectedCause = 
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        
protected Invocation getLastInvocation() {
private final MockMaker delegate = new SubclassByteBuddyMockMaker(new AndroidLoadingStrategy());"Haven't you forgot @Test annotation?\n"import org.mockito.internal.stubbing.answers.DoesNothing;
answers.add(new DoesNothing());
public Object answer(InvocationOnMock invocation) throws Throwable {
return this.method.getReturnType() == Void.TYPE;
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
import org.mockito.internal.invocation.InvocationBuilder;
import static org.assertj.core.api.Assertions.assertThat;
public class DoesNothingTest {
public void should_do_nothing() throws Throwable {
assertThat(new DoesNothing().answer(new InvocationBuilder().method("voidMethod").toInvocation())).isNull();
public void should_fail_when_non_void_method_does_nothing() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().simpleMethod().toInvocation());
public void should_allow_void_return_for_void_method() throws Throwable {
new DoesNothing().validateFor(new InvocationBuilder().method("voidMethod").toInvocation());
protected Invocation getLastInvocation() {return null;       
mockingProgress().getArgumentMatcherStorage().reportAnd(); 
mockingProgress().getArgumentMatcherStorage().reportNot(); 
for(Annotation annotation : field.getAnnotations()) {           
throwIfAlreadyAssigned(field, alreadyAssigned);                    
alreadyAssigned = true;                    
return warnings == null || "".equals(warnings); // isEmpty() is in JDK 6+ 
if (!actual.getClass().isInstance(wanted)){ 
return  "iOngoingStubbing: " + ongoingStubbing + 
throw new RuntimeException(e);        
stubbing = thenThrow(t);                    
else 
return m.getReturnType() == String.class && 
m.getParameterTypes().length == 0 && 
list.add(o);        
public Class<?> getGenericType(Field field) {        
this.inOrder = inOrder;        
if (invocations.size() != 1 && chunk.size() > 0) {            
InOrderContext getOrderingContext(); 
this.wanted = wanted;        
void verifyInOrder(VerificationDataInOrder data);    
&& !safelyMatches(m, arguments[i]) 
public void run(final RunNotifier notifier) {           
public void run(final RunNotifier notifier) {           
public void run(RunNotifier notifier) {        
public void testFailure(final Failure failure) throws Exception {       
new JUnitFailureHacker().appendWarnings(failure, warnings);                              
Stubber doAnswer(Answer answer);    
public void shouldDetectMisplacedArgumentMatcher() {      
"org.mockito.Mockito" 
"org.mockito.Mockito" 
"org.mockito.Mockito", 
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertEquals(ex, failure.getException());        
assertEquals(ex, failure.getException());        
class Foo {        
private final String isNull = null;        
private final String notNull = "";        
String canThrowException() throws CharacterCodingException; 
assertEquals(0, returningDefaults.intReturningMethod()); 
assertEquals(0, noExtraConfig.intReturningMethod());        
class Tested {        
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
.name("great mockie"));    
CustomAnswersMustImplementSerializableForSerializationToWork answer = 
foo.varArgs("");        
foo.varArgs((String[]) null);    
public class Foo {      
public void varArgs(String... args) {}       
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree)); 
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo)); 
throw new RuntimeException("Silent rule should not write anything to the logger");        
assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);        
mock(Integer.TYPE); 
verify(mock).oneArg(true); 
fail(); 
IMethods methods = unstubbedMethodInvokedHere(mock); 
verifyNoMoreInteractions(mock);        
String expected = 
"-> at "; 
String expectedCause = 
String expected = 
"-> at"; 
String expectedMessage = 
"iMethods.simpleMethod(999);"; 
String expectedMessage = 
"-> at"; 
String expectedMessage = 
String expectedCause = 
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
return null;       
mockingProgress().getArgumentMatcherStorage().reportAnd(); 
mockingProgress().getArgumentMatcherStorage().reportNot(); 
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
return mock(classToMock, withSettings());
public static MockitoSessionBuilder mockitoSession() {
return new DefaultMockitoSessionBuilder();
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.MockitoListener;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public interface MockitoSession {
void finishMocking();
import org.mockito.MockitoSession;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
package org.mockito.exceptions.misusing;
import org.mockito.MockitoSession;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.session.MockitoSessionBuilder;
public class UnfinishedMockingSessionException extends MockitoException {
public UnfinishedMockingSessionException(String message) {
super(message);
import org.mockito.MockitoSession;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
import static org.mockito.internal.util.StringUtil.removeFirstLine;
return removeFirstLine(super.toString());
for(Annotation annotation : field.getAnnotations()) {           
throwIfAlreadyAssigned(field, alreadyAssigned);                    
alreadyAssigned = true;                    
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.internal.util.StringUtil.join;
field.set(testInstance, spyInstance(field, instance));
field.set(testInstance, spyNewInstance(testInstance, field));
type = testInstance != null ? testInstance.getClass() : type;
private Object spyInstance(Field field, Object instance) {
return Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName()));
private static Object spyNewInstance(Object testInstance, Field field)
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
int modifiers = type.getModifiers();
if (typeIsPrivateAbstractInnerClass(type, modifiers)) {
throw new MockitoException(join("@Spy annotation can't initialize private abstract inner classes.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + type.getEnclosingClass().getSimpleName() + "'",
"",
"You should augment the visibility of this inner class"));
if (typeIsNonStaticInnerClass(type, modifiers)) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException(join("@Spy annotation can only initialize inner classes declared in the test.",
"  inner class: '" + type.getSimpleName() + "'",
"  outer class: '" + enclosing.getSimpleName() + "'",
""));
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
Constructor<?> constructor = noArgConstructorOf(type);
if (Modifier.isPrivate(constructor.getModifiers())) {
constructor.setAccessible(true);
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
return Mockito.mock(type, settings.useConstructor());
private static Constructor<?> noArgConstructorOf(Class<?> type) {
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has a no-arg constructor.");
return constructor;
private static boolean typeIsNonStaticInnerClass(Class<?> type, int modifiers) {
return !Modifier.isStatic(modifiers) && type.getEnclosingClass() != null;
private static boolean typeIsPrivateAbstractInnerClass(Class<?> type, int modifiers) {
return Modifier.isPrivate(modifiers) && Modifier.isAbstract(modifiers) && type.getEnclosingClass() != null;
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
import static org.mockito.internal.util.StringUtil.join;
import static org.mockito.internal.util.StringUtil.join;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
import static org.mockito.internal.util.StringUtil.join;
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final Object BOOTSTRAP_LOCK = new Object();
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import static org.mockito.internal.util.StringUtil.join;
throw noMatchingConstructor(cls);
private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
cause);
private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
return new InstantiationException(
join("Unable to create instance of '" + cls.getSimpleName() + "'.",
"Unable to find a matching 1-arg constructor for the outer instance.")
, null);
t);
sb.append("[Mockito] Unused stubbings of: " + mock).append("\n");
import static org.mockito.internal.util.StringUtil.join;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.verification.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringUtil.join;
return new MockitoException(join(
public static void potentialStubbingProblem(
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
public static void unfinishedMockingSession() {
throw new UnfinishedMockingSessionException(join(
"Unfinished mocking session detected.",
"Previous MockitoSession was not concluded with 'finishMocking()'.",
"For examples of correct usage see javadoc for MockitoSession class."));
package org.mockito.internal.framework;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.RedundantListenerException;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.internal.junit.TestFinishedEvent;
import org.mockito.internal.junit.UniversalTestListener;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.quality.Strictness;
public class DefaultMockitoSession implements MockitoSession {
private final Object testClassInstance;
private final UniversalTestListener listener;
public DefaultMockitoSession(Object testClassInstance, Strictness strictness, MockitoLogger logger) {
this.testClassInstance = testClassInstance;
listener = new UniversalTestListener(strictness, logger);
try {
Mockito.framework().addListener(listener);
Reporter.unfinishedMockingSession();
MockitoAnnotations.initMocks(testClassInstance);
public void finishMocking() {
Mockito.framework().removeListener(listener);
listener.testFinished(new TestFinishedEvent() {
public Throwable getFailure() {
return null;
public Object getTestClassInstance() {
return testClassInstance;
public String getTestMethodName() {
return null;
Mockito.validateMockitoUsage();
private Strictness currentStrictness;
private boolean mismatchesReported;
mismatchesReported = true;
Reporter.potentialStubbingProblem(invocation, argMismatchStubbings);
void setCurrentStrictness(Strictness currentStrictness) {
this.currentStrictness = currentStrictness;
boolean isMismatchesReported() {
return mismatchesReported;
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
public class UniversalTestListener implements MockitoTestListener {
public UniversalTestListener(Strictness initialStrictness, MockitoLogger logger) {
private void reportUnusedStubs(TestFinishedEvent event, Collection<Object> mocks) {
if (event.getFailure() == null && !stubbingLookupListener.isMismatchesReported()) {
this.stubbingLookupListener.setCurrentStrictness(strictness);
return warnings == null || "".equals(warnings); // isEmpty() is in JDK 6+ 
if (!actual.getClass().isInstance(wanted)){ 
import static org.mockito.internal.util.StringUtil.decamelizeMatcher;
import org.mockito.ArgumentMatcher;
return decamelizeMatcher(matcher.getClass().getSimpleName());
import org.mockito.internal.exceptions.Reporter;
return  "iOngoingStubbing: " + ongoingStubbing + 
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
throw new RuntimeException(e);        
package org.mockito.internal.session;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
public class DefaultMockitoSessionBuilder implements MockitoSessionBuilder {
private Object testClassInstance;
private Strictness strictness;
public MockitoSessionBuilder initMocks(Object testClassInstance) {
this.testClassInstance = testClassInstance;
return this;
public MockitoSessionBuilder strictness(Strictness strictness) {
this.strictness = strictness;
return this;
public MockitoSession startMocking() {
Object effectiveTest = this.testClassInstance == null ? new Object() : this.testClassInstance;
Strictness effectiveStrictness = this.strictness == null ? Strictness.STRICT_STUBS : this.strictness;
return new DefaultMockitoSession(effectiveTest, effectiveStrictness, new ConsoleMockitoLogger());
stubbing = thenThrow(t);                    
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
else 
if (t == null) {
throw throwable;
import org.mockito.internal.util.JavaEightUtil;
import org.mockito.internal.util.ObjectMethodsGuru;
import java.io.Serializable;
import java.util.*;
return JavaEightUtil.emptyOptional();
return JavaEightUtil.emptyOptionalDouble();
return JavaEightUtil.emptyOptionalInt();
return JavaEightUtil.emptyOptionalLong();
return JavaEightUtil.emptyStream();
return JavaEightUtil.emptyDoubleStream();
return JavaEightUtil.emptyIntStream();
return JavaEightUtil.emptyLongStream();
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
package org.mockito.internal.util;
import org.mockito.internal.creation.instance.InstantiationException;
import java.lang.reflect.Method;
public final class JavaEightUtil {
private static Object emptyOptional;
private static Object emptyOptionalDouble;
private static Object emptyOptionalInt;
private static Object emptyOptionalLong;
private JavaEightUtil() {
public static Object emptyOptional() {
if (emptyOptional != null) {
return emptyOptional;
return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
public static Object emptyOptionalDouble() {
if (emptyOptionalDouble != null) {
return emptyOptionalDouble;
return emptyOptionalDouble = invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
public static Object emptyOptionalInt() {
if (emptyOptionalInt != null) {
return emptyOptionalInt;
return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
public static Object emptyOptionalLong() {
if (emptyOptionalLong != null) {
return emptyOptionalLong;
return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
public static Object emptyStream() {
return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
public static Object emptyDoubleStream() {
return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
public static Object emptyIntStream() {
return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
public static Object emptyLongStream() {
return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
try {
final Class<?> type = Class.forName(fqcn);
final Method method = type.getMethod(methodName);
return method.invoke(null);
throw new InstantiationException(
String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
return m.getReturnType() == String.class && 
m.getParameterTypes().length == 0 && 
package org.mockito.internal.util;
import static java.util.Arrays.asList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class StringUtil {
private static final Pattern CAPS = Pattern.compile("([A-Z\\d][^A-Z\\d]*)");
private StringUtil() {}
public static String removeFirstLine(String text) {
return text.replaceFirst(".*?\n", "");
public static String join(Object ... linesToBreak) {
return join("\n", asList(linesToBreak));
public static String join(String start, Iterable<?> lines) {
StringBuilder out = new StringBuilder(start);
for (Object line : lines) {
out.append(line.toString()).append("\n");
int lastBreak = out.lastIndexOf("\n");
return out.replace(lastBreak, lastBreak+1, "").toString();
public static String decamelizeMatcher(String className) {
if (className.length() == 0) {
return "<custom argument matcher>";
String decamelized = decamelizeClassName(className);
if (decamelized.length() == 0) {
return "<" + className + ">";
return "<" + decamelized + ">";
private static String decamelizeClassName(String className) {
Matcher match = CAPS.matcher(className);
StringBuilder deCameled = new StringBuilder();
while (match.find()) {
if (deCameled.length() == 0) {
deCameled.append(match.group());
deCameled.append(" ");
deCameled.append(match.group().toLowerCase());
return deCameled.toString();
list.add(o);        
import java.util.Iterator;
public static <T> T firstOf(Iterable<T> iterable) {
Iterator<T> iterator = iterable.iterator();
if (!iterator.hasNext()) {
throw new IllegalArgumentException("Cannot provide 1st element from empty iterable: " + iterable);
return iterator.next();
public Class<?> getGenericType(Field field) {        
import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
import java.util.List;
import org.mockito.invocation.MatchableInvocation;
checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
this.inOrder = inOrder;        
if (invocations.size() != 1 && chunk.size() > 0) {            
import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
checkNumberOfInvocations(invocations, wanted, wantedCount);
checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
InOrderContext getOrderingContext(); 
this.wanted = wanted;        
void verifyInOrder(VerificationDataInOrder data);    
&& !safelyMatches(m, arguments[i]) 
import org.mockito.internal.verification.api.InOrderContext;
import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
private NumberOfInvocationsChecker() {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
int actualCount = chunk.size();
if (wantedCount > actualCount) {
Location lastInvocation = getLastLocation(chunk);
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
if (wantedCount < actualCount) {
Location firstUndesired = chunk.get(wantedCount).getLocation();
throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
markVerifiedInOrder(chunk, wanted, context);
public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
int actualCount = 0;
Location lastLocation = null;
while( actualCount < wantedCount ){
Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
if( next == null ){
throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
markVerified( next, wanted );
context.markVerified( next );
lastLocation = next.getLocation();
actualCount++;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
public void run(final RunNotifier notifier) {           
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.quality.MockitoHint;
import org.mockito.MockitoSession;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.junit.MockitoJUnitRunner;
public void run(final RunNotifier notifier) {           
public void run(RunNotifier notifier) {        
public void testFailure(final Failure failure) throws Exception {       
new JUnitFailureHacker().appendWarnings(failure, warnings);                              
package org.mockito.session;
import org.mockito.Incubating;
import org.mockito.MockitoAnnotations;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
public interface MockitoSessionBuilder {
MockitoSessionBuilder initMocks(Object testClassInstance);
MockitoSessionBuilder strictness(Strictness strictness);
MockitoSession startMocking() throws UnfinishedMockingSessionException;
Stubber doAnswer(Answer answer);    
public void shouldDetectMisplacedArgumentMatcher() {      
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
"org.mockito.Mockito" 
"org.mockito.Mockito" 
"org.mockito.Mockito", 
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
assertEquals(ex, failure.getException());        
assertEquals(ex, failure.getException());        
package org.mockito.internal.session;
import org.junit.After;
import org.junit.Test;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.quality.Strictness;
import org.mockitoutil.ThrowableAssert;
public class DefaultMockitoSessionBuilderTest {
new StateMaster().clearMockitoListeners();
new DefaultMockitoSessionBuilder().startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(null).strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(null).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(this).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().initMocks(new Object()).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().strictness(Strictness.LENIENT).startMocking().finishMocking();
new DefaultMockitoSessionBuilder().startMocking();
ThrowableAssert.assertThat(new Runnable() {
public void run() {
new DefaultMockitoSessionBuilder().startMocking();
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
import org.junit.Assume;
import java.util.*;
import static junit.framework.TestCase.*;
verify_empty_Optional_is_returned("java.util.stream.Stream", "java.util.Optional");
public void should_return_empty_OptionalDouble() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.DoubleStream", "java.util.OptionalDouble");
public void should_return_empty_OptionalInt() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.IntStream", "java.util.OptionalInt");
public void should_return_empty_OptionalLong() throws Exception {
verify_empty_Optional_is_returned("java.util.stream.LongStream", "java.util.OptionalLong");
private void verify_empty_Optional_is_returned(String streamFqcn, String optionalFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = mock(streamType);
Object optional = streamType.getMethod("findAny").invoke(stream);
assertNotNull(optional);
assertFalse((Boolean) Class.forName(optionalFqcn).getMethod("isPresent").invoke(optional));
Invocation findAny = this.getLastInvocation();
Object result = values.answer(findAny);
assertEquals(optional, result);
public void should_return_empty_Stream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.Stream");
public void should_return_empty_DoubleStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.DoubleStream");
public void should_return_empty_IntStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.IntStream");
public void should_return_empty_LongStream() throws Exception {
verify_empty_Stream_is_returned("java.util.stream.LongStream");
private void verify_empty_Stream_is_returned(String streamFqcn) throws Exception {
Class<?> streamType = getClassOrSkipTest(streamFqcn);
Object stream = values.returnValueFor(streamType);
long count = (Long) streamType.getMethod("count").invoke(stream);
assertEquals("count of empty " + streamFqcn, 0L, count);
private Class<?> getClassOrSkipTest(String className) {
try {
return Class.forName(className);
Assume.assumeNoException("JVM does not support " + className, e);
return null;
import static junit.framework.TestCase.assertTrue;
public void shouldReturnEmptyArray() {
String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());
assertTrue(ret.getClass().isArray());
assertTrue(ret.length == 0);
public void shouldReturnEmptyString() {
public void assertEmpty() {
if (loggedInfo.length() != 0) {
throw new AssertionError("Expected the logger to be empty but it has:\n" + loggedInfo.toString());
package org.mockito.internal.util;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.Test;
public class StringUtilTest  {
public void decamelizeMatcher() throws Exception {
assertEquals("<Sentence with strong language>", StringUtil.decamelizeMatcher("SentenceWithStrongLanguage"));
assertEquals("<W e i r d o 1>", StringUtil.decamelizeMatcher("WEIRDO1"));
assertEquals("<_>", StringUtil.decamelizeMatcher("_"));
assertEquals("<Has exactly 3 elements>", StringUtil.decamelizeMatcher("HasExactly3Elements"));
assertEquals("<custom argument matcher>", StringUtil.decamelizeMatcher(""));
public void join_non() throws Exception {
assertThat(StringUtil.join()).isEmpty();;
public void join_singleLine() throws Exception {
assertThat(StringUtil.join("line1")).hasLineCount(2);
public void join_twoLines() throws Exception {
assertThat(StringUtil.join("line1","line2")).hasLineCount(3);
public void join_hasPreceedingLinebreak() throws Exception {
assertThat(StringUtil.join("line1")).isEqualTo("\nline1");
public void removeFirstLine() throws Exception {
assertThat(StringUtil.removeFirstLine("line1\nline2")).isEqualTo("line2");
class Foo {        
private final String isNull = null;        
private final String notNull = "";        
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).contains("\n");
assertThat(printer.getActual().toString()).contains("\n");
assertThat(printer.getWanted().toString()).doesNotContain("\n");
assertThat(printer.getActual().toString()).doesNotContain("\n");
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
assertThat(invocation.isVerified()).isFalse();
NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String canThrowException() throws CharacterCodingException; 
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
assertEquals(0, returningDefaults.intReturningMethod()); 
assertEquals(0, noExtraConfig.intReturningMethod());        
class Tested {        
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
List<String> list;
assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
List<String> list = new LinkedList<String>();
assertThat(e.getMessage()).contains("Please ensure that the type")
.contains(NoValidConstructor.class.getSimpleName())
.contains("has a no-arg constructor");
assertThat(e.getMessage()).contains("Unable to create mock instance");
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
public void should_report_private_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivate());
fail();
assertThat(e).hasMessageContaining("Unable to initialize @Spy annotated field 'spy_field'")
.hasMessageContaining(WithInnerPrivate.InnerPrivate.class.getSimpleName());
public void should_report_private_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateAbstract.InnerPrivateAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
public void should_report_private_static_abstract_inner_not_supported() throws Exception {
try {
MockitoAnnotations.initMocks(new WithInnerPrivateStaticAbstract());
fail();
assertThat(e).hasMessageContaining("@Spy annotation can't initialize private abstract inner classes")
.hasMessageContaining(WithInnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining(WithInnerPrivateStaticAbstract.InnerPrivateStaticAbstract.class.getSimpleName())
.hasMessageContaining("You should augment the visibility of this inner class");
static class WithInnerPrivateStaticAbstract {
private InnerPrivateStaticAbstract spy_field;
private static abstract class InnerPrivateStaticAbstract {
static class WithInnerPrivateAbstract {
private InnerPrivateAbstract spy_field;
public void some_method() {
new InnerPrivateConcrete();
private abstract class InnerPrivateAbstract {
private class InnerPrivateConcrete extends InnerPrivateAbstract {
static class WithInnerPrivate {
private InnerPrivate spy_field;
private class InnerPrivate {
private class InnerPrivateSub extends InnerPrivate {}
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
.name("great mockie"));    
CustomAnswersMustImplementSerializableForSerializationToWork answer = 
foo.varArgs("");        
foo.varArgs((String[]) null);    
public class Foo {      
public void varArgs(String... args) {}       
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.spy;
public class ImplementationOfGenericAbstractMethodNotInvokedOnSpyTest {
public abstract class GenericAbstract<T> {
protected abstract String method_to_implement(T value);
public String public_method(T value) {
return method_to_implement(value);
public class ImplementsGenericMethodOfAbstract<T extends Number> extends GenericAbstract<T> {
protected String method_to_implement(T value) {
return "concrete value";
public void should_invoke_method_to_implement() {
GenericAbstract<Number> spy = spy(new ImplementsGenericMethodOfAbstract<Number>());
assertThat(spy.public_method(73L)).isEqualTo("concrete value");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;
assertThat(e.getCause()).hasMessageContaining("Unable to find a matching 1-arg constructor for the outer instance.");
public void handles_bridge_methods_correctly() {
SomeConcreteClass<Integer> testBug = spy(new SomeConcreteClass<Integer>());
assertEquals("value", testBug.getValue(0));
public abstract class SomeAbstractClass<T> {
protected abstract String getRealValue(T value);
public String getValue(T value) {
return getRealValue(value);
public class SomeConcreteClass<T extends Number> extends SomeAbstractClass<T> {
protected String getRealValue(T value) {
return "value";
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree)); 
when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo)); 
throw new RuntimeException("Silent rule should not write anything to the logger");        
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockitoutil.ConcurrentTesting;
ConcurrentTesting.inThread(new Runnable() {
ConcurrentTesting.inThread(new Runnable() {
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);        
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
mock(Integer.TYPE); 
package org.mockitousage.session;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
public class MockitoSessionTest {
private JUnitCore junit = new JUnitCore();
Result result = junit.run(MockitoSessionTest.SessionWithoutAnyConfiguration.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutInitMocksConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithoutStrictnessConfigured.class);
JUnitResultAssert.assertThat(result).succeeds(1);
Result result = junit.run(MockitoSessionTest.SessionWithIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
Result result = junit.run(MockitoSessionTest.SessionWithTestFailureAndIncorrectMockitoUsage.class);
JUnitResultAssert.assertThat(result)
.failsExactly(AssertionError.class, UnfinishedStubbingException.class);
public static class SessionWithoutAnyConfiguration {
MockitoSession mockito = Mockito.mockitoSession().startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutInitMocksConfigured {
MockitoSession mockito = Mockito.mockitoSession().strictness(Strictness.LENIENT).startMocking();
mockito.finishMocking();
assertNull(mock); //initMocks() was not used when configuring session
public static class SessionWithoutStrictnessConfigured {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
assertNotNull(mock);
public static class SessionWithIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
public static class SessionWithTestFailureAndIncorrectMockitoUsage {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).startMocking();
mockito.finishMocking();
when(mock.simpleMethod());
assertTrue(false);
verify(mock).oneArg(true); 
fail(); 
IMethods methods = unstubbedMethodInvokedHere(mock); 
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.StateMaster;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedMockingSessionException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.ConcurrentTesting.concurrently;
import static org.mockitoutil.JUnitResultAssert.assertThat;
public class StrictStubbingEndToEndTest {
JUnitCore junit = new JUnitCore();
new StateMaster().clearMockitoListeners();
Result result = junit.run(UnnecessaryStubbing.class);
assertThat(result)
.fails("unnecessary_stubbing", IllegalStateException.class)
.fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
assertThat(result).fails(1, PotentialStubbingProblem.class);
Result result = junit.run(LenientStrictness1.class, StrictStubsPassing.class, LenientStrictness2.class);
assertThat(result).succeeds(5);
Result result = junit.run(UnfinishedMocking.class);
assertThat(result)
.fails(UnfinishedMockingSessionException.class, "\n" +
"Unfinished mocking session detected.\n" +
"Previous MockitoSession was not concluded with 'finishMocking()'.\n" +
"For examples of correct usage see javadoc for MockitoSession class.");
final Map<Class, Result> results = new ConcurrentHashMap<Class, Result>();
concurrently(new Runnable() {
public void run() {
results.put(StrictStubsPassing.class, junit.run(StrictStubsPassing.class));
public void run() {
results.put(ReportMismatchButNotUnusedStubbing.class, junit.run(ReportMismatchButNotUnusedStubbing.class));
);
assertThat(results.get(StrictStubsPassing.class)).succeeds(1);
assertThat(results.get(ReportMismatchButNotUnusedStubbing.class)).fails(1);
public static class UnnecessaryStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod("1")).willReturn("one");
throw new IllegalStateException();
public static class ReportMismatchButNotUnusedStubbing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(2);
public static class StrictStubsPassing {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
given(mock.simpleMethod(1)).willReturn("");
mock.simpleMethod(1);
public static class LenientStrictness1 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class LenientStrictness2 {
given(mock.simpleMethod(1)).willReturn("");
given(mock.simpleMethod(2)).willReturn("");
mock.simpleMethod(3);
public static class UnfinishedMocking {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
given(mock.simpleMethod("1")).willReturn("one");
given(mock.simpleMethod("1")).willReturn("one");
package org.mockitousage.stubbing;
import org.junit.After;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoSession;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockitoutil.ThrowableAssert.assertThat;
public class StrictStubbingTest {
MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
mockito.finishMocking();
mockito.finishMocking();
mock.simpleMethod(100);
mock.otherMethod();
mock.simpleMethod(100);
mock.otherMethod();
verify(mock).simpleMethod(100);
verify(mock).otherMethod();
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- implicitly verified
mock.simpleMethod(200); // <- unverified
assertThat(new Runnable() {
public void run() {
verifyNoMoreInteractions(mock);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mock.simpleMethod(200);
given(mock.simpleMethod(100)).willReturn("100");
assertThat(new Runnable() {
public void run() {
mockito.finishMocking();
package org.mockitousage.stubbing;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoSession;
import org.mockito.internal.framework.DefaultMockitoSession;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.quality.Strictness;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.mockito.BDDMockito.given;
import static org.mockitoutil.TestBase.filterLineNo;
public class StubbingWarningsTest {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
MockitoSession mockito = new DefaultMockitoSession(this, Strictness.WARN, logger);
mock.simpleMethod(100);
mock.otherMethod();
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100);
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(100); // <- stubbing is used
mock.simpleMethod(200); // <- other method should not generate arg mismatch
mockito.finishMocking();
logger.assertEmpty();
given(mock.simpleMethod(100)).willReturn("100");
mock.simpleMethod(200);
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.stubbing_argument_mismatch(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
given(mock.simpleMethod(100)).willReturn("100");
mockito.finishMocking();
assertEquals(filterLineNo(
"[MockitoHint] StubbingWarningsTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.stubbing.StubbingWarningsTest.unused_stubbing(StubbingWarningsTest.java:0)\n"),
filterLineNo(logger.getLoggedInfo()));
verifyNoMoreInteractions(mock);        
String expected = 
"-> at "; 
String expectedCause = 
String expected = 
"-> at"; 
String expectedMessage = 
"iMethods.simpleMethod(999);"; 
String expectedMessage = 
"-> at"; 
String expectedMessage = 
String expectedCause = 
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        
inOrder.verifyNoMoreInteractions();        
if (declaredField.getType() == field.getType()) { // don't copy this
package org.mockitoutil;
import java.util.LinkedList;
import java.util.List;
public class ConcurrentTesting {
public static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
public static void concurrently(Runnable ... runnables) throws InterruptedException {
List<Thread> threads = new LinkedList<Thread>();
for (Runnable r : runnables) {
Thread t = new Thread(r);
t.start();
threads.add(t);
for (Thread t : threads) {
t.join();
import static org.junit.Assert.assertEquals;
import static org.mockito.internal.util.collections.Iterables.firstOf;
import static org.mockitoutil.TestBase.filterLineNo;
private JUnitResultAssert(Result result) {
throw new AssertionError(formatFailures(result.getFailures()));
fails(expectedFailureCount);
for (Failure f : result.getFailures()) {
if (!expectedException.isInstance(f.getException())) {
throw new AssertionError("Incorrect failure type, expected: " + expectedException + ", actual: " + f.getException().getClass().getSimpleName() + "\n" +
formatFailures(result.getFailures()));
return this;
public JUnitResultAssert fails(int expectedFailureCount) {
return this;
public JUnitResultAssert failsExactly(Class ... expectedExceptions) {
fails(expectedExceptions.length);
int i = 0;
if (!expectedExceptions[i].isInstance(f.getException())) {
throw new AssertionError("Actual failure #" + (i+1)
+ " should be of type: " + expectedExceptions[i].getSimpleName()
+ " but is of type: " + f.getException().getClass().getSimpleName()
+ "\n" + formatFailures(result.getFailures()));
i++;
public JUnitResultAssert fails(Class expectedException, String exceptionMessage) {
fails(1, expectedException);
Failure f = firstOf(result.getFailures());
assertEquals(filterLineNo(exceptionMessage), filterLineNo(f.getException().getMessage()));
return this;
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed." +
"\n" + formatFailures(result.getFailures()));
StringBuilder sb = new StringBuilder("There were " + failures.size() + " test failures:\n");
int count = 0;
sb.append("  <-----> ").append(++count).append(". ").append(f.getTrace()).append("\n");
return sb.toString();
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
import static org.mockito.internal.util.StringUtil.join;
import java.io.File;
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);
package org.mockitoinline;
import org.junit.Test;
import org.mockito.Mockito;
public class FinalClassMockingTest {
public void no_exception_while_mocking_final_class() throws Exception {
Mockito.mock(FinalClass.class);
private static final class FinalClass {
package org.mockitoinline;
import org.junit.Test;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
import static org.junit.Assert.*;
public class PluginTest {
public void plugin_type_should_be_inline() throws Exception {
assertTrue(Plugins.getMockMaker() instanceof InlineByteBuddyMockMaker);inThread(new Runnable() {
inThread(new Runnable() {
private static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
import org.mockitoutil.JUnitResultAssert;
Result result = junit.run(ArgumentMismatch.class);
JUnitResultAssert.assertThat(result)
.fails("stubbing_argument_mismatch", IllegalStateException.class)
.fails("stubbing_argument_mismatch", UnnecessaryStubbingException.class);
JUnitResultAssert.assertThat(result).fails(1, PotentialStubbingProblem.class);
JUnitResultAssert.assertThat(result).succeeds(5);
JUnitResultAssert.assertThat(result)
public static class ArgumentMismatch {
System.out.println("working");
System.out.println("SomeDemo");mocking.finishMocking();
mocking.finishMocking();
mocking.finishMocking();
mocking.finishMocking();return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()
.spiedInstance(instance)
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName())));
field.set(testInstance, newSpyInstance(testInstance, field));
type = testInstance != null? testInstance.getClass() : type;
private static Object newSpyInstance(Object testInstance, Field field)
MockSettings settings = withSettings()
.defaultAnswer(Mockito.CALLS_REAL_METHODS)
.name(field.getName());
if (!Modifier.isStatic(type.getModifiers())) {
if (enclosing != null) {
if (!enclosing.isInstance(testInstance)) {
throw new MockitoException("@Spy annotation can only initialize inner classes declared in the test. "
+ "Inner class: '" + type.getSimpleName() + "', "
+ "outer class: '" + enclosing.getSimpleName() + "'.");
return Mockito.mock(type, settings
.useConstructor()
.outerInstance(testInstance));
throw new MockitoException("Please ensure that the type '" + type.getSimpleName() + "' has 0-arg constructor.");
if (Modifier.isPrivate(constructor.getModifiers())) {
constructor.setAccessible(true);
return Mockito.mock(type, settings
.spiedInstance(constructor.newInstance()));
return Mockito.mock(type, settings.useConstructor());
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation, Field field, Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());
private final Object BOOTSTRAP_LOCK = new Object();
ClassLoader classLoader = params.mockedType.getClassLoader();
return (Class<T>) typeCache.findOrInsert(classLoader,
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
import static org.mockito.internal.util.StringJoiner.join;
throw paramsException(cls, null);
private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {
return new InstantiationException(join(
"Unable to create instance of '" + cls.getSimpleName() + "'.",
"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.")
, e);
t);
import org.assertj.core.api.Assertions;
import java.util.*;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");
Assertions.assertThat(e.getMessage()).contains("0-arg constructor");
Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");
class WithMockAndSpy {
public void should_report_when_encosing_instance_is_needed() throws Exception {
class Inner {}
static class NestedClassWithoutDefinedConstructor { }
static class NestedClassWithNoArgConstructor {
NestedClassWithNoArgConstructor() { }
NestedClassWithNoArgConstructor(String f) { }
NoValidConstructor(String f) { }
ThrowingConstructor() { throw new RuntimeException("boo!"); }
import java.util.List;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.*;
assertThat(e.getCause()).hasMessageContaining("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.");private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
MockitoFramework addListener(MockitoListener listener);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.invocation.Invocation;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
import java.util.regex.Pattern;
import static org.assertj.core.api.Assertions.assertThat;
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
StringBuilder out = new StringBuilder("Failures:");
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy(target);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
return mock(classToMock, withSettings());
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
import static org.mockito.Mockito.CALLS_REAL_METHODS;
field.set(testInstance, Mockito.mock(instance.getClass(),
withSettings().spiedInstance(instance)
.defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName())));
type = testInstance != null ? testInstance.getClass() : type;
MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)
.name(field.getName());
+ "Inner class: '" + type.getSimpleName() + "', "
+ "outer class: '" + enclosing.getSimpleName() + "'.");
return Mockito.mock(type, settings.useConstructor()
.outerInstance(testInstance));
return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));
private void assertNoIncompatibleAnnotations(Class<? extends Annotation> annotation,
Field field,
Class<? extends Annotation>... undesiredAnnotations) {
throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),
annotation.getClass().getSimpleName());
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import org.mockito.exceptions.misusing.*;
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotNull;
import static junit.framework.TestCase.assertTrue;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
final List<String> spiedList = new ArrayList<String>();
InnerStaticClassWithNoArgConstructor staticTypeWithNoArgConstructor;
InnerStaticClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;
public final ExpectedException shouldThrow = ExpectedException.none();
List<String> list;
List<String> list = new LinkedList<String>();
AbstractList<String> list;
class WithMockAndSpy {
private InnerStrength strength;
private List<String> list;
public void should_report_when_enclosing_instance_is_needed() throws Exception {
class Inner {
private Outer.Inner inner;
static class InnerStaticClassWithoutDefinedConstructor {
static class InnerStaticClassWithNoArgConstructor {
InnerStaticClassWithNoArgConstructor() {
InnerStaticClassWithNoArgConstructor(String f) {
NoValidConstructor(String f) {
ThrowingConstructor() {
throw new RuntimeException("boo!");
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this
private JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed.");
StringBuilder out = new StringBuilder("Failures:\n");
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
return mock(classToMock, withSettings());
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import org.mockito.exceptions.misusing.*;
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this
private JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed.");
StringBuilder out = new StringBuilder("Failures:\n");
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
MockitoFramework addListener(MockitoListener listener);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.invocation.Invocation;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
import java.util.regex.Pattern;
import static org.assertj.core.api.Assertions.assertThat;
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
StringBuilder out = new StringBuilder("Failures:");
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy(target);return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
return mock(classToMock, withSettings());
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import org.mockito.exceptions.misusing.*;
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
if (t == null) {
throw throwable;
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;
public class NPEWhenCustomExceptionStackTraceReturnNullTest extends TestBase {
IMethods mock;
class NullStackTraceException extends RuntimeException {
public Exception fillInStackTrace() {
return null;
public void shouldNotThrowNPE() {
when(mock.simpleMethod()).thenThrow(new NullStackTraceException());
try {
mock.simpleMethod();
fail();
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this
private JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed.");
StringBuilder out = new StringBuilder("Failures:\n");
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
return new AndroidClassLoadingStrategy.Injecting(target);private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)MockitoFramework addListener(MockitoListener listener);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.invocation.Invocation;
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
import java.util.regex.Pattern;
import static org.assertj.core.api.Assertions.assertThat;
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
StringBuilder out = new StringBuilder("Failures:");
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import org.mockito.exceptions.misusing.*;
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this
private JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed.");
StringBuilder out = new StringBuilder("Failures:\n");
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {MockitoFramework addListener(MockitoListener listener);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodInterceptor.ForEquals.class).build(),
public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
ClassLoadingStrategy getStrategy(Class<?> mockedType);
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Collections;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
private final boolean weak;
this.weak = weak;
public <T> Class<T> mockClass(MockFeatures<T> params) {
cleanUpCachesForObsoleteClassLoaders();
return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
void cleanUpCachesForObsoleteClassLoaders() {
Reference<?> reference;
while ((reference = poll()) != null) {
avoidingClassLeakageCache.remove(reference);
private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
classLoader = classLoader == null ? BOOT_LOADER : classLoader;
CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
if (generator == null) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
if (generator == null) {
generator = newGenerator;
return generator;
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
private BytecodeGenerator bytecodeGenerator;
private final boolean weak;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
this.weak = weak;
private Class<?> getMockClass(MockKey<?> mockKey) {
Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
if (classReference != null) {
return classReference.get();
return null;
Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
Class<?> generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
synchronized (features.mockedType) {
generatedMockClass = getMockClass(mockKey);
if (generatedMockClass == null) {
generatedMockClass = bytecodeGenerator.mockClass(features);
generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
return generatedMockClass;
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types;
private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
this.mockedType = mockedType.getName();
if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
types = Collections.emptySet();
types = new HashSet<String>();
for (Class<?> anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
return new MockKey<T>(mockedType, interfaces);
private interface Key {
ClassLoader get();
private static class LookupKey implements Key {
private final ClassLoader value;
private final int hashCode;
public LookupKey(ClassLoader value) {
this.value = value;
hashCode = System.identityHashCode(value);
public ClassLoader get() {
return value;
public boolean equals(Object object) {
if (this == object) return true;
if (!(object instanceof Key)) return false;
return value == ((Key) object).get();
public int hashCode() {
return hashCode;
private static class WeakKey extends WeakReference<ClassLoader> implements Key {
private final int hashCode;
public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
super(referent, q);
hashCode = System.identityHashCode(referent);
if (!(object instanceof Key)) return false;
return get() == ((Key) object).get();
return hashCode;
import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;
import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
stubbings.append("  ").append(count++).append(". ").append(s);
stubbings.append("\n    ").append(s.getLocation()).append("\n");
"Strict JUnit rule detected stubbing argument mismatch.",
"This invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"  " + actualInvocation,
"  " + actualInvocation.getLocation(),
"Has following stubbing(s) with different arguments:",
"In order to streamline debugging tests Mockito fails early in this scenario.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing",
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.invocation.Invocation;
assumeTrue(ClassFileVersion.ofThisVm().isLessThan(JAVA_V9)); // Change when ByteBuddy has ASM6 - see #862
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
import java.util.regex.Pattern;
import static org.assertj.core.api.Assertions.assertThat;
String[] message = filterLineNo(logger.getLoggedInfo()).split("\n");
assertThat(message[0]).isEqualTo("[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):");
assertThat(message[1]).matches("\\[MockitoHint\\] 1\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
assertThat(message[2]).matches("\\[MockitoHint\\] 2\\. Unused \\-\\> at [\\w\\.]+\\.reflect\\.NativeMethodAccessorImpl\\.invoke0\\(.*Native Method\\)");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class).actualTypeArguments().keySet();
assertThat(genericsNestKeySet.size()).isEqualTo(1);
assertThat(genericsNestKeySet.iterator().next().getName()).isEqualTo("K");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("N");
Set<TypeVariable<?>> mapKeySet = inferFrom(Map.class).actualTypeArguments().keySet();
assertThat(mapKeySet.size()).isEqualTo(2);
Iterator<TypeVariable<?>> iterator = mapKeySet.iterator();
assertThat(iterator.next().getName()).isEqualTo("K");
assertThat(iterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> genericsNestKeySet = inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(genericsNestKeySet .size()).isEqualTo(2);
Iterator<TypeVariable<?>> genericsNestKeySetIterator = genericsNestKeySet .iterator();
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("K");
assertThat(genericsNestKeySetIterator.next().getName()).isEqualTo("V");
Set<TypeVariable<?>> listOfAnyNumbersKeySet = inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(listOfAnyNumbersKeySet.size()).isEqualTo(1);
assertThat(listOfAnyNumbersKeySet.iterator().next().getName()).isEqualTo("E");
Set<TypeVariable<?>> integerKeySet = inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet();
assertThat(integerKeySet.size()).isEqualTo(1);
assertThat(integerKeySet.iterator().next().getName()).isEqualTo("T");
super(new StrictRunner(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.junit.Ignore;
RememberingListener listener2 = new RememberingListener();
MockitoFramework mockitoFramework = Mockito.framework();
mockitoFramework.addListener(listener1);
mockitoFramework.addListener(listener2);
"Strict JUnit rule detected stubbing argument mismatch.\n" +
"This invocation of 'simpleMethod' method:\n" +
"  mock.simpleMethod(15);\n" +
"  -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Has following stubbing(s) with different arguments:\n" +
"  1. mock.simpleMethod(20);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"  2. mock.simpleMethod(30);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"In order to streamline debugging tests Mockito fails early in this scenario.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this$0
JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passing test methods but there were " + i + " passing methods.");
StringBuilder out = new StringBuilder("Failures:");
public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {return (Answer<T>) new ReturnsArgumentAt(0);
return (Answer<T>) new ReturnsArgumentAt(1);
return (Answer<T>) new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT);
import org.mockito.exceptions.misusing.RedundantListenerException;
MockitoFramework addListener(MockitoListener listener) throws RedundantListenerException;
package org.mockito.exceptions.misusing;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.listeners.MockitoListener;
public class RedundantListenerException extends MockitoException {
public RedundantListenerException(String message) {
super(message);
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
.withBinders(of(MockMethodAdvice.Identifier.class, identifier))
.to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
FieldList<FieldDescription.InDefinedShape> fields,
MethodList<?> methods,
MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
import net.bytebuddy.TypeCache;
import org.mockito.mock.SerializableMode;
import java.util.concurrent.Callable;
private final TypeCache<SerializationFeatureKey> typeCache;
typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
public <T> Class<T> mockClass(final MockFeatures<T> params) {
try {
return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
new Callable<Class<?>>() {
public Class<?> call() throws Exception {
return bytecodeGenerator.mockClass(params);
Throwable cause = exception.getCause();
if (cause instanceof RuntimeException) {
throw (RuntimeException) cause;
throw exception;
private static class SerializationFeatureKey extends TypeCache.SimpleKey {
private final SerializableMode serializableMode;
private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
super(type, additionalType);
this.serializableMode = serializableMode;
if (object == null || getClass() != object.getClass()) return false;
if (!super.equals(object)) return false;
SerializationFeatureKey that = (SerializationFeatureKey) object;
return serializableMode.equals(that.serializableMode);
int result = super.hashCode();
result = 31 * result + serializableMode.hashCode();
return result;
import org.mockito.exceptions.misusing.*;
stubbings.append("    ").append(count++).append(". ").append(s);
stubbings.append("\n      ").append(s.getLocation()).append("\n");
"Strict stubbing argument mismatch. Please check:",
" - this invocation of '" + actualInvocation.getMethod().getName() + "' method:",
"    " + actualInvocation,
"    " + actualInvocation.getLocation(),
" - has following stubbing(s) with different arguments:",
"Mockito fails early so that you can debug potential problem easily.",
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.",
public static void redundantMockitoListener(String listenerType) {
throw new RedundantListenerException(join(
"Problems adding Mockito listener.",
"Listener of type '" + listenerType + "' has already been added and not removed.",
"It indicates that previous listener was not removed according to the API.",
"When you add a listener, don't forget to remove the listener afterwards:",
"  Mockito.framework().removeListener(myListener);",
"For more information, see the javadoc for RedundantListenerException class."));
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.MockCreationSettings;
import org.mockito.quality.Strictness;
public class StrictStubsRunnerTestListener implements MockitoTestListener {
private final DefaultStubbingLookupListener stubbingLookupListener = new DefaultStubbingLookupListener(Strictness.STRICT_STUBS);
public void testFinished(TestFinishedEvent event) {}
public void onMockCreated(Object mock, MockCreationSettings settings) {
((CreationSettings) settings).getStubbingLookupListeners().add(stubbingLookupListener);
import org.mockito.internal.exceptions.Reporter;
for (MockitoListener existing : listeners) {
if (existing.getClass().equals(listener.getClass())) {
Reporter.redundantMockitoListener(listener.getClass().getSimpleName());
import org.mockito.internal.junit.StrictStubsRunnerTestListener;
public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
return create(klass, new Supplier<MockitoTestListener>() {
public MockitoTestListener get() {
return new StrictStubsRunnerTestListener();
import java.lang.reflect.Method;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
if (wantedArgumentPosition != LAST_ARGUMENT && wantedArgumentPosition < 0) {
throw Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime();
this.wantedArgumentPosition = wantedArgumentPosition;
public Object answer(InvocationOnMock invocation) throws Throwable {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return ((Invocation) invocation).getRawArguments()[argumentPosition];
return invocation.getArgument(argumentPosition);
public void validateFor(InvocationOnMock invocation) {
int argumentPosition = inferWantedArgumentPosition(invocation);
validateIndexWithinInvocationRange(invocation, argumentPosition);
validateArgumentTypeCompatibility(invocation, argumentPosition);
private int inferWantedArgumentPosition(InvocationOnMock invocation) {
return wantedArgumentPosition == LAST_ARGUMENT ?
invocation.getArguments().length - 1 :
wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation, int argumentPosition) {
if (!wantedArgumentPositionIsValidForInvocation(invocation, argumentPosition)) {
throw Reporter.invalidArgumentPositionRangeAtInvocationTime(invocation,
wantedArgumentPosition == LAST_ARGUMENT,
wantedArgumentPosition);
private void validateArgumentTypeCompatibility(InvocationOnMock invocation, int argumentPosition) {
InvocationInfo invocationInfo = new InvocationInfo(invocation);
Class<?> inferredArgumentType = inferWantedArgumentType(invocation, argumentPosition);
if (!invocationInfo.isValidReturnType(inferredArgumentType)) {
throw Reporter.wrongTypeOfArgumentToReturn(invocation,
invocationInfo.printMethodReturnType(),
inferredArgumentType,
wantedArgumentPosition);
private boolean wantedArgIndexIsVarargAndSameTypeAsReturnType(Method method, int argumentPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
return method.isVarArgs()
&& argumentPosition == /* vararg index */ parameterTypes.length - 1
&& method.getReturnType().isAssignableFrom(parameterTypes[argumentPosition]);
private boolean wantedArgumentPositionIsValidForInvocation(InvocationOnMock invocation, int argumentPosition) {
if (argumentPosition < 0) {
return invocation.getArguments().length > argumentPosition;
private Class<?> inferWantedArgumentType(InvocationOnMock invocation, int argumentPosition) {
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
if (!invocation.getMethod().isVarArgs()) {
return parameterTypes[argumentPosition];
int varargIndex = parameterTypes.length - 1; // vararg always last
if (argumentPosition < varargIndex) {
return parameterTypes[argumentPosition];
if (wantedArgIndexIsVarargAndSameTypeAsReturnType(invocation.getMethod(), argumentPosition)) {
return parameterTypes[argumentPosition]; // move to MethodInfo ?
return parameterTypes[varargIndex].getComponentType();
public static class StrictStubs extends MockitoJUnitRunner {
public StrictStubs(Class<?> klass) throws InvocationTargetException {
super(new StrictRunner(new RunnerFactory().createStrictStubs(klass), klass));
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
other_mock_type = is_no_more_referenced();
assertThat(referenceQueue.poll()).isEqualTo(typeReference);
public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.NONE
));
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class<?>>emptySet(),
SerializableMode.BASIC
));
assertThat(other_mock_type).isNotSameAs(the_mock_type);
import org.mockito.exceptions.misusing.RedundantListenerException;
import static org.mockitoutil.ThrowableAssert.assertThat;
framework.addListener(new MyListener());
assertThat(new Runnable() {
public void run() {
framework.addListener(new MyListener());
.throwsMessage("\n" +
"Problems adding Mockito listener.\n" +
"Listener of type 'MyListener' has already been added and not removed.\n" +
"It indicates that previous listener was not removed according to the API.\n" +
"When you add a listener, don't forget to remove the listener afterwards:\n" +
"  Mockito.framework().removeListener(myListener);\n" +
"For more information, see the javadoc for RedundantListenerException class.");
private static class MyListener implements MockitoListener {}
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
import org.assertj.core.api.Assertions;
import org.mockito.invocation.Invocation;
public void should_identify_bad_parameter_type_for_invocation() throws Exception {
try {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
.args(new Object(), new Object(), new Object())
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("oneArray")
.argTypes(boolean[].class)
.args(true, false, false)
.toInvocation());
Assertions.fail("should scream");
try {
new ReturnsArgumentAt(0).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
Assertions.fail("should scream");
public void should_not_scream_when_mixed_vararg_parameter_is_compatible_with_invocation() throws Exception {
new ReturnsArgumentAt(1).validateFor(new InvocationBuilder().method("mixedVarargsReturningString")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation());
public void should_handle_returning_vararg_as_array() throws Throwable {
Invocation mixedVarargsReturningStringArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningStringArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningStringArray)).isEqualTo(new String[]{"A", "B", "C"});
Invocation mixedVarargsReturningObjectArray = new InvocationBuilder().method("mixedVarargsReturningStringArray")
.argTypes(Object.class, String[].class)
.args(new Object(), new String[]{"A", "B", "C"})
.toInvocation();
new ReturnsArgumentAt(1).validateFor(mixedVarargsReturningObjectArray);
assertThat(new ReturnsArgumentAt(1).answer(mixedVarargsReturningObjectArray)).isEqualTo(new String[]{"A", "B", "C"});
assertThat(e.getMessage()).containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt")
.argTypes(int.class)
.arg(1000)
.toInvocation()
new InvocationBuilder().method("toString")
.argTypes(String.class)
.arg("whatever")
.toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg")
.arg("A")
.toInvocation());
return new InvocationBuilder().method("varargsReturningString")
.argTypes(Object[].class)
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
super(new StrictRunner(new RunnerFactory().create(klass, new Supplier<MockitoTestListener>() {
String mixedVarargsReturningString(Object i, String ... string);
String[] mixedVarargsReturningStringArray(Object i, String ... string);
Object[] mixedVarargsReturningObjectArray(Object i, String ... string);
public String mixedVarargsReturningString(Object i, String... string) {
return null;
public String[] mixedVarargsReturningStringArray(Object i, String... string) {
return null;
public Object[] mixedVarargsReturningObjectArray(Object i, String... string) {
return null;
import org.junit.Before;
import java.util.AbstractCollection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
MockitoAnnotations.initMocks(this);
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
RememberingListener2 listener2 = new RememberingListener2();
Mockito.framework().addListener(listener1).addListener(listener2);
private static class RememberingListener2 extends RememberingListener {
"Strict stubbing argument mismatch. Please check:\n" +
" - this invocation of 'simpleMethod' method:\n" +
"    mock.simpleMethod(15);\n" +
"    -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
" - has following stubbing(s) with different arguments:\n" +
"    1. mock.simpleMethod(20);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"    2. mock.simpleMethod(30);\n" +
"      -> at org.mockitousage.junitrule.StrictJUnitRuleTest.fails_fast_when_stubbing_invoked_with_different_argument(StrictJUnitRuleTest.java:0)\n" +
"Typically, stubbing argument mismatch indicates user mistake when writing tests.\n" +
"Mockito fails early so that you can debug potential problem easily.\n" +
"However, there are legit scenarios when this exception generates false negative signal:\n" +
"  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API\n" +
"    Please use 'will().given()' or 'doReturn().when()' API for stubbing.\n" +
"  - stubbed method is intentionally invoked with different arguments by code under test\n" +
"    Please use 'default' or 'silent' JUnit Rule.\n" +
"For more information see javadoc for PotentialStubbingProblem class."),
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import org.mockitoutil.JUnitResultAssert;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class StrictStubsRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(UnnecessaryStubbing.class);
JUnitResultAssert.assertThat(result)
.fails(1, UnnecessaryStubbingException.class)
.succeeds(2);
Result result = runner.run(StubbingArgMismatch.class);
JUnitResultAssert.assertThat(result)
.succeeds(2)
.fails(1, PotentialStubbingProblem.class);
public static class UnnecessaryStubbing {
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
public static class StubbingArgMismatch {
when(mock.simpleMethod()).thenReturn("");
mock.simpleMethod();
when(mock.simpleMethod(10)).thenReturn("");
mock.simpleMethod(20);
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {
if (declaredField.getType() == field.getType()) { // don't copy this
private JUnitResultAssert(Result result) {
throw new AssertionError("Expected " + successCount + " passes but " + i + "/" + result.getRunCount() + " passed.");
StringBuilder out = new StringBuilder("Failures:\n");
package org.mockitoutil;
import static org.junit.Assert.assertEquals;
public class ThrowableAssert {
private Throwable reportedException;
private ThrowableAssert(Runnable runnable) {
try {
runnable.run();
this.reportedException = t;
return;
throw new AssertionError("Expected runnable to throw an exception but it didn't");
public ThrowableAssert throwsException(Class<? extends Throwable> exceptionType) {
if(!exceptionType.isInstance(reportedException)) {
throw new AssertionError("Exception should be of type: "
+ exceptionType.getSimpleName() + " but it was: "
+ reportedException.getClass().getSimpleName());
return this;
public ThrowableAssert throwsMessage(String exceptionMessage) {
assertEquals(exceptionMessage, reportedException.getMessage());
return this;
public static ThrowableAssert assertThat(Runnable runnable) {
return new ThrowableAssert(runnable);
public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);
private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);
private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);
return (Answer<T>) RETURNS_FIRST_ARGUMENT;
return (Answer<T>) RETURNS_SECOND_ARGUMENT;
return (Answer<T>) RETURNS_LAST_ARGUMENT;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime;
import static org.mockito.internal.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime;
import static org.mockito.internal.exceptions.Reporter.wrongTypeOfArgumentToReturn;
this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);
validateIndexWithinInvocationRange(invocation);
return invocation.getArgument(actualArgumentPosition(invocation));
validateIndexWithinInvocationRange(invocation);
InvocationInfo invocationInfo = new InvocationInfo(invocation);
if (!invocationInfo.isValidReturnType(returnedTypeOnSignature(invocation))) {
throw wrongTypeOfArgumentToReturn(invocation, invocationInfo.printMethodReturnType(),
returnedTypeOnSignature(invocation),
wantedArgumentPosition());
private int actualArgumentPosition(InvocationOnMock invocation) {
return returningLastArg() ?
lastArgumentIndexOf(invocation) :
argumentIndexOf(invocation);
private boolean returningLastArg() {
return wantedArgumentPosition == LAST_ARGUMENT;
private int argumentIndexOf(InvocationOnMock invocation) {
return wantedArgumentPosition;
private int lastArgumentIndexOf(InvocationOnMock invocation) {
return invocation.getArguments().length - 1;
private int checkWithinAllowedRange(int argumentPosition) {
if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {
throw invalidArgumentRangeAtIdentityAnswerCreationTime();
return argumentPosition;
private int wantedArgumentPosition() {
return wantedArgumentPosition;
private void validateIndexWithinInvocationRange(InvocationOnMock invocation) {
if (!argumentPositionInRange(invocation)) {
throw invalidArgumentPositionRangeAtInvocationTime(invocation,
returningLastArg(),
wantedArgumentPosition);
private boolean argumentPositionInRange(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if (actualArgumentPosition < 0) {
return invocation.getArguments().length > actualArgumentPosition;
private Class<?> returnedTypeOnSignature(InvocationOnMock invocation) {
int actualArgumentPosition = actualArgumentPosition(invocation);
if(!invocation.getMethod().isVarArgs()) {
return invocation.getMethod().getParameterTypes()[actualArgumentPosition];
Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();
int varargPosition = parameterTypes.length - 1;
if(actualArgumentPosition < varargPosition) {
return parameterTypes[actualArgumentPosition];
return parameterTypes[varargPosition].getComponentType();
assertThat(e.getMessage())
.containsIgnoringCase("argument index")
.containsIgnoringCase("positive number")
.contains("1")
.containsIgnoringCase("last argument");
new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()
new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()
new ReturnsArgumentAt(30).validateFor(new InvocationBuilder().method("oneArg").arg("A").toInvocation());
return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).extracting("name").contains("T");
package org.mockitousage.bugs;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.junit.Test;
public class ConfusedSignatureTest {
public void should_mock_method_which_has_generic_return_type_in_superclass_and_concrete_one_in_interface() {
Sub mock = mock(Sub.class);
when(mock.getFoo()).thenReturn("Hello");
assertThat(mock.getFoo()).isEqualTo("Hello");
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {outputStream.putNextEntry(new JarEntry(source + ".class"));
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.regex.Pattern;public class VerificationListenerCallBackTest {public RunnerImpl create(Class<?> klass) throws InvocationTargetException {
public RunnerImpl createStrict(Class<?> klass) throws InvocationTargetException {
public RunnerImpl create(Class<?> klass, Supplier<MockitoTestListener> listenerSupplier) throws InvocationTargetException {
public interface RunnerImpl extends Filterable {
public class SilentJUnitRunner implements RunnerImpl {
public class StrictRunner implements RunnerImpl {
private final RunnerImpl runner;
public StrictRunner(RunnerImpl runner, Class<?> testClass) {
import org.mockito.internal.runners.RunnerImpl;
public RunnerImpl newInstance(String runnerClassName, Object ... constructorArgs) throws Exception {
return (RunnerImpl) constructor.newInstance(constructorArgs);
import org.mockito.internal.runners.RunnerImpl;
private final RunnerImpl runner;
MockitoJUnitRunner(RunnerImpl runner) throws InvocationTargetException {
import org.mockito.internal.runners.RunnerImpl;
private final RunnerImpl runner;
ConsoleSpammingMockitoJUnitRunner(MockitoLogger logger, RunnerImpl runnerImpl) {
this.runner = runnerImpl;
import org.mockito.internal.runners.RunnerImpl;
private final RunnerImpl runner;
VerboseMockitoJUnitRunner(RunnerImpl runnerImpl) {
this.runner = runnerImpl;
import org.mockito.internal.runners.RunnerImpl;
RunnerImpl runner = provider.newInstance("org.mockito.internal.runners.SilentJUnitRunner", this.getClass(), null);
import org.mockito.internal.runners.RunnerImpl;
runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {
static class RunnerImplStub implements RunnerImpl {import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import static org.mockito.internal.util.Primitives.defaultValue;
import java.io.Serializable;
private final String regex;
this.regex = regex;
return (actual instanceof String) && ((String) actual).matches(regex);
return "matches(\"" + regex.replaceAll("\\\\", "\\\\\\\\") + "\")";
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNotSame;
import static junit.framework.TestCase.fail;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.RandomAccess;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;import java.lang.reflect.Method;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.*;import java.util.Iterator;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
removeAlreadyVerified(actualInvocations);
private static void removeAlreadyVerified(List<Invocation> invocations) {
for (Iterator<Invocation> iterator = invocations.iterator(); iterator.hasNext(); ) {
Invocation i = iterator.next();
if (i.isVerified()) {
iterator.remove();
import java.util.Iterator;
import java.util.List;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.reporting.Discrepancy;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;
removeAlreadyVerified(actualInvocations);
private void removeAlreadyVerified(List<Invocation> invocations) {
for (Iterator<Invocation> iterator = invocations.iterator(); iterator.hasNext(); ) {
Invocation i = iterator.next();
if (i.isVerified()) {
iterator.remove();import org.mockito.internal.listeners.StubbingLookUpListener;
protected final List<StubbingLookUpListener> stubbingLookUpListeners = new ArrayList<StubbingLookUpListener>();
public List<StubbingLookUpListener> getStubbingLookUpListeners() {
return stubbingLookUpListeners;
import org.mockito.internal.listeners.StubbingLookUpListener;
notifyStubbedAnswerLookUp(invocation, stubbedInvocation);
private void notifyStubbedAnswerLookUp(Invocation invocation, StubbedInvocationMatcher exception) {
for (StubbingLookUpListener listener : mockSettings.getStubbingLookUpListeners()) {
listener.onStubbingLookUp(invocation, exception);
import org.mockito.internal.listeners.StubbingLookUpListener;
settings.getStubbingLookUpListeners().add(new StubbingLookUpListener() {
public void onStubbingLookUp(Invocation invocation, MatchableInvocation stubbingFound) {
public interface StubbingLookUpListener {
void onStubbingLookUp(Invocation invocation, MatchableInvocation stubbingFound);
import org.mockito.internal.listeners.StubbingLookUpListener;
List<StubbingLookUpListener> getStubbingLookUpListeners();import org.assertj.core.api.Assertions;
import static org.junit.Assert.assertNull;
String message = rule.getReportedThrowable().getMessage();
Assertions.assertThat(message).startsWith("Unused stubbings");
Assertions.assertThat(rule.getReportedThrowable()).hasMessageStartingWith("Argument mismatch");
assertNull(rule.getReportedThrowable());
Assertions.assertThat(rule.getReportedThrowable()).hasMessageStartingWith("Unused stubbings");public Statement apply(final Statement base, FrameworkMethod method, Object target) {
base.evaluate();
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;
SafeJUnitRule rule = new SafeJUnitRule(mock(MethodRule.class));if (remainingAttempts > 0) {
throw throwable;try {
final Class<?> optionalClass = Class.forName("java.util.Optional");
final Method emptyMethod = optionalClass.getMethod("empty");
return emptyOptional = emptyMethod.invoke(null);
throw new InstantiationException("Could not create java.util.Optional#empty(): " + e, e);
final Class<?> optionalClass = Class.forName("java.util.stream.Stream");
final Method emptyMethod = optionalClass.getMethod("empty");
return emptyMethod.invoke(null);
throw new InstantiationException("Could not create java.util.stream.Stream#empty(): " + e, e);
public void should_return_empty_optional() throws Exception {
public void should_return_empty_stream() throws Exception {import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.after;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.junit.MockitoJUnit.rule;
import static org.mockitoutil.Stopwatch.createNotStarted;
import java.util.concurrent.ScheduledExecutorService;
import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.junit.MockitoJUnit.rule;
import java.util.concurrent.ScheduledExecutorService;
private ScheduledExecutorService executor;
private DelayedExecution delayedExecution;
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );package org.mockito.javadoc;
import com.sun.javadoc.*;
import com.sun.tools.doclets.formats.html.HtmlDoclet;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;
public class JavadocExclude {
public static int optionLength(String var0) {
return HtmlDoclet.optionLength(var0);
public static boolean start(RootDoc root) {
Class clz = root.getClass();
return HtmlDoclet.start((RootDoc) Proxy.newProxyInstance(clz.getClassLoader(), clz.getInterfaces(), new ExcludeHandler(root)));
public static boolean validOptions(String[][] var0, DocErrorReporter var1) {
return HtmlDoclet.validOptions(var0, var1);
public static LanguageVersion languageVersion() {
return HtmlDoclet.languageVersion();
private static class ExcludeHandler implements InvocationHandler {
private final RootDoc root;
private ExcludeHandler(RootDoc root) {
this.root = root;
public Object invoke(Object o, Method method, Object[] args) throws Throwable {
Object result = method.invoke(root, args);
if (result instanceof Object[]) {
List<ClassDoc> filteredDocs = new ArrayList<ClassDoc>();
Object[] array = (Object[]) result;
for (Object entry : array) {
if (entry instanceof ClassDoc) {
ClassDoc doc = (ClassDoc) entry;
if (!doc.containingPackage().name().startsWith("org.mockito.internal")) {
filteredDocs.add(doc);
if (filteredDocs.size() > 0) {
ClassDoc[] docArray = new ClassDoc[filteredDocs.size()];
return filteredDocs.toArray(docArray);
return result;
import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.verification.*;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import java.io.Serializable;
import java.lang.reflect.Array;
Class<?> componenetType = type.getComponentType();
return Array.newInstance(componenetType, 0);
import org.mockitoutil.RetryRule;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.after;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.junit.MockitoJUnit.rule;
import static org.mockitoutil.Stopwatch.createNotStarted;
public RetryRule retryRule = RetryRule.attempts(4);
import org.mockitoutil.RetryRule;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.junit.MockitoJUnit.rule;
public RetryRule retryRule = RetryRule.attempts(4);
delayedExecution.callAsync(30, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(30, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(10, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(10, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(10, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(10, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(30, MILLISECONDS, callMock('c'));
delayedExecution.callAsync(30, MILLISECONDS, callMock('c'));
package org.mockitoutil;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;
public class RetryRule implements TestRule {
private final TestRule innerRule;
public static RetryRule attempts(final int attempts) {
return new RetryRule(new NumberedAttempts(attempts));
private RetryRule(TestRule innerRule) {
this.innerRule = innerRule;
public Statement apply(final Statement base, final Description description) {
return innerRule.apply(base, description);
private static class NumberedAttempts implements TestRule {
private final int attempts;
NumberedAttempts(int attempts) {
assert attempts > 1;
this.attempts = attempts;
public Statement apply(final Statement base, final Description description) {
return new Statement() {
public void evaluate() throws Throwable {
for (int remainingAttempts = attempts; remainingAttempts > 0 ; remainingAttempts--) {
try {
base.evaluate();
if (remainingAttempts > 0) {
throw throwable;import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
return methodVisitor;
import java.io.Serializable;
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static junit.framework.TestCase.assertEquals;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.after;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.junit.MockitoJUnit.rule;
import static org.mockitoutil.Stopwatch.createNotStarted;
import java.util.concurrent.ScheduledExecutorService;
import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.junit.rules.ExpectedException.none;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.junit.MockitoJUnit.rule;
import java.util.concurrent.ScheduledExecutorService;
private ScheduledExecutorService executor;
private DelayedExecution delayedExecution;
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(10, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );
delayedExecution.callAsync(30, MILLISECONDS, callMock('c') );import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.Doc;
import com.sun.javadoc.DocErrorReporter;
import com.sun.javadoc.LanguageVersion;
import com.sun.javadoc.RootDoc;
import com.sun.tools.doclets.formats.html.HtmlDoclet;
import com.sun.tools.javadoc.Main;
public static void main(String[] args) {
String name = JavadocExclude.class.getName();
Main.execute(name, name, args);
return HtmlDoclet.start((RootDoc) Proxy.newProxyInstance(clz.getClassLoader(),
clz.getInterfaces(),
new ExcludeHandler(root)));
public static boolean validOptions(String[][] optionsAndValue, DocErrorReporter docErrorReporter) {
return HtmlDoclet.validOptions(optionsAndValue, docErrorReporter);
private static boolean exclude(Doc doc) {
if (doc instanceof ClassDoc) {
ClassDoc classDoc = (ClassDoc) doc;
if (classDoc.containingPackage().name().contains("org.mockito.internal")) {
return true;
return false;
private static Object process(Object obj, Class expect) {
if (obj == null)
return null;
Class cls = obj.getClass();
if (cls.getName().startsWith("com.sun.")) {
return Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), new ExcludeHandler(obj));
Class componentType = expect.getComponentType();
Object[] array = (Object[]) obj;
List list = new ArrayList(array.length);
for (int i = 0; i < array.length; i++) {
Object entry = array[i];
if ((entry instanceof Doc) && exclude((Doc) entry)) {
continue;
list.add(process(entry, componentType));
return list.toArray((Object[]) Array.newInstance(componentType != null ? componentType : Object.class,
list.size()));
return obj;
private final Object root;
private ExcludeHandler(Object root) {
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
if (args != null) {
String methodName = method.getName();
if (methodName.equals("compareTo")
|| methodName.equals("equals")
|| methodName.equals("overrides")
|| methodName.equals("subclassOf")) {
args[0] = unwrap(args[0]);
if (methodName.equals("inlineTags")) {
Object[] invoke = (Object[]) method.invoke(root, args);
if (invoke.length != 0) {
System.out.println(methodName);
System.out.println(Arrays.toString(invoke));
try {
return process(method.invoke(root, args),
method.getReturnType());
throw e.getTargetException();
private Object unwrap(Object proxy) {
if (proxy instanceof Proxy) {
return ((ExcludeHandler) Proxy.getInvocationHandler(proxy)).root;
return proxy;
import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;
return methodVisitor;
import java.io.Serializable;
import java.lang.reflect.Array;
Class<?> componentType = type.getComponentType();
return Array.newInstance(componentType, 0);import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;
import java.io.Serializable;
import java.lang.reflect.Array;
Class<?> componenetType = type.getComponentType();
return Array.newInstance(componenetType, 0);import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.verification.*;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;return byteBuddy.redefine(classBeingRedefined, new ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(loader),
ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer)))import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
package org.mockito.verification;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.MatchableInvocation;
import java.util.List;
public interface VerificationData extends org.mockito.internal.verification.api.VerificationData {
List<Invocation> getAllInvocations();
MatchableInvocation getTarget();
void verify(VerificationData data);
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;
import org.mockito.verification.VerificationData;if (!project.hasProperty("dryRun")) { //accommodate testing
rollback.onlyIf(new Spec<Task>() {
public boolean isSatisfiedBy(Task t) {
return task.getState().getFailure() == null;private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());
import org.assertj.core.api.ObjectAssert;
import org.mockito.Mockito;
import java.util.List;
verify(mock).varargs(Mockito.<Object>eq(null));
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Object>isNull());
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any()); // any() -> VarargMatcher
verify(mock).varargs(Mockito.<Integer>any(), Mockito.<Integer>any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, List<? extends T>, T, ObjectAssert<T>> assertThat(ArgumentCaptor<T> captor) {public class InvocationMatcher implements DescribedInvocation, CapturesArgumentsFromInvocation, Serializable {
public static List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {
public static List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {
public static List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {
private static List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {
public static Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){
public static Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {
private final InvocationMatcher wanted;
private RemoveNotMatching(InvocationMatcher wanted) {
public String print(InvocationMatcher invocationMatcher) {
public SmartPrinter(InvocationMatcher wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
InvocationMatcher wanted = data.getWanted();
InvocationMatcher wanted = data.getWanted();
InvocationMatcher wantedMatcher = data.getWanted();
InvocationMatcher wanted = data.getWanted();
InvocationMatcher wanted = data.getWanted();
InvocationMatcher getWanted();   
private final InvocationMatcher wanted;
public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, InvocationMatcher wanted) {
public InvocationMatcher getWanted() {
public static void checkAtLeastNumberOfInvocations(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {
public static void checkAtLeastNumberOfInvocations(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount,InOrderContext orderingContext) {
public static void checkMissingInvocation(List<Invocation> invocations, InvocationMatcher wanted) {
public static void checkMissingInvocation(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context) {
public static void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {
Invocation next = findFirstMatchingUnverifiedInvocation( invocations, wanted, context );
public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {
public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.invocation.Invocation;
InvocationMatcher getWanted();verify(mock).varargs(eq(null));
verify(mock).varargs(isNull());
verify(mock).varargs(isNull());
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any()); // any() -> VarargMatcher
verify(mock).varargs(any(), any()); // any() -> VarargMatcher
private static <T> AbstractListAssert<?, ?, T> assertThat(ArgumentCaptor<T> captor) {rollback(attempted); //TODO SF what if rollback fails?
throw new RuntimeException("Release failed at step " + attempted.size() + " (" + step.getDescription() + "). Rollback was performed.", t);public interface Answer1<T, A> {
T answer(A a);
public interface Answer2<T, A, B> {
T answer(A a, B b);
public interface Answer3<T, A, B, C> {
T answer(A a, B b, C c);
public interface Answer4<T, A, B, C, D> {
T answer(A a, B b, C c, D d);
public interface Answer5<T, A, B, C, D, E> {
T answer(A a, B b, C c, D d, E e);
public interface VoidAnswer1<A> {
void answer(A a);
public interface VoidAnswer2<A, B> {
void answer(A a, B b);
public interface VoidAnswer3<A, B, C> {
void answer(A a, B b, C c);
public interface VoidAnswer4<A, B, C, D> {
void answer(A a, B b, C c, D d);
public interface VoidAnswer5<A, B, C, D, E> {
void answer(A a, B b, C c, D d, E e);
assertThat(new InvocationsPrinter().printInvocations(mock)).isEqualTo("No interactions and stubbings found for mock: mock");
assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
.isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:0)\n"));
assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
.isEqualTo(filterLineNo("[Mockito] Unused stubbings of: mock\n" +
" 1. mock.simpleMethod(\"a\");\n" +
"  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:70)\n"));
assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
.isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n"));
assertThat(filterLineNo(new InvocationsPrinter().printInvocations(mock)))
.isEqualTo(filterLineNo("[Mockito] Interactions of: mock\n" +
" 1. mock.simpleMethod(\"b\");\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_unused_stubbings(InvocationsPrinterTest.java:55)\n" +
" 2. mock.otherMethod();\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n" +
"[Mockito] Unused stubbings of: mock\n" +
" 1. mock.simpleMethod(\"a\");\n" +
"  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:62)\n"));"Mockito can only non-private & non-final classes.",String printInvocations();
return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
package org.mockito.internal.debugging;
import org.mockito.Mockito;
import org.mockito.internal.util.collections.ListUtil;
import org.mockito.invocation.Invocation;
import org.mockito.stubbing.Stubbing;
import java.util.Collection;
import java.util.LinkedList;
public class InvocationsPrinter {
public String printInvocations(Object mock) {
Collection<Invocation> invocations = Mockito.mockingDetails(mock).getInvocations();
Collection<Stubbing> stubbings = Mockito.mockingDetails(mock).getStubbings();
if (invocations.isEmpty() && stubbings.isEmpty()) {
return "No interactions and stubbings found for mock: " + mock;
String out = "";
int x = 1;
for(Invocation i:invocations) {
if (x == 1) {
out += line("[Mockito] Interactions of: " + mock);
out += line(" " + x++ + ". " + i.toString());
out += line("  " + i.getLocation());
if (i.stubInfo() != null) {
out += line("   - stubbed " + i.stubInfo().stubbedAt());
LinkedList<Stubbing> unused = ListUtil.filter(stubbings, new ListUtil.Filter<Stubbing>() {
public boolean isOut(Stubbing s) {
return s.wasUsed();
if (unused.isEmpty()) {
return out;
out += line("[Mockito] Unused stubbings of: " + mock);
x = 1;
for(Stubbing s:stubbings) {
out += line(" " + x++ + ". " + s.getInvocation().toString());
out += line("  - stubbed " + s.getInvocation().getLocation());
return out;
private String line(String text) {
return text + "\n";
import org.mockito.internal.debugging.InvocationsPrinter;
public String printInvocations() {
assertGoodMock();
return new InvocationsPrinter().printInvocations(toInspect);
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;
public void prints_invocations() throws Exception {
given(mock.simpleMethod("different arg")).willReturn("foo");
mock.simpleMethod("arg");
String log = Mockito.mockingDetails(mock).printInvocations();
assertThat(log).containsIgnoringCase("unused");
assertThat(log).containsIgnoringCase("mock.simpleMethod(\"arg\")");
assertThat(log).containsIgnoringCase("mock.simpleMethod(\"different arg\")");
public void fails_when_printin_invocations_from_non_mock() {
try {
mockingDetails(new Object()).printInvocations();
fail();
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
package org.mockitousage.debugging;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.internal.debugging.InvocationsPrinter;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;
public class InvocationsPrinterTest extends TestBase {
Assert.assertEquals("No interactions and stubbings found for mock: mock", new InvocationsPrinter().printInvocations(mock));
mock.simpleMethod(100);
triggerInteraction();
assertEquals(filterLineNo("[Mockito] Interactions of: mock\n" +
" 1. mock.simpleMethod(100);\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations(InvocationsPrinterTest.java:0)\n" +
" 2. mock.otherMethod();\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:0)\n"),
filterLineNo(new InvocationsPrinter().printInvocations(mock)));
triggerStubbing();
assertEquals(filterLineNo("[Mockito] Unused stubbings of: mock\n" +
" 1. mock.simpleMethod(\"a\");\n" +
"  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:70)\n"),
filterLineNo(new InvocationsPrinter().printInvocations(mock)));
triggerStubbing();
mock.simpleMethod("a");
triggerInteraction();
assertEquals(filterLineNo("[Mockito] Interactions of: mock\n" +
" 1. mock.simpleMethod(\"a\");\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_stubbings(InvocationsPrinterTest.java:49)\n" +
"   - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:73)\n" +
" 2. mock.otherMethod();\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n"),
filterLineNo(new InvocationsPrinter().printInvocations(mock)));
triggerStubbing();
mock.simpleMethod("b");
triggerInteraction();
assertEquals(filterLineNo("[Mockito] Interactions of: mock\n" +
" 1. mock.simpleMethod(\"b\");\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.prints_invocations_and_unused_stubbings(InvocationsPrinterTest.java:55)\n" +
" 2. mock.otherMethod();\n" +
"  -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerInteraction(InvocationsPrinterTest.java:34)\n" +
"[Mockito] Unused stubbings of: mock\n" +
" 1. mock.simpleMethod(\"a\");\n" +
"  - stubbed -> at org.mockitousage.debugging.InvocationsPrinterTest.triggerStubbing(InvocationsPrinterTest.java:62)\n"),
filterLineNo(new InvocationsPrinter().printInvocations(mock)));
private void triggerInteraction() {
mock.otherMethod();
private void triggerStubbing() {
when(mock.simpleMethod("a")).thenReturn("x");import org.mockito.internal.debugging.MockitoDebuggerImpl;
return new MockitoDebuggerImpl().printInvocations(toInspect);import org.mockito.stubbing.Stubbing;
import org.mockito.quality.MockitoHint;
Collection<Stubbing> getStubbings();
package org.mockito.internal.invocation;
import org.mockito.invocation.Invocation;
import java.util.Comparator;
public class InvocationComparator implements Comparator<Invocation> {
public int compare(Invocation o1, Invocation o2) {
return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());
import org.mockito.internal.invocation.InvocationComparator;
import org.mockito.stubbing.Stubbing;
import org.mockito.internal.stubbing.StubbingComparator;
import org.mockito.internal.util.DefaultMockingDetails;
Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new InvocationComparator());
Collection<Invocation> fromSingleMock = new DefaultMockingDetails(mock).getInvocations();
public static Set<Stubbing> findStubbings(Iterable<?> mocks) {
Set<Stubbing> stubbings = new TreeSet<Stubbing>(new StubbingComparator());
Collection<? extends Stubbing> fromSingleMock = new DefaultMockingDetails(mock).getStubbings();
import org.mockito.stubbing.Stubbing;
import org.mockito.stubbing.Stubbing;
import org.mockito.stubbing.Stubbing;
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
List<Stubbing> unused = filter(stubbings, new Filter<Stubbing>() {
public boolean isOut(Stubbing s) {
Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
return String.format("0x%02X", (Byte) value);
import org.mockito.stubbing.Stubbing;
import java.io.Serializable;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
package org.mockito.internal.stubbing;
import org.mockito.internal.invocation.InvocationComparator;
import org.mockito.stubbing.Stubbing;
import java.util.Comparator;
public class StubbingComparator implements Comparator<Stubbing> {
private final InvocationComparator invocationComparator = new InvocationComparator();
public int compare(Stubbing o1, Stubbing o2) {
return invocationComparator.compare(o1.getInvocation(), o2.getInvocation());
import org.mockito.stubbing.Stubbing;
import org.mockito.internal.stubbing.StubbingComparator;
import java.util.List;
import java.util.TreeSet;
public Collection<Stubbing> getStubbings() {
List<? extends Stubbing> stubbings = mockHandler().getInvocationContainer().getStubbedInvocations();
TreeSet<Stubbing> out = new TreeSet<Stubbing>(new StubbingComparator());
out.addAll(stubbings);
return out;
package org.mockito.stubbing;
import org.mockito.MockingDetails;
import org.mockito.invocation.Invocation;
public interface Stubbing {
Invocation getInvocation();
boolean wasUsed();
import org.mockito.stubbing.Stubbing;
List<Stubbing> stubbings = new ArrayList<Stubbing>(findStubbings(asList(mockOne, mockOne, mockTwo)));
import java.util.LinkedHashMap;
import static org.junit.Assert.assertEquals;
public void prints_values() throws Exception {
assertEquals("null", print(null));
assertEquals("\"str\"", print("str"));
assertEquals("\"x\ny\"", print("x\ny"));
assertEquals("3", print(3));
assertEquals("3L", print(3L));
assertEquals("3.14d", print(3.14d));
assertEquals("3.14f", print(3.14f));
assertEquals("[1, 2]", print(new int[]{1, 2}));
assertEquals("{\"foo\" = 2L}", print(new LinkedHashMap<String, Object>() {
put("foo", 2L);
assertEquals("{\"byte\" = 0x01, \"short\" = 2, \"int\" = 3, \"long\" = 4L, \"float\" = 2.71f, \"double\" = 3.14d}", print(new LinkedHashMap<String, Object>() {
put("byte", (byte)1);
put("short", (short)2);
put("int", 3);
put("long", 4L);
put("float", 2.71f);
put("double", 3.14d);
assertEquals("ToString", print(new ToString()));
assertEquals("formatted", print(new FormattedText("formatted")));
public void prints_chars() throws Exception {
assertEquals("'a'", print('a'));
assertEquals("'\\n'", print('\n'));
assertEquals("'\\t'", print('\t'));
assertEquals("'\\r'", print('\r'));
import org.junit.Before;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.stubbing.Stubbing;
import java.util.Collection;
import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.withSettings;
MockitoAnnotations.initMocks(this);
public void should_know_spy(){
assertTrue(mockingDetails(gork).isMock());
assertTrue(mockingDetails(spy( new Gork())).isMock());
assertTrue(mockingDetails(spy(Gork.class)).isMock());
assertTrue(mockingDetails(mock(Gork.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isMock());
public void should_know_mock(){
assertTrue(mockingDetails(foo).isMock());
assertTrue(mockingDetails(mock(Foo.class)).isMock());
assertFalse(mockingDetails(foo).isSpy());
assertFalse(mockingDetails(mock(Foo.class)).isSpy());
public void should_handle_non_mocks() {
assertFalse(mockingDetails("non mock").isSpy());
assertFalse(mockingDetails("non mock").isMock());
assertFalse(mockingDetails(null).isSpy());
assertFalse(mockingDetails(null).isMock());
public void manipulating_invocations_is_safe() {
mock.simpleMethod();
mockingDetails(mock).getInvocations().clear();
assertEquals(1, mockingDetails(mock).getInvocations().size());
public void fails_when_getting_stubbings_from_non_mock() {
try {
mockingDetails(new Object()).getStubbings();
fail();
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
public void mock_with_no_stubbings() {
assertTrue(mockingDetails(mock).getStubbings().isEmpty());
public void provides_stubbings_of_mock_in_declaration_order() {
when(mock.simpleMethod(1)).thenReturn("1");
when(mock.otherMethod()).thenReturn("2");
Collection<Stubbing> stubbings = mockingDetails(mock).getStubbings();
assertEquals(2, stubbings.size());
assertEquals("[mock.simpleMethod(1); stubbed with: [Returns: 1], mock.otherMethod(); stubbed with: [Returns: 2]]", stubbings.toString());
public void manipulating_stubbings_explicitly_is_safe() {
when(mock.simpleMethod(1)).thenReturn("1");
mockingDetails(mock).getStubbings().clear();
assertEquals(1, mockingDetails(mock).getStubbings().size());
.hasMessageContaining("iMethods.forByte(0x19)");public void provides_stubbings_of_mock() {import static org.mockito.Mockito.mockingDetails;
import static org.mockito.Mockito.when;
package org.mockitousage.basicapi;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Spy;
import org.mockitoutil.TestBase;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertTrue;
import static org.mockito.Mockito.*;
public class MockingDetailsTest extends TestBase {
static class TestClass {}
public void should_know_spy(){
assertTrue(mockingDetails(annotatedSpy).isMock());
assertTrue(mockingDetails(spy( new TestClass())).isMock());
assertTrue(mockingDetails(spy(TestClass.class)).isMock());
assertTrue(mockingDetails(mock(TestClass.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isMock());
assertTrue(mockingDetails(annotatedSpy).isSpy());
assertTrue(mockingDetails(spy( new TestClass())).isSpy());
assertTrue(mockingDetails(spy(TestClass.class)).isSpy());
assertTrue(mockingDetails(mock(TestClass.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isSpy());
public void should_know_mock(){
assertTrue(mockingDetails(annotatedMock).isMock());
assertTrue(mockingDetails(mock(TestClass.class)).isMock());
assertFalse(mockingDetails(annotatedMock).isSpy());
assertFalse(mockingDetails(mock(TestClass.class)).isSpy());
public void should_handle_non_mocks() {
assertFalse(mockingDetails("non mock").isSpy());
assertFalse(mockingDetails("non mock").isMock());
assertFalse(mockingDetails(null).isSpy());
assertFalse(mockingDetails(null).isMock());.transform(withModifiers(SynchronizationState.PLAIN))
private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());private final JUnitDetector detector;
FriendlyExceptionMaker(JUnitDetector detector) {
this.detector = detector;
if (!detector.hasJUnit()) {
class JUnitDetector {
JUnitDetector() {
private static final JUnitDetector detector = new JUnitDetector();
return detector.hasJUnit();
return new FriendlyExceptionMaker(detector).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))assertThat(e).hasMessageContaining("Most likely it is a private class that is not visible by Mockito");import java.util.HashMap;
import java.util.Map;
private final Map<String, String> alias;
this.alias = new HashMap<String, String>();
PluginLoader withAlias(String name, String type) {
alias.put(name, type);
return this;
String aliasType = alias.get(foundPluginClass);
if (aliasType != null) {
foundPluginClass = aliasType;
private final PluginSwitch pluginSwitch = new PluginLoader(new DefaultPluginSwitch())
.loadPlugin(PluginSwitch.class, DefaultPluginSwitch.class.getName());
private final MockMaker mockMaker = new PluginLoader(pluginSwitch)
.withAlias("mockito-inline", "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker")
.loadPlugin(MockMaker.class, "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
private final StackTraceCleanerProvider stackTraceCleanerProvider = new PluginLoader(pluginSwitch)
.loadPlugin(StackTraceCleanerProvider.class, "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
private final InstantiatorProvider instantiatorProvider = new PluginLoader(pluginSwitch)
.loadPlugin(InstantiatorProvider.class, "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.SerializableMode;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import static org.mockito.internal.util.StringJoiner.join;
import static org.mockito.internal.util.reflection.FieldSetter.setField;
try {
Class<?> proxyClass = ((ClassCreatingMockMaker) Plugins.getMockMaker()).createMockType(
new CreationSettings()
.setTypeToMock(typeToMock)
.setExtraInterfaces(extraInterfaces)
.setSerializableMode(SerializableMode.ACROSS_CLASSLOADERS));
hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
return proxyClass;
throw new MockitoSerializationIssue(join(
"A Byte Buddy-generated mock cannot be deserialized into a non-Byte Buddy generated mock class",
"",
"The mock maker in use was: " + Plugins.getMockMaker().getClass()
), cce);
import org.mockito.Incubating;
public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
private ClassCreatingMockMaker defaultByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
return defaultByteBuddyMockMaker.createMock(settings, handler);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> creationSettings) {
return defaultByteBuddyMockMaker.createMockType(creationSettings);
return defaultByteBuddyMockMaker.getHandler(mock);
defaultByteBuddyMockMaker.resetMock(mock, newHandler, settings);
public TypeMockability isTypeMockable(Class<?> type) {
return defaultByteBuddyMockMaker.isTypeMockable(type);
package org.mockito.internal.creation.bytebuddy;
public interface BytecodeGenerator {
<T> Class<? extends T> mockClass(MockFeatures<T> features);
package org.mockito.internal.creation.bytebuddy;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
public interface ClassCreatingMockMaker extends MockMaker {
<T> Class<? extends T> createMockType(MockCreationSettings<T> settings);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.dynamic.ClassFileLocator;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.instrument.Instrumentation;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
import static org.mockito.internal.util.StringJoiner.join;
public class InlineByteBuddyMockMaker implements ClassCreatingMockMaker {
private final Instrumentation instrumentation;
private final BytecodeGenerator bytecodeGenerator;
private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks = new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
public InlineByteBuddyMockMaker() {
try {
instrumentation = ByteBuddyAgent.install();
if (!instrumentation.isRetransformClassesSupported()) {
throw new MockitoException("Current VM does not support retransformation");
File boot = File.createTempFile("mockitoboot", "jar");
boot.deleteOnExit();
JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
try {
outputStream.putNextEntry(new JarEntry("org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class"));
outputStream.write(ClassFileLocator.ForClassLoader.of(InlineByteBuddyMockMaker.class.getClassLoader())
.locate("org.mockito.internal.creation.bytebuddy.MockMethodDispatcher")
.resolve());
outputStream.closeEntry();
outputStream.close();
instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(boot));
bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(instrumentation, mocks), true);
throw new MockitoException("Cannot apply self-instrumentation on current VM", exception);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> type = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
try {
T instance = instantiator.newInstance(type);
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(handler), settings);
mocks.put(instance, mockMethodInterceptor);
if (instance instanceof MockAccess) {
((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
return instance;
throw new MockitoException("Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
return bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
public MockHandler getHandler(Object mock) {
MockMethodInterceptor interceptor = mocks.get(mock);
if (interceptor == null) {
return null;
return interceptor.handler;
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(newHandler), settings);
mocks.put(mock, mockMethodInterceptor);
if (mock instanceof MockAccess) {
((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return instrumentation.isModifiableClass(type) && !EXCLUDES.contains(type);
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (EXCLUDES.contains(type)) {
return "Cannot mock wrapper types, String.class or Class.class";
return "VM does not not support modification of given type";
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.dynamic.ClassFileLocator;
import net.bytebuddy.dynamic.scaffold.TypeValidation;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.utility.RandomString;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.internal.util.concurrent.WeakConcurrentSet;
import org.mockito.mock.SerializableMode;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.lang.reflect.Modifier;
import java.security.ProtectionDomain;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static net.bytebuddy.implementation.MethodDelegation.to;
import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
import static net.bytebuddy.matcher.ElementMatchers.*;
public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTransformer {
static final Set<Class<?>> EXCLUDES = new HashSet<Class<?>>(Arrays.asList(Class.class,
Boolean.class,
Byte.class,
Short.class,
Character.class,
Integer.class,
Long.class,
Float.class,
Double.class,
String.class));
private final Instrumentation instrumentation;
private final ByteBuddy byteBuddy;
private final WeakConcurrentSet<Class<?>> mocked;
private final String identifier;
private final MockMethodAdvice advice;
private final BytecodeGenerator subclassEngine;
public InlineBytecodeGenerator(Instrumentation instrumentation, WeakConcurrentMap<Object, MockMethodInterceptor> mocks) {
this.instrumentation = instrumentation;
byteBuddy = new ByteBuddy()
.with(TypeValidation.DISABLED)
.with(Implementation.Context.Disabled.Factory.INSTANCE);
mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
identifier = RandomString.make();
advice = new MockMethodAdvice(mocks, identifier);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodDispatcher.set(identifier, advice);
instrumentation.addTransformer(this, true);
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
synchronized (this) {
Set<Class<?>> types = new HashSet<Class<?>>();
Class<?> type = features.mockedType;
do {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
type = type.getSuperclass();
if (!types.isEmpty()) {
try {
instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
for (Class<?> failed : types) {
mocked.remove(failed);
throw new MockitoException("Could not modify all classes " + types, exception);
Class<? extends T> mockedType = features.mockedType;
if (!features.interfaces.isEmpty()
|| features.serializableMode != SerializableMode.NONE
|| Modifier.isAbstract(features.mockedType.getModifiers())) {
mockedType = subclassEngine.mockClass(features);
return mockedType;
private void addInterfaces(Set<Class<?>> types, Class<?>[] interfaces) {
for (Class<?> type : interfaces) {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
public byte[] transform(ClassLoader loader,
String className,
Class<?> classBeingRedefined,
ProtectionDomain protectionDomain,
byte[] classfileBuffer) throws IllegalClassFormatException {
if (classBeingRedefined == null
|| !mocked.contains(classBeingRedefined)
|| EXCLUDES.contains(classBeingRedefined)) {
return null;
try {
return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.class).on(isVirtual()
.and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
.and(not(isDeclaredBy(nameStartsWith("java.")).<MethodDescription>and(isPackagePrivate())))))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForHashCode.class).on(isHashCode()))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForEquals.class).on(isEquals()))
.make()
.getBytes();
return null;
package org.mockito.internal.creation.bytebuddy;
public interface MockAccess {
MockMethodInterceptor getMockitoInterceptor();
void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
import org.mockito.mock.SerializableMode;
final SerializableMode serializableMode;
private MockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
this.serializableMode = serializableMode;
public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
return new MockFeatures<T>(mockedType, interfaces, serializableMode);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.This;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.Callable;
public class MockMethodAdvice extends MockMethodDispatcher {
final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
private final String identifier;
private final SelfCallInfo selfCallInfo = new SelfCallInfo();
public MockMethodAdvice(WeakConcurrentMap<Object, MockMethodInterceptor> interceptors, String identifier) {
this.interceptors = interceptors;
this.identifier = identifier;
private static Callable<?> enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
if (dispatcher == null || !dispatcher.isMocked(mock, origin)) {
return null;
return dispatcher.handle(mock, origin, arguments);
private static void exit(@Advice.BoxedReturn(readOnly = false) Object returned,
if (mocked != null) {
returned = mocked.call();
public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
MockMethodInterceptor interceptor = interceptors.get(instance);
if (interceptor == null) {
return null;
InterceptedInvocation.SuperMethod superMethod;
if (instance instanceof Serializable) {
superMethod = new SerializableSuperMethodCall(identifier, origin, instance, arguments);
superMethod = new SuperMethodCall(selfCallInfo, origin, instance, arguments);
return new ReturnValueWrapper(interceptor.doIntercept(instance,
origin,
arguments,
superMethod));
public boolean isMock(Object instance) {
return interceptors.containsKey(instance);
public boolean isMocked(Object instance, Method origin) {
return selfCallInfo.checkSuperCall(instance) && isMock(instance) && isNotOverridden(instance.getClass(), origin);
private static boolean isNotOverridden(Class<?> type, Method origin) {
Class<?> currentType = type;
do {
try {
return origin.equals(type.getDeclaredMethod(origin.getName(), origin.getParameterTypes()));
currentType = currentType.getSuperclass();
return true;
private static class SuperMethodCall implements InterceptedInvocation.SuperMethod {
private final SelfCallInfo selfCallInfo;
private final Method origin;
private final Object instance;
private final Object[] arguments;
private SuperMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
this.selfCallInfo = selfCallInfo;
this.origin = origin;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
origin.setAccessible(true);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
private static class SerializableSuperMethodCall implements InterceptedInvocation.SuperMethod {
private final String identifier;
private final SerializableMethod origin;
private final Object instance;
private final Object[] arguments;
private SerializableSuperMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
this.origin = new SerializableMethod(origin);
this.identifier = identifier;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
Method method = origin.getJavaMethod();
if (!Modifier.isPublic(method.getDeclaringClass().getModifiers() & method.getModifiers())) {
method.setAccessible(true);
MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instance);
if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
throw new MockitoException("Unexpected dispatcher for advice-based super call");
((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(instance);
return tryInvoke(method, instance, arguments);
private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
try {
return origin.invoke(instance, arguments);
Throwable cause = exception.getCause();
new ConditionalStackTraceFilter().filter(hideRecursiveCall(cause, new Throwable().getStackTrace().length, origin.getDeclaringClass()));
throw cause;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
private static class ReturnValueWrapper implements Callable<Object> {
private final Object returned;
private ReturnValueWrapper(Object returned) {
this.returned = returned;
public Object call() {
return returned;
private static class SelfCallInfo extends ThreadLocal<Object> {
boolean checkSuperCall(Object value) {
Object current = get();
if (current == value) {
set(null);
return false;
return true;
static class ForHashCode {
private static boolean enter(@Identifier String id,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
hashCode = System.identityHashCode(self);
static class ForEquals {
private static boolean enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
equals = self == other;
public static class ForReadObject {
public static void doReadObject(@Identifier String identifier,
objectInputStream.defaultReadObject();
MockMethodAdvice mockMethodAdvice = (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
if (mockMethodAdvice != null) {
mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
package org.mockito.internal.creation.bytebuddy;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
public abstract class MockMethodDispatcher {
private static final ConcurrentMap<String, MockMethodDispatcher> INSTANCE = new ConcurrentHashMap<String, MockMethodDispatcher>();
public static MockMethodDispatcher get(String identifier, Object mock) {
if (mock == INSTANCE) { // Avoid endless loop if ConcurrentHashMap was redefined to check for being a mock.
return null;
return INSTANCE.get(identifier);
public static void set(String identifier, MockMethodDispatcher dispatcher) {
INSTANCE.putIfAbsent(identifier, dispatcher);
public abstract Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable;
public abstract boolean isMock(Object instance);
public abstract boolean isMocked(Object instance, Method origin);
final InternalMockHandler handler;
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod) throws Throwable {
package org.mockito.internal.creation.bytebuddy;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.Platform;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
private final BytecodeGenerator cachingMockBytecodeGenerator;
public SubclassByteBuddyMockMaker() {
cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), false);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> mockedProxyType = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
T mockInstance = null;
try {
mockInstance = instantiator.newInstance(mockedProxyType);
MockAccess mockAccess = (MockAccess) mockInstance;
mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
return ensureMockIsAssignableToMockedType(settings, mockInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito mock :",
"  class to mock : " + describeClass(settings.getTypeToMock()),
"  created class : " + describeClass(mockedProxyType),
"  proxy instance class : " + describeClass(mockInstance),
"  instance creation by : " + instantiator.getClass().getSimpleName(),
"",
"You might experience classloading issues, please ask the mockito mailing-list.",
""
), cce);
throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
try {
return cachingMockBytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
throw prettifyFailure(settings, bytecodeGenerationFailed);
private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {
Class<T> typeToMock = settings.getTypeToMock();
return typeToMock.cast(mock);
private <T> RuntimeException prettifyFailure(MockCreationSettings<T> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
"Most likely it is a private class that is not visible by Mockito",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock(),
"",
"Mockito can only non-private & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
Platform.describe(),
"",
"Underlying exception : " + generationFailed
), generationFailed);
private static String describeClass(Class<?> type) {
return type == null ? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private static String describeClass(Object instance) {
return instance == null ? "null" : describeClass(instance.getClass());
public MockHandler getHandler(Object mock) {
if (!(mock instanceof MockAccess)) {
return null;
return ((MockAccess) mock).getMockitoInterceptor().getMockHandler();
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
((MockAccess) mock).setMockitoInterceptor(
new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)
);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (Modifier.isFinal(type.getModifiers())) {
return "final or anonymous class";
return join("not handled type");
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.implementation.Implementation;
import org.mockito.mock.SerializableMode;
import java.io.IOException;
import java.io.ObjectInputStream;
import static java.lang.Thread.currentThread;
import static net.bytebuddy.dynamic.Transformer.ForMethod.withModifiers;
import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER;
class SubclassBytecodeGenerator implements BytecodeGenerator {
private final Implementation readReplace;
private final ElementMatcher<? super MethodDescription> matcher;
public SubclassBytecodeGenerator() {
this(null, any());
public SubclassBytecodeGenerator(Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
this.readReplace = readReplace;
this.matcher = matcher;
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
.method(matcher)
.intercept(to(DispatcherDefaultingToRealMethod.class))
.transform(withModifiers(SynchronizationState.PLAIN))
.attribute(INCLUDING_RECEIVER)
.intercept(to(MockMethodInterceptor.ForEquals.class))
.serialVersionUid(42L)
.defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
.implement(MockAccess.class)
.intercept(FieldAccessor.ofBeanProperty());
if (features.serializableMode == SerializableMode.ACROSS_CLASSLOADERS) {
if (readReplace != null) {
builder = builder.defineMethod("readObject", void.class, Visibility.PRIVATE)
.withParameters(ObjectInputStream.class)
.throwing(ClassNotFoundException.class, IOException.class)
.intercept(readReplace);
.append(currentThread().getContextClassLoader())
class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
private final BytecodeGenerator bytecodeGenerator;
public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
public <T> Class<T> mockClass(MockFeatures<T> params) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
private BytecodeGenerator bytecodeGenerator;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
if (classReference != null) {
if (generatedMockClass == null) {
return bytecodeGenerator.mockClass(mockFeatures);
"",
"You might be able to avoid this problem when using inline mocks.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
"Unless you explicitly enable inline mocks, Mockito can only mock visible & non-final classes.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
public CreationSettings<T> setSerializableMode(SerializableMode serializableMode) {
this.serializableMode = serializableMode;
return this;
public class MockHandlerImpl<T> implements InternalMockHandler<T> {
private volatile transient Method method;
this.method = method;
if (method != null) {
return method;
method = declaringClass.getDeclaredMethod(methodName, parameterTypes);
return method;
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
import org.mockito.internal.runners.util.FailureDetecter;
FailureDetecter listener = new FailureDetecter();
if (!filterRequested && listener.isSussessful()) {
public class FailureDetecter extends RunListener {
public boolean isSussessful() {
package org.mockito.internal.util;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public abstract class Platform {
private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME = Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
private static final Pattern JAVA_8_DEV_VERSION_SCHEME = Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
public static final String JAVA_VERSION = System.getProperty("java.specification.version");
public static final String JVM_VERSION = System.getProperty("java.runtime.version");
public static final String JVM_VENDOR = System.getProperty("java.vm.vendor");
public static final String JVM_VENDOR_VERSION = System.getProperty("java.vm.version");
public static final String JVM_NAME = System.getProperty("java.vm.name");
public static final String JVM_INFO = System.getProperty("java.vm.info");
public static final String OS_NAME = System.getProperty("os.name");
public static final String OS_VERSION = System.getProperty("os.version");
private Platform() {}
public static String describe() {
return String.format("Java               : %s\n" +
"JVM vendor name    : %s\n" +
"JVM vendor version : %s\n" +
"JVM name           : %s\n" +
"JVM version        : %s\n" +
"JVM info           : %s\n" +
"OS name            : %s\n" +
"OS version         : %s\n",
JAVA_VERSION,
JVM_VENDOR,
JVM_VENDOR_VERSION,
JVM_NAME,
JVM_VERSION,
JVM_INFO,
OS_NAME,
OS_VERSION);
public static boolean isJava8BelowUpdate45() {
return isJava8BelowUpdate45(JVM_VERSION);
static boolean isJava8BelowUpdate45(String jvmVersion) {
Matcher matcher = JAVA_8_RELEASE_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = JAVA_8_DEV_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = Pattern.compile("1\\.8\\.0-b\\d+").matcher(jvmVersion);
if (matcher.matches()) {
return true;
return false;
package org.mockito.internal.util.concurrent;
public class DetachedThreadLocal<T> implements Runnable {
final WeakConcurrentMap<Thread, T> map;
public DetachedThreadLocal(Cleaner cleaner) {
switch (cleaner) {
case THREAD:
case MANUAL:
map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
case INLINE:
map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
default:
throw new AssertionError();
public T get() {
return map.get(Thread.currentThread());
public void set(T value) {
map.put(Thread.currentThread(), value);
public void clear() {
map.remove(Thread.currentThread());
public void clearAll() {
map.clear();
public T pushTo(Thread thread) {
T value = get();
if (value != null) {
map.put(thread, inheritValue(value));
return value;
public T fetchFrom(Thread thread) {
T value = map.get(thread);
if (value != null) {
set(inheritValue(value));
return value;
public T get(Thread thread) {
return map.get(thread);
public void define(Thread thread, T value) {
map.put(thread, value);
protected T initialValue(Thread thread) {
return null;
protected T inheritValue(T value) {
return value;
public WeakConcurrentMap<Thread, T> getBackingMap() {
return map;
public void run() {
map.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
package org.mockito.internal.util.concurrent;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnable, Iterable<Map.Entry<K, V>> {
private static final AtomicLong ID = new AtomicLong();
final ConcurrentMap<WeakKey<K>, V> target;
private final Thread thread;
public WeakConcurrentMap(boolean cleanerThread) {
target = new ConcurrentHashMap<WeakKey<K>, V>();
if (cleanerThread) {
thread = new Thread(this);
thread.setName("weak-ref-cleaner-" + ID.getAndIncrement());
thread.setPriority(Thread.MIN_PRIORITY);
thread.setDaemon(true);
thread.start();
thread = null;
public V get(K key) {
if (key == null) throw new NullPointerException();
V value = target.get(new LatentKey<K>(key));
if (value == null) {
value = defaultValue(key);
if (value != null) {
V previousValue = target.putIfAbsent(new WeakKey<K>(key, this), value);
if (previousValue != null) {
value = previousValue;
return value;
public boolean containsKey(K key) {
if (key == null) throw new NullPointerException();
return target.containsKey(new LatentKey<K>(key));
public V put(K key, V value) {
if (key == null || value == null) throw new NullPointerException();
return target.put(new WeakKey<K>(key, this), value);
public V remove(K key) {
if (key == null) throw new NullPointerException();
return target.remove(new LatentKey<K>(key));
public void clear() {
target.clear();
protected V defaultValue(K key) {
return null;
public Thread getCleanerThread() {
return thread;
public void expungeStaleEntries() {
Reference<?> reference;
while ((reference = poll()) != null) {
target.remove(reference);
public int approximateSize() {
return target.size();
public void run() {
try {
while (true) {
target.remove(remove());
clear();
public Iterator<Map.Entry<K, V>> iterator() {
return new EntryIterator(target.entrySet().iterator());
private static class WeakKey<T> extends WeakReference<T> {
private final int hashCode;
WeakKey(T key, ReferenceQueue<? super T> queue) {
super(key, queue);
hashCode = System.identityHashCode(key);
public int hashCode() {
return hashCode;
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == get();
return ((WeakKey<?>) other).get() == get();
private static class LatentKey<T> {
final T key;
private final int hashCode;
LatentKey(T key) {
this.key = key;
hashCode = System.identityHashCode(key);
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == key;
return ((WeakKey<?>) other).get() == key;
public int hashCode() {
return hashCode;
public static class WithInlinedExpunction<K, V> extends WeakConcurrentMap<K, V> {
public WithInlinedExpunction() {
super(false);
public V get(K key) {
expungeStaleEntries();
return super.get(key);
public boolean containsKey(K key) {
expungeStaleEntries();
return super.containsKey(key);
public V put(K key, V value) {
expungeStaleEntries();
return super.put(key, value);
public V remove(K key) {
expungeStaleEntries();
return super.remove(key);
public Iterator<Map.Entry<K, V>> iterator() {
expungeStaleEntries();
return super.iterator();
public int approximateSize() {
expungeStaleEntries();
return super.approximateSize();
private class EntryIterator implements Iterator<Map.Entry<K, V>> {
private final Iterator<Map.Entry<WeakKey<K>, V>> iterator;
private Map.Entry<WeakKey<K>, V> nextEntry;
private K nextKey;
private EntryIterator(Iterator<Map.Entry<WeakKey<K>, V>> iterator) {
this.iterator = iterator;
findNext();
private void findNext() {
while (iterator.hasNext()) {
nextEntry = iterator.next();
nextKey = nextEntry.getKey().get();
if (nextKey != null) {
return;
nextEntry = null;
nextKey = null;
public boolean hasNext() {
return nextKey != null;
public Map.Entry<K, V> next() {
if (nextKey == null) {
throw new NoSuchElementException();
try {
return new SimpleEntry(nextKey, nextEntry);
findNext();
public void remove() {
throw new UnsupportedOperationException();
private class SimpleEntry implements Map.Entry<K, V> {
private final K key;
final Map.Entry<WeakKey<K>, V> entry;
private SimpleEntry(K key, Map.Entry<WeakKey<K>, V> entry) {
this.key = key;
this.entry = entry;
public K getKey() {
return key;
public V getValue() {
return entry.getValue();
public V setValue(V value) {
if (value == null) throw new NullPointerException();
return entry.setValue(value);
package org.mockito.internal.util.concurrent;
import java.util.Iterator;
import java.util.Map;
public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
final WeakConcurrentMap<V, Boolean> target;
public WeakConcurrentSet(Cleaner cleaner) {
switch (cleaner) {
case INLINE:
target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
break;
case THREAD:
case MANUAL:
target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
break;
default:
throw new AssertionError();
public boolean add(V value) {
return target.put(value, Boolean.TRUE) == null; // is null or Boolean.TRUE
public boolean contains(V value) {
return target.containsKey(value);
public boolean remove(V value) {
return target.remove(value);
public void clear() {
target.clear();
public int approximateSize() {
return target.approximateSize();
public void run() {
target.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
public void expungeStaleEntries() {
target.expungeStaleEntries();
public Thread getCleanerThread() {
return target.getCleanerThread();
public Iterator<V> iterator() {
return new ReducingIterator<V>(target.iterator());
private static class ReducingIterator<V> implements Iterator<V> {
private final Iterator<Map.Entry<V, Boolean>> iterator;
private ReducingIterator(Iterator<Map.Entry<V, Boolean>> iterator) {
this.iterator = iterator;
public void remove() {
iterator.remove();
public V next() {
return iterator.next().getKey();
public boolean hasNext() {
return iterator.hasNext();
import org.mockito.internal.creation.bytebuddy.TypeCachingMockBytecodeGeneratorTest;
import java.util.*;
import static junit.framework.TestCase.assertEquals;
private Set<Class<?>> failed = new HashSet<Class<?>>();
TypeCachingMockBytecodeGeneratorTest.class,
failed.add(failure.getDescription().getTestClass());
public Set<Class<?>> getFailed() {
assertEquals("Run in multiple thread failed for tests", Collections.emptySet(), runInMultipleThreads(3));
public static Set<Class<?>> runInMultipleThreads(int numberOfThreads) throws Exception {
Set<Class<?>> failed = new HashSet<Class<?>>();
failed.addAll(t.getFailed());
Set<Class<?>> failed = runInMultipleThreads(numberOfThreads);
System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds. (" + failed.size() + " tests failed)");
import static org.junit.Assume.assumeTrue;
assumeTrue("Annotation copying does not apply for inline mocks", mock(OnClass.class).getClass() != OnClass.class);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import org.junit.Test;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.InvocationContainer;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.SerializableMode;
import org.mockito.plugins.MockMaker;
import org.mockito.stubbing.Answer;
import org.mockitoutil.ClassLoaders;
import org.mockitoutil.SimpleSerializationUtil;
import org.objenesis.ObjenesisStd;
import java.io.Serializable;
import java.util.List;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockitoutil.ClassLoaders.coverageTool;
public abstract class AbstractByteBuddyMockMakerTest {
protected final MockMaker mockMaker;
public AbstractByteBuddyMockMakerTest(MockMaker mockMaker) {
this.mockMaker = mockMaker;
protected abstract Class<?> mockTypeOf(Class<?> type);
public void should_create_mock_from_interface() throws Exception {
SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyH());
Class<?> superClass = proxy.getClass().getSuperclass();
assertThat(superClass).isEqualTo(Object.class);
public void should_create_mock_from_class() throws Exception {
ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyH());
Class<?> superClass = mockTypeOf(proxy.getClass());
assertThat(superClass).isEqualTo(ClassWithoutConstructor.class);
public void should_create_mock_from_class_even_when_constructor_is_dodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyH());
assertThat(mock).isNotNull();
public void should_mocks_have_different_interceptors() throws Exception {
SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
MockHandler handlerOne = mockMaker.getHandler(mockOne);
MockHandler handlerTwo = mockMaker.getHandler(mockTwo);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_use_ancillary_Types() {
SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyH());
assertThat(mock).isInstanceOf(SomeInterface.class);
public void should_create_class_by_constructor() {
OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyH());
assertThat(mock).isNotNull();
public void should_allow_serialization() throws Exception {
SerializableClass proxy = mockMaker.createMock(serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC), dummyH());
SerializableClass serialized = SimpleSerializationUtil.serializeAndBack(proxy);
assertThat(serialized).isNotNull();
MockHandler handlerOne = mockMaker.getHandler(proxy);
MockHandler handlerTwo = mockMaker.getHandler(serialized);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_create_mock_from_class_with_super_call_to_final_method() throws Exception {
MockCreationSettings<CallingSuperMethodClass> settings = settingsWithSuperCall(CallingSuperMethodClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<CallingSuperMethodClass>(settings));
assertThat(proxy.foo()).isEqualTo("foo");
public void should_reset_mock_and_set_new_handler() throws Throwable {
MockCreationSettings<SampleClass> settings = settingsWithSuperCall(SampleClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<SampleClass>(settings));
MockHandler handler = new MockHandlerImpl<SampleClass>(settings);
mockMaker.resetMock(proxy, handler, settings);
assertThat(mockMaker.getHandler(proxy)).isSameAs(handler);
public void is_type_mockable_excludes_primitive_classes() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.mockable()).isFalse();
class SomeClass {}
interface SomeInterface {}
static class OtherClass {}
static class SerializableClass implements Serializable {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
public void instantiate_fine_when_objenesis_on_the_classpath() throws Exception {
ClassLoader classpath_with_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
.withCodeSourceUrlOf(coverageTool())
.build();
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker",
true,
classpath_with_objenesis
);
mock_maker_class_loaded_fine_until.newInstance();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
if(extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static <T> MockCreationSettings<T> serializableSettingsFor(Class<T> type, SerializableMode serializableMode) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.serializable(serializableMode);
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithSuperCall(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new CallsRealMethods());
return mockSettings;
private static MockHandler dummyH() {
return new DummyMockHandler();
private static class DummyMockHandler implements InternalMockHandler<Object> {
public Object handle(Invocation invocation) throws Throwable { return null; }
public MockCreationSettings<Object> getMockSettings() { return null; }
public InvocationContainer getInvocationContainer() { return null; }
public void setAnswersForStubbing(List<Answer<?>> list) { }
private static class SampleClass {
public String foo() {
return "foo";
private static class CallingSuperMethodClass extends SampleClass {
public String foo() {
return super.foo();
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.verify;
public class ByteBuddyMockMakerTest extends TestBase {
private ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker();
private ClassCreatingMockMaker delegate;
public void should_delegate_call() {
CreationSettings<Object> creationSettings = new CreationSettings<Object>();
MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
mockMaker.createMockType(creationSettings);
mockMaker.createMock(creationSettings, handler);
mockMaker.getHandler(this);
mockMaker.isTypeMockable(Object.class);
mockMaker.resetMock(this, handler, creationSettings);
verify(delegate).createMock(creationSettings, handler);
verify(delegate).getHandler(this);
verify(delegate).isTypeMockable(Object.class);
verify(delegate).resetMock(this, handler, creationSettings);
package org.mockito.internal.creation.bytebuddy;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import static org.assertj.core.api.Assertions.assertThat;
public class InlineByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public ExpectedException expectedException = ExpectedException.none();
public InlineByteBuddyMockMakerTest() {
super(new InlineByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type;
public void should_create_mock_from_final_class() throws Exception {
MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
FinalClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
MockCreationSettings<FinalMethodAbstractType> settings = settingsFor(FinalMethodAbstractType.class);
FinalMethodAbstractType proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(proxy.bar()).isEqualTo("bar");
public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
MockCreationSettings<FinalMethod> settings = settingsFor(FinalMethod.class, SampleInterface.class);
FinalMethod proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
public void should_throw_exception_redefining_unmodifiable_class() {
int[] array = new int[5];
MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
expectedException.expect(MockitoException.class);
expectedException.expectMessage(new BaseMatcher<String>() {
public boolean matches(Object item) {
return ((String) item).contains("Could not modify all classes");
public void describeTo(Description description) {
mockMaker.createMock(settings, new MockHandlerImpl(settings));
public void should_create_mock_from_enum() throws Exception {
MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
StackTraceElement[] stack = new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
new StackTraceElement("qux", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
Throwable throwable = new Throwable();
throwable.setStackTrace(stack);
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(throwable.getStackTrace()).isEqualTo(new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
Throwable throwable = new Throwable();
throwable.setStackTrace(new StackTraceElement[0]);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
public void should_provide_reason_for_wrapper_class() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.nonMockableReason()).isEqualTo("Cannot mock wrapper types, String.class or Class.class");
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new Returns("bar"));
if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static final class FinalClass {
public String foo() {
return "foo";
private enum EnumClass {
INSTANCE;
public String foo() {
return "foo";
private abstract static class FinalMethodAbstractType {
public final String foo() {
return "foo";
public abstract String bar();
private static class FinalMethod {
public final String foo() {
return "foo";
private static class NonFinalMethod {
public String foo() {
return "foo";
private interface SampleInterface {
String bar();
package org.mockito.internal.creation.bytebuddy;
public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public SubclassByteBuddyMockMakerTest() {
super(new SubclassByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type.getSuperclass();
import org.mockito.mock.SerializableMode;
public class TypeCachingMockBytecodeGeneratorTest {
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
import org.mockito.internal.configuration.plugins.Plugins;
import static org.junit.Assume.assumeFalse;
public void should_return_null_for_final_class_if_unsupported() throws Exception {
assumeFalse(Plugins.getMockMaker().isTypeMockable(Baz.class).mockable());
import org.mockito.internal.configuration.plugins.Plugins;
Assertions.assertThat(MockUtil.typeMockabilityOf(FinalClass.class).mockable())
.isEqualTo(Plugins.getMockMaker().isTypeMockable(FinalClass.class).mockable());
package org.mockito.internal.util;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.HashMap;
import java.util.Map;
import org.junit.Test;
public class PlatformTest {
public void const_are_initialized_from_system_properties() {
assertThat(Platform.JVM_VERSION).isEqualTo(System.getProperty("java.runtime.version"));
assertThat(Platform.JVM_INFO).isEqualTo(System.getProperty("java.vm.info"));
assertThat(Platform.JVM_NAME).isEqualTo(System.getProperty("java.vm.name"));
assertThat(Platform.JVM_VENDOR).isEqualTo(System.getProperty("java.vm.vendor"));
assertThat(Platform.JVM_VENDOR_VERSION).isEqualTo(System.getProperty("java.vm.version"));
public void should_parse_open_jdk_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("1.8.0_92-b14", false);
put("1.8.0-b24", true);
put("1.8.0_5", true);
put("1.8.0b5_u44", true);
put("1.8.0b5_u92", false);
put("1.7.0_4", false);
put("1.4.0_03-b04", false);
put("1.4.0_03-ea-b01", false);
put("pxi3270_27sr4-20160303_03 (SR4)", false);
put("pwi3260sr11-20120412_01 (SR11)", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
public void should_parse_open_jdk9_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("9-ea+73", false);
put("9+100", false);
put("9.1.2+62", false);
put("9.0.1+20", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
private void assertPlatformParsesCorrectlyVariousVersionScheme(Map<String, Boolean> versions) {
for (Map.Entry<String, Boolean> version : versions.entrySet()) {
assertThat(Platform.isJava8BelowUpdate45(version.getKey())).describedAs(version.getKey())
.isEqualTo(version.getValue());
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeFalse;
public void shouldNotAllowMockingFinalClassesIfDisabled() throws Exception {
assumeFalse("Inlining mock allows mocking final classes", mock(FinalClass.class).getClass() == FinalClass.class);
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
import static org.junit.Assume.assumeTrue;
List<String> spy = spy(real);
assumeTrue("Using inline mocks, it is possible to spy on private types", spy.getClass() != real.getClass());
import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
public class MyMockMaker extends SubclassByteBuddyMockMaker {import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Modifier;
import org.mockito.internal.util.Platform;
"  class to mock : " + describeClass(settings.getTypeToMock()),
"  created class : " + describeClass(mockedProxyType),
try {
return cachingMockBytecodeGenerator.get(mockFeatures);
throw prettifyFailure(mockFeatures, bytecodeGenerationFailed);
private RuntimeException prettifyFailure(MockFeatures<?> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.mockedType.getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType + ".",
"Most likely it is a private class that is not visible by Mockito",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType,
"",
"Mockito can only non-private & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
Platform.describe(),
"",
"Underlying exception : " + generationFailed
), generationFailed);
generatedMockClass = generator.generateMockClass(features);
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
if (!detecter.hasJUnit()) {
class JUnitDetecter {
JUnitDetecter() {
private static final JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.util;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public abstract class Platform {
private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME = Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
private static final Pattern JAVA_8_DEV_VERSION_SCHEME = Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
public static final String JAVA_VERSION = System.getProperty("java.specification.version");
public static final String JVM_VERSION = System.getProperty("java.runtime.version");
public static final String JVM_VENDOR = System.getProperty("java.vm.vendor");
public static final String JVM_VENDOR_VERSION = System.getProperty("java.vm.version");
public static final String JVM_NAME = System.getProperty("java.vm.name");
public static final String JVM_INFO = System.getProperty("java.vm.info");
public static final String OS_NAME = System.getProperty("os.name");
public static final String OS_VERSION = System.getProperty("os.version");
private Platform() {}
public static String describe() {
return String.format("Java               : %s\n" +
"JVM vendor name    : %s\n" +
"JVM vendor version : %s\n" +
"JVM name           : %s\n" +
"JVM version        : %s\n" +
"JVM info           : %s\n" +
"OS name            : %s\n" +
"OS version         : %s\n",
JAVA_VERSION,
JVM_VENDOR,
JVM_VENDOR_VERSION,
JVM_NAME,
JVM_VERSION,
JVM_INFO,
OS_NAME,
OS_VERSION);
public static boolean isJava8BelowUpdate45() {
return isJava8BelowUpdate45(JVM_VERSION);
static boolean isJava8BelowUpdate45(String jvmVersion) {
Matcher matcher = JAVA_8_RELEASE_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = JAVA_8_DEV_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = Pattern.compile("1\\.8\\.0-b\\d+").matcher(jvmVersion);
if (matcher.matches()) {
return true;
return false;
package org.mockito.internal.util;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.HashMap;
import java.util.Map;
import org.junit.Test;
public class PlatformTest {
public void const_are_initialized_from_system_properties() {
assertThat(Platform.JVM_VERSION).isEqualTo(System.getProperty("java.runtime.version"));
assertThat(Platform.JVM_INFO).isEqualTo(System.getProperty("java.vm.info"));
assertThat(Platform.JVM_NAME).isEqualTo(System.getProperty("java.vm.name"));
assertThat(Platform.JVM_VENDOR).isEqualTo(System.getProperty("java.vm.vendor"));
assertThat(Platform.JVM_VENDOR_VERSION).isEqualTo(System.getProperty("java.vm.version"));
public void should_parse_open_jdk_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("1.8.0_92-b14", false);
put("1.8.0-b24", true);
put("1.8.0_5", true);
put("1.8.0b5_u44", true);
put("1.8.0b5_u92", false);
put("1.7.0_4", false);
put("1.4.0_03-b04", false);
put("1.4.0_03-ea-b01", false);
put("pxi3270_27sr4-20160303_03 (SR4)", false);
put("pwi3260sr11-20120412_01 (SR11)", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
public void should_parse_open_jdk9_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("9-ea+73", false);
put("9+100", false);
put("9.1.2+62", false);
put("9.0.1+20", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
private void assertPlatformParsesCorrectlyVariousVersionScheme(Map<String, Boolean> versions) {
for (Map.Entry<String, Boolean> version : versions.entrySet()) {
assertThat(Platform.isJava8BelowUpdate45(version.getKey())).describedAs(version.getKey())
.isEqualTo(version.getValue());
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());import java.util.HashMap;
import java.util.Map;
private final Map<String, String> alias;
this.alias = new HashMap<String, String>();
PluginLoader withAlias(String name, String type) {
alias.put(name, type);
return this;
String aliasType = alias.get(foundPluginClass);
if (aliasType != null) {
foundPluginClass = aliasType;
private final PluginSwitch pluginSwitch = new PluginLoader(new DefaultPluginSwitch())
.loadPlugin(PluginSwitch.class, DefaultPluginSwitch.class.getName());
private final MockMaker mockMaker = new PluginLoader(pluginSwitch)
.withAlias("mockito-inline", "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker")
.loadPlugin(MockMaker.class, "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
private final StackTraceCleanerProvider stackTraceCleanerProvider = new PluginLoader(pluginSwitch)
.loadPlugin(StackTraceCleanerProvider.class, "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
private final InstantiatorProvider instantiatorProvider = new PluginLoader(pluginSwitch)
.loadPlugin(InstantiatorProvider.class, "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.SerializableMode;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import static org.mockito.internal.util.StringJoiner.join;
import static org.mockito.internal.util.reflection.FieldSetter.setField;
try {
Class<?> proxyClass = ((ClassCreatingMockMaker) Plugins.getMockMaker()).createMockType(
new CreationSettings()
.setTypeToMock(typeToMock)
.setExtraInterfaces(extraInterfaces)
.setSerializableMode(SerializableMode.ACROSS_CLASSLOADERS));
hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
return proxyClass;
throw new MockitoSerializationIssue(join(
"A Byte Buddy-generated mock cannot be deserialized into a non-Byte Buddy generated mock class",
"",
"The mock maker in use was: " + Plugins.getMockMaker().getClass()
), cce);
import org.mockito.Incubating;
public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
private ClassCreatingMockMaker defaultByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
return defaultByteBuddyMockMaker.createMock(settings, handler);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> creationSettings) {
return defaultByteBuddyMockMaker.createMockType(creationSettings);
return defaultByteBuddyMockMaker.getHandler(mock);
defaultByteBuddyMockMaker.resetMock(mock, newHandler, settings);
public TypeMockability isTypeMockable(Class<?> type) {
return defaultByteBuddyMockMaker.isTypeMockable(type);
package org.mockito.internal.creation.bytebuddy;
public interface BytecodeGenerator {
<T> Class<? extends T> mockClass(MockFeatures<T> features);
package org.mockito.internal.creation.bytebuddy;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
public interface ClassCreatingMockMaker extends MockMaker {
<T> Class<? extends T> createMockType(MockCreationSettings<T> settings);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.dynamic.ClassFileLocator;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.instrument.Instrumentation;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
import static org.mockito.internal.util.StringJoiner.join;
public class InlineByteBuddyMockMaker implements ClassCreatingMockMaker {
private final Instrumentation instrumentation;
private final BytecodeGenerator bytecodeGenerator;
private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks = new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
public InlineByteBuddyMockMaker() {
try {
instrumentation = ByteBuddyAgent.install();
if (!instrumentation.isRetransformClassesSupported()) {
throw new MockitoException("Current VM does not support retransformation");
File boot = File.createTempFile("mockitoboot", "jar");
boot.deleteOnExit();
JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
try {
outputStream.putNextEntry(new JarEntry("org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class"));
outputStream.write(ClassFileLocator.ForClassLoader.of(InlineByteBuddyMockMaker.class.getClassLoader())
.locate("org.mockito.internal.creation.bytebuddy.MockMethodDispatcher")
.resolve());
outputStream.closeEntry();
outputStream.close();
instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(boot));
bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(instrumentation, mocks), true);
throw new MockitoException("Cannot apply self-instrumentation on current VM", exception);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> type = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
try {
T instance = instantiator.newInstance(type);
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(handler), settings);
mocks.put(instance, mockMethodInterceptor);
if (instance instanceof MockAccess) {
((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
return instance;
throw new MockitoException("Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
return bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
public MockHandler getHandler(Object mock) {
MockMethodInterceptor interceptor = mocks.get(mock);
if (interceptor == null) {
return null;
return interceptor.handler;
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(newHandler), settings);
mocks.put(mock, mockMethodInterceptor);
if (mock instanceof MockAccess) {
((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return instrumentation.isModifiableClass(type) && !EXCLUDES.contains(type);
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (EXCLUDES.contains(type)) {
return "Cannot mock wrapper types, String.class or Class.class";
return "VM does not not support modification of given type";
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.dynamic.ClassFileLocator;
import net.bytebuddy.dynamic.scaffold.TypeValidation;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.utility.RandomString;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.internal.util.concurrent.WeakConcurrentSet;
import org.mockito.mock.SerializableMode;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.lang.reflect.Modifier;
import java.security.ProtectionDomain;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static net.bytebuddy.implementation.MethodDelegation.to;
import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
import static net.bytebuddy.matcher.ElementMatchers.*;
public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTransformer {
static final Set<Class<?>> EXCLUDES = new HashSet<Class<?>>(Arrays.asList(Class.class,
Boolean.class,
Byte.class,
Short.class,
Character.class,
Integer.class,
Long.class,
Float.class,
Double.class,
String.class));
private final Instrumentation instrumentation;
private final ByteBuddy byteBuddy;
private final WeakConcurrentSet<Class<?>> mocked;
private final String identifier;
private final MockMethodAdvice advice;
private final BytecodeGenerator subclassEngine;
public InlineBytecodeGenerator(Instrumentation instrumentation, WeakConcurrentMap<Object, MockMethodInterceptor> mocks) {
this.instrumentation = instrumentation;
byteBuddy = new ByteBuddy()
.with(TypeValidation.DISABLED)
.with(Implementation.Context.Disabled.Factory.INSTANCE);
mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
identifier = RandomString.make();
advice = new MockMethodAdvice(mocks, identifier);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodDispatcher.set(identifier, advice);
instrumentation.addTransformer(this, true);
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
synchronized (this) {
Set<Class<?>> types = new HashSet<Class<?>>();
Class<?> type = features.mockedType;
do {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
type = type.getSuperclass();
if (!types.isEmpty()) {
try {
instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
for (Class<?> failed : types) {
mocked.remove(failed);
throw new MockitoException("Could not modify all classes " + types, exception);
Class<? extends T> mockedType = features.mockedType;
if (!features.interfaces.isEmpty()
|| features.serializableMode != SerializableMode.NONE
|| Modifier.isAbstract(features.mockedType.getModifiers())) {
mockedType = subclassEngine.mockClass(features);
return mockedType;
private void addInterfaces(Set<Class<?>> types, Class<?>[] interfaces) {
for (Class<?> type : interfaces) {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
public byte[] transform(ClassLoader loader,
String className,
Class<?> classBeingRedefined,
ProtectionDomain protectionDomain,
byte[] classfileBuffer) throws IllegalClassFormatException {
if (classBeingRedefined == null
|| !mocked.contains(classBeingRedefined)
|| EXCLUDES.contains(classBeingRedefined)) {
return null;
try {
return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.class).on(isVirtual()
.and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
.and(not(isDeclaredBy(nameStartsWith("java.")).<MethodDescription>and(isPackagePrivate())))))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForHashCode.class).on(isHashCode()))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForEquals.class).on(isEquals()))
.make()
.getBytes();
return null;
package org.mockito.internal.creation.bytebuddy;
public interface MockAccess {
MockMethodInterceptor getMockitoInterceptor();
void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
import org.mockito.mock.SerializableMode;
final SerializableMode serializableMode;
private MockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
this.serializableMode = serializableMode;
public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
return new MockFeatures<T>(mockedType, interfaces, serializableMode);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.This;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.Callable;
public class MockMethodAdvice extends MockMethodDispatcher {
final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
private final String identifier;
private final SelfCallInfo selfCallInfo = new SelfCallInfo();
public MockMethodAdvice(WeakConcurrentMap<Object, MockMethodInterceptor> interceptors, String identifier) {
this.interceptors = interceptors;
this.identifier = identifier;
private static Callable<?> enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
if (dispatcher == null || !dispatcher.isMocked(mock, origin)) {
return null;
return dispatcher.handle(mock, origin, arguments);
private static void exit(@Advice.BoxedReturn(readOnly = false) Object returned,
if (mocked != null) {
returned = mocked.call();
public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
MockMethodInterceptor interceptor = interceptors.get(instance);
if (interceptor == null) {
return null;
InterceptedInvocation.SuperMethod superMethod;
if (instance instanceof Serializable) {
superMethod = new SerializableSuperMethodCall(identifier, origin, instance, arguments);
superMethod = new SuperMethodCall(selfCallInfo, origin, instance, arguments);
return new ReturnValueWrapper(interceptor.doIntercept(instance,
origin,
arguments,
superMethod));
public boolean isMock(Object instance) {
return interceptors.containsKey(instance);
public boolean isMocked(Object instance, Method origin) {
return selfCallInfo.checkSuperCall(instance) && isMock(instance) && isNotOverridden(instance.getClass(), origin);
private static boolean isNotOverridden(Class<?> type, Method origin) {
Class<?> currentType = type;
do {
try {
return origin.equals(type.getDeclaredMethod(origin.getName(), origin.getParameterTypes()));
currentType = currentType.getSuperclass();
return true;
private static class SuperMethodCall implements InterceptedInvocation.SuperMethod {
private final SelfCallInfo selfCallInfo;
private final Method origin;
private final Object instance;
private final Object[] arguments;
private SuperMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
this.selfCallInfo = selfCallInfo;
this.origin = origin;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
origin.setAccessible(true);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
private static class SerializableSuperMethodCall implements InterceptedInvocation.SuperMethod {
private final String identifier;
private final SerializableMethod origin;
private final Object instance;
private final Object[] arguments;
private SerializableSuperMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
this.origin = new SerializableMethod(origin);
this.identifier = identifier;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
Method method = origin.getJavaMethod();
if (!Modifier.isPublic(method.getDeclaringClass().getModifiers() & method.getModifiers())) {
method.setAccessible(true);
MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instance);
if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
throw new MockitoException("Unexpected dispatcher for advice-based super call");
((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(instance);
return tryInvoke(method, instance, arguments);
private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
try {
return origin.invoke(instance, arguments);
Throwable cause = exception.getCause();
new ConditionalStackTraceFilter().filter(hideRecursiveCall(cause, new Throwable().getStackTrace().length, origin.getDeclaringClass()));
throw cause;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
private static class ReturnValueWrapper implements Callable<Object> {
private final Object returned;
private ReturnValueWrapper(Object returned) {
this.returned = returned;
public Object call() {
return returned;
private static class SelfCallInfo extends ThreadLocal<Object> {
boolean checkSuperCall(Object value) {
Object current = get();
if (current == value) {
set(null);
return false;
return true;
static class ForHashCode {
private static boolean enter(@Identifier String id,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
hashCode = System.identityHashCode(self);
static class ForEquals {
private static boolean enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
equals = self == other;
public static class ForReadObject {
public static void doReadObject(@Identifier String identifier,
objectInputStream.defaultReadObject();
MockMethodAdvice mockMethodAdvice = (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
if (mockMethodAdvice != null) {
mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
package org.mockito.internal.creation.bytebuddy;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
public abstract class MockMethodDispatcher {
private static final ConcurrentMap<String, MockMethodDispatcher> INSTANCE = new ConcurrentHashMap<String, MockMethodDispatcher>();
public static MockMethodDispatcher get(String identifier, Object mock) {
if (mock == INSTANCE) { // Avoid endless loop if ConcurrentHashMap was redefined to check for being a mock.
return null;
return INSTANCE.get(identifier);
public static void set(String identifier, MockMethodDispatcher dispatcher) {
INSTANCE.putIfAbsent(identifier, dispatcher);
public abstract Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable;
public abstract boolean isMock(Object instance);
public abstract boolean isMocked(Object instance, Method origin);
final InternalMockHandler handler;
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod) throws Throwable {
package org.mockito.internal.creation.bytebuddy;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.Platform;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
private final BytecodeGenerator cachingMockBytecodeGenerator;
public SubclassByteBuddyMockMaker() {
cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), false);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> mockedProxyType = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
T mockInstance = null;
try {
mockInstance = instantiator.newInstance(mockedProxyType);
MockAccess mockAccess = (MockAccess) mockInstance;
mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
return ensureMockIsAssignableToMockedType(settings, mockInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito mock :",
"  class to mock : " + describeClass(settings.getTypeToMock()),
"  created class : " + describeClass(mockedProxyType),
"  proxy instance class : " + describeClass(mockInstance),
"  instance creation by : " + instantiator.getClass().getSimpleName(),
"",
"You might experience classloading issues, please ask the mockito mailing-list.",
""
), cce);
throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
try {
return cachingMockBytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
throw prettifyFailure(settings, bytecodeGenerationFailed);
private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {
Class<T> typeToMock = settings.getTypeToMock();
return typeToMock.cast(mock);
private <T> RuntimeException prettifyFailure(MockCreationSettings<T> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
"Most likely it is a private class that is not visible by Mockito",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock(),
"",
"Mockito can only non-private & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
Platform.describe(),
"",
"Underlying exception : " + generationFailed
), generationFailed);
private static String describeClass(Class<?> type) {
return type == null ? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private static String describeClass(Object instance) {
return instance == null ? "null" : describeClass(instance.getClass());
public MockHandler getHandler(Object mock) {
if (!(mock instanceof MockAccess)) {
return null;
return ((MockAccess) mock).getMockitoInterceptor().getMockHandler();
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
((MockAccess) mock).setMockitoInterceptor(
new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)
);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (Modifier.isFinal(type.getModifiers())) {
return "final or anonymous class";
return join("not handled type");
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.implementation.Implementation;
import org.mockito.mock.SerializableMode;
import java.io.IOException;
import java.io.ObjectInputStream;
import static java.lang.Thread.currentThread;
import static net.bytebuddy.dynamic.Transformer.ForMethod.withModifiers;
import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER;
class SubclassBytecodeGenerator implements BytecodeGenerator {
private final Implementation readReplace;
private final ElementMatcher<? super MethodDescription> matcher;
public SubclassBytecodeGenerator() {
this(null, any());
public SubclassBytecodeGenerator(Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
this.readReplace = readReplace;
this.matcher = matcher;
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
.method(matcher)
.intercept(to(DispatcherDefaultingToRealMethod.class))
.transform(withModifiers(SynchronizationState.PLAIN))
.attribute(INCLUDING_RECEIVER)
.intercept(to(MockMethodInterceptor.ForEquals.class))
.serialVersionUid(42L)
.defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
.implement(MockAccess.class)
.intercept(FieldAccessor.ofBeanProperty());
if (features.serializableMode == SerializableMode.ACROSS_CLASSLOADERS) {
if (readReplace != null) {
builder = builder.defineMethod("readObject", void.class, Visibility.PRIVATE)
.withParameters(ObjectInputStream.class)
.throwing(ClassNotFoundException.class, IOException.class)
.intercept(readReplace);
.append(currentThread().getContextClassLoader())
import org.mockito.exceptions.base.MockitoException;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
private final BytecodeGenerator bytecodeGenerator;
public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
public <T> Class<T> mockClass(MockFeatures<T> params) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
private BytecodeGenerator bytecodeGenerator;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
if (classReference != null) {
if (generatedMockClass == null) {
generatedMockClass = generate(features);
private <T> Class<? extends T> generate(MockFeatures<T> mockFeatures) {
try {
return bytecodeGenerator.mockClass(mockFeatures);
throw prettifyFailure(mockFeatures, bytecodeGenerationFailed);
private RuntimeException prettifyFailure(MockFeatures<?> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.mockedType.getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType + ".",
"Most likely it is a private class that is not visible by Mockito",
"",
"You might be able to avoid this problem when using inline mocks.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType,
"",
"Unless you explicitly enable inline mocks, Mockito can only mock visible & non-final classes.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
"Underlying exception : " + generationFailed),
generationFailed
);
public CreationSettings<T> setSerializableMode(SerializableMode serializableMode) {
this.serializableMode = serializableMode;
return this;
public class MockHandlerImpl<T> implements InternalMockHandler<T> {
private volatile transient Method method;
this.method = method;
if (method != null) {
return method;
method = declaringClass.getDeclaredMethod(methodName, parameterTypes);
return method;
import org.mockito.internal.runners.util.FailureDetecter;
FailureDetecter listener = new FailureDetecter();
if (!filterRequested && listener.isSussessful()) {
public class FailureDetecter extends RunListener {
public boolean isSussessful() {
package org.mockito.internal.util.concurrent;
public class DetachedThreadLocal<T> implements Runnable {
final WeakConcurrentMap<Thread, T> map;
public DetachedThreadLocal(Cleaner cleaner) {
switch (cleaner) {
case THREAD:
case MANUAL:
map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
case INLINE:
map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
default:
throw new AssertionError();
public T get() {
return map.get(Thread.currentThread());
public void set(T value) {
map.put(Thread.currentThread(), value);
public void clear() {
map.remove(Thread.currentThread());
public void clearAll() {
map.clear();
public T pushTo(Thread thread) {
T value = get();
if (value != null) {
map.put(thread, inheritValue(value));
return value;
public T fetchFrom(Thread thread) {
T value = map.get(thread);
if (value != null) {
set(inheritValue(value));
return value;
public T get(Thread thread) {
return map.get(thread);
public void define(Thread thread, T value) {
map.put(thread, value);
protected T initialValue(Thread thread) {
return null;
protected T inheritValue(T value) {
return value;
public WeakConcurrentMap<Thread, T> getBackingMap() {
return map;
public void run() {
map.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
package org.mockito.internal.util.concurrent;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnable, Iterable<Map.Entry<K, V>> {
private static final AtomicLong ID = new AtomicLong();
final ConcurrentMap<WeakKey<K>, V> target;
private final Thread thread;
public WeakConcurrentMap(boolean cleanerThread) {
target = new ConcurrentHashMap<WeakKey<K>, V>();
if (cleanerThread) {
thread = new Thread(this);
thread.setName("weak-ref-cleaner-" + ID.getAndIncrement());
thread.setPriority(Thread.MIN_PRIORITY);
thread.setDaemon(true);
thread.start();
thread = null;
public V get(K key) {
if (key == null) throw new NullPointerException();
V value = target.get(new LatentKey<K>(key));
if (value == null) {
value = defaultValue(key);
if (value != null) {
V previousValue = target.putIfAbsent(new WeakKey<K>(key, this), value);
if (previousValue != null) {
value = previousValue;
return value;
public boolean containsKey(K key) {
if (key == null) throw new NullPointerException();
return target.containsKey(new LatentKey<K>(key));
public V put(K key, V value) {
if (key == null || value == null) throw new NullPointerException();
return target.put(new WeakKey<K>(key, this), value);
public V remove(K key) {
if (key == null) throw new NullPointerException();
return target.remove(new LatentKey<K>(key));
public void clear() {
target.clear();
protected V defaultValue(K key) {
return null;
public Thread getCleanerThread() {
return thread;
public void expungeStaleEntries() {
Reference<?> reference;
while ((reference = poll()) != null) {
target.remove(reference);
public int approximateSize() {
return target.size();
public void run() {
try {
while (true) {
target.remove(remove());
clear();
public Iterator<Map.Entry<K, V>> iterator() {
return new EntryIterator(target.entrySet().iterator());
private static class WeakKey<T> extends WeakReference<T> {
private final int hashCode;
WeakKey(T key, ReferenceQueue<? super T> queue) {
super(key, queue);
hashCode = System.identityHashCode(key);
public int hashCode() {
return hashCode;
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == get();
return ((WeakKey<?>) other).get() == get();
private static class LatentKey<T> {
final T key;
private final int hashCode;
LatentKey(T key) {
this.key = key;
hashCode = System.identityHashCode(key);
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == key;
return ((WeakKey<?>) other).get() == key;
public int hashCode() {
return hashCode;
public static class WithInlinedExpunction<K, V> extends WeakConcurrentMap<K, V> {
public WithInlinedExpunction() {
super(false);
public V get(K key) {
expungeStaleEntries();
return super.get(key);
public boolean containsKey(K key) {
expungeStaleEntries();
return super.containsKey(key);
public V put(K key, V value) {
expungeStaleEntries();
return super.put(key, value);
public V remove(K key) {
expungeStaleEntries();
return super.remove(key);
public Iterator<Map.Entry<K, V>> iterator() {
expungeStaleEntries();
return super.iterator();
public int approximateSize() {
expungeStaleEntries();
return super.approximateSize();
private class EntryIterator implements Iterator<Map.Entry<K, V>> {
private final Iterator<Map.Entry<WeakKey<K>, V>> iterator;
private Map.Entry<WeakKey<K>, V> nextEntry;
private K nextKey;
private EntryIterator(Iterator<Map.Entry<WeakKey<K>, V>> iterator) {
this.iterator = iterator;
findNext();
private void findNext() {
while (iterator.hasNext()) {
nextEntry = iterator.next();
nextKey = nextEntry.getKey().get();
if (nextKey != null) {
return;
nextEntry = null;
nextKey = null;
public boolean hasNext() {
return nextKey != null;
public Map.Entry<K, V> next() {
if (nextKey == null) {
throw new NoSuchElementException();
try {
return new SimpleEntry(nextKey, nextEntry);
findNext();
public void remove() {
throw new UnsupportedOperationException();
private class SimpleEntry implements Map.Entry<K, V> {
private final K key;
final Map.Entry<WeakKey<K>, V> entry;
private SimpleEntry(K key, Map.Entry<WeakKey<K>, V> entry) {
this.key = key;
this.entry = entry;
public K getKey() {
return key;
public V getValue() {
return entry.getValue();
public V setValue(V value) {
if (value == null) throw new NullPointerException();
return entry.setValue(value);
package org.mockito.internal.util.concurrent;
import java.util.Iterator;
import java.util.Map;
public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
final WeakConcurrentMap<V, Boolean> target;
public WeakConcurrentSet(Cleaner cleaner) {
switch (cleaner) {
case INLINE:
target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
break;
case THREAD:
case MANUAL:
target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
break;
default:
throw new AssertionError();
public boolean add(V value) {
return target.put(value, Boolean.TRUE) == null; // is null or Boolean.TRUE
public boolean contains(V value) {
return target.containsKey(value);
public boolean remove(V value) {
return target.remove(value);
public void clear() {
target.clear();
public int approximateSize() {
return target.approximateSize();
public void run() {
target.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
public void expungeStaleEntries() {
target.expungeStaleEntries();
public Thread getCleanerThread() {
return target.getCleanerThread();
public Iterator<V> iterator() {
return new ReducingIterator<V>(target.iterator());
private static class ReducingIterator<V> implements Iterator<V> {
private final Iterator<Map.Entry<V, Boolean>> iterator;
private ReducingIterator(Iterator<Map.Entry<V, Boolean>> iterator) {
this.iterator = iterator;
public void remove() {
iterator.remove();
public V next() {
return iterator.next().getKey();
public boolean hasNext() {
return iterator.hasNext();
import org.mockito.internal.creation.bytebuddy.TypeCachingMockBytecodeGeneratorTest;
import java.util.*;
import static junit.framework.TestCase.assertEquals;
private Set<Class<?>> failed = new HashSet<Class<?>>();
TypeCachingMockBytecodeGeneratorTest.class,
failed.add(failure.getDescription().getTestClass());
public Set<Class<?>> getFailed() {
assertEquals("Run in multiple thread failed for tests", Collections.emptySet(), runInMultipleThreads(3));
public static Set<Class<?>> runInMultipleThreads(int numberOfThreads) throws Exception {
Set<Class<?>> failed = new HashSet<Class<?>>();
failed.addAll(t.getFailed());
Set<Class<?>> failed = runInMultipleThreads(numberOfThreads);
System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds. (" + failed.size() + " tests failed)");
import static org.junit.Assume.assumeTrue;
assumeTrue("Annotation copying does not apply for inline mocks", mock(OnClass.class).getClass() != OnClass.class);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import org.junit.Test;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.InvocationContainer;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.SerializableMode;
import org.mockito.plugins.MockMaker;
import org.mockito.stubbing.Answer;
import org.mockitoutil.ClassLoaders;
import org.mockitoutil.SimpleSerializationUtil;
import org.objenesis.ObjenesisStd;
import java.io.Serializable;
import java.util.List;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockitoutil.ClassLoaders.coverageTool;
public abstract class AbstractByteBuddyMockMakerTest {
protected final MockMaker mockMaker;
public AbstractByteBuddyMockMakerTest(MockMaker mockMaker) {
this.mockMaker = mockMaker;
protected abstract Class<?> mockTypeOf(Class<?> type);
public void should_create_mock_from_interface() throws Exception {
SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyH());
Class<?> superClass = proxy.getClass().getSuperclass();
assertThat(superClass).isEqualTo(Object.class);
public void should_create_mock_from_class() throws Exception {
ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyH());
Class<?> superClass = mockTypeOf(proxy.getClass());
assertThat(superClass).isEqualTo(ClassWithoutConstructor.class);
public void should_create_mock_from_class_even_when_constructor_is_dodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyH());
assertThat(mock).isNotNull();
public void should_mocks_have_different_interceptors() throws Exception {
SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
MockHandler handlerOne = mockMaker.getHandler(mockOne);
MockHandler handlerTwo = mockMaker.getHandler(mockTwo);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_use_ancillary_Types() {
SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyH());
assertThat(mock).isInstanceOf(SomeInterface.class);
public void should_create_class_by_constructor() {
OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyH());
assertThat(mock).isNotNull();
public void should_allow_serialization() throws Exception {
SerializableClass proxy = mockMaker.createMock(serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC), dummyH());
SerializableClass serialized = SimpleSerializationUtil.serializeAndBack(proxy);
assertThat(serialized).isNotNull();
MockHandler handlerOne = mockMaker.getHandler(proxy);
MockHandler handlerTwo = mockMaker.getHandler(serialized);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_create_mock_from_class_with_super_call_to_final_method() throws Exception {
MockCreationSettings<CallingSuperMethodClass> settings = settingsWithSuperCall(CallingSuperMethodClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<CallingSuperMethodClass>(settings));
assertThat(proxy.foo()).isEqualTo("foo");
public void should_reset_mock_and_set_new_handler() throws Throwable {
MockCreationSettings<SampleClass> settings = settingsWithSuperCall(SampleClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<SampleClass>(settings));
MockHandler handler = new MockHandlerImpl<SampleClass>(settings);
mockMaker.resetMock(proxy, handler, settings);
assertThat(mockMaker.getHandler(proxy)).isSameAs(handler);
public void is_type_mockable_excludes_primitive_classes() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.mockable()).isFalse();
class SomeClass {}
interface SomeInterface {}
static class OtherClass {}
static class SerializableClass implements Serializable {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
public void instantiate_fine_when_objenesis_on_the_classpath() throws Exception {
ClassLoader classpath_with_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
.withCodeSourceUrlOf(coverageTool())
.build();
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker",
true,
classpath_with_objenesis
);
mock_maker_class_loaded_fine_until.newInstance();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
if(extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static <T> MockCreationSettings<T> serializableSettingsFor(Class<T> type, SerializableMode serializableMode) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.serializable(serializableMode);
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithSuperCall(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new CallsRealMethods());
return mockSettings;
private static MockHandler dummyH() {
return new DummyMockHandler();
private static class DummyMockHandler implements InternalMockHandler<Object> {
public Object handle(Invocation invocation) throws Throwable { return null; }
public MockCreationSettings<Object> getMockSettings() { return null; }
public InvocationContainer getInvocationContainer() { return null; }
public void setAnswersForStubbing(List<Answer<?>> list) { }
private static class SampleClass {
public String foo() {
return "foo";
private static class CallingSuperMethodClass extends SampleClass {
public String foo() {
return super.foo();
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.verify;
public class ByteBuddyMockMakerTest extends TestBase {
private ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker();
private ClassCreatingMockMaker delegate;
public void should_delegate_call() {
CreationSettings<Object> creationSettings = new CreationSettings<Object>();
MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
mockMaker.createMockType(creationSettings);
mockMaker.createMock(creationSettings, handler);
mockMaker.getHandler(this);
mockMaker.isTypeMockable(Object.class);
mockMaker.resetMock(this, handler, creationSettings);
verify(delegate).createMock(creationSettings, handler);
verify(delegate).getHandler(this);
verify(delegate).isTypeMockable(Object.class);
verify(delegate).resetMock(this, handler, creationSettings);
package org.mockito.internal.creation.bytebuddy;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import static org.assertj.core.api.Assertions.assertThat;
public class InlineByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public ExpectedException expectedException = ExpectedException.none();
public InlineByteBuddyMockMakerTest() {
super(new InlineByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type;
public void should_create_mock_from_final_class() throws Exception {
MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
FinalClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
MockCreationSettings<FinalMethodAbstractType> settings = settingsFor(FinalMethodAbstractType.class);
FinalMethodAbstractType proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(proxy.bar()).isEqualTo("bar");
public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
MockCreationSettings<FinalMethod> settings = settingsFor(FinalMethod.class, SampleInterface.class);
FinalMethod proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
public void should_throw_exception_redefining_unmodifiable_class() {
int[] array = new int[5];
MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
expectedException.expect(MockitoException.class);
expectedException.expectMessage(new BaseMatcher<String>() {
public boolean matches(Object item) {
return ((String) item).contains("Could not modify all classes");
public void describeTo(Description description) {
mockMaker.createMock(settings, new MockHandlerImpl(settings));
public void should_create_mock_from_enum() throws Exception {
MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
StackTraceElement[] stack = new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
new StackTraceElement("qux", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
Throwable throwable = new Throwable();
throwable.setStackTrace(stack);
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(throwable.getStackTrace()).isEqualTo(new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
Throwable throwable = new Throwable();
throwable.setStackTrace(new StackTraceElement[0]);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
public void should_provide_reason_for_wrapper_class() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.nonMockableReason()).isEqualTo("Cannot mock wrapper types, String.class or Class.class");
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new Returns("bar"));
if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static final class FinalClass {
public String foo() {
return "foo";
private enum EnumClass {
INSTANCE;
public String foo() {
return "foo";
private abstract static class FinalMethodAbstractType {
public final String foo() {
return "foo";
public abstract String bar();
private static class FinalMethod {
public final String foo() {
return "foo";
private static class NonFinalMethod {
public String foo() {
return "foo";
private interface SampleInterface {
String bar();
package org.mockito.internal.creation.bytebuddy;
public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public SubclassByteBuddyMockMakerTest() {
super(new SubclassByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type.getSuperclass();
import org.mockito.mock.SerializableMode;
public class TypeCachingMockBytecodeGeneratorTest {
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
import org.mockito.internal.configuration.plugins.Plugins;
import static org.junit.Assume.assumeFalse;
public void should_return_null_for_final_class_if_unsupported() throws Exception {
assumeFalse(Plugins.getMockMaker().isTypeMockable(Baz.class).mockable());
import org.mockito.internal.configuration.plugins.Plugins;
Assertions.assertThat(MockUtil.typeMockabilityOf(FinalClass.class).mockable())
.isEqualTo(Plugins.getMockMaker().isTypeMockable(FinalClass.class).mockable());
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeFalse;
public void shouldNotAllowMockingFinalClassesIfDisabled() throws Exception {
assumeFalse("Inlining mock allows mocking final classes", mock(FinalClass.class).getClass() == FinalClass.class);
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
import static org.junit.Assume.assumeTrue;
List<String> spy = spy(real);
assumeTrue("Using inline mocks, it is possible to spy on private types", spy.getClass() != real.getClass());
import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
public class MyMockMaker extends SubclassByteBuddyMockMaker {import java.util.HashMap;
import java.util.Map;
private final Map<String, String> alias;
this.alias = new HashMap<String, String>();
PluginLoader withAlias(String name, String type) {
alias.put(name, type);
return this;
String aliasType = alias.get(foundPluginClass);
if (aliasType != null) {
foundPluginClass = aliasType;
private final PluginSwitch pluginSwitch = new PluginLoader(new DefaultPluginSwitch())
.loadPlugin(PluginSwitch.class, DefaultPluginSwitch.class.getName());
private final MockMaker mockMaker = new PluginLoader(pluginSwitch)
.withAlias("mockito-inline", "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker")
.loadPlugin(MockMaker.class, "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
private final StackTraceCleanerProvider stackTraceCleanerProvider = new PluginLoader(pluginSwitch)
.loadPlugin(StackTraceCleanerProvider.class, "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider");
private final InstantiatorProvider instantiatorProvider = new PluginLoader(pluginSwitch)
.loadPlugin(InstantiatorProvider.class, "org.mockito.internal.creation.instance.DefaultInstantiatorProvider");
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.mock.SerializableMode;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import static org.mockito.internal.util.StringJoiner.join;
import static org.mockito.internal.util.reflection.FieldSetter.setField;
try {
Class<?> proxyClass = ((ClassCreatingMockMaker) Plugins.getMockMaker()).createMockType(
new CreationSettings()
.setTypeToMock(typeToMock)
.setExtraInterfaces(extraInterfaces)
.setSerializableMode(SerializableMode.ACROSS_CLASSLOADERS));
hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
return proxyClass;
throw new MockitoSerializationIssue(join(
"A Byte Buddy-generated mock cannot be deserialized into a non-Byte Buddy generated mock class",
"",
"The mock maker in use was: " + Plugins.getMockMaker().getClass()
), cce);
import org.mockito.Incubating;
public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
private ClassCreatingMockMaker defaultByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
return defaultByteBuddyMockMaker.createMock(settings, handler);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> creationSettings) {
return defaultByteBuddyMockMaker.createMockType(creationSettings);
return defaultByteBuddyMockMaker.getHandler(mock);
defaultByteBuddyMockMaker.resetMock(mock, newHandler, settings);
public TypeMockability isTypeMockable(Class<?> type) {
return defaultByteBuddyMockMaker.isTypeMockable(type);
package org.mockito.internal.creation.bytebuddy;
public interface BytecodeGenerator {
<T> Class<? extends T> mockClass(MockFeatures<T> features);
package org.mockito.internal.creation.bytebuddy;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
public interface ClassCreatingMockMaker extends MockMaker {
<T> Class<? extends T> createMockType(MockCreationSettings<T> settings);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.dynamic.ClassFileLocator;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.instrument.Instrumentation;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
import static org.mockito.internal.util.StringJoiner.join;
public class InlineByteBuddyMockMaker implements ClassCreatingMockMaker {
private final Instrumentation instrumentation;
private final BytecodeGenerator bytecodeGenerator;
private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks = new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
public InlineByteBuddyMockMaker() {
try {
instrumentation = ByteBuddyAgent.install();
if (!instrumentation.isRetransformClassesSupported()) {
throw new MockitoException("Current VM does not support retransformation");
File boot = File.createTempFile("mockitoboot", "jar");
boot.deleteOnExit();
JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
try {
outputStream.putNextEntry(new JarEntry("org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class"));
outputStream.write(ClassFileLocator.ForClassLoader.of(InlineByteBuddyMockMaker.class.getClassLoader())
.locate("org.mockito.internal.creation.bytebuddy.MockMethodDispatcher")
.resolve());
outputStream.closeEntry();
outputStream.close();
instrumentation.appendToBootstrapClassLoaderSearch(new JarFile(boot));
bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(instrumentation, mocks), true);
throw new MockitoException("Cannot apply self-instrumentation on current VM", exception);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> type = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
try {
T instance = instantiator.newInstance(type);
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(handler), settings);
mocks.put(instance, mockMethodInterceptor);
if (instance instanceof MockAccess) {
((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
return instance;
throw new MockitoException("Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
return bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
public MockHandler getHandler(Object mock) {
MockMethodInterceptor interceptor = mocks.get(mock);
if (interceptor == null) {
return null;
return interceptor.handler;
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(asInternalMockHandler(newHandler), settings);
mocks.put(mock, mockMethodInterceptor);
if (mock instanceof MockAccess) {
((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return instrumentation.isModifiableClass(type) && !EXCLUDES.contains(type);
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (EXCLUDES.contains(type)) {
return "Cannot mock wrapper types, String.class or Class.class";
return "VM does not not support modification of given type";
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.dynamic.ClassFileLocator;
import net.bytebuddy.dynamic.scaffold.TypeValidation;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.utility.RandomString;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.internal.util.concurrent.WeakConcurrentSet;
import org.mockito.mock.SerializableMode;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.lang.reflect.Modifier;
import java.security.ProtectionDomain;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static net.bytebuddy.implementation.MethodDelegation.to;
import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
import static net.bytebuddy.matcher.ElementMatchers.*;
public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTransformer {
static final Set<Class<?>> EXCLUDES = new HashSet<Class<?>>(Arrays.asList(Class.class,
Boolean.class,
Byte.class,
Short.class,
Character.class,
Integer.class,
Long.class,
Float.class,
Double.class,
String.class));
private final Instrumentation instrumentation;
private final ByteBuddy byteBuddy;
private final WeakConcurrentSet<Class<?>> mocked;
private final String identifier;
private final MockMethodAdvice advice;
private final BytecodeGenerator subclassEngine;
public InlineBytecodeGenerator(Instrumentation instrumentation, WeakConcurrentMap<Object, MockMethodInterceptor> mocks) {
this.instrumentation = instrumentation;
byteBuddy = new ByteBuddy()
.with(TypeValidation.DISABLED)
.with(Implementation.Context.Disabled.Factory.INSTANCE);
mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
identifier = RandomString.make();
advice = new MockMethodAdvice(mocks, identifier);
subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
.appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
MockMethodDispatcher.set(identifier, advice);
instrumentation.addTransformer(this, true);
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
synchronized (this) {
Set<Class<?>> types = new HashSet<Class<?>>();
Class<?> type = features.mockedType;
do {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
type = type.getSuperclass();
if (!types.isEmpty()) {
try {
instrumentation.retransformClasses(types.toArray(new Class<?>[types.size()]));
for (Class<?> failed : types) {
mocked.remove(failed);
throw new MockitoException("Could not modify all classes " + types, exception);
Class<? extends T> mockedType = features.mockedType;
if (!features.interfaces.isEmpty()
|| features.serializableMode != SerializableMode.NONE
|| Modifier.isAbstract(features.mockedType.getModifiers())) {
mockedType = subclassEngine.mockClass(features);
return mockedType;
private void addInterfaces(Set<Class<?>> types, Class<?>[] interfaces) {
for (Class<?> type : interfaces) {
if (mocked.add(type)) {
types.add(type);
addInterfaces(types, type.getInterfaces());
public byte[] transform(ClassLoader loader,
String className,
Class<?> classBeingRedefined,
ProtectionDomain protectionDomain,
byte[] classfileBuffer) throws IllegalClassFormatException {
if (classBeingRedefined == null
|| !mocked.contains(classBeingRedefined)
|| EXCLUDES.contains(classBeingRedefined)) {
return null;
try {
return byteBuddy.redefine(classBeingRedefined, ClassFileLocator.Simple.of(classBeingRedefined.getName(), classfileBuffer))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.class).on(isVirtual()
.and(not(isBridge().or(isHashCode()).or(isEquals()).or(isDefaultFinalizer())))
.and(not(isDeclaredBy(nameStartsWith("java.")).<MethodDescription>and(isPackagePrivate())))))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForHashCode.class).on(isHashCode()))
.visit(Advice.withCustomMapping()
.bind(MockMethodAdvice.Identifier.class, identifier)
.to(MockMethodAdvice.ForEquals.class).on(isEquals()))
.make()
.getBytes();
return null;
package org.mockito.internal.creation.bytebuddy;
public interface MockAccess {
MockMethodInterceptor getMockitoInterceptor();
void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
import org.mockito.mock.SerializableMode;
final SerializableMode serializableMode;
private MockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
this.serializableMode = serializableMode;
public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType, Set<Class<?>> interfaces, SerializableMode serializableMode) {
return new MockFeatures<T>(mockedType, interfaces, serializableMode);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.This;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.Callable;
public class MockMethodAdvice extends MockMethodDispatcher {
final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
private final String identifier;
private final SelfCallInfo selfCallInfo = new SelfCallInfo();
public MockMethodAdvice(WeakConcurrentMap<Object, MockMethodInterceptor> interceptors, String identifier) {
this.interceptors = interceptors;
this.identifier = identifier;
private static Callable<?> enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
if (dispatcher == null || !dispatcher.isMocked(mock, origin)) {
return null;
return dispatcher.handle(mock, origin, arguments);
private static void exit(@Advice.BoxedReturn(readOnly = false) Object returned,
if (mocked != null) {
returned = mocked.call();
public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
MockMethodInterceptor interceptor = interceptors.get(instance);
if (interceptor == null) {
return null;
InterceptedInvocation.SuperMethod superMethod;
if (instance instanceof Serializable) {
superMethod = new SerializableSuperMethodCall(identifier, origin, instance, arguments);
superMethod = new SuperMethodCall(selfCallInfo, origin, instance, arguments);
return new ReturnValueWrapper(interceptor.doIntercept(instance,
origin,
arguments,
superMethod));
public boolean isMock(Object instance) {
return interceptors.containsKey(instance);
public boolean isMocked(Object instance, Method origin) {
return selfCallInfo.checkSuperCall(instance) && isMock(instance) && isNotOverridden(instance.getClass(), origin);
private static boolean isNotOverridden(Class<?> type, Method origin) {
Class<?> currentType = type;
do {
try {
return origin.equals(type.getDeclaredMethod(origin.getName(), origin.getParameterTypes()));
currentType = currentType.getSuperclass();
return true;
private static class SuperMethodCall implements InterceptedInvocation.SuperMethod {
private final SelfCallInfo selfCallInfo;
private final Method origin;
private final Object instance;
private final Object[] arguments;
private SuperMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
this.selfCallInfo = selfCallInfo;
this.origin = origin;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
origin.setAccessible(true);
selfCallInfo.set(instance);
return tryInvoke(origin, instance, arguments);
private static class SerializableSuperMethodCall implements InterceptedInvocation.SuperMethod {
private final String identifier;
private final SerializableMethod origin;
private final Object instance;
private final Object[] arguments;
private SerializableSuperMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
this.origin = new SerializableMethod(origin);
this.identifier = identifier;
this.instance = instance;
this.arguments = arguments;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
Method method = origin.getJavaMethod();
if (!Modifier.isPublic(method.getDeclaringClass().getModifiers() & method.getModifiers())) {
method.setAccessible(true);
MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instance);
if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
throw new MockitoException("Unexpected dispatcher for advice-based super call");
((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(instance);
return tryInvoke(method, instance, arguments);
private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
try {
return origin.invoke(instance, arguments);
Throwable cause = exception.getCause();
new ConditionalStackTraceFilter().filter(hideRecursiveCall(cause, new Throwable().getStackTrace().length, origin.getDeclaringClass()));
throw cause;
static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
try {
StackTraceElement[] stack = throwable.getStackTrace();
int skip = 0;
StackTraceElement next;
do {
next = stack[stack.length - current - ++skip];
int top = stack.length - current - skip;
StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
System.arraycopy(stack, 0, cleared, 0, top);
System.arraycopy(stack, top + skip, cleared, top, current);
throwable.setStackTrace(cleared);
return throwable;
return throwable;
private static class ReturnValueWrapper implements Callable<Object> {
private final Object returned;
private ReturnValueWrapper(Object returned) {
this.returned = returned;
public Object call() {
return returned;
private static class SelfCallInfo extends ThreadLocal<Object> {
boolean checkSuperCall(Object value) {
Object current = get();
if (current == value) {
set(null);
return false;
return true;
static class ForHashCode {
private static boolean enter(@Identifier String id,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
hashCode = System.identityHashCode(self);
static class ForEquals {
private static boolean enter(@Identifier String identifier,
MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
return dispatcher != null && dispatcher.isMock(self);
private static void enter(@Advice.This Object self,
if (skipped) {
equals = self == other;
public static class ForReadObject {
public static void doReadObject(@Identifier String identifier,
objectInputStream.defaultReadObject();
MockMethodAdvice mockMethodAdvice = (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
if (mockMethodAdvice != null) {
mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
package org.mockito.internal.creation.bytebuddy;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
public abstract class MockMethodDispatcher {
private static final ConcurrentMap<String, MockMethodDispatcher> INSTANCE = new ConcurrentHashMap<String, MockMethodDispatcher>();
public static MockMethodDispatcher get(String identifier, Object mock) {
if (mock == INSTANCE) { // Avoid endless loop if ConcurrentHashMap was redefined to check for being a mock.
return null;
return INSTANCE.get(identifier);
public static void set(String identifier, MockMethodDispatcher dispatcher) {
INSTANCE.putIfAbsent(identifier, dispatcher);
public abstract Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable;
public abstract boolean isMock(Object instance);
public abstract boolean isMocked(Object instance, Method origin);
final InternalMockHandler handler;
Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod) throws Throwable {
package org.mockito.internal.creation.bytebuddy;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.util.Platform;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
private final BytecodeGenerator cachingMockBytecodeGenerator;
public SubclassByteBuddyMockMaker() {
cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), false);
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<? extends T> mockedProxyType = createMockType(settings);
Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);
T mockInstance = null;
try {
mockInstance = instantiator.newInstance(mockedProxyType);
MockAccess mockAccess = (MockAccess) mockInstance;
mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
return ensureMockIsAssignableToMockedType(settings, mockInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito mock :",
"  class to mock : " + describeClass(settings.getTypeToMock()),
"  created class : " + describeClass(mockedProxyType),
"  proxy instance class : " + describeClass(mockInstance),
"  instance creation by : " + instantiator.getClass().getSimpleName(),
"",
"You might experience classloading issues, please ask the mockito mailing-list.",
""
), cce);
throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
try {
return cachingMockBytecodeGenerator.mockClass(MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode()
));
throw prettifyFailure(settings, bytecodeGenerationFailed);
private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {
Class<T> typeToMock = settings.getTypeToMock();
return typeToMock.cast(mock);
private <T> RuntimeException prettifyFailure(MockCreationSettings<T> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
"Most likely it is a private class that is not visible by Mockito",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.getTypeToMock(),
"",
"Mockito can only non-private & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
Platform.isJava8BelowUpdate45() ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n" : "",
Platform.describe(),
"",
"Underlying exception : " + generationFailed
), generationFailed);
private static String describeClass(Class<?> type) {
return type == null ? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private static String describeClass(Object instance) {
return instance == null ? "null" : describeClass(instance.getClass());
public MockHandler getHandler(Object mock) {
if (!(mock instanceof MockAccess)) {
return null;
return ((MockAccess) mock).getMockitoInterceptor().getMockHandler();
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
((MockAccess) mock).setMockitoInterceptor(
new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)
);
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
public String nonMockableReason() {
if (type.isPrimitive()) {
return "primitive type";
if (Modifier.isFinal(type.getModifiers())) {
return "final or anonymous class";
return join("not handled type");
private static InternalMockHandler<?> asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler<?>) handler;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.implementation.Implementation;
import org.mockito.mock.SerializableMode;
import java.io.IOException;
import java.io.ObjectInputStream;
import static java.lang.Thread.currentThread;
import static net.bytebuddy.dynamic.Transformer.ForMethod.withModifiers;
import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER;
class SubclassBytecodeGenerator implements BytecodeGenerator {
private final Implementation readReplace;
private final ElementMatcher<? super MethodDescription> matcher;
public SubclassBytecodeGenerator() {
this(null, any());
public SubclassBytecodeGenerator(Implementation readReplace, ElementMatcher<? super MethodDescription> matcher) {
this.readReplace = readReplace;
this.matcher = matcher;
public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
.method(matcher)
.intercept(to(DispatcherDefaultingToRealMethod.class))
.transform(withModifiers(SynchronizationState.PLAIN))
.attribute(INCLUDING_RECEIVER)
.intercept(to(MockMethodInterceptor.ForEquals.class))
.serialVersionUid(42L)
.defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
.implement(MockAccess.class)
.intercept(FieldAccessor.ofBeanProperty());
if (features.serializableMode == SerializableMode.ACROSS_CLASSLOADERS) {
if (readReplace != null) {
builder = builder.defineMethod("readObject", void.class, Visibility.PRIVATE)
.withParameters(ObjectInputStream.class)
.throwing(ClassNotFoundException.class, IOException.class)
.intercept(readReplace);
.append(currentThread().getContextClassLoader())
class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
private final BytecodeGenerator bytecodeGenerator;
public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
public <T> Class<T> mockClass(MockFeatures<T> params) {
CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
private BytecodeGenerator bytecodeGenerator;
private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
this.bytecodeGenerator = bytecodeGenerator;
if (classReference != null) {
if (generatedMockClass == null) {
return bytecodeGenerator.mockClass(mockFeatures);
"",
"You might be able to avoid this problem when using inline mocks.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
"Unless you explicitly enable inline mocks, Mockito can only mock visible & non-final classes.",
"You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
public CreationSettings<T> setSerializableMode(SerializableMode serializableMode) {
this.serializableMode = serializableMode;
return this;
public class MockHandlerImpl<T> implements InternalMockHandler<T> {
private volatile transient Method method;
this.method = method;
if (method != null) {
return method;
method = declaringClass.getDeclaredMethod(methodName, parameterTypes);
return method;
import org.mockito.internal.runners.util.FailureDetecter;
FailureDetecter listener = new FailureDetecter();
if (!filterRequested && listener.isSussessful()) {
public class FailureDetecter extends RunListener {
public boolean isSussessful() {
package org.mockito.internal.util;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public abstract class Platform {
private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME = Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
private static final Pattern JAVA_8_DEV_VERSION_SCHEME = Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
public static final String JAVA_VERSION = System.getProperty("java.specification.version");
public static final String JVM_VERSION = System.getProperty("java.runtime.version");
public static final String JVM_VENDOR = System.getProperty("java.vm.vendor");
public static final String JVM_VENDOR_VERSION = System.getProperty("java.vm.version");
public static final String JVM_NAME = System.getProperty("java.vm.name");
public static final String JVM_INFO = System.getProperty("java.vm.info");
public static final String OS_NAME = System.getProperty("os.name");
public static final String OS_VERSION = System.getProperty("os.version");
private Platform() {}
public static String describe() {
return String.format("Java               : %s\n" +
"JVM vendor name    : %s\n" +
"JVM vendor version : %s\n" +
"JVM name           : %s\n" +
"JVM version        : %s\n" +
"JVM info           : %s\n" +
"OS name            : %s\n" +
"OS version         : %s\n",
JAVA_VERSION,
JVM_VENDOR,
JVM_VENDOR_VERSION,
JVM_NAME,
JVM_VERSION,
JVM_INFO,
OS_NAME,
OS_VERSION);
public static boolean isJava8BelowUpdate45() {
return isJava8BelowUpdate45(JVM_VERSION);
static boolean isJava8BelowUpdate45(String jvmVersion) {
Matcher matcher = JAVA_8_RELEASE_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = JAVA_8_DEV_VERSION_SCHEME.matcher(jvmVersion);
if (matcher.matches()) {
int update = Integer.parseInt(matcher.group(1));
return update < 45;
matcher = Pattern.compile("1\\.8\\.0-b\\d+").matcher(jvmVersion);
if (matcher.matches()) {
return true;
return false;
package org.mockito.internal.util.concurrent;
public class DetachedThreadLocal<T> implements Runnable {
final WeakConcurrentMap<Thread, T> map;
public DetachedThreadLocal(Cleaner cleaner) {
switch (cleaner) {
case THREAD:
case MANUAL:
map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
case INLINE:
map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
protected T defaultValue(Thread key) {
return DetachedThreadLocal.this.initialValue(key);
break;
default:
throw new AssertionError();
public T get() {
return map.get(Thread.currentThread());
public void set(T value) {
map.put(Thread.currentThread(), value);
public void clear() {
map.remove(Thread.currentThread());
public void clearAll() {
map.clear();
public T pushTo(Thread thread) {
T value = get();
if (value != null) {
map.put(thread, inheritValue(value));
return value;
public T fetchFrom(Thread thread) {
T value = map.get(thread);
if (value != null) {
set(inheritValue(value));
return value;
public T get(Thread thread) {
return map.get(thread);
public void define(Thread thread, T value) {
map.put(thread, value);
protected T initialValue(Thread thread) {
return null;
protected T inheritValue(T value) {
return value;
public WeakConcurrentMap<Thread, T> getBackingMap() {
return map;
public void run() {
map.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
package org.mockito.internal.util.concurrent;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnable, Iterable<Map.Entry<K, V>> {
private static final AtomicLong ID = new AtomicLong();
final ConcurrentMap<WeakKey<K>, V> target;
private final Thread thread;
public WeakConcurrentMap(boolean cleanerThread) {
target = new ConcurrentHashMap<WeakKey<K>, V>();
if (cleanerThread) {
thread = new Thread(this);
thread.setName("weak-ref-cleaner-" + ID.getAndIncrement());
thread.setPriority(Thread.MIN_PRIORITY);
thread.setDaemon(true);
thread.start();
thread = null;
public V get(K key) {
if (key == null) throw new NullPointerException();
V value = target.get(new LatentKey<K>(key));
if (value == null) {
value = defaultValue(key);
if (value != null) {
V previousValue = target.putIfAbsent(new WeakKey<K>(key, this), value);
if (previousValue != null) {
value = previousValue;
return value;
public boolean containsKey(K key) {
if (key == null) throw new NullPointerException();
return target.containsKey(new LatentKey<K>(key));
public V put(K key, V value) {
if (key == null || value == null) throw new NullPointerException();
return target.put(new WeakKey<K>(key, this), value);
public V remove(K key) {
if (key == null) throw new NullPointerException();
return target.remove(new LatentKey<K>(key));
public void clear() {
target.clear();
protected V defaultValue(K key) {
return null;
public Thread getCleanerThread() {
return thread;
public void expungeStaleEntries() {
Reference<?> reference;
while ((reference = poll()) != null) {
target.remove(reference);
public int approximateSize() {
return target.size();
public void run() {
try {
while (true) {
target.remove(remove());
clear();
public Iterator<Map.Entry<K, V>> iterator() {
return new EntryIterator(target.entrySet().iterator());
private static class WeakKey<T> extends WeakReference<T> {
private final int hashCode;
WeakKey(T key, ReferenceQueue<? super T> queue) {
super(key, queue);
hashCode = System.identityHashCode(key);
public int hashCode() {
return hashCode;
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == get();
return ((WeakKey<?>) other).get() == get();
private static class LatentKey<T> {
final T key;
private final int hashCode;
LatentKey(T key) {
this.key = key;
hashCode = System.identityHashCode(key);
public boolean equals(Object other) {
if (other instanceof LatentKey<?>) {
return ((LatentKey<?>) other).key == key;
return ((WeakKey<?>) other).get() == key;
public int hashCode() {
return hashCode;
public static class WithInlinedExpunction<K, V> extends WeakConcurrentMap<K, V> {
public WithInlinedExpunction() {
super(false);
public V get(K key) {
expungeStaleEntries();
return super.get(key);
public boolean containsKey(K key) {
expungeStaleEntries();
return super.containsKey(key);
public V put(K key, V value) {
expungeStaleEntries();
return super.put(key, value);
public V remove(K key) {
expungeStaleEntries();
return super.remove(key);
public Iterator<Map.Entry<K, V>> iterator() {
expungeStaleEntries();
return super.iterator();
public int approximateSize() {
expungeStaleEntries();
return super.approximateSize();
private class EntryIterator implements Iterator<Map.Entry<K, V>> {
private final Iterator<Map.Entry<WeakKey<K>, V>> iterator;
private Map.Entry<WeakKey<K>, V> nextEntry;
private K nextKey;
private EntryIterator(Iterator<Map.Entry<WeakKey<K>, V>> iterator) {
this.iterator = iterator;
findNext();
private void findNext() {
while (iterator.hasNext()) {
nextEntry = iterator.next();
nextKey = nextEntry.getKey().get();
if (nextKey != null) {
return;
nextEntry = null;
nextKey = null;
public boolean hasNext() {
return nextKey != null;
public Map.Entry<K, V> next() {
if (nextKey == null) {
throw new NoSuchElementException();
try {
return new SimpleEntry(nextKey, nextEntry);
findNext();
public void remove() {
throw new UnsupportedOperationException();
private class SimpleEntry implements Map.Entry<K, V> {
private final K key;
final Map.Entry<WeakKey<K>, V> entry;
private SimpleEntry(K key, Map.Entry<WeakKey<K>, V> entry) {
this.key = key;
this.entry = entry;
public K getKey() {
return key;
public V getValue() {
return entry.getValue();
public V setValue(V value) {
if (value == null) throw new NullPointerException();
return entry.setValue(value);
package org.mockito.internal.util.concurrent;
import java.util.Iterator;
import java.util.Map;
public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
final WeakConcurrentMap<V, Boolean> target;
public WeakConcurrentSet(Cleaner cleaner) {
switch (cleaner) {
case INLINE:
target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
break;
case THREAD:
case MANUAL:
target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
break;
default:
throw new AssertionError();
public boolean add(V value) {
return target.put(value, Boolean.TRUE) == null; // is null or Boolean.TRUE
public boolean contains(V value) {
return target.containsKey(value);
public boolean remove(V value) {
return target.remove(value);
public void clear() {
target.clear();
public int approximateSize() {
return target.approximateSize();
public void run() {
target.run();
public enum Cleaner {
THREAD, INLINE, MANUAL
public void expungeStaleEntries() {
target.expungeStaleEntries();
public Thread getCleanerThread() {
return target.getCleanerThread();
public Iterator<V> iterator() {
return new ReducingIterator<V>(target.iterator());
private static class ReducingIterator<V> implements Iterator<V> {
private final Iterator<Map.Entry<V, Boolean>> iterator;
private ReducingIterator(Iterator<Map.Entry<V, Boolean>> iterator) {
this.iterator = iterator;
public void remove() {
iterator.remove();
public V next() {
return iterator.next().getKey();
public boolean hasNext() {
return iterator.hasNext();
import org.mockito.internal.creation.bytebuddy.TypeCachingMockBytecodeGeneratorTest;
import java.util.*;
import static junit.framework.TestCase.assertEquals;
private Set<Class<?>> failed = new HashSet<Class<?>>();
TypeCachingMockBytecodeGeneratorTest.class,
failed.add(failure.getDescription().getTestClass());
public Set<Class<?>> getFailed() {
assertEquals("Run in multiple thread failed for tests", Collections.emptySet(), runInMultipleThreads(3));
public static Set<Class<?>> runInMultipleThreads(int numberOfThreads) throws Exception {
Set<Class<?>> failed = new HashSet<Class<?>>();
failed.addAll(t.getFailed());
Set<Class<?>> failed = runInMultipleThreads(numberOfThreads);
System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds. (" + failed.size() + " tests failed)");
import static org.junit.Assume.assumeTrue;
assumeTrue("Annotation copying does not apply for inline mocks", mock(OnClass.class).getClass() != OnClass.class);
package org.mockito.internal.creation.bytebuddy;
import net.bytebuddy.ByteBuddy;
import org.junit.Test;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.InvocationContainer;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.SerializableMode;
import org.mockito.plugins.MockMaker;
import org.mockito.stubbing.Answer;
import org.mockitoutil.ClassLoaders;
import org.mockitoutil.SimpleSerializationUtil;
import org.objenesis.ObjenesisStd;
import java.io.Serializable;
import java.util.List;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockitoutil.ClassLoaders.coverageTool;
public abstract class AbstractByteBuddyMockMakerTest {
protected final MockMaker mockMaker;
public AbstractByteBuddyMockMakerTest(MockMaker mockMaker) {
this.mockMaker = mockMaker;
protected abstract Class<?> mockTypeOf(Class<?> type);
public void should_create_mock_from_interface() throws Exception {
SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyH());
Class<?> superClass = proxy.getClass().getSuperclass();
assertThat(superClass).isEqualTo(Object.class);
public void should_create_mock_from_class() throws Exception {
ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyH());
Class<?> superClass = mockTypeOf(proxy.getClass());
assertThat(superClass).isEqualTo(ClassWithoutConstructor.class);
public void should_create_mock_from_class_even_when_constructor_is_dodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyH());
assertThat(mock).isNotNull();
public void should_mocks_have_different_interceptors() throws Exception {
SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
MockHandler handlerOne = mockMaker.getHandler(mockOne);
MockHandler handlerTwo = mockMaker.getHandler(mockTwo);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_use_ancillary_Types() {
SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyH());
assertThat(mock).isInstanceOf(SomeInterface.class);
public void should_create_class_by_constructor() {
OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyH());
assertThat(mock).isNotNull();
public void should_allow_serialization() throws Exception {
SerializableClass proxy = mockMaker.createMock(serializableSettingsFor(SerializableClass.class, SerializableMode.BASIC), dummyH());
SerializableClass serialized = SimpleSerializationUtil.serializeAndBack(proxy);
assertThat(serialized).isNotNull();
MockHandler handlerOne = mockMaker.getHandler(proxy);
MockHandler handlerTwo = mockMaker.getHandler(serialized);
assertThat(handlerOne).isNotSameAs(handlerTwo);
public void should_create_mock_from_class_with_super_call_to_final_method() throws Exception {
MockCreationSettings<CallingSuperMethodClass> settings = settingsWithSuperCall(CallingSuperMethodClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<CallingSuperMethodClass>(settings));
assertThat(proxy.foo()).isEqualTo("foo");
public void should_reset_mock_and_set_new_handler() throws Throwable {
MockCreationSettings<SampleClass> settings = settingsWithSuperCall(SampleClass.class);
SampleClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<SampleClass>(settings));
MockHandler handler = new MockHandlerImpl<SampleClass>(settings);
mockMaker.resetMock(proxy, handler, settings);
assertThat(mockMaker.getHandler(proxy)).isSameAs(handler);
public void is_type_mockable_excludes_primitive_classes() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.mockable()).isFalse();
class SomeClass {}
interface SomeInterface {}
static class OtherClass {}
static class SerializableClass implements Serializable {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
public void instantiate_fine_when_objenesis_on_the_classpath() throws Exception {
ClassLoader classpath_with_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
.withCodeSourceUrlOf(coverageTool())
.build();
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker",
true,
classpath_with_objenesis
);
mock_maker_class_loaded_fine_until.newInstance();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
if(extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static <T> MockCreationSettings<T> serializableSettingsFor(Class<T> type, SerializableMode serializableMode) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.serializable(serializableMode);
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithSuperCall(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new CallsRealMethods());
return mockSettings;
private static MockHandler dummyH() {
return new DummyMockHandler();
private static class DummyMockHandler implements InternalMockHandler<Object> {
public Object handle(Invocation invocation) throws Throwable { return null; }
public MockCreationSettings<Object> getMockSettings() { return null; }
public InvocationContainer getInvocationContainer() { return null; }
public void setAnswersForStubbing(List<Answer<?>> list) { }
private static class SampleClass {
public String foo() {
return "foo";
private static class CallingSuperMethodClass extends SampleClass {
public String foo() {
return super.foo();
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.verify;
public class ByteBuddyMockMakerTest extends TestBase {
private ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker();
private ClassCreatingMockMaker delegate;
public void should_delegate_call() {
CreationSettings<Object> creationSettings = new CreationSettings<Object>();
MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
mockMaker.createMockType(creationSettings);
mockMaker.createMock(creationSettings, handler);
mockMaker.getHandler(this);
mockMaker.isTypeMockable(Object.class);
mockMaker.resetMock(this, handler, creationSettings);
verify(delegate).createMock(creationSettings, handler);
verify(delegate).getHandler(this);
verify(delegate).isTypeMockable(Object.class);
verify(delegate).resetMock(this, handler, creationSettings);
package org.mockito.internal.creation.bytebuddy;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.handler.MockHandlerImpl;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import static org.assertj.core.api.Assertions.assertThat;
public class InlineByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public ExpectedException expectedException = ExpectedException.none();
public InlineByteBuddyMockMakerTest() {
super(new InlineByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type;
public void should_create_mock_from_final_class() throws Exception {
MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
FinalClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
MockCreationSettings<FinalMethodAbstractType> settings = settingsFor(FinalMethodAbstractType.class);
FinalMethodAbstractType proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(proxy.bar()).isEqualTo("bar");
public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
MockCreationSettings<FinalMethod> settings = settingsFor(FinalMethod.class, SampleInterface.class);
FinalMethod proxy = mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
public void should_throw_exception_redefining_unmodifiable_class() {
int[] array = new int[5];
MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
expectedException.expect(MockitoException.class);
expectedException.expectMessage(new BaseMatcher<String>() {
public boolean matches(Object item) {
return ((String) item).contains("Could not modify all classes");
public void describeTo(Description description) {
mockMaker.createMock(settings, new MockHandlerImpl(settings));
public void should_create_mock_from_enum() throws Exception {
MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
assertThat(proxy.foo()).isEqualTo("bar");
public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
StackTraceElement[] stack = new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
new StackTraceElement("qux", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
Throwable throwable = new Throwable();
throwable.setStackTrace(stack);
throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
assertThat(throwable.getStackTrace()).isEqualTo(new StackTraceElement[]{
new StackTraceElement("foo", "", "", -1),
new StackTraceElement("bar", "", "", -1),
new StackTraceElement("baz", "", "", -1)
public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
Throwable throwable = new Throwable();
throwable.setStackTrace(new StackTraceElement[0]);
assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class)).isSameAs(throwable);
public void should_provide_reason_for_wrapper_class() {
MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
assertThat(mockable.nonMockableReason()).isEqualTo("Cannot mock wrapper types, String.class or Class.class");
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class<?>... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
mockSettings.defaultAnswer(new Returns("bar"));
if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static final class FinalClass {
public String foo() {
return "foo";
private enum EnumClass {
INSTANCE;
public String foo() {
return "foo";
private abstract static class FinalMethodAbstractType {
public final String foo() {
return "foo";
public abstract String bar();
private static class FinalMethod {
public final String foo() {
return "foo";
private static class NonFinalMethod {
public String foo() {
return "foo";
private interface SampleInterface {
String bar();
package org.mockito.internal.creation.bytebuddy;
public class SubclassByteBuddyMockMakerTest extends AbstractByteBuddyMockMakerTest {
public SubclassByteBuddyMockMakerTest() {
super(new SubclassByteBuddyMockMaker());
protected Class<?> mockTypeOf(Class<?> type) {
return type.getSuperclass();
import org.mockito.mock.SerializableMode;
public class TypeCachingMockBytecodeGeneratorTest {
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
SerializableMode.NONE
import org.mockito.internal.configuration.plugins.Plugins;
import static org.junit.Assume.assumeFalse;
public void should_return_null_for_final_class_if_unsupported() throws Exception {
assumeFalse(Plugins.getMockMaker().isTypeMockable(Baz.class).mockable());
import org.mockito.internal.configuration.plugins.Plugins;
Assertions.assertThat(MockUtil.typeMockabilityOf(FinalClass.class).mockable())
.isEqualTo(Plugins.getMockMaker().isTypeMockable(FinalClass.class).mockable());
package org.mockito.internal.util;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.HashMap;
import java.util.Map;
import org.junit.Test;
public class PlatformTest {
public void const_are_initialized_from_system_properties() {
assertThat(Platform.JVM_VERSION).isEqualTo(System.getProperty("java.runtime.version"));
assertThat(Platform.JVM_INFO).isEqualTo(System.getProperty("java.vm.info"));
assertThat(Platform.JVM_NAME).isEqualTo(System.getProperty("java.vm.name"));
assertThat(Platform.JVM_VENDOR).isEqualTo(System.getProperty("java.vm.vendor"));
assertThat(Platform.JVM_VENDOR_VERSION).isEqualTo(System.getProperty("java.vm.version"));
public void should_parse_open_jdk_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("1.8.0_92-b14", false);
put("1.8.0-b24", true);
put("1.8.0_5", true);
put("1.8.0b5_u44", true);
put("1.8.0b5_u92", false);
put("1.7.0_4", false);
put("1.4.0_03-b04", false);
put("1.4.0_03-ea-b01", false);
put("pxi3270_27sr4-20160303_03 (SR4)", false);
put("pwi3260sr11-20120412_01 (SR11)", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
public void should_parse_open_jdk9_string() {
Map<String, Boolean> versions = new HashMap<String, Boolean>() {{
put("9-ea+73", false);
put("9+100", false);
put("9.1.2+62", false);
put("9.0.1+20", false);
assertPlatformParsesCorrectlyVariousVersionScheme(versions);
private void assertPlatformParsesCorrectlyVariousVersionScheme(Map<String, Boolean> versions) {
for (Map.Entry<String, Boolean> version : versions.entrySet()) {
assertThat(Platform.isJava8BelowUpdate45(version.getKey())).describedAs(version.getKey())
.isEqualTo(version.getValue());
verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeTrue;
assumeTrue("Does not apply for inline mocks", withFinal.getClass() != WithFinal.class);
import static org.junit.Assume.assumeFalse;
public void shouldNotAllowMockingFinalClassesIfDisabled() throws Exception {
assumeFalse("Inlining mock allows mocking final classes", mock(FinalClass.class).getClass() == FinalClass.class);
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
assumeTrue("Test can only be executed on Java 8 capable VMs", ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V8));
import static org.junit.Assume.assumeTrue;
List<String> spy = spy(real);
assumeTrue("Using inline mocks, it is possible to spy on private types", spy.getClass() != real.getClass());
import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
public class MyMockMaker extends SubclassByteBuddyMockMaker {import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
"  class to mock : " + describeClass(mockedProxyType),
"  created class : " + describeClass(settings.getTypeToMock()),
return cachingMockBytecodeGenerator.get(mockFeatures);
import org.mockito.exceptions.base.MockitoException;
import java.lang.reflect.Modifier;
import static org.mockito.internal.util.StringJoiner.join;
generatedMockClass = generate(features);
private <T> Class<? extends T> generate(MockFeatures<T> mockFeatures) {
try {
return generator.generateMockClass(mockFeatures);
throw prettifyFailure(mockFeatures, bytecodeGenerationFailed);
private RuntimeException prettifyFailure(MockFeatures<?> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.mockedType.getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType + ".",
"Most likely it is a private class that is not visible by Mockito",
""
), generationFailed);
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType,
"",
"Mockito can only mock visible & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list.",
"",
"Underlying exception : " + generationFailed),
generationFailed
);
import org.mockito.Mockito;
verify(mock).simpleMethod(Mockito.<Object>any());
verify(mock).simpleMethod(Mockito.<Object>anyObject());verify(mock).simpleMethod(any());
verify(mock).simpleMethod(anyObject());import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
import java.util.Collection;
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer1<T, A> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer1<A> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer2<T, A, B> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer2<A, B> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C> Answer<T> answer(AnswerFunctionalInterfaces.Answer3<T, A, B, C> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer3<A, B, C> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C, D> Answer<T> answer(AnswerFunctionalInterfaces.Answer4<T, A, B, C, D> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C, D> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer4<A, B, C, D> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C, D, E> Answer<T> answer(AnswerFunctionalInterfaces.Answer5<T, A, B, C, D, E> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C, D, E> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer5<A, B, C, D, E> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public interface Answer1<T, A> {
T answer(A a);
public interface VoidAnswer1<A> {
void answer(A a);
public interface Answer2<T, A, B> {
T answer(A a, B b);
public interface VoidAnswer2< A, B> {
void answer(A a, B b);
public interface Answer3<T, A, B, C> {
T answer(A a, B b, C c);
public interface VoidAnswer3< A, B, C> {
void answer(A a, B b, C c);
public interface Answer4<T, A, B, C, D> {
T answer(A a, B b, C c, D d);
public interface VoidAnswer4<A, B, C, D> {
void answer(A a, B b, C c, D d);
public interface Answer5<T, A, B, C, D, E> {
T answer(A a, B b, C c, D d, E e);
public interface VoidAnswer5< A, B, C, D, E> {
void answer(A a, B b, C c, D d, E e);
import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.AdditionalAnswers.*;
import static org.mockito.BDDMockito.*;
.will(answer(new AnswerFunctionalInterfaces.Answer1<String, String>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer1<String>() {
.will(answer(new AnswerFunctionalInterfaces.Answer2<String, String, Integer>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer2<String, Integer>() {
.will(answer(new AnswerFunctionalInterfaces.Answer3<String, Integer, String, String>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer3<Integer, String, String>() {
.will(answer(new AnswerFunctionalInterfaces.Answer4<String, Integer, String, String, boolean[]>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer4<Integer, String, String, boolean[]>() {
.will(answer(new AnswerFunctionalInterfaces.Answer5<String, String, Integer, Integer, Integer, Integer>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer5<String, Integer, Integer, Integer, Integer>() {verify(mock, timeout(50)).oneArg('1');import java.util.concurrent.TimeUnit;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
callAsyncWithDelay(mock, '1', 20, MILLISECONDS);
callAsyncWithDelay(mock, '1', 20, MILLISECONDS);
callAsyncWithDelay(mock, '1', 20, MILLISECONDS);
callAsyncWithDelay(mock, '1', 20, MILLISECONDS);
callAsyncWithDelay(mock, '1', 20, MILLISECONDS);
private void callAsyncWithDelay(final IMethods mock, final char value, long delay, TimeUnit unit) {
Runnable task = new Runnable() {
public void run() {
mock.oneArg(value);
executor.schedule(task, delay, unit);
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 20);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 30);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 20);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 20);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 20);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 20);
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 0);
delayedExecution.recordAsyncCall('0');
delayedExecution.recordAsyncCall('1');
delayedExecution.recordAsyncCall('2');
verify(mock, timeout(50)).oneArg('0');
DelayedExecution delayedExecution = new DelayedExecution(executor, mock, 30);
private static class DelayedExecution {
private final ScheduledExecutorService executor;
private final IMethods mock;
private final int delay;
private final ArrayList<Character> invocations = new ArrayList<Character>();
public DelayedExecution(ScheduledExecutorService executor, IMethods mock, int delay) {
this.executor = executor;
this.mock = mock;
this.delay = delay;
public void recordAsyncCall(char c) {
invocations.add(c);
public void allAsyncCallsStarted() throws InterruptedException {
final CountDownLatch countDownLatch = new CountDownLatch(invocations.size());
for (final Character invocation : invocations) {
executor.execute(runnable(countDownLatch, invocation));
countDownLatch.await();
private Runnable runnable(final CountDownLatch countDownLatch, final Character invocation) {
return new Runnable() {
public void run() {
countDownLatch.countDown();
sleep();
mock.oneArg(invocation.charValue());
private void sleep() {
try {
Thread.sleep(delay);
throw new RuntimeException(e);import static org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer;
import java.util.Collection;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.Answer2;
import org.mockito.stubbing.Answer3;
import org.mockito.stubbing.Answer4;
import org.mockito.stubbing.Answer5;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.stubbing.VoidAnswer2;
import org.mockito.stubbing.VoidAnswer3;
import org.mockito.stubbing.VoidAnswer4;
import org.mockito.stubbing.VoidAnswer5;
public static <T, A> Answer<T> answer(Answer1<T, A> answer) {
return toAnswer(answer);
public static <A> Answer<Void> answerVoid(VoidAnswer1<A> answer) {
return toAnswer(answer);
public static <T, A, B> Answer<T> answer(Answer2<T, A, B> answer) {
return toAnswer(answer);
public static <A, B> Answer<Void> answerVoid(VoidAnswer2<A, B> answer) {
return toAnswer(answer);
public static <T, A, B, C> Answer<T> answer(Answer3<T, A, B, C> answer) {
return toAnswer(answer);
public static <A, B, C> Answer<Void> answerVoid(VoidAnswer3<A, B, C> answer) {
return toAnswer(answer);
public static <T, A, B, C, D> Answer<T> answer(Answer4<T, A, B, C, D> answer) {
return toAnswer(answer);
public static <A, B, C, D> Answer<Void> answerVoid(VoidAnswer4<A, B, C, D> answer) {
return toAnswer(answer);
public static <T, A, B, C, D, E> Answer<T> answer(Answer5<T, A, B, C, D, E> answer) {
return toAnswer(answer);
public static <A, B, C, D, E> Answer<Void> answerVoid(VoidAnswer5<A, B, C, D, E> answer) {
return toAnswer(answer);
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.Answer2;
import org.mockito.stubbing.Answer3;
import org.mockito.stubbing.Answer4;
import org.mockito.stubbing.Answer5;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.stubbing.VoidAnswer2;
import org.mockito.stubbing.VoidAnswer3;
import org.mockito.stubbing.VoidAnswer4;
import org.mockito.stubbing.VoidAnswer5;
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface Answer1<T, A> {
T answer(A a);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface Answer2<T, A, B> {
T answer(A a, B b);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface Answer3<T, A, B, C> {
T answer(A a, B b, C c);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface Answer4<T, A, B, C, D> {
T answer(A a, B b, C c, D d);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface Answer5<T, A, B, C, D, E> {
T answer(A a, B b, C c, D d, E e);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface VoidAnswer1<A> {
void answer(A a);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface VoidAnswer2<A, B> {
void answer(A a, B b);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface VoidAnswer3<A, B, C> {
void answer(A a, B b, C c);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface VoidAnswer4<A, B, C, D> {
void answer(A a, B b, C c, D d);
package org.mockito.stubbing;
import org.mockito.Incubating;
public interface VoidAnswer5<A, B, C, D, E> {
void answer(A a, B b, C c, D d, E e);
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.AdditionalAnswers.answer;
import static org.mockito.AdditionalAnswers.answerVoid;
import static org.mockito.AdditionalAnswers.returnsArgAt;
import static org.mockito.AdditionalAnswers.returnsFirstArg;
import static org.mockito.AdditionalAnswers.returnsLastArg;
import static org.mockito.AdditionalAnswers.returnsSecondArg;
import static org.mockito.BDDMockito.any;
import static org.mockito.BDDMockito.anyInt;
import static org.mockito.BDDMockito.anyObject;
import static org.mockito.BDDMockito.anyString;
import static org.mockito.BDDMockito.anyVararg;
import static org.mockito.BDDMockito.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.mock;
import static org.mockito.BDDMockito.times;
import static org.mockito.BDDMockito.verify;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.Answer2;
import org.mockito.stubbing.Answer3;
import org.mockito.stubbing.Answer4;
import org.mockito.stubbing.Answer5;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.stubbing.VoidAnswer2;
import org.mockito.stubbing.VoidAnswer3;
import org.mockito.stubbing.VoidAnswer4;
import org.mockito.stubbing.VoidAnswer5;
.will(answer(new Answer1<String, String>() {
.will(answerVoid(new VoidAnswer1<String>() {
.will(answer(new Answer2<String, String, Integer>() {
.will(answerVoid(new VoidAnswer2<String, Integer>() {
.will(answer(new Answer3<String, Integer, String, String>() {
.will(answerVoid(new VoidAnswer3<Integer, String, String>() {
.will(answer(new Answer4<String, Integer, String, String, boolean[]>() {
.will(answerVoid(new VoidAnswer4<Integer, String, String, boolean[]>() {
.will(answer(new Answer5<String, String, Integer, Integer, Integer, Integer>() {
.will(answerVoid(new VoidAnswer5<String, Integer, Integer, Integer, Integer>() {
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import java.util.concurrent.TimeUnit;
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 30, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
public void canIgnoreInvocationsWithJunit() {
callAsyncWithDelay(mock, '0', 0, MILLISECONDS);
callAsyncWithDelay(mock, '1', 0, MILLISECONDS);
callAsyncWithDelay(mock, '2', 20, MILLISECONDS);
callAsyncWithDelay(mock, '1', 30, MILLISECONDS);
private void callAsyncWithDelay(final IMethods mock, final char value, long delay, TimeUnit unit) {
Runnable task = new Runnable() {
public void run() {
mock.oneArg(value);
executor.schedule(task, delay, unit);import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
import java.util.Collection;
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer1<T, A> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer1<A> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer2<T, A, B> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer2<A, B> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C> Answer<T> answer(AnswerFunctionalInterfaces.Answer3<T, A, B, C> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer3<A, B, C> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C, D> Answer<T> answer(AnswerFunctionalInterfaces.Answer4<T, A, B, C, D> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C, D> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer4<A, B, C, D> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <T, A, B, C, D, E> Answer<T> answer(AnswerFunctionalInterfaces.Answer5<T, A, B, C, D, E> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public static <A, B, C, D, E> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer5<A, B, C, D, E> answer) {
return AnswerFunctionalInterfaces.toAnswer(answer);
public interface Answer1<T, A> {
T answer(A a);
public interface VoidAnswer1<A> {
void answer(A a);
public interface Answer2<T, A, B> {
T answer(A a, B b);
public interface VoidAnswer2< A, B> {
void answer(A a, B b);
public interface Answer3<T, A, B, C> {
T answer(A a, B b, C c);
public interface VoidAnswer3< A, B, C> {
void answer(A a, B b, C c);
public interface Answer4<T, A, B, C, D> {
T answer(A a, B b, C c, D d);
public interface VoidAnswer4<A, B, C, D> {
void answer(A a, B b, C c, D d);
public interface Answer5<T, A, B, C, D, E> {
T answer(A a, B b, C c, D d, E e);
public interface VoidAnswer5< A, B, C, D, E> {
void answer(A a, B b, C c, D d, E e);
import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.AdditionalAnswers.*;
import static org.mockito.BDDMockito.*;
.will(answer(new AnswerFunctionalInterfaces.Answer1<String, String>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer1<String>() {
.will(answer(new AnswerFunctionalInterfaces.Answer2<String, String, Integer>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer2<String, Integer>() {
.will(answer(new AnswerFunctionalInterfaces.Answer3<String, Integer, String, String>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer3<Integer, String, String>() {
.will(answer(new AnswerFunctionalInterfaces.Answer4<String, Integer, String, String, boolean[]>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer4<Integer, String, String, boolean[]>() {
.will(answer(new AnswerFunctionalInterfaces.Answer5<String, String, Integer, Integer, Integer, Integer>() {
.will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer5<String, Integer, Integer, Integer, Integer>() {return new NotGenericReturnTypeSupport(type);
public NotGenericReturnTypeSupport(Type genericReturnType) {import org.mockito.release.notes.improvements.ImprovementsProvider;
import java.util.Map;
public String buildNotes(String version, String fromRevision, String toRevision, Map<String, String> labels) {
ImprovementSet improvements = improvementsProvider.getImprovements(contributions, labels);
import java.util.Map;
String buildNotes(String version, String fromRevision, String toRevision, Map<String, String> labels);
import org.mockito.release.util.MultiMap;
import java.util.*;
final List<Improvement> improvements = new LinkedList<Improvement>();
private final Map<String, String> labels;
public DefaultImprovements(Map<String, String> labels) {
this.labels = labels;
MultiMap<String, Improvement> byLabel = new MultiMap<String, Improvement>();
Set<Improvement> remainingImprovements = new LinkedHashSet<Improvement>(improvements);
for (String label : labels.keySet()) {
for (Improvement i : improvements) {
if (i.labels.contains(label) && remainingImprovements.contains(i)) {
remainingImprovements.remove(i);
byLabel.put(label, i);
for (String label : byLabel.keySet()) {
String labelCaption = labels.get(label);
Collection<Improvement> labelImprovements = byLabel.get(label);
sb.append("\n  * ").append(labelCaption).append(": ").append(labelImprovements.size());
for (Improvement i : labelImprovements) {
sb.append("\n    * ").append(i.toText());
if (!remainingImprovements.isEmpty()) {
String indent;
if (byLabel.size() > 0) {
indent = "  ";
sb.append("\n  * Remaining changes: ").append(remainingImprovements.size());
indent = "";
for (Improvement i : remainingImprovements) {
sb.append("\n").append(indent).append("  * ").append(i.toText());
public DefaultImprovements add(Improvement improvement) {
return this;
public DefaultImprovements addAll(List<Improvement> improvements) {
return this;
import java.util.Map;
public ImprovementSet getImprovements(ContributionSet contributions, Map<String, String> labels) {
DefaultImprovements out = new DefaultImprovements(labels);
import org.json.simple.JSONArray;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.*;
Collection<String> labels = extractLabels(issue);
pagedImprovements.add(new Improvement(id, title, issueUrl, labels));
private static Collection<String> extractLabels(JSONObject issue) {
Set<String> out = new HashSet<String>();
JSONArray labels = (JSONArray) issue.get("labels");
for (Object o : labels.toArray()) {
JSONObject label = (JSONObject) o;
out.add((String) label.get("name"));
return out;
private final long id; //TODO SF String
final Collection<String> labels;
import java.util.Map;
ImprovementSet getImprovements(ContributionSet contributions, Map<String, String> labels);
package org.mockito.release.util;
import java.util.*;
public class MultiMap<K, V> {
private final Map<K, Collection<V>> data = new LinkedHashMap<K, Collection<V>>();
public Collection<V> get(K key) {
return data.get(key);
public void put(K key, V value) {
Collection<V> elements = get(key);
if (elements == null) {
elements = new LinkedHashSet<V>();
elements.add(value);
data.put(key, elements);
public Set<K> keySet() {
return data.keySet();
public int size() {
return data.size();import org.mockito.release.notes.improvements.ImprovementsProvider;
import java.util.Map;
public String buildNotes(String version, String fromRevision, String toRevision, Map<String, String> labels) {
ImprovementSet improvements = improvementsProvider.getImprovements(contributions, labels);
import java.util.Map;
String buildNotes(String version, String fromRevision, String toRevision, Map<String, String> labels);
import org.mockito.release.util.MultiMap;
import java.util.*;
final List<Improvement> improvements = new LinkedList<Improvement>();
private final Map<String, String> labels;
public DefaultImprovements(Map<String, String> labels) {
this.labels = labels;
MultiMap<String, Improvement> byLabel = new MultiMap<String, Improvement>();
Set<Improvement> remainingImprovements = new LinkedHashSet<Improvement>(improvements);
for (String label : labels.keySet()) {
for (Improvement i : improvements) {
if (i.labels.contains(label) && remainingImprovements.contains(i)) {
remainingImprovements.remove(i);
byLabel.put(label, i);
for (String label : byLabel.keySet()) {
String labelCaption = labels.get(label);
Collection<Improvement> labelImprovements = byLabel.get(label);
sb.append("\n  * ").append(labelCaption).append(": ").append(labelImprovements.size());
for (Improvement i : labelImprovements) {
sb.append("\n    * ").append(i.toText());
if (!remainingImprovements.isEmpty()) {
String indent;
if (byLabel.size() > 0) {
indent = "  ";
sb.append("\n  * Remaining changes: ").append(remainingImprovements.size());
indent = "";
for (Improvement i : remainingImprovements) {
sb.append("\n").append(indent).append("  * ").append(i.toText());
public DefaultImprovements add(Improvement improvement) {
return this;
public DefaultImprovements addAll(List<Improvement> improvements) {
return this;
import java.util.Map;
public ImprovementSet getImprovements(ContributionSet contributions, Map<String, String> labels) {
DefaultImprovements out = new DefaultImprovements(labels);
import org.json.simple.JSONArray;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.*;
Collection<String> labels = extractLabels(issue);
pagedImprovements.add(new Improvement(id, title, issueUrl, labels));
private static Collection<String> extractLabels(JSONObject issue) {
Set<String> out = new HashSet<String>();
JSONArray labels = (JSONArray) issue.get("labels");
for (Object o : labels.toArray()) {
JSONObject label = (JSONObject) o;
out.add((String) label.get("name"));
return out;
private final long id; //TODO SF String
final Collection<String> labels;
import java.util.Map;
ImprovementSet getImprovements(ContributionSet contributions, Map<String, String> labels);
package org.mockito.release.util;
import java.util.*;
public class MultiMap<K, V> {
private final Map<K, Collection<V>> data = new LinkedHashMap<K, Collection<V>>();
public Collection<V> get(K key) {
return data.get(key);
public void put(K key, V value) {
Collection<V> elements = get(key);
if (elements == null) {
elements = new LinkedHashSet<V>();
elements.add(value);
data.put(key, elements);
public Set<K> keySet() {
return data.keySet();
public int size() {
return data.size();import org.mockito.release.notes.improvements.Improvements;
public String buildNotes(String version, String fromRevision, String toRevision) {
ImprovementSet improvements = improvementsProvider.getImprovements(contributions);
String buildNotes(String version, String fromRevision, String toRevision);
import java.util.LinkedList;
import java.util.List;
for (Improvement i : improvements) {
sb.append("\n  * ").append(i.toText());
public void add(Improvement improvement) {
public void addAll(List<Improvement> improvements) {
public ImprovementSet getImprovements(ContributionSet contributions) {
DefaultImprovements out = new DefaultImprovements();
private final long id;
ImprovementSet getImprovements(ContributionSet contributions);private final Collection<Stubbing> unused;
UnusedStubbings(Collection<Stubbing> unused) {
import org.mockito.internal.util.collections.ListUtil;
Collection<Stubbing> stubbings = (Collection) AllInvocationsFinder.findStubbings(mocks);
LinkedList<Stubbing> unused = ListUtil.filter(stubbings, new ListUtil.Filter<Stubbing>() {
public boolean isOut(Stubbing s) {
Collection<Stubbing> stubbings = (Collection) AllInvocationsFinder.findStubbings(mocks);String getAuthorId();
String getAuthor();
final String authorId;
final String author;
authorId = commit.getAuthorId();
author = commit.getAuthor();
assert authorId.equals(commit.getAuthorId());
return commits.size() + ": " + author;
return Integer.valueOf(other.getCommits().size()).compareTo(commits.size());
private final Map<String, Contribution> contributions = new HashMap<String, Contribution>();
Contribution c = contributions.get(commit.getAuthorId());
if (c == null) {
contributions.put(commit.getAuthorId(), new Contribution(commit));
c.add(commit);
for (Map.Entry<String, Contribution> entry : sortByValue(contributions)) {
Contribution c = entry.getValue();
public static <K, V extends Comparable<V>> List<Map.Entry<K, V>> sortByValue(Map<K, V> map) {
List<Map.Entry<K, V>> entries = new ArrayList<Map.Entry<K, V>>(map.entrySet());
Collections.sort(entries, new ByValue<K, V>());
return entries;
private static class ByValue<K, V extends Comparable<V>> implements Comparator<Map.Entry<K, V>> {
public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
return o1.getValue().compareTo(o2.getValue());
public String getAuthorId() {
public String getAuthor() {
private ArgumentMatchingTool(){}
public static Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<ArgumentMatcher> matchers, Object[] arguments) {
private static boolean safelyMatches(ArgumentMatcher m, Object arg) {
private static boolean toStringEquals(ArgumentMatcher m, Object arg) {
import static org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes;
Integer[] indexesOfSuspiciousArgs = getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());
import org.mockito.internal.matchers.ContainsExtraTypeInfo;
import java.util.Collections;
import static java.util.Collections.singletonList;
import static org.junit.Assert.*;
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, 20 });
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, 20 });
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10, longPretendingAnInt });
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(matcherWithBadDescription), new Object[] { argument });
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] { null });
class StringMatcher implements ArgumentMatcher<String>, ContainsExtraTypeInfo {
public boolean matches(String item) {
return true; // in this test we never get here
public String toStringWithType() {
return "";
public boolean typeMatches(Object target) {
return true;
List<ArgumentMatcher> matchers = (List) singletonList(new StringMatcher());
Integer[] suspicious = ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] { 10 });
callAsyncWithDelay(mock, 'c', 20, MILLISECONDS);
verify(mock, timeout(100).only()).oneArg('c');assertEquals("(Long) 100", descStr);
assertEquals("(1, (Integer) 2);", line);
assertEquals("(1, (String) \"x\");", line);
assertEquals("(\n    (Long) 1,\n    (Integer) 2\n);", line);
assertEquals("((Long) 1, notNull());", line);
.hasMessageContaining("iMethods.forByte(25)");
.hasMessageContaining("withLong((Long) 100);");
.hasMessageContaining("withLongAndInt((Long) 100, 200)");
"    (Long) 100,\n" +
.hasMessageContaining("withLongAndInt(100, 200)")
.hasMessageContaining("withLongAndInt(100, 230)");Pattern pattern = Pattern.compile("(\\d+)\\.(\\d+)\\.(\\d+)(-(\\w+)\\.(\\d+))?");
throw new IllegalArgumentException("Unsupported version: '" + version + "'. Examples of supported versions: 1.0.0, 1.20.123, 1.0.10-beta.3");
if (matcher.group(4) != null) {
int betaVersion = Integer.parseInt(matcher.group(6));
return "" + major + "." + minor + "." + patch + "-" + matcher.group(5) + "." + (betaVersion + 1);
return "" + major + "." + minor + "." + (patch + 1);import org.mockito.listeners.StubbingListener;
void setStubbingListener(StubbingListener listener);
import org.mockito.internal.progress.MockingProgress;
import org.mockito.listeners.StubbingListener;
public void setStubbingListener(StubbingListener listener) {
MockingProgress p = mockingProgress();
if (listener == null) {
p.setStubbingListener(null);
p.setStubbingListener(new ThreadSafeStubbingListener(listener));
package org.mockito.internal.framework;
import org.mockito.invocation.Invocation;
import org.mockito.listeners.StubbingListener;
class ThreadSafeStubbingListener implements StubbingListener {
private final StubbingListener delegate;
private final Object lock = new Object();
ThreadSafeStubbingListener(StubbingListener delegate) {
this.delegate = delegate;
public void newStubbing(Invocation stubbing) {
synchronized (lock) {
delegate.newStubbing(stubbing);
public void usedStubbing(Invocation stubbing, Invocation actual) {
synchronized (lock) {
delegate.usedStubbing(stubbing, actual);
public void stubbingNotFound(Invocation actual) {
synchronized (lock) {
delegate.stubbingNotFound(actual);
class UnusedStubbings {
int size() {
import org.mockito.internal.invocation.Stubbing;
import java.util.Collection;
import java.util.LinkedList;
class UnusedStubbingsFinder {
UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
import org.mockito.internal.listeners.MockingProgressListener;
import org.mockito.listeners.StubbingListener;
void setStubbingListener(StubbingListener stubbingListener);
StubbingListener getStubbingListener();
import static org.mockito.internal.exceptions.Reporter.unfinishedStubbing;
import static org.mockito.internal.exceptions.Reporter.unfinishedVerificationException;
import org.mockito.listeners.StubbingListener;
private StubbingListener stubbingListener;
getStubbingListener().newStubbing(invocation);
use cases:
- single threaded execution throughout
- single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
- thread per test case
public void setStubbingListener(StubbingListener stubbingListener) {
this.stubbingListener = stubbingListener;
public StubbingListener getStubbingListener() {
if (this.stubbingListener == null) {
return NoOpStubbingListener.INSTANCE;
return this.stubbingListener;
package org.mockito.internal.progress;
import org.mockito.invocation.Invocation;
import org.mockito.listeners.StubbingListener;
class NoOpStubbingListener implements StubbingListener {
static StubbingListener INSTANCE = new NoOpStubbingListener();
public void newStubbing(Invocation stubbing) {}
public void usedStubbing(Invocation stubbing, Invocation actual) {}
public void stubbingNotFound(Invocation actual) {}
Mockito.framework().setStubbingListener(reporter);
Mockito.framework().setStubbingListener(null);
package org.mockito.internal.runners;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunNotifier;
import org.mockito.internal.exceptions.Reporter;
import org.mockito.invocation.Invocation;
import org.mockito.listeners.StubbingListener;
import java.util.*;
class UnnecessaryStubbingsReporter implements StubbingListener {
private final Map<String, Invocation> stubbings = new LinkedHashMap<String, Invocation>();
private final Set<String> used = new LinkedHashSet<String>();
public void newStubbing(Invocation stubbing) {
stubbings.put(stubbing.getLocation().toString(), stubbing);
public void usedStubbing(Invocation stubbing, Invocation actual) {
String location = stubbing.getLocation().toString();
used.add(location);
stubbings.remove(location);
public void stubbingNotFound(Invocation actual) {}
void validateUnusedStubs(Class<?> testClass, RunNotifier notifier) {
if (stubbings.isEmpty()) {
return;
for (String u : used) {
stubbings.remove(u);
if (stubbings.isEmpty()) {
return;
if (stubbings.isEmpty()) {
return; //whoa!!! All stubbings were used!
Description unnecessaryStubbings = Description.createTestDescription(testClass, "unnecessary Mockito stubbings");
notifier.fireTestFailure(new Failure(unnecessaryStubbings,
Reporter.formatUnncessaryStubbingException(testClass, stubbings.values())));
mockingProgress().getStubbingListener().usedStubbing(s.getInvocation(), invocation);
mockingProgress().getStubbingListener().stubbingNotFound(invocation);
package org.mockito.listeners;
import org.mockito.Incubating;
import org.mockito.invocation.Invocation;
public interface StubbingListener {
void newStubbing(Invocation stubbing);
void usedStubbing(Invocation stubbing, Invocation actual);
void stubbingNotFound(Invocation actual);
import org.junit.runners.BlockJUnit4ClassRunner;
package org.mockito.internal.junit;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import java.util.List;
import static java.util.Arrays.asList;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
public class UnusedStubbingsFinderTest extends TestBase {
UnusedStubbingsFinder finder = new UnusedStubbingsFinder();
public void no_interactions() throws Exception {
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void no_stubbings() throws Exception {
mock1.simpleMethod();
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void no_unused_stubbings() throws Exception {
when(mock1.simpleMethod()).thenReturn("1");
mock1.simpleMethod();
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void unused_stubbings() throws Exception {
when(mock1.simpleMethod()).thenReturn("1");
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(1, stubbings.size());
public void some_unused_stubbings() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
when(mock2.simpleMethod(2)).thenReturn("2");
when(mock2.simpleMethod(3)).thenReturn("3");
mock2.simpleMethod(2);
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(2, stubbings.size());
assertEquals("[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
stubbings.toString());List<Invocation> unusedStubs = new LinkedList(this.baseUnusedStubs);
List<InvocationMatcher> allInvocations = new LinkedList(this.baseAllInvocations);
private Iterator applyPrintSettings(List<ArgumentMatcher> matchers, PrintSettings printSettings) {
List out = new LinkedList();
public static <T extends Iterable> T checkItemsNotNull(T iterable, String checkedIterable) {
public MockNameImpl(String mockName, Class classToMock) {
public Class getGenericType(Field field) {        
return (Class) actual;
return (Class) ((ParameterizedType) actual).getRawType();
Map map = new HashMap();
Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O = (Comparable) mock.typeVarWithTypeParams();
private interface HasCompare extends Comparable {
List list = mock(List.class);
Map map = mock(Map.class);
protected Class findClass(String name) throws ClassNotFoundException {
private final Map<String,Class> classHashMap = new HashMap<String, Class>();import java.util.Set;
Class<?> getMockedType();
Set<Class<?>> getExtraInterfaces();
import java.util.Collection;
import java.util.Set;
return getMockHandler(toInspect).getInvocationContainer().getInvocations();
public Class<?> getMockedType() {
return getMockHandler(toInspect).getMockSettings().getTypeToMock();
public Set<Class<?>> getExtraInterfaces() {
return getMockHandler(toInspect).getMockSettings().getExtraInterfaces();
package org.mockito;
import org.junit.Test;
import org.mockito.internal.MockitoCore;
import org.mockito.invocation.Invocation;
import org.mockitoutil.TestBase;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import static junit.framework.TestCase.*;
import static org.mockito.Mockito.mock;
public class MockingDetailsTest extends TestBase {
public void should_provide_invocations() {
List<String> methodsInvoked = new ArrayList<String>() {{
add("add");
add("remove");
add("clear");
List<String> mockedList = (List<String>) mock(List.class);
mockedList.add("one");
mockedList.remove(0);
mockedList.clear();
MockingDetails mockingDetails = new MockitoCore().mockingDetails(mockedList);
Collection<Invocation> invocations = mockingDetails.getInvocations();
assertNotNull(invocations);
assertEquals(invocations.size(),3);
for (Invocation method : invocations) {
assertTrue(methodsInvoked.contains(method.getMethod().getName()));
if (method.getMethod().getName().equals("add")) {
assertEquals(method.getArguments().length,1);
assertEquals(method.getArguments()[0],"one");
public void should_handle_null_input() {
import java.util.*;
import static org.mockito.Mockito.*;
public void should_get_mocked_type() throws Exception {
assertEquals(Bar.class, mockingDetails(bar).getMockedType());
public void should_report_when_not_a_mockito_mock_on_getMockedType() throws Exception {
mockingDetails("not a mock").getMockedType();
public void should_get_extra_interfaces() throws Exception {
Bar loup = mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));
assertEquals(setOf(Observer.class, List.class), mockingDetails(loup).getExtraInterfaces());
public void should_report_when_not_a_mockito_mock_on_getExtraInterfaces() throws Exception {
mockingDetails("not a mock").getExtraInterfaces();
private <T> Set<T> setOf(T... items) {
return new HashSet<T>(Arrays.asList(items));import org.mockito.mock.MockCreationSettings;
MockCreationSettings<?> getMockCreationSettings();
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.mock.MockCreationSettings;
import static org.mockito.internal.util.MockUtil.getMockHandler;
return mockHandler().getInvocationContainer().getInvocations();
public MockCreationSettings<?> getMockCreationSettings() {
return mockHandler().getMockSettings();
private InternalMockHandler<Object> mockHandler() {
assertGoodMock();
return getMockHandler(toInspect);
private void assertGoodMock() {
if (toInspect == null) {
throw new NotAMockException("Argument passed to Mockito.mockingDetails() should be a mock, but is null!");
throw new NotAMockException("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of " + toInspect.getClass() + "!");
protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();
TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
TypeVariable typeParameter = typeParameters[i];
protected void registerTypeParametersOn(TypeVariable[] typeParameters) {
for (TypeVariable type : typeParameters) {
private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {
private BoundedType boundsOf(TypeVariable typeParameter) {
return boundsOf((TypeVariable) typeParameter.getBounds()[0]);
return boundsOf((TypeVariable) wildCardBoundedType.firstBound());
public Map<TypeVariable, Type> actualTypeArguments() {
TypeVariable[] typeParameters = rawType().getTypeParameters();
LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();
for (TypeVariable typeParameter : typeParameters) {
protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {
TypeVariable typeVariable = (TypeVariable) type;
return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) type);
private final TypeVariable[] typeParameters;
public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {
private final TypeVariable typeVariable;
private final TypeVariable[] typeParameters;
public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {
private final TypeVariable typeVariable;
public TypeVarBoundedType(TypeVariable typeVariable) {
public TypeVariable typeVariable() {
import junit.framework.TestCase;
import org.mockitousage.IMethods;
import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.mockingDetails;
public void provides_invocations() {
mock.simpleMethod(10);
mock.otherMethod();
assertEquals(0, mockingDetails(foo).getInvocations().size());
assertEquals("[mock.simpleMethod(10);, mock.otherMethod();]", mockingDetails(mock).getInvocations().toString());
public void provides_mock_creation_settings() {
assertEquals(Foo.class, mockingDetails(foo).getMockCreationSettings().getTypeToMock());
assertEquals(Bar.class, mockingDetails(bar).getMockCreationSettings().getTypeToMock());
assertEquals(0, mockingDetails(mock).getMockCreationSettings().getExtraInterfaces().size());
public void fails_when_getting_creation_settings_for_incorrect_input() {
mockingDetails(null).getMockCreationSettings();
public void fails_when_getting_invocations_when_null() {
try {
mockingDetails(null).getInvocations();
fail();
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is null!", e.getMessage());
public void fails_when_getting_invocations_when_not_mock() {
try {
mockingDetails(new Object()).getInvocations();
fail();
TestCase.assertEquals("Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Object!", e.getMessage());
private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {
for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {import java.util.Set;
Class<?> getMockedType();
Set<Class<?>> getExtraInterfaces();
import java.util.Set;
assertIsMock(toInspect);
return getMockHandler(toInspect).getInvocationContainer().getInvocations();
private void assertIsMock(Object toInspect) {
public Class<?> getMockedType() {
return getMockHandler(toInspect).getMockSettings().getTypeToMock();
public Set<Class<?>> getExtraInterfaces() {
return getMockHandler(toInspect).getMockSettings().getExtraInterfaces();
import java.util.*;
import static org.mockito.Mockito.*;
public void should_get_mocked_type() throws Exception {
assertEquals(Bar.class, mockingDetails(bar).getMockedType());
public void should_report_when_not_a_mockito_mock_on_getMockedType() throws Exception {
mockingDetails("not a mock").getMockedType();
public void should_get_extra_interfaces() throws Exception {
Bar loup = mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));
assertEquals(setOf(Observer.class, List.class), mockingDetails(loup).getExtraInterfaces());
public void should_report_when_not_a_mockito_mock_on_getExtraInterfaces() throws Exception {
mockingDetails("not a mock").getExtraInterfaces();
private <T> Set<T> setOf(T... items) {
return new HashSet<T>(Arrays.asList(items));throw new NullPointerException(checkedValue + " should not be null");import org.mockito.internal.DefaultMockitoFramework;
package org.mockito.internal;
import org.mockito.MockitoFramework;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
import org.mockito.listeners.StubbingListener;
public class DefaultMockitoFramework implements MockitoFramework {
public void setStubbingListener(StubbingListener listener) {
ThreadSafeMockingProgress.mockingProgress().setStubbingListener(listener);
mockingProgress().mockingStarted(mock, typeToMock);
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.listeners.CollectCreatedMocks;
mockingProgress().setListener(new CollectCreatedMocks(createdMocks));
" 2. you are trying to stub a final method, you naughty developer!",
"To keep the tests clean it is important to remove unnecessary code.",
"Following stubbings are declared in test but not realized during test execution:" + stubbings,
public static List<Invocation> find(List<?> mocks) {
import org.mockito.internal.debugging.WarningsCollector;
public JUnitRule(MockitoLogger logger) {
return new Statement() {
public void evaluate() throws Throwable {
WarningsCollector c = new WarningsCollector();
MockitoAnnotations.initMocks(target);
try {
base.evaluate();
logger.log(c.getWarnings());
throw t;
Mockito.validateMockitoUsage();
package org.mockito.internal.listeners;
import java.util.List;
public class CollectCreatedMocks implements MockingStartedListener {
private final List<Object> toBeFilled;
public CollectCreatedMocks(List<Object> toBeFilled) {
this.toBeFilled = toBeFilled;
public void mockingStarted(Object mock, Class<?> classToMock) {
toBeFilled.add(mock);
package org.mockito.internal.listeners;
public interface MockingStartedListener extends MockingProgressListener {
void mockingStarted(Object mock, Class<?> classToMock);
void mockingStarted(Object mock, Class<?> classToMock);
void setListener(MockingProgressListener listener);
import org.mockito.internal.listeners.MockingProgressListener;
import org.mockito.internal.listeners.MockingStartedListener;
private MockingProgressListener listener;
public void mockingStarted(Object mock, Class<?> classToMock) {
if (listener instanceof MockingStartedListener) {
((MockingStartedListener) listener).mockingStarted(mock, classToMock);
public void setListener(MockingProgressListener listener) {
this.listener = listener;
reporter.report(testClass, notifier);
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
private final Map<String, Invocation> stubbings = new HashMap<String, Invocation>();
private final Set<String> used = new HashSet<String>();
public void report(Class<?> testClass, RunNotifier notifier) {
public boolean isSussessful() {
return !failed;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
public class StubbedInvocationMatcher extends InvocationMatcher implements Answer, Serializable {
return new JUnitRule(new ConsoleMockitoLogger());
public interface MockitoRule extends MethodRule {}
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
public void shouldGetAllInvocationsInOrder() throws Exception {
List<Invocation> invocations = AllInvocationsFinder.find(asList(mockOne, mockTwo));
public void shouldNotCountDuplicatedInteractions() throws Exception {
List<Invocation> invocations = AllInvocationsFinder.find(asList(mockOne, mockOne, mockOne));
private JUnitRule jUnitRule = new JUnitRule(logger);
public void shouldInjectIntoTestCase() throws Throwable {
jUnitRule.apply(new DummyStatement(),null, injectTestCase).evaluate();
public void shouldRethrowException() throws Throwable {
jUnitRule.apply(new ExceptionStatement(), null,injectTestCase).evaluate();
public void shouldDetectUnfinishedStubbing() throws Throwable {
jUnitRule.apply(new UnfinishedStubbingStatement(),null, injectTestCase).evaluate();
public void shouldWarnAboutUnusedStubsWhenFailed() throws Throwable {
IMethods mock = Mockito.mock(IMethods.class);
declareUnusedStub(mock);
throw new AssertionError("x");
assertEquals("x", e.getMessage());
assertEquals(filterLineNo(logger.getLoggedInfo()),
"[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
"[Mockito]\n" +
"[Mockito] Unused stubbing (perhaps can be removed from the test?):\n" +
"[Mockito]\n" +
"[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:0)"
);
public void can_remove_line_numbers() throws Throwable {
assertEquals(
"[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:0)",
filterLineNo("[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:82)"));
public void shouldNotWarnAboutUnusedStubsWhenPassed() throws Throwable {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = Mockito.mock(IMethods.class);
declareUnusedStub(mock);
assertEquals("", logger.getLoggedInfo());
private static void declareUnusedStub(IMethods mock) {
Mockito.when(mock.simpleMethod("foo")).thenReturn("bar");
import org.mockito.internal.listeners.MockingStartedListener;
import java.util.List;
public void shouldNotifyListenerWhenMockingStarted() throws Exception {
MockingStartedListener listener = mock(MockingStartedListener.class);
mockingProgress.setListener(listener);
mockingProgress.mockingStarted("foo", List.class);
verify(listener).mockingStarted(eq("foo"), eq(List.class));
mockingProgress.setListener(null);
import org.junit.Before;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitoutil.TestBase;
public class ExampleTest extends TestBase {
private ArticleManager articleManager;
public void setup() {
articleManager = new ArticleManager(mockCalculator, mockDatabase);
"To keep the tests clean it is important to remove unnecessary code.\n" +
"Following stubbings are declared in test but not realized during test execution:\n" +for (Class<?> currentExploredClass = clazz;
currentExploredClass != null && currentExploredClass != Object.class;
currentExploredClass = superClassOf(currentExploredClass)) {
readActualTypeParametersOnDeclaringClass(currentExploredClass);
private Class superClassOf(Class<?> currentExploredClass) {
Type genericSuperclass = currentExploredClass.getGenericSuperclass();
if (genericSuperclass instanceof ParameterizedType) {
Type rawType = ((ParameterizedType) genericSuperclass).getRawType();
return (Class<?>) rawType;
return (Class<?>) genericSuperclass;
private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {
registerTypeVariablesOn(clazz.getGenericSuperclass());
for (Type genericInterface : clazz.getGenericInterfaces()) {
registerTypeVariablesOn(genericInterface);
registerTypeVariablesOn(parameterizedType.getRawType());
registerTypeVariablesOn(parameterizedType);
private Class<?> extractRawTypeOf(Type type) {
if (type instanceof Class) {
return (Class<?>) type;
if (type instanceof ParameterizedType) {
return (Class<?>) ((ParameterizedType) type).getRawType();
if (type instanceof BoundedType) {
return extractRawTypeOf(((BoundedType) type).firstBound());
if (type instanceof TypeVariable) {
return extractRawTypeOf(contextualActualTypeParameters.get(type));
throw new MockitoException("Raw extraction not supported for : '" + type + "'");import org.mockito.internal.framework.DefaultMockitoFramework;
import org.mockito.listeners.MockitoListener;
void addListener(MockitoListener listener);
void removeListener(MockitoListener listener);
mockingProgress().mockingStarted(mock, creationSettings);
throw cannotInitializeForInjectMocksAnnotation(field.getName(), e);
import java.util.LinkedList;
import java.util.List;
" 2. you are trying to stub a final method, which is not supported",
public static MockitoException cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {
return new MockitoException(join("Cannot instantiate @InjectMocks field named '" + fieldName + "'.",
"However, I failed because: " + details.getMessage(),
"   //also, don't forget about MockitoAnnotations.initMocks();",
""), details);
"Clean & maintainable test code requires zero unnecessary code.",
"Following stubbings are unnecessary (click to navigate to relevant line of code):" + stubbings,
package org.mockito.internal.framework;
import org.mockito.MockitoFramework;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.listeners.MockitoListener;
import org.mockito.listeners.StubbingListener;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
public class DefaultMockitoFramework implements MockitoFramework {
public void setStubbingListener(StubbingListener listener) {
MockingProgress p = mockingProgress();
if (listener == null) {
p.setStubbingListener(null);
p.setStubbingListener(new ThreadSafeStubbingListener(listener));
public void addListener(MockitoListener listener) {
assertNotNull(listener);
mockingProgress().addListener(listener);
public void removeListener(MockitoListener listener) {
assertNotNull(listener);
mockingProgress().removeListener(listener);
private void assertNotNull(MockitoListener listener) {
if (listener == null) {
throw new IllegalArgumentException("listener cannot be null");
package org.mockito.internal.framework;
import org.mockito.invocation.Invocation;
import org.mockito.listeners.StubbingListener;
class ThreadSafeStubbingListener implements StubbingListener {
private final StubbingListener delegate;
private final Object lock = new Object();
ThreadSafeStubbingListener(StubbingListener delegate) {
this.delegate = delegate;
public void newStubbing(Invocation stubbing) {
synchronized (lock) {
delegate.newStubbing(stubbing);
public void usedStubbing(Invocation stubbing, Invocation actual) {
synchronized (lock) {
delegate.usedStubbing(stubbing, actual);
public void stubbingNotFound(Invocation actual) {
synchronized (lock) {
delegate.stubbingNotFound(actual);
package org.mockito.internal.invocation;
import org.mockito.invocation.Invocation;
public interface Stubbing {
Invocation getInvocation();
boolean wasUsed();
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
public static List<Invocation> find(Iterable<?> mocks) {
public static Set<StubbedInvocationMatcher> findStubbings(Iterable<?> mocks) {
Set<StubbedInvocationMatcher> stubbings = new TreeSet<StubbedInvocationMatcher>(new SequenceNumberComparator2());
for (Object mock : mocks) {
InternalMockHandler<Object> handler = MockUtil.getMockHandler(mock);
List<StubbedInvocationMatcher> fromSingleMock = handler.getInvocationContainer().getStubbedInvocations();
stubbings.addAll(fromSingleMock);
return stubbings;
private static final class SequenceNumberComparator2 implements Comparator<StubbedInvocationMatcher> {
public int compare(StubbedInvocationMatcher o1, StubbedInvocationMatcher o2) {
return new SequenceNumberComparator().compare(o1.getInvocation(), o2.getInvocation());
package org.mockito.internal.junit;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.invocation.Invocation;
import org.mockito.internal.invocation.Stubbing;
class ArgMismatchFinder {
StubbingArgMismatches getStubbingArgMismatches(Iterable<Object> mocks) {
StubbingArgMismatches mismatches = new StubbingArgMismatches();
for (Invocation i : AllInvocationsFinder.find(mocks)) {
if (i.stubInfo() != null) {
continue;
for (Stubbing stubbing : AllInvocationsFinder.findStubbings(mocks)) {
if (!stubbing.wasUsed() && stubbing.getInvocation().getMock() == i.getMock()
&& stubbing.getInvocation().getMethod().getName().equals(i.getMethod().getName())) {
mismatches.add(i, stubbing.getInvocation());
return mismatches;
private final boolean silent;
public JUnitRule(MockitoLogger logger, boolean silent) {
this.silent = silent;
if (silent) {
return new SilentStatement(target, base);
String testName = target.getClass().getSimpleName() + "." + method.getName();
return new DefaultStatement(target, testName, base);
public JUnitRule silent() {
return new JUnitRule(logger, true);
private class SilentStatement extends Statement {
private final Object target;
private final Statement base;
public SilentStatement(Object target, Statement base) {
this.target = target;
this.base = base;
public void evaluate() throws Throwable {
MockitoAnnotations.initMocks(target);
base.evaluate();
Mockito.validateMockitoUsage();
private class DefaultStatement extends Statement {
private final Object target;
private final String testName;
private final Statement base;
DefaultStatement(Object target, String testName, Statement base) {
this.target = target;
this.testName = testName;
this.base = base;
public void evaluate() throws Throwable {
RuleStubbingHintsReporter reporter = new RuleStubbingHintsReporter();
Mockito.framework().addListener(reporter);
try {
performEvaluation(reporter);
Mockito.framework().removeListener(reporter);
private void performEvaluation(RuleStubbingHintsReporter reporter) throws Throwable {
MockitoAnnotations.initMocks(target);
try {
base.evaluate();
reporter.getStubbingArgMismatches().format(testName, logger);
throw t;
reporter.getUnusedStubbings().format(testName, logger);
Mockito.validateMockitoUsage();
package org.mockito.internal.junit;
import org.mockito.listeners.MockCreationListener;
import org.mockito.mock.MockCreationSettings;
import java.util.LinkedList;
import java.util.List;
class RuleStubbingHintsReporter implements MockCreationListener {
private final List<Object> mocks = new LinkedList<Object>();
StubbingArgMismatches getStubbingArgMismatches() {
return new ArgMismatchFinder().getStubbingArgMismatches(mocks);
UnusedStubbings getUnusedStubbings() {
return new UnusedStubbingsFinder().getUnusedStubbings(mocks);
public void onMockCreated(Object mock, MockCreationSettings settings) {
mocks.add(mock);
package org.mockito.internal.junit;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.invocation.Invocation;
import java.util.*;
class StubbingArgMismatches {
final Map<Invocation, Set<Invocation>> mismatches = new LinkedHashMap<Invocation, Set<Invocation>>();
public void add(Invocation invocation, Invocation stubbing) {
Set<Invocation> matchingInvocations = mismatches.get(stubbing);
if (matchingInvocations == null) {
matchingInvocations = new LinkedHashSet<Invocation>();
mismatches.put(stubbing, matchingInvocations);
matchingInvocations.add(invocation);
public void format(String testName, MockitoLogger logger) {
if (mismatches.isEmpty()) {
return;
StubbingHint hint = new StubbingHint(testName);
int x = 1;
for (Map.Entry<Invocation, Set<Invocation>> m : mismatches.entrySet()) {
hint.appendLine(x++, ". Unused... ", m.getKey().getLocation());
for (Invocation invocation : m.getValue()) {
hint.appendLine(" ...args ok? ", invocation.getLocation());
logger.log(hint.toString());
public int size() {
return mismatches.size();
public String toString() {
return "" + mismatches;
package org.mockito.internal.junit;
class StubbingHint {
private final StringBuilder hint;
StubbingHint(String testName) {
hint = new StringBuilder("[MockitoHint] ")
.append(testName).append(" (see javadoc for MockitoHint):");
void appendLine(Object ... elements) {
hint.append("\n[MockitoHint] ");
for (Object e : elements) {
hint.append(e);
public String toString() {
return hint.toString() + "\n";
package org.mockito.internal.junit;
import org.mockito.internal.util.MockitoLogger;
import org.mockito.internal.invocation.Stubbing;
import java.util.Collection;
class UnusedStubbings {
private final Collection<Stubbing> unused;
UnusedStubbings(Collection<Stubbing> unused) {
this.unused = unused;
void format(String testName, MockitoLogger logger) {
if (unused.isEmpty()) {
return;
StubbingHint hint = new StubbingHint(testName);
int x = 1;
for (Stubbing candidate : unused) {
if (!candidate.wasUsed()) {
hint.appendLine(x++, ". Unused ", candidate.getInvocation().getLocation());
logger.log(hint.toString());
int size() {
return unused.size();
public String toString() {
return unused.toString();
package org.mockito.internal.junit;
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
import org.mockito.internal.util.collections.ListUtil;
import org.mockito.internal.invocation.Stubbing;
import java.util.Collection;
import java.util.LinkedList;
class UnusedStubbingsFinder {
UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
Collection<Stubbing> stubbings = (Collection) AllInvocationsFinder.findStubbings(mocks);
LinkedList<Stubbing> unused = ListUtil.filter(stubbings, new ListUtil.Filter<Stubbing>() {
public boolean isOut(Stubbing s) {
return s.wasUsed();
return new UnusedStubbings(unused);
import org.mockito.listeners.MockitoListener;
import org.mockito.mock.MockCreationSettings;
void mockingStarted(Object mock, MockCreationSettings settings);
void addListener(MockitoListener listener);
void removeListener(MockitoListener listener);
import org.mockito.listeners.MockCreationListener;
import org.mockito.listeners.MockitoListener;
import org.mockito.mock.MockCreationSettings;
import java.util.LinkedHashSet;
import java.util.Set;
private final Set<MockitoListener> listeners = new LinkedHashSet<MockitoListener>();
use cases:
- single threaded execution throughout
- single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
- thread per test case
public void mockingStarted(Object mock, MockCreationSettings settings) {
for (MockitoListener listener : listeners) {
if (listener instanceof MockCreationListener) {
((MockCreationListener) listener).onMockCreated(mock, settings);
public void addListener(MockitoListener listener) {
this.listeners.add(listener);
public void removeListener(MockitoListener listener) {
this.listeners.remove(listener);
public void stubbingNotFound(Invocation actual) {}
reporter.validateUnusedStubs(testClass, notifier);
import java.util.*;
private final Map<String, Invocation> stubbings = new LinkedHashMap<String, Invocation>();
private final Set<String> used = new LinkedHashSet<String>();
public void stubbingNotFound(Invocation actual) {}
void validateUnusedStubs(Class<?> testClass, RunNotifier notifier) {
if (stubbings.isEmpty()) {
return; //whoa!!! All stubbings were used!
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
mockingProgress().getStubbingListener().stubbingNotFound(invocation);
import org.mockito.internal.invocation.Stubbing;
public class StubbedInvocationMatcher extends InvocationMatcher implements Answer, Serializable, Stubbing {
if(field.getType().isMemberClass() && !Modifier.isStatic(field.getType().getModifiers())) {
throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an inner class.");
throw new MockitoException("the type '" + field.getType().getSimpleName() + " is an abstract class.");
import org.mockito.Incubating;
return new JUnitRule(new ConsoleMockitoLogger(), false);
public interface MockitoRule extends MethodRule {
MockitoRule silent();
import org.mockito.Incubating;
package org.mockito.listeners;
import org.mockito.mock.MockCreationSettings;
public interface MockCreationListener extends MockitoListener {
void onMockCreated(Object mock, MockCreationSettings settings);
package org.mockito.listeners;
public interface MockitoListener {
void stubbingNotFound(Invocation actual);
package org.mockito.quality;
public interface MockitoHint {
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
import java.util.ArrayList;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;
import static org.mockito.internal.invocation.finder.AllInvocationsFinder.find;
import static org.mockito.internal.invocation.finder.AllInvocationsFinder.findStubbings;
public void no_interactions() throws Exception {
assertTrue(find(asList(mockOne, mockTwo)).isEmpty());
assertTrue(findStubbings(asList(mockOne, mockTwo)).isEmpty());
public void provides_invocations_in_order() throws Exception {
List<Invocation> invocations = find(asList(mockOne, mockTwo));
public void deduplicates_interactions_from_the_same_mock() throws Exception {
List<Invocation> invocations = find(asList(mockOne, mockOne, mockOne));
public void provides_stubbings_in_order() throws Exception {
mockOne.simpleMethod(50); //ignored, not a stubbing
when(mockOne.simpleMethod(100)).thenReturn("100");
when(mockOne.simpleMethod(200)).thenReturn("200");
when(mockTwo.simpleMethod(300)).thenReturn("300");
List<StubbedInvocationMatcher> stubbings = new ArrayList<StubbedInvocationMatcher>(findStubbings(asList(mockOne, mockOne, mockTwo)));
assertEquals(3, stubbings.size());
assertArgumentEquals(100, stubbings.get(0).getInvocation());
assertArgumentEquals(200, stubbings.get(1).getInvocation());
assertArgumentEquals(300, stubbings.get(2).getInvocation());
package org.mockito.internal.framework;
import org.junit.Test;
import org.mockitoutil.TestBase;
public class DefaultMockitoFrameworkTest extends TestBase {
DefaultMockitoFramework framework = new DefaultMockitoFramework();
public void prevents_adding_null_listener() {
framework.addListener(null);
public void prevents_removing_null_listener() {
framework.addListener(null);
package org.mockito.internal.junit;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import java.util.List;
import static java.util.Arrays.asList;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
public class ArgMismatchFinderTest extends TestBase {
ArgMismatchFinder finder = new ArgMismatchFinder();
public void no_interactions() throws Exception {
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(0, mismatches.size());
public void no_mismatch_when_mock_different() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
mock2.simpleMethod(2); //arg mismatch on different mock
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(0, mismatches.size());
public void no_mismatch_when_method_different() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
mock1.otherMethod();
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(0, mismatches.size());
public void no_mismatch_when_stubbing_used() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
mock1.simpleMethod(1); // stub used
mock1.simpleMethod(2); // no stubbing, but we don't want it to be reported, either
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(0, mismatches.size());
public void stubbing_mismatch() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
mock1.simpleMethod(2);
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(1, mismatches.size());
public void single_mismatch_with_multiple_invocations() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
mock1.simpleMethod(2);
mock1.simpleMethod(3);
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(1, mismatches.size());
assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(2);, mock1.simpleMethod(3);]}", mismatches.toString());
public void single_invocation_with_multiple_stubs() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
when(mock1.simpleMethod(2)).thenReturn("2");
mock1.simpleMethod(3);
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals(2, mismatches.size());
assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(3);], mock1.simpleMethod(2);=[mock1.simpleMethod(3);]}"
, mismatches.toString());
public void mismatch_reports_only_unstubbed_invocations() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1"); //unused
when(mock1.simpleMethod(2)).thenReturn("2"); //used
mock1.simpleMethod(2); //stubbed
mock1.simpleMethod(3); //unstubbed
StubbingArgMismatches mismatches = finder.getStubbingArgMismatches((List) asList(mock1, mock2));
assertEquals("{mock1.simpleMethod(1);=[mock1.simpleMethod(3);]}", mismatches.toString());
import org.junit.After;
import org.junit.runners.model.FrameworkMethod;
import static org.mockito.Mockito.mock;
private JUnitRule jUnitRule = new JUnitRule(logger, false);
private FrameworkMethod dummy = mock(FrameworkMethod.class);
resetState();
public void injects_into_test_case() throws Throwable {
jUnitRule.apply(new DummyStatement(), dummy, injectTestCase).evaluate();
public void rethrows_exception() throws Throwable {
jUnitRule.apply(new ExceptionStatement(), dummy, injectTestCase).evaluate();
public void detects_invalid_mockito_usage_on_success() throws Throwable {
jUnitRule.apply(new UnfinishedStubbingStatement(), dummy, injectTestCase).evaluate();
public void does_not_check_invalid_mockito_usage_on_failure() throws Throwable {
IMethods mock = mock(IMethods.class);
Mockito.when(mock.simpleMethod()); // <--- unfinished stubbing
throw new RuntimeException("Boo!"); // <--- some failure
assertEquals("Boo!", e.getMessage());
package org.mockito.internal.junit;
import org.junit.Test;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockito.invocation.Invocation;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
public class StubbingArgMismatchesTest extends TestBase {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
StubbingArgMismatches mismatches = new StubbingArgMismatches();
public void no_op_when_no_mismatches() throws Exception {
mismatches.format("MyTest.myTestMethod", logger);
assertTrue(logger.isEmpty());
public void logs_mismatch() throws Exception {
mismatches.add(
new InvocationBuilder().args("a").location("-> at A.java").toInvocation(),
new InvocationBuilder().args("b").location("-> at B.java").toInvocation());
mismatches.format("MyTest.myTestMethod", logger);
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused... -> at B.java\n" +
"[MockitoHint]  ...args ok? -> at A.java\n", logger.getLoggedInfo());
public void multiple_matching_invocations_per_stub_plus_some_other_invocation() throws Exception {
Invocation stubbing = new InvocationBuilder().args("a").location("-> at A.java").toInvocation();
mismatches.add(new InvocationBuilder().args("x").location("-> at X.java").toInvocation(), stubbing);
mismatches.add(new InvocationBuilder().args("y").location("-> at Y.java").toInvocation(), stubbing);
mismatches.add(
new InvocationBuilder().method("differentMethod").args("n").location("-> at N.java").toInvocation(),
new InvocationBuilder().method("differentMethod").args("m").location("-> at M.java").toInvocation());
mismatches.format("MyTest.myTestMethod", logger);
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused... -> at A.java\n" +
"[MockitoHint]  ...args ok? -> at X.java\n" +
"[MockitoHint]  ...args ok? -> at Y.java\n" +
"[MockitoHint] 2. Unused... -> at M.java\n" +
"[MockitoHint]  ...args ok? -> at N.java\n", logger.getLoggedInfo());
package org.mockito.internal.junit;
import org.junit.Test;
import org.mockito.Mock;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import java.util.List;
import static java.util.Arrays.asList;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
public class UnusedStubbingsFinderTest extends TestBase {
UnusedStubbingsFinder finder = new UnusedStubbingsFinder();
public void no_interactions() throws Exception {
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void no_stubbings() throws Exception {
mock1.simpleMethod();
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void no_unused_stubbings() throws Exception {
when(mock1.simpleMethod()).thenReturn("1");
mock1.simpleMethod();
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(0, stubbings.size());
public void unused_stubbings() throws Exception {
when(mock1.simpleMethod()).thenReturn("1");
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(1, stubbings.size());
public void some_unused_stubbings() throws Exception {
when(mock1.simpleMethod(1)).thenReturn("1");
when(mock2.simpleMethod(2)).thenReturn("2");
when(mock2.simpleMethod(3)).thenReturn("3");
mock2.simpleMethod(2);
UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
assertEquals(2, stubbings.size());
assertEquals("[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
stubbings.toString());
package org.mockito.internal.junit;
import org.junit.Test;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
import org.mockito.internal.stubbing.answers.DoesNothing;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockitoutil.TestBase;
import java.util.List;
import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
public class UnusedStubbingsTest extends TestBase {
SimpleMockitoLogger logger = new SimpleMockitoLogger();
public void no_unused_stubbings() throws Exception {
UnusedStubbings stubbings = new UnusedStubbings((List) asList());
stubbings.format("MyTest.myTestMethod", logger);
assertEquals("", logger.getLoggedInfo());
public void unused_stubbings() throws Exception {
UnusedStubbings stubbings = new UnusedStubbings((List) asList(
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing()),
new StubbedInvocationMatcher(new InvocationBuilder().toInvocationMatcher(), new DoesNothing())
));
stubbings.format("MyTest.myTestMethod", logger);
assertEquals(
"[MockitoHint] MyTest.myTestMethod (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n" +
"[MockitoHint] 2. Unused -> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
filterLineNo(logger.getLoggedInfo()));
mockingProgress.addListener(null);
public boolean isEmpty() {
return loggedInfo.length() == 0;
import java.util.List;
import java.util.Set;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import org.junit.Rule;
import org.mockito.InjectMocks;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
public class ExampleTest {
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.mockitousage.IMethods;
import static org.mockito.Mockito.when;
public class SilentJUnitRuleTest {
public MockitoRule mockitoRule = MockitoJUnit.rule().silent();
public void testInjectMocks() throws Exception {
when(mock.simpleMethod(1)).thenReturn("1");
mock.simpleMethod(2);
package org.mockitousage.junitrule;
import org.junit.After;
import org.junit.Test;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.mockito.Mock;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingWarningsJUnitRuleTest extends TestBase {
private SimpleMockitoLogger logger = new SimpleMockitoLogger();
private JUnitRule jUnitRule = new JUnitRule(logger, false);
private FrameworkMethod dummy = mock(FrameworkMethod.class);
resetState();
public void no_unused_stubs_reported_on_failure() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbing(mock);
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertTrue(logger.getLoggedInfo().isEmpty());
public void stubbing_arg_mismatch_on_failure() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "b");
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertEquals(
"[MockitoHint] DummyTestCase.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
public void no_stubbing_arg_mismatch_when_no_mismatch_on_fail() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "a");
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertTrue(logger.isEmpty());
public void no_stubbing_warning_on_pass() throws Throwable {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "a");
assertTrue(logger.isEmpty());
public void multiple_stubbing_arg_mismatch_on_failure() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
declareStubbingWithArg(mock, "b");
useStubbingWithArg(mock, "c");
useStubbingWithArg(mock, "d");
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertEquals(
"[MockitoHint] DummyTestCase.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint] 2. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
public void reports_only_mismatching_stubs() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a"); // <-- used
declareStubbingWithArg(mock, "b"); // <-- unused
useStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "d"); // <-- arg mismatch
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertEquals(
"[MockitoHint] DummyTestCase.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused... -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n" +
"[MockitoHint]  ...args ok? -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.useStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
public void no_mismatch_when_stub_was_used() throws Throwable {
try {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "d"); // <-- arg mismatch, but the stub was already used
throw new AssertionError("x");
fail();
assertEquals("x", e.getMessage());
assertEquals("", logger.getLoggedInfo());
public void no_stubbing_arg_mismatch_on_pass() throws Throwable {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbingWithArg(mock, "a");
useStubbingWithArg(mock, "b");
assertEquals(
"[MockitoHint] DummyTestCase.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbingWithArg(StubbingWarningsJUnitRuleTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
public void warns_about_unused_stubs_when_passed() throws Throwable {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbing(mock);
assertEquals(
"[MockitoHint] DummyTestCase.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsJUnitRuleTest.declareStubbing(StubbingWarningsJUnitRuleTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
public void no_warnings_when_silent() throws Throwable {
jUnitRule = new JUnitRule(logger, false).silent();
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = mock(IMethods.class);
declareStubbing(mock);
assertTrue(logger.isEmpty());
private static void declareStubbingWithArg(IMethods mock, String arg) {
when(mock.simpleMethod(arg)).thenReturn("bar");
private static void declareStubbing(IMethods mock) {
when(mock.simpleMethod("foo")).thenReturn("bar");
private void useStubbingWithArg(IMethods mock, String arg) {
mock.simpleMethod(arg);
public static class DummyTestCase {
package org.mockitousage.junitrule;
import org.junit.After;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.internal.util.SimpleMockitoLogger;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class StubbingWarningsMultiThreadingTest extends TestBase {
private SimpleMockitoLogger logger = new SimpleMockitoLogger();
private JUnitRule rule = new JUnitRule(logger, false);
private FrameworkMethod dummy = mock(FrameworkMethod.class);
public void after() {
resetState();
rule.apply(new Statement() {
public void evaluate() throws Throwable {
final IMethods mock = mock(IMethods.class);
when(mock.simpleMethod()).thenReturn("1");
inThread(new Runnable() {
public void run() {
mock.simpleMethod();
assertEquals("", logger.getLoggedInfo());
rule.apply(new Statement() {
public void evaluate() throws Throwable {
final IMethods mock = mock(IMethods.class);
when(mock.simpleMethod(1)).thenReturn("1");
when(mock.simpleMethod(2)).thenReturn("2");
inThread(new Runnable() {
public void run() {
mock.simpleMethod(1);
assertEquals(
"[MockitoHint] StubbingWarningsMultiThreadingTest.null (see javadoc for MockitoHint):\n" +
"[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsMultiThreadingTest$2.evaluate(StubbingWarningsMultiThreadingTest.java:0)\n",
filterLineNo(logger.getLoggedInfo()));
private static void inThread(Runnable r) throws InterruptedException {
Thread t = new Thread(r);
t.start();
t.join();
import org.junit.Rule;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
Result result = runner.run(RunnerAndRule.class);
JUnitResultAssert.assertThat(result).fails(1, UnnecessaryStubbingException.class);
public static class RunnerAndRule {
public @Rule MockitoRule rule = MockitoJUnit.rule();
IMethods mock = mock(IMethods.class);
when(mock.simpleMethod(1)).thenReturn("1");
mock.simpleMethod(2);
"Clean & maintainable test code requires zero unnecessary code.\n" +
"Following stubbings are unnecessary (click to navigate to relevant line of code):\n" +import org.mockito.internal.DefaultMockitoFramework;
package org.mockito.internal;
import org.mockito.MockitoFramework;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
import org.mockito.listeners.StubbingListener;
public class DefaultMockitoFramework implements MockitoFramework {
public void setStubbingListener(StubbingListener listener) {
ThreadSafeMockingProgress.mockingProgress().setStubbingListener(listener);
mockingProgress().mockingStarted(mock, typeToMock);
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.listeners.CollectCreatedMocks;
mockingProgress().setListener(new CollectCreatedMocks(createdMocks));
" 2. you are trying to stub a final method, you naughty developer!",
"To keep the tests clean it is important to remove unnecessary code.",
"Following stubbings are declared in test but not realized during test execution:" + stubbings,
public static List<Invocation> find(List<?> mocks) {
import org.mockito.internal.debugging.WarningsCollector;
public JUnitRule(MockitoLogger logger) {
return new Statement() {
public void evaluate() throws Throwable {
WarningsCollector c = new WarningsCollector();
MockitoAnnotations.initMocks(target);
try {
base.evaluate();
logger.log(c.getWarnings());
throw t;
Mockito.validateMockitoUsage();
package org.mockito.internal.listeners;
import java.util.List;
public class CollectCreatedMocks implements MockingStartedListener {
private final List<Object> toBeFilled;
public CollectCreatedMocks(List<Object> toBeFilled) {
this.toBeFilled = toBeFilled;
public void mockingStarted(Object mock, Class<?> classToMock) {
toBeFilled.add(mock);
package org.mockito.internal.listeners;
public interface MockingStartedListener extends MockingProgressListener {
void mockingStarted(Object mock, Class<?> classToMock);
void mockingStarted(Object mock, Class<?> classToMock);
void setListener(MockingProgressListener listener);
import org.mockito.internal.listeners.MockingProgressListener;
import org.mockito.internal.listeners.MockingStartedListener;
private MockingProgressListener listener;
public void mockingStarted(Object mock, Class<?> classToMock) {
if (listener instanceof MockingStartedListener) {
((MockingStartedListener) listener).mockingStarted(mock, classToMock);
public void setListener(MockingProgressListener listener) {
this.listener = listener;
reporter.report(testClass, notifier);
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
private final Map<String, Invocation> stubbings = new HashMap<String, Invocation>();
private final Set<String> used = new HashSet<String>();
public void report(Class<?> testClass, RunNotifier notifier) {
public boolean isSussessful() {
return !failed;
import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
public class StubbedInvocationMatcher extends InvocationMatcher implements Answer, Serializable {
return new JUnitRule(new ConsoleMockitoLogger());
public interface MockitoRule extends MethodRule {}
import org.mockito.internal.invocation.finder.AllInvocationsFinder;
public void shouldGetAllInvocationsInOrder() throws Exception {
List<Invocation> invocations = AllInvocationsFinder.find(asList(mockOne, mockTwo));
public void shouldNotCountDuplicatedInteractions() throws Exception {
List<Invocation> invocations = AllInvocationsFinder.find(asList(mockOne, mockOne, mockOne));
private JUnitRule jUnitRule = new JUnitRule(logger);
public void shouldInjectIntoTestCase() throws Throwable {
jUnitRule.apply(new DummyStatement(),null, injectTestCase).evaluate();
public void shouldRethrowException() throws Throwable {
jUnitRule.apply(new ExceptionStatement(), null,injectTestCase).evaluate();
public void shouldDetectUnfinishedStubbing() throws Throwable {
jUnitRule.apply(new UnfinishedStubbingStatement(),null, injectTestCase).evaluate();
public void shouldWarnAboutUnusedStubsWhenFailed() throws Throwable {
IMethods mock = Mockito.mock(IMethods.class);
declareUnusedStub(mock);
throw new AssertionError("x");
assertEquals("x", e.getMessage());
assertEquals(filterLineNo(logger.getLoggedInfo()),
"[Mockito] Additional stubbing information (see javadoc for StubbingInfo class):\n" +
"[Mockito]\n" +
"[Mockito] Unused stubbing (perhaps can be removed from the test?):\n" +
"[Mockito]\n" +
"[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:0)"
);
public void can_remove_line_numbers() throws Throwable {
assertEquals(
"[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:0)",
filterLineNo("[Mockito] 1. -> at org.mockito.internal.junit.JUnitRuleTest.declareUnusedStub(JUnitRuleTest.java:82)"));
public void shouldNotWarnAboutUnusedStubsWhenPassed() throws Throwable {
jUnitRule.apply(new Statement() {
public void evaluate() throws Throwable {
IMethods mock = Mockito.mock(IMethods.class);
declareUnusedStub(mock);
assertEquals("", logger.getLoggedInfo());
private static void declareUnusedStub(IMethods mock) {
Mockito.when(mock.simpleMethod("foo")).thenReturn("bar");
import org.mockito.internal.listeners.MockingStartedListener;
import java.util.List;
public void shouldNotifyListenerWhenMockingStarted() throws Exception {
MockingStartedListener listener = mock(MockingStartedListener.class);
mockingProgress.setListener(listener);
mockingProgress.mockingStarted("foo", List.class);
verify(listener).mockingStarted(eq("foo"), eq(List.class));
mockingProgress.setListener(null);
import org.junit.Before;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitoutil.TestBase;
public class ExampleTest extends TestBase {
private ArticleManager articleManager;
public void setup() {
articleManager = new ArticleManager(mockCalculator, mockDatabase);
"To keep the tests clean it is important to remove unnecessary code.\n" +
"Following stubbings are declared in test but not realized during test execution:\n" +assumeTrue(ClassFileVersion.forCurrentJavaVersion().isAtLeast(ClassFileVersion.JAVA_V8));
assumeTrue(ClassFileVersion.forCurrentJavaVersion().isAtLeast(ClassFileVersion.JAVA_V8));assertContains("verifyMock_x", trace);
assertNotContains("verify_excludeMe_x", trace);
assertContains("verifyMock_x", trace);
assertContains("verify_excludeMe_x", trace);
private final WeakHashMap<Object, Boolean> initializedInstances = new WeakHashMap<>();private List mock;
private List spy;
public void setSpy(List spy) {
package org.mockitousage.bugs;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mockito;
public class DiamondInheritanceIsConfusingMockitoTest {
public void should_work() {
Sub mock = Mockito.mock(Sub.class);
Mockito.when(mock.getFoo()).thenReturn("Hello");
Assert.assertEquals("Hello", mock.getFoo());
public class Super<T> {
private T value;
public Super(T value) {
this.value = value;
public T getFoo() { return value; }
public class Sub
extends Super<String>
implements iInterface {
public Sub(String s) {
super(s);
public interface iInterface {
String getFoo();
Class clazz = this.getClass().getClassLoader().loadClass("org.mockitousage.configuration.ClassToBeMocked");
public static class PrepareMockito implements Callable {
public Object call() throws Exception {
private List list;
public List getList() {
List real = Arrays.asList("first", "second");import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import org.mockito.MockitoFramework;
import org.mockito.internal.runners.util.FrameworkUsageValidator;
import org.junit.runner.notification.RunNotifier;
missingInvocation.check(data.getAllInvocations(), data.getWanted());
numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);
throw tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        
throw neverWantedButInvoked(wanted, firstUndesired); 
import static org.mockito.Matchers.anyObject;
public Object someMethod(Object param);
public Object otherMethod(Object param);
private static interface IMatcher extends Matcher<Integer> {}
class MyException extends RuntimeException {};
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyObject;
import static org.mockito.BDDMockito.doAnswer;
public boolean anyImportRunningOrRunnedToday(int importType, Date currentDate);
public void save(Person capture);
private class HasPrivateConstructor {};
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyObject;
public String targetMethod(String arg);
public MyIterator<T> iterator();
public Integer getValue(Integer param);
public List<Integer> getValues(Integer param);
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyByte;
import static org.mockito.Matchers.anyChar;
import static org.mockito.Matchers.anyDouble;
import static org.mockito.Matchers.anyFloat;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyShort;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.isNotNull;
import static org.mockito.Matchers.isNull;
import static org.mockito.Matchers.matches;
import static org.mockito.Matchers.notNull;
import static org.mockito.Matchers.same;
import static org.mockito.Matchers.startsWith;
import static org.mockito.Matchers.anyCollection;
import static org.mockito.Matchers.anyList;
import static org.mockito.Matchers.anyMap;
import static org.mockito.Matchers.anySet;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.startsWith;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyObject;
static class Foo {};
class Bar {};
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.matches;
try { verifyNoMoreInteractions(mock); fail(); } catch (NoInteractionsWanted e) {};
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.eq;
verify(mock, timeout(50).atLeast(1)).oneArg('c');
verify(mock, timeout(50).times(2)).oneArg('c');
import static org.testng.Assert.fail;import java.util.ArrayList;
public static <T> T any() {
return anyObject();
public static <T> T anyObject() {
reportMatcher(Any.ANY);
return null;
public static <T> T any(Class<T> type) {
reportMatcher(new InstanceOf.VarArgAware(type, "<any " + type.getCanonicalName() + ">"));
return defaultValue(type);
public static <T> T isA(Class<T> type) {
reportMatcher(new InstanceOf(type));
return defaultValue(type);
public static <T> T anyVararg() {
any();
return null;
public static boolean anyBoolean() {
reportMatcher(new InstanceOf(Boolean.class, "<any boolean>"));
return false;
public static byte anyByte() {
reportMatcher(new InstanceOf(Byte.class, "<any byte>"));
public static char anyChar() {
reportMatcher(new InstanceOf(Character.class, "<any char>"));
public static int anyInt() {
reportMatcher(new InstanceOf(Integer.class, "<any integer>"));
public static long anyLong() {
reportMatcher(new InstanceOf(Long.class, "<any long>"));
return 0;
public static float anyFloat() {
reportMatcher(new InstanceOf(Float.class, "<any float>"));
return 0;
public static double anyDouble() {
reportMatcher(new InstanceOf(Double.class, "<any double>"));
return 0;
public static short anyShort() {
reportMatcher(new InstanceOf(Short.class, "<any short>"));
return 0;
reportMatcher(new InstanceOf(String.class, "<any string>"));
reportMatcher(new InstanceOf(List.class, "<any List>"));
return new ArrayList(0);
reportMatcher(new InstanceOf(Set.class, "<any set>"));
return new HashSet(0);
reportMatcher(new InstanceOf(Map.class, "<any map>"));
return new HashMap(0);
reportMatcher(new InstanceOf(Collection.class, "<any collection>"));
return new ArrayList(0);
+     * @return empty Iterable.
+     * @see #anyIterableOf(Class)
+     */
public static Collection anyIterable() {
reportMatcher(new InstanceOf(Iterable.class, "<any iterable>"));
return new ArrayList(0);
public static <T> Iterable<T> anyIterableOf(Class<T> clazz) {
return anyIterable();
public static <T> T isNull() {
public static <T> T notNull() {
public static <T> T isNotNull() {
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import org.mockito.internal.util.Primitives;
private String description;
this(clazz, "isA(" + clazz.getCanonicalName() + ")");
public InstanceOf(Class<?> clazz, String describedAs) {
this.description = describedAs;
return (actual != null) &&
(Primitives.isAssignableFromWrapper(actual.getClass(), clazz)
|| clazz.isAssignableFrom(actual.getClass()));
return description;
public static class VarArgAware extends InstanceOf implements VarargMatcher {
public VarArgAware(Class<?> clazz) {
super(clazz);
public VarArgAware(Class<?> clazz, String describedAs) {
super(clazz, describedAs);
import org.mockito.MockitoFramework;
import org.mockito.internal.runners.util.FrameworkUsageValidator;
import org.junit.runner.notification.RunNotifier;
public static boolean isAssignableFromWrapper(Class<?> valueClass, Class<?> referenceType) {
if(isPrimitiveOrWrapper(valueClass) && isPrimitiveOrWrapper(referenceType)) {
return Primitives.primitiveTypeOf(valueClass).isAssignableFrom(referenceType);
return false;
import static org.mockito.Matchers.anyObject;
public Object someMethod(Object param);
public Object otherMethod(Object param);
import org.assertj.core.api.Assertions;
import static org.mockitoutil.Conditions.onlyThoseClassesInStackTrace;
Assertions.assertThat(t).has(onlyThoseClassesInStackTrace("org.mockito.Mockito", "org.test.MockitoSampleTest"));
Assertions.assertThat(t).has(onlyThoseClassesInStackTrace("org.test.MockitoSampleTest"));
import org.assertj.core.api.Assertions;
import static org.mockitoutil.Conditions.onlyThoseClasses;
Assertions.assertThat(filtered).has(onlyThoseClasses("MockitoExampleTest"));
Assertions.assertThat(filtered).has(onlyThoseClasses("MockitoExampleTest"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.TestSupport", "org.test.TestSupport", "org.test.MockitoSampleTest"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "junit.stuff", "org.mockito.runners.Runner"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "junit.stuff", "org.mockito.runners.Runner","org.mockito.internal.junit.JUnitRule$1.evaluate(JUnitRule.java:16)"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "org.mockito.internal.runners.Runner"));
Assertions.assertThat(filtered).has(onlyThoseClasses("org.test.MockitoSampleTest", "org.test.Good"));
Assertions.assertThat(filtered).has(onlyThoseClasses(
private static interface IMatcher extends Matcher<Integer> {}
import org.assertj.core.api.Assertions;
Assertions.assertThat(invocation.toString()).endsWith("simpleMethod(\"foo\");");
Assertions.assertThat(invocation.toString()).endsWith("simpleMethod(\"foo\", 1);");
Assertions.assertThat(invocation.toString()).endsWith("simpleMethod(null);");
Assertions.assertThat(invocation.toString()).endsWith("oneArray([1, 2, 3]);");
Assertions.assertThat(invocation.toString()).endsWith("oneArray(null);");
Assertions.assertThat(invocation.toString()).endsWith(
");");
import org.assertj.core.api.Assertions;
import static junit.framework.TestCase.assertNull;
import static junit.framework.TestCase.assertSame;
import static junit.framework.TestCase.assertTrue;
Assertions.assertThat(actual).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
Assertions.assertThat(actual).containsSequence(differentMethodInvocation);
Assertions.assertThat(allMatching).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
Assertions.assertThat(allMatching).containsSequence(simpleMethodInvocationTwo);
Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo);
Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree);
Assertions.assertThat(chunk).containsSequence(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree);
package org.mockito.internal.matchers;
import org.junit.Test;
import java.util.ArrayList;
import java.util.List;
import static org.assertj.core.api.Assertions.assertThat;
public class InstanceOfTest {
public void should_describe_the_matcher() {
assertThat(new InstanceOf(Object.class).toString()).contains("isA")
.contains("Object");
assertThat(new InstanceOf(Object[].class).toString()).contains("isA")
.contains("Object[]");
assertThat(new InstanceOf(Object.class, "matches something").toString()).isEqualTo("matches something");
public void should_check_instance_type() {
assertThat(new InstanceOf(Object.class).matches(new Object())).isTrue();
assertThat(new InstanceOf(Object.class).matches(new ArrayList())).isTrue();
assertThat(new InstanceOf(List.class).matches(new ArrayList())).isTrue();
assertThat(new InstanceOf(List.class).matches(new Object())).isFalse();
public void should_check_for_primitive_wrapper_types() {
assertThat(new InstanceOf(int.class).matches(1000)).isTrue();
assertThat(new InstanceOf(Integer.class).matches(1000)).isTrue();
assertThat(new InstanceOf(int.class).matches(new Integer(1000))).isTrue();
assertThat(new InstanceOf(Integer.class).matches(new Integer(1000))).isTrue();
assertThat(new InstanceOf(double.class).matches(1000.1)).isTrue();
assertThat(new InstanceOf(Double.class).matches(1000.1)).isTrue();
assertThat(new InstanceOf(double.class).matches(new Double(1000.1))).isTrue();
assertThat(new InstanceOf(Double.class).matches(new Double(1000.1))).isTrue();
assertThat(new InstanceOf(int.class).matches(1000L)).isFalse();
assertThat(new InstanceOf(Integer.class).matches(1000L)).isFalse();
assertThat(new InstanceOf(int.class).matches(new Long(1000))).isFalse();
assertThat(new InstanceOf(Integer.class).matches(new Long(1000))).isFalse();
assertThat(new InstanceOf(long.class).matches(1000L)).isTrue();
assertThat(new InstanceOf(Long.class).matches(1000L)).isTrue();
assertThat(new InstanceOf(long.class).matches(new Long(1000))).isTrue();
assertThat(new InstanceOf(Long.class).matches(new Long(1000))).isTrue();
assertThat(new InstanceOf(long.class).matches(1000)).isFalse();
assertThat(new InstanceOf(Long.class).matches(1000)).isFalse();
assertThat(new InstanceOf(long.class).matches(new Integer(1000))).isFalse();
assertThat(new InstanceOf(Long.class).matches(new Integer(1000))).isFalse();
public void can_be_vararg_aware() {
assertThat(new InstanceOf.VarArgAware(Number[].class)).isInstanceOf(VarargMatcher.class);
assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Integer[0])).isTrue();
assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Number[0])).isTrue();
assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Object[0])).isFalse();
class MyException extends RuntimeException {};
public void should_check_that_value_type_is_assignable_to_wrapper_reference() {
assertThat(Primitives.isAssignableFromWrapper(int.class, Integer.class));
assertThat(Primitives.isAssignableFromWrapper(Integer.class, Integer.class));
assertThat(Primitives.isAssignableFromWrapper(long.class, Long.class));
assertThat(Primitives.isAssignableFromWrapper(Long.class, Long.class));
assertThat(Primitives.isAssignableFromWrapper(double.class, Double.class));
assertThat(Primitives.isAssignableFromWrapper(Double.class, Double.class));
assertThat(Primitives.isAssignableFromWrapper(float.class, Float.class));
assertThat(Primitives.isAssignableFromWrapper(Float.class, Float.class));
assertThat(Primitives.isAssignableFromWrapper(char.class, Character.class));
assertThat(Primitives.isAssignableFromWrapper(Character.class, Character.class));
assertThat(Primitives.isAssignableFromWrapper(short.class, Short.class));
assertThat(Primitives.isAssignableFromWrapper(Short.class, Short.class));
assertThat(Primitives.isAssignableFromWrapper(byte.class, Byte.class));
assertThat(Primitives.isAssignableFromWrapper(Byte.class, Byte.class));
assertThat(Primitives.isAssignableFromWrapper(boolean.class, Boolean.class));
assertThat(Primitives.isAssignableFromWrapper(Boolean.class, Boolean.class));
import org.assertj.core.api.Assertions;
Assertions.assertThat(timer.isCounting()).isTrue();
Assertions.assertThat(timer.isCounting()).isFalse();
import org.assertj.core.api.Assertions;
Assertions.assertThat(filtered).containsSequence("one", "two", "three");
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyObject;
import static org.mockito.BDDMockito.doAnswer;
String forIterable(Iterable<String> iterable);
Object iterableArgMethod(Iterable<String> collection);
public String forIterable(Iterable<String> iterable) {
return null;
public Object iterableArgMethod(Iterable<String> iterable) {
return null;
public boolean anyImportRunningOrRunnedToday(int importType, Date currentDate);
public void save(Person capture);
private class HasPrivateConstructor {};
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import org.assertj.core.api.Assertions;
Assertions.assertThat(mock).isEqualTo(mock);
Assertions.assertThat(mock).isNotEqualTo(otherMock);
Assertions.assertThat(mock.hashCode()).isNotEqualTo(otherMock.hashCode());
Assertions.assertThat(mock).isEqualTo(mock);
Assertions.assertThat(mock).isNotEqualTo(otherMock);
Assertions.assertThat(mock.hashCode()).isNotEqualTo(otherMock.hashCode());
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyObject;
public String targetMethod(String arg);
public MyIterator<T> iterator();
public Integer getValue(Integer param);
public List<Integer> getValues(Integer param);
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import org.assertj.core.api.Assertions;
import static org.mockitoutil.Conditions.methodInStackTraceAt;
Assertions.assertThat(e).has(methodInStackTraceAt(0, "throwSomething"));
Assertions.assertThat(e).has(methodInStackTraceAt(1, "invoke"));
Assertions.assertThat(e).has(methodInStackTraceAt(2, "shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows"));
import org.mockitoutil.JUnitResultAssert;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
JUnitResultAssert.assertThat(result).isSuccessful();
JUnitResultAssert.assertThat(result).fails(1, TooLittleActualInvocations.class);
JUnitResultAssert.assertThat(result).fails(1, UnfinishedStubbingException.class);
JUnitResultAssert.assertThat(result).isSuccessful();
import org.mockitoutil.JUnitResultAssert;
JUnitResultAssert.assertThat(result).isSuccessful();
JUnitResultAssert.assertThat(result).fails(3, UnnecessaryStubbingException.class);
JUnitResultAssert.assertThat(result).fails(1, MyAssertionError.class);
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyByte;
import static org.mockito.Matchers.anyChar;
import static org.mockito.Matchers.anyDouble;
import static org.mockito.Matchers.anyFloat;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyShort;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.isNotNull;
import static org.mockito.Matchers.isNull;
import static org.mockito.Matchers.matches;
import static org.mockito.Matchers.notNull;
import static org.mockito.Matchers.same;
import static org.mockito.Matchers.startsWith;
import static junit.framework.TestCase.fail;
public void should_help_out_with_unnecessary_casting() {
public void any_should_be_actual_alias_to_anyObject() {
verify(mock).simpleMethod(any());
public void any_class_should_be_actual_alias_to_isA() {
mock.simpleMethod(new ArrayList());
verify(mock).simpleMethod(isA(List.class));
verify(mock).simpleMethod(any(List.class));
mock.simpleMethod((String) null);
try {
verify(mock).simpleMethod(isA(String.class));
fail();
try {
verify(mock).simpleMethod(any(String.class));
fail();
public void should_help_out_with_unnecessary_casting_of_lists() {
public void should_help_out_with_unnecessary_casting_of_sets() {
public void should_help_out_with_unnecessary_casting_of_maps() {
public void should_help_out_with_unnecessary_casting_of_collections() {
when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn("collection");
assertEquals("collection", mock.collectionArgMethod(new ArrayList<String>()));
assertEquals("collection", mock.collectionArgMethod(Collections.<String>emptyList()));
public void should_help_out_with_unnecessary_casting_of_iterables() {
when(mock.iterableArgMethod(anyIterableOf(String.class))).thenReturn("iterable");
assertEquals("iterable", mock.iterableArgMethod(new ArrayList<String>()));
assertEquals("iterable", mock.iterableArgMethod(Collections.<String>emptyList()));
public void should_help_out_with_unnecessary_casting_of_nullity_checks() {
import static org.mockito.Matchers.anyCollection;
import static org.mockito.Matchers.anyList;
import static org.mockito.Matchers.anyMap;
import static org.mockito.Matchers.anySet;
public void shouldAllowAnyIterable() {
when(mock.forIterable(anyIterable())).thenReturn("matched");
assertEquals("matched", mock.forIterable(new HashSet<String>()));
assertEquals(null, mock.forIterable(null));
verify(mock, times(1)).forIterable(anyIterable());
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.startsWith;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyObject;
static class Foo {};
class Bar {};
import org.assertj.core.api.Assertions;
import static org.mockitoutil.Conditions.bridgeMethod;
Assertions.assertThat(Sub.class).has(bridgeMethod("say"));
Assertions.assertThat(s).has(bridgeMethod("say"));
import org.assertj.core.api.Assertions;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockitoutil.Conditions.methodsInStackTrace;
Assertions.assertThat(t).has(methodsInStackTrace(
import org.assertj.core.api.Assertions;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
Assertions.assertThat(type.getMethod("foo").invoke(object)).isEqualTo((Object) "bar");
Assertions.assertThat(impl.getMethod("foo").invoke(object)).isEqualTo((Object) "bar");
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import org.assertj.core.api.Assertions;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.mockitoutil.Conditions.firstMethodInStackTrace;
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerify"));
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoMoreInteractions"));
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStackTraceOnVerifyZeroInteractions"));
Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));
Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceWhenInOrderThrowsMockitoException"));
Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));
Assertions.assertThat(expected).has(firstMethodInStackTrace("shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));
Assertions.assertThat(e).has(firstMethodInStackTrace("shouldShowProperExceptionStackTrace"));
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.matches;
"    <any integer>,\n" +
import org.assertj.core.api.Assertions;
import static org.mockito.ArgumentMatchers.any;
public void should_not_report_argument_types_when_to_string_is_the_same() {
public void should_show_the_type_of_only_the_argument_that_doesnt_match() {
public void should_show_the_type_of_the_mismatching_argument_when_output_descriptions_for_invocations_are_different() {
Assertions.assertThat(e.getMessage())
.contains("withLongAndInt(\n" +
"    (Long) 100,\n" +
"    200\n" +
")")
.contains("withLongAndInt(\n" +
"    (Integer) 100,\n" +
"    <any java.lang.Integer>\n" +
")");
public void should_not_show_types_when_argument_value_is_different() {
public void should_not_show_types_when_types_are_the_same_even_if_to_string_gives_the_same_result() {
try { verifyNoMoreInteractions(mock); fail(); } catch (NoInteractionsWanted e) {};
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.eq;
package org.mockitoutil;
import org.assertj.core.api.Assertions;
import org.assertj.core.api.Condition;
import org.assertj.core.description.Description;
import org.assertj.core.description.TextDescription;
import org.hamcrest.CoreMatchers;
import java.lang.reflect.Method;
import java.util.Arrays;
public class Conditions {
public static Condition<Throwable> onlyThoseClassesInStackTrace(final String... classes) {
return new Condition<Throwable>() {
public boolean matches(Throwable traceElements) {
StackTraceElement[] trace = traceElements.getStackTrace();
Assertions.assertThat(trace.length)
.describedAs("Number of classes does not match.\nExpected: %s\nGot: %s",
Arrays.toString(classes),
Arrays.toString(traceElements.getStackTrace()))
.isEqualTo(classes.length);
for (int i = 0; i < trace.length; i++) {
Assertions.assertThat(trace[i].getClassName()).isEqualTo(classes[i]);
return true;
public static Condition<StackTraceElement[]> onlyThoseClasses(final String... classes) {
return new Condition<StackTraceElement[]>() {
public boolean matches(StackTraceElement[] traceElements) {
Assertions.assertThat(traceElements.length)
.describedAs("Number of classes does not match.\nExpected: %s\nGot: %s",
Arrays.toString(classes),
Arrays.toString(traceElements))
.isEqualTo(classes.length);
for (int i = 0; i < traceElements.length; i++) {
Assertions.assertThat(traceElements[i].getClassName()).isEqualTo(classes[i]);
return true;
public static Condition<Throwable> firstMethodInStackTrace(final String method) {
return methodInStackTraceAt(0, method);
public static Condition<Throwable> methodInStackTraceAt(final int stackTraceIndex, final String method) {
return new Condition<Throwable>() {
private String actualMethodAtIndex;
public boolean matches(Throwable throwable) {
actualMethodAtIndex = throwable.getStackTrace()[stackTraceIndex].getMethodName();
return actualMethodAtIndex.equals(method);
public Description description() {
return new TextDescription("Method at index: %d\nexpected to be: %s\nbut is: %s", stackTraceIndex, method, actualMethodAtIndex);
public static Condition<Object> bridgeMethod(final String methodName) {
return new Condition<Object>() {
public boolean matches(Object o) {
Class<?> clazz = null;
if (o instanceof Class) {
clazz = (Class<?>) o;
clazz = o.getClass();
for (Method m : clazz.getMethods()) {
if (m.isBridge() && m.getName().equals(methodName)) {
return true;
Assertions.fail("Bridge method [" + methodName + "]\nnot found in:\n" + o);
return false;
public static org.hamcrest.Matcher<Object> clazz(Class<?> type) {
return CoreMatchers.instanceOf(type);
public static Condition<Throwable> methodsInStackTrace(final String... methods) {
return new Condition<Throwable>() {
public boolean matches(Throwable value) {
StackTraceElement[] trace = value.getStackTrace();
for (int i = 0; i < methods.length; i++) {
Assertions.assertThat(trace[i].getMethodName()).describedAs("Expected methods[%d] to be in the stack trace.", i).isEqualTo(methods[i]);
return true;
public static JUnitResultAssert assertThat(Result result) {
return new JUnitResultAssert(result);
import static org.testng.Assert.fail;MockMethodInterceptor.ForEquals.class).build(), ClassLoadingStrategy.Default.INJECTION)import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
StringBuilder sb = new StringBuilder("\nHowever, there were other interactions with this mock:\n");
public void shouldGetPluralizedNumber() {
new Pluralizer();
exception.expectMessage("However, there were other interactions with this mock:");
assertContains("However, there were other interactions with this mock", e.getMessage());Set<Class> getExtraInterfaces();
MockCreationSettings getMockSettings();
public MockSettingsImpl stubOnly() {
private static InternalMockHandler asInternalMockHandler(MockHandler handler) {
return (InternalMockHandler) handler;
import org.mockito.exceptions.verification.*;
import static org.mockito.internal.reporting.Pluralizer.were_exactly_x_interactions;
StringBuilder sb = new StringBuilder(
"\nHowever, there " + were_exactly_x_interactions(invocations.size()) + " with this mock:\n");
public InvocationNotifierHandler(InternalMockHandler<T> mockHandler, MockCreationSettings<?> settings) {
public MockCreationSettings getMockSettings() {
private final MockCreationSettings mockSettings;
public MockHandlerImpl(MockCreationSettings mockSettings) {
public MockCreationSettings getMockSettings() {
public MockCreationSettings getMockSettings() {
public static String were_exactly_x_interactions(int x) {
if (x == 1) {
return "was exactly 1 interaction";
return "were exactly " + x + " interactions";
public Set<Class> getExtraInterfaces() {
Answer getDefaultAnswer();
public MockCreationSettings getMockSettings() { return null; }
(MockSettingsImpl<?>) new MockSettingsImpl<ArrayList<Answer<?>>>().invocationListeners(customListener, listener1, listener2)
public void pluralizes_number() {
public void pluralizes_interactions() {
assertEquals("were exactly 0 interactions", Pluralizer.were_exactly_x_interactions(0));
assertEquals("was exactly 1 interaction", Pluralizer.were_exactly_x_interactions(1));
assertEquals("were exactly 100 interactions", Pluralizer.were_exactly_x_interactions(100));
exception.expectMessage("However, there was exactly 1 interaction with this mock:");
verify(mock).otherMethod(); //verify 1st interaction
assertContains("However, there were exactly 2 interactions with this mock", e.getMessage());import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
StringBuilder sb = new StringBuilder("\nHowever, there were other interactions with this mock:\n");
import static org.mockito.internal.runners.util.TestMethodsFinder.hasTestMethods;
if (!hasTestMethods(klass)) {
private TestMethodsFinder() {}
public static boolean hasTestMethods(Class<?> klass) {
public void shouldGetPluralizedNumber() {
new Pluralizer();
assertTrue(TestMethodsFinder.hasTestMethods(HasTests.class));
assertFalse(TestMethodsFinder.hasTestMethods(DoesNotHaveTests.class));
exception.expectMessage("However, there were other interactions with this mock:");
assertContains("However, there were other interactions with this mock", e.getMessage());public class InternalJUnitRunner implements RunnerImpl {
public InternalJUnitRunner(Class<?> testClass) throws InitializationError {
return new RunnerProvider().newInstance("org.mockito.internal.runners.InternalJUnitRunner", klass);
import org.mockito.internal.runners.util.MockitoJUnitListener;
MockitoJUnitListener listener = new MockitoJUnitListener(notifier);
public class MockitoJUnitListener extends RunListener {
public MockitoJUnitListener(RunNotifier notifier) {
RunnerImpl runner = provider.newInstance("org.mockito.internal.runners.InternalJUnitRunner", this.getClass());
package org.mockito.runners;
import org.junit.Test;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.mockito.internal.runners.util.MockitoJUnitListener;
import org.mockitoutil.TestBase;
import java.util.LinkedList;
import java.util.List;
import static junit.framework.TestCase.assertEquals;
import static org.mockitoutil.ExtraMatchers.clazz;
import static org.mockitoutil.ExtraMatchers.contains;
public class RunnersValidateFrameworkUsageTest extends TestBase {
private Runner runner;
private RunNotifierStub notifier = new RunNotifierStub();
public static class DummyTest extends TestBase {
public class RunNotifierStub extends RunNotifier {
private List<RunListener> addedListeners = new LinkedList<RunListener>();
public void addListener(RunListener listener) {
addedListeners.add(listener);
public void shouldValidateWithDefaultRunner() throws Exception {
runner = new MockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
public void shouldValidateWithD44Runner() throws Exception {
runner = new MockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
public void shouldValidateWithVerboseRunner() throws Exception {
runner = new ConsoleSpammingMockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertEquals(2, notifier.addedListeners.size());
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitoutil.TestBase;
import java.util.List;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;
public class InternalJUnitRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(
SomeFeature.class
);
assertThat(result).isSuccessful();
Result result = runner.run(
SomeFailingFeature.class
);
assertThat(result).fails(1, TooLittleActualInvocations.class);
public static class SomeFeature {
when(list.get(0)).thenReturn("0");
assertEquals("0", list.get(0));
public static class SomeFailingFeature {
list.clear();
verify(list, times(2)).clear();
import org.junit.runner.notification.Failure;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public void ignores_unused_stubs() {
JUnitCore runner = new JUnitCore();
Result result = runner.run(HasUnnecessaryStubs.class);
assertThat(result).isSuccessful();
public class StrictJUnitRunnerTest extends TestBase {"  1. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:27)\n" +
"  2. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:26)\n" +throw new AssertionError("Wrong number of failures, expected: " + expectedFailureCount + ", actual: " + expectedFailureCount + "\n" +import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;public class InternalJUnitRunner implements RunnerImpl {
public InternalJUnitRunner(Class<?> testClass) throws InitializationError {
return new RunnerProvider().newInstance("org.mockito.internal.runners.InternalJUnitRunner", klass);
import org.mockito.internal.runners.util.MockitoJUnitListener;
MockitoJUnitListener listener = new MockitoJUnitListener(notifier);
public class MockitoJUnitListener extends RunListener {
public MockitoJUnitListener(RunNotifier notifier) {
RunnerImpl runner = provider.newInstance("org.mockito.internal.runners.InternalJUnitRunner", this.getClass());
package org.mockito.runners;
import static org.mockitoutil.ExtraMatchers.*;
import java.util.LinkedList;
import java.util.List;
import org.junit.Test;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.mockito.internal.runners.util.MockitoJUnitListener;
import org.mockitoutil.TestBase;
public class RunnersValidateFrameworkUsageTest extends TestBase {
private Runner runner;
private RunNotifierStub notifier = new RunNotifierStub();
public static class DummyTest extends TestBase {
public class RunNotifierStub extends RunNotifier {
private List<RunListener> addedListeners = new LinkedList<RunListener>();
public void addListener(RunListener listener) {
addedListeners.add(listener);
public void shouldValidateWithDefaultRunner() throws Exception {
runner = new MockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
public void shouldValidateWithD44Runner() throws Exception {
runner = new MockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
public void shouldValidateWithVerboseRunner() throws Exception {
runner = new ConsoleSpammingMockitoJUnitRunner(DummyTest.class);
runner.run(notifier);
assertEquals(2, notifier.addedListeners.size());
assertThat(notifier.addedListeners, contains(clazz(MockitoJUnitListener.class)));
package org.mockitousage.junitrunner;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitoutil.TestBase;
import java.util.List;
import static org.mockito.Mockito.*;
public class InternalJUnitRunnerTest extends TestBase {
JUnitCore runner = new JUnitCore();
Result result = runner.run(
SomeFeature.class
);
assertThat(result).isSuccessful();
Result result = runner.run(
SomeFailingFeature.class
);
assertThat(result).fails(1, TooLittleActualInvocations.class);
public static class SomeFeature {
when(list.get(0)).thenReturn("0");
assertEquals("0", list.get(0));
public static class SomeFailingFeature {
list.clear();
verify(list, times(2)).clear();
import org.junit.runner.notification.Failure;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public void ignores_unused_stubs() {
JUnitCore runner = new JUnitCore();
Result result = runner.run(HasUnnecessaryStubs.class);
assertThat(result).isSuccessful();
public class StrictJUnitRunnerTest extends TestBase {"  1. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:27)\n" +
"  2. -> at org.mockitousage.junitrunner.UnusedStubsExceptionMessageTest$HasUnnecessaryStubs.<init>(UnusedStubsExceptionMessageTest.java:26)\n" +public static <T extends Comparable<T>> T geq(Comparable<T> value) {
public static <T extends Comparable<T>> T leq(Comparable<T> value) {
public static <T extends Comparable<T>> T gt(Comparable<T> value) {
public static <T extends Comparable<T>> T lt(Comparable<T> value) {
public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {
import java.util.List;
if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {
private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {
public CompareEqual(Comparable<T> value) {
private final Comparable<T> wanted;
public CompareTo(Comparable<T> value) {
public boolean matches(T actual) {
return matchResult(((Comparable)actual).compareTo(wanted));
public String toString() {
public GreaterOrEqual(Comparable<T> value) {
public GreaterThan(Comparable<T> value) {
public LessOrEqual(Comparable<T> value) {
public LessThan(Comparable<T> value) {
import org.junit.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));
new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));
UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);
mocks.add(mock);
assertThat(mocks.contains(mock)).isTrue();
assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();
UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);
mock(UnmockableHashCodeAndEquals.class),
mock(UnmockableHashCodeAndEquals.class),
mock(UnmockableHashCodeAndEquals.class),
mock(UnmockableHashCodeAndEquals.class),
UnmockableHashCodeAndEquals mock1 = mock(UnmockableHashCodeAndEquals.class);.append(MultipleParentClassLoader.class.getClassLoader())
.build(), ClassLoadingStrategy.Default.INJECTION)private InvocationsFinder() {
public static List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {
public static List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {
public static List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {
return findAllMatchingUnverifiedChunks(invocations, wanted, context);
private static List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {
public static Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){
public static Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {
public static Invocation findFirstUnverified(List<Invocation> invocations) {
static Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {
public static Location getLastLocation(List<Invocation> invocations) {
public static Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {
private static List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {
public static Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
List<Invocation> found = findInvocations(invocations, wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverifiedInOrder;
Invocation unverified = findFirstUnverified(data.getAllInvocations());
Invocation unverified = findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified;
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
List<Invocation> chunk = findInvocations(invocations,wantedMatcher);
Invocation unverified = findFirstUnverified(invocations);
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Location lastLocation = getLastLocation(actualInvocations);
import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);
Location lastLocation = getLastLocation(chunk);
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Invocation similar = findSimilarInvocation(invocations, wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks;
import static org.mockito.internal.invocation.InvocationsFinder.findPreviousVerifiedInOrder;
List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, context);
Invocation previousInOrder = findPreviousVerifiedInOrder(invocations, context);
if (previousInOrder != null) {
new MissingInvocationChecker().check(invocations, wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
Invocation next = findFirstMatchingUnverifiedInvocation( invocations, wanted, context );
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Location lastInvocation = getLastLocation(actualInvocations);
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
Location lastInvocation = getLastLocation(chunk);
private Set theSet;
new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream(), new HashMap()));
new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream()));
new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(), new TreeSet()));
import org.junit.Ignore;
public void report_issue_when_trying_to_load_objenesis() throws Exception {
ClassLoader classpath_without_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class)
.withCodeSourceUrlOf(coverageTool())
.without("org.objenesis")
.build();
boolean initialize_class = true;
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker",
initialize_class,
classpath_without_objenesis
);
try {
mock_maker_class_loaded_fine_until.newInstance();
fail();
assertThat(e).isInstanceOf(IllegalStateException.class);
assertThat(e.getMessage()).containsIgnoringCase("objenesis").contains("missing");
private static final Answer SOME_ANSWER = mock(Answer.class);
private InvocationNotifierHandler notifier;
notifier = new InvocationNotifierHandler(
(MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)
notifier.setAnswersForStubbing(new ArrayList<Answer>());
List<Invocation> actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));
actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverified(invocations));
assertSame(differentMethodInvocation, InvocationsFinder.findFirstUnverified(invocations));
assertNull(InvocationsFinder.findFirstUnverified(invocations));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(differentMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
assertNull(InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));
assertNull(InvocationsFinder.findFirstUnverified(invocations, "different mock"));
Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));
Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));
Location last = InvocationsFinder.getLastLocation(invocations);
assertNull(InvocationsFinder.getLastLocation(Collections.<Invocation>emptyList()));
List<Invocation> allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
Invocation previous = InvocationsFinder.findPreviousVerifiedInOrder(invocations, context);
previous = InvocationsFinder.findPreviousVerifiedInOrder(invocations, context);
assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty());
assertTrue(((Set) values.returnValueFor(Set.class)).isEmpty());
assertTrue(((SortedSet) values.returnValueFor(SortedSet.class)).isEmpty());
assertTrue(((HashSet) values.returnValueFor(HashSet.class)).isEmpty());
assertTrue(((TreeSet) values.returnValueFor(TreeSet.class)).isEmpty());
assertTrue(((LinkedHashSet) values.returnValueFor(LinkedHashSet.class)).isEmpty());
assertTrue(((List) values.returnValueFor(List.class)).isEmpty());
assertTrue(((ArrayList) values.returnValueFor(ArrayList.class)).isEmpty());
assertTrue(((LinkedList) values.returnValueFor(LinkedList.class)).isEmpty());
assertTrue(((Map) values.returnValueFor(Map.class)).isEmpty());
assertTrue(((SortedMap) values.returnValueFor(SortedMap.class)).isEmpty());
assertTrue(((HashMap) values.returnValueFor(HashMap.class)).isEmpty());
assertTrue(((TreeMap) values.returnValueFor(TreeMap.class)).isEmpty());
assertTrue(((LinkedHashMap) values.returnValueFor(LinkedHashMap.class)).isEmpty());
assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());
List list = asList("one", "x", "two", "x", "three");
List filtered = ListUtil.filter(list, new Filter() {
public boolean isOut(Object object) {
List list = new LinkedList();
List filtered = ListUtil.filter(list, null);
public interface ListSet extends List<Set> {}
private Set whateverForNow;
Set wrongArg = mock(Set.class);
package org.mockito.internal.verification.checkers;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.verification.InOrderContextImpl;
import org.mockito.internal.verification.api.InOrderContext;
import org.mockito.invocation.Invocation;
import static java.util.Arrays.asList;
import static org.assertj.core.api.Assertions.assertThat;
public class AtLeastXNumberOfInvocationsCheckerInOrderTest   {
public ExpectedException exception = ExpectedException.none();
public void shouldMarkActualInvocationsAsVerified() {
InOrderContext context = new InOrderContextImpl();
AtLeastXNumberOfInvocationsInOrderChecker c = new AtLeastXNumberOfInvocationsInOrderChecker(context);
Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
c.check(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);
assertThat(invocation.isVerified()).isTrue();
public void shouldReportTooLittleInvocations() {
InOrderContext context = new InOrderContextImpl();
AtLeastXNumberOfInvocationsInOrderChecker c = new AtLeastXNumberOfInvocationsInOrderChecker(context);
Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();
Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("iMethods.simpleMethod()");
exception.expectMessage("Wanted *at least* 2 times");
exception.expectMessage("But was 1 time");
c.check(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 2);
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import java.util.List;
import org.assertj.core.api.Assertions;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.mockitousage.IMethods;
public class NumberOfInvocationsInOrderCheckerTest {
private List<Invocation> invocations;
private InOrderContext context;
private IMethods mock;
public ExpectedException exception = ExpectedException.none();
checker = new NumberOfInvocationsInOrderChecker();
context = new InOrderContextImpl();
mock = mock(IMethods.class, "mock");
public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = emptyList();
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation());
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(first, second);
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 4 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 4, context);
public void shouldMarkAsVerifiedInOrder() throws Exception {
Invocation invocation = buildSimpleMethod().toInvocation();
invocations = asList(invocation);
wanted = buildSimpleMethod().toInvocationMatcher();
assertThat(context.isVerified(invocation)).isFalse();
checker.check(invocations, wanted, 1, context);
assertThat(context.isVerified(invocation)).isTrue();
public void shouldReportTooLittleActual() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 100, context);
public void shouldReportWithLastInvocationStackTrace() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
exception.expectMessage(containsTimes("-> at", 2));
checker.check(invocations, wanted, 100, context);
public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {
invocations = emptyList();
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 0 times");
exception.expectMessage(containsTimes("-> at", 1));
checker.check(invocations, wanted, 100, context);
public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
Invocation third = buildSimpleMethod().toInvocation();
invocations = asList(first, second, third);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("" + third.getLocation());
checker.check(invocations, wanted, 2, context);
public void shouldReportTooManyActual() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
invocations = asList(first, second);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expectMessage("Wanted 1 time");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 1, context);
public void shouldReportNeverWantedButInvoked() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
invocations = asList(first);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 0 times");
exception.expectMessage("But was 1 time. Undesired invocation");
exception.expectMessage("" + first.getLocation());
checker.check(invocations, wanted, 0, context);
public void shouldMarkInvocationsAsVerified() throws Exception {
Invocation invocation = buildSimpleMethod().toInvocation();
Assertions.assertThat(invocation.isVerified()).isFalse();
invocations = asList(invocation);
wanted = buildSimpleMethod().toInvocationMatcher();
assertThat(invocation.isVerified()).isTrue();
private static BaseMatcher<String> containsTimes(String value, int amount) {
return new StringContainsNumberMatcher(value, amount);
private static class StringContainsNumberMatcher extends TypeSafeMatcher<String> {
private final String expected;
private final int amount;
StringContainsNumberMatcher(String expected, int amount) {
this.expected = expected;
this.amount = amount;
public boolean matchesSafely(String text) {
int lastIndex = 0;
int count = 0;
while (lastIndex != -1) {
lastIndex = text.indexOf(expected, lastIndex);
if (lastIndex != -1) {
count++;
lastIndex += expected.length();
return count == amount;
public void describeTo(Description description) {
description.appendText("containing '" + expected + "' exactly " + amount + " times");
private InvocationBuilder buildSimpleMethod() {
return new InvocationBuilder().mock(mock).simpleMethod();
private Answer byCheckingLogEquals(final ImportLogBean status) {
return new Answer() {
Set notAMock;
List wrongType;
public some_class_with_parametered_constructor(List collaborator) {
FailingConstructor(Set set) {
private List aList;
public List getAList() { return aList; }
private Map aMap;
public Map getAMap() { return aMap; }
private TreeSet searchTree;
public TreeSet getSearchTree() { return searchTree; }
private Set histogram1;
private Set histogram2;
public Set getHistogram1() { return histogram1; }
public Set getHistogram2() { return histogram2; }
MockitoAnnotations.initMocks(new Object() { @InjectMocks @Spy List mock; });
MockitoAnnotations.initMocks(new Object() { @Spy List mock; });
static class WithDependency { List list; }
TestMock test = mock(TestMock.class, new Answer() {
TestMock test = mock(TestMock.class, new Answer() {
Assert.assertNotNull(((Iterable) iterable).iterator());
verify((Iterable) iterable).iterator();
iterable = (MyIterable) Proxy.newProxyInstance(
((Iterable) iterable).iterator();
List list= mock(List.class);
import org.assertj.core.api.Condition;
private Condition<Throwable> cceIsThrownFrom(final String stacktraceElementDescription) {
return new Condition<Throwable>() {
public boolean matches(Throwable throwable) {
StackTraceElement[] stackTrace = throwable.getStackTrace();
for (StackTraceElement stackTraceElement : stackTrace) {
if (stackTraceElement.toString().contains(stacktraceElementDescription)) {
return true;
return false;
public static class DoTheMocking implements Callable {
Set expectedMock = mock(Set.class);
Set returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();
ArgumentCaptor<List> argument = ArgumentCaptor.forClass(ArrayList.class);
List list = Mockito.mock(List.class);
List mocks = new LinkedList();
List list = mock(List.class);
List list = mock(List.class);
new Answer() {
List list = new LinkedList();
List spy = Mockito.spy(list);
public int size(Map map) {
public int size(Collection collection) {
private static class RecordCall implements Answer {
private LinkedList mock;
List list = Mockito.mock(List.class);
HashMap map = Mockito.mock(HashMap.class);
List list = mock(List.class);
Map map = mock(Map.class);
Set set = mock(Set.class);new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream(), new HashMap()));
new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream()));
new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(), new TreeSet()));
private static final Answer SOME_ANSWER = mock(Answer.class);
private InvocationNotifierHandler notifier;
notifier = new InvocationNotifierHandler(
(MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)
notifier.setAnswersForStubbing(new ArrayList<Answer>());
assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty());
assertTrue(((Set) values.returnValueFor(Set.class)).isEmpty());
assertTrue(((SortedSet) values.returnValueFor(SortedSet.class)).isEmpty());
assertTrue(((HashSet) values.returnValueFor(HashSet.class)).isEmpty());
assertTrue(((TreeSet) values.returnValueFor(TreeSet.class)).isEmpty());
assertTrue(((LinkedHashSet) values.returnValueFor(LinkedHashSet.class)).isEmpty());
assertTrue(((List) values.returnValueFor(List.class)).isEmpty());
assertTrue(((ArrayList) values.returnValueFor(ArrayList.class)).isEmpty());
assertTrue(((LinkedList) values.returnValueFor(LinkedList.class)).isEmpty());
assertTrue(((Map) values.returnValueFor(Map.class)).isEmpty());
assertTrue(((SortedMap) values.returnValueFor(SortedMap.class)).isEmpty());
assertTrue(((HashMap) values.returnValueFor(HashMap.class)).isEmpty());
assertTrue(((TreeMap) values.returnValueFor(TreeMap.class)).isEmpty());
assertTrue(((LinkedHashMap) values.returnValueFor(LinkedHashMap.class)).isEmpty());
assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());
FailingConstructor(Set set) {
private List aList;
public List getAList() { return aList; }
private Map aMap;
public Map getAMap() { return aMap; }
private TreeSet searchTree;
public TreeSet getSearchTree() { return searchTree; }
private Set histogram1;
private Set histogram2;
public Set getHistogram1() { return histogram1; }
public Set getHistogram2() { return histogram2; }
Set expectedMock = mock(Set.class);
Set returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();private InvocationsFinder() {
public static List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {
public static List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {
public static List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {
return findAllMatchingUnverifiedChunks(invocations, wanted, context);
private static List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {
public static Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){
public static Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {
public static Invocation findFirstUnverified(List<Invocation> invocations) {
static Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {
public static Location getLastLocation(List<Invocation> invocations) {
public static Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {
private static List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {
public static Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
List<Invocation> found = findInvocations(invocations, wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified;
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverifiedInOrder;
Invocation unverified = findFirstUnverified(data.getAllInvocations());
Invocation unverified = findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified;
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
List<Invocation> chunk = findInvocations(invocations,wantedMatcher);
Invocation unverified = findFirstUnverified(invocations);
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Location lastLocation = getLastLocation(actualInvocations);
import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);
Location lastLocation = getLastLocation(chunk);
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Invocation similar = findSimilarInvocation(invocations, wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks;
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.findPreviousVerifiedInOrder;
import static org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation;
List<Invocation> chunk = findAllMatchingUnverifiedChunks(invocations, wanted, context);
Invocation previousInOrder = findPreviousVerifiedInOrder(invocations, context);
if (previousInOrder != null) {
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
if (actualInvocations == null || actualInvocations.isEmpty())  {
Invocation similar = findSimilarInvocation(invocations, wanted);
if (similar != null) {
Integer[] indicesOfSimilarMatchingArguments =
new ArgumentMatchingTool().getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(),
similar.getArguments());
SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indicesOfSimilarMatchingArguments);
throw argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());
throw wantedButNotInvoked(wanted);
import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
Invocation next = findFirstMatchingUnverifiedInvocation( invocations, wanted, context );
import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> actualInvocations = findInvocations(invocations, wanted);
Location lastInvocation = getLastLocation(actualInvocations);
import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
Location lastInvocation = getLastLocation(chunk);
List<Invocation> actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));
actual = InvocationsFinder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverified(invocations));
assertSame(differentMethodInvocation, InvocationsFinder.findFirstUnverified(invocations));
assertNull(InvocationsFinder.findFirstUnverified(invocations));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(differentMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
assertNull(InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(null, InvocationsFinder.findFirstUnverifiedInOrder(context, invocations));        
assertSame(simpleMethodInvocation, InvocationsFinder.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));
assertNull(InvocationsFinder.findFirstUnverified(invocations, "different mock"));
Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));
Invocation found = InvocationsFinder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));
Location last = InvocationsFinder.getLastLocation(invocations);
assertNull(InvocationsFinder.getLastLocation(Collections.<Invocation>emptyList()));
List<Invocation> allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
allMatching = InvocationsFinder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
List<Invocation> chunk = InvocationsFinder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);
Invocation previous = InvocationsFinder.findPreviousVerifiedInOrder(invocations, context);
previous = InvocationsFinder.findPreviousVerifiedInOrder(invocations, context);
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import java.util.List;
import org.assertj.core.api.Assertions;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.mockitousage.IMethods;
public class NumberOfInvocationsInOrderCheckerTest {
private List<Invocation> invocations;
private InOrderContext context;
private IMethods mock;
public ExpectedException exception = ExpectedException.none();
checker = new NumberOfInvocationsInOrderChecker();
context = new InOrderContextImpl();
mock = mock(IMethods.class, "mock");
public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = emptyList();
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation());
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(first, second);
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 4 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 4, context);
public void shouldMarkAsVerifiedInOrder() throws Exception {
Invocation invocation = buildSimpleMethod().toInvocation();
invocations = asList(invocation);
wanted = buildSimpleMethod().toInvocationMatcher();
assertThat(context.isVerified(invocation)).isFalse();
checker.check(invocations, wanted, 1, context);
assertThat(context.isVerified(invocation)).isTrue();
public void shouldReportTooLittleActual() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 100, context);
public void shouldReportWithLastInvocationStackTrace() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
exception.expectMessage(containsTimes("-> at", 2));
checker.check(invocations, wanted, 100, context);
public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {
invocations = emptyList();
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 0 times");
exception.expectMessage(containsTimes("-> at", 1));
checker.check(invocations, wanted, 100, context);
public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
Invocation third = buildSimpleMethod().toInvocation();
invocations = asList(first, second, third);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("" + third.getLocation());
checker.check(invocations, wanted, 2, context);
public void shouldReportTooManyActual() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
invocations = asList(first, second);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expectMessage("Wanted 1 time");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 1, context);
public void shouldReportNeverWantedButInvoked() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
invocations = asList(first);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(VerificationInOrderFailure.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 0 times");
exception.expectMessage("But was 1 time. Undesired invocation");
exception.expectMessage("" + first.getLocation());
checker.check(invocations, wanted, 0, context);
public void shouldMarkInvocationsAsVerified() throws Exception {
Invocation invocation = buildSimpleMethod().toInvocation();
Assertions.assertThat(invocation.isVerified()).isFalse();
invocations = asList(invocation);
wanted = buildSimpleMethod().toInvocationMatcher();
assertThat(invocation.isVerified()).isTrue();
private static BaseMatcher<String> containsTimes(String value, int amount) {
return new StringContainsNumberMatcher(value, amount);
private static class StringContainsNumberMatcher extends TypeSafeMatcher<String> {
private final String expected;
private final int amount;
StringContainsNumberMatcher(String expected, int amount) {
this.expected = expected;
this.amount = amount;
public boolean matchesSafely(String text) {
int lastIndex = 0;
int count = 0;
while (lastIndex != -1) {
lastIndex = text.indexOf(expected, lastIndex);
if (lastIndex != -1) {
count++;
lastIndex += expected.length();
return count == amount;
public void describeTo(Description description) {
description.appendText("containing '" + expected + "' exactly " + amount + " times");
private InvocationBuilder buildSimpleMethod() {
return new InvocationBuilder().mock(mock).simpleMethod();
TestMock test = mock(TestMock.class, new Answer() {
TestMock test = mock(TestMock.class, new Answer() {
Assert.assertNotNull(((Iterable) iterable).iterator());
verify((Iterable) iterable).iterator();
iterable = (MyIterable) Proxy.newProxyInstance(
((Iterable) iterable).iterator();
List list= mock(List.class);
List mocks = new LinkedList();
List list = mock(List.class);
List list = mock(List.class);
new Answer() {
List list = new LinkedList();
List spy = Mockito.spy(list);
public int size(Map map) {
public int size(Collection collection) {
private static class RecordCall implements Answer {
private LinkedList mock;Class superClass = proxy.getClass().getSuperclass();
Class superClass = proxy.getClass().getSuperclass();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class... extraInterfaces) {
cache.put(short_lived_classloader, new HoldingAReference(new WeakReference<Class>(short_lived_classloader.loadClass("foo.Bar"))));
final WeakReference<Class> a;
HoldingAReference(WeakReference<Class> a) {
Map map = new HashMap();
CapturingMatcher m = new CapturingMatcher();
CapturingMatcher m = new CapturingMatcher();
CapturingMatcher m = new CapturingMatcher();
VarargCapturingMatcher m = new VarargCapturingMatcher<Object>();
Set expectedMock = mock(Set.class);
Set returnedMock = when(expectedMock.isEmpty()).thenReturn(false).getMock();
Set returnedMock = when(mock(Set.class).isEmpty()).thenReturn(false, true).getMock();
List<Future> futures = new ArrayList<Future>(threadingFactor);
for (Future future : futures) {Class superClass = proxy.getClass().getSuperclass();
Class superClass = proxy.getClass().getSuperclass();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class... extraInterfaces) {
cache.put(short_lived_classloader, new HoldingAReference(new WeakReference<Class>(short_lived_classloader.loadClass("foo.Bar"))));
final WeakReference<Class> a;
HoldingAReference(WeakReference<Class> a) {
Map map = new HashMap();
CapturingMatcher m = new CapturingMatcher();
CapturingMatcher m = new CapturingMatcher();
CapturingMatcher m = new CapturingMatcher();
VarargCapturingMatcher m = new VarargCapturingMatcher<Object>();
Set expectedMock = mock(Set.class);
Set returnedMock = when(expectedMock.isEmpty()).thenReturn(false).getMock();
Set returnedMock = when(mock(Set.class).isEmpty()).thenReturn(false, true).getMock();
public static class DoTheMocking implements Callable<Object> {
List<Future> futures = new ArrayList<Future>(threadingFactor);
for (Future future : futures) {BDDStubber willAnswer(Answer answer);
BDDStubber will(Answer answer);
public BDDStubber willAnswer(Answer answer) {
public BDDStubber will(Answer answer) {
public static BDDStubber willAnswer(Answer answer) {
public static BDDStubber will(Answer answer) {
import org.mockito.exceptions.Reporter;
return (List) matchers;
ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
ArrayList mock = mock(ArrayList.class);
List mock = Mockito.mock(List.class);
List mock = Mockito.mock(List.class);
List mock = Mockito.mock(List.class);
List mock = Mockito.mock(List.class, "original");
Class clazz = null;
clazz = (Class) o;
public static Assertor hasMethodsInStackTrace(final String ... methods) {public static MockitoException notAMockPassedToVerify(Class type) {
public static MockitoException mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
public static MockitoException serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {
void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {
for (Class u : undesiredAnnotations) {
private static String describeClass(Class type) {
for (Class anInterface : interfaces) {
for (Class i : extraInterfaces) {
for (Class currentExploredClass = clazz;
currentExploredClass = superClassOf(currentExploredClass)
) {
private Class superClassOf(Class currentExploredClass) {
return (Class) rawType;
return (Class) genericSuperclass;
new Class[] { MyIterable.class },
Class[] tests = {StubbingInConstructorUnused.class,
new Class[]{ byte[].class },
mock(IMethods.class, withSettings().extraInterfaces((Class[]) null));
public Object doInRealm(String callableCalledInClassLoaderRealm, Class[] argTypes, Object[] args) throws Exception {
Class[] types = new Class[args.length];
new Class[0])), new Object[0], 1, realMethod, new LocationImpl());public boolean matches(T argument);
public static MockitoException wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {
Class configClass;
configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);
public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class<?>> extraInterfaces) throws IOException {
private ConcurrentHashMap<MockKey, WeakReference<Class>> generatedClassCache =
new ConcurrentHashMap<MockKey, WeakReference<Class>>();
public <T> Class getOrGenerateMockClass(MockFeatures<T> features) {
MockKey mockKey = MockKey.of(features.mockedType, features.interfaces);
Class generatedMockClass = null;
WeakReference<Class> classWeakReference = generatedClassCache.get(mockKey);
generatedClassCache.put(mockKey, new WeakReference<Class>(generatedMockClass));
public static <T> MockKey of(Class<T> mockedType, Set<Class<?>> interfaces) {
public Class getRawReturnType() {
public static Class genericTypeOfMatcher(Class matcherClass) {
Class[] params1 = m1.getParameterTypes();
Class[] params2 = m2.getParameterTypes();
public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {
public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,
Class lhsClass = lhs.getClass();
Class rhsClass = rhs.getClass();
Class testClass;
Class clazz,
List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;
Class lhsClass = lhs.getClass();
static String toString(ArgumentMatcher matcher) {
Class cls = matcher.getClass();
public Class returnedTypeOnSignature(InvocationOnMock invocation) {
return join("\n", (Iterable<String>) (Object) asList(linesToBreak));
public static String join(String start, Iterable<String> lines) {
public static Class genericTypeOf(Class rootClass, Class targetBaseClass, Class targetBaseInterface) {
Class match = rootClass;
private static Type findGenericInteface(Class sourceClass, Class targetBaseInterface) {
Class inter = sourceClass.getInterfaces()[i];
private static Class extractGeneric(Type type) {
return (Class) genericTypes[0];
copy(from, mock, from.getClass(), mock.getClass().getSuperclass());
copy(from, to, from.getClass(), to.getClass());
private <T> void copy(T from, T to, Class fromClazz, Class toClass) {
private <T> void copyValues(T from, T mock, Class classFrom) {
for (int i = 0; i < fields.length; i++) {
Field field = fields[i];
Class getRawReturnType();
private void detectsAndCleansUp(DetectsInvalidState detector, Class expected) {public boolean matches(Object argument);
boolean isOut(StackTraceElement candidate);
public boolean isOut(StackTraceElement e) {
return false;
if (!CLEANER.isOut(element)) {
public boolean matches(Object actual) {
if(!(actual instanceof Comparable)) {
return false;
return matchResult(((Comparable) actual).compareTo(wanted));
public boolean matches(Object actual) {
return actual != null && ((String) actual).contains(substring);
public boolean matches(Object actual) {
return actual != null && ((String) actual).endsWith(suffix);
public boolean matches(Object object) {
Number actual = (Number) object;
public boolean matches(Object actual) {
return actual != null && Pattern.compile(regex).matcher((String) actual).find();
public boolean matches(Object actual) {
return actual != null && ((String) actual).startsWith(prefix);
assertThat(cleaner.isOut(type(className))).describedAs("Must be accepted %s", className).isFalse();
assertThat(cleaner.isOut(type(className))).describedAs("Must be rejected %s", className).isTrue();
public boolean matches(Object argument) {
public boolean matches(Object arg) {
return ((String) arg).contains("foo");
public boolean matches(Object arg) {
public boolean matches(Object arg) {
Character character = (Character) arg;
public boolean matches(Object arg) {
Number number = (Number) arg;
public boolean matches(Object argument) {
String arg = (String) argument;
public boolean matches(Object argument) {
package org.mockitousage.stubbing;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.AdditionalAnswers.returnsArgAt;
import static org.mockito.AdditionalAnswers.returnsFirstArg;
import static org.mockito.AdditionalAnswers.returnsLastArg;
import static org.mockito.AdditionalAnswers.returnsSecondArg;
import static org.mockito.BDDMockito.given;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.anyVararg;
import static org.mockito.Matchers.eq;
public class StubbingWithAdditionalAnswers {
public void can_return_arguments_of_invocation() throws Exception {
given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());
given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());
given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());
assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
assertThat(iMethods.threeArgumentMethod(0, "second", "whatever")).isEqualTo("second");
assertThat(iMethods.threeArgumentMethod(1, "whatever", "last")).isEqualTo("last");
public void can_return_expanded_arguments_of_invocation() throws Exception {
given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));
assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl")).isEqualTo("alice");
public void can_return_primitives_or_wrappers() throws Exception {
given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());
given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());
assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);
assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);
try {
verify(mock, timeout(40).only()).clear();
fail();
public boolean isOut(StackTraceElement candidate) {
return true;
return defaultCleaner.isOut(candidate);import static java.lang.annotation.ElementType.PARAMETER;
return false;.filter(isBootstrapClassLoader())result = delegateMethod.invoke(delegatedObject, invocation.getArguments());+ "At the moment, you cannot provide your own implementations that class.");
public void markVerified(List<Invocation> invocations, CapturesArgumentsFromInvocation wanted) {
public void markVerified(Invocation invocation, CapturesArgumentsFromInvocation wanted) {
public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumentsFromInvocation wanted, InOrderContext context) {
import org.mockito.exceptions.Reporter;
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(found, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker marker = new InvocationMarker();
marker.markVerified(chunk.get(0), wantedMatcher);
import org.mockito.internal.invocation.InvocationMarker;
InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(actualInvocations, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerifiedInOrder(chunk, wanted, orderingContext);
import org.mockito.exceptions.Reporter;
import org.mockito.internal.invocation.InvocationMarker;
import static org.mockito.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import java.util.List;
private final InvocationMarker marker;
this(new InvocationsFinder(), new InvocationMarker());
NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, InvocationMarker marker ) {
this.marker = marker;
marker.markVerified( next, wanted );
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(actualInvocations, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerifiedInOrder(chunk, wanted, context);
InvocationMarker marker = new InvocationMarker();
marker.markVerified(Arrays.asList(i), im);
InvocationMarker marker = new InvocationMarker();
marker.markVerified(Arrays.asList(i), c);
InvocationMarker marker = new InvocationMarker();
marker.markVerifiedInOrder(Arrays.asList(i), im, context);
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import org.mockito.Mockito;
import org.mockito.internal.invocation.*;
import org.mockitoutil.TestBase;
public class AtLeastXNumberOfInvocationsCheckerTest extends TestBase {
c.invocationMarker = Mockito.mock(InvocationMarker.class);
Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)), any(CapturesArgumentsFromInvocation.class));public void markVerified(List<Invocation> invocations, CapturesArgumentsFromInvocation wanted) {
public void markVerified(Invocation invocation, CapturesArgumentsFromInvocation wanted) {
public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumentsFromInvocation wanted, InOrderContext context) {
import org.mockito.exceptions.Reporter;
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(found, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker marker = new InvocationMarker();
marker.markVerified(chunk.get(0), wantedMatcher);
import org.mockito.internal.invocation.InvocationMarker;
InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(actualInvocations, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerifiedInOrder(chunk, wanted, orderingContext);
import org.mockito.exceptions.Reporter;
import org.mockito.internal.invocation.InvocationMarker;
import static org.mockito.exceptions.Reporter.tooLittleActualInvocationsInOrder;
import java.util.List;
private final InvocationMarker marker;
this(new InvocationsFinder(), new InvocationMarker());
NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, InvocationMarker marker ) {
this.marker = marker;
marker.markVerified( next, wanted );
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerified(actualInvocations, wanted);
import org.mockito.internal.invocation.InvocationMarker;
private final InvocationMarker invocationMarker = new InvocationMarker();
invocationMarker.markVerifiedInOrder(chunk, wanted, context);
InvocationMarker marker = new InvocationMarker();
marker.markVerified(Arrays.asList(i), im);
InvocationMarker marker = new InvocationMarker();
marker.markVerified(Arrays.asList(i), c);
InvocationMarker marker = new InvocationMarker();
marker.markVerifiedInOrder(Arrays.asList(i), im, context);
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import org.mockito.Mockito;
import org.mockito.internal.invocation.*;
import org.mockitoutil.TestBase;
public class AtLeastXNumberOfInvocationsCheckerTest extends TestBase {
c.invocationMarker = Mockito.mock(InvocationMarker.class);
Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)), any(CapturesArgumentsFromInvocation.class));"Wanted " + discrepancy.getPluralizedWantedCount() + ":",
"But was " + discrepancy.getPluralizedActualCount() + ":",
public boolean isOut(StackTraceElement candidate) {
String className = candidate.getClassName();
if (isFromMockitoRunner(className))
if (isFromMockitoRule(className))
return true;
if (isFromMockito(className)){
if (isTest(className))
return true;
return false;
if (isMock(className))
return false;
return true;
private boolean isTest(String className) {
return className.endsWith("Test");
private boolean isMock(String className) {
private boolean isFromMockito(String className) {
private boolean isFromMockitoRule(String className) {
private boolean isFromMockitoRunner(String className) {
if (CLEANER.isOut(element)) {
public void mock_should_have_annotations_copied_from_mocked_type_on_fields() {
AnnotationWithDefaultValue onClassDefaultValue = field("field", mock(OnField.class)).getAnnotation(AnnotationWithDefaultValue.class);
AnnotationWithCustomValue onClassCustomValue = field("field", mock(OnField.class)).getAnnotation(AnnotationWithCustomValue.class);
Assertions.assertThat(onClassDefaultValue.value()).isEqualTo("yup");
Assertions.assertThat(onClassCustomValue.value()).isEqualTo("yay");
public class OnField {
public String field;
assertThat(cleaner.isOut(type(className))).describedAs("Must be accepted %s", className).isTrue();
assertThat(cleaner.isOut(type(className))).describedAs("Must be rejected %s", className).isFalse();
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.List;
private NumberOfInvocationsChecker checker;
private InvocationMatcher wanted;
private List<Invocation> invocations;
private IMethods mock;
public ExpectedException exception = ExpectedException.none();
public TestName testName = new TestName();
public void setup() {
checker = new NumberOfInvocationsChecker();
public void shouldReportTooLittleActual() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(TooLittleActualInvocations.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 100);
public void shouldReportWithLastInvocationStackTrace() throws Exception {
wanted = buildSimpleMethod().toInvocationMatcher();
invocations = asList(buildSimpleMethod().toInvocation(), buildSimpleMethod().toInvocation());
exception.expect(TooLittleActualInvocations.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 100);
public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {
invocations = emptyList();
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(TooLittleActualInvocations.class);
exception.expectMessage("mock.simpleMethod()");
exception.expectMessage("Wanted 100 times:");
exception.expectMessage("-> at " + getClass().getName() + "." + testName.getMethodName());
checker.check(invocations, wanted, 100);
public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
Invocation third = buildSimpleMethod().toInvocation();
invocations = asList(first, second, third);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(TooManyActualInvocations.class);
exception.expectMessage("" + third.getLocation());
checker.check(invocations, wanted, 2);
public void shouldReportTooManyActual() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
Invocation second = buildSimpleMethod().toInvocation();
invocations = asList(first, second);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expectMessage("Wanted 1 time");
exception.expectMessage("But was 2 times");
checker.check(invocations, wanted, 1);
public void shouldReportNeverWantedButInvoked() throws Exception {
Invocation first = buildSimpleMethod().toInvocation();
invocations = asList(first);
wanted = buildSimpleMethod().toInvocationMatcher();
exception.expect(NeverWantedButInvoked.class);
exception.expectMessage("Never wanted here");
exception.expectMessage("But invoked here");
exception.expectMessage("" + first.getLocation());
checker.check(invocations, wanted, 0);
public void shouldMarkInvocationsAsVerified() throws Exception {
Invocation invocation = buildSimpleMethod().toInvocation();
assertThat(invocation.isVerified()).isFalse();
invocations = asList(invocation);
wanted = buildSimpleMethod().toInvocationMatcher();
checker.check(invocations, wanted, 1);
assertThat(invocation.isVerified()).isTrue();
private InvocationBuilder buildSimpleMethod() {
return new InvocationBuilder().mock(mock).simpleMethod();import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import static org.mockito.Mockito.mock;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;boolean apply(StackTraceElement candidate);
public boolean apply(StackTraceElement candidate) {
if (CLEANER.apply(element)) {
import org.assertj.core.api.Assertions;
assertThat(cleaner.apply(type(className))).describedAs("Must be accepted %s", className).isTrue();
assertThat(cleaner.apply(type(className))).describedAs("Must be rejected %s", className).isFalse();
Invocation invocation = new InvocationBuilder().toInvocation();
wanted = new InvocationBuilder().toInvocationMatcher();
public boolean apply(StackTraceElement candidate) {
return defaultCleaner.apply(candidate);public static class BDDOngoingStubbingImpl<T> implements BDDMyOngoingStubbing<T> {
static class ThenImpl<T> implements Then<T> {
public static class BDDStubberImpl implements BDDStubber {
public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {
return MOCKITO_CORE.stub(methodCall);
public static <T> VoidMethodStubbable<T> stubVoid(T mock) {
return MOCKITO_CORE.stubVoid(mock);
public @interface Mock {}    
import org.mockito.internal.progress.IOngoingStubbing;
public IOngoingStubbing stub() {
IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();
public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {
mockingProgress.stubbingStarted();
return (DeprecatedOngoingStubbing) stub();
public <T> OngoingStubbing<T> when(T methodCall) {
mockingProgress.stubbingStarted();
return (OngoingStubbing) stub();
registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());
package org.mockito.internal.configuration;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations.Mock;
import java.lang.reflect.Field;
public class MockitoAnnotationsMockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {
public Object process(Mock annotation, Field field) {
return Mockito.mock(field.getType(), field.getName());
assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);
import org.mockito.MockitoAnnotations;
return null != field.getAnnotation(Spy.class)
|| null != field.getAnnotation(Mock.class)
|| null != field.getAnnotation(MockitoAnnotations.Mock.class);
public <T> T getArgumentAt(int index, Class<T> clazz) {
return (T) getArgument(index);
public <T> T getArgumentAt(int index, Class<T> clazz) {
return (T) getArgument(index);
public class JUnitRule {
private final MockitoLogger logger;
public JUnitRule(MockitoLogger logger) {
this.logger = logger;
public Statement apply(final Statement base, final Object target) {
return new Statement() {
package org.mockito.internal.progress;
public interface IOngoingStubbing {}
import org.mockito.MockSettings;
void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing);
IOngoingStubbing pullOngoingStubbing();
IOngoingStubbing iOngoingStubbing;
public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {
this.iOngoingStubbing = iOngoingStubbing;
public IOngoingStubbing pullOngoingStubbing() {
IOngoingStubbing temp = iOngoingStubbing;
iOngoingStubbing = null;
iOngoingStubbing = null;
return  "iOngoingStubbing: " + iOngoingStubbing + 
public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {
public IOngoingStubbing pullOngoingStubbing() {
import org.mockito.stubbing.DeprecatedOngoingStubbing;
public abstract class BaseStubbing<T> implements OngoingStubbing<T>, DeprecatedOngoingStubbing<T> {
public DeprecatedOngoingStubbing<T> toReturn(T value) {
return toAnswer(new Returns(value));
public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {
return toAnswer(new ThrowsException(throwable));
import org.mockito.stubbing.DeprecatedOngoingStubbing;
public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {
invocationContainerImpl.addConsecutiveAnswer(answer);
return this;
import org.mockito.stubbing.DeprecatedOngoingStubbing;
public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {
invocationContainerImpl.addAnswer(answer);
return new ConsecutiveStubbing<T>(invocationContainerImpl);
package org.mockito.internal.stubbing.defaultanswers;
import org.mockito.Mockito;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.stubbing.Answer;
public enum Answers {
RETURNS_DEFAULTS(new GloballyConfiguredAnswer()),
RETURNS_SMART_NULLS(new ReturnsSmartNulls()),
RETURNS_MOCKS(new ReturnsMocks()),
RETURNS_DEEP_STUBS(new ReturnsDeepStubs()),
CALLS_REAL_METHODS(new CallsRealMethods())
private final Answer<Object> implementation;
private Answers(Answer<Object> implementation) {
this.implementation = implementation;
public Answer<Object> get() {
return implementation;
<T> T getArgumentAt(int index, Class<T> clazz);
return new MockitoJUnitRule();
package org.mockito.junit;
import org.junit.rules.MethodRule;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.mockito.internal.junit.JUnitRule;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.MockitoLogger;
public class MockitoJUnitRule implements MethodRule, MockitoRule {
private final JUnitRule jUnitRule;
public MockitoJUnitRule() {
this.jUnitRule = new JUnitRule(new ConsoleMockitoLogger());
public MockitoJUnitRule(MockitoLogger logger) {
this.jUnitRule = new JUnitRule(logger);
public MockitoJUnitRule(Object targetTest) {
this();
public Statement apply(Statement base, FrameworkMethod method, Object target) {
return jUnitRule.apply(base, target);
package org.mockito.stubbing;
import org.mockito.Mockito;
import org.mockito.internal.progress.IOngoingStubbing;
public interface DeprecatedOngoingStubbing<T> extends IOngoingStubbing {
DeprecatedOngoingStubbing<T> toReturn(T value);
DeprecatedOngoingStubbing<T> toThrow(Throwable throwable);
DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer);
import org.mockito.internal.progress.IOngoingStubbing;
public interface OngoingStubbing<T> extends IOngoingStubbing {
public VerificationMode never();
public VerificationMode atMost(int maxNumberOfInvocations);
package org.concurrentmockito;
import static org.mockito.Mockito.*;
import org.junit.Ignore;
import org.junit.Test;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
public class ThreadsStubSharedMockTest extends TestBase {
private IMethods mock;
public void shouldStubFineConcurrently() throws Exception {
for(int i = 0; i < 100; i++) {
performTest();
private void performTest() throws InterruptedException {
mock = mock(IMethods.class);
final Thread[] listeners = new Thread[3];
for (int i = 0; i < listeners.length; i++) {
listeners[i] = new Thread() {
public void run() {
when(mock.simpleMethod(getId()))
.thenReturn(getId() + "")
.thenReturn("foo")
.thenReturn("bar");
stubVoid(mock)
.toThrow(new RuntimeException(getId() + ""))
.toReturn()
.toThrow(new RuntimeException())
.on().differentMethod();
listeners[i].start();
for (Thread listener : listeners) {
listener.join();
public void shouldValidateMockWhenStubbingVoid() {
Mockito.stubVoid("notMock");
when(mock.simpleMethod());
detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);
public void shouldDetectUnfinishedStubbingVoid() {
stubVoid(mock);
detectsAndCleansUp(new OnMethodCallOnMock(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnStub(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnVerify(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);
stubVoid(mock);
detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);
doAnswer(null);
detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);
verify(mock);
detectsAndCleansUp(new OnStubVoid(), UnfinishedVerificationException.class);
public void shouldDetectMisplacedArgumentMatcher() {
anyObject();
detectsAndCleansUp(new OnStubVoid(), InvalidUseOfMatchersException.class);
stubVoid(mock).toThrow(new RuntimeException());
stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);
stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);
private static class OnStubVoid implements DetectsInvalidState {
public void detect(IMethods mock) {
stubVoid(mock);
jUnitRule.apply(new DummyStatement(), injectTestCase).evaluate();
jUnitRule.apply(new ExceptionStatement(), injectTestCase).evaluate();
jUnitRule.apply(new UnfinishedStubbingStatement(), injectTestCase).evaluate();
package org.mockitousage.annotation;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import java.awt.*;
import static org.junit.Assert.assertNotNull;
public class DeprecatedMockAnnotationTest {
public void initMocks() throws Exception {
MockitoAnnotations.initMocks(this);
public void shouldCreateMockForDeprecatedMockAnnotation() throws Exception {
assertNotNull(deprecatedMock);
public void shouldInjectDeprecatedMockAnnotation() throws Exception {
assertNotNull(anInjectedObject.aFieldAwaitingInjection);
private static class AnInjectedObject {
List aFieldAwaitingInjection;
stubVoid(mock).toThrow(expected).on().withStringVarargs(3, "1", "2", "3", "4");
package org.mockitousage.bugs;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import static org.mockito.Mockito.*;
public class TimeoutWithAtMostOrNeverShouldBeDisabledTest extends TestBase {
public void shouldDisableTimeoutForAtMost() {
try {
verify(mock, timeout(30000).atMost(1)).simpleMethod();
fail();
public void shouldDisableTimeoutForNever() {
try {
verify(mock, timeout(30000).never()).simpleMethod();
fail();
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertNotNull;
public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule("asdf");
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);
stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);
stubVoid(spy)
.toReturn()
.toThrow(new RuntimeException())
.on().clear();
package org.mockitousage.stubbing;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
public class DeprecatedStubbingTest extends TestBase {
public void setup() {
mock = mock(IMethods.class);
public void shouldEvaluateLatestStubbingFirst() throws Exception {
stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);
stub(mock.objectReturningMethod(200)).toReturn(200);
assertEquals(200, mock.objectReturningMethod(200));
assertEquals(100, mock.objectReturningMethod(666));
assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));
public void shouldStubbingBeTreatedAsInteraction() throws Exception {
stub(mock.booleanReturningMethod()).toReturn(true);
mock.booleanReturningMethod();
try {
verifyNoMoreInteractions(mock);
fail();
public void shouldAllowStubbingToString() throws Exception {
IMethods mockTwo = mock(IMethods.class);
stub(mockTwo.toString()).toReturn("test");
assertContains("Mock for IMethods", mock.toString());
assertEquals("test", mockTwo.toString());
public void shouldStubbingNotBeTreatedAsInteraction() {
stub(mock.simpleMethod("one")).toThrow(new RuntimeException());
stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod("two");
verifyZeroInteractions(mock);
public void shouldAllowConsecutiveStubbing() throws Exception {
stub(mock.simpleMethod())
.toReturn("100")
.toReturn("200");
assertEquals("100", mock.simpleMethod());
assertEquals("200", mock.simpleMethod());
import static org.mockito.Mockito.stubVoid;
import static org.mockito.Mockito.when;
stubVoid(mock)
.toThrow(new IllegalArgumentException())
.toReturn()
.toThrow(new NullPointerException())
.on().voidMethod();
stubVoid(mock).toReturn()
.toThrow(new NullPointerException())
.toReturn()
.on().voidMethod();
stubVoid(mock).toReturn()
.toThrow(new Exception())
.on().voidMethod();
import java.lang.reflect.Method;
import java.util.Set;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.stubVoid;
import static org.mockito.Mockito.when;
stubVoid(mock).toAnswer(recordCall).on().voidMethod();
stubVoid(mock).toAnswer(call1)
.toThrow(new UnsupportedOperationException())
.toAnswer(call2)
.on().voidMethod();
stubVoid(mock).toThrow(expected).on().clear();
stubVoid(mock).toThrow(new ExceptionOne()).on().clear();
stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();
stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();
stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();
stubVoid(mock).toThrow(new RuntimeException()).on().clone();
stubVoid(mock).toThrow(new RuntimeException()).on().clone();
return CoreMatchers.isA((Class) type);
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.base.MockitoException;
import java.lang.reflect.Field;
import java.util.HashSet;
import java.util.Set;
.filter(annotatedBy(Mock.class,
Spy.class,
MockitoAnnotations.Mock.class))
private Set<Object> instanceMocksIn(Object instance, Class<?> clazz) {
Set<Object> instanceMocks = new HashSet<Object>();
Field[] declaredFields = clazz.getDeclaredFields();
for (Field declaredField : declaredFields) {
if (declaredField.isAnnotationPresent(Mock.class) || declaredField.isAnnotationPresent(Spy.class)) {
declaredField.setAccessible(true);
try {
Object fieldValue = declaredField.get(instance);
if (fieldValue != null) {
instanceMocks.add(fieldValue);
throw new MockitoException("Could not access field " + declaredField.getName());
return instanceMocks;return (T) arguments[index];
return (T) arguments[index];
((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
package org.mockito.internal.runners;
import org.junit.internal.runners.InitializationError;
import org.junit.internal.runners.JUnit4ClassRunner;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Filter;
import org.junit.runner.manipulation.NoTestsRemainException;
import org.junit.runner.notification.RunNotifier;
import org.mockito.MockitoAnnotations;
import org.mockito.internal.runners.util.FrameworkUsageValidator;
public class JUnit44RunnerImpl implements RunnerImpl {
JUnit4ClassRunner runner;
public JUnit44RunnerImpl(Class<?> klass) throws InitializationError {
this.runner = new JUnit4ClassRunner(klass) {
protected Object createTest() throws Exception {
Object test = super.createTest();
MockitoAnnotations.initMocks(test);
return test;
public void run(RunNotifier notifier) {
notifier.addListener(new FrameworkUsageValidator(notifier));
runner.run(notifier);
public Description getDescription() {
return runner.getDescription();
public void filter(Filter filter) throws NoTestsRemainException {
runner.filter(filter);
if (runnerProvider.isJUnit45OrHigherAvailable()) {
return runnerProvider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl", klass);
return runnerProvider.newInstance("org.mockito.internal.runners.JUnit44RunnerImpl", klass);
"MockitoRunner can only be used with JUnit 4.4 or higher.\n" +
"If you get this error despite using JUnit 4.4 or higher then please report this error to the mockito mailing list.\n"
private static boolean hasJUnit45OrHigher; 
static {
try {
Class.forName("org.junit.runners.BlockJUnit4ClassRunner");
hasJUnit45OrHigher = true;
hasJUnit45OrHigher = false;
public boolean isJUnit45OrHigherAvailable() {
return hasJUnit45OrHigher;
return invocation.getArguments()[actualArgumentPosition(invocation)];
return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
assertEquals(argumentValue, invocation.getArguments()[0]);
public void _dont_implement_Matcher___instead_extend_BaseMatcher_() { }
int secondArgument = invocationOnInterface.getArgumentAt(1, int.class);
package org.mockito.internal.runners;
import static org.hamcrest.CoreMatchers.*;
import org.junit.Test;
import org.junit.runners.model.InitializationError;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.runners.util.RunnerProvider;
import org.mockitoutil.TestBase;
import java.lang.reflect.InvocationTargetException;
public class RunnerFactoryTest extends TestBase {
static class ClassProviderStub extends RunnerProvider {
public boolean isJUnit45OrHigherAvailable() {
return super.isJUnit45OrHigherAvailable();
public void shouldCreateRunnerForJUnit44() throws Exception {
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return false;
RunnerFactory factory = new RunnerFactory(provider);
RunnerImpl runner = factory.create(RunnerFactoryTest.class);
assertThat(runner, is(JUnit44RunnerImpl.class));
public void shouldCreateRunnerForJUnit45()  throws Exception{
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return true;
RunnerFactory factory = new RunnerFactory(provider);
RunnerImpl runner = factory.create(RunnerFactoryTest.class);
assertThat(runner, is(JUnit45AndHigherRunnerImpl.class));
public void
shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound()  throws Exception{
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return false;
public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {
throw new InitializationError("Where is JUnit, dude?");
RunnerFactory factory = new RunnerFactory(provider);
try {
factory.create(RunnerFactoryTest.class);
fail();
assertContains("upgrade your JUnit version", e.getMessage());
static class NoTestMethods {}
public void shouldSaySomethingMeaningfulWhenNoTestMethods()  throws Exception{
RunnerFactory factory = new RunnerFactory(new RunnerProvider());
try {
factory.create(NoTestMethods.class);
fail();
catch (MockitoException e) {
assertContains("No tests", e.getMessage());
public void shouldForwardInvocationTargetException()  throws Exception{
RunnerFactory factory = new RunnerFactory(new RunnerProvider()
public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {
throw new InvocationTargetException(new RuntimeException());
try {
factory.create(this.getClass());
fail();
catch (InvocationTargetException e) {}
public void shouldKnowAboutJUnit45() throws Exception {
RunnerProvider provider = new RunnerProvider();
assertTrue(provider.isJUnit45OrHigherAvailable());
package org.mockitousage.verification;
ImportLogBean bean = (ImportLogBean) invocation.getArguments()[0];
assertThat(mock, is(List.class));
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
String arg = (String) invocation.getArguments()[0];
return CoreMatchers.is(type);
protected static <T> void assertThat(T actual, Matcher<T> m) {
org.junit.Assert.assertThat(actual, m);return (T) getArgument(index);
public <T> T getArgument(int index) {
return (T)arguments[index];
return (T) getArgument(index);
public <T> T getArgument(int index) {
return (T)arguments[index];
((CapturesArguments) m).captureFrom(invocation.getArgument(position));
return runnerProvider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl", klass);
"MockitoRunner can only be used with JUnit 4.5 or higher.\n" +
"If you get this error despite using JUnit 4.5 or higher then please report this error to the mockito mailing list.\n"
return invocation.getArgument(actualArgumentPosition(invocation));
return invocation.getMock() == invocation.getArgument(0) ? 0 : 1;
<T> T getArgument(int index);
assertEquals(argumentValue, invocation.getArgument(0));
public void describeMismatch(Object item, Description mismatchDescription) {}
public void describeMismatch(Object item, Description mismatchDescription) {}
public void describeMismatch(Object item, Description mismatchDescription) {}
public void describeMismatch(Object item, Description mismatchDescription) {}
public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {}
public void describeMismatch(Object item, Description mismatchDescription) {
int secondArgument = invocationOnInterface.getArgument(1);
package org.mockito.internal.verification;
ImportLogBean bean =  invocation.getArgument(0);
assertTrue(mock instanceof List);
return  invocation.getArgument(0);
return  invocation.getArgument(0);
return  invocation.getArgument(0);
package org.mockitousage.junitrunner;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class MockitoJUnitRunnerTest {
JUnitCore runner = new JUnitCore();
Result result = runner.run(
StubbingInConstructorUsed.class,
StubbingInBeforeUsed.class,
StubbingInTestUsed.class
);
assertTrue(result.wasSuccessful());
JUnitCore runner = new JUnitCore();
Class[] tests = {StubbingInConstructorUnused.class,
StubbingInBeforeUnused.class,
StubbingInTestUnused.class};
Result result = runner.run(tests);
System.out.println(result.getFailures());
assertEquals(tests.length, result.getFailureCount());
public static class StubbingInConstructorUsed extends StubbingInConstructorUnused{
assertEquals("1", mock.simpleMethod(1));
public static class StubbingInConstructorUnused {
IMethods mock = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
public static class StubbingInBeforeUsed extends StubbingInBeforeUnused{
assertEquals("1", mock.simpleMethod(1));
public static class StubbingInBeforeUnused {
IMethods mock;
mock = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
public static class StubbingInTestUsed {
IMethods mock = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
assertEquals("1", mock.simpleMethod(1));
public static class StubbingInTestUnused {
when(mock(IMethods.class).simpleMethod(1)).thenReturn("1");
String arg =  invocation.getArgument(0);
return CoreMatchers.isA((Class) type);
protected static <T> void assertThat(T actual, Matcher<? super T> matcher) {
org.junit.Assert.assertThat(actual, matcher);throw new AssertionError("Wrong number of failures, expected: " + expectedFailureCount + ", actual: " + expectedFailureCount + "\n" +import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;package org.mockito.internal.runners;
import org.junit.internal.runners.InitializationError;
import org.junit.internal.runners.JUnit4ClassRunner;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Filter;
import org.junit.runner.manipulation.NoTestsRemainException;
import org.junit.runner.notification.RunNotifier;
import org.mockito.MockitoAnnotations;
import org.mockito.internal.runners.util.FrameworkUsageValidator;
public class JUnit44RunnerImpl implements RunnerImpl {
JUnit4ClassRunner runner;
public JUnit44RunnerImpl(Class<?> klass) throws InitializationError {
this.runner = new JUnit4ClassRunner(klass) {
protected Object createTest() throws Exception {
Object test = super.createTest();
MockitoAnnotations.initMocks(test);
return test;
public void run(RunNotifier notifier) {
notifier.addListener(new FrameworkUsageValidator(notifier));
runner.run(notifier);
public Description getDescription() {
return runner.getDescription();
public void filter(Filter filter) throws NoTestsRemainException {
runner.filter(filter);
if (runnerProvider.isJUnit45OrHigherAvailable()) {
return runnerProvider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl", klass);
return runnerProvider.newInstance("org.mockito.internal.runners.JUnit44RunnerImpl", klass);
"MockitoRunner can only be used with JUnit 4.4 or higher.\n" +
"If you get this error despite using JUnit 4.4 or higher then please report this error to the mockito mailing list.\n"
private static boolean hasJUnit45OrHigher; 
static {
try {
Class.forName("org.junit.runners.BlockJUnit4ClassRunner");
hasJUnit45OrHigher = true;
hasJUnit45OrHigher = false;
public boolean isJUnit45OrHigherAvailable() {
return hasJUnit45OrHigher;
package org.mockito.internal.runners;
import org.junit.Test;
import org.junit.runners.model.InitializationError;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.runners.util.RunnerProvider;
import org.mockitoutil.TestBase;
import java.lang.reflect.InvocationTargetException;
public class RunnerFactoryTest extends TestBase {
static class ClassProviderStub extends RunnerProvider {
public boolean isJUnit45OrHigherAvailable() {
return super.isJUnit45OrHigherAvailable();
public void shouldCreateRunnerForJUnit44() throws Exception {
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return false;
RunnerFactory factory = new RunnerFactory(provider);
RunnerImpl runner = factory.create(RunnerFactoryTest.class);
assertTrue(runner instanceof JUnit44RunnerImpl);
public void shouldCreateRunnerForJUnit45()  throws Exception{
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return true;
RunnerFactory factory = new RunnerFactory(provider);
RunnerImpl runner = factory.create(RunnerFactoryTest.class);
assertTrue(runner instanceof JUnit45AndHigherRunnerImpl);
public void
shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound()  throws Exception{
RunnerProvider provider = new RunnerProvider() {
public boolean isJUnit45OrHigherAvailable() {
return false;
public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {
throw new InitializationError("Where is JUnit, dude?");
RunnerFactory factory = new RunnerFactory(provider);
try {
factory.create(RunnerFactoryTest.class);
fail();
assertContains("upgrade your JUnit version", e.getMessage());
static class NoTestMethods {}
public void shouldSaySomethingMeaningfulWhenNoTestMethods()  throws Exception{
RunnerFactory factory = new RunnerFactory(new RunnerProvider());
try {
factory.create(NoTestMethods.class);
fail();
catch (MockitoException e) {
assertContains("No tests", e.getMessage());
public void shouldForwardInvocationTargetException()  throws Exception{
RunnerFactory factory = new RunnerFactory(new RunnerProvider()
public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {
throw new InvocationTargetException(new RuntimeException());
try {
factory.create(this.getClass());
fail();
catch (InvocationTargetException e) {}
public void shouldKnowAboutJUnit45() throws Exception {
RunnerProvider provider = new RunnerProvider();
assertTrue(provider.isJUnit45OrHigherAvailable());public void _dont_implement_Matcher___instead_extend_BaseMatcher_() { }
import static org.hamcrest.CoreMatchers.*;
assertThat(runner, is(JUnit44RunnerImpl.class));
assertThat(runner, is(JUnit45AndHigherRunnerImpl.class));
assertThat(mock, is(List.class));
return CoreMatchers.is(type);
protected static <T> void assertThat(T actual, Matcher<T> m) {
org.junit.Assert.assertThat(actual, m);return (T) arguments[index];
return (T) arguments[index];
((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
return invocation.getArguments()[actualArgumentPosition(invocation)];
return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
assertEquals(argumentValue, invocation.getArguments()[0]);
int secondArgument = invocationOnInterface.getArgumentAt(1, int.class);
ImportLogBean bean = (ImportLogBean) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
String arg = (String) invocation.getArguments()[0];assertTrue(logger.getLoggedInfo().startsWith("This stubbing was never used"));public class SimpleMockitoLogger extends ConsoleMockitoLogger {
"' but this field is not declared withing hierarchy of this class!");
public interface DescribedInvocation {
runner = new MockitoJUnitRunner(DummyTest.class);
ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.AdditionalAnswers;
when(mock.objectReturningMethodNoArgs()).thenAnswer(AdditionalAnswers.returnsElementsOf(list));
when(mock.objectReturningMethodNoArgs()).thenAnswer(AdditionalAnswers.returnsElementsOf(list));
AdditionalAnswers.returnsElementsOf(null);missingInvocation.check(data.getAllInvocations(), data.getWanted());
numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);
import static org.mockito.Mockito.after;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;return (T) getArgument(index);
public <T> T getArgument(int index) {
return (T)arguments[index];
return (T) getArgument(index);
public <T> T getArgument(int index) {
return (T)arguments[index];
((CapturesArguments) m).captureFrom(invocation.getArgument(position));
return invocation.getArgument(actualArgumentPosition(invocation));
return invocation.getMock() == invocation.getArgument(0) ? 0 : 1;
<T> T getArgument(int index);
assertEquals(argumentValue, invocation.getArgument(0));
int secondArgument = invocationOnInterface.getArgument(1);
ImportLogBean bean =  invocation.getArgument(0);
return  invocation.getArgument(0);
return  invocation.getArgument(0);
return  invocation.getArgument(0);
String arg =  invocation.getArgument(0);return (T) arguments[index];
return (T) arguments[index];
((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
return invocation.getArguments()[actualArgumentPosition(invocation)];
return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
assertEquals(argumentValue, invocation.getArguments()[0]);
int secondArgument = invocationOnInterface.getArgumentAt(1, int.class);
ImportLogBean bean = (ImportLogBean) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
return (String) invocation.getArguments()[0];
String arg = (String) invocation.getArguments()[0];import static org.mockito.Mockito.*;
import static org.mockito.hamcrest.MockitoHamcrest.argThat;
import static org.mockito.Mockito.argThat;
when(mock.simpleMethod(argThat(new ArgumentMatcher<String>() {The following example shows verification but the same applies to stubbing:The following example shows verification but the same applies to stubbing:validator.validateSerializable(typeToMock, source.isSerializable());
public void validateSerializable(Class<?> classToMock, boolean serializable) {
if(serializable
&& !classToMock.isInterface()
&& !(Serializable.class.isAssignableFrom(classToMock))
&& Constructors.noArgConstructorOf(classToMock) == null
) {
new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);
public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {
class NonSerializableInnerClassThatHaveAHiddenOneArgConstructor {}
boolean serializable = true;
validator.validateSerializable(NonSerializableInnerClassThatHaveAHiddenOneArgConstructor.class, serializable);
public void should_allow_serializable_with_interfaces_or_Serializable_objects() {
boolean serializable = true;
validator.validateSerializable(Observer.class, serializable);
validator.validateSerializable(Integer.class, serializable);
public static class FailTestClass {
NotSerializableAndNoDefaultConstructor notSerializableAndNoDefaultConstructor;
public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {
try {
FailTestClass testClass = new FailTestClass();
MockitoAnnotations.initMocks(testClass);
serializeAndBack(testClass.notSerializableAndNoDefaultConstructor);
fail("should have thrown an exception to say the object is not serializable");
Assertions.assertThat(e.getMessage())
.contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())
.contains("serializable()")
.contains("implement Serializable")
.contains("no-arg constructor");
static class NotSerializableAndNoDefaultConstructor {
NotSerializableAndNoDefaultConstructor(Observable o) { super(); }
public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {
try {
serializeAndBack(mock(NotSerializableAndNoDefaultConstructor.class, withSettings().serializable()));
fail("should have thrown an exception to say the object is not serializable");
Assertions.assertThat(e.getMessage())
.contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())
.contains("serializable()")
.contains("implement Serializable")
.contains("no-arg constructor");BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses);
public BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses) {
return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableClasses));
BDDStubber willThrow(Throwable toBeThrown);
public BDDStubber willThrow(Throwable toBeThrown) {
public static BDDStubber willThrow(Throwable toBeThrown) {
public static Stubber doThrow(Throwable toBeThrown) {
return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));
return MOCKITO_CORE.doAnswer(new ThrowsExceptionClass(toBeThrown));
return MOCKITO_CORE.doAnswer(new CallsRealMethods());
return MOCKITO_CORE.doAnswer(answer);
return MOCKITO_CORE.doAnswer(new DoesNothing());
return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.DeprecatedOngoingStubbing;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidMethodStubbable;
public Stubber doAnswer(Answer answer) {
return new StubberImpl().doAnswer(answer);
OngoingStubbing<T> stubbing = thenReturn(value);            
thenThrow((Throwable) null);
private OngoingStubbing<T> thenThrow(Class<? extends Throwable> throwableClass) {
return thenAnswer(new ThrowsExceptionClass(throwableClass));
public OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses) {
if (throwableClasses == null) {
OngoingStubbing<T> stubbing = null;
for (Class<? extends Throwable> t: throwableClasses) {
if (stubbing == null) {
stubbing = thenThrow(t);
stubbing = stubbing.thenThrow(t);
answers.add(new Returns(toBeReturned));
public Stubber doThrow(Throwable toBeThrown) {
answers.add(new ThrowsException(toBeThrown));
answers.add(new ThrowsExceptionClass(toBeThrown));
this.throwableClass = throwableClass;
OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses);
Stubber doThrow(Throwable toBeThrown);
assertEquals("bar", mock.simpleMethod("foo"));
assertEquals(null, mock.simpleMethod("whatever"));
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("foo", mock.simpleMethod("whatever"));
assertEquals("bar", mock.simpleMethod("whatever"));
assertEquals("foo", mock.simpleMethod());
assertEquals(null, mock.simpleMethod());
assertEquals(null, mock.simpleMethod("boooo"));
assertEquals("foo", mock.simpleMethod("bar"));
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("woof", dog.bark());
assertEquals("woof", dog.bark());
assertEquals(expectedMock, returnedMock);
import static org.mockito.Mockito.*;
public void shouldReturnConsecutiveValues() throws Exception {
.thenReturn("one")
.thenReturn("two")
.thenReturn("three");
public void shouldReturnConsecutiveValuesForTwoNulls() throws Exception {
when(mock.simpleMethod()).thenReturn(null, (String[])null);
assertNull(mock.simpleMethod());        
assertNull(mock.simpleMethod());        
public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethod() throws Exception {        
when(mock.simpleMethod())
.thenReturn("one", "two", "three");
public void shouldReturnConsecutiveValueAndThrowExceptionssSetByShortenReturnMethods()
throws Exception {
when(mock.simpleMethod())
.thenReturn("zero")
.thenReturn("one", "two")
.thenThrow(new NullPointerException(), new RuntimeException())
.thenReturn("three")
.thenThrow(new IllegalArgumentException());
public void shouldThrowConsecutively() throws Exception {
when(mock.simpleMethod())
.thenThrow(new RuntimeException())
.thenThrow(new IllegalArgumentException())
.thenThrow(new NullPointerException());
public void shouldThrowConsecutivelySetByShortenThenThrowMethod() throws Exception {
when(mock.simpleMethod())
.thenThrow(new RuntimeException(), new IllegalArgumentException(), new NullPointerException());
public void shouldMixConsecutiveReturnsWithExcepions() throws Exception {
.thenThrow(new IllegalArgumentException())
.thenReturn("one")
.thenThrow(new NullPointerException())
.thenReturn(null);
public void shouldValidateConsecutiveException() throws Exception {
.thenReturn("one")
.thenThrow(new Exception());
public void shouldStubVoidMethodAndContinueThrowing() throws Exception {
.toThrow(new IllegalArgumentException())
.toReturn()
.toThrow(new NullPointerException())
.on().voidMethod();
public void shouldStubVoidMethod() throws Exception {
stubVoid(mock)
.toReturn()
.toThrow(new NullPointerException())
.toReturn()
.on().voidMethod();
public void shouldValidateConsecutiveExceptionForVoidMethod() throws Exception {
stubVoid(mock)
.toReturn()
.toThrow(new Exception())
.on().voidMethod();
public void shouldStub() throws Exception {
assertEquals("bar", mock.simpleMethod());
public void shouldStubWithArgs() throws Exception {
assertEquals("foo", mock.simpleMethod("foo"));
assertEquals("bar", mock.simpleMethod("one", 234));
assertEquals(null, mock.simpleMethod("xxx", 234));
public void shouldStubWithThrowable() throws Exception {
public void shouldAllowSettingValidCheckedException() throws Exception {
public void shouldDetectInvalidCheckedException() throws Exception {
public void shouldScreamWhenReturnSetForVoid() throws Exception {
public void shouldScreamWhenNotAMockPassed() throws Exception {
public void shouldScreamWhenNullPassed() throws Exception {
public void shouldAllowChainedStubbing() {
doReturn("foo").
doThrow(new RuntimeException()).
doReturn("bar")
.when(mock).simpleMethod();
assertEquals("foo", mock.simpleMethod());
assertEquals("bar", mock.simpleMethod());
assertEquals("bar", mock.simpleMethod());
public void shouldAllowDoCallRealMethodInChainedStubbing() throws Exception {
assertEquals("A", methods.simpleMethod());
assertEquals(null, methods.simpleMethod());
public void shouldAllowChainedStubbingWithExceptionClass() throws Exception {
assertEquals("whatever", mock.simpleMethod());
public void shouldAllowChainedStubbingOnVoidMethods() {
doNothing().
doNothing().
doThrow(new RuntimeException())
.when(mock).voidMethod();
public void shouldStubWithGenericAnswer() {
assertEquals("foo", mock.simpleMethod());
public void shouldNotAllowDoNothingOnNonVoids() {
public void shouldStubbingBeTreatedAsInteraction() throws Exception {
public void shouldVerifyStubbedCall() throws Exception {
public void shouldAllowStubbingToString() throws Exception {
assertEquals("test", mock.toString());
public void shouldDetectInvalidReturnType() throws Exception {
public void shouldDetectWhenNullAssignedToBoolean() throws Exception {
public void shouldAllowStubbingWhenTypesMatchSignature() throws Exception {
doReturn(new Integer(2)).when(mock).intReturningMethod();
import org.mockito.Mockito;
when(mock.add(null)).thenThrow(IllegalArgumentException.class);
Mockito.doThrow(IllegalArgumentException.class).when(mock).add(null);import net.bytebuddy.ClassFileVersion;
.defineField("serialVersionUID", long.class, STATIC, PRIVATE, FINAL).value(42L);public StackTraceElement[] getStackTrace() {
filterStackTrace();
return super.getStackTrace();import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("K");
assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("N");
assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");
assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");
assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("E");
assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("T");
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.*;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Fail.fail;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Condition;
.satisfies(thatCceIsThrownFrom("java.lang.Class.cast"))
.satisfies(thatCceIsThrownFrom("org.mockito.internal.creation.cglib.ClassImposterizer.imposterise"));
private Condition<Throwable> thatCceIsThrownFrom(final String stacktraceElementDescription) {
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import org.fest.assertions.Assertions;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;
import static org.fest.assertions.Assertions.assertThat;public void shouldSetInternalStateOnHierarchy() {
Object internalState = org.powermock.reflect.Whitebox.getInternalState(dummy, "somePrivateField");
public void shouldGetInternalStateFromHierarchy() {
DummyClassForTests dummy = new DummyClassForTests();
org.powermock.reflect.Whitebox.setInternalState(dummy, "somePrivateField", "boo!");
Object internalState = Whitebox.getInternalState(dummy, "somePrivateField");
assertEquals("boo!", internalState);package org.mockito.internal.creation.cglib;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoSerializationIssue;
import org.mockito.internal.creation.instance.InstantiatorProvider;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.reflection.FieldSetter;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.MockName;
import org.mockito.mock.SerializableMode;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import static org.mockito.internal.util.StringJoiner.join;
class AcrossJVMSerializationFeature implements Serializable {
private static final long serialVersionUID = 7411152578314420778L;
private static final String MOCKITO_PROXY_MARKER = "MockitoProxyMarker";
private boolean instanceLocalCurrentlySerializingFlag = false;
private final Lock mutex = new ReentrantLock();
public boolean isWriteReplace(Method method) {
return method.getReturnType() == Object.class
&& method.getParameterTypes().length == 0
&& method.getName().equals("writeReplace");
public Object writeReplace(Object mockitoMock) throws ObjectStreamException {
try {
mutex.lock();
if (mockIsCurrentlyBeingReplaced()) {
return mockitoMock;
mockReplacementStarted();
return new AcrossJVMMockSerializationProxy(mockitoMock);
MockUtil mockUtil = new MockUtil();
MockName mockName = mockUtil.getMockName(mockitoMock);
String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();
throw new MockitoSerializationIssue(join(
"The mock '" + mockName + "' of type '" + mockedType + "'",
"The Java Standard Serialization reported an '" + ioe.getClass().getSimpleName() + "' saying :",
"  " + ioe.getMessage()
), ioe);
mockReplacementCompleted();
mutex.unlock();
private void mockReplacementCompleted() {
instanceLocalCurrentlySerializingFlag = false;
private void mockReplacementStarted() {
instanceLocalCurrentlySerializingFlag = true;
private boolean mockIsCurrentlyBeingReplaced() {
return instanceLocalCurrentlySerializingFlag;
public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {
if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);
public static class AcrossJVMMockSerializationProxy implements Serializable {
private static final long serialVersionUID = -7600267929109286514L;
private final byte[] serializedMock;
private final Class typeToMock;
private final Set<Class> extraInterfaces;
public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {
ByteArrayOutputStream out = new ByteArrayOutputStream();
ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);
objectOutputStream.writeObject(mockitoMock);
objectOutputStream.close();
out.close();
MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);
this.serializedMock = out.toByteArray();
this.typeToMock = mockSettings.getTypeToMock();
this.extraInterfaces = mockSettings.getExtraInterfaces();
private Object readResolve() throws ObjectStreamException {
try {
ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);
ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);
Object deserializedMock = objectInputStream.readObject();
bis.close();
objectInputStream.close();
return deserializedMock;
throw new MockitoSerializationIssue(join(
"Mockito mock cannot be deserialized to a mock of '" + typeToMock.getCanonicalName() + "'. The error was :",
"  " + ioe.getMessage(),
"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list."
), ioe);
throw new MockitoSerializationIssue(join(
"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :",
"  " + cce.getMessage(),
"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list."
), cce);
public static class MockitoMockObjectInputStream extends ObjectInputStream {
private final Class typeToMock;
private final Set<Class> extraInterfaces;
public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {
super(in);
this.typeToMock = typeToMock;
this.extraInterfaces = extraInterfaces;
enableResolveObject(true); // ensure resolving is enabled
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (notMarkedAsAMockitoMock(readObject())) {
return super.resolveClass(desc);
ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));
imposterizer.setConstructorsAccessible(typeToMock, true);
Class<?> proxyClass = imposterizer.createProxyClass(
typeToMock,
extraInterfaces.toArray(new Class[extraInterfaces.size()])
);
hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
return proxyClass;
private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {
try {
Field classNameField = descInstance.getClass().getDeclaredField("name");
new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());
throw new MockitoSerializationIssue(join(
"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
"this is definitely a bug in our code as it means the JDK team changed a few internal things.",
"",
"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."
), nsfe);
private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {
return !MOCKITO_PROXY_MARKER.equals(marker);
private static class MockitoMockObjectOutputStream extends ObjectOutputStream {
private static final String NOTHING = "";
public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {
super(out);
protected void annotateClass(Class<?> cl) throws IOException {
writeObject(mockitoProxyClassMarker(cl));
private String mockitoProxyClassMarker(Class<?> cl) {
if (AcrossJVMMockitoMockSerializable.class.isAssignableFrom(cl)) {
return MOCKITO_PROXY_MARKER;
return NOTHING;
public interface AcrossJVMMockitoMockSerializable {
public Object writeReplace() throws java.io.ObjectStreamException;
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.MethodProxy;
import java.io.Serializable;
import java.lang.reflect.Field;
class CGLIBHacker {
public void setMockitoNamingPolicy(MethodProxy methodProxy) {
try {
Field createInfoField = reflectOnCreateInfo(methodProxy);
createInfoField.setAccessible(true);
Object createInfo = createInfoField.get(methodProxy);
Field namingPolicyField = createInfo.getClass().getDeclaredField("namingPolicy");
namingPolicyField.setAccessible(true);
if (namingPolicyField.get(createInfo) == null) {
namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);
throw new RuntimeException(
"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses", e);
private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {
Class cglibMethodProxyClass = methodProxy.getClass();
while (cglibMethodProxyClass != MethodProxy.class) {
cglibMethodProxyClass = methodProxy.getClass().getSuperclass();
return cglibMethodProxyClass.getDeclaredField("createInfo");
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.Callback;
import org.mockito.cglib.proxy.Factory;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.instance.InstantiatorProvider;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import java.lang.reflect.Modifier;
public class CglibMockMaker implements MockMaker {
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
InternalMockHandler mockitoHandler = cast(handler);
new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);
return new ClassImposterizer(new InstantiatorProvider().getInstantiator(settings)).imposterise(
new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());
private InternalMockHandler cast(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException("At the moment you cannot provide own implementations of MockHandler." +
"\nPlease see the javadocs for the MockMaker interface.");
return (InternalMockHandler) handler;
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));
public MockHandler getHandler(Object mock) {
if (!(mock instanceof Factory)) {
return null;
Factory factory = (Factory) mock;
Callback callback = factory.getCallback(0);
if (!(callback instanceof MethodInterceptorFilter)) {
return null;
return ((MethodInterceptorFilter) callback).getHandler();
public TypeMockability isTypeMockable(final Class<?> type) {
return new TypeMockability() {
public boolean mockable() {
return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
public String nonMockableReason() {
if(type.isPrimitive()) {
return "primitive type";
if(Modifier.isFinal(type.getModifiers())) {
return "final or anonymous class";
return join("not handled type");
package org.mockito.internal.creation.cglib;
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.List;
import org.mockito.cglib.core.CodeGenerationException;
import org.mockito.cglib.core.NamingPolicy;
import org.mockito.cglib.core.Predicate;
import org.mockito.cglib.proxy.Callback;
import org.mockito.cglib.proxy.CallbackFilter;
import org.mockito.cglib.proxy.Enhancer;
import org.mockito.cglib.proxy.Factory;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.NoOp;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.creation.instance.InstantiationException;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.creation.util.SearchingClassLoader;
class ClassImposterizer {
private final Instantiator instantiator;
public ClassImposterizer(Instantiator instantiator) {
this.instantiator = instantiator;
private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {
public String getClassName(String prefix, String source, Object key, Predicate names) {
return "codegen." + super.getClassName(prefix, source, key, names);
private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {
public int accept(Method method) {
return method.isBridge() ? 1 : 0;
public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {
return (T) imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));
public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {
Class<Factory> proxyClass = null;
Object proxyInstance = null;
try {
setConstructorsAccessible(mockedType, true);
proxyClass = createProxyClass(mockedType, ancillaryTypes);
proxyInstance = createProxy(proxyClass, interceptor);
return mockedType.cast(proxyInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito proxy :",
"  class to mock : " + describeClass(mockedType),
"  created class : " + describeClass(proxyClass),
"  proxy instance class : " + describeClass(proxyInstance),
"  instance creation by : " + instantiator.getClass().getSimpleName(),
"",
"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)"
), cce);
setConstructorsAccessible(mockedType, false);
private static String describeClass(Class type) {
return type == null? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private static String describeClass(Object instance) {
return instance == null? "null" : describeClass(instance.getClass());
public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {
for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {
constructor.setAccessible(accessible);
public Class<Factory> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {
if (mockedType == Object.class) {
mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;
Enhancer enhancer = new Enhancer() {
protected void filterConstructors(Class sc, List constructors) {
Class<?>[] allMockedTypes = prepend(mockedType, interfaces);
enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));
enhancer.setUseFactory(true);
if (mockedType.isInterface()) {
enhancer.setSuperclass(Object.class);
enhancer.setInterfaces(allMockedTypes);
enhancer.setSuperclass(mockedType);
enhancer.setInterfaces(interfaces);
enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});
enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);
if (mockedType.getSigners() != null) {
enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);
enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);
enhancer.setSerialVersionUID(42L);
try {
return enhancer.createClass();
if (Modifier.isPrivate(mockedType.getModifiers())) {
throw new MockitoException("\n"
+ "Mockito cannot mock this class: " + mockedType
+ ".\n"
+ "Most likely it is a private class that is not visible by Mockito");
throw new MockitoException("\n"
+ "Mockito cannot mock this class: " + mockedType
+ "\n"
+ "Mockito can only mock visible & non-final classes."
+ "\n"
+ "If you're not sure why you're getting this error, please report to the mailing list.", e);
private Object createProxy(Class<Factory> proxyClass, final MethodInterceptor interceptor) {
Factory proxy;
try {
proxy = instantiator.newInstance(proxyClass);
throw new MockitoException("Unable to create mock instance of type '" + proxyClass.getSuperclass().getSimpleName() + "'", e);
proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });
return proxy;
private Class<?>[] prepend(Class<?> first, Class<?>... rest) {
Class<?>[] all = new Class<?>[rest.length+1];
all[0] = first;
System.arraycopy(rest, 0, all, 1, rest.length);
return all;
public static class ClassWithSuperclassToWorkAroundCglibBug {}
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.creation.util.MockitoMethodProxy;
class DelegatingMockitoMethodProxy implements MockitoMethodProxy {
private final MethodProxy methodProxy;
public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {
this.methodProxy = methodProxy;
public Object invokeSuper(Object target, Object[] arguments) throws Throwable {
return methodProxy.invokeSuper(target, arguments);
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.DelegatingMethod;
import org.mockito.internal.creation.util.MockitoMethodProxy;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;
import org.mockito.internal.progress.SequenceNumber;
import org.mockito.internal.util.ObjectMethodsGuru;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import java.io.Serializable;
import java.lang.reflect.Method;
class MethodInterceptorFilter implements MethodInterceptor, Serializable {
private static final long serialVersionUID = 6182795666612683784L;
private final InternalMockHandler handler;
final ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();
private final MockCreationSettings mockSettings;
private final AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();
public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {
this.handler = handler;
this.mockSettings = mockSettings;
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)
throws Throwable {
if (objectMethodsGuru.isEqualsMethod(method)) {
return proxy == args[0];
return hashCodeForMock(proxy);
return acrossJVMSerializationFeature.writeReplace(proxy);
MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);
new CGLIBHacker().setMockitoNamingPolicy(methodProxy);
MockitoMethod mockitoMethod = createMockitoMethod(method);
CleanTraceRealMethod realMethod = new CleanTraceRealMethod(mockitoMethodProxy);
Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);
return handler.handle(invocation);
public MockHandler getHandler() {
return handler;
private int hashCodeForMock(Object mock) {
return System.identityHashCode(mock);
public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {
if (mockSettings.isSerializable())
return new SerializableMockitoMethodProxy(methodProxy);
return new DelegatingMockitoMethodProxy(methodProxy);
public MockitoMethod createMockitoMethod(Method method) {
if (mockSettings.isSerializable()) {
return new SerializableMethod(method);
return new DelegatingMethod(method);
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.core.DefaultNamingPolicy;
class MockitoNamingPolicy extends DefaultNamingPolicy {
public static final MockitoNamingPolicy INSTANCE = new MockitoNamingPolicy(); 
protected String getTag() {
return "ByMockitoWithCGLIB";
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.creation.util.MockitoMethodProxy;
import org.mockito.internal.util.reflection.Whitebox;
import java.io.Serializable;
class SerializableMockitoMethodProxy implements MockitoMethodProxy, Serializable {
private static final long serialVersionUID = -5337859962876770632L;
private final Class<?> c1;
private final Class<?> c2;
private final String desc;
private final String name;
private final String superName;
transient MethodProxy methodProxy;
public SerializableMockitoMethodProxy(MethodProxy methodProxy) {
assert methodProxy != null;
Object info = Whitebox.getInternalState(methodProxy, "createInfo");
c1 = (Class<?>) Whitebox.getInternalState(info, "c1");
c2 = (Class<?>) Whitebox.getInternalState(info, "c2");
desc = methodProxy.getSignature().getDescriptor();
name = methodProxy.getSignature().getName();
superName = methodProxy.getSuperName();
this.methodProxy = methodProxy;
private MethodProxy getMethodProxy() {
if (methodProxy == null) {
methodProxy = MethodProxy.create(c1, c2, desc, name, superName);
return methodProxy;
public Object invokeSuper(Object target, Object[] arguments) throws Throwable {
return getMethodProxy().invokeSuper(target, arguments);
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.Callback;
import org.mockito.cglib.proxy.NoOp;
import java.io.Serializable;
class SerializableNoOp implements NoOp, Serializable {
private static final long serialVersionUID = 7434976328690189159L;
public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();
package org.mockito.cglibintegration;
import org.mockito.Mockito;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.util.Observable;
public class DeserializeMockFromFile {
public static void main(String[] args) {
Observable o = (Observable) deSerializeObject("mockito_mock.ser");
Mockito.verify(o).addObserver(null);
Mockito.verify(o).countObservers();
private static Object deSerializeObject(String filename) {
InputStream is = null;
ObjectInputStream ois = null;
Object returnObject = null;
try {
is = new BufferedInputStream(new FileInputStream(filename));
ois = new ObjectInputStream(is);
returnObject = ois.readObject();
e.printStackTrace();
try {
if (is != null)
is.close();
e.printStackTrace();
try {
if (ois != null)
ois.close();
e.printStackTrace();
return returnObject;
package org.mockito.cglibintegration;
import static org.junit.Assert.fail;
import java.util.ArrayList;
import org.junit.Test;
import org.mockito.cglib.proxy.Enhancer;
import org.mockito.cglib.proxy.NoOp;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.internal.util.MockUtil;
public class MockUtilTest {
private MockUtil mockUtil = new MockUtil();
public void should_scream_when_enhanced_but_not_a_mock_passed() {
Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);
try {
mockUtil.getMockHandler(o);
fail();
package org.mockito.cglibintegration;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.Observable;
import org.mockito.Mockito;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
public class SerializeMockToFile {
public static void main(String[] args) {
Observable observable = Mockito.mock(
Observable.class,
Mockito.withSettings().serializable()
);
observable.addObserver(null);
observable.countObservers();
serializeMock(observable, "mockito_mock.ser");
private static void serializeMock(Object obj, String filename) {
OutputStream os = null;
ObjectOutputStream oos = null;
try {
os = new BufferedOutputStream(new FileOutputStream(filename, false));
oos = new ObjectOutputStream(os);
oos.writeObject(obj);
e.printStackTrace();
try {
if (os != null) os.close();
e.printStackTrace();
try {
if (oos != null) oos.close();
e.printStackTrace();
private static class DefaultMethodInterceptor implements MethodInterceptor, Serializable {
private static final long serialVersionUID = 6606245777399406255L;
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
return methodProxy.invokeSuper(o, objects);
package org.mockito.cglibintegration;
import java.util.LinkedList;
import java.util.List;
import org.concurrentmockito.VerificationInOrderFromMultipleThreadsTest;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;
import org.mockito.MockitoTest;
import org.mockito.exceptions.ReporterTest;
import org.mockito.exceptions.base.MockitoAssertionErrorTest;
import org.mockito.exceptions.base.MockitoExceptionTest;
import org.mockito.internal.AllInvocationsFinderTest;
import org.mockito.internal.InvalidStateDetectionTest;
import org.mockito.internal.creation.cglib.ClassImposterizerTest;
import org.mockito.internal.handler.MockHandlerImplTest;
import org.mockito.internal.invocation.InvocationImplTest;
import org.mockito.internal.invocation.InvocationMatcherTest;
import org.mockito.internal.invocation.InvocationsFinderTest;
import org.mockito.internal.matchers.ComparableMatchersTest;
import org.mockito.internal.matchers.EqualsTest;
import org.mockito.internal.matchers.MatchersToStringTest;
import org.mockito.internal.progress.MockingProgressImplTest;
import org.mockito.internal.progress.TimesTest;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;
import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest;
import org.mockito.internal.util.MockUtilTest;
import org.mockito.internal.util.collections.ListUtilTest;
import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;
import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;
import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;
import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;
import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;
import org.mockitousage.basicapi.ReplacingObjectMethodsTest;
import org.mockitousage.basicapi.ResetTest;
import org.mockitousage.basicapi.UsingVarargsTest;
import org.mockitousage.examples.use.ExampleTest;
import org.mockitousage.matchers.CustomMatchersTest;
import org.mockitousage.matchers.InvalidUseOfMatchersTest;
import org.mockitousage.matchers.MatchersTest;
import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;
import org.mockitousage.misuse.InvalidUsageTest;
import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;
import org.mockitousage.puzzlers.OverloadingPuzzleTest;
import org.mockitousage.stacktrace.ClickableStackTracesTest;
import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;
import org.mockitousage.stacktrace.StackTraceFilteringTest;
import org.mockitousage.stubbing.BasicStubbingTest;
import org.mockitousage.stubbing.ReturningDefaultValuesTest;
import org.mockitousage.stubbing.StubbingWithThrowablesTest;
import org.mockitousage.verification.AtMostXVerificationTest;
import org.mockitousage.verification.BasicVerificationInOrderTest;
import org.mockitousage.verification.BasicVerificationTest;
import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;
import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;
import org.mockitousage.verification.NoMoreInteractionsVerificationTest;
import org.mockitousage.verification.RelaxedVerificationInOrderTest;
import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;
import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;
import org.mockitousage.verification.VerificationInOrderTest;
import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;
import org.mockitousage.verification.VerificationUsingMatchersTest;
import org.mockitoutil.TestBase;
public class ThreadsRunAllTestsHalfManualTest extends TestBase {
private static class AllTestsRunner extends Thread {
private boolean failed;
public void run() {
Result result = JUnitCore.runClasses(
EqualsTest.class,
ListUtilTest.class,
MockingProgressImplTest.class,
TimesTest.class,
MockHandlerImplTest.class,
AllInvocationsFinderTest.class,
ReturnsEmptyValuesTest.class,
NumberOfInvocationsCheckerTest.class,
DefaultRegisteredInvocationsTest.class,
MissingInvocationCheckerTest.class,
NumberOfInvocationsInOrderCheckerTest.class,
MissingInvocationInOrderCheckerTest.class,
ClassImposterizerTest.class,
InvocationMatcherTest.class,
InvocationsFinderTest.class,
InvocationImplTest.class,
MockitoTest.class,
MockUtilTest.class,
ReporterTest.class,
MockitoAssertionErrorTest.class,
MockitoExceptionTest.class,
StackTraceFilteringTest.class,
BridgeMethodPuzzleTest.class,
OverloadingPuzzleTest.class,
InvalidUsageTest.class,
UsingVarargsTest.class,
CustomMatchersTest.class,
ComparableMatchersTest.class,
InvalidUseOfMatchersTest.class,
MatchersTest.class,
MatchersToStringTest.class,
VerificationAndStubbingUsingMatchersTest.class,
BasicStubbingTest.class,
ReturningDefaultValuesTest.class,
StubbingWithThrowablesTest.class,
AtMostXVerificationTest.class,
BasicVerificationTest.class,
ExactNumberOfTimesVerificationTest.class,
VerificationInOrderTest.class,
NoMoreInteractionsVerificationTest.class,
SelectedMocksInOrderVerificationTest.class,
VerificationOnMultipleMocksUsingMatchersTest.class,
VerificationUsingMatchersTest.class,
RelaxedVerificationInOrderTest.class,
DescriptiveMessagesWhenVerificationFailsTest.class,
DescriptiveMessagesWhenTimesXVerificationFailsTest.class,
BasicVerificationInOrderTest.class,
VerificationInOrderMixedWithOrdiraryVerificationTest.class,
DescriptiveMessagesOnVerificationInOrderErrorsTest.class,
InvalidStateDetectionTest.class,
ReplacingObjectMethodsTest.class,
ClickableStackTracesTest.class,
ExampleTest.class,
PointingStackTraceToActualInvocationTest.class,
VerificationInOrderFromMultipleThreadsTest.class,
ResetTest.class,
ReturnsGenericDeepStubsTest.class
);
if (!result.wasSuccessful()) {
System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");
List<Failure> failures = result.getFailures();
System.err.println(failures.size());
for (Failure failure : failures) {
System.err.println(failure.getTrace());
failed = true;
public boolean isFailed() {
return failed;
public void shouldRunInMultipleThreads() throws Exception {
assertFalse("Run in multiple thread failed", runInMultipleThreads(3));
public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {
List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();
for (int i = 1; i <= numberOfThreads; i++) {
threads.add(new AllTestsRunner());
for (Thread t : threads) {
t.start();
boolean failed = false;
for (AllTestsRunner t : threads) {
t.join();
failed = failed ? true : t.isFailed();
return failed;
public static void main(String[] args) throws Exception {
int numberOfThreads = 20;
long before = System.currentTimeMillis();
runInMultipleThreads(numberOfThreads);
long after = System.currentTimeMillis();
long executionTime = (after-before)/1000;
System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds.");
package org.mockito.internal.creation.cglib;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.cglib.core.NamingPolicy;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockitoutil.TestBase;
import org.powermock.reflect.Whitebox;
import static org.mockito.Mockito.spy;
public class CGLIBHackerTest extends TestBase {
public void shouldSetMockitoNamingPolicy() throws Exception {
MethodProxy methodProxy = MethodProxy.create(String.class, Integer.class, "", "", "");
new CGLIBHacker().setMockitoNamingPolicy(methodProxy);
Object createInfo = Whitebox.getInternalState(methodProxy, "createInfo");
NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {
MethodProxy proxiedMethodProxy = spy(MethodProxy.create(String.class, Integer.class, "", "", ""));
new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);
Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, "createInfo");
NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
package org.mockito.internal.creation.cglib;
import org.junit.Test;
import org.mockito.cglib.proxy.Factory;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.creation.instance.ConstructorInstantiator;
import org.mockito.internal.creation.instance.InstantiatorProvider;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockitoutil.TestBase;
import java.lang.reflect.Method;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
public class ClassImposterizerTest extends TestBase {
ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));
public void shouldCreateMockFromInterface() throws Exception {
SomeInterface proxy = imposterizer.imposterise(new MethodInterceptorStub(), SomeInterface.class);
Class superClass = proxy.getClass().getSuperclass();
assertEquals(Object.class, superClass);
public void shouldCreateMockFromClass() throws Exception {
ClassWithoutConstructor proxy = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);
Class superClass = proxy.getClass().getSuperclass();
assertEquals(ClassWithoutConstructor.class, superClass);
public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);
assertNotNull(mock);
public void shouldMocksHaveDifferentInterceptors() throws Exception {
SomeClass mockOne = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);
SomeClass mockTwo = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);
Factory cglibFactoryOne = (Factory) mockOne;
Factory cglibFactoryTwo = (Factory) mockTwo;
assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));
public void shouldUseAnicilliaryTypes() {
SomeClass mock = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);
assertThat(mock, is(instanceOf(SomeInterface.class)));
public void shouldCreateClassByConstructor() {
imposterizer = new ClassImposterizer(new ConstructorInstantiator(null));
OtherClass mock = imposterizer.imposterise(new MethodInterceptorStub(), OtherClass.class);
assertNotNull(mock);
class SomeClass {}
interface SomeInterface {}
static class OtherClass {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
private final class MethodInterceptorStub implements MethodInterceptor {
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
return null;
package org.mockito.internal.creation.cglib;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.DelegatingMethod;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.creation.util.MockitoMethodProxy;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockitousage.MethodsImpl;
import org.mockitoutil.TestBase;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import static org.hamcrest.core.IsInstanceOf.instanceOf;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.withSettings;
public class MethodInterceptorFilterTest extends TestBase {
InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
public void shouldBeSerializable() throws Exception {
new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));
public void shouldProvideOwnImplementationOfHashCode() throws Throwable {
Object ret = filter.intercept(new MethodsImpl(), MethodsImpl.class.getMethod("hashCode"), new Object[0], null);
assertTrue((Integer) ret != 0);
Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
public void shouldProvideOwnImplementationOfEquals() throws Throwable {
MethodsImpl proxy = new MethodsImpl();
Object ret = filter.intercept(proxy, MethodsImpl.class.getMethod("equals", Object.class), new Object[] {proxy}, null);
assertTrue((Boolean) ret);
Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));
public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));
public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
Method method = new InvocationBuilder().toInvocation().getMethod();
MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
assertThat(mockitoMethod, instanceOf(SerializableMethod.class));
public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
Method method = new InvocationBuilder().toInvocation().getMethod();
MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
assertThat(mockitoMethod, instanceOf(DelegatingMethod.class));
package org.mockito.internal.creation.cglib;
import org.junit.Test;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockitoutil.TestBase;
import org.powermock.reflect.Whitebox;
public class SerializableMockitoMethodProxyTest extends TestBase {
public void shouldCreateCorrectCreationInfo() throws Exception {
MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "", "", "");
SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
serializableMockitoMethodProxy.methodProxy = null;
Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
Object info = Whitebox.getInternalState(methodProxy, "createInfo");
assertEquals(String.class, Whitebox.getInternalState(info, "c1"));
assertEquals(Integer.class, Whitebox.getInternalState(info, "c2"));
public void shouldCreateCorrectSignatures() throws Exception {
MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "a", "b", "c");
SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
serializableMockitoMethodProxy.methodProxy = null;
MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
assertEquals("a", methodProxy.getSignature().getDescriptor());
assertEquals("b", methodProxy.getSignature().getName());
assertEquals("c", methodProxy.getSuperName());
public String toString() {
return "SerializableMockitoMethodProxyTest []";import org.mockito.internal.matchers.MatcherDecorator;
MockitoMatcher actualMatcher;
if (m instanceof MatcherDecorator) {
actualMatcher = ((MatcherDecorator)m).getActualMatcher();
actualMatcher = m;
if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {
import org.mockito.internal.matchers.MatcherDecorator;
if (matcher instanceof MatcherDecorator) {
set.add(((MatcherDecorator) matcher).getActualMatcher());
set.add(matcher);
InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<MockitoMatcher>)(List) lastMatchers);
return invocationWithMatchers;
public class LocalizedMatcher implements MockitoMatcher, ContainsExtraTypeInfo, CapturesArguments, MatcherDecorator, Serializable {
private final MockitoMatcher actualMatcher;
public LocalizedMatcher(MockitoMatcher actualMatcher) {
this.actualMatcher = actualMatcher;
public boolean matches(Object item) {
return actualMatcher.matches(item);
public String toString() {
return actualMatcher.toString();
public String toStringWithType() {
if (actualMatcher instanceof ContainsExtraTypeInfo) {
return ((ContainsExtraTypeInfo) actualMatcher).toStringWithType();
return actualMatcher.toString();
public boolean typeMatches(Object target) {
return actualMatcher instanceof ContainsExtraTypeInfo
&& ((ContainsExtraTypeInfo) actualMatcher).typeMatches(target);
public void captureFrom(Object argument) {
if (actualMatcher instanceof CapturesArguments) {
((CapturesArguments) actualMatcher).captureFrom(argument);
public MockitoMatcher getActualMatcher() {
return actualMatcher;
package org.mockito.internal.matchers;
import org.mockito.MockitoMatcher;
import java.io.Serializable;
public interface MatcherDecorator extends Serializable {
MockitoMatcher getActualMatcher();
List<MockitoMatcher> result = new LinkedList<MockitoMatcher>();
result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));
matcherStack.pop();
InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));
InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));
InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));
package org.mockito.internal.matchers;
import org.junit.Test;
import org.mockito.MockitoMatcher;
import org.mockitoutil.TestBase;
public class LocalizedMatcherTest extends TestBase {
public void shouldMatchTypesWhenActualMatcherHasCorrectType() throws Exception {
ContainsExtraTypeInfo equals10 = new Equals(10);
LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) equals10);
assertTrue(m.typeMatches(10));
assertFalse(m.typeMatches(10L));
public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType() throws Exception {
LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
assertFalse(m.typeMatches(10));
public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType() throws Exception {
ContainsExtraTypeInfo equals10 = new Equals(10);
LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) equals10);
assertEquals("(Integer) 10", m.toStringWithType());
public void shouldDescribeStringWithType() throws Exception {
ContainsExtraTypeInfo e = new Equals("x");
LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) e);
assertEquals("(String) \"x\"", m.toStringWithType());
public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType() throws Exception {
LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
assertEquals(m.toString(), m.toStringWithType());
public void shouldDelegateToCapturingMatcher() throws Exception {
CapturingMatcher capturingMatcher = new CapturingMatcher();
LocalizedMatcher m = new LocalizedMatcher(capturingMatcher);
m.captureFrom("boo");
assertEquals("boo", capturingMatcher.getLastValue());import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import java.util.List;
import net.bytebuddy.ByteBuddy;
import java.util.Set;
import net.bytebuddy.ByteBuddy;import org.hamcrest.SelfDescribing;
public interface ContainsExtraTypeInformation extends Serializable {
SelfDescribing withExtraTypeInfo();
import org.hamcrest.SelfDescribing;
public class Equals extends ArgumentMatcher<Object> implements ContainsExtraTypeInformation, Serializable {
public SelfDescribing withExtraTypeInfo() {
return new SelfDescribing() {
public void describeTo(Description description) {
description.appendText(describe("("+ wanted.getClass().getSimpleName() +") " + wanted));
import org.hamcrest.SelfDescribing;
public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {
public SelfDescribing withExtraTypeInfo() {
if (actualMatcher instanceof ContainsExtraTypeInformation) {
return ((ContainsExtraTypeInformation) actualMatcher).withExtraTypeInfo();
return this;
return actualMatcher instanceof ContainsExtraTypeInformation
&& ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);
import java.util.LinkedList;
import java.util.List;
import org.hamcrest.StringDescription;
public String print(SelfDescribing matcher) {
return StringDescription.toString(matcher);
Description result = new StringDescription();
result.appendList("(", ", ", ");", applyPrintSettings(matchers, printSettings));
return result.toString();
Description result = new StringDescription();
result.appendList("(\n    ", ",\n    ", "\n);", applyPrintSettings(matchers, printSettings));
return result.toString();
private List<SelfDescribing> applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {
List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();
if (matcher instanceof ContainsExtraTypeInformation && printSettings.extraTypeInfoFor(i)) {
withPrintSettings.add(((ContainsExtraTypeInformation) matcher).withExtraTypeInfo());
withPrintSettings.add(matcher);
return withPrintSettings;
import org.mockito.internal.matchers.ContainsExtraTypeInformation;
import org.mockito.internal.matchers.MatchersPrinter;
if (m instanceof ContainsExtraTypeInformation 
&& !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {
return new MatchersPrinter().print(m).equals(arg == null? "null" : arg.toString());
String descStr = describe(new Equals(100).withExtraTypeInfo());
String descStr = describe(new Equals(100L).withExtraTypeInfo());
ContainsExtraTypeInformation equals = new Equals(10);
ContainsExtraTypeInformation equals = new Equals(null);
ContainsExtraTypeInformation equals = new Equals(10);
ContainsExtraTypeInformation equals10 = new Equals(10);
ContainsExtraTypeInformation equals10 = new Equals(10);
assertEquals("(Integer) 10", describe(m.withExtraTypeInfo()));
ContainsExtraTypeInformation e = new Equals("x");
assertEquals("\"(String) x\"", describe(m.withExtraTypeInfo()));
assertSame(m, m.withExtraTypeInfo());
assertEquals("(1, \"(String) x\");", line); //TODO SF this is awkward, it should be: (String) "x"
return new MatchersPrinter().print(m);import static org.mockito.internal.util.StringJoiner.join;
MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
if (!(mock instanceof MockMethodInterceptor.MockAccess)) {
return ((MockMethodInterceptor.MockAccess) mock).getMockitoInterceptor().getMockHandler();
((MockMethodInterceptor.MockAccess) mock).setMockitoInterceptor(
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldGetter;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldSetter;
import static net.bytebuddy.matcher.ElementMatchers.*;
private final Implementation delegation;
delegation = MethodDelegation.to(InterceptionDispatcher.class)
.appendParameterBinder(FieldProxy.Binder.install(FieldGetter.class,
FieldSetter.class));
.method(any()).intercept(delegation)
public static class InterceptionDispatcher {
return null;
public void should_be_able_to_create_spy() throws Exception {
MockitoAnnotations.initMocks(this);
private static class HasConstructorInvokingMethod {
public HasConstructorInvokingMethod() {
someMethod();
void someMethod() { }import static net.bytebuddy.implementation.FieldAccessor.ofBeanProperty;
import static net.bytebuddy.implementation.MethodDelegation.toInstanceField;
.method(any()).intercept(toInstanceField(MockMethodInterceptor.class, "mockitoInterceptor")
.filter(isDeclaredBy(MockMethodInterceptor.class)))
.implement(MockMethodInterceptor.MockAccess.class).intercept(ofBeanProperty())
int index = 1;
for (Class<?> type : features.interfaces) {
allMockedTypes[index++] = type;
return builder.make()
.load(SearchingClassLoader.combineLoadersOf(allMockedTypes), ClassLoadingStrategy.Default.INJECTION)
.getLoaded();
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import net.bytebuddy.implementation.bind.annotation.AllArguments;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.BindingPriority;
import net.bytebuddy.implementation.bind.annotation.DefaultCall;
import net.bytebuddy.implementation.bind.annotation.Origin;
import net.bytebuddy.implementation.bind.annotation.RuntimeType;
import net.bytebuddy.implementation.bind.annotation.SuperCall;
import net.bytebuddy.implementation.bind.annotation.This;
public static interface MockAccess {import java.util.Random;
import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
import org.mockito.internal.creation.util.SearchingClassLoader;
import net.bytebuddy.description.modifier.FieldManifestation;
import net.bytebuddy.description.modifier.Ownership;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.matcher.ElementMatchers;
DynamicType.Builder<T> builder = byteBuddy.subclass(features.mockedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
.name(nameFor(features.mockedType))
.implement(features.interfaces.toArray(new Class<?>[features.interfaces.size()]))
.method(ElementMatchers.any()).intercept(MethodDelegation
.toInstanceField(MockMethodInterceptor.class, "mockitoInterceptor")
.filter(ElementMatchers.isDeclaredBy(MockMethodInterceptor.class)))
.implement(MockMethodInterceptor.MockAccess.class).intercept(FieldAccessor.ofBeanProperty())
.method(ElementMatchers.isHashCode()).intercept(MethodDelegation.to(MockMethodInterceptor.ForHashCode.class))
.method(ElementMatchers.isEquals()).intercept(MethodDelegation.to(MockMethodInterceptor.ForEquals.class))
.defineField("serialVersionUID", long.class, Ownership.STATIC, Visibility.PRIVATE, FieldManifestation.FINAL).value(42L);
if (features.crossClassLoaderSerializable) {
builder = builder.implement(CrossClassLoaderSerializableMock.class)
.intercept(MethodDelegation.to(MockMethodInterceptor.ForWriteReplace.class));
.load(SearchingClassLoader.combineLoadersOf(allMockedTypes), ClassLoadingStrategy.Default.INJECTION)
.getLoaded();public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
return getAnnotation(annotationClass) != null;
Bar loup = mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));
assertEquals(setOf(Observer.class, List.class), mockingDetails(loup).getExtraInterfaces());
String temp = file.getAbsolutePath().substring(root.getAbsolutePath().length() + 1).replace('/', '.');mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));
assertEquals(setOf(Observer.class, List.class), mockingDetails(bar).getExtraInterfaces());import java.util.Collection;
return delegate.isMock( toInspect );
return delegate.isSpy( toInspect );"Most likely it is a private class that is not visible by Mockito"
));
"If you're not sure why you're getting this error, please report to the mailing list."),
if (typeName.startsWith("java.") || (type.getPackage() != null && type.getPackage().isSealed())) {
public static interface Then<T> {
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.ObjectMethodsGuru;
import org.mockito.internal.util.Primitives;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.mock.MockName;
import org.mockito.stubbing.Answer;
import java.util.*;
import static org.mockito.Mockito.mock;
public void shouldStub() throws Exception {
public void shouldStubWithThrowable() throws Exception {
given(mock.simpleMethod("foo")).willThrow(new RuntimeException());
public void shouldStubWithThrowableClass() throws Exception {
given(mock.simpleMethod("foo")).willThrow(RuntimeException.class);
public void shouldStubWithAnswer() throws Exception {
public void shouldStubWithWillAnswerAlias() throws Exception {
public void shouldStubConsecutively() throws Exception {
given(mock.simpleMethod(anyString()))
.willReturn("foo")
.willReturn("bar");
assertEquals("foo", mock.simpleMethod("whatever"));
assertEquals("bar", mock.simpleMethod("whatever"));
public void shouldStubConsecutivelyWithCallRealMethod() throws Exception {
public void shouldStubVoid() throws Exception {
willThrow(new RuntimeException()).given(mock).voidMethod();
public void shouldStubVoidWithExceptionClass() throws Exception {
willThrow(RuntimeException.class).given(mock).voidMethod();
public void shouldStubVoidConsecutively() throws Exception {
.willThrow(new RuntimeException())
.given(mock).voidMethod();
public void shouldStubVoidConsecutivelyWithExceptionClass() throws Exception {
.willThrow(IllegalArgumentException.class)
.given(mock).voidMethod();
public void shouldStubUsingDoReturnStyle() throws Exception {
public void shouldStubUsingDoAnswerStyle() throws Exception {
.given(mock).simpleMethod(anyString());
class Dog {
public String bark() {
return "woof";
public void shouldStubByDelegatingToRealMethod() throws Exception {
public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax() throws Exception {
public void shouldAllStubbedMockReferenceAccess() throws Exception {
public void shouldValidateMockWhenVerifying() {
public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {
public void shouldValidateMockWhenVerifyingNoMoreInteractions() {
public void shouldFailForExpectedBehaviorThatDidNotHappen() {
public void shouldPassForExpectedBehaviorThatHappened() {
then(mock).should().booleanObjectReturningMethod();
public void shouldPassFluentBddScenario() {
static class Bike {public interface CapturesArgumensFromInvocation {
public void markVerified(List<Invocation> invocations, CapturesArgumensFromInvocation wanted) {
public void markVerified(Invocation invocation, CapturesArgumensFromInvocation wanted) {
invocation.markVerified();
wanted.captureArgumentsFrom(invocation);
public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {
public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {
int indexOfVararg = invocation.getRawArguments().length - 1;
for (int position = 0; position < indexOfVararg; position++) {
Matcher m = matchers.get(position);
if (m instanceof CapturesArguments) {
((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
if (m instanceof CapturesArguments) {
Object rawArgument = invocation.getRawArguments()[indexOfVararg];
for (int i = 0; i < Array.getLength(rawArgument); i++) {
((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
for (int position = 0; position < matchers.size(); position++) {
Matcher m = matchers.get(position);
if (m instanceof CapturesArguments) {
((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
CapturesArgumensFromInvocation c = new CapturesArgumensFromInvocation() {
Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)), any(CapturesArgumensFromInvocation.class));import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.matchers.VarargMatcher;
Class[] params1 = m1.getParameterTypes();
Class[] params2 = m2.getParameterTypes();
if (params1.length == params2.length) {
for (int i = 0; i < params1.length; i++) {
if (params1[i] != params2[i])
return false;
return true;
for (int position = indexOfVararg; position < matchers.size(); position++) {
Matcher m = matchers.get(position);
((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
private boolean isVarargMatcher(Matcher matcher) {
Matcher actualMatcher = matcher;
if (actualMatcher instanceof MatcherDecorator) {
actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();
return actualMatcher instanceof VarargMatcher;
private boolean isVariableArgument(Invocation invocation, int position) {
return invocation.getRawArguments().length - 1 == position
&& invocation.getRawArguments()[position] != null
&& invocation.getRawArguments()[position].getClass().isArray()
&& invocation.getMethod().isVarArgs();throw new UnsupportedOperationException();for (int position = 0; position < matchers.size(); position++) {
Matcher m = matchers.get(position);
if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {
if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {
Object array = invocation.getRawArguments()[position];
for (int i = 0; i < Array.getLength(array); i++) {
((CapturesArguments) m).captureFrom(Array.get(array, i));
return;
((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);import junit.framework.Assert;import org.mockito.Mock;
class Emailer {
public Emailer(EmailService service) {
Emailer emailer = new Emailer(emailService);
emailer.email(12);
ArgumentCaptor<Person> argument = new ArgumentCaptor<Person>();
emailer.email(11, 12);
ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
verify(emailService, atLeastOnce()).sendEmailTo(argument.capture());
List<Person> allValues = argument.getAllValues();
assertEquals(11, allValues.get(0).getAge());
assertEquals(12, allValues.get(1).getAge());
emailer.email(11, 12, 13);
ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
verify(emailService, atLeastOnce()).sendEmailTo(argument.capture());
ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);
ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
IMethods mock = mock(IMethods.class);
IMethods mock = mock(IMethods.class);
IMethods mock = mock(IMethods.class);
IMethods mock = mock(IMethods.class);
IMethods mock = mock(IMethods.class);
IMethods mock = mock(IMethods.class);
List<String> allVarargsValues = argumentCaptor.getAllValues();
Assertions.assertThat(allVarargsValues).containsExactly("a", "b", "c", "again ?!");
IMethods mock = mock(IMethods.class);
public void captures_correclty_when_captor_used_multiple_times() throws Exception {
IMethods mock = mock(IMethods.class);Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
import java.util.List;
public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
import java.util.List;
List<Field> fields, Object instance
private final MockCandidateFilter next;
private final MockUtil mockUtil = new MockUtil();
public NameBasedCandidateFilter(MockCandidateFilter next) {
this.next = next;
public OngoingInjecter filterCandidate(Collection<Object> mocks,
Field field, List<Field> fields, Object fieldInstance) {
List<Object> mockNameMatches = new ArrayList<Object>();
if (mocks.size() > 1) {
for (Object mock : mocks) {
if (field.getName().equals(mockUtil.getMockName(mock).toString())) {
mockNameMatches.add(mock);
return next.filterCandidate(mockNameMatches, field, fields,
fieldInstance);
String mockName = mockUtil.getMockName(mocks.iterator().next())
.toString();
for (Field otherField : fields) {
if (!otherField.equals(field)
&& otherField.getType().equals(field.getType())
&& otherField.getName().equals(mockName)) {
return new OngoingInjecter() {
public Object thenInject() {
return null;
return next.filterCandidate(mocks, field, fields, fieldInstance);
public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
public void shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable() {
MockitoAnnotations.initMocks(this);
assertNull(otherSuperUnderTesting.candidate1);
assertNotNull(otherSuperUnderTesting.candidate2);
static class OtherSuperUnderTesting {
private A candidate1;
private A candidate2;
interface A {Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
Object fieldInstance
private final MockCandidateFilter next;
private final MockUtil mockUtil = new MockUtil();
public NameBasedCandidateFilter(MockCandidateFilter next) {
this.next = next;
public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
List<Object> mockNameMatches = new ArrayList<Object>();
if(mocks.size() > 1) {
for (Object mock : mocks) {
if (field.getName().equals(mockUtil.getMockName(mock).toString())) {
mockNameMatches.add(mock);
return next.filterCandidate(mockNameMatches, field, fieldInstance);
return next.filterCandidate(mocks, field, fieldInstance);
public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
return next.filterCandidate(mockTypeMatches, field, fieldInstance);Timeout(VerificationOverTimeImpl verificationOverTime) {
super(verificationOverTime);private final long durationMillis;
this(pollingPeriodMillis, durationMillis, delegate, returnOnSuccess, new Timer(durationMillis));
public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {
this.durationMillis = durationMillis;
public long getPollingPeriod() {
return pollingPeriodMillis;
public long getDuration() {
return durationMillis;
public VerificationMode getDelegate() {
return delegate;
public After(long pollingPeriod, long delayMillis, VerificationMode verificationMode) {
super(new VerificationOverTimeImpl(pollingPeriod, delayMillis, verificationMode, false));
return new After(wrappedVerification.getPollingPeriod(), wrappedVerification.getDuration(), verificationMode);
super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true));
Timeout(long pollingPeriodMillis, long millis, VerificationMode delegate, Timer timer) {
super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true, timer));
return new Timeout(wrappedVerification.getPollingPeriod(), wrappedVerification.getDuration(), newVerificationMode);
import org.mockito.internal.verification.AtLeast;
import org.mockito.internal.verification.Only;
import org.mockito.internal.verification.Times;
Timeout t = new Timeout(1, 3, mode, timer);
Timeout t = new Timeout(1, 2, mode, timer);
Timeout t = new Timeout(1, 5, mode, timer);
Timeout t = new Timeout(10, 50, mode, timer);
public void should_create_correctly_configured_timeout() {
Timeout t = new Timeout(25, 50, mode, timer);
assertTimeoutCorrectlyConfigured(t.atLeastOnce(), Timeout.class, 50, 25, AtLeast.class);
assertTimeoutCorrectlyConfigured(t.atLeast(5), Timeout.class, 50, 25, AtLeast.class);
assertTimeoutCorrectlyConfigured(t.times(5), Timeout.class, 50, 25, Times.class);
assertTimeoutCorrectlyConfigured(t.only(), Timeout.class, 50, 25, Only.class);
private void assertTimeoutCorrectlyConfigured(VerificationMode t, Class<?> expectedType, long expectedTimeout, long expectedPollingPeriod, Class<?> expectedDelegateType) {
assertEquals(expectedType, t.getClass());
assertEquals(expectedTimeout, ((Timeout) t).wrappedVerification.getDuration());
assertEquals(expectedPollingPeriod, ((Timeout) t).wrappedVerification.getPollingPeriod());
assertEquals(expectedDelegateType, ((Timeout) t).wrappedVerification.getDelegate().getClass());boolean stillCounting = timer.isCounting();
assertThat(stillCounting, is(true));
public void should_return_false_if_task_is_outside_the_acceptable_time_bounds() {
Timer timer = new Timer(-1);
boolean stillCounting = timer.isCounting();private final Class<? extends T> clazz;
private ArgumentCaptor(Class<? extends T> clazz) {
public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
return new ArgumentCaptor<U>(clazz);
"But found this interaction on mock '" + undesired.getMock() + "':",
"But found this interaction on mock '" + undesired.getMock() + "':",
"Mockito couldn't inject mock dependency '" + new MockUtil().getMockName(matchingMock) + "' on field ",
"Also I failed because: " + details.getCause().getMessage(),
" -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
" -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
"When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
"When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
import org.mockito.internal.reporting.*;
public void shouldLetPassingNullLastActualStackTrace() throws Exception {
public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {
new Reporter().invocationListenerDoesNotAcceptNullParameters();
import java.util.ArrayList;
public void should_allow_construction_of_captor_for_parameterized_type_in_a_convenient_way()  {
ArgumentCaptor<List<Person>> argument = ArgumentCaptor.forClass(List.class);
public void should_allow_construction_of_captor_for_a_more_specific_type()  {
ArgumentCaptor<List> argument = ArgumentCaptor.forClass(ArrayList.class);private final Class<T> clazz;
ArgumentCaptor(Class<T> clazz) {
public static <T> ArgumentCaptor<T> forClass(Class<T> clazz) {
return new ArgumentCaptor<T>(clazz);private final Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();
Collections.sort(declaredFields, superTypesLast);
static class FieldTypeAndNameComparator implements Comparator<Field> {
public int compare(Field field1, Field field2) {
Class<?> field1Type = field1.getType();
Class<?> field2Type = field2.getType();
if (field1Type == field2Type) {
return field1.getName().compareTo(field2.getName());
if(field1Type.isAssignableFrom(field2Type)) {
return 1;
if(field2Type.isAssignableFrom(field1Type)) {
return -1;
return 0;
private static Comparator<Field> cmp = new PropertyAndSetterInjection.FieldTypeAndNameComparator();
Collections.sort(unsortedFields, cmp);package org.mockito.internal.creation.bytebuddy;
import static org.mockito.internal.creation.bytebuddy.MockFeatures.withMockFeatures;
import static org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.*;
import static org.mockito.internal.util.StringJoiner.join;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoSerializationIssue;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.ForWriteReplace;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.reflection.FieldSetter;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.MockName;
class ByteBuddyCrossClassLoaderSerializationSupport implements Serializable {
private static final long serialVersionUID = 7411152578314420778L;
private static final String MOCKITO_PROXY_MARKER = "ByteBuddyMockitoProxyMarker";
private boolean instanceLocalCurrentlySerializingFlag = false;
private final Lock mutex = new ReentrantLock();
public Object writeReplace(Object mockitoMock) throws ObjectStreamException {
mutex.lock();
try {
if (mockIsCurrentlyBeingReplaced()) {
return mockitoMock;
mockReplacementStarted();
return new CrossClassLoaderSerializationProxy(mockitoMock);
MockUtil mockUtil = new MockUtil();
MockName mockName = mockUtil.getMockName(mockitoMock);
String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();
throw new MockitoSerializationIssue(join(
"The mock '" + mockName + "' of type '" + mockedType + "'",
"The Java Standard Serialization reported an '" + ioe.getClass().getSimpleName() + "' saying :",
"  " + ioe.getMessage()
), ioe);
mockReplacementCompleted();
mutex.unlock();
private void mockReplacementCompleted() {
instanceLocalCurrentlySerializingFlag = false;
private void mockReplacementStarted() {
instanceLocalCurrentlySerializingFlag = true;
private boolean mockIsCurrentlyBeingReplaced() {
return instanceLocalCurrentlySerializingFlag;
public static class CrossClassLoaderSerializationProxy implements Serializable {
private static final long serialVersionUID = -7600267929109286514L;
private final byte[] serializedMock;
private final Class typeToMock;
private final Set<Class> extraInterfaces;
public CrossClassLoaderSerializationProxy(Object mockitoMock) throws IOException {
ByteArrayOutputStream out = new ByteArrayOutputStream();
ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);
objectOutputStream.writeObject(mockitoMock);
objectOutputStream.close();
out.close();
MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);
this.serializedMock = out.toByteArray();
this.typeToMock = mockSettings.getTypeToMock();
this.extraInterfaces = mockSettings.getExtraInterfaces();
private Object readResolve() throws ObjectStreamException {
try {
ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);
ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);
Object deserializedMock = objectInputStream.readObject();
bis.close();
objectInputStream.close();
return deserializedMock;
throw new MockitoSerializationIssue(join(
"Mockito mock cannot be deserialized to a mock of '" + typeToMock.getCanonicalName() + "'. The error was :",
"  " + ioe.getMessage(),
"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list."
), ioe);
throw new MockitoSerializationIssue(join(
"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :",
"  " + cce.getMessage(),
"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list."
), cce);
public static class MockitoMockObjectInputStream extends ObjectInputStream {
private final Class typeToMock;
private final Set<Class> extraInterfaces;
public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {
super(in);
this.typeToMock = typeToMock;
this.extraInterfaces = extraInterfaces;
enableResolveObject(true); // ensure resolving is enabled
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (notMarkedAsAMockitoMock(readObject())) {
return super.resolveClass(desc);
Class<?> proxyClass = ((ByteBuddyMockMaker) Plugins.getMockMaker())
.createProxyClass(withMockFeatures(typeToMock, extraInterfaces, true));
hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
return proxyClass;
private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {
try {
Field classNameField = descInstance.getClass().getDeclaredField("name");
new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());
throw new MockitoSerializationIssue(join(
"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
"this is definitely a bug in our code as it means the JDK team changed a few internal things.",
"",
"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."
), nsfe);
private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {
return !MOCKITO_PROXY_MARKER.equals(marker);
private static class MockitoMockObjectOutputStream extends ObjectOutputStream {
private static final String NOTHING = "";
public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {
super(out);
protected void annotateClass(Class<?> cl) throws IOException {
writeObject(mockitoProxyClassMarker(cl));
private String mockitoProxyClassMarker(Class<?> cl) {
if (CrossClassLoaderSerializableMock.class.isAssignableFrom(cl)) {
return MOCKITO_PROXY_MARKER;
return NOTHING;
public interface CrossClassLoaderSerializableMock {
Object writeReplace() throws ObjectStreamException;
package org.mockito.internal.creation.bytebuddy;
import static org.mockito.internal.util.StringJoiner.join;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.instance.Instantiator;
import org.mockito.internal.creation.instance.InstantiatorProvider;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.SerializableMode;
import org.mockito.plugins.MockMaker;
public class ByteBuddyMockMaker implements MockMaker {
private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;
public ByteBuddyMockMaker() {
cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();
public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
Class<T> mockedProxyType = createProxyClass(mockWithFeaturesFrom(settings));
Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
T mockInstance = null;
try {
mockInstance = instantiator.newInstance(mockedProxyType);
MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
return ensureMockIsAssignableToMockedType(settings, mockInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito mock :",
"  class to mock : " + describeClass(mockedProxyType),
"  created class : " + describeClass(settings.getTypeToMock()),
"  proxy instance class : " + describeClass(mockInstance),
"  instance creation by : " + instantiator.getClass().getSimpleName(),
"",
"You might experience classloading issues, please ask the mockito mailing-list.",
""
),cce);
throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
<T> Class<T> createProxyClass(MockFeatures<T> mockFeatures) {
return cachingMockBytecodeGenerator.get(mockFeatures);
private <T> MockFeatures<T> mockWithFeaturesFrom(MockCreationSettings<T> settings) {
return MockFeatures.withMockFeatures(
settings.getTypeToMock(),
settings.getExtraInterfaces(),
settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS
);
private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {
Class<T> typeToMock = settings.getTypeToMock();
return typeToMock.cast(mock);
private static String describeClass(Class type) {
return type == null ? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private static String describeClass(Object instance) {
return instance == null ? "null" : describeClass(instance.getClass());
public MockHandler getHandler(Object mock) {
if (!(mock instanceof MockMethodInterceptor.MockAccess)) {
return null;
return ((MockMethodInterceptor.MockAccess) mock).getMockitoInterceptor().getMockHandler();
public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
((MockMethodInterceptor.MockAccess) mock).setMockitoInterceptor(
new MockMethodInterceptor(asInternalMockHandler(newHandler), settings)
);
private static InternalMockHandler asInternalMockHandler(MockHandler handler) {
if (!(handler instanceof InternalMockHandler)) {
throw new MockitoException(join(
"At the moment you cannot provide own implementations of MockHandler.",
"Please see the javadocs for the MockMaker interface.",
""
));
return (InternalMockHandler) handler;
package org.mockito.internal.creation.bytebuddy;
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.ref.WeakReference;
import java.lang.reflect.Modifier;
import java.util.HashSet;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.mockito.exceptions.base.MockitoException;
class CachingMockBytecodeGenerator {
private final Lock avoidingClassLeakCacheLock = new ReentrantLock();
public final WeakHashMap<ClassLoader, CachedBytecodeGenerator> avoidingClassLeakageCache =
new WeakHashMap<ClassLoader, CachedBytecodeGenerator>();
private final MockBytecodeGenerator mockBytecodeGenerator = new MockBytecodeGenerator();
public <T> Class<T> get(MockFeatures<T> params) {
avoidingClassLeakCacheLock.lock();
try {
Class generatedMockClass = mockCachePerClassLoaderOf(params.mockedType).getOrGenerateMockClass(
params
);
return generatedMockClass;
avoidingClassLeakCacheLock.unlock();
private <T> CachedBytecodeGenerator mockCachePerClassLoaderOf(Class<T> mockedType) {
if (!avoidingClassLeakageCache.containsKey(mockedType.getClassLoader())) {
avoidingClassLeakageCache.put(
mockedType.getClassLoader(),
new CachedBytecodeGenerator(mockBytecodeGenerator)
);
return avoidingClassLeakageCache.get(mockedType.getClassLoader());
private static class CachedBytecodeGenerator {
private ConcurrentHashMap<MockKey, WeakReference<Class>> generatedClassCache =
new ConcurrentHashMap<MockKey, WeakReference<Class>>();
private final MockBytecodeGenerator generator;
private CachedBytecodeGenerator(MockBytecodeGenerator generator) {
this.generator = generator;
public <T> Class getOrGenerateMockClass(MockFeatures<T> features) {
MockKey mockKey = MockKey.of(features.mockedType, features.interfaces);
Class generatedMockClass = null;
WeakReference<Class> classWeakReference = generatedClassCache.get(mockKey);
if(classWeakReference != null) {
generatedMockClass = classWeakReference.get();
if(generatedMockClass == null) {
generatedMockClass = generate(features);
generatedClassCache.put(mockKey, new WeakReference<Class>(generatedMockClass));
return generatedMockClass;
private <T> Class<? extends T> generate(MockFeatures<T> mockFeatures) {
try {
return generator.generateMockClass(mockFeatures);
throw prettifyFailure(mockFeatures, bytecodeGenerationFailed);
private RuntimeException prettifyFailure(MockFeatures<?> mockFeatures, Exception generationFailed) {
if (Modifier.isPrivate(mockFeatures.mockedType.getModifiers())) {
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType + ".",
"Most likely it is a private class that is not visible by Mockito"
));
throw new MockitoException(join(
"Mockito cannot mock this class: " + mockFeatures.mockedType,
"",
"Mockito can only mock visible & non-final classes.",
"If you're not sure why you're getting this error, please report to the mailing list."),
generationFailed
);
private static class MockKey<T> {
private final String mockedType;
private final Set<String> types = new HashSet<String>();
private MockKey(Class<T> mockedType, Set<Class> interfaces) {
this.mockedType = mockedType.getName();
for (Class anInterface : interfaces) {
types.add(anInterface.getName());
types.add(this.mockedType);
public boolean equals(Object other) {
if (this == other) return true;
if (other == null || getClass() != other.getClass()) return false;
MockKey mockKey = (MockKey<?>) other;
if (!mockedType.equals(mockKey.mockedType)) return false;
if (!types.equals(mockKey.types)) return false;
return true;
public int hashCode() {
int result = mockedType.hashCode();
result = 31 * result + types.hashCode();
return result;
public static <T> MockKey of(Class<T> mockedType, Set<Class> interfaces) {
return new MockKey<T>(mockedType, interfaces);
package org.mockito.internal.creation.bytebuddy;
import org.mockito.exceptions.Reporter;
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.internal.exceptions.VerificationAwareInvocation;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.internal.invocation.ArgumentsProcessor;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.reporting.PrintSettings;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.StubInfo;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.concurrent.Callable;
class InterceptedInvocation implements Invocation, VerificationAwareInvocation {
private static final long serialVersionUID = 475027563923510472L;
private final Object mock;
private final MockitoMethod mockitoMethod;
private final Object[] arguments, rawArguments;
private final SuperMethod superMethod;
private final int sequenceNumber;
private final Location location;
private boolean verified;
private boolean isIgnoredForVerification;
private StubInfo stubInfo;
public InterceptedInvocation(Object mock,
MockitoMethod mockitoMethod,
Object[] arguments,
SuperMethod superMethod,
int sequenceNumber) {
this.mock = mock;
this.mockitoMethod = mockitoMethod;
this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), arguments);
this.rawArguments = arguments;
this.superMethod = superMethod;
this.sequenceNumber = sequenceNumber;
location = new LocationImpl();
public boolean isVerified() {
return verified || isIgnoredForVerification;
public int getSequenceNumber() {
return sequenceNumber;
public Location getLocation() {
return location;
public Object[] getRawArguments() {
return rawArguments;
public void markVerified() {
verified = true;
public StubInfo stubInfo() {
return stubInfo;
public void markStubbed(StubInfo stubInfo) {
this.stubInfo = stubInfo;
public boolean isIgnoredForVerification() {
return isIgnoredForVerification;
public void ignoreForVerification() {
isIgnoredForVerification = true;
public Object getMock() {
return mock;
public Method getMethod() {
return mockitoMethod.getJavaMethod();
public Object[] getArguments() {
return arguments;
public <T> T getArgumentAt(int index, Class<T> clazz) {
return (T) arguments[index];
public Object callRealMethod() throws Throwable {
if (!superMethod.isInvokable()) {
new Reporter().cannotCallAbstractRealMethod();
return superMethod.invoke();
public int hashCode() {
return 1;
public boolean equals(Object o) {
if (o == null || !o.getClass().equals(this.getClass())) {
return false;
InterceptedInvocation other = (InterceptedInvocation) o;
return this.mock.equals(other.mock)
&& this.mockitoMethod.equals(other.mockitoMethod)
&& this.equalArguments(other.arguments);
private boolean equalArguments(Object[] arguments) {
return Arrays.equals(arguments, this.arguments);
public String toString() {
return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);
public static interface SuperMethod extends Serializable {
static enum IsIllegal implements SuperMethod {
INSTANCE;
public boolean isInvokable() {
return false;
public Object invoke() {
throw new IllegalStateException();
static class FromCallable implements SuperMethod {
private static final long serialVersionUID = 47957363950483625L;
private final Callable<?> callable;
public FromCallable(Callable<?> callable) {
this.callable = callable;
public boolean isInvokable() {
return true;
public Object invoke() throws Throwable {
try {
return callable.call();
new ConditionalStackTraceFilter().filter(t);
throw t;
boolean isInvokable();
Object invoke() throws Throwable;
package org.mockito.internal.creation.bytebuddy;
import java.util.Random;
import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
import org.mockito.internal.creation.util.SearchingClassLoader;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.ClassFileVersion;
import net.bytebuddy.dynamic.ClassLoadingStrategy;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
import net.bytebuddy.instrumentation.FieldAccessor;
import net.bytebuddy.instrumentation.MethodDelegation;
import net.bytebuddy.instrumentation.attribute.MethodAttributeAppender;
import net.bytebuddy.instrumentation.attribute.TypeAttributeAppender;
import net.bytebuddy.matcher.ElementMatchers;
import net.bytebuddy.modifier.FieldManifestation;
import net.bytebuddy.modifier.Ownership;
import net.bytebuddy.modifier.Visibility;
class MockBytecodeGenerator {
private final ByteBuddy byteBuddy;
private final Random random;
public MockBytecodeGenerator() {
byteBuddy = new ByteBuddy(ClassFileVersion.JAVA_V5)
.withDefaultMethodAttributeAppender(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE)
.withAttribute(TypeAttributeAppender.ForSuperType.INSTANCE);
random = new Random();
public <T> Class<? extends T> generateMockClass(MockFeatures<T> features) {
DynamicType.Builder<T> builder = byteBuddy.subclass(features.mockedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
.name(nameFor(features.mockedType))
.implement(features.interfaces.toArray(new Class<?>[features.interfaces.size()]))
.method(ElementMatchers.any()).intercept(MethodDelegation
.toInstanceField(MockMethodInterceptor.class, "mockitoInterceptor")
.filter(ElementMatchers.isDeclaredBy(MockMethodInterceptor.class)))
.implement(MockMethodInterceptor.MockAccess.class).intercept(FieldAccessor.ofBeanProperty())
.method(ElementMatchers.isHashCode()).intercept(MethodDelegation.to(MockMethodInterceptor.ForHashCode.class))
.method(ElementMatchers.isEquals()).intercept(MethodDelegation.to(MockMethodInterceptor.ForEquals.class))
.defineField("serialVersionUID", long.class, Ownership.STATIC, Visibility.PRIVATE, FieldManifestation.FINAL).value(42L);
if (features.crossClassLoaderSerializable) {
builder = builder.implement(CrossClassLoaderSerializableMock.class)
.intercept(MethodDelegation.to(MockMethodInterceptor.ForWriteReplace.class));
Class<?>[] allMockedTypes = new Class<?>[features.interfaces.size() + 1];
allMockedTypes[0] = features.mockedType;
int index = 1;
for (Class<?> type : features.interfaces) {
allMockedTypes[index++] = type;
return builder.make()
.load(SearchingClassLoader.combineLoadersOf(allMockedTypes), ClassLoadingStrategy.Default.INJECTION)
.getLoaded();
private String nameFor(Class<?> type) {
String typeName = type.getName();
if (typeName.startsWith("java.") || (type.getPackage() != null && type.getPackage().isSealed())) {
typeName = "codegen." + typeName;
return String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
package org.mockito.internal.creation.bytebuddy;
import java.util.Collections;
import java.util.Set;
class MockFeatures<T> {
final Class<T> mockedType;
final Set<Class> interfaces;
final boolean crossClassLoaderSerializable;
private MockFeatures(Class<T> mockedType, Set<Class> interfaces, boolean crossClassLoaderSerializable) {
this.mockedType = mockedType;
this.interfaces = Collections.unmodifiableSet(interfaces);
this.crossClassLoaderSerializable = crossClassLoaderSerializable;
public static <T> MockFeatures<T> withMockFeatures(Class<T> mockedType, Set<Class> interfaces, boolean crossClassLoaderSerializable) {
return new MockFeatures<T>(mockedType, interfaces, crossClassLoaderSerializable);
package org.mockito.internal.creation.bytebuddy;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.DelegatingMethod;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.progress.SequenceNumber;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.AllArguments;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.Argument;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.BindingPriority;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.DefaultCall;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.Origin;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.RuntimeType;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.SuperCall;
import net.bytebuddy.instrumentation.method.bytecode.bind.annotation.This;
public class MockMethodInterceptor implements Serializable {
private static final long serialVersionUID = 7152947254057253027L;
private final InternalMockHandler handler;
private final MockCreationSettings mockCreationSettings;
private final ByteBuddyCrossClassLoaderSerializationSupport serializationSupport;
public MockMethodInterceptor(InternalMockHandler handler, MockCreationSettings mockCreationSettings) {
this.handler = handler;
this.mockCreationSettings = mockCreationSettings;
serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport();
public Object interceptSuperCallable(@This Object mock,
return doIntercept(
mock,
invokedMethod,
arguments,
new InterceptedInvocation.SuperMethod.FromCallable(superCall)
);
public Object interceptDefaultCallable(@This Object mock,
return doIntercept(
mock,
invokedMethod,
arguments,
new InterceptedInvocation.SuperMethod.FromCallable(superCall)
);
public Object interceptAbstract(@This Object mock,
return doIntercept(
mock,
invokedMethod,
arguments,
InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE
);
private Object doIntercept(Object mock,
Method invokedMethod,
Object[] arguments,
InterceptedInvocation.SuperMethod superMethod) throws Throwable {
return handler.handle(new InterceptedInvocation(
mock,
createMockitoMethod(invokedMethod),
arguments,
superMethod,
SequenceNumber.next()
));
private MockitoMethod createMockitoMethod(Method method) {
if (mockCreationSettings.isSerializable()) {
return new SerializableMethod(method);
return new DelegatingMethod(method);
public MockHandler getMockHandler() {
return handler;
public ByteBuddyCrossClassLoaderSerializationSupport getSerializationSupport() {
return serializationSupport;
public static class ForHashCode {
public static int doIdentityHashCode(@This Object thiz) {
return System.identityHashCode(thiz);
public static class ForEquals {
public static boolean doIdentityEquals(@This Object thiz, @Argument(0) Object other) {
return thiz == other;
public static class ForWriteReplace {
public static Object doWriteReplace(@This MockAccess thiz) throws ObjectStreamException {
return thiz.getMockitoInterceptor().getSerializationSupport().writeReplace(thiz);
public static interface MockAccess {
MockMethodInterceptor getMockitoInterceptor();
void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
package org.mockito.internal.creation.bytebuddy;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import java.util.List;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.MockAccess;
import org.mockito.internal.stubbing.InvocationContainer;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.MockMaker;
import org.mockito.stubbing.VoidMethodStubbable;
import org.mockitoutil.ClassLoaders;
import org.objenesis.ObjenesisStd;
import net.bytebuddy.ByteBuddy;
public class ByteBuddyMockMakerTest {
MockMaker mockMaker = new ByteBuddyMockMaker();
public void should_create_mock_from_interface() throws Exception {
SomeInterface proxy = mockMaker.createMock(settingsFor(SomeInterface.class), dummyH());
Class superClass = proxy.getClass().getSuperclass();
assertThat(superClass).isEqualTo(Object.class);
public void should_create_mock_from_class() throws Exception {
ClassWithoutConstructor proxy = mockMaker.createMock(settingsFor(ClassWithoutConstructor.class), dummyH());
Class superClass = proxy.getClass().getSuperclass();
assertThat(superClass).isEqualTo(ClassWithoutConstructor.class);
public void should_create_mock_from_class_even_when_constructor_is_dodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = mockMaker.createMock(settingsFor(ClassWithDodgyConstructor.class), dummyH());
assertThat(mock).isNotNull();
public void should_mocks_have_different_interceptors() throws Exception {
SomeClass mockOne = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
SomeClass mockTwo = mockMaker.createMock(settingsFor(SomeClass.class), dummyH());
MockAccess interceptorOne = (MockAccess) mockOne;
MockAccess interceptorTwo = (MockAccess) mockTwo;
assertThat(interceptorOne.getMockitoInterceptor())
.isNotSameAs(interceptorTwo.getMockitoInterceptor());
public void should_use_ancillary_Types() {
SomeClass mock = mockMaker.createMock(settingsFor(SomeClass.class, SomeInterface.class), dummyH());
assertThat(mock).isInstanceOf(SomeInterface.class);
public void should_create_class_by_constructor() {
OtherClass mock = mockMaker.createMock(settingsWithConstructorFor(OtherClass.class), dummyH());
assertThat(mock).isNotNull();
class SomeClass {}
interface SomeInterface {}
static class OtherClass {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
public void report_issue_when_trying_to_load_objenesis() throws Exception {
ClassLoader classpath_without_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class)
.without("org.objenesis")
.build();
boolean initialize_class = true;
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker",
initialize_class,
classpath_without_objenesis
);
try {
mock_maker_class_loaded_fine_until.newInstance();
fail();
assertThat(e).isInstanceOf(IllegalStateException.class);
assertThat(e.getMessage()).containsIgnoringCase("objenesis").contains("missing");
public void instantiate_fine_when_objenesis_on_the_classpath() throws Exception {
ClassLoader classpath_with_objenesis = ClassLoaders.excludingClassLoader()
.withCodeSourceUrlOf(Mockito.class, ByteBuddy.class, ObjenesisStd.class)
.build();
boolean initialize_class = true;
Class<?> mock_maker_class_loaded_fine_until = Class.forName(
"org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker",
initialize_class,
classpath_with_objenesis
);
mock_maker_class_loaded_fine_until.newInstance();
private static <T> MockCreationSettings<T> settingsFor(Class<T> type, Class... extraInterfaces) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
if(extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
return mockSettings;
private static <T> MockCreationSettings<T> settingsWithConstructorFor(Class<T> type) {
MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
mockSettings.setTypeToMock(type);
return mockSettings;
public static MockHandler dummyH() {
return new DummyMockHandler();
private static class DummyMockHandler implements InternalMockHandler {
public Object handle(Invocation invocation) throws Throwable { return null; }
public MockCreationSettings getMockSettings() { return null; }
public VoidMethodStubbable voidMethodStubbable(Object mock) { return null; }
public InvocationContainer getInvocationContainer() { return null; }
public void setAnswersForStubbing(List list) { }
package org.mockito.internal.creation.bytebuddy;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assume.assumeTrue;
import static org.mockito.internal.creation.bytebuddy.MockFeatures.withMockFeatures;
import static org.mockitoutil.ClassLoaders.inMemoryClassLoader;
import static org.mockitoutil.SimpleClassGenerator.makeMarkerInterface;
import java.lang.management.ManagementFactory;
import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.List;
import java.util.WeakHashMap;
import org.junit.Before;
import org.junit.Test;
public class CachingMockBytecodeGeneratorTest {
public void ensure_disable_gc_is_activated() throws Exception {
assumeTrue(explicitGCEnabled());
public void ensure_cache_is_cleared_if_no_reference_to_classloader_and_classes() throws Exception {
ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
CachingMockBytecodeGenerator cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();
Class<?> the_mock_type = cachingMockBytecodeGenerator.get(withMockFeatures(
classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
Collections.<Class>emptySet(),
false
));
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
classloader_with_life_shorter_than_cache = is_no_more_referenced();
the_mock_type = is_no_more_referenced();
System.gc();
ensure_gc_happened();
assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
public void validate_simple_code_idea_where_weakhashmap_with_classloader_as_key_get_GCed_when_no_more_references() throws Exception {
WeakHashMap<ClassLoader, Object> cache = new WeakHashMap<ClassLoader, Object>();
ClassLoader short_lived_classloader = inMemoryClassLoader()
.withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
.build();
cache.put(short_lived_classloader, new HoldingAReference(new WeakReference<Class>(short_lived_classloader.loadClass("foo.Bar"))));
assertThat(cache).hasSize(1);
short_lived_classloader = is_no_more_referenced();
System.gc();
ensure_gc_happened();
assertThat(cache).isEmpty();
static class HoldingAReference {
final WeakReference<Class> a;
HoldingAReference(WeakReference<Class> a) {
this.a = a;
private static <T> T is_no_more_referenced() {
return null;
private static boolean explicitGCEnabled() {
List<String> inputArguments = ManagementFactory.getRuntimeMXBean().getInputArguments();
for (String inputArgument : inputArguments) {
if (inputArgument.contains("-XX:+DisableExplicitGC")) {
return false;
return true;
private static void ensure_gc_happened() throws InterruptedException {
Thread.sleep(500);
return method.getReturnType() == Object.class
if (mockIsCurrentlyBeingReplaced()) {
super(in);
Field classNameField = descInstance.getClass().getDeclaredField("name");
new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.proxy.MethodProxy;
import java.io.Serializable;
import java.lang.reflect.Field;
class CGLIBHacker {
public void setMockitoNamingPolicy(MethodProxy methodProxy) {
try {
Field createInfoField = reflectOnCreateInfo(methodProxy);
createInfoField.setAccessible(true);
Object createInfo = createInfoField.get(methodProxy);
Field namingPolicyField = createInfo.getClass().getDeclaredField("namingPolicy");
namingPolicyField.setAccessible(true);
if (namingPolicyField.get(createInfo) == null) {
namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);
throw new RuntimeException(
"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses", e);
private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {
Class cglibMethodProxyClass = methodProxy.getClass();
while (cglibMethodProxyClass != MethodProxy.class) {
cglibMethodProxyClass = methodProxy.getClass().getSuperclass();
return cglibMethodProxyClass.getDeclaredField("createInfo");
package org.mockito.internal.creation.cglib;
import org.mockito.cglib.core.DefaultNamingPolicy;
class MockitoNamingPolicy extends DefaultNamingPolicy {
public static final MockitoNamingPolicy INSTANCE = new MockitoNamingPolicy(); 
protected String getTag() {
return "ByMockitoWithCGLIB";
package org.mockito.cglibintegration;
package org.mockito.cglibintegration;
import static org.junit.Assert.fail;
import java.util.ArrayList;
import org.junit.Test;
import org.mockito.cglib.proxy.Enhancer;
import org.mockito.cglib.proxy.NoOp;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.internal.util.MockUtil;
public class MockUtilTest {
private MockUtil mockUtil = new MockUtil();
public void should_scream_when_enhanced_but_not_a_mock_passed() {
Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);
try {
mockUtil.getMockHandler(o);
fail();
package org.mockito.cglibintegration;
import org.mockito.Mockito;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
package org.mockito.cglibintegration;
import java.util.LinkedList;
import java.util.List;
import org.concurrentmockito.VerificationInOrderFromMultipleThreadsTest;
import org.junit.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;
import org.mockito.MockitoTest;
import org.mockito.exceptions.ReporterTest;
import org.mockito.exceptions.base.MockitoAssertionErrorTest;
import org.mockito.exceptions.base.MockitoExceptionTest;
import org.mockito.internal.AllInvocationsFinderTest;
import org.mockito.internal.InvalidStateDetectionTest;
import org.mockito.internal.creation.cglib.ClassImposterizerTest;
import org.mockito.internal.handler.MockHandlerImplTest;
import org.mockito.internal.invocation.InvocationImplTest;
import org.mockito.internal.invocation.InvocationMatcherTest;
import org.mockito.internal.invocation.InvocationsFinderTest;
import org.mockito.internal.matchers.ComparableMatchersTest;
import org.mockito.internal.matchers.EqualsTest;
import org.mockito.internal.matchers.MatchersToStringTest;
import org.mockito.internal.progress.MockingProgressImplTest;
import org.mockito.internal.progress.TimesTest;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;
import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest;
import org.mockito.internal.util.MockUtilTest;
import org.mockito.internal.util.collections.ListUtilTest;
import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;
import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;
import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;
import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;
import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;
import org.mockitousage.basicapi.ReplacingObjectMethodsTest;
import org.mockitousage.basicapi.ResetTest;
import org.mockitousage.basicapi.UsingVarargsTest;
import org.mockitousage.examples.use.ExampleTest;
import org.mockitousage.matchers.CustomMatchersTest;
import org.mockitousage.matchers.InvalidUseOfMatchersTest;
import org.mockitousage.matchers.MatchersTest;
import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;
import org.mockitousage.misuse.InvalidUsageTest;
import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;
import org.mockitousage.puzzlers.OverloadingPuzzleTest;
import org.mockitousage.stacktrace.ClickableStackTracesTest;
import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;
import org.mockitousage.stacktrace.StackTraceFilteringTest;
import org.mockitousage.stubbing.BasicStubbingTest;
import org.mockitousage.stubbing.ReturningDefaultValuesTest;
import org.mockitousage.stubbing.StubbingWithThrowablesTest;
import org.mockitousage.verification.AtMostXVerificationTest;
import org.mockitousage.verification.BasicVerificationInOrderTest;
import org.mockitousage.verification.BasicVerificationTest;
import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;
import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;
import org.mockitousage.verification.NoMoreInteractionsVerificationTest;
import org.mockitousage.verification.RelaxedVerificationInOrderTest;
import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;
import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;
import org.mockitousage.verification.VerificationInOrderTest;
import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;
import org.mockitousage.verification.VerificationUsingMatchersTest;
import org.mockitoutil.TestBase;
public class ThreadsRunAllTestsHalfManualTest extends TestBase {
private static class AllTestsRunner extends Thread {
private boolean failed;
public void run() {
Result result = JUnitCore.runClasses(
EqualsTest.class,
ListUtilTest.class,
MockingProgressImplTest.class,
TimesTest.class,
MockHandlerImplTest.class,
AllInvocationsFinderTest.class,
ReturnsEmptyValuesTest.class,
NumberOfInvocationsCheckerTest.class,
DefaultRegisteredInvocationsTest.class,
MissingInvocationCheckerTest.class,
NumberOfInvocationsInOrderCheckerTest.class,
MissingInvocationInOrderCheckerTest.class,
ClassImposterizerTest.class,
InvocationMatcherTest.class,
InvocationsFinderTest.class,
InvocationImplTest.class,
MockitoTest.class,
MockUtilTest.class,
ReporterTest.class,
MockitoAssertionErrorTest.class,
MockitoExceptionTest.class,
StackTraceFilteringTest.class,
BridgeMethodPuzzleTest.class,
OverloadingPuzzleTest.class,
InvalidUsageTest.class,
UsingVarargsTest.class,
CustomMatchersTest.class,
ComparableMatchersTest.class,
InvalidUseOfMatchersTest.class,
MatchersTest.class,
MatchersToStringTest.class,
VerificationAndStubbingUsingMatchersTest.class,
BasicStubbingTest.class,
ReturningDefaultValuesTest.class,
StubbingWithThrowablesTest.class,
AtMostXVerificationTest.class,
BasicVerificationTest.class,
ExactNumberOfTimesVerificationTest.class,
VerificationInOrderTest.class,
NoMoreInteractionsVerificationTest.class,
SelectedMocksInOrderVerificationTest.class,
VerificationOnMultipleMocksUsingMatchersTest.class,
VerificationUsingMatchersTest.class,
RelaxedVerificationInOrderTest.class,
DescriptiveMessagesWhenVerificationFailsTest.class,
DescriptiveMessagesWhenTimesXVerificationFailsTest.class,
BasicVerificationInOrderTest.class,
VerificationInOrderMixedWithOrdiraryVerificationTest.class,
DescriptiveMessagesOnVerificationInOrderErrorsTest.class,
InvalidStateDetectionTest.class,
ReplacingObjectMethodsTest.class,
ClickableStackTracesTest.class,
ExampleTest.class,
PointingStackTraceToActualInvocationTest.class,
VerificationInOrderFromMultipleThreadsTest.class,
ResetTest.class,
ReturnsGenericDeepStubsTest.class
);
if (!result.wasSuccessful()) {
System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");
List<Failure> failures = result.getFailures();
System.err.println(failures.size());
for (Failure failure : failures) {
System.err.println(failure.getTrace());
failed = true;
public boolean isFailed() {
return failed;
public void shouldRunInMultipleThreads() throws Exception {
assertFalse("Run in multiple thread failed", runInMultipleThreads(3));
public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {
List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();
for (int i = 1; i <= numberOfThreads; i++) {
threads.add(new AllTestsRunner());
for (Thread t : threads) {
t.start();
boolean failed = false;
for (AllTestsRunner t : threads) {
t.join();
failed = failed ? true : t.isFailed();
return failed;
public static void main(String[] args) throws Exception {
int numberOfThreads = 20;
long before = System.currentTimeMillis();
runInMultipleThreads(numberOfThreads);
long after = System.currentTimeMillis();
long executionTime = (after-before)/1000;
System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds.");
package org.mockito.internal.creation.cglib;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.cglib.core.NamingPolicy;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockitoutil.TestBase;
import org.powermock.reflect.Whitebox;
import static org.mockito.Mockito.spy;
public class CGLIBHackerTest extends TestBase {
public void shouldSetMockitoNamingPolicy() throws Exception {
MethodProxy methodProxy = MethodProxy.create(String.class, Integer.class, "", "", "");
new CGLIBHacker().setMockitoNamingPolicy(methodProxy);
Object createInfo = Whitebox.getInternalState(methodProxy, "createInfo");
NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {
MethodProxy proxiedMethodProxy = spy(MethodProxy.create(String.class, Integer.class, "", "", ""));
new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);
Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, "createInfo");
NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
= new PluginLoader(pluginSwitch).loadPlugin(MockMaker.class, "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker");
boolean fromByteBuddyMockObject = e.getClassName().contains("$MockitoMock$");
return (fromMockObject || fromByteBuddyMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;
import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;
public class MyMockMaker extends ByteBuddyMockMaker {
import java.util.LinkedList;
import java.util.List;
import org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGeneratorTest;
import org.mockitousage.verification.AtMostXVerificationTest;
import org.mockitousage.verification.BasicVerificationInOrderTest;
import org.mockitousage.verification.BasicVerificationTest;
import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;
import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;
import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;
import org.mockitousage.verification.NoMoreInteractionsVerificationTest;
import org.mockitousage.verification.RelaxedVerificationInOrderTest;
import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;
import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;
import org.mockitousage.verification.VerificationInOrderTest;
import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;
import org.mockitousage.verification.VerificationUsingMatchersTest;
CachingMockBytecodeGeneratorTest.class,
int numberOfThreads = 20;
import static org.mockito.Mockito.withSettings;
import java.util.ArrayList;
import java.util.List;
import org.junit.Ignore;
MockitoAssertionError error = new MockitoAssertionError("");
import java.util.Set;
import org.junit.Assume;
import org.mockito.internal.configuration.plugins.Plugins;
import net.bytebuddy.ByteBuddy;
public void pure_mockito_should_not_depend_JUnit___ByteBuddy() throws Exception {
Assume.assumeTrue("ByteBuddyMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));
ByteBuddy.class,
public void shouldNotAllowMockAndSpy() throws Exception {
public void shouldNotAllowSpyAndInjectMock() throws Exception {
MockitoAnnotations.initMocks(new Object() {
public void shouldNotAllowMockAndInjectMock() throws Exception {
public void shouldNotAllowCaptorAndMock() throws Exception {
public void shouldNotAllowCaptorAndSpy() throws Exception {
public void shouldNotAllowCaptorAndInjectMock() throws Exception {
import static org.mockito.Matchers.anyObject;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import java.util.List;
import org.junit.Assume;
import org.junit.Before;
import org.mockito.internal.configuration.plugins.Plugins;
public void only_if_CglibMockMaker() {
Assume.assumeTrue("CglibMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import java.util.concurrent.Callable;
import org.junit.Assume;
import org.mockito.internal.configuration.plugins.Plugins;
Assume.assumeTrue("CglibMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));
return (!qualifiedName.contains("net.bytebuddy") && qualifiedName.contains("org.mockito"));
import org.junit.Ignore;
import static org.mockito.Mockito.*;
import java.io.ByteArrayInputStream;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
import static org.objectweb.asm.Opcodes.ACC_INTERFACE;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.V1_6;
import org.objectweb.asm.ClassWriter;
obtainClassPath("net.bytebuddy.ByteBuddy")ClassLoader classpath_without_objenesis = ClassLoaders.excludingClassLoader()
classpath_without_objenesisimport net.bytebuddy.modifier.MemberVisibility;
private static class MockKey {
private final Class<?> mockedType;
private MockKey(Class<?> mockedType, Set<Class> interfaces, boolean acrossClassLoaderSerialization) {
MockKey mockKey = (MockKey) other;
private final Map<MockKey, Class<?>> previousClasses;
previousClasses = new HashMap<MockKey, Class<?>>();
MockKey mockKey = new MockKey(mockedType, interfaces, acrossClassLoaderSerialization);
Class<? extends T> mockType = (Class<? extends T>) previousClasses.get(mockKey);
try {
mockType = makeMock(mockedType, interfaces, acrossClassLoaderSerialization);
prettify(mockedType, e);
previousClasses.put(mockKey, mockType);
builder = builder.defineMethod("writeReplace", Object.class, Collections.<Class<?>>emptyList(), MemberVisibility.PRIVATE).intercept(MethodDelegation.to(MethodDelegation.to(MethodInterceptor.ForWriteReplace.class)));
if (typeName.startsWith("java.") || type.getPackage().isSealed()) {
public static interface SuperMethod {DynamicType.Builder<T> builder = byteBuddy.subclass(mockType)
.method(any()).intercept(MethodDelegation.toInstanceField(MethodInterceptor.class, "mockitoInterceptor"))import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
catch (ArgumentsAreDifferent e) {VersionFile versionFile(File versionFile) {return reportMatcher(Any.ANY).returnFalse();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnChar();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return reportMatcher(Any.ANY).returnZero();
return (T) reportMatcher(Any.ANY).returnNull();
return (T) reportMatcher(Any.ANY).returnFor(clazz);
return (T) anyObject();
return reportMatcher(Any.ANY).returnString();
return reportMatcher(Any.ANY).returnList();
return (List) reportMatcher(Any.ANY).returnList();
return reportMatcher(Any.ANY).returnSet();
return (Set) reportMatcher(Any.ANY).returnSet();
return reportMatcher(Any.ANY).returnMap();
return reportMatcher(Any.ANY).returnMap();
return reportMatcher(Any.ANY).returnList();
return (Collection) reportMatcher(Any.ANY).returnList();
public static final Any ANY = new Any();    
public void shouldAnyXMatchersAcceptNull() {
assertEquals("0", mock.oneArg((Object) null));
assertEquals("1", mock.oneArg((String) null));
assertEquals("2", mock.forList(null));
assertEquals("3", mock.forMap(null));
assertEquals("4", mock.forCollection(null));
assertEquals("5", mock.forSet(null));
public void shouldAcceptNullsInAllPrimitiveWrapperAnyMatchers() {
assertEquals("0", mock.forInteger(null));
assertEquals("1", mock.forCharacter(null));
assertEquals("2", mock.forShort(null));
assertEquals("3", mock.forByte(null));
assertEquals("4", mock.forBoolean(null));
assertEquals("5", mock.forLong(null));
assertEquals("6", mock.forFloat(null));
assertEquals("7", mock.forDouble(null));
when(mock.oneArg(anyString())).thenReturn("1");
assertEquals("1", mock.oneArg(""));
assertEquals("1", mock.oneArg("any string"));
assertEquals(null, mock.oneArg((Object) null));
when(mock.forList(anyList())).thenReturn("x");
assertEquals("x", mock.forList(null));
assertEquals("x", mock.forList(Arrays.asList("x", "y")));
verify(mock, times(2)).forList(anyList());
when(mock.forCollection(anyCollection())).thenReturn("x");
assertEquals("x", mock.forCollection(null));
assertEquals("x", mock.forCollection(Arrays.asList("x", "y")));
verify(mock, times(2)).forCollection(anyCollection());
when(mock.forMap(anyMap())).thenReturn("x");
assertEquals("x", mock.forMap(null));
assertEquals("x", mock.forMap(new HashMap<String, String>()));
verify(mock, times(2)).forMap(anyMap());
when(mock.forSet(anySet())).thenReturn("x");
assertEquals("x", mock.forSet(null));
assertEquals("x", mock.forSet(new HashSet<String>()));
verify(mock, times(2)).forSet(anySet());import org.gradle.api.Project;
import org.mockito.release.notes.exec.Exec;
package org.mockito.release.notes.exec;
package org.mockito.release.notes.exec;
package org.mockito.release.notes.exec;
import org.mockito.release.notes.exec.ProcessRunner;
import org.mockito.release.notes.exec.ProcessRunner;
class DefaultReleaseStep implements ReleaseStep {
private final String description;
private final Operation operation;
private Operation rollback;
public DefaultReleaseStep(String description, Operation operation) {
this.description = description;
this.operation = operation;
public String getDescription() {
return description;
public void rollback(Closure closure) {
rollback = Operations.toOperation(closure);
public Operation getRollback() {
return rollback;
public void perform() {
operation.perform();
public ReleaseStep newStep(String description, Operation operation) {
public void perform() {
List<ReleaseStep> attempted = new LinkedList<ReleaseStep>();
Operation r = s.getRollback();
if (r != null) {
System.out.println("Rolling back step " + (targets.size() + 1) + " (" + s.getDescription() + ")");
r.perform();
System.out.println("No rollback for step " + (targets.size() + 1) + " (" + s.getDescription() + ")");
import groovy.lang.Closure;
String getDescription();
void rollback(Closure closure); //TODO SF avoid leaking closure here as the release steps should be a java tool
Operation getRollback();
ReleaseStep newStep(String description, Operation operation);
package org.mockito;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
import org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs;
import org.mockito.internal.stubbing.defaultanswers.ReturnsMocks;
import org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
public enum Answers implements Answer<Object>{
RETURNS_DEFAULTS(new GloballyConfiguredAnswer()),
RETURNS_SMART_NULLS(new ReturnsSmartNulls()),
RETURNS_MOCKS(new ReturnsMocks()),
RETURNS_DEEP_STUBS(new ReturnsDeepStubs()),
CALLS_REAL_METHODS(new CallsRealMethods())
private final Answer<Object> implementation;
private Answers(Answer<Object> implementation) {
this.implementation = implementation;
public Answer<Object> get() {
return this;
public Object answer(InvocationOnMock invocation) throws Throwable {
return implementation.answer(invocation);
package org.mockito;
import org.mockito.internal.MockitoCore;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.debugging.MockitoDebuggerImpl;
import org.mockito.internal.stubbing.answers.*;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;
import org.mockito.internal.verification.VerificationModeFactory;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
import org.mockito.junit.*;
public class Mockito extends Matchers {
static final MockitoCore MOCKITO_CORE = new MockitoCore();
public static final Answer<Object> RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS;
public static final Answer<Object> RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS;
public static final Answer<Object> RETURNS_MOCKS = Answers.RETURNS_MOCKS;
public static final Answer<Object> RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS;
public static final Answer<Object> CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;
public static <T> T mock(Class<T> classToMock) {
return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
public static <T> T mock(Class<T> classToMock, String name) {
return mock(classToMock, withSettings()
.name(name)
.defaultAnswer(RETURNS_DEFAULTS));
public static MockingDetails mockingDetails(Object toInspect) {
return MOCKITO_CORE.mockingDetails(toInspect);
public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
return MOCKITO_CORE.mock(classToMock, mockSettings);
public static <T> T spy(T object) {
return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
.spiedInstance(object)
.defaultAnswer(CALLS_REAL_METHODS));
public static <T> T spy(Class<T> classToSpy) {
return MOCKITO_CORE.mock(classToSpy, withSettings()
.useConstructor()
.defaultAnswer(CALLS_REAL_METHODS));
public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {
return MOCKITO_CORE.stub(methodCall);
public static <T> OngoingStubbing<T> when(T methodCall) {
return MOCKITO_CORE.when(methodCall);
public static <T> T verify(T mock) {
return MOCKITO_CORE.verify(mock, times(1));
public static <T> T verify(T mock, VerificationMode mode) {
return MOCKITO_CORE.verify(mock, mode);
public static <T> void reset(T ... mocks) {
MOCKITO_CORE.reset(mocks);
public static void verifyNoMoreInteractions(Object... mocks) {
MOCKITO_CORE.verifyNoMoreInteractions(mocks);
public static void verifyZeroInteractions(Object... mocks) {
MOCKITO_CORE.verifyNoMoreInteractions(mocks);
public static <T> VoidMethodStubbable<T> stubVoid(T mock) {
return MOCKITO_CORE.stubVoid(mock);
public static Stubber doThrow(Throwable toBeThrown) {
return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));
public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {
return MOCKITO_CORE.doAnswer(new ThrowsExceptionClass(toBeThrown));
public static Stubber doCallRealMethod() {
return MOCKITO_CORE.doAnswer(new CallsRealMethods());
public static Stubber doAnswer(Answer answer) {
return MOCKITO_CORE.doAnswer(answer);
public static Stubber doNothing() {
return MOCKITO_CORE.doAnswer(new DoesNothing());
public static Stubber doReturn(Object toBeReturned) {
return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));
public static InOrder inOrder(Object... mocks) {
return MOCKITO_CORE.inOrder(mocks);
public static Object[] ignoreStubs(Object... mocks) {
return MOCKITO_CORE.ignoreStubs(mocks);
public static VerificationMode times(int wantedNumberOfInvocations) {
return VerificationModeFactory.times(wantedNumberOfInvocations);
public static VerificationMode never() {
return times(0);
public static VerificationMode atLeastOnce() {
return VerificationModeFactory.atLeastOnce();
public static VerificationMode atLeast(int minNumberOfInvocations) {
return VerificationModeFactory.atLeast(minNumberOfInvocations);
public static VerificationMode atMost(int maxNumberOfInvocations) {
return VerificationModeFactory.atMost(maxNumberOfInvocations);
public static VerificationMode calls( int wantedNumberOfInvocations ){
return VerificationModeFactory.calls( wantedNumberOfInvocations );
public static VerificationMode only() {
return VerificationModeFactory.only();
public static VerificationWithTimeout timeout(long millis) {
return new Timeout(millis, VerificationModeFactory.times(1));
public static VerificationAfterDelay after(int millis) {
return new After(millis, VerificationModeFactory.times(1));
public static void validateMockitoUsage() {
MOCKITO_CORE.validateMockitoUsage();
public static MockSettings withSettings() {
return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);
static MockitoDebugger debug() {
return new MockitoDebuggerImpl();
mockSettings.defaultAnswer(annotation.answer());
package org.mockito.internal.stubbing.answers;
import static org.mockito.Answers.RETURNS_DEFAULTS;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import java.io.Serializable;
import java.lang.reflect.Modifier;
public class CallsRealMethods implements Answer<Object>, Serializable {
private static final long serialVersionUID = 9057165148930624087L;
public Object answer(InvocationOnMock invocation) throws Throwable {
if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
return RETURNS_DEFAULTS.answer(invocation);
return invocation.callRealMethod();
for (TypeVariable typeVariable : typeParameters) {
registerTypeVariableIfNotPresent(typeVariable);
public void shouldAnyPrimiteWraperMatchersAcceptNull() {for (TypeVariable typeVariable : typeParameters) {
registerTypeVariableIfNotPresent(typeVariable);package org.mockito.release.exec;
package org.mockito.release.exec;
package org.mockito.release.exec;
package org.mockito.release.git;
import org.mockito.release.exec.ProcessRunner;
class DefaultGitAuthor implements GitAuthor {
final String previousUser;
final String previousEmail;
private final ProcessRunner runner;
DefaultGitAuthor(String previousUser, String previousEmail, ProcessRunner runner) {
this.previousUser = previousUser;
this.previousEmail = previousEmail;
this.runner = runner;
public void restoreOriginal() {
if (!previousUser.isEmpty()) {
runner.run("git", "config", "--local", "user.name", previousUser);
runner.run("git", "config", "--local", "--unset", "user.name");
if (!previousEmail.isEmpty()) {
runner.run("git", "config", "--local", "user.email", previousEmail);
runner.run("git", "config", "--local", "--unset", "user.email");
package org.mockito.release.git;
import org.mockito.release.exec.ProcessRunner;
class DefaultGitTool implements GitTool {
private final ProcessRunner runner;
public DefaultGitTool(ProcessRunner runner) {
this.runner = runner;
public DefaultGitAuthor setAuthor(String name, String email) {
String currentLocalUser = runner.run("git", "config", "--local", "user.name").trim();
String currentLocalEmail = runner.run("git", "config", "--local", "user.email").trim();
runner.run("git", "config", "user.name", name);
runner.run("git", "config", "user.email", email);
return new DefaultGitAuthor(currentLocalUser, currentLocalEmail, runner);
package org.mockito.release.git;
import org.mockito.release.exec.ProcessRunner;
public class Git {
public static GitTool gitTool(ProcessRunner runner) {
return new DefaultGitTool(runner);
package org.mockito.release.git;
public interface GitAuthor {
void restoreOriginal();
package org.mockito.release.git;
public interface GitTool {
GitAuthor setAuthor(String name, String email);
import org.mockito.release.exec.Exec;
import org.mockito.release.exec.ProcessRunner;
import org.mockito.release.exec.ProcessRunner;
package org.mockito.release.steps;
import groovy.lang.Closure;
public interface ConfigurableReleaseStep extends ReleaseStep {
void rollback(Closure closure);
void cleanup(Closure closure);
class DefaultReleaseStep implements ConfigurableReleaseStep {
private final String description;
private final Operation operation;
private Operation rollback;
private Operation cleanup;
public DefaultReleaseStep(String description, Operation operation) {
this.description = description;
this.operation = operation;
public String getDescription() {
return description;
public void performRollback() {
if (rollback != null) {
rollback.perform();
cleanup.perform();
System.out.println("No rollback or cleanup operation found for step '" + description + "'");
public void performCleanup() {
if (cleanup != null) {
System.out.println("Cleaning up after step '" + getDescription() + "'");
cleanup.perform();
System.out.println("No cleanup found for step '" + getDescription() + "'");
public void rollback(Closure closure) {
rollback = Operations.toOperation(closure);
public void cleanup(Closure closure) {
this.cleanup = Operations.toOperation(closure);
public void perform() {
operation.perform();
public ConfigurableReleaseStep newStep(String description, Operation operation) {
public ReleaseStep getStep(int stepNumber) {
return steps.get(stepNumber - 1); //TODO SF array index
public void performRollback() {
rollback(steps);
public void perform() {
LinkedList<ReleaseStep> attempted = new LinkedList<ReleaseStep>();
while(!attempted.isEmpty()) {
ReleaseStep step = attempted.removeLast();
step.performCleanup();
System.out.println("Attempting to roll back step " + (targets.size() + 1) + " (" + s.getDescription() + ")");
s.performRollback();
String getDescription();
void performRollback();
void performCleanup();
ConfigurableReleaseStep newStep(String description, Operation operation);
ReleaseStep getStep(int stepNumber);
void performRollback();
import org.mockito.junit.*;
throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
class FriendlyExceptionMaker {
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
if (!detecter.hasJUnit()) {
return new ArgumentsAreDifferent(message);
try {
Class<?> clazz = Class.forName("org.mockito.exceptions.verification.junit.ArgumentsAreDifferent");
AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);
return throwable;
return new ArgumentsAreDifferent(message);
package org.mockito.internal.junit;
class JUnitDetecter {
private boolean hasJUnit;
JUnitDetecter() {
try {
Class.forName("junit.framework.ComparisonFailure");
hasJUnit = true;
hasJUnit = false;
public boolean hasJUnit() {
return hasJUnit;
package org.mockito.internal.junit;
public Statement apply(final Statement base, final Object target) {
MockitoAnnotations.initMocks(target);
private static JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
for (TypeVariable typeVariable : typeParameters) {
registerTypeVariableIfNotPresent(typeVariable);
package org.mockito.junit;
public class MockitoJUnit {
public static MockitoRule rule() {
return new MockitoJUnitRule();
import org.junit.rules.MethodRule;
import org.junit.runners.model.FrameworkMethod;
import org.mockito.internal.junit.JUnitRule;
public class MockitoJUnitRule implements MethodRule, MockitoRule {
public MockitoJUnitRule() {
this.jUnitRule = new JUnitRule();
public MockitoJUnitRule(Object targetTest) {
this();
public Statement apply(Statement base, FrameworkMethod method, Object target) {
return jUnitRule.apply(base, target);
package org.mockito.junit;
import org.junit.rules.MethodRule;
public interface MockitoRule extends MethodRule {}
package org.mockito.internal.junit;
import org.junit.Test;
import org.junit.runners.model.Statement;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.internal.junit.JUnitRule;
import static org.junit.Assert.*;
public class JUnitRuleTest {
private JUnitRule jUnitRule = new JUnitRule();
private InjectTestCase injectTestCase = new InjectTestCase();
public void shouldInjectIntoTestCase() throws Throwable {
jUnitRule.apply(new DummyStatement(), injectTestCase).evaluate();
assertNotNull("@Mock mock object created", injectTestCase.getInjected());
assertNotNull("@InjectMocks object created", injectTestCase.getInjectInto());
assertNotNull("Mock injected into the object", injectTestCase.getInjectInto().getInjected());
public void shouldRethrowException() throws Throwable {
try {
jUnitRule.apply(new ExceptionStatement(), injectTestCase).evaluate();
fail("Should throw exception");
assertEquals("Correct message", "Statement exception", e.getMessage());
public void shouldDetectUnfinishedStubbing() throws Throwable {
try {
jUnitRule.apply(new UnfinishedStubbingStatement(), injectTestCase).evaluate();
fail("Should detect invalid Mockito usage");
private static class DummyStatement extends Statement {
public void evaluate() throws Throwable {
private static class ExceptionStatement extends Statement {
public void evaluate() throws Throwable {
throw new RuntimeException("Statement exception");
private static class UnfinishedStubbingStatement extends Statement {
public void evaluate() throws Throwable {
InjectTestCase injectTestCase = new InjectTestCase();
MockitoAnnotations.initMocks(injectTestCase);
injectTestCase.unfinishedStubbingThrowsException();
public static class InjectTestCase {
private Injected injected;
private InjectInto injectInto;
public void dummy() throws Exception {
public void unfinishedStubbingThrowsException() throws Exception {
Mockito.when(injected.stringMethod());
public Injected getInjected() {
return injected;
public InjectInto getInjectInto() {
return injectInto;
public static class Injected {
public String stringMethod() {
return "string";
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
interface GenericsSelfReference<T extends GenericsSelfReference<T>> {
T self();
public void typeVariable_of_self_type() {
GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod("self", GenericsSelfReference.class));
assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertNotNull;
import static org.mockitousage.junitrule.MockitoJUnitRuleTest.InjectInto;
import static org.mockitousage.junitrule.MockitoJUnitRuleTest.Injected;
public class InvalidTargetMockitoJUnitRuleTest {
public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule("asdf");
private Injected injected;
private InjectInto injectInto;
public void shouldInjectWithInvalidReference() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Test object created", injectInto);
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class MockitoJUnitRuleTest {
public MockitoRule mockitoRule = MockitoJUnit.rule();
private Injected injected;
private InjectInto injectInto;
public void testInjectMocks() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Object created", injectInto);
assertEquals("A injected into B", injected, injectInto.getInjected());
public static class Injected {
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.MethodRule;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class RuleTestWithFactoryMethodTest {
public MockitoRule mockitoRule = MockitoJUnit.rule();
private Injected injected;
private InjectInto injectInto;
public void testInjectMocks() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Object created", injectInto);
assertEquals("A injected into B", injected, injectInto.getInjected());
public static class Injected {
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
package org.mockitousage.junitrule;
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class RuleTestWithParameterConstructorTest {
public static class Injected {
public static class InjectInto {import org.mockito.junit.*;
throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);
package org.mockito.internal.junit;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
class FriendlyExceptionMaker {
private final JUnitDetecter detecter;
FriendlyExceptionMaker(JUnitDetecter detecter) {
this.detecter = detecter;
public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {
if (!detecter.hasJUnit()) {
return new ArgumentsAreDifferent(message);
try {
Class<?> clazz = Class.forName("org.mockito.exceptions.verification.junit.ArgumentsAreDifferent");
AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);
return throwable;
return new ArgumentsAreDifferent(message);
package org.mockito.internal.junit;
class JUnitDetecter {
private boolean hasJUnit;
JUnitDetecter() {
try {
Class.forName("junit.framework.ComparisonFailure");
hasJUnit = true;
hasJUnit = false;
public boolean hasJUnit() {
return hasJUnit;
package org.mockito.internal.junit;
public Statement apply(final Statement base, final Object target) {
MockitoAnnotations.initMocks(target);
private static JUnitDetecter detecter = new JUnitDetecter();
return detecter.hasJUnit();
return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);
protected void registerTypeParametersOn(TypeVariable[] typeParameters) {
for (TypeVariable typeVariable : typeParameters) {
registerTypeVariableIfNotPresent(typeVariable);
registerTypeParametersOn(typeParameters);
package org.mockito.junit;
public class MockitoJUnit {
public static MockitoRule rule() {
return new MockitoJUnitRule();
import org.junit.rules.MethodRule;
import org.junit.runners.model.FrameworkMethod;
import org.mockito.internal.junit.JUnitRule;
public class MockitoJUnitRule implements MethodRule, MockitoRule {
public MockitoJUnitRule() {
this.jUnitRule = new JUnitRule();
public MockitoJUnitRule(Object targetTest) {
this();
public Statement apply(Statement base, FrameworkMethod method, Object target) {
return jUnitRule.apply(base, target);
package org.mockito.junit;
import org.junit.rules.MethodRule;
public interface MockitoRule extends MethodRule {}
package org.mockito.internal.junit;
import org.junit.Test;
import org.junit.runners.model.Statement;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.internal.junit.JUnitRule;
import static org.junit.Assert.*;
public class JUnitRuleTest {
private JUnitRule jUnitRule = new JUnitRule();
private InjectTestCase injectTestCase = new InjectTestCase();
public void shouldInjectIntoTestCase() throws Throwable {
jUnitRule.apply(new DummyStatement(), injectTestCase).evaluate();
assertNotNull("@Mock mock object created", injectTestCase.getInjected());
assertNotNull("@InjectMocks object created", injectTestCase.getInjectInto());
assertNotNull("Mock injected into the object", injectTestCase.getInjectInto().getInjected());
public void shouldRethrowException() throws Throwable {
try {
jUnitRule.apply(new ExceptionStatement(), injectTestCase).evaluate();
fail("Should throw exception");
assertEquals("Correct message", "Statement exception", e.getMessage());
public void shouldDetectUnfinishedStubbing() throws Throwable {
try {
jUnitRule.apply(new UnfinishedStubbingStatement(), injectTestCase).evaluate();
fail("Should detect invalid Mockito usage");
private static class DummyStatement extends Statement {
public void evaluate() throws Throwable {
private static class ExceptionStatement extends Statement {
public void evaluate() throws Throwable {
throw new RuntimeException("Statement exception");
private static class UnfinishedStubbingStatement extends Statement {
public void evaluate() throws Throwable {
InjectTestCase injectTestCase = new InjectTestCase();
MockitoAnnotations.initMocks(injectTestCase);
injectTestCase.unfinishedStubbingThrowsException();
public static class InjectTestCase {
private Injected injected;
private InjectInto injectInto;
public void dummy() throws Exception {
public void unfinishedStubbingThrowsException() throws Exception {
Mockito.when(injected.stringMethod());
public Injected getInjected() {
return injected;
public InjectInto getInjectInto() {
return injectInto;
public static class Injected {
public String stringMethod() {
return "string";
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertNotNull;
import static org.mockitousage.junitrule.MockitoJUnitRuleTest.InjectInto;
import static org.mockitousage.junitrule.MockitoJUnitRuleTest.Injected;
public class InvalidTargetMockitoJUnitRuleTest {
public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule("asdf");
private Injected injected;
private InjectInto injectInto;
public void shouldInjectWithInvalidReference() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Test object created", injectInto);
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class MockitoJUnitRuleTest {
public MockitoRule mockitoRule = MockitoJUnit.rule();
private Injected injected;
private InjectInto injectInto;
public void testInjectMocks() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Object created", injectInto);
assertEquals("A injected into B", injected, injectInto.getInjected());
public static class Injected {
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
package org.mockitousage.junitrule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.MethodRule;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class RuleTestWithFactoryMethodTest {
public MockitoRule mockitoRule = MockitoJUnit.rule();
private Injected injected;
private InjectInto injectInto;
public void testInjectMocks() throws Exception {
assertNotNull("Mock created", injected);
assertNotNull("Object created", injectInto);
assertEquals("A injected into B", injected, injectInto.getInjected());
public static class Injected {
public static class InjectInto {
private Injected injected;
public Injected getInjected() {
return injected;
package org.mockitousage.junitrule;
import org.mockito.junit.MockitoJUnitRule;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
public class RuleTestWithParameterConstructorTest {
public static class Injected {
public static class InjectInto {import org.junit.runner.Description;
private Object object;
public JUnitRule(Object object) {
this.object = object;
public Statement apply(final Statement base, Description description) {
MockitoAnnotations.initMocks(object);
package org.mockito.internal.rules;
public class JunitRuleImpl {
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import static org.mockito.internal.util.Checks.checkNotNull;
public class MockitoJUnitRule implements TestRule {
checkNotNull(targetTest, "Mockito JUnit rule target");
this.jUnitRule = new JUnitRule(targetTest);
public Statement apply(final Statement base, Description description) {
return jUnitRule.apply(base, description);
private static class Injected {
private static class InjectInto {
import org.junit.Assert;
import org.junit.runner.Description;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
jUnitRule = new JUnitRule(injectTestCase);
jUnitRule.apply(new DummyStatement(), Description.EMPTY).evaluate();
assertNotNull("", injectTestCase.getInjected());
assertNotNull("", injectTestCase.getInjectInto());
jUnitRule.apply(new ExceptionStatement(), Description.EMPTY).evaluate();
jUnitRule.apply(new UnfinishedStubbingStatement(), Description.EMPTY).evaluate();
fail("Should detect unvalid Mockito usage");
public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);
public void testThrowExceptionWhenNullTarget() throws Exception {
try {
new MockitoJUnitRule(null);
fail();
assertEquals("valid message", "Mockito JUnit rule target should not be null", e.getMessage());
private static class Injected {
private static class InjectInto {import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.internal.util.collections.ListUtil;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;
import org.mockito.Incubating;LinkedList<ReleaseStep> targets = new LinkedList<ReleaseStep>();public class ClassPathLoaderTest {return isMockitoMock(mock) &&
(getMockSettings(mock).getSpiedInstance() != null
|| getMockSettings(mock).isUsingConstructor());
assertFalse(mockUtil.isSpy((Class) null));
public void shouldKnowIfTypeIsMockable() throws Exception {import org.mockito.*;
import org.mockito.configuration.AnnotationEngine;
import org.mockito.exceptions.Reporter;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.reflection.FieldInitializationReport;
import org.mockito.internal.util.reflection.FieldInitializer;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import static org.mockito.Mockito.withSettings;
assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();
instance = report.fieldInstance();
new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);
try {
field.setAccessible(true);
return isMockitoMock(mock) && getMockSettings(mock).getSpiedInstance() != null;
private static class CustomListener implements InvocationListener {
public void shouldFailIfTypeIsAnInterface() throws Exception {
class FailingSpy {
try {
MockitoAnnotations.initMocks(new FailingSpy());
fail();
Assertions.assertThat(e.getMessage()).contains("an interface");
Assertions.assertThat(e.getMessage()).contains("default constructor");
Assertions.assertThat(e.getMessage()).contains("raised an exception");
public void shouldFailIfTypeIsAbstract() throws Exception {
class FailingSpy {
try {
MockitoAnnotations.initMocks(new FailingSpy());
fail();
Assertions.assertThat(e.getMessage()).contains("abstract class");
public void shouldFailIfTypeIsInnerClass() throws Exception {
class FailingSpy {
class TheInnerClass { }
try {
MockitoAnnotations.initMocks(new FailingSpy());
fail();
Assertions.assertThat(e.getMessage()).contains("inner class");
private static class TestClass{return Answers.CALLS_REAL_METHODS.get().answer(invocation);import java.io.Serializable;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
public Object answer(InvocationOnMock invocation) throws Throwable {
import org.junit.Ignore;return null;
private final Collection<String> tickets = new LinkedList<String>();import org.mockito.release.notes.vcs.Commit;
import java.util.*;
import java.util.regex.Pattern;
LOGGER.info("Parsing {} commits", contributions.getAllCommits());
Set<String> ticketIds = findTickets(contributions);
new GitHubTicketFetcher().fetchTickets(authToken.getToken(), ticketIds, out);
private Set<String> findTickets(ContributionSet contributions) {
Set<String> tickets = new LinkedHashSet<String>();
for (Commit commit : contributions.getAllCommits()) {
Scanner scanner = new Scanner(commit.getMessage());
Pattern ticket = Pattern.compile("#\\d+");
while(scanner.hasNext(ticket)) {
String ticketId = scanner.next(ticket).substring(1); //remove leading '#'
tickets.add(ticketId);
return tickets;import org.mockito.release.notes.versions.PreviousVersionFromFile;
import java.io.File;
public static PreviousVersion previousVersion(File releaseNotesFile) {
return new PreviousVersionFromFile(releaseNotesFile);
import java.io.File;
PreviousVersion previousFromNotesFile(File releaseNotesFile) {
return new PreviousVersionFromFile(releaseNotesFile);return withOuterClass(cls);
private <T> T withOuterClass(Class<T> cls) {
Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());
return c.newInstance(outerClassInstance);
throw new InstantationException("Unable to create mock instance of '"
+ cls.getSimpleName() + "'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.", e);
private <T> T noArgConstructor(Class<T> cls) {return new ConstructorInstantiator();
imposterizer = new ClassImposterizer(new ConstructorInstantiator());
String message = "hey!";import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
private static final long serialVersionUID = -8343690268123254910L;
private Object delegatedObject = null ;
public ForwardsInvocations(Object delegatedObject) {
this.delegatedObject = delegatedObject ;
public Object answer(InvocationOnMock invocation) throws Throwable {
Method method = invocation.getMethod() ;
return method.invoke(delegatedObject, invocation.getArguments());private static final long serialVersionUID = 7434976328690189159L;
public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();if (!poms) {
getLogger().lifecycle("{} - pom files are not equal", getPath());
if (!jars) {
getLogger().lifecycle("{} - source jars are not equal", getPath());import org.mockito.release.notes.internal.ChangeSetSegregator;
private String headerForOtherChanges;
ChangeSetSegregator segregator = new ChangeSetSegregator(labelsToShowSeparately, labelsToIgnore);
ImprovementsPrinter improvementsPrinter = new ImprovementsPrinter(segregator, labelToHeaderMapping, headerForOtherChanges);
ReleaseNotesBuilderFactory headerForOtherChanges(String headerForOtherChanges) {
this.headerForOtherChanges = headerForOtherChanges;"org.mockito.internal.creation.CglibMockMaker";
package org.mockito.internal.creation;
public abstract class AbstractMockitoMethodProxy implements MockitoMethodProxy {
public Object invokeSuper(Object target, Object[] arguments) throws Throwable {
return getMethodProxy().invokeSuper(target, arguments);
package org.mockito.internal.creation;
import org.mockito.internal.creation.jmock.ClassImposterizer;
public class AcrossJVMSerializationFeature implements Serializable {
ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);
Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(
package org.mockito.internal.creation;
import org.mockito.internal.creation.jmock.ClassImposterizer;
return ClassImposterizer.INSTANCE.imposterise(
package org.mockito.internal.creation;
import org.mockito.cglib.proxy.MethodProxy;
public class DelegatingMockitoMethodProxy extends AbstractMockitoMethodProxy {
private final MethodProxy methodProxy;
public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {
this.methodProxy = methodProxy;
public MethodProxy getMethodProxy() {
return methodProxy;
package org.mockito.internal.creation;
import org.mockito.internal.creation.cglib.CGLIBHacker;
import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;
public class MethodInterceptorFilter implements MethodInterceptor, Serializable {
CGLIBHacker cglibHacker = new CGLIBHacker();
cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);
FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);
return new DelegatingMethod(method); 
package org.mockito.internal.creation;
import org.mockito.cglib.proxy.MethodProxy;
public interface MockitoMethodProxy {
Object invokeSuper(Object target, Object[] arguments) throws Throwable;
MethodProxy getMethodProxy();
package org.mockito.internal.creation;
import java.io.Serializable;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.util.reflection.Whitebox;
public class SerializableMockitoMethodProxy extends AbstractMockitoMethodProxy implements Serializable {
private static final long serialVersionUID = -5337859962876770632L;
private final Class<?> c1;
private final Class<?> c2;
private final String desc;
private final String name;
private final String superName;
private transient MethodProxy methodProxy;
public SerializableMockitoMethodProxy(MethodProxy methodProxy) {
Object info = Whitebox.getInternalState(methodProxy, "createInfo");
c1 = (Class<?>) Whitebox.getInternalState(info, "c1");
c2 = (Class<?>) Whitebox.getInternalState(info, "c2");
desc = methodProxy.getSignature().getDescriptor();
name = methodProxy.getSignature().getName();
superName = methodProxy.getSuperName();
this.methodProxy = methodProxy;
public MethodProxy getMethodProxy() {
if (methodProxy == null)
methodProxy = MethodProxy.create(c1, c2, desc, name, superName);
return methodProxy;
import org.mockito.internal.creation.MockitoMethodProxy;
import org.mockito.cglib.proxy.MethodProxy;
public class CGLIBHacker implements Serializable {
private static final long serialVersionUID = -4389233991416356668L;
public void setMockitoNamingPolicy(MockitoMethodProxy mockitoMethodProxy) {
MethodProxy methodProxy = mockitoMethodProxy.getMethodProxy();
public class MockitoNamingPolicy extends DefaultNamingPolicy {
package org.mockito.internal.creation.jmock;
import org.mockito.cglib.core.CodeGenerationException;
import org.mockito.cglib.core.NamingPolicy;
import org.mockito.cglib.core.Predicate;
import org.mockito.cglib.proxy.*;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.configuration.GlobalConfiguration;
import org.mockito.internal.creation.cglib.MockitoNamingPolicy;
import org.objenesis.ObjenesisStd;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.List;
import static org.mockito.internal.util.StringJoiner.join;
public class ClassImposterizer  {
public static final ClassImposterizer INSTANCE = new ClassImposterizer();
private ClassImposterizer() {}
private final ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());
private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {
public String getClassName(String prefix, String source, Object key, Predicate names) {
return "codegen." + super.getClassName(prefix, source, key, names);
private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {
public int accept(Method method) {
return method.isBridge() ? 1 : 0;
public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {
return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));
public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {
Class<?> proxyClass = null;
Object proxyInstance = null;
try {
setConstructorsAccessible(mockedType, true);
proxyClass = createProxyClass(mockedType, ancillaryTypes);
proxyInstance = createProxy(proxyClass, interceptor);
return mockedType.cast(proxyInstance);
throw new MockitoException(join(
"ClassCastException occurred while creating the mockito proxy :",
"  class to imposterize : '" + mockedType.getCanonicalName() + "', loaded by classloader : '" + mockedType.getClassLoader() + "'",
"  imposterizing class : '" + proxyClass.getCanonicalName() + "', loaded by classloader : '" + proxyClass.getClassLoader() + "'",
"  proxy instance class : '" + proxyInstance.getClass().getCanonicalName() + "', loaded by classloader : '" + proxyInstance.getClass().getClassLoader() + "'",
"",
"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)"
), cce);
setConstructorsAccessible(mockedType, false);
public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {
for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {
constructor.setAccessible(accessible);
public Class<?> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {
if (mockedType == Object.class) {
mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;
Enhancer enhancer = new Enhancer() {
protected void filterConstructors(Class sc, List constructors) {
Class<?>[] allMockedTypes = prepend(mockedType, interfaces);
enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));
enhancer.setUseFactory(true);
if (mockedType.isInterface()) {
enhancer.setSuperclass(Object.class);
enhancer.setInterfaces(allMockedTypes);
enhancer.setSuperclass(mockedType);
enhancer.setInterfaces(interfaces);
enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});
enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);
if (mockedType.getSigners() != null) {
enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);
enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);
enhancer.setSerialVersionUID(42L);
try {
return enhancer.createClass(); 
if (Modifier.isPrivate(mockedType.getModifiers())) {
throw new MockitoException("\n"
+ "Mockito cannot mock this class: " + mockedType 
+ ".\n"
+ "Most likely it is a private class that is not visible by Mockito");
throw new MockitoException("\n"
+ "Mockito cannot mock this class: " + mockedType 
+ "\n" 
+ "Mockito can only mock visible & non-final classes."
+ "\n" 
+ "If you're not sure why you're getting this error, please report to the mailing list.", e);
private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {
Factory proxy = (Factory) objenesis.newInstance(proxyClass);
proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });
return proxy;
private Class<?>[] prepend(Class<?> first, Class<?>... rest) {
Class<?>[] all = new Class<?>[rest.length+1];
all[0] = first;
System.arraycopy(rest, 0, all, 1, rest.length);
return all;
public static class ClassWithSuperclassToWorkAroundCglibBug {}
package org.mockito.internal.creation.jmock;
import static java.lang.Thread.*;
import java.util.ArrayList;
import java.util.List;
public class SearchingClassLoader extends ClassLoader {
private final ClassLoader nextToSearch;
public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {
super(parent);
this.nextToSearch = nextToSearch;
public static ClassLoader combineLoadersOf(Class<?>... classes) {
return combineLoadersOf(classes[0], classes);
private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {
List<ClassLoader> loaders = new ArrayList<ClassLoader>();
addIfNewElement(loaders, first.getClassLoader());
for (Class<?> c : others) {
addIfNewElement(loaders, c.getClassLoader());
addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());
addIfNewElement(loaders, currentThread().getContextClassLoader());
return combine(loaders);
private static ClassLoader combine(List<ClassLoader> parentLoaders) {
ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);
for (int i = parentLoaders.size()-2; i >= 0; i--) {
loader = new SearchingClassLoader(parentLoaders.get(i), loader);
return loader;
private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {
if (c != null && !loaders.contains(c)) {
loaders.add(c);
protected Class<?> findClass(String name) throws ClassNotFoundException {
if (nextToSearch != null) {
return nextToSearch.loadClass(name);
return super.findClass(name); // will throw ClassNotFoundException
package org.mockito.internal.creation.jmock;
import org.mockito.cglib.proxy.Callback;
import org.mockito.cglib.proxy.NoOp;
import java.io.Serializable;
public class SerializableNoOp implements NoOp, Serializable {
private static final long serialVersionUID = 7434976328690189159L;
public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();
package org.mockito.internal.invocation.realmethod;
import java.io.Serializable;
import org.mockito.internal.creation.MockitoMethodProxy;
public class CGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {
private static final long serialVersionUID = -4596470901191501582L;
private final MockitoMethodProxy methodProxy;
public CGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {
this.methodProxy = methodProxy;
public Object invoke(Object target, Object[] arguments) throws Throwable {
return methodProxy.invokeSuper(target, arguments);
public MockitoMethodProxy getMethodProxy() {
return methodProxy;
package org.mockito.internal.invocation.realmethod;
import org.mockito.internal.creation.MockitoMethodProxy;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import java.io.Serializable;
public class FilteredCGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {
private static final long serialVersionUID = 3596550785818938496L;
private final RealMethod realMethod;
public FilteredCGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {
this(new CGLIBProxyRealMethod(methodProxy));
public FilteredCGLIBProxyRealMethod(RealMethod realMethod) {
this.realMethod = realMethod;
public Object invoke(Object target, Object[] arguments) throws Throwable {
try {
return realMethod.invoke(target, arguments);
new ConditionalStackTraceFilter().filter(t);
throw t;
public MockitoMethodProxy getMethodProxy() {
return ((HasCGLIBMethodProxy) realMethod).getMethodProxy();
package org.mockito.internal.invocation.realmethod;
import java.io.Serializable;
import org.mockito.internal.creation.MockitoMethodProxy;
public interface HasCGLIBMethodProxy extends Serializable {
MockitoMethodProxy getMethodProxy();
import static org.mockito.Mockito.withSettings;
import java.io.IOException;
import java.io.Serializable;
InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
return stubbedInvocationMatcher.answer(invocation);
return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);
private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
withSettingsUsing(returnTypeGenericMetadata)
private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
return mockSettings
.serializable()
import org.mockito.internal.creation.jmock.ClassImposterizerTest;
package org.mockito.internal.creation;
import static org.hamcrest.core.IsInstanceOf.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.internal.creation.cglib.CGLIBHacker;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockitousage.MethodsImpl;
import org.mockitoutil.TestBase;
public class MethodInterceptorFilterTest extends TestBase {
InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
public void setUp() {
filter.cglibHacker = Mockito.mock(CGLIBHacker.class);        
public void shouldBeSerializable() throws Exception {
new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));
public void shouldProvideOwnImplementationOfHashCode() throws Throwable {
Object ret = filter.intercept(new MethodsImpl(), MethodsImpl.class.getMethod("hashCode"), new Object[0], null);
assertTrue((Integer) ret != 0);
Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
public void shouldProvideOwnImplementationOfEquals() throws Throwable {
MethodsImpl proxy = new MethodsImpl();
Object ret = filter.intercept(proxy, MethodsImpl.class.getMethod("equals", Object.class), new Object[] {proxy}, null);
assertTrue((Boolean) ret);
Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));
public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));
public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
Method method = new InvocationBuilder().toInvocation().getMethod();
MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
assertThat(mockitoMethod, instanceOf(SerializableMethod.class));
public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock() throws Exception {
MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
Method method = new InvocationBuilder().toInvocation().getMethod();
MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
assertThat(mockitoMethod, instanceOf(DelegatingMethod.class));
package org.mockito.internal.creation;
import org.junit.Test;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockitoutil.TestBase;
import org.powermock.reflect.Whitebox;
public class SerializableMockitoMethodProxyTest extends TestBase {
public void shouldCreateCorrectCreationInfo() throws Exception {
MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "", "", "");
SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
Object info = Whitebox.getInternalState(methodProxy, "createInfo");
assertEquals(String.class, Whitebox.getInternalState(info, "c1"));
assertEquals(Integer.class, Whitebox.getInternalState(info, "c2"));
public void shouldCreateCorrectSignatures() throws Exception {
MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "a", "b", "c");
SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
assertEquals("a", methodProxy.getSignature().getDescriptor());
assertEquals("b", methodProxy.getSignature().getName());
assertEquals("c", methodProxy.getSuperName());
public String toString() {
return "SerializableMockitoMethodProxyTest []";
import static org.mockito.Mockito.spy;
import org.mockito.internal.creation.MockitoMethodProxy;
MockitoMethodProxy methodProxy = new MethodProxyBuilder().build();
Object realMethodProxy = Whitebox.invokeMethod(methodProxy, "getMethodProxy", new Object[0]);
Object createInfo = Whitebox.getInternalState(realMethodProxy, "createInfo");
MockitoMethodProxy proxiedMethodProxy = spy(new MethodProxyBuilder().build());
Object realMethodProxy = Whitebox.invokeMethod(proxiedMethodProxy, "getMethodProxy", new Object[0]);
Object createInfo = Whitebox.getInternalState(realMethodProxy, "createInfo");
package org.mockito.internal.creation.cglib;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import org.mockito.internal.creation.MockitoMethodProxy;
import org.mockito.internal.invocation.ExposedInvocation;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.mockitousage.IMethods;
public class MethodProxyBuilder {
public MockitoMethodProxy build() {
IMethods mock = mock(IMethods.class);
when(mock.objectReturningMethodNoArgs()).thenAnswer(new Answer<Object>() {
public Object answer(InvocationOnMock invocation) throws Throwable {
return invocation;
InvocationImpl i = (InvocationImpl) mock.objectReturningMethodNoArgs();
return new ExposedInvocation(i).getMethodProxy();
package org.mockito.internal.creation.jmock;
import static org.hamcrest.CoreMatchers.*;
import java.lang.reflect.Method;
import org.junit.Test;
import org.mockito.cglib.proxy.Factory;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockitoutil.TestBase;
public class ClassImposterizerTest extends TestBase {
public void shouldCreateMockFromInterface() throws Exception {
SomeInterface proxy = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeInterface.class);
Class superClass = proxy.getClass().getSuperclass();
assertEquals(Object.class, superClass);
public void shouldCreateMockFromClass() throws Exception {
ClassWithoutConstructor proxy = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);
Class superClass = proxy.getClass().getSuperclass();
assertEquals(ClassWithoutConstructor.class, superClass);
public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {
try {
new ClassWithDodgyConstructor();
fail();
ClassWithDodgyConstructor mock = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);
assertNotNull(mock);
public void shouldMocksHaveDifferentInterceptors() throws Exception {
SomeClass mockOne = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class);
SomeClass mockTwo = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class);
Factory cglibFactoryOne = (Factory) mockOne;
Factory cglibFactoryTwo = (Factory) mockTwo;
assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));
public void shouldUseAnicilliaryTypes() {
SomeClass mock = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);
assertThat(mock, is(instanceOf(SomeInterface.class)));
class SomeClass {}
interface SomeInterface {}
private class ClassWithoutConstructor {}
private class ClassWithDodgyConstructor {
public ClassWithDodgyConstructor() {
throw new RuntimeException();
private final class MethodInterceptorStub implements MethodInterceptor {
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
return null;
package org.mockito.internal.invocation;
import org.mockito.internal.creation.MockitoMethodProxy;
import org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy;
public class ExposedInvocation {
private final MockitoMethodProxy methodProxy;
public ExposedInvocation(InvocationImpl toBeExposed) {
methodProxy = ((HasCGLIBMethodProxy) toBeExposed.realMethod).getMethodProxy();
public MockitoMethodProxy getMethodProxy() {
return methodProxy;
.satisfies(thatCceIsThrownFrom("org.mockito.internal.creation.jmock.ClassImposterizer.imposterise"));
package org.mockitousage.internal.invocation.realmethod;
import static org.mockitoutil.ExtraMatchers.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;
import org.mockito.internal.invocation.realmethod.RealMethod;
import org.mockitoutil.TestBase;
public class FilteredCGLIBProxyRealMethodTest extends TestBase {
public void keepStackTracesClean() {
makeStackTracesClean();
class Foo {
public String throwSomething() {
throw new RuntimeException();
public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows() throws Throwable {
FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(new RealMethod() {
public Object invoke(Object target, Object[] arguments) throws Throwable {
return new Foo().throwSomething();
try {
realMethod.invoke(null, null);
fail();
assertThat(e, hasMethodInStackTraceAt(0, "throwSomething"));
assertThat(e, hasMethodInStackTraceAt(1, "invoke"));
assertThat(e, hasMethodInStackTraceAt(2, "shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows"));MethodProxy methodProxy = MethodProxy.create(null, null, null, null, null);
Object realMethodProxy = Whitebox.invokeMethod(methodProxy, "getMethodProxy", new Object[0]);
Object createInfo = Whitebox.getInternalState(realMethodProxy, "createInfo");
MethodProxy proxiedMethodProxy = spy(MethodProxy.create(null, null, null, null, null));
Object realMethodProxy = Whitebox.invokeMethod(proxiedMethodProxy, "getMethodProxy", new Object[0]);
Object createInfo = Whitebox.getInternalState(realMethodProxy, "createInfo");ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);
Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(
import org.mockito.internal.creation.instance.InstanceFactory;
import org.mockito.internal.creation.instance.ObjenesisInstanceFactory;
private final static InstanceFactory INSTANCE_FACTORY = new ObjenesisInstanceFactory();
return ClassImposterizer.INSTANCE.imposterise(INSTANCE_FACTORY,
public static final ClassImposterizer INSTANCE = new ClassImposterizer();
private ClassImposterizer() {}
public <T> T imposterise(InstanceFactory factory, final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {
return imposterise(factory, interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));
public <T> T imposterise(InstanceFactory factory, final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {
proxyInstance = createProxy(factory, proxyClass, interceptor);
"  class to mock : '" + describeClass(mockedType),
"  created class : '" + describeClass(proxyClass),
"  proxy instance class : '" + describeClass(proxyInstance),
"  instance creation by : '" + factory.getClass().getSimpleName(),
return type == null? "null" : type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
private Object createProxy(InstanceFactory factory, Class<Factory> proxyClass, final MethodInterceptor interceptor) {
Factory proxy = factory.newInstance(proxyClass);
SomeInterface proxy = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), SomeInterface.class);
ClassWithoutConstructor proxy = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), ClassWithoutConstructor.class);
ClassWithDodgyConstructor mock = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), ClassWithDodgyConstructor.class);
SomeClass mockOne = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), SomeClass.class);
SomeClass mockTwo = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), SomeClass.class);
SomeClass mock = ClassImposterizer.INSTANCE.imposterise(new ObjenesisInstanceFactory(), new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);
OtherClass mock = ClassImposterizer.INSTANCE.imposterise(new ConstructorInstanceFactory(), new MethodInterceptorStub(), OtherClass.class);return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);
private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
withSettingsUsing(returnTypeGenericMetadata)
private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
return mockSettings
.serializable()"  class to imposterize : '" + mockedType.getCanonicalName() + "', loaded by classloader : '" + mockedType.getClassLoader() + "'",
"  imposterizing class : '" + proxyClass.getCanonicalName() + "', loaded by classloader : '" + proxyClass.getClassLoader() + "'",
"  proxy instance class : '" + proxyInstance.getClass().getCanonicalName() + "', loaded by classloader : '" + proxyInstance.getClass().getClassLoader() + "'",public MockitoJUnitRule(Object testInstance) {
checkNotNull(testInstance, "mockito JUnit rule test instance");
this.jUnitRule = new JUnitRule(testInstance);
assertEquals("valid message", "Rule target should not be null", e.getMessage());import static org.mockito.internal.reporting.Pluralizer.pluralize;
import static org.mockito.internal.util.StringJoiner.join;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
"3. the parent of the mocked class is not public.",
"   It is a limitation of the mock engine.",
import org.mockito.Mockito;
import static org.mockito.Mockito.mock;
Mockito.when(clazzMock.isValid()).thenReturn(true);
public void report_why_this_exception_happen() throws Exception {
Mockito.when(clazzMock.isValid()).thenReturn(true);
.contains("the parent of the mocked class is not public.")
.contains("It is a limitation of the mock engine");import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;
class Foo {
int blah(String a, String b, Object ... c) {
return 1;
public void leo() throws Exception {
Foo foo = mock(Foo.class);
when(foo.blah(anyString(), anyString())).thenCallRealMethod();
assertEquals(1, foo.blah("foo", "bar"));
import java.io.*;
new StateMaster().validate();while (System.currentTimeMillis() - startTime <= durationMillis) {
import org.mockito.internal.verification.AtLeast;
import org.mockito.internal.verification.Only;
import org.mockito.internal.verification.Times;
import org.mockito.internal.verification.VerificationDataImpl;
Timeout t = new Timeout(10, 50, mode);package org.mockito.internal.creation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import org.mockito.internal.invocation.MockitoMethod;
public class DelegatingMethod implements MockitoMethod {
private final Method method;
public DelegatingMethod(Method method) {
assert method != null : "Method cannot be null";
this.method = method;
public Class<?>[] getExceptionTypes() {
return method.getExceptionTypes();
public Method getJavaMethod() {
return method;
public String getName() {
return method.getName();
public Class<?>[] getParameterTypes() {
return method.getParameterTypes();
public Class<?> getReturnType() {
return method.getReturnType();
public boolean isVarArgs() {
return method.isVarArgs();
public boolean isAbstract() {
return (method.getModifiers() & Modifier.ABSTRACT) != 0;
public int hashCode() {
return 1;
public boolean equals(Object obj) {
return method.equals(obj);package org.mockito.internal.creation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import org.mockito.internal.invocation.MockitoMethod;
public class DelegatingMethod implements MockitoMethod {
private final Method method;
public DelegatingMethod(Method method) {
assert method != null : "Method cannot be null";
this.method = method;
public Class<?>[] getExceptionTypes() {
return method.getExceptionTypes();
public Method getJavaMethod() {
return method;
public String getName() {
return method.getName();
public Class<?>[] getParameterTypes() {
return method.getParameterTypes();
public Class<?> getReturnType() {
return method.getReturnType();
public boolean isVarArgs() {
return method.isVarArgs();
public boolean isAbstract() {
return (method.getModifiers() & Modifier.ABSTRACT) != 0;
public int hashCode() {
return 1;
public boolean equals(Object obj) {
return method.equals(obj);
public boolean hasNext() { return true; }
public E next() { return e; }
public void remove() { }mockSettingsImpl.invocationListeners(null);
when(mixedVarargs.doSomething("hello", null)).thenReturn("hello");
when(mixedVarargs.doSomething("goodbye", null)).thenReturn("goodbye");
String result = mixedVarargs.doSomething("hello", null);
verify(mixedVarargs).doSomething("hello", null);
when(mixedVarargs.doSomething("one", "two", null)).thenReturn("hello");
when(mixedVarargs.doSomething("1", "2", null)).thenReturn("goodbye");
String result = mixedVarargs.doSomething("one", "two", null);
verifyNoMoreInteractions(null);
when(mock.simpleMethod()).thenReturn(null, null);
inOrder(null);
verifyNoMoreInteractions(null);mockSettingsImpl.invocationListeners((InvocationListener[])null);
when(mixedVarargs.doSomething("hello", (String[])null)).thenReturn("hello");
when(mixedVarargs.doSomething("goodbye", (String[])null)).thenReturn("goodbye");
String result = mixedVarargs.doSomething("hello",(String[]) null);
verify(mixedVarargs).doSomething("hello", (String[])null);
when(mixedVarargs.doSomething("one", "two", (String[])null)).thenReturn("hello");
when(mixedVarargs.doSomething("1", "2", (String[])null)).thenReturn("goodbye");
String result = mixedVarargs.doSomething("one", "two", (String[])null);
verifyNoMoreInteractions((Object[])null);
when(mock.simpleMethod()).thenReturn(null, (String[])null);
inOrder((Object[])null);
verifyNoMoreInteractions((Object[])null);try {
Thread.sleep(100);
Thread t = new Thread() { private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnFalse();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnChar();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportAnd().<T>returnNull();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnFalse();
return mockingProgress.getArgumentMatcherStorage().reportOr().<T>returnNull();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnChar();
return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().<T>returnNull();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnChar();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnFalse();
return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();
return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);
private Answer<Object> implementation;
private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();
return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);
private StackTraceElement[] unfilteredStackTrace;
private StackTraceElement[] unfilteredStackTrace;
static final long serialVersionUID = -2860353062105505938L;
private static ThreadLocal<IMockitoConfiguration> globalConfiguration = new ThreadLocal<IMockitoConfiguration>();
return globalConfiguration.get();
if (globalConfiguration.get() == null) {
globalConfiguration.set(createConfig());
return globalConfiguration.get().getReturnValues();
return globalConfiguration.get().getAnnotationEngine();
return globalConfiguration.get().cleansStackTrace();
return globalConfiguration.get().enableClassCache();
return globalConfiguration.get().getDefaultAnswer();
private AnnotationEngine delegate = new DefaultAnnotationEngine();
private AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();
private Set<Field> fields = new HashSet<Field>();
private Set<Object> mocks = newMockSafeHashSet();
private Object fieldOwner;
private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();
private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();
private Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();
private ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {
private MockUtil mockUtil = new MockUtil();
private Lock mutex = new ReentrantLock();
private byte[] serializedMock;
private Class typeToMock;
private Set<Class> extraInterfaces;
private Class typeToMock;
private Set<Class> extraInterfaces;
private MockUtil mockUtil = new MockUtil();
ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();
private AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();
private ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());
private boolean warnAboutUnstubbed;
private AllInvocationsFinder allInvocationsFinder = new AllInvocationsFinder();
private UnusedStubsFinder unusedStubsFinder = new UnusedStubsFinder();
import java.util.List;
private WarningsFinder finder;
static final long serialVersionUID = -8085849703510292641L;
private IMockitoConfiguration config = new GlobalConfiguration();
private StackTraceFilter filter = new StackTraceFilter();
private static StackTraceCleaner cleaner =
if (!cleaner.isOut(unfilteredStackTrace.get(i))) {
private List<InvocationListener> invocationListeners;
private InternalMockHandler<T> mockHandler;
import org.mockito.exceptions.base.MockitoException;
private Class<?> declaringClass;
private String methodName;
private Class<?>[] parameterTypes;
private Class<?> returnType;
private Class<?>[] exceptionTypes;
private boolean isVarArgs;
private boolean isAbstract;
private DescribedInvocation stubbedAt;
import org.mockito.MockSettings;
private List toBeFilled;
private Object returnedValue;
private Throwable throwable;
if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;
if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)
return false;
if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;
return true;
private LinkedList<Object> arguments = new LinkedList<Object>();
String text = quoting();
text+="" + object;
text+= quoting();
return text;
import java.io.Serializable;
import org.hamcrest.*;
private Location location;
private LinkedList<List<T>> arguments = new LinkedList<List<T>>();
if (isEquals == false) {
return this;
isEquals = superEquals;
if (isEquals == false) {
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
return this;
isEquals = (lhs == rhs);
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
if (isEquals == false) {
private Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();
import org.mockito.MockSettings;
if (listener != null && listener instanceof MockingStartedListener) {
import java.io.Serializable;
import org.mockito.MockSettings;
private static ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();
private BlockJUnit4ClassRunner runner;
private InvocationContainerImpl invocationContainerImpl;
private Reporter reporter = new Reporter();
private Method method;
private Class<? extends Throwable> throwableClass;
private Answer<Object> implementation;
private Object mock;
import java.io.Serializable;
private MockitoCore mockitoCore = new MockitoCore();
private Answer<Object> delegate = new ReturnsMoreEmptyValues();
import java.io.Serializable;
import java.lang.reflect.Array;
private Answer<Object> delegate = new ReturnsEmptyValues();
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
import org.mockito.invocation.Invocation;
private Object toInspect;
private MockUtil delegate;
public Collection<Invocation> getInvocations() {
return delegate.getMockHandler(toInspect).getInvocationContainer().getInvocations();
private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();
private static Map<Class<?>, Object> primitiveOrWrapperDefaultValues = new HashMap<Class<?>, Object>();
return (Class<T>) primitiveTypes.get(clazz);
return primitiveOrWrapperDefaultValues.containsKey(type);
return (T) primitiveOrWrapperDefaultValues.get(primitiveOrWrapperType);
primitiveTypes.put(Boolean.class, Boolean.TYPE);
primitiveTypes.put(Character.class, Character.TYPE);
primitiveTypes.put(Byte.class, Byte.TYPE);
primitiveTypes.put(Short.class, Short.TYPE);
primitiveTypes.put(Integer.class, Integer.TYPE);
primitiveTypes.put(Long.class, Long.TYPE);
primitiveTypes.put(Float.class, Float.TYPE);
primitiveTypes.put(Double.class, Double.TYPE);
primitiveOrWrapperDefaultValues.put(Boolean.class, false);
primitiveOrWrapperDefaultValues.put(Character.class, '\u0000');
primitiveOrWrapperDefaultValues.put(Byte.class, (byte) 0);
primitiveOrWrapperDefaultValues.put(Short.class, (short) 0);
primitiveOrWrapperDefaultValues.put(Integer.class, 0);
primitiveOrWrapperDefaultValues.put(Long.class, 0L);
primitiveOrWrapperDefaultValues.put(Float.class, 0F);
primitiveOrWrapperDefaultValues.put(Double.class, 0D);
primitiveOrWrapperDefaultValues.put(boolean.class, false);
primitiveOrWrapperDefaultValues.put(char.class, '\u0000');
primitiveOrWrapperDefaultValues.put(byte.class, (byte) 0);
primitiveOrWrapperDefaultValues.put(short.class, (short) 0);
primitiveOrWrapperDefaultValues.put(int.class, 0);
primitiveOrWrapperDefaultValues.put(long.class, 0L);
primitiveOrWrapperDefaultValues.put(float.class, 0F);
primitiveOrWrapperDefaultValues.put(double.class, 0D);
private Object mockInstance;
private HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();
private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();
private boolean reportNoSetterFound;
private Object fieldInstance;
private boolean wasInitialized;
private boolean wasInitializedUsingConstructorArgs;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.MockUtil;
private Object fieldOwner;
private Field field;
private ConstructorInstantiator instantiator;
private Object testClass;
private Field field;
private Object testClass;
private Field field;
private ConstructorArgumentResolver argResolver;
private final MockUtil mockUtil = new MockUtil();
private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {
if (generic != null && generic instanceof ParameterizedType) {
if (!field.equals(that.field)) return false;
if (!instance.equals(that.instance)) return false;
return true;
import java.util.List;
void assertWantedIsVerifiable() {
ObjectMethodsGuru o = new ObjectMethodsGuru();
<T extends Object> T getArgumentAt(int index, Class<T> clazz);
import java.lang.reflect.InvocationTargetException;
private RunnerImpl runner;
import java.lang.reflect.InvocationTargetException;
private RunnerImpl runner;
private StackTraceFilter filter = new StackTraceFilter();
import java.math.BigDecimal;
public void testGreateThan() {
public void testGreateOrEqual() {
CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(
new BigDecimal("5.00"));MockitoAssertionError error = null;
if (canRecoverFromFailure(delegate)) {
error = e;
sleep(pollingPeriodMillis);
throw e;if (o1 == null || o2 == null) {if (o1 == null || o2 == null) {import static org.mockito.Mockito.*;
private transient MockitoCore mockitoCore;
private transient ReturnsEmptyValues delegate;
instantiateMockitoCoreIfNeeded();
instantiateDelegateIfNeeded();
if (!mockitoCore.isTypeMockable(rawType)) {
return delegate.returnValueFor(rawType);
return getMock(invocation, returnTypeGenericMetadata);
private synchronized void instantiateMockitoCoreIfNeeded() {
if (mockitoCore == null) {
mockitoCore = new MockitoCore();
private synchronized void instantiateDelegateIfNeeded() {
if (delegate == null) {
delegate = new ReturnsEmptyValues();
private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
return mockitoCore.mock(
return new ReturnsDeepStubs() {
protected GenericMetadataSupport actualParameterizedType(Object mock) {
return returnTypeGenericMetadata;
return mock;
abstract class SerializableAnswer implements Answer<Object>, Serializable {
package org.mockitousage.stubbing;
import static org.fest.assertions.Assertions.*;
import static org.mockito.Mockito.*;
import java.io.Serializable;
import java.util.Map;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.Matchers;
import org.mockito.Mockito;
import org.mockitoutil.SimpleSerializationUtil;
public class DeepStubsSerializableTest {
public static final boolean STUBBED_BOOLEAN_VALUE = true;
public static final int STUBBED_INTEGER_VALUE = 999;
public void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {
SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());
when(sampleClass.getSample().isSth()).thenReturn(STUBBED_BOOLEAN_VALUE);
when(sampleClass.getSample().getNumber()).thenReturn(STUBBED_INTEGER_VALUE);
Object o = SimpleSerializationUtil.serializeAndBack(sampleClass);
assertThat(o).isInstanceOf(SampleClass.class);
SampleClass deserializedSample = (SampleClass) o;
assertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_BOOLEAN_VALUE);
assertThat(deserializedSample.getSample().getNumber()).isEqualTo(STUBBED_INTEGER_VALUE);
public void should_serialize_and_deserialize_map_mocked_by_deep_stubs() throws Exception {
Map map = Mockito.mock(Map.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());
Mockito.when(map.entrySet().contains(Matchers.anyString())).thenReturn(STUBBED_BOOLEAN_VALUE);
Object o = SimpleSerializationUtil.serializeAndBack(map);
assertThat(o).isInstanceOf(Map.class);
Map deserializedMap = (Map) o;
assertThat(deserializedMap.entrySet().contains("Something")).isEqualTo(STUBBED_BOOLEAN_VALUE);
class SampleClass implements Serializable {
SampleClass2 getSample() {
return new SampleClass2();
class SampleClass2 implements Serializable {
boolean isSth() {
return false;
int getNumber(){
return 100; .withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1")
cl.loadClass("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1");
assertThat(e.getMessage()).contains("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1");
.withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1")
cl.loadClass("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1");
assertThat(e.getMessage()).contains("org/mockitoutil/IsolatedClassLoaderBuilderTest$Interface1");
public void isolated_class_loader_can_load_all_classes_if_all_prefixes_correct() throws Exception {
.withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1")
.withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1")
Class<?> aClass = cl.loadClass("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1");
.withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1")
.withPrivateCopyOf("org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1")enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));
enhancer.setInterfaces(prepend(mockedType, interfaces));import org.junit.Test;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;
if (method.getName().contains(methodName)) {Timeout t = new Timeout(1, 4, mode);int timeout;
int treshhold;
public VerificationWithTimeoutImpl(int treshhold, int millis, VerificationMode delegate) {
this.treshhold = treshhold;
this.timeout = millis;
int soFar = 0;
while (soFar <= timeout) {
soFar += treshhold;
sleep(treshhold);
return timeout;
return treshhold;
Timeout t = new Timeout(1, 2, mode);
static final int TEST_MILLIS = 1000;
static final int TIMES = TEST_MILLIS / INTERVAL_MILLIS;
public void testInvocationConcurrently() throws Exception {
verify(target, timeout(TEST_MILLIS).times(TIMES*nThreads)).targetMethod("arg");
import org.mockito.Mockito;
import org.mockito.exceptions.base.MockitoException;
import java.util.List;
import static org.mockito.Matchers.anyObject;
public class TimeoutWithAtMostShouldBeDisabledTest extends TestBase {
public void shouldDisableTimeout() {
verify(mock, timeout(30000).atMost(1)).simpleMethod();public void atMostAndNeverShouldNotBeUsedWithTimeout() {
"timeout() should not be used with atMost() or never() because...",
int timeout;
int treshhold;
public VerificationWithTimeoutImpl(int treshhold, int millis, VerificationMode delegate) {
this.treshhold = treshhold;
this.timeout = millis;
int soFar = 0;
MockitoAssertionError error = null;
while (soFar <= timeout) {
soFar += treshhold;
sleep(treshhold);
return timeout;
return treshhold;
new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();
new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();
return null;
static final int TEST_MILLIS = 1000;
static final int TIMES = TEST_MILLIS / INTERVAL_MILLIS;
verify(target, timeout(TEST_MILLIS).times(TIMES*nThreads)).targetMethod("arg");
verify(mock, timeout(50).atLeast(1)).clear();
verify(mock, timeout(50).times(2)).clear();
verify(mock, timeout(50).atLeast(1)).clear();
Thread t1 = waitAndExerciseMock(20);
Thread t1 = waitAndExerciseMock(20);
inOrder.verify(mock, timeout(40)).clear();throw new RuntimeException("Unable to set internal state on a private field. Please report to mockito mailing list.", e);
"You want me to set value to this field: '" + field + private final MockUtil mockUtil = new MockUtil();
"The Java Standard Serialization reported an '" + ioe.getClass().getSimpleName() + "' saying : " + ioe.getMessage()
"Mockito mock cannot be deserialized to a mock of '" + typeToMock.getCanonicalName() + "'.",
"A class couldn't be found while deserializing a Mockito mock, you should check your classpath.",
), e);
Assertions.assertThat(e.getMessage()).contains("no valid constructor");fail();
public class FailingBecauseIncorrectAnnotationUsage {
public class FailingBecauseIncorrectStubbingSyntax {
public class FailingBecauseWrongStubbingSyntaxInConfigurationMethod {
TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectAnnotationUsage.class);
TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectStubbingSyntax.class);
TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseWrongStubbingSyntaxInConfigurationMethod.class);import org.fest.assertions.Assertions;
import java.util.HashSet;
public void constructor_is_called_for_each_test() throws Exception {
int minimum_number_of_test_before = 3;
Assertions.assertThat(articleVisitorInstantiationCount).isGreaterThan(minimum_number_of_test_before);
Assertions.assertThat(articleVisitorMockInjectedInstances.size()).isGreaterThan(minimum_number_of_test_before);
Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");
Assertions.assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);
private static int articleVisitorInstantiationCount = 0;
private static Set<Object> articleVisitorMockInjectedInstances = new HashSet<Object>();
private static class ArticleVisitor {
public ArticleVisitor(ArticleCalculator calculator) {
articleVisitorInstantiationCount++;
articleVisitorMockInjectedInstances.add(calculator);import java.util.*;package org.mockito.internal.stubbing;
import org.junit.Test;
import org.mockito.internal.invocation.InvocationBuilder;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import org.mockito.invocation.Invocation;
import java.util.LinkedList;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
public class InvocationContainerImplTest {
InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());
Invocation invocation = new InvocationBuilder().toInvocation();
LinkedList<Throwable> exceptions = new LinkedList<Throwable>();
public void shouldBeThreadSafe() throws Throwable {
Thread[] t = new Thread[200];
for (int i = 0; i < t.length; i++ ) {
t[i] = new Thread() {
public void run() {
try {
Thread.sleep(10); //NOPMD
throw new RuntimeException(e);
container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));
container.addAnswer(new Returns("foo"));
container.findAnswerFor(invocation);
t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
public void uncaughtException(Thread t, Throwable e) {
exceptions.add(e);
t[i].start();
for (Thread aT : t) {
aT.join();
if (exceptions.size() != 0) {
throw exceptions.getFirst();
public void shouldReturnInvokedMock() throws Exception {
container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));
assertEquals(invocation.getMock(), container.invokedMock());
public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {
container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());
assertTrue(container.hasInvocationForPotentialStubbing());
container.addAnswer(new ReturnsEmptyValues());
assertFalse(container.hasInvocationForPotentialStubbing());import org.mockito.exceptions.misusing.FriendlyReminderException;
import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.SmartNullPointerException;
import org.mockito.exceptions.verification.TooLittleActualInvocations;
import org.mockito.exceptions.verification.TooManyActualInvocations;
import org.mockito.exceptions.verification.VerificationInOrderFailure;
import org.mockito.exceptions.verification.WantedButNotInvoked;
));
));
));
"Argument(s) passed is not a mock!",
"Examples of correct verifications:",
"    verifyNoMoreInteractions(mockOne, mockTwo);",
"    verifyZeroInteractions(mockOne, mockTwo);",
""
));
));
));
));
locationsOf(recordedMatchers),
description.add(matcher.getLocation().toString());
);
sb.append(i.getLocation());
sb.append("\n");
"Verification in order failure",
"Wanted but not invoked:",
wanted.toString(),
new LocationImpl(),
"Wanted anywhere AFTER following interaction:",
previous.toString(),
previous.getLocation(),
""
Location firstUndesired) {
));
Location lastActualInvocation) {
(lastActualInvocation != null)? lastActualInvocation + "\n" : "\n";
String message = join(
wanted.toString(),
"Wanted " + discrepancy.getPluralizedWantedCount() + ":",
new LocationImpl(),
"But was " + discrepancy.getPluralizedActualCount() + ":",
ending
);
return message;
));
));
));
));
));
));
));
));
));
"You haven't provided the instance for spying at field declaration so I tried to construct the instance.",
"However, I failed because: " + details.getMessage(),
"Examples of correct usage of @Spy:",
"   @Spy List mock = new LinkedList();",
"   @Spy Foo foo; //only if Foo has parameterless constructor",
"   //also, don't forget about MockitoAnnotations.initMocks();",
"You haven't provided the instance at field declaration so I tried to construct the instance.",
"However, I failed because: " + details.getMessage(),
"Examples of correct usage of @InjectMocks:",
"   @InjectMocks Service service = new Service();",
"   @InjectMocks Service service;",
"   //also, don't forget about MockitoAnnotations.initMocks();",
"   //and... don't forget about some @Mocks for injection :)",
public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
throw new MockitoException(join(
public void spyAndDelegateAreMutuallyExclusive() {
throw new MockitoException(join(
"Settings should not define a spy instance and a delegated instance at the same time."
)) ;
"The index need to be a positive number that indicates the position of the argument to return.",
"However it is possible to use the -1 value to indicates that the last argument should be",
"returned."));
" -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
"",
(willReturnLastParameter ?
"Last parameter wanted" :
"Wanted parameter at position " + argumentIndex) + " but " + possibleArgumentTypesOf(invocation),
"The index need to be a positive number that indicates a valid position of the argument in the invocation.",
"However it is possible to use the -1 value to indicates that the last argument should be returned.",
""));
public MockSettings verboseLogging() {
return this;
private boolean invocationListenersContainsType(Class<?> clazz) {
for (InvocationListener listener : invocationListeners) {
if (listener.getClass().equals(clazz)) {
return true;
return false;
import org.mockito.internal.creation.MockSettingsImpl;
if (classToMock == null || delegatedInstance == null) {
if (delegatedInstance.getClass().isAssignableFrom(classToMock)) {
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.mockitoutil.TestBase;
public class MockCreationValidatorTest extends TestBase {
public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {
assertContains("You mocked following type: IMethods", e.getMessage());
public void shouldNotAllowsInconsistentTypes() throws Exception {
try {
validator.validateMockedType(List.class, new ArrayList());
fail();
public void shouldAllowOnlyConsistentTypes() throws Exception {
public void shouldValidationBeSafeWhenNullsPassed() throws Exception {
import static org.mockito.Mockito.*;
import java.io.*;
import java.util.*;
public void shouldAllowThrowsExceptionToBeSerializable() throws Exception {
public void shouldAllowMethodDelegation() throws Exception {
public void shouldAllowMockToBeSerializable() throws Exception {
public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {
public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {
public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {
public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {
public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {
public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {
public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization() throws Exception {
public void shouldSerializationWork() throws Exception {
public void shouldStubEvenIfSomeMethodsCalledAfterSerialization() throws Exception {
public void shouldVerifyCallOrderForSerializedMock() throws Exception {
public void shouldRememberInteractionsForSerializedMock() throws Exception {
public void shouldSerializeWithStubbingCallback() throws Exception {
CustomAnswersMustImplementSerializableForSerializationToWork answer = 
new CustomAnswersMustImplementSerializableForSerializationToWork();
class CustomAnswersMustImplementSerializableForSerializationToWork 
implements Answer<Object>, Serializable {
public void shouldSerializeWithRealObjectSpy() throws Exception {
.spiedInstance(list)
.defaultAnswer(CALLS_REAL_METHODS)
.serializable());
public void shouldSerializeObjectMock() throws Exception {
public void shouldSerializeRealPartialMock() throws Exception {
public void shouldSerializeAlreadySerializableClass() throws Exception {
public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {public void defaultAnswerDoesNotAcceptNullParameter() {
throw new MockitoException("defaultAnswer() does not accept null parameter");
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
for (MockMaker mockMaker : loadImplementations(MockMaker.class)) {
return mockMaker; // return the first one service loader finds (if any)
return new CglibMockMaker(); // default implementation
import org.mockito.internal.util.reflection.GenericMetadataSupport;
if (defaultAnswer == null) {
new Reporter().defaultAnswerDoesNotAcceptNullParameter();
public MockSettings parameterizedInfo(GenericMetadataSupport mockitoGenericMetadata) {
this.mockitoGenericMetadata = mockitoGenericMetadata;
return this;
import org.mockito.internal.util.reflection.GenericMetadataSupport;
private static final long serialVersionUID = -6789800638070123629L;
protected GenericMetadataSupport mockitoGenericMetadata;
this.mockitoGenericMetadata = copy.mockitoGenericMetadata;
public GenericMetadataSupport getMockitoGenericMetadata() {
if (mockitoGenericMetadata == null) {
this.mockitoGenericMetadata = GenericMetadataSupport.from(typeToMock);
return mockitoGenericMetadata;
public void setMockitoGenericMetadata(GenericMetadataSupport mockitoGenericMetadata) {
this.mockitoGenericMetadata = mockitoGenericMetadata;
import org.mockito.internal.exceptions.base.StackTraceFilter;
import org.mockito.invocation.Location;
package org.mockito.internal.exceptions.base;
package org.mockito.internal.exceptions.base;
public boolean isBad(StackTraceElement e) {
boolean fromMockObject = e.getClassName().contains("$$EnhancerByMockitoWithCGLIB$$");
boolean fromOrgMockito = e.getClassName().startsWith("org.mockito.");
boolean isRunner = e.getClassName().startsWith("org.mockito.runners.");
boolean isInternalRunner = e.getClassName().startsWith("org.mockito.internal.runners.");
return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;
if (!this.isBad(unfilteredStackTrace.get(i))) {
import org.mockito.internal.creation.MockitoMethodProxy;
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
import java.io.Serializable;
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;
package org.mockito.internal.stubbing.defaultanswers;
import org.mockito.Incubating;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
import org.mockito.internal.util.MockCreationValidator;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.reflection.GenericMetadataSupport;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import java.io.Serializable;
public class ReturnsGenericDeepStubs extends ReturnsDeepStubs implements Answer<Object>, Serializable {
private static final long serialVersionUID = -7105341425736035847L;
private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
public Object answer(InvocationOnMock invocation) throws Throwable {
GenericMetadataSupport returnTypeGenericMetadata =
actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
Class<?> rawType = returnTypeGenericMetadata.rawType();
if (!new MockCreationValidator().isTypeMockable(rawType)) {
return delegate.returnValueFor(rawType);
return getMock(invocation, returnTypeGenericMetadata);
private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
return stubbedInvocationMatcher.answer(invocation);
return recordDeepStubMock(returnTypeGenericMetadata.toMock(this), container);
private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
container.addAnswer(new Answer<Object>() {
public Object answer(InvocationOnMock invocation) throws Throwable {
return mock;
return mock;
private GenericMetadataSupport actualParameterizedType(Object mock) {
CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();
return mockSettings.getMockitoGenericMetadata();
System.out.println(what);
package org.mockito.internal.util.reflection;
import org.mockito.Incubating;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.util.Checks;
import org.mockito.stubbing.Answer;
import java.lang.reflect.*;
import java.util.*;
import static org.mockito.Mockito.withSettings;
public abstract class GenericMetadataSupport {
protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();
protected void registerTypeVariablesOn(Type classType) {
if (!(classType instanceof ParameterizedType)) {
return;
ParameterizedType parameterizedType = (ParameterizedType) classType;
TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
for (int i = 0; i < actualTypeArguments.length; i++) {
TypeVariable typeParameter = typeParameters[i];
Type actualTypeArgument = actualTypeArguments[i];
if (actualTypeArgument instanceof WildcardType) {
contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
protected void registerTypeParametersOn(TypeVariable[] typeParameters) {
for (TypeVariable typeParameter : typeParameters) {
contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));
private BoundedType boundsOf(TypeVariable typeParameter) {
if (typeParameter.getBounds()[0] instanceof TypeVariable) {
return boundsOf((TypeVariable) typeParameter.getBounds()[0]);
return new TypeVarBoundedType(typeParameter);
private BoundedType boundsOf(WildcardType wildCard) {
WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);
if (wildCardBoundedType.firstBound() instanceof TypeVariable) {
return boundsOf((TypeVariable) wildCardBoundedType.firstBound());
return wildCardBoundedType;
public abstract Class<?> rawType();
public List<Type> extraInterfaces() {
return Collections.emptyList();
public Map<TypeVariable, Type> actualTypeArguments() {
TypeVariable[] typeParameters = rawType().getTypeParameters();
LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();
for (TypeVariable typeParameter : typeParameters) {
Type actualType = getActualTypeArgumentFor(typeParameter);
actualTypeArguments.put(typeParameter, actualType);
return actualTypeArguments;
protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {
Type type = this.contextualActualTypeParameters.get(typeParameter);
if (type instanceof TypeVariable) {
TypeVariable typeVariable = (TypeVariable) type;
return getActualTypeArgumentFor(typeVariable);
return type;
public Object toMock(Answer answer) {
return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));
private Object createMock(Class<?> rawType, MockSettings mockSettings) {
return Mockito.mock(rawType, mockSettings);
public GenericMetadataSupport resolveGenericReturnType(Method method) {
Type genericReturnType = method.getGenericReturnType();
if (genericReturnType instanceof Class) {
return new NotGenericReturnTypeSupport(genericReturnType);
if (genericReturnType instanceof ParameterizedType) {
return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());
if (genericReturnType instanceof TypeVariable) {
return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);
throw new MockitoException("Ouch, it shouldn't happen, type '" + genericReturnType.getClass().getCanonicalName() + "' on method : '" + method.toGenericString() + "' is not supported : " + genericReturnType);
public static GenericMetadataSupport from(Type type) {
Checks.checkNotNull(type, "type");
if (type instanceof Class) {
return new FromClassGenericMetadataSupport((Class<?>) type);
if (type instanceof ParameterizedType) {
return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);
throw new MockitoException("Type meta-data for this Type (" + type.getClass().getCanonicalName() + ") is not supported : " + type);
private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {
private Class<?> clazz;
public FromClassGenericMetadataSupport(Class<?> clazz) {
this.clazz = clazz;
readActualTypeParametersOnDeclaringClass();
private void readActualTypeParametersOnDeclaringClass() {
registerTypeParametersOn(clazz.getTypeParameters());
registerTypeVariablesOn(clazz.getGenericSuperclass());
for (Type genericInterface : clazz.getGenericInterfaces()) {
registerTypeVariablesOn(genericInterface);
public Class<?> rawType() {
return clazz;
private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {
private ParameterizedType parameterizedType;
public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {
this.parameterizedType = parameterizedType;
readActualTypeParameters();
private void readActualTypeParameters() {
registerTypeVariablesOn(parameterizedType.getRawType());
registerTypeVariablesOn(parameterizedType);
public Class<?> rawType() {
return (Class<?>) parameterizedType.getRawType();
private static class ParameterizedReturnType extends GenericMetadataSupport {
private final ParameterizedType parameterizedType;
private final TypeVariable[] typeParameters;
public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {
this.parameterizedType = parameterizedType;
this.typeParameters = typeParameters;
this.contextualActualTypeParameters = source.contextualActualTypeParameters;
readTypeParameters();
readTypeVariables();
private void readTypeParameters() {
registerTypeParametersOn(typeParameters);
private void readTypeVariables() {
registerTypeVariablesOn(parameterizedType);
public Class<?> rawType() {
return (Class<?>) parameterizedType.getRawType();
private static class TypeVariableReturnType extends GenericMetadataSupport {
private final TypeVariable typeVariable;
private final TypeVariable[] typeParameters;
private Class<?> rawType;
public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {
this.typeParameters = typeParameters;
this.typeVariable = typeVariable;
this.contextualActualTypeParameters = source.contextualActualTypeParameters;
readTypeParameters();
readTypeVariables();
private void readTypeParameters() {
registerTypeParametersOn(typeParameters);
private void readTypeVariables() {
for (Type type : typeVariable.getBounds()) {
registerTypeVariablesOn(type);
registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
public Class<?> rawType() {
if (rawType == null) {
rawType = extractRawTypeOf(typeVariable);
return rawType;
private Class<?> extractRawTypeOf(Type type) {
if (type instanceof Class) {
return (Class<?>) type;
if (type instanceof ParameterizedType) {
return (Class<?>) ((ParameterizedType) type).getRawType();
if (type instanceof BoundedType) {
return extractRawTypeOf(((BoundedType) type).firstBound());
if (type instanceof TypeVariable) {
return extractRawTypeOf(contextualActualTypeParameters.get(type));
throw new MockitoException("Raw extraction not supported for : '" + type + "'");
public List<Type> extraInterfaces() {
Type type = extractActualBoundedTypeOf(typeVariable);
if (type instanceof BoundedType) {
return Arrays.asList(((BoundedType) type).interfaceBounds());
if (type instanceof ParameterizedType) {
return Collections.singletonList(type);
if (type instanceof Class) {
return Collections.emptyList();
throw new MockitoException("Cannot extract extra-interfaces from '" + typeVariable + "' : '" + type + "'");
private Class<?>[] rawExtraInterfaces() {
List<Type> extraInterfaces = extraInterfaces();
List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();
for (Type extraInterface : extraInterfaces) {
Class<?> rawInterface = extractRawTypeOf(extraInterface);
if(!rawType().equals(rawInterface)) {
rawExtraInterfaces.add(rawInterface);
return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);
private Type extractActualBoundedTypeOf(Type type) {
if (type instanceof TypeVariable) {
If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
on the class definition, such as such as List<E>.
return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));
if (type instanceof BoundedType) {
Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());
if (!(actualFirstBound instanceof BoundedType)) {
return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType
return actualFirstBound;
return type; // irrelevant, we don't manage other types.
public Object toMock(Answer answer) {
Class<?>[] rawExtraInterfaces = rawExtraInterfaces();
if (rawExtraInterfaces.length <= 0) {
return super.toMock(answer);
return super.createMock(
rawType(),
((MockSettingsImpl) withSettings()
.defaultAnswer(answer)
.extraInterfaces(rawExtraInterfaces))
.parameterizedInfo(this)
);
private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {
private final Class<?> returnType;
public NotGenericReturnTypeSupport(Type genericReturnType) {
returnType = (Class<?>) genericReturnType;
public Class<?> rawType() {
return returnType;
public static interface BoundedType extends Type {
Type firstBound();
Type[] interfaceBounds();
public static class TypeVarBoundedType implements BoundedType {
private TypeVariable typeVariable;
public TypeVarBoundedType(TypeVariable typeVariable) {
this.typeVariable = typeVariable;
public Type firstBound() {
return typeVariable.getBounds()[0]; //
public Type[] interfaceBounds() {
Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];
System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);
return interfaceBounds;
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);
public int hashCode() {
return typeVariable.hashCode();
public String toString() {
final StringBuilder sb = new StringBuilder();
sb.append("{firstBound=").append(firstBound());
sb.append(", interfaceBounds=").append(Arrays.deepToString(interfaceBounds()));
sb.append('}');
return sb.toString();
public TypeVariable typeVariable() {
return typeVariable;
public static class WildCardBoundedType implements BoundedType {
private WildcardType wildcard;
public WildCardBoundedType(WildcardType wildcard) {
this.wildcard = wildcard;
public Type firstBound() {
Type[] lowerBounds = wildcard.getLowerBounds();
Type[] upperBounds = wildcard.getUpperBounds();
return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];
public Type[] interfaceBounds() {
return new Type[0];
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
return wildcard.equals(((TypeVarBoundedType) o).typeVariable);
public int hashCode() {
return wildcard.hashCode();
public String toString() {
final StringBuilder sb = new StringBuilder();
sb.append("{firstBound=").append(firstBound());
sb.append(", interfaceBounds=[]}");
return sb.toString();
public WildcardType wildCard() {
return wildcard;
package org.mockito.internal.exceptions.base;
import static org.mockitoutil.ExtraMatchers.*;
package org.mockito.internal.exceptions.base;
import static org.mockitoutil.ExtraMatchers.*;
package org.mockito.internal.stubbing.defaultanswers;
import org.junit.Test;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static org.fest.assertions.Assertions.assertThat;
import static org.mockito.Mockito.mock;
public class ReturnsGenericDeepStubsTest {
interface ListOfInteger extends List<Integer> {}
interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
Set<Number> remove(Object key); // override with fixed ParameterizedType
List<? super Number> returningWildcard();
Map<String, K> returningNonMockableNestedGeneric();
K returningK();
<O extends K> List<O> paramTypeWithTypeParams();
<S extends Appendable, T extends S> T twoTypeParams(S s);
<O extends K> O typeVarWithTypeParams();
Number returnsNormalType();
public void returning_deep_stubs_1() throws Exception {
GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();
Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();
Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();
Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();
Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();
Set<Number> value = mock.entrySet().iterator().next().getValue();
Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();
Number number = mock.entrySet().iterator().next().getValue().iterator().next();
public void returning_deep_stubs_2() throws Exception {
GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
Cloneable cloneable1 = mock.paramTypeWithTypeParams().get(0);
Comparable<?> comparable1 = mock.paramTypeWithTypeParams().get(0);
Cloneable cloneable2 = mock.returningK();
Comparable<?> comparable2 = mock.returningK();
Cloneable cloneable3 = (Cloneable) mock.typeVarWithTypeParams();
public void returning_deep_stubs_3() throws Exception {
GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
List<? super Integer> objects = mock.returningWildcard();
Number n = (Number) mock.returningWildcard().get(45);
n.floatValue();
public void returning_deep_stubs_4() throws Exception {
GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
Number n = mock.returnsNormalType();
n.floatValue();
public void return_default_value_on_non_mockable_nested_generic() throws Exception {
GenericsNest<?> genericsNest = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
ListOfInteger listOfInteger = mock(ListOfInteger.class, new ReturnsGenericDeepStubs());
assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();
assertThat(listOfInteger.get(25)).isEqualTo(0);
public void returning_deep_stub_dont_work_because_StringBuilder_is_subject_to_erasure() throws Exception {
GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
StringBuilder stringBuilder = mock.twoTypeParams(new StringBuilder()).append(2).append(3); // ClassCastException
import org.junit.Test;
import java.lang.reflect.Type;
import java.util.*;
import static org.junit.Assert.assertEquals;
public interface ListSet extends List<Set> {}
public interface MapNumberString extends Map<Number, String> {}
public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}
public List<Number> numberList() { return null; }
public Comparable<Number> numberComparable() { return null; }
public List rawList() { return null; }
public List<? extends Type> typeList() { return null; }
public void should_find_generic_class() throws Exception {
public void should_get_object_for_non_generic() throws Exception {
public void should_deal_with_nested_generics() throws Exception {
package org.mockito.internal.util.reflection;
import org.junit.Test;
import org.mockito.exceptions.base.MockitoException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.RETURNS_DEFAULTS;
import static org.mockito.internal.util.reflection.GenericMetadataSupport.from;
public class GenericMetadataSupportTest {
interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {
E get();
interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {
E get();
interface ListOfNumbers extends List<Number> {}
interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
Set<Number> remove(Object key); // override with fixed ParameterizedType
List<? super Integer> returning_wildcard_with_class_lower_bound();
List<? super K> returning_wildcard_with_typeVar_lower_bound();
List<? extends K> returning_wildcard_with_typeVar_upper_bound();
K returningK();
<O extends K> List<O> paramType_with_type_params();
<S, T extends S> T two_type_params();
<O extends K> O typeVar_with_type_params();
public void can_get_raw_type_from_Class() throws Exception {
assertThat(from(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);
assertThat(from(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);
assertThat(from(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);
public void can_get_raw_type_from_ParameterizedType() throws Exception {
assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);
assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);
assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);
public void can_get_type_variables_from_Class() throws Exception {
assertThat(from(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("K");
assertThat(from(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();
assertThat(from(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("N");
assertThat(from(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");
assertThat(from(Serializable.class).actualTypeArguments().keySet()).isEmpty();
public void can_get_type_variables_from_ParameterizedType() throws Exception {
assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");
assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("E");
assertThat(from(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("T");
assertThat(from(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();
public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("get", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(Set.class);
assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);
public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returningK", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);
GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));
assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);
public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("remove", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(Set.class);
assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);
public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("values", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);
GenericMetadataSupport fromTypeVariableE = from(typeVariableValue(genericMetadata.actualTypeArguments(), "E"));
assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);
assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);
public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("paramType_with_type_params", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(List.class);
Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E")).firstBound();
assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);
public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("typeVar_with_type_params", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);
GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));
assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);
public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {
GenericMetadataSupport genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod("append", StringBuilder.class));
assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);
assertThat(genericMetadata.actualTypeArguments()).isEmpty();
public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(List.class);
GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
assertThat(boundedType.firstBound()).isEqualTo(Integer.class);
assertThat(boundedType.interfaceBounds()).isEmpty();
public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_lower_bound", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(List.class);
GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);
assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }
public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_upper_bound", GenericsNest.class));
assertThat(genericMetadata.rawType()).isEqualTo(List.class);
GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);
assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);
public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound", GenericsNest.class));
GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);
public void toMock_returns_mock_of_correct_type() throws Exception {
GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returningK", GenericsNest.class));
assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);
assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);
private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {
for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {
if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {
return typeVariableTypeEntry.getValue();
fail("'" + typeVariableName + "' was not found in " + typeVariables);
return null; // unreachable
private Method firstNamedMethod(String methodName, Class<?> clazz) {
for (Method method : clazz.getMethods()) {
if (method.getName().contains(methodName)) {
return method;
throw new IllegalStateException("The method : '" + methodName + "' do not exist in '" + clazz.getSimpleName() + "'");
import org.mockito.internal.exceptions.base.StackTraceFilter;System.out.println(what);
package org.mockito.internal.util.reflection;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.HashMap;
import java.util.Map;
class ClassEnhancedToParameterizedType implements ParameterizedType {
private Class<?> clazz;
private Map<TypeVariable, Type> allActualTypeParameters = new HashMap<TypeVariable, Type>();
ClassEnhancedToParameterizedType(Class<?> clazz) {
this.clazz = clazz;
readActualTypeParametersOnDeclaringClass();
private void readActualTypeParametersOnDeclaringClass() {
registerTypeVariablesOn(clazz);
registerTypeVariablesOn(clazz.getGenericSuperclass());
for (Type genericInterface : clazz.getGenericInterfaces()) {
registerTypeVariablesOn(genericInterface);
private void registerTypeVariablesOn(Type classType) {
if (!(classType instanceof ParameterizedType)) {
return;
ParameterizedType parameterizedType = (ParameterizedType) classType;
TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
for (int i = 0; i < actualTypeArguments.length; i++) {
Type actualTypeArgument = actualTypeArguments[i];
TypeVariable typeParameter = typeParameters[i];
allActualTypeParameters.put(typeParameter, actualTypeArgument);
GenericTypeInfo.logger.log("For '" + parameterizedType + "' found type variable : { '" + typeParameter + "(in '" + typeParameter.getGenericDeclaration() + "')" + "' : '" + actualTypeArgument + "' }");
private void registerTypeVariablesOn(Class<?> clazz) {
TypeVariable[] typeParameters = clazz.getTypeParameters();
for (TypeVariable typeParameter : typeParameters) {
allActualTypeParameters.put(typeParameter, boundsOf(typeParameter));
GenericTypeInfo.logger.log("For '" + clazz.getCanonicalName() + "' found type variable : { '" + typeParameter + "(in '" + typeParameter.getGenericDeclaration() + "')" + "' : '" + boundsOf(typeParameter) + "' }");
private Type boundsOf(TypeVariable typeParameter) {
return new GenericTypeInfo.TypeVariableUpperBounds(typeParameter);
public Type[] getActualTypeArguments() {
return new Type[0];  //To change body of implemented methods use File | Settings | File Templates.
public Type getRawType() {
return clazz;
public Type getOwnerType() {
return null;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public Class<?> identifyGenericReturnType(Method method, Class<?> onClass) {
Type genericReturnType = method.getGenericReturnType();
if (genericReturnType instanceof ParameterizedType) {
ParameterizedType parameterizedType = (ParameterizedType) genericReturnType;
if (parameterizedType.getActualTypeArguments().length <= 0) {
return null; // not supported yet, see #getActualTypeArguments javadoc
Type type = parameterizedType.getActualTypeArguments()[0];
if (type instanceof Class) {
return (Class) type;
if (type instanceof TypeVariable) {
throw new IllegalStateException();
if (type instanceof ParameterizedType) {
throw new IllegalStateException();
return null;
return null;
private Class<?> identifyReturnTypeFromClass(TypeVariable typeVariable, Class<?> onClass) {
List<Type> genericInterfaces = new ArrayList<Type>(Arrays.asList(onClass.getGenericInterfaces()));
genericInterfaces.add(onClass.getGenericSuperclass());
for (Type genericInterface : genericInterfaces) {
if (genericInterface instanceof ParameterizedType) {
ParameterizedType parameterizedType = (ParameterizedType) genericInterface;
parameterizedType.getActualTypeArguments();
if (parameterizedType.getRawType() instanceof Class) {
Class rawType = (Class) parameterizedType.getRawType();
TypeVariable[] typeParameters = rawType.getTypeParameters();
for (int typeVarPosition = 0; typeVarPosition < typeParameters.length; typeVarPosition++) {
TypeVariable typeParameter = typeParameters[typeVarPosition];
if (typeVariable.equals(typeParameter)) {
Type typeVariableValue = parameterizedType.getActualTypeArguments()[typeVarPosition];
if (typeVariableValue instanceof Class) {
return (Class) typeVariableValue;
if (typeVariableValue instanceof TypeVariable) {
TypeVariable variableValue = (TypeVariable) typeVariableValue;
throw new IllegalStateException("type var :" + variableValue);
return null;
package org.mockito.internal.util.reflection;
import org.mockito.Incubating;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.Checks;
import org.mockito.internal.util.ConsoleMockitoLogger;
import org.mockito.internal.util.MockitoLogger;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
public class GenericTypeInfo {
public static MockitoLogger logger = new ConsoleMockitoLogger();
private final Type typeToSolve;
private final Type clazz;
private Map<TypeVariable, Type> typeVariables = new HashMap<TypeVariable, Type>();
private GenericTypeInfo(Type typeToSolve, Class<?> sourceType, Map<TypeVariable, Type> typeVariables) {
this.typeToSolve = typeToSolve;
this.clazz = sourceType;
this.typeVariables = typeVariables;
throw new UnsupportedOperationException("code under (re)factoring");
public Class<?> asRawType() {
return extractRawTypeOf(typeToSolve);
private Class<?> extractRawTypeOf(Type type) {
if (type instanceof Class) {
return (Class<?>) type;
if (type instanceof ParameterizedType) {
return (Class<?>) ((ParameterizedType) type).getRawType();
if (type instanceof TypeVariableUpperBounds) {
return extractRawTypeOf(((TypeVariableUpperBounds) type).firstBound());
if (type instanceof TypeVariable) {
If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
on the class definition, such as such as List<E>.
return extractRawTypeOf(typeVariables.get(type));
throw new MockitoException("Raw extraction not managed for : '" + type + "'");
private Type actualType() {
return extractActualTypeOf(typeToSolve);
private Type extractActualTypeOf(Type type) {
if (type instanceof TypeVariableUpperBounds) {
return extractActualTypeOf(((TypeVariableUpperBounds) type).firstBound());
if (type instanceof TypeVariable) {
If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
on the class definition, such as such as List<E>.
return extractActualTypeOf(typeVariables.get(type));
return type; // irrelevant, we don't manage other types.
public String toString() {
final StringBuilder sb = new StringBuilder();
sb.append(actualType());
sb.append(' ').append(typeVariables);
return sb.toString();
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
GenericTypeInfo that = (GenericTypeInfo) o;
return !(clazz != null ? !clazz.equals(that.clazz) : that.clazz != null) && typeToSolve.equals(that.typeToSolve);
public int hashCode() {
int result = typeToSolve.hashCode();
result = 31 * result + (clazz != null ? clazz.hashCode() : 0);
return result;
public static class TypeVariableUpperBounds implements Type {
private TypeVariable typeVariable;
public TypeVariableUpperBounds(TypeVariable typeVariable) {
this.typeVariable = typeVariable;
public Type firstBound() {
return typeVariable.getBounds()[0]; // either a class or an interface, always present
public Type[] interfaceBounds() {
Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];
System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);
return interfaceBounds;
public String toString() {
final StringBuilder sb = new StringBuilder();
sb.append("{firstBound=").append(firstBound());
sb.append(", interfaceBounds=").append(Arrays.deepToString(interfaceBounds()));
sb.append('}');
return sb.toString();
public static ParameterizedType asParameterizedType(Class<?> clazz) {
return new ClassEnhancedToParameterizedType(clazz);
public static Builder on(Class<?> clazz) {
Checks.checkNotNull(clazz, "clazz");
return new Builder().onClass(clazz);
public static Builder on(GenericTypeInfo genericTypeInfo) {
Checks.checkNotNull(genericTypeInfo, "genericTypeInfo");
return new Builder().onClass(genericTypeInfo.asRawType())
.withTypeVariables(genericTypeInfo.typeVariables);
public static class Builder {
private Class<?> clazz;
private Method method;
private Map<TypeVariable, Type> typeVariables = new HashMap<TypeVariable, Type>();
public Builder onClass(Class<?> clazz) {
this.clazz = clazz;
return this;
public Builder method(Method method) {
Checks.checkNotNull(method, "method");
this.method = method;
return this;
public Builder methodName(String methodName) {
Checks.checkNotNull(methodName, "methodName");
this.method = pickFirstMatchingMethod(methodName, clazz);
return this;
private Method pickFirstMatchingMethod(String methodName, Class<?> clazz) {
for (Method method : clazz.getMethods()) {
if (method.getName().contains(methodName)) {
return method;
throw new IllegalStateException("The method : '" + methodName + "' do not exist in '" + clazz.getSimpleName() + "'");
private Builder withTypeVariables(Map<TypeVariable, Type> typeVariables) {
this.typeVariables = typeVariables;
return this;
public GenericTypeInfo genericReturnTypeInfo() {
Type genericReturnType = method.getGenericReturnType();
return new GenericTypeInfo(genericReturnType, clazz, typeVariables);
package org.mockito.internal.util.reflection;
import org.junit.Test;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static org.fest.assertions.Assertions.assertThat;
public class ClassEnhancedToParameterizedTypeTest {
interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {
E get();
interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {
E get();
interface ListOfNumbers extends List<Number> {}
interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {}
public void can_get_raw_type() throws Exception {
assertThat(new ClassEnhancedToParameterizedType(ListOfAnyNumbers.class).getRawType()).isEqualTo(ListOfAnyNumbers.class);
assertThat(new ClassEnhancedToParameterizedType(ListOfNumbers.class).getRawType()).isEqualTo(ListOfNumbers.class);
assertThat(new ClassEnhancedToParameterizedType(MapWithNestedGenerics.class).getRawType()).isEqualTo(MapWithNestedGenerics.class);
public void can_read_actual_type_parameters() throws Exception {
import org.junit.Ignore;
import org.junit.Test;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.*;
import static org.junit.Assert.assertEquals;
public interface ListSet extends List<Set> {}
public interface MapNumberString extends Map<Number, String> {}
public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}
public List<Number> numberList() { return null; }
public Comparable<Number> numberComparable() { return null; }
public List rawList() { return null; }
public List<? extends Type> typeList() { return null; }
public void should_find_generic_class() throws Exception {
public void should_get_object_for_non_generic() throws Exception {
public void should_deal_with_nested_generics() throws Exception {
public void can_identify_generic_type_of_returned_collection() throws Exception {
assertEquals(Number.class, m.identifyGenericReturnType(method("numberList"), this.getClass()));
public void can_identify_generic_type_of_returned_user_type() throws Exception {
assertEquals(Number.class, m.identifyGenericReturnType(method("numberComparable"), this.getClass()));
public void can_identify_generic_type_of_returned_type_when_owner_type_forces_generic_type() throws Exception {
assertEquals(Set.class, m.identifyGenericReturnType(method(ListSet.class, "iterator"), ListSet.class));
assertEquals(Number.class, m.identifyGenericReturnType(method(MapNumberString.class, "keySet"), MapNumberString.class));
assertEquals(String.class, m.identifyGenericReturnType(method(MapNumberString.class, "values"), MapNumberString.class));
assertEquals(String.class, m.identifyGenericReturnType(method(MapNumberString.class, "remove"), MapNumberString.class));
assertEquals(Map.Entry.class, m.identifyGenericReturnType(method(MapNumberString.class, "entrySet"), MapNumberString.class));
public void can_identify_type_variable_upper_bound() throws Exception {
assertEquals(Number.class, m.identifyGenericReturnType(method(HashMapNumberString.class, "keySet"), HashMapNumberString.class));
assertEquals(Type.class, m.identifyGenericReturnType(method("typeList"), this.getClass()));
public void can_identify_nested_generic_type_of_returned_type_when_owner_forces_generic_type() throws Exception {
public void will_return_null_if_return_type_not_generic() throws Exception {
assertEquals(null, m.identifyGenericReturnType(method("rawList"), this.getClass()));
private Method method(String noArgMethod) throws NoSuchMethodException {
return method(this.getClass(), noArgMethod);
private Method method(Class<?> clazz, String noArgMethod) throws NoSuchMethodException {
for (Method method : clazz.getMethods()) {
if (method.getName().contains(noArgMethod)) {
return method;
throw new NoSuchMethodException("method " + noArgMethod + " do not exist in " + clazz.getSimpleName());
package org.mockito.internal.util.reflection;
import org.junit.Test;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import static org.fest.assertions.Assertions.assertThat;
import static org.mockito.internal.util.reflection.GenericTypeInfo.on;
public class GenericTypeInfoTest {
interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {
E get();
interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {
E get();
interface ListOfNumbers extends List<Number> {}
interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
public void can_get_raw_type_on_simple_return_type() throws Exception {
assertThat(on(List.class).methodName("iterator").genericReturnTypeInfo().asRawType()).isEqualTo(Iterator.class);
assertThat(on(List.class).methodName("size").genericReturnTypeInfo().asRawType()).isEqualTo(int.class);
assertThat(on(Number.class).methodName("toString").genericReturnTypeInfo().asRawType()).isEqualTo(String.class);
public void can_get_raw_type_of_parameterized_return_type() throws Exception {
assertThat(on(List.class).methodName("get").genericReturnTypeInfo().asRawType()).isEqualTo(Object.class);
public void can_get_raw_type_of_parameterized_return_type_with_upper_bounded_type_variable() throws Exception {
assertThat(on(UpperBoundedTypeWithInterfaces.class).methodName("get").genericReturnTypeInfo().asRawType()).isEqualTo(Comparable.class);
assertThat(on(UpperBoundedTypeWithClass.class).methodName("get").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);
public void can_get_raw_type_of_parameterized_return_type_with_fixed_type_argument() throws Exception {
assertThat(on(ListOfNumbers.class).methodName("get").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);
public void can_get_raw_type_of_parameterized_return_type_with_bounded_type_parameter() throws Exception {
assertThat(on(ListOfAnyNumbers.class).methodName("get").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);
interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable & Set<Number>> extends Map<K, Set<Number>> {}
public void test() throws Exception {
GenericTypeInfo entrySetGenericTypeInfo = on(MapWithNestedGenerics.class).methodName("entrySet").genericReturnTypeInfo();
System.out.println(entrySetGenericTypeInfo); // Set<Entry<K extends Comparable<K>, Set<Number>>
System.out.println("======================================================");
GenericTypeInfo iteratorGenericTypeInfo = on(entrySetGenericTypeInfo).methodName("iterator").genericReturnTypeInfo();
System.out.println(iteratorGenericTypeInfo);public class InvocationNotifierHandler<T> implements MockHandler, InternalMockHandler<T> {
private MockHandlerImpl<T> mockHandler;
public InvocationNotifierHandler(MockHandlerImpl<T> mockHandler, MockCreationSettings settings) {
import org.mockito.invocation.MockHandler;
public MockHandler create(MockCreationSettings settings) {
return new InvocationNotifierHandler(
new MockHandlerImpl(settings), settings);
public class MockHandlerImpl<T> implements InternalMockHandler<T> {
Object ret = mockSettings.getDefaultAnswer().answer(invocation);MockSettings forwardTo(Object delegate) ;
import org.mockito.internal.creation.MockSettingsImpl;
public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsImpl settings) {
public MockSettingsImpl getMockSettings() {
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.invocation.MockitoInvocationHandler;
private final MockSettingsImpl mockSettings;
public MockHandler(MockSettingsImpl mockSettings) {
MockHandler() {
this(new MockSettingsImpl());
public MockHandler(MockHandlerInterface<T> oldMockHandler) {
this(oldMockHandler.getMockSettings());
public MockSettingsImpl getMockSettings() {
import org.mockito.internal.creation.MockSettingsImpl;
MockSettingsImpl getMockSettings();
T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
mockUtil.redefineMockNameIfSurrogate(instance, field.getName());
public <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,
private Class<?>[] extraInterfaces;
public MockSettings extraInterfaces(Class<?>... extraInterfaces) {
for (Class<?> i : extraInterfaces) {
this.extraInterfaces = extraInterfaces;
public Class<?>[] getExtraInterfaces() {
this.delegatedInstance = delegatedInstance ;
return defaultAnswer(new ForwardsInvocations(this.delegatedInstance)) ;
public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {
public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {
Class<?>[] extraInterfaces = prepareAncillaryTypes(settings);
private Class<?>[] prepareAncillaryTypes(MockSettingsImpl settings) {
Class<?>[] interfaces = settings.getExtraInterfaces();
Class<?>[] ancillaryTypes;
if (settings.isSerializable()) {
ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
ancillaryTypes = new ArrayUtils().concat(ancillaryTypes, MockitoSpy.class);
MockSettingsImpl settings = oldHandler.getMockSettings();
public void redefineMockNameIfSurrogate(Object mock, String newName) {
public Class<?>[] concat(Class<?>[] interfaces, Class<?>... clazz) {
int interfacesCount = interfaces.length;
int appendedCount = clazz.length;
Class[] out = new Class[interfacesCount + appendedCount];
System.arraycopy(interfaces, 0, out, 0, interfacesCount);
System.arraycopy(clazz, 0, out, interfacesCount, appendedCount);
return out;
Class<?>[] extraInterfaces,
MockHandler<?> handler = new MockHandler();
assertEquals(List.class, mockSettingsImpl.getExtraInterfaces()[0]);
assertEquals(Set.class, mockSettingsImpl.getExtraInterfaces()[1]);
package org.mockito.internal.util;
import org.fest.assertions.Assertions;
import org.junit.Test;
import org.mockito.internal.util.collections.ArrayUtils;
import org.mockitoutil.TestBase;
import java.io.Serializable;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ArrayUtilsTest extends TestBase {
ArrayUtils utils = new ArrayUtils();
public void shouldConcatenateItemToAnEmptyArray() throws Exception {
Class<?>[] items = utils.concat(new Class[0], List.class);
Assertions.assertThat(items).containsOnly(List.class);
public void shouldConcatenateItemsToFullArray() throws Exception {
Class<?>[] items = utils.concat(new Class[] {Serializable.class, Map.class}, List.class, Set.class);
Assertions.assertThat(items).containsOnly(Serializable.class, Map.class, List.class, Set.class);
validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});
public void validateExtraInterfaces(Class classToMock, Class ... interfaces) {
mockUtil.redefineMockNameIfSurrogate(mock, "newName");
mockUtil.redefineMockNameIfSurrogate(mock, "newName");InvocationNotifierHandler oldHandler
= (InvocationNotifierHandler) mockMaker.getHandler(mock);import org.mockito.MockitoAnnotations;
public Object process(MockitoAnnotations.Mock annotation, Field field) {public interface PrintableInvocation extends DescribedInvocation {}
private final Invocation invocation;
private Object returnedValue;
private Throwable throwable;
public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {
this.invocation = invocation;
this.returnedValue = returnedValue;
public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {
this.invocation = invocation;
this.throwable = throwable;
public DescribedInvocation getInvocation() {
return invocation;
public Object getReturnedValue() {
return returnedValue;
public Throwable getThrowable() {
return throwable;
public boolean threwException() {
return throwable != null;
public String getLocationOfStubbing() {
return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt().toString();
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;
if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;
if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)
return false;
if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;
return true;
public int hashCode() {
int result = invocation != null ? invocation.hashCode() : 0;
result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);
result = 31 * result + (throwable != null ? throwable.hashCode() : 0);
return result;
public interface DescribedInvocation {
PrintableInvocation getInvocation();private static List<String> readerToLines(Reader reader) throws IOException {
private static String stripCommentAndWhitespace(String line) {import org.mockito.internal.util.ListUtil;
import org.mockito.internal.util.ListUtil.Filter;import org.junit.BeforeClass;import java.util.ServiceLoader;
import org.mockito.internal.creation.CglibMockMaker;
Class configClass = null;
for (MockMaker mockMaker : ServiceLoader.load(MockMaker.class)) {
return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());
IMethods mock = mock(IMethods.class); import java.util.List;
"This exception *might* occur in wrongly written multi-threaded tests.",
"Please refer to Mockito FAQ on limitations of concurrency testing.",
import org.mockito.exceptions.Reporter;
import org.mockito.exceptions.base.MockitoException;
AnnotationEngine delegate = new DefaultAnnotationEngine();
AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();
void assertNoAnnotations(final Field field, final Class ... annotations) {
for (Class annotation : annotations) {
if (field.isAnnotationPresent(annotation)) {
new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());
public void injectMocks(final Object testClass) {
Class<?> clazz = testClass.getClass();
mockDependentFields.addAll(scanForInjection(testClass, clazz));
mocks.addAll(scanMocks(testClass, clazz));
new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClass);
private Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {
Set<Field> mockDependentFields = new HashSet<Field>();
Field[] fields = clazz.getDeclaredFields();
for (Field field : fields) {
if (null != field.getAnnotation(InjectMocks.class)) {
assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);
mockDependentFields.add(field);
return mockDependentFields;
private Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {
Set<Object> mocks = new HashSet<Object>();
for (Field field : clazz.getDeclaredFields()) {
if (null != field.getAnnotation(Spy.class) || null != field.getAnnotation(org.mockito.Mock.class)
|| null != field.getAnnotation(org.mockito.MockitoAnnotations.Mock.class)) {
Object fieldInstance = null;
boolean wasAccessible = field.isAccessible();
field.setAccessible(true);
try {
fieldInstance = field.get(testClass);
throw new MockitoException("Problems reading this field dependency " + field.getName() + " for injection", e);
field.setAccessible(wasAccessible);
if (fieldInstance != null) {
mocks.add(fieldInstance);
return mocks;
return report.fieldWasInitialized();
import java.lang.reflect.*;
import java.util.List;
import org.mockito.cglib.core.*;
private ObjenesisStd objenesis = new ObjenesisStd();
import org.mockito.internal.stubbing.answers.DoesNothing;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.internal.stubbing.answers.ThrowsException;
import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
if (!new MockCreationValidator().isTypeMockable(clz))
private Object getMock(InvocationOnMock invocation) {
MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
InvocationContainerImpl container = (InvocationContainerImpl)handler.getInvocationContainer();
public Class<?>[] concat(Class<?>[] interfaces, Class<?> clazz) {
int length = interfaces.length;
Class[] out = new Class[length +1];
System.arraycopy(interfaces, 0, out, 0, length);
out[length] = clazz;
Object spiedInstance = settings.getSpiedInstance();
T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);
if (spiedInstance != null) {
new LenientCopyTool().copyToMock(spiedInstance, mock);
return mock;
public boolean isMock(Object mock) {
return mock != null && isMockitoMock(mock);
public FieldInitializationReport(Object fieldInstance, boolean wasInitialized) {
return new FieldInitializationReport(fieldInstance, false);
instantiator.instantiate();
return new FieldInitializationReport(field.get(fieldOwner), true);
Object instantiate();
public Object instantiate() {
return field.get(testClass);
public Object instantiate() {
return field.get(testClass);
public class ReturnsElementsOf implements Answer {
final LinkedList elements;
public ReturnsElementsOf(Collection elements) {
this.elements = new LinkedList(elements);
public void shouldConcatenateItemToFullArray() throws Exception {
Class<?>[] items = utils.concat(new Class[] {Serializable.class, Map.class}, List.class);
Assertions.assertThat(items).containsOnly(Serializable.class, Map.class, List.class);
import static org.mockito.Mockito.*;
public void isValidMocked() {
import static org.mockito.BDDMockito.*;
import javax.net.SocketFactory;
import org.junit.Test;
import org.mockitoutil.TestBase;
static final class FinalClass {};    Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);
injectionOccurred |= injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);
public void should_not_inject_the_object() {public boolean enableClassCache() {
return true;
boolean enableClassCache();
"If you're unsure why you're getting above error read on.",
"Due to the nature of the syntax above problem might occur because:",
"1. This exception *might* occur in wrongly written multi-threaded tests.",
"   Please refer to Mockito FAQ on limitations of concurrency testing.",
"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ",
"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.",
public boolean enableClassCache() {
return globalConfiguration.get().enableClassCache();
Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);
injectionOccurred |= injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);
import org.mockito.internal.configuration.GlobalConfiguration;
private ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());
private boolean enableClassCache = true;
public void overrideEnableClassCache(boolean enableClassCache) {
this.enableClassCache = enableClassCache;
public boolean enableClassCache() {
return enableClassCache;
public void should_not_inject_the_object() {
package org.mockitousage.configuration;
import org.fest.assertions.Condition;
import org.junit.Test;
import org.mockito.internal.configuration.ConfigurationAccess;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.concurrent.Callable;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
public class ClassCacheVersusClassReloadingTest {
private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm = new SimplePerRealmReloadingClassLoader(reloadMockito());
public void should_throw_ClassCastException_on_second_call() throws Exception {
doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
try {
doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
fail("should have raised a ClasCastException when Objenis Cache is enabled");
assertThat(e).satisfies(thatCceIsThrownFrom("org.mockito.internal.creation.jmock.ClassImposterizer.imposterise"));
public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() throws Exception {
prepareMockitoAndDisableObjenesisCache();
doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");
private Condition<Throwable> thatCceIsThrownFrom(final String stacktraceElementDescription) {
return new Condition<Throwable>() {
public boolean matches(Throwable throwable) {
return throwable.getStackTrace()[1].toString().contains(stacktraceElementDescription);
public static class DoTheMocking implements Callable {
public Object call() throws Exception {
Class clazz = this.getClass().getClassLoader().loadClass("org.mockitousage.MethodsImpl");
return mock(clazz);
private static void doInNewChildRealm(ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {
new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope()).doInRealm(callableCalledInClassLoaderRealm);
private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {
return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {
public boolean needReload(String qualifiedName) {
return "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking".equals(qualifiedName)
|| "org.mockitousage.MethodsImpl".equals(qualifiedName);
private void prepareMockitoAndDisableObjenesisCache() throws Exception {
testMethodClassLoaderRealm.doInRealm("org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito");
public static class PrepareMockito implements Callable {
public Object call() throws Exception {
Class.forName("org.mockito.Mockito");
ConfigurationAccess.getConfig().overrideEnableClassCache(false);
return Boolean.TRUE;
private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {
return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {
public boolean needReload(String qualifiedName) {
return qualifiedName.contains("org.mockito")
&& !qualifiedName.contains("org.mockito.cglib");
private static class SimplePerRealmReloadingClassLoader extends URLClassLoader {
private ReloadClassPredicate reloadClassPredicate;
public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {
super(new URL[]{obtainClassPath(), obtainClassPath("org.mockito.Mockito")});
this.reloadClassPredicate = reloadClassPredicate;
public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {
super(new URL[]{
obtainClassPath(),
obtainClassPath("org.mockito.Mockito")
this.reloadClassPredicate = reloadClassPredicate;
private static URL obtainClassPath() {
String className = SimplePerRealmReloadingClassLoader.class.getName();
return obtainClassPath(className);
private static URL obtainClassPath(String className) {
String path = className.replace('.', '/') + ".class";
String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();
try {
return new URL(url.substring(0, url.length() - path.length()));
throw new RuntimeException("Classloader couldn't obtain a proper classpath URL", e);
public Class<?> loadClass(String qualifiedName) throws ClassNotFoundException {
if(reloadClassPredicate.needReload(qualifiedName)) {
return findClass(qualifiedName);
return super.loadClass(qualifiedName);
public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {
Callable<?> callableInRealm = (Callable<?>) this.loadClass(callableCalledInClassLoaderRealm).newInstance();
return callableInRealm.call();
public static interface ReloadClassPredicate {
boolean needReload(String qualifiedName);
package org.mockitousage.misuse;
import org.junit.Test;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
import static org.junit.Assert.fail;
import static org.fest.assertions.Assertions.assertThat;
import static org.mockito.Mockito.*;
public class SpyStubbingMisuseTest {
public void nestedWhenTest() {
Strategy mfoo = mock(Strategy.class);
Sampler mpoo = mock(Sampler.class);
Producer out = spy(new Producer(mfoo));
try {
when(out.produce()).thenReturn(mpoo);
fail();
assertThat(e.getMessage()).contains("spy").contains("syntax").contains("doReturn|Throw");
public class Sample { }
public class Strategy {
Sample getSample() {
return new Sample();
public class Sampler {
Sample sample;
Sampler(Strategy f) {
sample = f.getSample();
public class Producer {
Strategy strategy;
Producer(Strategy f) {
strategy = f;
Sampler produce() {
return new Sampler(strategy);"If the method you are trying to stub is *overloaded* then make sure you are calling the right overloaded version.",
"This exception might also occur when somewhere in your test you are stubbing *final methods*."int number_of_test_before_including_this_one = 4;
assertEquals(number_of_test_before_including_this_one, articleVisitorInstantiationCount);
assertEquals(number_of_test_before_including_this_one, articleVisitorMockInjectedInstances.size());
class ATest {import static org.mockito.Matchers.contains;
InvocationListener listener = mock(InvocationListener.class);
verify(listener).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),
contains(getClass().getSimpleName().toString()));
InvocationListener listener1 = mock(InvocationListener.class);
InvocationListener listener2 = mock(InvocationListener.class);
verify(listener1).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),
isA(String.class));
verify(listener2).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),
isA(String.class));"2. inside when() you don't call method on mock but on some other object."import org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter;
import org.mockito.internal.stubbing.answers.CallsRealMethods;
import org.mockito.internal.stubbing.answers.DoesNothing;
import org.mockito.internal.stubbing.answers.Returns;
import org.mockito.internal.stubbing.answers.ThrowsException;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.DeprecatedOngoingStubbing;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.VoidMethodStubbable;
import org.mockito.verification.VerificationWithTimeout;
import java.util.LinkedList;
import java.util.List;
import static org.mockito.BDDMockito.*;
import static org.mockito.Mockito.*;
when(mock.simpleMethod()).thenThrow(null);
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import java.io.IOException;
import static org.mockito.Mockito.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.exceptions.verification.WantedButNotInvoked;
import org.mockitoutil.TestBase;
when(mock.add("monkey island")).thenThrow(null);import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
import org.mockito.exceptions.misusing.MissingMethodInvocationException;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.exceptions.misusing.NullInsteadOfMockException;
import org.mockito.exceptions.misusing.UnfinishedStubbingException;
import org.mockito.exceptions.misusing.UnfinishedVerificationException;
import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atMost(maxNumberOfInvocations));
assertCorrectMode(t.atMost(10), Timeout.class, 50, 25, AtMost.class);return -1;
return 1;
public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {
for (Field field : testClassFields) {
Object fieldInstance = null;
fieldInstance = new FieldInitializer(testClass, field).initialize();
Class<?> fieldClass = fieldInstance.getClass();
injectMockCandidate(fieldClass, mocks, fieldInstance);
for(Field field : declaredFields) {
mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
public boolean thenInject() {
return true;
public boolean thenInject() {
return false;
boolean thenInject();
import org.junit.Ignore;
private Object reference = new Object();
public void test() {
assertSame(reference, illegalInjectionExample.mockShouldNotGoInHere);
public class Bean {}
public class Service {
public final Object mockShouldNotGoInHere = reference;import java.io.Serializable;
if (object == null) {
text+="null";
text+=object.toString();
description.appendText(wanted == null ? "null" : wanted.toString());import java.io.Serializable;
description.appendText(wanted.toString());
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;while (clazz != Object.class) {
scan(testClass, clazz);
clazz = clazz.getSuperclass();
static void scan(Object testClass, Class<?> clazz) {
AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();
if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {
processAnnotationDeprecatedWay(annotationEngine, testClass, field);                
annotationEngine.process(clazz, testClass);
import org.mockito.MockitoAnnotations;
void process(Class<?> context, Object testClass);
"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?", e);
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
public void process(Class<?> clazz, Object testClass) {
new FieldSetter(testClass, field).set(mock);
public void process(Class<?> context, Object testClass) {
delegate.process(context, testClass);
spyAnnotationEngine.process(context, testClass);
Field[] fields = context.getDeclaredFields();
for (Field field : fields) {
if (field.isAnnotationPresent(InjectMocks.class)) {
assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
injectMocks(testClass);
void assertNoAnnotations(Field field, Class ... annotations) {
public void injectMocks(Object testClass) {       
private static Set<Field> scanForInjection(Object testClass, Class<?> clazz) {
private static Set<Object> scanMocks(Object testClass, Class<?> clazz) {
|| null != field.getAnnotation(Mock.class)) {
public void process(Class<?> context, Object testClass) {
instance = new FieldInitializer(testClass, field).initialize();
field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
import java.io.Serializable;
if (object == null) {
text+="null";
text+=object.toString();
import java.io.Serializable;
description.appendText(wanted.toString());
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;"    verifyZeroInteractions(mockOne, mockTwo);",
""
"    verifyZeroInteractions(mockOne, mockTwo);",
""
scenario
"Unable to instantiate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?", e);
|| null != field.getAnnotation(org.mockito.MockitoAnnotations.Mock.class)) {
import java.io.Serializable;
text+="" + object;
import java.io.Serializable;
description.appendText("" + wanted);
package org.mockitousage.annotation;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import java.awt.*;
import static org.junit.Assert.assertNotNull;
public class DeprecatedMockAnnotationTest {
public void initMocks() throws Exception {
MockitoAnnotations.initMocks(this);
public void shouldCreateMockForDeprecatedMockAnnotation() throws Exception {
assertNotNull(deprecatedMock);
public void shouldInjectDeprecatedMockAnnotation() throws Exception {
assertNotNull(anInjectedObject.aFieldAwaitingInjection);
private static class AnInjectedObject {
List aFieldAwaitingInjection;
package org.mockitousage.bugs;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import java.util.List;
import java.util.Set;
public class DeepStubGenericTypesIssueTest extends TestBase {
static interface ListSet extends List<Set> {}
public void testDeepMockWithClass() {
final ListSet mock = Mockito.mock(ListSet.class, Mockito.RETURNS_DEEP_STUBS);
final Set mock2 = mock.get(0);
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
public void shouldNotThrowNPEWhenNullPassedToEq() {
mock.objectArgMethod("not null");
verify(mock).objectArgMethod(eq(null));
public void shouldNotThrowNPEWhenNullPassedToSame() {
mock.objectArgMethod("not null");
verify(mock).objectArgMethod(same(null));
package org.mockitousage.verification;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.internal.invocation.CapturesArgumensFromInvocation;
import org.mockito.internal.invocation.Invocation;
import org.mockito.internal.invocation.InvocationMarker;
import org.mockito.internal.stubbing.InvocationContainer;
import org.mockito.internal.util.MockUtil;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
import java.util.List;
import static org.mockito.Mockito.*;
public class NoMoreInteractionsExcludingStubsTest extends TestBase {
public void shouldAllowToExcludeStubsForVerification() throws Exception {
when(mock.simpleMethod()).thenReturn("foo");
String stubbed = mock.simpleMethod(); //irrelevant call because it is stubbing
mock.objectArgMethod(stubbed);
verify(mock).objectArgMethod("foo");
try { verifyNoMoreInteractions(mock); fail(); } catch (NoInteractionsWanted e) {};
ignoreStubs(mock);
verifyNoMoreInteractions(mock);
public static Object[] ignoreStubs(Object... mocks) {
for (Object m : mocks) {
InvocationContainer invocationContainer = new MockUtil().getMockHandler(m).getInvocationContainer();
List<Invocation> ins = invocationContainer.getInvocations();
for (Invocation in : ins) {
InvocationMarker invocationMarker = new InvocationMarker();
if (in.stubInfo() != null) {
invocationMarker.markVerified(in, new CapturesArgumensFromInvocation() {
public void captureArgumentsFrom(Invocation i) {
return mocks;"    verifyZeroInteractions(mockOne, mockTwo);"
"    verifyZeroInteractions(mockOne, mockTwo);"
scenario,
""
|| null != field.getAnnotation(Mock.class)) {
import java.io.Serializable;
if (object == null) {
text+="null";
text+=object.toString();
import java.io.Serializable;
description.appendText(wanted.toString());
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
verify(mock, atLeastOnce()).compareTo(new Date());Foo foo = mock.getSomeClass(); 
Bar bar = mock.getSomeInterface(); public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {
public Injecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
return new Injecter() {
new FieldSetter(fieldInstance, field).set(matchingMock);
return new Injecter() {
package org.mockito.internal.configuration.injection;
public interface Injecter {
boolean thenInject();
Injecter filterCandidate(
public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {" 2. although stubbed methods may return mocks, you cannot inline mock creation (mock()) call inside a thenReturn method (see issue 53)",
" 3. you are trying to stub a final method, you naughty developer!",public void notAMockPassedToVerify() {
"Argument passed to verify() is not a mock!",
"Examples of correct verifications:",
reporter.notAMockPassedToVerify();return (T) anyObject();field.set(testClass, Mockito.spy(instance));public class ShouldNotDeadlockAnswerExecution {
class LockingAnswer implements Answer<String> {
private AtomicInteger counter;
public LockingAnswer(AtomicInteger counter) {
this.counter = counter;
public String answer(InvocationOnMock invocation) throws Throwable {
counter.decrementAndGet();
while (counter.get() != 0) {
Thread.sleep(10);
return null;
class ServiceRunner implements Runnable {
private Service service;
public ServiceRunner(Service service) {
this.service = service;
public void run() {
service.verySlowMethod();
interface Service {
String verySlowMethod();public void withLong(long y) {
mock = spy(new Foo());
when(mock.getStuff()).thenReturn("aha!");
mock.doSomeThing();"    Argument<Person> argument = new Argument<Person>();",public boolean hasSameMethod(Invocation candidate) {
return invocation.getMethod().equals(candidate.getMethod());return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;if (invocations.size() != 1 && chunk.size() > 0) {
marker.markVerified(chunk.get(0), wantedMatcher);return answers.size() == 1 ? answers.peek().answer(invocation) : answers.poll().answer(invocation);"***",
"For your reference, here is the list of all invocations ([?] - means unverified).",
StringBuilder sb = new StringBuilder();public void noMoreInteractionsWanted(PrintableInvocation undesired) {
));
public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {
Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());
new Reporter().noMoreInteractionsWanted(unverified);
public void verify(VerificationData data) {
reporter.noMoreInteractionsWanted(unverified);return (Class) actual;
assertEquals(m.getGenericType(field("one")), String.class);
assertEquals(m.getGenericType(field("two")), Integer.class);
assertEquals(m.getGenericType(field("map")), Double.class);
assertEquals(m.getGenericType(field("nonGeneric")), Object.class);import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
Type generic = field.getGenericType();
if (generic != null && generic instanceof ParameterizedType) {
Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
return ArgumentCaptor.forClass(typeToClass(actual));
return ArgumentCaptor.forClass(Object.class);    
private Class typeToClass(Type actual) {
if (actual.equals(Double.class)) {
return Double.class;
return Object.class;annotationEngine.process(clazz, testClass);
return ArgumentCaptor.forClass(Object.class); // Object.class due toimport org.mockito.exceptions.base.MockitoException;
import org.mockito.Mockito;import org.mockito.verification.VerificationWithTimeout;
public static Timeout timeout(int millis) {
return new VerificationWithTimeout(millis, VerificationModeFactory.atLeastOnce());
package org.mockito.verification;
import org.mockito.Mockito;
public interface Timeout extends VerificationMode {
public VerificationMode times(int wantedNumberOfInvocations);
public VerificationMode never();
public VerificationMode atLeastOnce();
public VerificationMode atLeast(int minNumberOfInvocations);
public VerificationMode atMost(int maxNumberOfInvocations);
public VerificationMode only();       
package org.mockito.verification;
import org.mockito.internal.verification.VerificationModeFactory;
import org.mockito.internal.verification.VerificationWithTimeoutImpl;
import org.mockito.internal.verification.api.VerificationData;
public class VerificationWithTimeout implements Timeout {
VerificationWithTimeoutImpl impl;
public VerificationWithTimeout(int millis, VerificationMode delegate) {
this(10, millis, delegate);
VerificationWithTimeout(int treshhold, int millis, VerificationMode delegate) {
this.impl = new VerificationWithTimeoutImpl(treshhold, millis, delegate);
public void verify(VerificationData data) {
impl.verify(data);
public VerificationMode atLeast(int minNumberOfInvocations) {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeast(minNumberOfInvocations));
public VerificationMode atLeastOnce() {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeastOnce());
public VerificationMode atMost(int maxNumberOfInvocations) {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atMost(maxNumberOfInvocations));
public VerificationMode never() {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(0));
public VerificationMode only() {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.only());
public VerificationMode times(int wantedNumberOfInvocations) {
return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(wantedNumberOfInvocations));
VerificationWithTimeout t = new VerificationWithTimeout(1, 3, mode);
VerificationWithTimeout t = new VerificationWithTimeout(1, 2, mode);
VerificationWithTimeout t = new VerificationWithTimeout(1, 2, mode);
VerificationWithTimeout t = new VerificationWithTimeout(1, 4, mode);
VerificationWithTimeout t = new VerificationWithTimeout(25, 50, mode);
assertCorrectMode(t.atLeastOnce(), VerificationWithTimeout.class, 50, 25, AtLeast.class);
assertCorrectMode(t.atLeast(5), VerificationWithTimeout.class, 50, 25, AtLeast.class);
assertCorrectMode(t.times(5), VerificationWithTimeout.class, 50, 25, Times.class);
assertCorrectMode(t.never(), VerificationWithTimeout.class, 50, 25, Times.class);
assertCorrectMode(t.only(), VerificationWithTimeout.class, 50, 25, Only.class);
assertCorrectMode(t.atMost(10), VerificationWithTimeout.class, 50, 25, AtMost.class);
assertEquals(expectedTimeout, ((VerificationWithTimeout) t).impl.getTimeout());
assertEquals(expectedTreshold, ((VerificationWithTimeout) t).impl.getTreshhold());
assertEquals(expectedDelegateType, ((VerificationWithTimeout) t).impl.getDelegate().getClass());
verify(mock, never()).clear();
verify(mock, timeout(40).atLeast(1)).clear();if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
verificationMode.verify(data);
return null;
mockingProgress.verificationStarted(mode);public void cannotStubVoidMethodWithAReturnValue() {
"Cannot stub a void method with a return value!",
"    doThrow(exception).when(mock).someVoidMethod();"
reporter.cannotStubVoidMethodWithAReturnValue();
assertContains("Cannot stub a void method with a return value", e.getMessage());import static org.mockito.internal.stubbing.defaultanswers.Answers.*;
import org.mockito.internal.stubbing.defaultanswers.Answers;
Answers answer() default RETURNS_DEFAULTS;
import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_MOCKS;
import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_DEFAULTS;
import java.util.*;
import org.mockito.*;import org.mockito.internal.stubbing.*;
import org.mockito.internal.verification.VerificationModeFactory;
import java.util.List;
public void verifyNoMoreInteractions() {
VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), null);
VerificationModeFactory.noMoreInteractions().verify(data);
void verifyNoMoreInteractions();
import org.mockito.stubbing.*;
import java.util.Arrays;
import java.util.List;
mockUtil.getMockHandler(mock).verifyNoMoreInteractions();
public class NoMoreInteractions implements VerificationMode {
import org.junit.Ignore;class InOrderImpl implements InOrder {
return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));
private boolean verifiedInOrder;
public boolean isVerifiedInOrder() {
return verifiedInOrder;
throw new RuntimeException("hashCode() is not implemented");
void markVerifiedInOrder() {
markVerified();
this.verifiedInOrder = true;
public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted) {
i.markVerifiedInOrder();
public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {
List<Invocation> unverified = removeVerifiedInOrder(invocations);
public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {
List<Invocation> unverified = removeVerifiedInOrder(invocations);
return this.findAllMatchingUnverifiedChunks(invocations, wanted);
public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations) {
LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder());
private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations) {
if (i.isVerifiedInOrder()) {
return !invocation.isVerifiedInOrder();
public void verifyInOrder(VerificationData data) {
AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker();
missingInvocation.check(allInvocations, wanted, this);
private final List<Object> mocksToBeVerifiedInOrder;
public InOrderWrapper(VerificationInOrderMode mode, List<Object> mocksToBeVerifiedInOrder) {
this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;
List<Invocation> allInvocations = new AllInvocationsFinder().find(mocksToBeVerifiedInOrder);
mode.verifyInOrder(new VerificationDataImpl(allInvocations, data.getWanted()));
public void verifyInOrder(VerificationData data) {
missingInvocation.check(allInvocations, wanted, this);
numberOfCalls.check(allInvocations, wanted, wantedCount);
void verifyInOrder(VerificationData data);
import org.mockito.internal.invocation.InvocationMarker;
List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);
invocationMarker.markVerifiedInOrder(chunk, wanted);
public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {
List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);
Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations);
import org.mockito.internal.invocation.InvocationMarker;
public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {
List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount);
invocationMarker.markVerifiedInOrder(chunk, wanted);
assertFalse(i.isVerifiedInOrder());
marker.markVerifiedInOrder(Arrays.asList(i), im);
assertTrue(i.isVerifiedInOrder());
public void shouldNotBeACitizenOfHashes() {
try {
map.put(invocation, "one");
fail();
assertEquals("hashCode() is not implemented", e.getMessage());
public void shouldMarkVerifiedWhenMarkingVerifiedInOrder() throws Exception {
assertFalse(invocation.isVerified());
assertFalse(invocation.isVerifiedInOrder());
invocation.markVerifiedInOrder();
assertTrue(invocation.isVerified());
assertTrue(invocation.isVerifiedInOrder());
List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));
simpleMethodInvocation.markVerifiedInOrder();
allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));
simpleMethodInvocationTwo.markVerifiedInOrder();
allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));
List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2);
List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1);
List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1);
Invocation previous = finder.findPreviousVerifiedInOrder(invocations);
simpleMethodInvocation.markVerifiedInOrder();
simpleMethodInvocationTwo.markVerifiedInOrder();
previous = finder.findPreviousVerifiedInOrder(invocations);
public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {
public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {
public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations) {
checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());
checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());
checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());
checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());
public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {
checker.check(invocations, wanted, 0);
checker.check(invocations, wanted, 1);
checker.check(invocations, wanted, 4);
checker.check(invocations, wanted, 1);
assertFalse(invocation.isVerifiedInOrder());
checker.check(invocations, wanted, 1);
assertTrue(invocation.isVerifiedInOrder());try {
new Equals(null).hashCode();
fail();public @interface InjectMock {import org.mockito.MockitoAnnotations.Mock;InjectMock injectMockAnnotation = (InjectMock) field.getAnnotation(InjectMock.class);
import java.util.*;
import org.mockito.internal.stubbing.StubbedInvocationMatcher;
import org.junit.runner.Runner;
import static org.mockito.Matchers.notNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import org.mockito.internal.util.SimpleMockitoLogger;
import java.util.Arrays;
import static java.util.Arrays.asList;
import static org.mockito.Mockito.only;
import static org.mockito.Mockito.verify;
private SimpleMockitoLogger logger = new SimpleMockitoLogger();
import static org.mockito.Matchers.any;
import org.fest.assertions.Assertions;
import org.mockito.internal.matchers.*;
import static org.mockito.Matchers.anyVararg;
import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;
import java.lang.reflect.Method;
import static java.util.Arrays.asList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.mockito.Mock;
import org.mockito.internal.invocation.Invocation;
import java.util.LinkedList;
import java.util.List;
import org.mockitousage.IMethods;
private IMethods mock;
import org.mockito.internal.stubbing.defaultanswers.Answers;
public List getMySpy() {
import org.junit.Before;
import org.mockito.Matchers;
import org.mockitousage.IMethods;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.verify;
import static org.mockitousage.junitrunner.Filters.methodNameContains;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Filter;
import org.mockitoutil.TestBase;
import org.junit.Ignore;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
import org.mockito.internal.verification.DummyVerificationMode;
import org.mockitousage.IMethods;
import java.util.List;reporter.wantedButNotInvoked(wanted);
import org.junit.Ignore;
import org.mockito.exceptions.verification.ArgumentsAreDifferent;
String expected = 
"\n" +
"Arguments are different!" +
"\n" +
"IMethods.simpleMethod(999);"; 
assertEquals(expected, e.getMessage());
assertEquals(null, e.getCause());class SimpleTest {
SimpleTest test = new SimpleTest();
SimpleTest test = new SimpleTest();
private SuperUnderTest superUnderTestWithoutInjection = new SuperUnderTest();
class SuperUnderTest {
class BaseUnderTest extends SuperUnderTest {
class OtherBaseUnderTest extends SuperUnderTest {
class SubUnderTest extends BaseUnderTest {public @interface Mock {}
private static final MockitoCore MOCKITO_CORE = new MockitoCore();
public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
public static final Answer<Object> RETURNS_DEEP_STUBS = new ReturnsDeepStubs();
public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
public @interface Mock {}
private static void scan(Object testClass, Class<?> clazz) {
boolean alreadyAssigned = false;
for(Annotation annotation : field.getAnnotations()) {
Object mock = annotationEngine.createMockFor(annotation, field);
if (mock != null) {
throwIfAlreadyAssigned(field, alreadyAssigned);
alreadyAssigned = true;
boolean wasAccessible = field.isAccessible();
field.setAccessible(true);
try {
field.set(testClass, mock);
throw new MockitoException("Problems setting field " + field.getName() + " annotated with "
+ annotation, e);
field.setAccessible(wasAccessible);
private static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {
throw new MockitoException("You cannot have more than one Mockito annotation on a field!\n" +
"The field '" + field.getName() + "' has multiple Mockito annotations.\n" +
"For info how to use annotations see examples in javadoc for MockitoAnnotations class.");
import org.mockito.internal.configuration.DefaultAnnotationEngine;
return new DefaultAnnotationEngine();
import org.mockito.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
if (annotation instanceof Mock || annotation instanceof org.mockito.MockitoAnnotations.Mock) {
return Mockito.mock(field.getType(), field.getName());
Class<?> type = field.getType();
if (!ArgumentCaptor.class.isAssignableFrom(type)) {
throw new MockitoException("@Captor field must be of the type ArgumentCaptor.\n" +
"Field: '" + field.getName() + "' has wrong type\n" +
"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.");
return ArgumentCaptor.forClass(Object.class);
if (annotation instanceof Spy) {
throw new IllegalArgumentException("@Spy is not yet supported.");
return null;
return warnings == null || warnings.isEmpty(); 
import org.mockito.internal.configuration.DefaultAnnotationEngine;
return new DefaultAnnotationEngine() {
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
public class JUnit44RunnerTest extends TestBase {
import static org.mockito.Mockito.verify;
import static org.mockitousage.junitrunner.Filters.methodNameContains;
import org.mockitoutil.TestBase;
public class JUnit45RunnerTest extends TestBase {ArgumentCaptor<List> missingGenerics;
assertEquals(
"Cannot have more than one Mockito annotation on field. For info how to use annotations see examples in javadoc for MockitoAnnotations class.",
e.getMessage());throw new MockitoException("Problems initiating mocks annotated with " + annotation, e);
import java.lang.reflect.Field;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.configuration.AnnotationEngine;
return null;import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;
package org.mockito.internal.verification.api;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;
import org.mockito.internal.util.reflection.Whitebox;
import org.mockito.internal.verification.api.VerificationMode;
import org.mockito.internal.verification.api.VerificationMode;Runner runner;
import org.junit.runner.Runner;
private Runner runner;
public interface RunnerImpl {
public class MockitoJUnitRunner extends Runner {
import static org.mockito.Mockito.*;
public void shouldInitMocksUsingRunner() {
list.add("test");
verify(list).add("test");
import static org.mockito.Mockito.*;"Also, this error might show up because you stub final/private/equals() or hashCode() method.",
"Also, this error might show up because you verify final or private methods.",
"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode() methods.",                
public void cannotVerifyEqualsOrHashCode() {
throw new MockitoException(join(
"Mockito cannot verify equals() and hashCode()",
"Mockito defines and depends upon a specific implementation of these methods. Redefining them might break Mockito. Not to mention that verifying equals() or hashCode() most likely hints awkward design (hard to explain in a short exception message. Trust me...)"
));
if (o.isEqualsMethod(wanted.getMethod())) {
new Reporter().cannotVerifyEqualsOrHashCode();
List mock;
public void shouldOrdinaryMethodBeVerifiable() throws Exception {
VerificationDataImpl v = new VerificationDataImpl(null, new InvocationBuilder().toInvocationMatcher());
v.assertWantedIsVerifiable();
public void shouldNotBreakWhenWantedIsNull() throws Exception {
VerificationDataImpl v = new VerificationDataImpl(new LinkedList<Invocation>(), null);
v.assertWantedIsVerifiable();
public void shouldEqualsBeNotVerifiable() throws Exception {
InvocationMatcher equals = new InvocationMatcher(invocationOf(Object.class, "equals", new Object()));
try {
new VerificationDataImpl(null, equals);
fail();
public void shouldNotVerifyToString() {
verify(mock).toString();
public void shouldNotVerifyHashCode() {
public void shouldNotVerifyEquals() {private void addAnswer(Answer answer, boolean isConsecutive) {if (m instanceof CapturesArguments) {
import org.mockito.internal.matchers.AnyVararg;
import org.mockito.internal.matchers.CapturingMatcher;
import org.mockito.internal.matchers.Equals;
import org.mockito.internal.matchers.NotNull;
public void shouldBuildEqualsMatchersWhenNullPassed() throws Exception {
InvocationMatcher m = new InvocationMatcher(new InvocationBuilder().args("foo").toInvocation(), null);
assertThat(m.getMatchers(), hasExactlyInOrder(new Equals("foo")));
void varargs(Object ... object);
void varargs(String ... string);
public void varargs(Object... object) {
public void varargs(String... string) {
IVarArgs mock;
public void setup() {
mock = Mockito.mock(IVarArgs.class);Object one = "1243";
Object two = "1243";
Object three = "1243";return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());
Object one = new String("1243");
Object two = new String("1243");
Object three = new String("1243");return MOCKITO_CORE.mock(classToMock, mockSettings, true);
.defaultAnswer(CALLS_REAL_METHODS), true); 
public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
if (shouldResetOngoingStubbing) {
mockingProgress.resetOngoingStubbing();
return mockitoCore.mock(clazz, new MockSettingsImpl().defaultAnswer(this), false);
package org.mockito.internal;
import org.junit.Test;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
import org.mockitoutil.TestBase;
public class MockitoCoreTest extends TestBase {
MockingProgress mockingProgress = new ThreadSafeMockingProgress();
MockitoCore core = new MockitoCore();
public void shouldResetOngoingStubbingWhenAsked() throws Exception {
core.mock(Object.class, new MockSettingsImpl(), true);
assertNull(mockingProgress.pullOngoingStubbing());
public void shouldNOTResetOngoingStubbingWhenAsked() throws Exception {
core.mock(Object.class, new MockSettingsImpl(), false);
assertNull(mockingProgress.pullOngoingStubbing());
public void shouldResetOngoingStubbingOnMock() {
mock.booleanReturningMethod();
mock(IMethods.class);
assertOngoingStubbingIsReset();
public void shouldResetOngoingStubbingOnVerifyNoMoreInteractions() {
mock.booleanReturningMethod();
IMethods mock2 = mock(IMethods.class);
verifyNoMoreInteractions(mock2);
assertOngoingStubbingIsReset();return MOCKITO_CORE.mock(classToMock, mockSettings);
.defaultAnswer(CALLS_REAL_METHODS)); 
public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
mockingProgress.resetOngoingStubbing();
return mockitoCore.mock((Class) clazz, new MockSettingsImpl().defaultAnswer(this));import java.util.Arrays;
import java.io.Serializable;
return this.extraInterfaces(Serializable.class);
return
extraInterfaces != null
&& Arrays.asList(extraInterfaces).contains(Serializable.class);
Class<?>[] ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
import java.io.Serializable;
import org.junit.Test;
import org.mockito.exceptions.base.MockitoException;
import org.mockitoutil.TestBase;
import org.fest.assertions.Assertions;
Assertions.assertThat(mockSettingsImpl.getExtraInterfaces()).contains(Serializable.class);public class StubbedInvocationMatcher extends InvocationMatcher implements Answer {
public class AnswerReturnValuesAdapter implements Answer<Object> {
public class CallsRealMethods implements Answer<Object> {
public class DoesNothing implements Answer<Object> {
public class Returns implements Answer<Object> {
public class ThrowsException implements Answer<Object> {
public class ReturnsEmptyValues implements Answer<Object> {
public class ReturnsMocks implements Answer<Object> {
public class ReturnsMoreEmptyValues implements Answer<Object> {
public class ReturnsSmartNulls implements Answer<Object> {
import java.io.Serializable;
public interface Answer<T> extends Serializable {
final String string = "return value";
when(mock.objectArgMethod(anyString())).thenAnswer(new Answer<Object>() {
public Object answer(InvocationOnMock invocation) {
invocation.getArguments();
invocation.getMock();
return string;
assertEquals(string, readObject.objectArgMethod(""));public class DebuggingTestCasesTest {return methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs;if (this.wanted == null) {
return actual == null;
return wanted.equals(actual);return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
return reportMatcher(new Equals(value)).<T>returnNull();
return reportMatcher(new Same(value)).<T>returnNull();
return primitiveValueFor(clazz);
public static <T> T primitiveValueFor(Class<T> primitiveType) {
public class NPEWithIsAClassMatcherTest extends TestBase {public RunnerImpl create(Class<?> klass) {
, t);
Class<?> runnerClass = Class.forName(runnerClassName);
Constructor<?> constructor = runnerClass.getConstructor(Class.class.getClass());
return (RunnerImpl) constructor.newInstance(constructorParam);   
public ConsoleSpammingMockitoJUnitRunner(Class<?> klass) {
this(klass, new MockitoLoggerImpl(), new RunnerFactory().create(klass));
ConsoleSpammingMockitoJUnitRunner(Class<?> klass, MockitoLogger logger, RunnerImpl runnerImpl) {
public MockitoJUnit44Runner(Class<?> klass) {
public MockitoJUnitRunner(Class<?> klass) {
public VerboseMockitoJUnitRunner(Class<?> klass) {
this(klass, new RunnerFactory().create(klass));
VerboseMockitoJUnitRunner(Class<?> klass, RunnerImpl runnerImpl) {
public void shouldCreateRunnerForJUnit44() {
public void shouldCreateRunnerForJUnit45() {
public void shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound() {
public void shouldSaySomethingMeaningfulWhenNoTestMethods() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {
runner = new ConsoleSpammingMockitoJUnitRunner(this.getClass(), loggerStub, new RunnerImplStub() {import org.junit.Ignore;
public void shouldFailFastWhenCallingRealMethodOnInterface2() throws Exception {"Cannot call real methond on java interface. Interface does not have any implementation!",
"  //correct:",return methodName;
return returnType;
return parameterTypes;
return exceptionTypes;
return isVarArgs;CreationValidator validator = new CreationValidator();
public void shouldIgnoreIfExtraInterfacesAreNull() throws Exception {
CreationValidator validator = new CreationValidator();
validator.validateExtraInterfaces(IMethods.class, (Class[]) null);
public void shouldNotAllowFinalClasses() throws Exception {
CreationValidator validator = new CreationValidator();
try {
validator.validateType(FinalClass.class);
fail();
assertContains("Cannot mock/spy", e.getMessage());private final StackTraceElement firstTraceElement;
StackTraceFilter filter = new StackTraceFilter();
this.firstTraceElement = filter.filter(stackTrace, false)[0];
return "-> at " + this.firstTraceElement.toString();public List<Invocation> getAllInvocations(List<? extends Object> mocks) {
int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());
assert comparison != 0 : "sequence number has to be globally unique";
return comparison;public class MockitoRunnerBreaksWhenNoTestMethodsTest extends TestBase {}import org.mockito.internal.matchers.Any;
import org.mockito.internal.matchers.Contains;
import org.mockito.internal.matchers.EndsWith;
import org.mockito.internal.matchers.Equals;
import org.mockito.internal.matchers.InstanceOf;
import org.mockito.internal.matchers.Matches;
import org.mockito.internal.matchers.NotNull;
import org.mockito.internal.matchers.Null;
import org.mockito.internal.matchers.Same;
import org.mockito.internal.matchers.StartsWith;
&& (argumentsMatch(actual.getArguments()));
private boolean argumentsMatch(Object[] actualArgs) {
if (actualArgs.length != matchers.size()) {
return false;
for (int i = 0; i < actualArgs.length; i++) {
if (!matchers.get(i).matches(actualArgs[i])) {
return false;
return true;
return argumentsMatch(actualArgs);
final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());        
if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {
return true;
return false;
public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments {
if (actualMatcher instanceof ContainsExtraTypeInformation) {
return ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);
return false;
import static java.util.Arrays.*;
import static org.mockitoutil.ExtraMatchers.*;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) Arrays.asList(new Equals("1"), capturingMatcher));        
package org.mockitousage.bugs;
import org.junit.Ignore;
public void shouldVerifyCorrectlyWithAnyObjectSubstitutingVarargs() {
verify(table, times(2)).newRow(anyString(), (String[]) anyObject());
public void shouldVerifyCorrectlyWithVarargs() {
package org.mockitousage.bugs;
import org.junit.Ignore;
public void shouldAllowAnyObjectForVarArgs() {
verify(mock).run((String[]) anyObject());
verify(mock).run(new String[] {anyObject()});
public void shouldAllowAnyObjectForVarArgsStubbing() {
when(mock.run((String[]) anyObject())).thenReturn("foo");verify(mock, atLeast(1)).add(anyString());if (wantedNumberOfInvocations <= 0) {
throw new MockitoException("Negative value or zero are not allowed here");
assertEquals("Negative value or zero are not allowed here", e.getMessage());public class AtLeastXNumberOfInvocationsCheckerTest {public void shouldNotAllowNegativeNumberOfMinimumInvocations() throws Exception {
try {
VerificationModeFactory.atLeast(-50);
fail();
assertEquals("Negative value or zero are not allowed here", e.getMessage());ArgumentCaptor<String> argument = new ArgumentCaptor<String>();new StateMaster().validate();private CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
return null;
public static Object primitiveWrapperOf(Class<?> type) {
return wrapperReturnValues.get(type);
ArgumentCaptor<Integer> argument = new ArgumentCaptor<Integer>();import java.lang.reflect.Method;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.cglib.proxy.MethodProxy;
import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;
import org.mockito.internal.progress.SequenceNumber;
public class MockHandler<T> implements MethodInterceptor {
private final MockitoStubber mockitoStubber;
private final MatchersBinder matchersBinder;
private final MockingProgress mockingProgress;
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));
Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));
Answer<?> stubbedAnswer = mockitoStubber.findAnswerFor(invocation);
if (!invocation.isVoid() && stubbedAnswer == null) {
if (stubbedAnswer != null) {
return stubbedAnswer.answer(invocation);
public class MethodInterceptorFilter<T extends MethodInterceptor> implements MethodInterceptor {
private final T delegate;
public MethodInterceptorFilter(Class toMock, T delegate) {
this.delegate = delegate;
return delegate.intercept(proxy, method, args, methodProxy);
public T getDelegate() {
return delegate;
public void markVerified() {
verified = true;
public void markVerifiedInOrder() {
this.markVerified();
this.verifiedInOrder = true;
public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation {
public class CapturingMatcher<T> extends ArgumentMatcher<T> {
this.arguments.add(argument);
return (T) arguments;
public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation {
public Answer<?> findAnswerFor(Invocation invocation) {
MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);
MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>>(Object.class, newMockHandler);
return getInterceptor(mock).getDelegate();
private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {
return (MethodInterceptorFilter<MockHandler<T>>) callback;
for (Invocation i : found) {
i.markVerified();
for (Invocation i : actualInvocations) {
i.markVerified();
for (Invocation i : chunk) {
i.markVerifiedInOrder();
for (Invocation i : actualInvocations) {
i.markVerified();
for (Invocation i : chunk) {
i.markVerifiedInOrder();
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.MockingProgressImpl;
MockingProgress state = new MockingProgressImpl();
state.verificationStarted(VerificationModeFactory.atLeastOnce());
MockHandler handler = new MockHandler(null, state, new ExceptionThrowingBinder(), null);
handler.intercept(null, String.class.getDeclaredMethod("toString"), new Object[]{}, null);
assertNull(state.pullVerificationMode());
private class ExceptionThrowingBinder extends MatchersBinder {
public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
throw new InvalidUseOfMatchersException("");import org.mockito.internal.util.reflection.FieldCopier;
import org.mockito.internal.util.reflection.LenientCopyTool;
package org.mockitousage.junitrunner;
import java.util.List;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.VerboseMockitoJUnitRunner;
import org.mockitoutil.TestBase;
public class VerboseJUnitRunnerTest extends TestBase {
public void shouldInitMocksUsingRunner() {
private void executeSystem(int idx) {
Object first = list.get(idx + 1);
listTwo.add(first);return StringDescription.toString(m).equals(arg.toString());Field createInfoField = methodProxy.getClass().getDeclaredField("createInfo");
private final RealMethod realMethod;
public class CGLIBProxyRealMethod implements RealMethod {
public class FilteredCGLIBProxyRealMethod implements RealMethod {&& (argumentsMatch(actual.getArguments()) || argumentsMatch(actual.getRawArguments()));
verify(table, times(2)).newRow(anyString(), (String[]) anyObject());import org.mockito.internal.reporting.PrintingFriendlyInocation;
public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInocation {
import org.mockito.internal.reporting.PrintingFriendlyInocation;
public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInocation {
public boolean printsInMultilines() {        
return toString().contains("\n");
public interface PrintingFriendlyInocation {
public SmartPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual, Integer ... toBePrintedVerbosely) {
import org.mockito.internal.reporting.PrintingFriendlyInocation;
PrintingFriendlyInocation withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
PrintingFriendlyInocation withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());
import org.mockito.internal.reporting.PrintingFriendlyInocation;
private PrintingFriendlyInocation multi;
private PrintingFriendlyInocation shortie;public interface CanPrintInMultilines {
String toString();
boolean printsInMultilines();
String toMultilineString();
public class Invocation implements PrintableInvocation, InvocationOnMock, CanPrintInMultilines {
return toString(argumentsToMatchers(), false);
public boolean printsInMultilines() {
return toString().contains("\n");
public String toMultilineString() {
return toString(argumentsToMatchers(), true);
protected String toString(List<Matcher> matchers, boolean forceMultiline) {
String invocation = method + getArgumentsLine(matchers);
if (forceMultiline || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {
return method + getArgumentsBlock(matchers);
private String getArgumentsLine(List<Matcher> matchers) {
Description result = new StringDescription();
result.appendList("(", ", ", ");", matchers);
return result.toString();
private String getArgumentsBlock(List<Matcher> matchers) {
Description result = new StringDescription();
result.appendList("(\n    ", ",\n    ", "\n);", matchers);
return result.toString();
return method.getReturnType() == String.class && method.getParameterTypes().length == 0 && method.getName().equals("toString");
public class InvocationMatcher implements PrintableInvocation, CanPrintInMultilines {
return invocation.toString(matchers, false);
public String toMultilineString() {
return invocation.toString(matchers, true);
public class Equals extends ArgumentMatcher<Object> {
appendQuoting(description);
if (wanted == null) {
description.appendText("null");
description.appendText(wanted.toString());
appendQuoting(description);
private void appendQuoting(Description description) {
description.appendText("\"");
description.appendText("'");
return this.wanted == null && other.wanted == null
|| this.wanted != null
&& this.wanted.equals(other.wanted);
public class LocalizedMatcher implements Matcher {
import org.mockito.internal.invocation.CanPrintInMultilines;
public SyncingPrinter(CanPrintInMultilines wanted, CanPrintInMultilines actual) {
if (wanted.printsInMultilines() || actual.printsInMultilines()) {
this.wanted = wanted.toMultilineString();
this.actual = actual.toMultilineString();
this.wanted = wanted.toString();
this.actual = actual.toString();
CanPrintInMultilines withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
CanPrintInMultilines withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());
import org.mockito.internal.invocation.CanPrintInMultilines;
private CanPrintInMultilines multi;
private CanPrintInMultilines normal;
public void setup() {
multi = new CanPrintInMultilinesStub(true, "multi", "normal");
normal = new CanPrintInMultilinesStub(false, "multi", "normal");
public void shouldPrintBothInMultilinesWhenAtLeastOneIsMulti() {
SyncingPrinter printer = new SyncingPrinter(multi, normal);
assertEquals("multi", printer.getWanted().toString());
assertEquals("multi", printer.getActual().toString());
printer = new SyncingPrinter(normal, multi);
assertEquals("multi", printer.getWanted().toString());
assertEquals("multi", printer.getActual().toString());
printer = new SyncingPrinter(multi, multi);
assertEquals("multi", printer.getWanted().toString());
assertEquals("multi", printer.getActual().toString());
public void shouldPrintBothInSingleLine() {
SyncingPrinter printer = new SyncingPrinter(normal, normal);
assertEquals("normal", printer.getWanted().toString());
assertEquals("normal", printer.getActual().toString());
static class CanPrintInMultilinesStub implements CanPrintInMultilines {
private final boolean printsInMultilines;
private final String multilineString;
private final String normalString;
public CanPrintInMultilinesStub(boolean printsInMultilines, String multilineString, String normalString) {
this.printsInMultilines = printsInMultilines;
this.multilineString = multilineString;
this.normalString = normalString;
public boolean printsInMultilines() {
return printsInMultilines;
public String toMultilineString() {
return multilineString;
public String toString() {
return normalString;
protected static Invocation invocationOf(Class<?> type, String methodName) throws NoSuchMethodException {
new Class[0]), new Object[0], 1, null);.defaultAnswer(RETURNS_DEFAULTS));
Answer<?> answer = mockitoStubber.findAnswerFor(invocation);
if (!invocation.isVoid() && answer == null) {
if (answer != null) {
return answer.answer(invocation);
return mockSettings.getDefaultAnswer().answer(invocation);
Object ret = methodProxy.invokeSuper(proxy, args);
public boolean isSpy() {
return spiedInstance != null;
public void shouldKnowIfIsASpy() throws Exception {
mockSettingsImpl.spiedInstance(new Object());
assertTrue(mockSettingsImpl.isSpy());
public void shouldKnowNotBeASpyIfNoSpiedInstance() throws Exception {
mockSettingsImpl.spiedInstance(null);
assertFalse(mockSettingsImpl.isSpy());
import org.junit.After;
import org.mockito.Mockito;
public void validateMockitoUsage() {
Mockito.validateMockitoUsage();import org.mockito.internal.returnvalues.ReturnsEmptyValues;
import org.mockito.internal.returnvalues.GloballyConfiguredAnswer;
import org.mockito.internal.returnvalues.ReturnsMocks;
import org.mockito.internal.returnvalues.ReturnsMoreEmptyValues;
import org.mockito.internal.returnvalues.ReturnsSmartNulls;
import org.mockito.internal.returnvalues.ReturnsEmptyValues;
import org.mockito.internal.returnvalues.ReturnsEmptyValues;
public void sayThatGetReturnValuesIsNowDeprecated() {
throw new MockitoException(join( 
"getReturnValues() is not used by the framework ever since verion 1.8", 
"Please implement getDefaultBehavior() instead",
"Sorry for inconvenience"));
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
import org.mockito.internal.returnvalues.ReturnsEmptyValuesTest;
private Answer<Object> overriddenReturnValues = null;
public void overrideReturnValues(Answer<Object> returnValues) {
this.overriddenReturnValues = returnValues;
if (overriddenReturnValues == null) {
return overriddenReturnValues;
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
ReturnsMocks returnValues = new ReturnsMocks();
assertEquals(false, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
assertEquals((char) 0, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
assertEquals(0, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));
assertEquals(0, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));
assertEquals(0, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));
assertEquals(0, returnValues.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));
package org.mockito.internal.returnvalues;
package org.mockito.internal.returnvalues;
Answer<Object> returnValues = new ReturnsSmartNulls();
assertEquals(false  ,   returnValues.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));
assertEquals((char) 0,  returnValues.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));
assertEquals(0,         returnValues.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));
assertEquals(0,         returnValues.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));
assertEquals(0,         returnValues.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));
assertEquals(0,         returnValues.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));
Answer<Object> returnValues = new ReturnsSmartNulls();
Foo smartNull = (Foo) returnValues.answer(invocationOf(Foo.class, "get"));
Answer<Object> returnValues = new ReturnsSmartNulls();
Foo smartNull = (Foo) returnValues.answer(invocationOf(Foo.class, "get"));
public void shouldFailWhenReturnValueSetForVoidMethod() throws Throwable {
public void shouldMaintainPreviousReturnValuesStrategy() {
ConfigurationAccess.getConfig().overrideReturnValues(new Answer<Object>() {
public class StubbingConsecutiveReturnValuesTest extends TestBase {
public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {
ConfigurationAccess.getConfig().overrideReturnValues(null);return MOCKITO_CORE.mock(classToMock, configureWith().defaultBehavior(RETURNS_DEFAULTS));
return MOCKITO_CORE.mock(classToMock, configureWith().name(name).defaultBehavior(RETURNS_DEFAULTS));
return MOCKITO_CORE.mock(classToMock, configureWith().defaultBehavior(returnValues));
return MOCKITO_CORE.mock((Class<T>) object.getClass(), configureWith().spiedInstance(object).defaultBehavior(RETURNS_DEFAULTS));
public static MockSettings configureWith() {
return new MockSettingsImpl();
Object optionalInstance = settings.getSpiedInstance();
if (optionalInstance != null) {
new LenientCopyTool().copyToMock(optionalInstance, mock);
import static org.mockito.Mockito.times;
Foo mock = mock(Foo.class, configureWith().extraInterfaces(IFoo.class, IBar.class));
mock(Foo.class, configureWith().extraInterfaces(IFoo.class, null));
mock(Foo.class, configureWith().extraInterfaces());
mock(Foo.class, configureWith().extraInterfaces((Class[]) null));
mock(Foo.class, configureWith().extraInterfaces(Foo.class));
mock(IMethods.class, configureWith().extraInterfaces(IMethods.class));
mock(IMethods.class, configureWith().extraInterfaces(List.class, null));
mock(IMethods.class, configureWith().extraInterfaces(LinkedList.class));
mock(IMethods.class, configureWith().extraInterfaces(IMethods.class));
mock(IMethods.class, configureWith().extraInterfaces());
mock(IMethods.class, configureWith().extraInterfaces((Class[]) null));Class<?>[] ancillaryTypes = settings.getExtraInterfaces();
Class<?>[] interfaces = ancillaryTypes == null ? new Class<?>[0] : ancillaryTypes;
T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, interfaces);
public void ensureMockIsAllTypes() {
public void shouldThrowWhenClassPassedAsInterface() {
ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeInterface.class, SomeClass.class);
public void shouldThrowWhenNullType() {
ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, (Class<?>) null);
public void ensureNoProblemsWithNullTypes() {
ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, (Class<?>[]) null);import org.mockito.exceptions.Reporter;
validateType(classToMock);
private static <T> void validateType(Class<T> classToMock) {
if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {
new Reporter().cannotMockFinalClass(classToMock);Class<? extends Object> classFrom = from.getClass();
Class<?> classTo = mock.getClass().getSuperclass();
assert classTo == classFrom : "Classes must have the same type: class from: " + classFrom + ", class to: " + classTo;
Field[] fieldsFrom = classFrom.getDeclaredFields();
Field[] fieldsTo = classTo.getDeclaredFields();
assert fieldsFrom.length == fieldsTo.length : "Objects should be of the same type";
for (int i = 0; i < fieldsFrom.length; i++) {
if (Modifier.isStatic(fieldsFrom[i].getModifiers())) {
fieldsFrom[i].setAccessible(true);
fieldsTo[i].setAccessible(true);
Object value = fieldsFrom[i].get(from);
fieldsTo[i].set(mock, value);
throw new UnableToCopyFieldValue(
"Unable to copy value from field: " + fieldsFrom[i] + 
" to field: " + fieldsTo[i], t); 
static class SomeObject {
public int hashCode() {
return 0;
public boolean equals(Object obj) {
if (this == obj) {
return true;
if (obj == null) {
return false;
if (getClass() != obj.getClass()) {
return false;
final SomeObject other = (SomeObject) obj;
if (defaultField == null) {
if (other.defaultField != null) {
return false;
return false;
if (finalField != other.finalField) {
return false;
if (instancePublicField == null) {
if (other.instancePublicField != null) {
return false;
return false;
if (privateField != other.privateField) {
return false;
if (privateTransientField != other.privateTransientField) {
return false;
if (protectedField == null) {
if (other.protectedField != null) {
return false;
return false;
return true;
class Person {package org.mockitousage;RunnerImpl runner = provider.newInstance("org.mockito.internal.runners.JUnit45AndUpRunnerImpl", this.getClass());import org.mockito.runners.MockitoJUnit44Runner;
import org.mockito.runners.MockitoJUnit44Runner;
import org.mockito.runners.MockitoJUnit44Runner;
package org.mockito.internal.runners;
package org.mockito.internal.runners;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.*;
import org.junit.internal.runners.*;
import org.junit.runner.*;
import org.junit.runner.manipulation.*;
import org.junit.runner.notification.*;
public class LegacyJUnitRunner extends Runner {
private final List<Method> fTestMethods;
private TestClass fTestClass;
private final TestCreationListener testStartedCallback;
public LegacyJUnitRunner(Class<?> klass,
TestCreationListener testStartedCallback)
throws InitializationError {
this.testStartedCallback = testStartedCallback;
fTestClass = new TestClass(klass);
fTestMethods = getTestMethods();
validate();
protected List<Method> getTestMethods() {
return fTestClass.getTestMethods();
protected void validate() throws InitializationError {
MethodValidator methodValidator = new MethodValidator(fTestClass);
methodValidator.validateMethodsForDefaultRunner();
methodValidator.assertValid();
public void run(final RunNotifier notifier) {
new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {
public void run() {
runMethods(notifier);
protected void runMethods(final RunNotifier notifier) {
for (Method method : fTestMethods) {
invokeTestMethod(method, notifier);
public Description getDescription() {
Description spec = Description.createSuiteDescription(getName(),
classAnnotations());
List<Method> testMethods = fTestMethods;
for (Method method : testMethods) {
spec.addChild(methodDescription(method));
return spec;
protected Annotation[] classAnnotations() {
return fTestClass.getJavaClass().getAnnotations();
protected String getName() {
return getTestClass().getName();
protected Object createTest() throws Exception {
Object test = getTestClass().getConstructor().newInstance();
testStartedCallback.testCreated(test);
return test;
protected void invokeTestMethod(Method method, RunNotifier notifier) {
Description description = methodDescription(method);
Object test;
try {
test = createTest();
testAborted(notifier, description, e.getCause());
return;
testAborted(notifier, description, e);
return;
TestMethod testMethod = wrapMethod(method);
new MethodRoadie(test, testMethod, notifier, description).run();
private void testAborted(RunNotifier notifier, Description description,
Throwable e) {
notifier.fireTestStarted(description);
notifier.fireTestFailure(new Failure(description, e));
notifier.fireTestFinished(description);
protected TestMethod wrapMethod(Method method) {
return new TestMethod(method, fTestClass);
protected String testName(Method method) {
return method.getName();
protected Description methodDescription(Method method) {
return Description.createTestDescription(getTestClass().getJavaClass(),
testName(method), testAnnotations(method));
protected Annotation[] testAnnotations(Method method) {
return method.getAnnotations();
public void filter(Filter filter) throws NoTestsRemainException {
for (Iterator<Method> iter = fTestMethods.iterator(); iter.hasNext();) {
Method method = iter.next();
if (!filter.shouldRun(methodDescription(method))) {
iter.remove();
if (fTestMethods.isEmpty()) {
throw new NoTestsRemainException();
public void sort(final Sorter sorter) {
Collections.sort(fTestMethods, new Comparator<Method>() {
public int compare(Method o1, Method o2) {
return sorter.compare(methodDescription(o1),
methodDescription(o2));
protected TestClass getTestClass() {
return fTestClass;
package org.mockito.internal.runners;
public interface TestCreationListener {
void testCreated(Object test);
import org.junit.internal.runners.*;
import org.junit.runner.*;
import org.junit.runner.notification.*;
import org.mockito.*;
import org.mockito.internal.runners.*;
public class MockitoJUnit44Runner extends Runner {
private LegacyJUnitRunner legacyRunner;
legacyRunner = new LegacyJUnitRunner(klass, new TestCreationListener() {
public void testCreated(Object test) {
MockitoAnnotations.initMocks(test);
public void run(final RunNotifier notifier) {
notifier.addListener(new FrameworkUsageValidator(notifier));
legacyRunner.run(notifier);
public Description getDescription() {
return legacyRunner.getDescription();
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.mockito.internal.runners.FrameworkUsageValidator;
public class MockitoJUnitRunner extends BlockJUnit4ClassRunner {
public MockitoJUnitRunner(Class<?> klass) throws InitializationError {
super(klass);
protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {
MockitoAnnotations.initMocks(target);
return super.withBefores(method, target, statement);
public void run(final RunNotifier notifier) {
notifier.addListener(new FrameworkUsageValidator(notifier));
super.run(notifier);
import org.mockito.internal.runners.FrameworkUsageValidator;
public void testGetLastUpdates() {
mock.simpleMethod();
import org.mockito.runners.MockitoJUnit44Runner;
public class JUnit4RunnerTest extends TestBase {assertContains("Argument value has not yet been captured", e.getMessage());private static Object[] expandVarArgs(final boolean isVarArgs,
final Object[] args) {
if (!isVarArgs || isVarArgs && args[args.length - 1] != null
&& !args[args.length - 1].getClass().isArray()) {
Object[] varArgs;  
varArgs = new Object[] {null};
return this.mock.equals(other.mock) && this.method.equals(other.method)
&& this.equalArguments(other.arguments);
return method.getReturnType() == String.class 
&& method.getParameterTypes().length == 0 
&& method.getName().equals("toString");return anyObject();final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate.getArguments());        "Also, this error might show up because you verify final method, equals() or hashcode() method.",
"Also, this error might show up because you stub a final method, equals() or hashcode() method.",
"Following methods *cannot* be stubbed/verified: final methods, equals() and hashcode().",                return isA(clazz);
assertEquals(null, mock.objectArgMethod(new Object()));&& argumentsMatch(actual);
private boolean argumentsMatch(Invocation actual) {
Object[] arguments = actual.getArguments();
if (arguments.length != matchers.size()) {
for (int i = 0; i < arguments.length; i++) {
if (!matchers.get(i).matches(arguments[i])) {
final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate);        
int expectedMatchersSize = invocation.getArguments().length;
import org.junit.Ignore;
import org.mockito.Mockito;
public void testVarargStubbing() {
VarargMethod mock = Mockito.mock(VarargMethod.class);Throwable filtered = throwable.fillInStackTrace();
filter.filterStackTrace(filtered);
throw filtered;import org.mockito.exceptions.verification.VerifcationInOrderFailure;
throw new VerifcationInOrderFailure(join(
throw new VerifcationInOrderFailure(join(
throw new VerifcationInOrderFailure(join(
public class VerifcationInOrderFailure extends MockitoAssertionError {
public VerifcationInOrderFailure(String message, Throwable cause) {
public VerifcationInOrderFailure(String message) {
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
public void testSomething() {}
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
public void shouldTooLittleInvocations() {
public void shouldTooManyInvocations() {
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;"\nYou have a NullPointerException here:",
"\nBecause this method was *not* stubbed correctly:",
"-> at " + location
package org.mockito.exceptions.cause;
import org.mockito.exceptions.base.MockitoException;
public class BecauseThisMethodWasNotStubbed extends MockitoException {
private static final long serialVersionUID = 1L;
public BecauseThisMethodWasNotStubbed(String message) {
super(message);
package org.mockito.exceptions.cause;
import org.mockito.exceptions.base.MockitoException;
public class UndesiredInvocation extends MockitoException {
private static final long serialVersionUID = 1L;
public UndesiredInvocation(String message) {
super(message);package org.mockito;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.hamcrest.Matcher;
import org.mockito.internal.matchers.Any;
import org.mockito.internal.matchers.Contains;
import org.mockito.internal.matchers.EndsWith;
import org.mockito.internal.matchers.Equals;
import org.mockito.internal.matchers.InstanceOf;
import org.mockito.internal.matchers.Matches;
import org.mockito.internal.matchers.NotNull;
import org.mockito.internal.matchers.Null;
import org.mockito.internal.matchers.Same;
import org.mockito.internal.matchers.StartsWith;
import org.mockito.internal.matchers.apachecommons.ReflectionEquals;
import org.mockito.internal.progress.HandyReturnValues;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;
public class Matchers {
private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();
public static boolean anyBoolean() {
return reportMatcher(Any.ANY).returnFalse();
public static byte anyByte() {
return reportMatcher(Any.ANY).returnZero();
public static char anyChar() {
return reportMatcher(Any.ANY).returnChar();
public static int anyInt() {
return reportMatcher(Any.ANY).returnZero();
public static long anyLong() {
return reportMatcher(Any.ANY).returnZero();
public static float anyFloat() {
return reportMatcher(Any.ANY).returnZero();
public static double anyDouble() {
return reportMatcher(Any.ANY).returnZero();
public static short anyShort() {
return reportMatcher(Any.ANY).returnZero();
public static <T> T anyObject() {
return (T) reportMatcher(Any.ANY).returnNull();
public static <T> T any(Class<T> clazz) {
return isA(clazz);
public static String anyString() {
return reportMatcher(Any.ANY).returnString();
public static List anyList() {
return reportMatcher(Any.ANY).returnList();
public static Map anyMap() {
return reportMatcher(Any.ANY).returnMap();
public static Collection anyCollection() {
return reportMatcher(Any.ANY).returnList();
public static <T> T isA(Class<T> clazz) {
return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
public static boolean eq(boolean value) {
return reportMatcher(new Equals(value)).returnFalse();
public static byte eq(byte value) {
return reportMatcher(new Equals(value)).returnZero();
public static char eq(char value) {
return reportMatcher(new Equals(value)).returnChar();
public static double eq(double value) {
return reportMatcher(new Equals(value)).returnZero();
public static float eq(float value) {
return reportMatcher(new Equals(value)).returnZero();
public static int eq(int value) {
return reportMatcher(new Equals(value)).returnZero();
public static long eq(long value) {
return reportMatcher(new Equals(value)).returnZero();
public static short eq(short value) {
return reportMatcher(new Equals(value)).returnZero();
public static <T> T eq(T value) {
return reportMatcher(new Equals(value)).<T>returnNull();
public static <T> T refEq(T value) {
return reportMatcher(new ReflectionEquals(value)).<T>returnNull();
public static <T> T same(T value) {
return reportMatcher(new Same(value)).<T>returnNull();
public static Object isNull() {
return reportMatcher(Null.NULL).returnNull();
public static Object notNull() {
return reportMatcher(NotNull.NOT_NULL).returnNull();
public static Object isNotNull() {
return notNull();
public static String contains(String substring) {
return reportMatcher(new Contains(substring)).returnString();
public static String matches(String regex) {
return reportMatcher(new Matches(regex)).returnString();
public static String endsWith(String suffix) {
return reportMatcher(new EndsWith(suffix)).returnString();
public static String startsWith(String prefix) {
return reportMatcher(new StartsWith(prefix)).returnString();
public static <T> T argThat(Matcher<T> matcher) {
return reportMatcher(matcher).<T>returnNull();
public static char charThat(Matcher<Character> matcher) {
return reportMatcher(matcher).returnChar();
public static boolean booleanThat(Matcher<Boolean> matcher) {
return reportMatcher(matcher).returnFalse();
public static byte byteThat(Matcher<Byte> matcher) {
return reportMatcher(matcher).returnZero();
public static short shortThat(Matcher<Short> matcher) {
return reportMatcher(matcher).returnZero();
public static int intThat(Matcher<Integer> matcher) {
return reportMatcher(matcher).returnZero();
public static long longThat(Matcher<Long> matcher) {
return reportMatcher(matcher).returnZero();
public static float floatThat(Matcher<Float> matcher) {
return reportMatcher(matcher).returnZero();
public static double doubleThat(Matcher<Double> matcher) {
return reportMatcher(matcher).returnZero();
private static HandyReturnValues reportMatcher(Matcher<?> matcher) {
return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);
package org.mockito.internal.progress;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
public class HandyReturnValues {
public byte returnZero() {
return 0;
public char returnChar() {
return 0;
public <T> T returnNull() {
return null;
public boolean returnFalse() {
return false;
public String returnString() {
return "";
public Map returnMap() {
return new HashMap();
public List returnList() {
return new LinkedList();
package org.mockitousage;
import java.io.IOException;
import java.nio.charset.CharacterCodingException;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.swing.text.ChangedCharSetException;
public interface IMethods {
boolean booleanReturningMethod();
Boolean booleanObjectReturningMethod();
byte byteReturningMethod();
Byte byteObjectReturningMethod();
short shortReturningMethod();
Short shortObjectReturningMethod();
char charReturningMethod();
Character charObjectReturningMethod();
int intReturningMethod();
Integer integerReturningMethod();
long longReturningMethod();
Long longObjectReturningMethod();
float floatReturningMethod();
Float floatObjectReturningMethod();
double doubleReturningMethod();
Double doubleObjectReturningMethod();
Object objectReturningMethod(Object ... objects);
Object objectReturningMethodNoArgs();
String oneArg(boolean value);
String oneArg(Boolean value);
String forBoolean(Boolean value);
String oneArg(byte value);
String oneArg(Byte value);
String forByte(Byte value);
String oneArg(short value);
String oneArg(Short value);
String forShort(Short value);
String oneArg(char value);
String oneArg(Character value);
String forCharacter(Character value);
String oneArg(int value);
String oneArg(Integer value);
String forInteger(Integer value);
String oneArg(long value);
String oneArg(Long value);
String forLong(Long value);
String oneArg(float value);
String oneArg(Float value);
String forFloat(Float value);
String oneArg(double value);
String oneArg(Double value);
String forDouble(Double value);
String oneArg(Object value);
String oneArg(String value);
String throwsNothing(boolean value);
String throwsIOException(int count) throws IOException;
String throwsError(int count);
String simpleMethod();
String differentMethod();
String differentMethod(String argument);
String otherMethod();
String simpleMethod(String argument);
String simpleMethod(Collection<?> collection);
String simpleMethod(Object argument);
String simpleMethod(int argument);
String simpleMethod(String argOne, Integer argTwo);
String simpleMethod(String one, Integer two, Integer three, Integer four, Integer five);
String simpleMethod(String one, String[] two);
Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);
void twoArgumentMethod(int one, int two);
void arrayMethod(String[] strings);
String oneArray(boolean[] array);
String oneArray(byte[] array);
String oneArray(char[] array);
String oneArray(double[] array);
String oneArray(float[] array);
String oneArray(int[] array);
String oneArray(long[] array);
String oneArray(short[] array);
String oneArray(Object[] array);
String canThrowException() throws ChangedCharSetException, CharacterCodingException; 
String oneArray(String[] array);
void varargsString(int i, String... string);
Object varargsObject(int i, Object... object);
void varargs(Object ... object);
void varargs(String ... string);
List<String> listReturningMethod(Object ... objects);
LinkedList<String> linkedListReturningMethod();
String toString();
String toString(String foo);
void voidMethod();
String forList(List<String> list);
String forMap(Map<String, String> map);
String forCollection(Collection<String> collection);
Object[] arrayReturningMethod();
IMethods iMethodsReturningMethod();
String stringReturningMethod();
Object objectArgMethod(Object str);
Object listArgMethod(List<String> list);
Object collectionArgMethod(Collection<String> collection);
package org.mockitousage.matchers;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;
public class AnyXMatchersAcceptNullsTest extends TestBase {
private IMethods mock;
public void setUp() {
mock = Mockito.mock(IMethods.class);
public void shouldAnyXMatchersAcceptNull() {
when(mock.oneArg(anyObject())).thenReturn("0");
when(mock.oneArg(anyString())).thenReturn("1");
when(mock.forList(anyList())).thenReturn("2");
when(mock.forMap(anyMap())).thenReturn("3");
when(mock.forCollection(anyCollection())).thenReturn("4");
assertEquals("0", mock.oneArg((Object) null));
assertEquals("1", mock.oneArg((String) null));
assertEquals("2", mock.forList(null));
assertEquals("3", mock.forMap(null));
assertEquals("4", mock.forCollection(null));
public void shouldAnyPrimiteWraperMatchersAcceptNull() {
when(mock.forInteger(anyInt())).thenReturn("0");
when(mock.forCharacter(anyChar())).thenReturn("1");
when(mock.forShort(anyShort())).thenReturn("2");
when(mock.forByte(anyByte())).thenReturn("3");
when(mock.forBoolean(anyBoolean())).thenReturn("4");
when(mock.forLong(anyLong())).thenReturn("5");
when(mock.forFloat(anyFloat())).thenReturn("6");
when(mock.forDouble(anyDouble())).thenReturn("7");
assertEquals("0", mock.forInteger(null));
assertEquals("1", mock.forCharacter(null));
assertEquals("2", mock.forShort(null));
assertEquals("3", mock.forByte(null));
assertEquals("4", mock.forBoolean(null));
assertEquals("5", mock.forLong(null));
assertEquals("6", mock.forFloat(null));
assertEquals("7", mock.forDouble(null));"Also make sure the method is not final - you cannot stub final methods."import org.mockito.exceptions.base.StackTraceFilter;
private StackTraceElement[] stackTrace;
StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
StackTraceFilter filter = new StackTraceFilter();
this.stackTrace = filter.filterStackTrace(stackTrace);
public StackTraceElement[] getStackTrace() {
return stackTrace;
return new Location(stackTrace);
public Location(StackTraceElement[] stackTrace) {
assert stackTrace != null;
assert stackTrace.length > 0;
this.stackTrace = stackTrace;
import org.mockito.exceptions.base.MockitoException;
this.stackTrace = new MockitoException("");"Unifinished stubbing detected!",
"E.g. toReturn() may be missing.","Missing method call for verify(mock) method",
" -> Located at " + location,
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();
unfinishedVerificationHere();public void unfinishedVerificationException() {
throw new UnfinishedVerificationException(join(
"Previous verify(mock) doesn't have a method call!",
"Also make sure the method is not final - you cannot verify final methods."
List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasStackTrace.getStackTrace());
hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));
private VerificationMode verificationMode;
verificationMode = (VerificationMode) verify;
VerificationMode temp = verificationMode;
reporter.unfinishedVerificationException();
verify(mock);
verify(mock);
verify(mock);
verify(mock);
verify(mock);
verify(mock);
verify(mock);
verify(mock);assertEquals("SmartNull returned by get() method on mock", smartNull + "");import net.sf.cglib.proxy.MethodInterceptor;
return ClassImposterizer.INSTANCE.imposterise(new MethodInterceptor() {
Exception whenCreated = new BecauseThisMethodWasNotStubbed("\nBecause this method was not stubbed correctly:");
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
if (Invocation.isToString(method)) {
return "SmartNull returned by " + invocation.getMethod().getName() + "() method on mock";
throw new SmartNullPointerException("\nYou have a NullPointerException here:", whenCreated);import org.mockito.internal.creation.ClassNameFinder;
public Object valueFor(InvocationOnMock invocation) {
return "SmartNull for " + ClassNameFinder.classNameForMock(obj);throw new RuntimeException("An Object method could not be found!");
return invocation.getMethod().getReturnType() == String.class 
&& invocation.getMethod().getParameterTypes().length == 0 
&& invocation.getMethod().getName().equals("toString");private final String mockName;
public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, ReturnValues returnValues) {
public String getMockName() {
String mockDescription = "Mock for " + ClassNameFinder.classNameForMock(mock) + ", hashCode: " + mock.hashCode();
return mockDescription;
if (mockName == null) {
mockName = toInstanceName(classToMock);
MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), returnValues);
private static String toInstanceName(Class<?> clazz) {
String className = clazz.getSimpleName();
return className.substring(0, 1).toLowerCase() + className.substring(1);
public static String getMockName(Object mock) {import org.mockito.internal.configuration.DefaultAnnotationEngine;public class ExperimentalMockitoJUnitRunner extends MockitoJUnitRunner {
public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {
public ExperimentalMockitoJUnitRunner(Class<?> klass, MockitoLogger logger) throws InitializationError {
ExperimentalMockitoJUnitRunner.super.run(notifier);
import org.junit.mockito.ExperimentalMockitoJUnitRunner;
import org.junit.mockito.ExperimentalMockitoJUnitRunner.JunitTestBody;
public class ExperimentalMockitoJUnitRunnerTest extends TestBase {
private ExperimentalMockitoJUnitRunner runner;
runner = new ExperimentalMockitoJUnitRunner(this.getClass(), loggerStub);
import org.junit.mockito.ExperimentalMockitoJUnitRunner;
import org.junit.mockito.ExperimentalMockitoJUnitRunner;return new Object();
public void shouldReturnObjectInstance() {
assertNotNull(rv.returnValueFor(Object.class));if (forceMultiline || invocation.length() > MAX_LINE_LENGTH) {throw new IllegalArgumentException("could not imposterise " + mockedType, e);private final List<Invocation> stubbedInvocations = new LinkedList<Invocation>();
private final List<InvocationMatcher> potentiallyUnstubbedInvocations = new LinkedList<InvocationMatcher>();
private final List<InvocationMatcher> unusedInvocations = new LinkedList<InvocationMatcher>();
Iterator<InvocationMatcher> unstubbedIterator = potentiallyUnstubbedInvocations.iterator();
stubbedInvocations.add(invocation);
potentiallyUnstubbedInvocations.add(invocationMatcher);
potentiallyUnstubbedInvocations.clear();
stubbedInvocations.clear();
WarningsPrinter warningsPrinter = new WarningsPrinter(stubbedInvocations, potentiallyUnstubbedInvocations);
return !stubbedInvocations.isEmpty() || !potentiallyUnstubbedInvocations.isEmpty();
public String toString() {
return "unusedInvocations: " + stubbedInvocations + "\nunstubbed invocations:" + potentiallyUnstubbedInvocations;
public Answer findAnswerFor(Invocation invocation) {
callStubbedMethodCorrectly();logger.print("Stubbed like that:");
logger.print("Click here to see it in your code:");
logger.print("Click here to see it in your code:");
logger.print("Click here to see it in your code:");
logger.print("Click here to see it in your code:");import java.util.LinkedList;
import java.util.List;import org.mockito.exceptions.cause.UndesiredInvocation;
Exception whenCreated = new UndesiredInvocation("Unstubbed method was invoked here");
throw new SmartNullPointerException("oops", whenCreated);return fromMockObject || fromOrgMockito;//) && !isRunner;
private final String test;
public DebuggingInfo(String test) {
this.test = test;
Throwable e = failure.getException();import org.mockito.exceptions.base.MockitoException;
import java.lang.reflect.Method;
Method[] methods = classToMock.getMethods();
import org.mockito.Mockito;
import org.junit.Ignore;
import org.mockitousage.IMethods;return MockUtil.createMock((Class<T>) object.getClass(), MOCKING_PROGRESS, null, object, USING_GLOBAL_CONFIG);return ListUtil.filter(invocations, new RemoveToString());if (args[args.length - 1] == null) {
return new Object[] {null};
Object[] varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);
Foo myClass = Mockito.mock(Foo.class);
myClass.varArgs("");        
Mockito.verify(myClass).varArgs((String[]) Mockito.anyObject());
Mockito.verify(myClass).varArgs((String) Mockito.anyObject());
Foo myClass = Mockito.mock(Foo.class);
myClass.varArgs((String[]) null);    
Mockito.verify(myClass).varArgs((String[]) Mockito.anyObject());
Mockito.verify(myClass).varArgs((String[]) null);Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());
Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());
int nextSequenceNumber();
private int invocationSequenceNumber = 1;
public int nextSequenceNumber() {
return invocationSequenceNumber++;
", invocationSequenceNumber: " + invocationSequenceNumber +
invocationSequenceNumber = 1;
public int nextSequenceNumber() {
return threadSafely().nextSequenceNumber();
PointingStackTraceToActualInvocationChunkTest.classimport org.mockito.internal.progress.NullObject;"Mockito cannot mock primitives or final classes like: ",
clazz.toString()
return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());return (String) anyObject();
return (List) anyObject();
return (Map) anyObject();
return (Collection) anyObject();
return reportMatcher(new Contains(substring)).<String>returnNull();
return reportMatcher(new Matches(regex)).<String>returnNull();
return reportMatcher(new EndsWith(suffix)).<String>returnNull();
return reportMatcher(new StartsWith(prefix)).<String>returnNull();import java.util.Arrays;addIfNewElement(loaders, ClassLoader.getSystemClassLoader());import static org.junit.Assert.*;
public class ClassImposterizerTest {Enhancer.registerCallbacks(mockClass, new Callback[] { filter });
mock.getCallback(0);Mockito.verify(list).contains(new Object[] {"1","2", "3"});        public static VerificationMode atLeastOnce() {
return VerificationModeImpl.atLeastOnce();
public static VerificationMode atLeast(int minNumberOfInvocations) {
return VerificationModeImpl.atLeast(minNumberOfInvocations);
public static VerificationMode times(int wantedNumberOfInvocations) {
return VerificationModeImpl.times(wantedNumberOfInvocations);
public static VerificationMode never() {
return times(0);Integer wantedCount = ((VerificationModeImpl) mode).wantedCount();
return Mockito.verify(mock, VerificationModeImpl.inOrder(wantedCount, mocksToBeVerifiedInOrder));
enum Verification { EXPLICIT, NO_MORE_WANTED };
private final Integer wantedInvocationCount;
private final Integer minInvocationCount;
private VerificationModeImpl(Integer wantedNumberOfInvocations, Integer minNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder, Verification verification) {
if (wantedNumberOfInvocations != null && wantedNumberOfInvocations < 0) {
if (minNumberOfInvocations != null && minNumberOfInvocations < 1) {
this.minInvocationCount = minNumberOfInvocations;
return new VerificationModeImpl(null, minNumberOfInvocations, Collections.emptyList(), Verification.EXPLICIT);
return new VerificationModeImpl(wantedNumberOfInvocations, null, Collections.emptyList(), Verification.EXPLICIT);
public static VerificationModeImpl inOrder(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder) {
return new VerificationModeImpl(wantedNumberOfInvocations, null, mocksToBeVerifiedInOrder, Verification.EXPLICIT);
return new VerificationModeImpl(null, null, Collections.emptyList(), Verification.NO_MORE_WANTED);
public Integer minimumCount() {
return minInvocationCount;
return wantedInvocationCount == null && explicitMode();
return !mocksToBeVerifiedInOrder.isEmpty() && explicitMode();
return explicitMode() && (atLeastMode() || wantedInvocationCount > 0);
return !inOrderMode() && explicitMode();
boolean atLeast = atLeastMode() && actualCount >= minInvocationCount;
return atLeastMode() && minInvocationCount > actualCount;
if (mode.explicitMode()) {
if (mode.tooManyActualInvocations(actualCount)) {
reporter.tooLittleActualInvocationsInAtLeastMode(mode.minimumCount(), actualCount, wanted, lastInvocation);        
private Integer times;
assertTrue(inOrder(null, asList("mock")).missingMethodInOrderMode());
import org.junit.Ignore;public class JUnit45RunnerTest extends JUnitRunnerTestCase {
public class JUnit4RunnerTest extends JUnitRunnerTestCase {import org.junit.runner.RunWith;"    stub(mock.isOk()).toReturn(true);",
"    stub(mock.isOk()).toThrow(exception);",
"stub() requires an argument which has to be a method call on a mock.",
"    stub(mock.getArticles()).toReturn(articles);"
mockingProgress.reportOngoingStubbing(new DeprecatedOngoingStubbingImpl());
private class DeprecatedOngoingStubbingImpl implements DeprecatedOngoingStubbing<T> {
public DeprecatedOngoingStubbing<T> toReturn(Object value) {
return toAnswer(new Returns(value));
public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {
return toAnswer(new ThrowsException(throwable));
public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {
return new DeprecatedConsecutiveStubbing();
private class DeprecatedConsecutiveStubbing implements DeprecatedOngoingStubbing<T> {
mockitoStubber.addConsecutiveAnswer(answer);
return this;
private class OngoingStubbingImpl implements NewOngoingStubbing<T> {
verifyingRecorder.eraseLastInvocation();
mockitoStubber.addAnswer(answer);
return new ConsecutiveStubbing();
private class ConsecutiveStubbing implements NewOngoingStubbing<T> {
public NewOngoingStubbing<T> thenReturn(Object value) {
return thenAnswer(new Returns(value));
public NewOngoingStubbing<T> thenThrow(Throwable throwable) {
return thenAnswer(new ThrowsException(throwable));
public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {
stub(mock.simpleMethod("foo"))
.toReturn("foo")
.toReturn("bar")
.toReturn("baz")
.toReturn("foo")
.toReturn("bar")
.toReturn("baz");
stub(mock.simpleMethod(getId()))
.toReturn(getId() + "")
.toReturn("foo")
.toReturn("bar");
Mockito.stub(mock.add("test")).toReturn(true);
stub(spy.get(0))
.toReturn("1")
.toReturn("1 again");
stub(spy.contains(anyObject())).toReturn(true);
stub(spy.contains("foo")).toReturn(false);
stub(mock.withStringVarargsReturningString(1)).toReturn("1");
stub(mock.withStringVarargsReturningString(2, "1", "2", "3")).toReturn("2");
stub(mock.withBooleanVarargs(1)).toReturn(true);
stub(mock.withBooleanVarargs(1, true, false)).toReturn(true);
stub(mockCalculator.countArticles("Guardian")).toReturn(12);
stub(mockCalculator.countArticlesInPolish(anyString())).toReturn(5);
stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).toReturn(1);
stub(mockCalculator.countNumberOfRelatedArticles(articleTwo)).toReturn(12);
stub(mockCalculator.countNumberOfRelatedArticles(articleThree)).toReturn(0);
stub(mockDatabase.getArticlesFor("Guardian")).toReturn(Arrays.asList(articleOne, articleTwo, articleThree)); 
stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).toReturn(1);
stub(mockCalculator.countNumberOfRelatedArticles(articleTwo)).toReturn(12);
stub(mockDatabase.getArticlesFor("Guardian")).toReturn(Arrays.asList(articleOne, articleTwo)); 
stub(mock.oneArg(anyObject())).toReturn("0");
stub(mock.oneArg(anyString())).toReturn("1");
stub(mock.forList(anyList())).toReturn("2");
stub(mock.forMap(anyMap())).toReturn("3");
stub(mock.forCollection(anyCollection())).toReturn("4");
stub(mock.forInteger(anyInt())).toReturn("0");
stub(mock.forCharacter(anyChar())).toReturn("1");
stub(mock.forShort(anyShort())).toReturn("2");
stub(mock.forByte(anyByte())).toReturn("3");
stub(mock.forBoolean(anyBoolean())).toReturn("4");
stub(mock.forLong(anyLong())).toReturn("5");
stub(mock.forFloat(anyFloat())).toReturn("6");
stub(mock.forDouble(anyDouble())).toReturn("7");
stub(mock.oneArg(booleanThat(new IsAnyBoolean()))).toReturn("foo");
stub(mock.oneArg(charThat(new IsSorZ()))).toReturn("foo");
stub(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).toReturn("byte");
stub(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).toReturn("short");
stub(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).toReturn("int");
stub(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).toReturn("long");
stub(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).toReturn("float");
stub(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).toReturn("double");
stub(mock.oneArg(argThat(new ContainsFoo()))).toReturn("foo");
stub(sorter.convertDate(new Date())).toReturn("one");
stub(sorter.convertDate((Date) anyObject())).toReturn("two");
stub(sorter.sort(anyList())).toReturn(null);
stub(mock.simpleMethod(argThat(new ContainsX()))).toReturn("X");
Mockito.stub(mock.threeArgumentMethod(1, "2", "3")).toReturn(null);
Mockito.stub(mock.threeArgumentMethod(1, eq("2"), "3")).toReturn(null);
stub(mock.oneArg(and(eq(false), eq(false)))).toReturn("0");
stub(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).toReturn("1");
stub(mock.oneArg(and(eq('a'), eq('a')))).toReturn("2");
stub(mock.oneArg(and(eq((double) 1), eq((double) 1)))).toReturn("3");
stub(mock.oneArg(and(eq((float) 1), eq((float) 1)))).toReturn("4");
stub(mock.oneArg(and(eq((int) 1), eq((int) 1)))).toReturn("5");
stub(mock.oneArg(and(eq((long) 1), eq((long) 1)))).toReturn("6");
stub(mock.oneArg(and(eq((short) 1), eq((short) 1)))).toReturn("7");
stub(mock.oneArg(and(Matchers.contains("a"), Matchers.contains("d")))).toReturn("8");
stub(mock.oneArg(and(isA(Class.class), eq(Object.class)))).toReturn("9");
stub(mock.oneArg(or(eq(false), eq(true)))).toReturn("0");
stub(mock.oneArg(or(eq((byte) 1), eq((byte) 2)))).toReturn("1");
stub(mock.oneArg(or(eq((char) 1), eq((char) 2)))).toReturn("2");
stub(mock.oneArg(or(eq((double) 1), eq((double) 2)))).toReturn("3");
stub(mock.oneArg(or(eq((float) 1), eq((float) 2)))).toReturn("4");
stub(mock.oneArg(or(eq((int) 1), eq((int) 2)))).toReturn("5");
stub(mock.oneArg(or(eq((long) 1), eq((long) 2)))).toReturn("6");
stub(mock.oneArg(or(eq((short) 1), eq((short) 2)))).toReturn("7");
stub(mock.oneArg(or(eq("asd"), eq("jkl")))).toReturn("8");
stub(mock.oneArg(or(eq(this.getClass()), eq(Object.class)))).toReturn("9");
stub(mock.oneArg(not(eq(false)))).toReturn("0");
stub(mock.oneArg(not(eq((byte) 1)))).toReturn("1");
stub(mock.oneArg(not(eq('a')))).toReturn("2");
stub(mock.oneArg(not(eq((double) 1)))).toReturn("3");
stub(mock.oneArg(not(eq((float) 1)))).toReturn("4");
stub(mock.oneArg(not(eq((int) 1)))).toReturn("5");
stub(mock.oneArg(not(eq((long) 1)))).toReturn("6");
stub(mock.oneArg(not(eq((short) 1)))).toReturn("7");
stub(mock.oneArg(not(Matchers.contains("a")))).toReturn("8");
stub(mock.oneArg(not(isA(Class.class)))).toReturn("9");
stub(mock.oneArg(leq((byte) 1))).toReturn("1");
stub(mock.oneArg(leq((double) 1))).toReturn("3");
stub(mock.oneArg(leq((float) 1))).toReturn("4");
stub(mock.oneArg(leq((int) 1))).toReturn("5");
stub(mock.oneArg(leq((long) 1))).toReturn("6");
stub(mock.oneArg(leq((short) 1))).toReturn("7");
stub(mock.oneArg(leq(new BigDecimal("1")))).toReturn("8");
stub(mock.oneArg(lt((byte) 1))).toReturn("1");
stub(mock.oneArg(lt((double) 1))).toReturn("3");
stub(mock.oneArg(lt((float) 1))).toReturn("4");
stub(mock.oneArg(lt((int) 1))).toReturn("5");
stub(mock.oneArg(lt((long) 1))).toReturn("6");
stub(mock.oneArg(lt((short) 1))).toReturn("7");
stub(mock.oneArg(lt(new BigDecimal("1")))).toReturn("8");
stub(mock.oneArg(geq((byte) 1))).toReturn("1");
stub(mock.oneArg(geq((double) 1))).toReturn("3");
stub(mock.oneArg(geq((float) 1))).toReturn("4");
stub(mock.oneArg(geq((int) 1))).toReturn("5");
stub(mock.oneArg(geq((long) 1))).toReturn("6");
stub(mock.oneArg(geq((short) 1))).toReturn("7");
stub(mock.oneArg(geq(new BigDecimal("1")))).toReturn("8");
stub(mock.oneArg(gt((byte) 1))).toReturn("1");
stub(mock.oneArg(gt((double) 1))).toReturn("3");
stub(mock.oneArg(gt((float) 1))).toReturn("4");
stub(mock.oneArg(gt((int) 1))).toReturn("5");
stub(mock.oneArg(gt((long) 1))).toReturn("6");
stub(mock.oneArg(gt((short) 1))).toReturn("7");
stub(mock.oneArg(gt(new BigDecimal("1")))).toReturn("8");
stub(mock.oneArg(cmpEq(new BigDecimal("1.5")))).toReturn("0");
stub(mock.oneArg(anyString())).toReturn("1");
stub(mock.oneArg(anyBoolean())).toReturn("0");
stub(mock.oneArg(anyByte())).toReturn("1");
stub(mock.oneArg(anyChar())).toReturn("2");
stub(mock.oneArg(anyDouble())).toReturn("3");
stub(mock.oneArg(anyFloat())).toReturn("4");
stub(mock.oneArg(anyInt())).toReturn("5");
stub(mock.oneArg(anyLong())).toReturn("6");
stub(mock.oneArg(anyShort())).toReturn("7");
stub(mock.oneArg((String) anyObject())).toReturn("8");
stub(mock.oneArg(anyObject())).toReturn("9");
stub(mock.oneArray(aryEq(nullArray))).toReturn("null");
stub(mock.oneArray(aryEq(new boolean[] { true, false, false }))).toReturn("0");
stub(mock.oneArray(aryEq(new byte[] { 1 }))).toReturn("1");
stub(mock.oneArray(aryEq(new char[] { 1 }))).toReturn("2");
stub(mock.oneArray(aryEq(new double[] { 1 }))).toReturn("3");
stub(mock.oneArray(aryEq(new float[] { 1 }))).toReturn("4");
stub(mock.oneArray(aryEq(new int[] { 1 }))).toReturn("5");
stub(mock.oneArray(aryEq(new long[] { 1 }))).toReturn("6");
stub(mock.oneArray(aryEq(new short[] { 1 }))).toReturn("7");
stub(mock.oneArray(aryEq(new String[] { "Test" }))).toReturn("8");
stub(mock.oneArray(aryEq(new Object[] { "Test", new Integer(4) }))).toReturn("9");
stub(mock.oneArg(geq(7))).toReturn(">= 7");
stub(mock.oneArg(lt(7))).toReturn("< 7");
stub(mock.oneArg(gt(7))).toReturn("> 7");
stub(mock.oneArg(leq(7))).toReturn("<= 7");
stub(mock.oneArg(leq(7))).toReturn("<= 7");
stub(mock.oneArg(gt(7))).toReturn("> 7");
stub(mock.oneArg(lt(7))).toReturn("< 7");
stub(mock.oneArg(geq(7))).toReturn(">= 7");
stub(mock.oneArg(anyInt())).toReturn("other");
stub(mock.oneArg(or(eq(7), eq(9)))).toReturn("7 or 9");
stub(mock.threeArgumentMethod(eq(1), isNull(), eq(""))).toReturn("1");
stub(mock.threeArgumentMethod(eq(1), not(isNull()), eq(""))).toReturn("2");
stub(mock.threeArgumentMethod(eq(1), notNull(), eq(""))).toReturn("1");
stub(mock.threeArgumentMethod(eq(1), not(isNotNull()), eq(""))).toReturn("2");
stub(mock.oneArg(find("([a-z]+)\\d"))).toReturn("1");
stub(mock.oneArg(matches("[a-z]+\\d\\d"))).toReturn("1");
stub(mock.oneArg(matches("\\d\\d\\d"))).toReturn("2");
stub(mock.oneArg(Matchers.contains("ell"))).toReturn("1");
stub(mock.oneArg(Matchers.contains("ld"))).toReturn("2");
stub(mock.oneArg(startsWith("ab"))).toReturn("1");
stub(mock.oneArg(startsWith("bc"))).toReturn("2");
stub(mock.oneArg(Matchers.endsWith("ab"))).toReturn("1");
stub(mock.oneArg(Matchers.endsWith("bc"))).toReturn("2");
stub(mock.oneArg(eq(1.0D, 0.1D))).toReturn("1");
stub(mock.oneArg(eq(2.0D, 0.1D))).toReturn("2");
stub(mock.oneArg(eq(1.0F, 0.1F))).toReturn("3");
stub(mock.oneArg(eq(2.0F, 0.1F))).toReturn("4");
stub(mock.oneArg(eq(2.0F, 0.1F))).toReturn("4");
stub(mock.oneArg(same(one))).toReturn("1");
stub(mock.oneArg(same(two))).toReturn("2");
stub(one.simpleMethod(2)).toReturn("2");
stub(two.simpleMethod(anyString())).toReturn("any");
stub(three.simpleMethod(startsWith("test"))).toThrow(new RuntimeException());
stub(three.varargsObject(5, "first arg", "second arg")).toReturn("stubbed");
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock.simpleMethod());
stub(mock);
stub(mock.simpleMethod()).toReturn("this stubbing is required to make sure Stubbable is pulled");
stub("".toString()).toReturn("x");
stub(mock.simpleMethod()).toThrow(new Exception());
stub(mock.simpleMethod()).toThrow(null);
stub(mock.oneArg(true)).toThrow(new Exception());
stub(mock.simpleMethod()).toThrow(new RuntimeException());
stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);
stub(mock.objectReturningMethod(200)).toReturn(200);
stub(mock.booleanReturningMethod()).toReturn(true);
stub(mockTwo.getList()).toReturn((List) subs);
stub(mockTwo.toString()).toReturn("test");
stub(mock.simpleMethod("one")).toThrow(new RuntimeException());
stub(mock.simpleMethod())
.toReturn("one")
.toReturn("two")
.toReturn("three");
stub(mock.simpleMethod())
.toThrow(new RuntimeException())
.toThrow(new IllegalArgumentException())
.toThrow(new NullPointerException());
stub(mock.simpleMethod())
.toThrow(new IllegalArgumentException())
.toReturn("one")
.toThrow(new NullPointerException())
.toReturn(null);
stub(mock.simpleMethod())
.toReturn("one")
.toThrow(new Exception());
stub(mock.simpleMethod(anyString())).toAnswer(new Answer<String>() {
stub(mock.simpleMethod())
.toAnswer(new Answer<String>() {
.toReturn("Hello")
.toAnswer(new Answer<String>() {
stub(mock.add("throw")).toThrow(expected);
stub(mock.get(1)).toThrow(new ExceptionOne());
stub(mock.get(1)).toThrow(new ExceptionTwo());
stub(reader.read()).toThrow(ioException);
stub(mock.add("quake")).toThrow(error);
stub(mock.add("monkey island")).toThrow(new Exception());
stub(mock.add("monkey island")).toThrow(null);
stub(mock.add("ExceptionOne")).toThrow(new ExceptionOne());
stub(mock.getLast()).toReturn("last");
stub(mockTwo.containsValue("ExceptionFour")).toThrow(new ExceptionFour());
stub(mockTwo.get("Are you there?")).toReturn("Yes!");
stub(mock.size()).toThrow(new RuntimeException());
stub(mock.size()).toThrow(new RuntimeException());
stub(mock.add("test")).toReturn(Boolean.FALSE);
stub(mock.add("test")).toReturn(false);
stub(mock.add("test")).toReturn(true);
stub(mock.add("one")).toReturn(true);
stub(mock.add("two")).toReturn(true);if (verifiedOnly.isEmpty()) {
return null;
return verifiedOnly.getLast();public abstract class ExampleTest {
public class JUnit45ExampleTest extends ExampleTest {
public class JUnit4ExampleTest extends ExampleTest {if (mockitoStubber.hasResultFor(invocation)) {
return mockitoStubber.getResultFor(invocation);
public boolean hasResultFor(Invocation invocation) {
return findMatch(invocation) != null;
return findMatch(invocation).answer(invocation);
private StubbedInvocationMatcher findMatch(Invocation invocation) {private Mockito() {}
public static Stubber doReturn(Object toBeReturned) {
return doAnswer(new Returns(toBeReturned));
"    stubVoid(mock).toThrow(exception).on().someMethod();"
"    doThrow(new RuntimeException()).when(mock).someVoidMethod();"
package org.mockito.internal.stubbing;
public interface StubbedMethodSelector {
<T> T when(T mock);
public interface Stubber extends StubbedMethodSelector {
import org.mockito.exceptions.base.MockitoException;
try {
if (Enhancer.isEnhanced(mock.getClass())) {
return ((MethodInterceptorFilter<MockHandler<T>>) getInterceptor(mock)).getDelegate();
throw new NotAMockException("Argument should be a mock, but is: " + mock.getClass());
return (MethodInterceptorFilter) factory.getCallback(0);
public static boolean isMock(Object mock) {
try {
getMockHandler(mock);
return true;
return false;
detects(new OnDoReturn(), UnfinishedStubbingException.class);
detects(new OnDoReturn(), UnfinishedStubbingException.class);
detects(new OnDoReturn(), UnfinishedVerificationException.class);
private static class OnDoReturn implements DetectsInvalidState {
doReturn(null);public static Stubber doThrow(Throwable toBeThrown) {
return doAnswer(new ThrowsException(toBeThrown));
public static Stubber doAnswer(Answer answer) {
MOCKING_PROGRESS.stubbingStarted();
return new StubberImpl().doAnswer(answer);
public void cannotStubNonVoidMethodWithAVoidReturn() {
"Cannot stub a non-void method with a void return!",
"Void return is only used for stubbing consecutive calls on void methods.",
"Example:",
"someVoidMethod() does nothing the 1st time but throws an exception 2nd time is called"
validateVoidReturn((DoesNothing) answer, invocation);
private void validateVoidReturn(DoesNothing answer, Invocation invocation) {
reporter.cannotStubNonVoidMethodWithAVoidReturn();
public void shouldFailWhenVoidReturnSetOnNonVoidMethod() throws Throwable {
assertThat(e.getMessage(), contains("Cannot stub a non-void method"));import org.mockito.internal.stubbing.ReturnsVoid;
public static Stubber doReturn() {
return doAnswer(new ReturnsVoid());
"    doReturn().",
import org.mockito.internal.stubbing.ReturnsVoid;
mockitoStubber.addAnswerForVoidMethod(new ReturnsVoid());
if (answer instanceof ReturnsVoid) {
validateVoidReturn((ReturnsVoid) answer, invocation);
private void validateVoidReturn(ReturnsVoid answer, Invocation invocation) {
public class ReturnsVoid implements Answer<Object> {
Stubber doReturn();
public Stubber doReturn() {
answers.add(new ReturnsVoid());
validator.validate(new ReturnsVoid(), new InvocationBuilder().simpleMethod().toInvocation());
validator.validate(new ReturnsVoid(), new InvocationBuilder().method("voidMethod").toInvocation());
doReturn().
doReturn().
public void shouldNotAllowDoReturnOnNonVoids() {
doReturn().when(mock).simpleMethod();public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String optionalMockName, T optionalInstance) {
if (optionalMockName == null) {
optionalMockName = toInstanceName(classToMock);
MockHandler<T> mockHandler = new MockHandler<T>(optionalMockName, progress, new MatchersBinder());if (mockitoStubber.hasAnswerForVoidMethod()) {
mockitoStubber.addVoidMethodForStubbing(invocationMatcher);
mockitoStubber.addAnswersForVoidMethod(answers);
private final List<Answer> answersForVoidMethod = new ArrayList<Answer>();
answersForVoidMethod.add(answer);
public void addAnswersForVoidMethod(List<Answer> answers) {
answersForVoidMethod.addAll(answers);
public boolean hasAnswerForVoidMethod() {
return !answersForVoidMethod.isEmpty();
public void addVoidMethodForStubbing(InvocationMatcher voidMethodInvocationMatcher) {
invocationForStubbing = voidMethodInvocationMatcher;
assert hasAnswerForVoidMethod();
for (int i = 0; i < answersForVoidMethod.size(); i++) {
addAnswer(answersForVoidMethod.get(i), i != 0);
answersForVoidMethod.clear();
mockitoStubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));
mockitoStubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));return handler.voidMethodStubbable();
public VoidMethodStubbable<T> voidMethodStubbable() {
return new VoidMethodStubbableImpl();
return instance;
import org.junit.Ignore;
spy.add("one");import org.mockito.internal.stubbing.DontThrow;
if (stubber.hasThrowableForVoidMethod()) {
stubber.addVoidMethodForThrowable(invocationMatcher);
stubber.addThrowableForVoidMethod(throwable);
stubber.addThrowableForVoidMethod(DontThrow.DONT_THROW);
public VoidMethodStubbable<T> toAnswer(Answer answer) {
stubber.addThrowableForVoidMethod(new DontThrow(answer));
stubber.addReturnValue(value);
stubber.addThrowable(throwable);
public OngoingStubbing<T> toAnswer(Answer<T> answer) {
stubber.addConsecutiveReturnValue(value);
stubber.addConsecutiveThrowable(throwable);
public OngoingStubbing<T> toAnswer(Answer<T> answer) {
OngoingStubbing<T> toAnswer(Answer<T> answer);
package org.mockito.internal.stubbing;
import org.mockito.exceptions.Reporter;
import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;
import org.mockito.exceptions.base.StackTraceFilter;
import org.mockito.internal.invocation.Invocation;
import org.mockito.invocation.InvocationOnMock;
public class AnswerFactory {
private final StackTraceFilter filter;
private final Reporter reporter;
public AnswerFactory(StackTraceFilter filter) {
this.filter = filter;
this.reporter = new Reporter();
public Answer createReturningAnswer(final Object value) {
return new Answer<Object>() {
public Object answer(InvocationOnMock invocation) throws Throwable {
return value;
public Answer createThrowingAnswer(final Throwable throwable, Invocation invocation) {
validateThrowable(throwable, invocation);
return new Answer<Object>() {
public Object answer(InvocationOnMock invocation) throws Throwable {
if (throwable instanceof DontThrow) {
return ((DontThrow) throwable).getAnswer().answer(invocation);
Throwable filtered = throwable.fillInStackTrace();
filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));
throw filtered;
private void validateThrowable(Throwable throwable, Invocation invocation) {
if (throwable == null) {
reporter.cannotStubWithNullThrowable();
if (throwable instanceof RuntimeException || throwable instanceof Error) {
return;
if (!invocation.isValidException(throwable)) {
reporter.checkedExceptionInvalid(throwable);
import java.util.LinkedList;
private final LinkedList<Answer> answers = new LinkedList<Answer>();
return answers.size() == 1 ? answers.getFirst().answer(invocation) : answers.removeFirst().answer(invocation);
import org.mockito.exceptions.base.StackTraceFilter;
private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();
private final AnswerFactory answerFactory = new AnswerFactory(new StackTraceFilter());
public void addReturnValue(Object value) {
mockingProgress.stubbingCompleted();
Answer answer = answerFactory.createReturningAnswer(value);
stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));
public void addThrowable(Throwable throwable) {
mockingProgress.stubbingCompleted();
Answer answer = answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation());
stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));
mockingProgress.stubbingCompleted();
stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));
public void addConsecutiveReturnValue(Object value) {
stubbed.getFirst().addAnswer(answerFactory.createReturningAnswer(value));
public void addConsecutiveThrowable(Throwable throwable) {
stubbed.getFirst()
.addAnswer(answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation()));
stubbed.getFirst().addAnswer(answer);
public void addThrowableForVoidMethod(Throwable throwable) {
throwablesForVoidMethod.add(throwable);
public boolean hasThrowableForVoidMethod() {
return !throwablesForVoidMethod.isEmpty();
public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {
assert hasThrowableForVoidMethod();
for (int i = 0; i < throwablesForVoidMethod.size(); i++) {
Throwable throwable = throwablesForVoidMethod.get(i);
if (i == 0) {
addThrowable(throwable);
addConsecutiveThrowable(throwable);
throwablesForVoidMethod.clear();
VoidMethodStubbable<T> toAnswer(Answer<T> answer);
import org.mockito.internal.stubbing.AnswerFactoryTest;
public class MultiThreadedTest extends TestBase {
AnswerFactoryTest.class,
package org.mockito.internal.stubbing;
import java.io.IOException;
import java.nio.charset.CharacterCodingException;
import java.util.Arrays;
import org.junit.Before;
import org.junit.Test;
import org.mockito.TestBase;
import org.mockito.exceptions.base.HasStackTrace;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.base.StackTraceFilter;
import org.mockito.internal.invocation.Invocation;
import org.mockito.internal.invocation.InvocationBuilder;
import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;
public class AnswerFactoryTest extends TestBase {
private StackTraceFilterStub filterStub;
private AnswerFactory factory;
public void setup() {
this.filterStub = new StackTraceFilterStub();
this.factory = new AnswerFactory(filterStub);
public void shouldCreateReturnResult() throws Throwable {
Answer result = factory.createReturningAnswer("lol");
assertEquals("lol", result.answer(null));
public void shouldCreateThrowResult() throws Throwable {
factory.createThrowingAnswer(new RuntimeException(), null).answer(null);
public void shouldFilterStackTraceWhenCreatingThrowResult() throws Throwable {
Answer result = factory.createThrowingAnswer(new RuntimeException(), null);
try {
result.answer(null);
fail();
assertTrue(Arrays.equals(filterStub.hasStackTrace.getStackTrace(), e.getStackTrace()));
assertThat(e, hasFirstMethodInStackTrace("answer"));
public void shouldValidateNullThrowable() throws Throwable {
try {
factory.createThrowingAnswer(null, null);
fail();
public void shouldAllowSettingProperCheckedException() throws Throwable {
Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();
factory.createThrowingAnswer(new CharacterCodingException(), invocation);
public void shouldValidateCheckedException() throws Throwable {
Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();
factory.createThrowingAnswer(new IOException(), invocation);
class StackTraceFilterStub extends StackTraceFilter {
HasStackTrace hasStackTrace;
public void filterStackTrace(HasStackTrace hasStackTrace) {
this.hasStackTrace = hasStackTrace;
stubber.addThrowable(new Exception());
stubber.addReturnValue("test");
stubber.addReturnValue("simpleMethod");
stubber.addThrowable(new MyException());
stubber.addReturnValue("simpleMethod");
stubber.addThrowableForVoidMethod(new MyException());
stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));
stubber.addThrowableForVoidMethod(new Exception());
stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));
stubber.addThrowable(null);if (toMock.getSigners() != null) {
enhancer.setNamingPolicy(ALLOWS_MOCKING_CLASSES_IN_SIGNED_PACKAGES);import java.util.List;
public static <T> LinkedList<T> filter(List<T> list, Filter<T> filter) {
for (T t : list) {
private final LinkedList<Invocation> invocations = new LinkedList<Invocation>();
invocations.removeLast();
package org.mockitousage;
int numberOfThreads = 10; package org.mockito.internal.stubbing;
import org.mockito.Mockito;
public interface VoidMethodStubbable<T> {
VoidMethodStubbable<T> toThrow(Throwable throwable);
VoidMethodStubbable<T> toReturn();
T on();package org.mockito.internal.configuration;
import org.mockito.configuration.ReturnValues;
import org.mockito.configuration.experimental.ConfigurationSupport;
public interface MockitoConfiguration {
ReturnValues getReturnValues();
void setReturnValues(ReturnValues returnValues);
void resetReturnValues();package org.mockito.configuration.experimental;
import java.lang.reflect.Modifier;
import org.mockito.internal.configuration.MockitoConfiguration;
import org.mockito.internal.configuration.Configuration;
import org.mockito.internal.configuration.MockitoProperties;
import org.mockito.invocation.InvocationOnMock;
public class ConfigurationSupport {
public static Object defaultValueFor(InvocationOnMock invocation) {
return MockitoProperties.DEFAULT_RETURN_VALUES.valueFor(invocation);
public static boolean isMockable(Class<?> clazz) {
return !Modifier.isFinal(clazz.getModifiers());
public static MockitoConfiguration getConfiguration() {
return Configuration.instance();import static org.junit.Assert.*;
public class SyncingPrinterTest {Object[] varArgs = ArrayEquals.createObjectArray(args[args.length - 1]);public static Answer createThrowResult(final Throwable throwable, final StackTraceFilter filter) {
public static Answer createReturnResult(final Object value) {
addResult(AnswerFactory.createReturnResult(value));
addResult(AnswerFactory.createThrowResult(throwable, new StackTraceFilter()));
stubbed.getFirst().addAnswer(AnswerFactory.createReturnResult(value));
stubbed.getFirst().addAnswer(AnswerFactory.createThrowResult(throwable, new StackTraceFilter()));
Answer result = AnswerFactory.createReturnResult("lol");
AnswerFactory.createThrowResult(new RuntimeException(), new StackTraceFilter()).answer();
Answer result = AnswerFactory.createThrowResult(new RuntimeException(), filterStub);if (type == Collection.class) {
import org.mockito.configuration.DefaultReturnValues;
private final class MyDefaultReturnValues implements ReturnValues {
public Object valueFor(InvocationOnMock invocation) {
Object value = new DefaultReturnValues().valueFor(invocation);
if (value != null || invocation.getMethod().getReturnType() == Void.TYPE) {
return value;
return Mockito.mock(invocation.getMethod().getReturnType());
assertEquals('\u0000', mock.charReturningMethod(12));private static final int MAX_LINE_LENGTH = 35;
return qualifiedMethodName() + getArgumentsString(matchers);
private String getArgumentsString(List<Matcher> matchers) {
String args = result.toString();
if (args.length() < MAX_LINE_LENGTH) {
return args;
result = new StringDescription();
result.appendList("(\n    ", ",\n    ", "\n  );", matchers);
return result.toString();
assertThat(e, messageContains("simpleMethod(<String that contains xxx>);"));
assertThat(e, messageContains("simpleMethod(<custom argument matcher>);"));
private class SomeClass {
return "SomeClass instance";
verify(mock).threeArgumentMethod(12, new SomeClass(), "xx");
assertThat(e, messageContains("IMethods.threeArgumentMethod(12, SomeClass instance, \"xx\")"));
"  );";
"  );";
mock.varargsString(10, "one", "two", "three");
verify(mock).varargsString(10, "two", "one", "three");
assertThat(e, messageContains("(10, \"two\""));
assertThat(e, causeMessageContains("(10, \"one\""));public static <T> T anyObject() {
return reportMatcher(Any.ANY).returnNull();&& invocation.getMethod().equals(actual.getMethod())
public boolean isSimilarTo(Invocation candidate) {
final boolean methodEquals = invocation.getMethod().equals(candidate.getMethod());
if (wanted.isSimilarTo(invocation)) {
return invocation;
return null;
assertTrue("\nException message >>>" + value.getMessage() + "\n>>> should contain: " + text,
assertTrue(simpleMethod.isSimilarTo(same));
assertFalse(simpleMethod.isSimilarTo(different));
assertFalse(simpleMethod.isSimilarTo(verified));
assertFalse(simpleMethod.isSimilarTo(onDifferentMock));
assertFalse(invocation.isSimilarTo(overloadedInvocation));
assertTrue(invocation.isSimilarTo(overloadedInvocation));
public void shouldFindSimilarInvocationByName() throws Exception {
Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());
assertSame(found, simpleMethodInvocation);"Invocation differs from actual:" +public void testShouldFilterStackTrace() {
StackTraceElement first = new StackTraceElement("MethodInterceptorFilter", "intercept", "MethodInterceptorFilter.java", 49);
StackTraceElement second = new StackTraceElement("List$$EnhancerByCGLIB$$2c406024", "add", "<generated>", 0);
StackTraceElement third = new StackTraceElement("MockitoSampleTest", "main", "MockitoSampleTest.java", 100);
HasStackTraceStub trace = new HasStackTraceStub(first, second, third);
assertEquals(1, trace.getStackTrace().length);
assertEquals(third, trace.getStackTrace()[0]);
private String[] methods;
public TraceBuilder methods(String ... methods) {
this.methods = methods;
return this;private boolean isOverloaded(Invocation actual) {
return invocation.getMock().equals(actual.getMock())
&& invocation.getMethod().getName().equals(actual.getMethod().getName())
&& !invocation.getMethod().equals(actual.getMethod());
boolean methodNameEquals = wantedMethodName.equals(currentMethodName);
boolean isUnverified = !candidate.isVerified();
boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();
boolean overloadedButSameArgs = isOverloaded(candidate) && argumentsMatch(candidate);        
import java.util.Arrays;
StackTraceElement elementOne = new StackTraceElement("MethodInterceptorFilter", "intercept", "MethodInterceptorFilter.java", 49);
HasStackTrace trace = new HasStackTraceStub(elementOne);
StackTraceElement elementTwo = new StackTraceElement("Mockito", "other", "Mockito.java", 90);
List<StackTraceElement> cause = Arrays.asList(elementTwo);
remover.remove(trace, cause);
assertEquals(1, trace.getStackTrace().length);
assertEquals(elementOne, trace.getStackTrace()[0]);mock.simpleMethod(null, null);public String getTypedArgs() {
StringBuilder result = new StringBuilder();
Class<?>[] types = getMethod().getParameterTypes();
for (int i = 0; i < types.length; i++) {
Class<?> paramType = types[i];
result.append(TAB).append(i+1).append(": ").append(paramType);
if (i != types.length-1) {
result.append("\n");
return result.toString();
return TAB + "<no arguments>"; 
public boolean differsWithArgumentTypes(Invocation actual) {
public String getTypedArgs() {
return invocation.getTypedArgs();
if (methodNameEquals && isUnverified && mockIsTheSame ) {
if (wantedInvocation.differsWithArgumentTypes(actualInvocation)) {
wantedArgs = wantedInvocation.getTypedArgs();
actualArgs = actualInvocation.getTypedArgs();
wantedArgs = wantedInvocation.getArgs();
actualArgs = actualInvocation.getArgs();
import static org.junit.Assert.assertEquals;
import java.lang.reflect.Method;
class Super {
void test(Object o) {};
class Sub extends Super {
void test(String s) {};
public void shouldPrintTypesWhenOnlyTypesDiffer() throws Exception {
Method methodOne = Super.class.getDeclaredMethod("test", Object.class);
Method methodTwo = Sub.class.getDeclaredMethod("test", String.class);
InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).toInvocationMatcher();
Invocation invocationTwo = new InvocationBuilder().method(methodTwo).toInvocation();
InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);
assertEquals(invocationOne.toString(), invocationTwo.toString());
assertEquals("Object.test(...)", printer.getWanted().toString());
assertEquals("    1: class java.lang.Object", printer.getWantedArgs().toString());
assertEquals("    1: class java.lang.String", printer.getActualArgs().toString());
class Dummy {
void test(String ... s) {};
void test(Object ... o) {};
public void shouldPrintVarargTypesWhenOnlyTypesDiffer() throws Exception {
Method methodOne = Dummy.class.getDeclaredMethod("test", new Object[]{}.getClass());
Method methodTwo = Dummy.class.getDeclaredMethod("test", new String[]{}.getClass());
InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).arg(new Object[]{}).toInvocationMatcher();
Invocation invocationTwo = new InvocationBuilder().method(methodTwo).arg(new String[]{}).toInvocation();
InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);
assertEquals(invocationOne.toString(), invocationTwo.toString());
assertEquals("Object.test(...)", printer.getWanted().toString());
assertEquals("    1: class [Ljava.lang.Object;", printer.getWantedArgs().toString());
assertEquals("    1: class [Ljava.lang.String;", printer.getActualArgs().toString());
import org.mockitousage.binding.IncorectBindingPuzzleFixedTest;
IncorectBindingPuzzleFixedTest.class,
package org.mockitousage.binding;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import static org.mockito.util.ExtraMatchers.*;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.InOrder;
import org.mockito.TestBase;
import org.mockito.exceptions.verification.ArgumentsAreDifferentException;
import org.mockito.exceptions.verification.VerifcationInOrderFailure;
import org.mockitousage.IMethods;
public class IncorectBindingPuzzleFixedTest extends TestBase {
private Super mock;
private void setMockWithDowncast(Super mock) {
this.mock = mock;
private interface Super {
void say(Object message);
private interface Sub extends Super {
void say(String message);
private void say(Object message) {
mock.say(message);
public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {
Sub sub = mock(Sub.class);
setMockWithDowncast(sub);
say("Hello");
try {
verify(sub).say("Hello");
fail();
String expected =
"\n" +
"Argument(s) are different!" +
"\n" +
"Method: Sub.say(...)" +
"\n" +
"All wanted arguments:" +
"\n" +
"    1: class java.lang.String";
assertEquals(expected, error.getMessage());
String expectedCause =
"\n" +
"All actual arguments:" +
"\n" +
"    1: class java.lang.Object";
assertEquals(expectedCause, error.getCause().getMessage());
public void shouldPrintArgumentTypeWhenOverloadingPuzzleDetectedByVerificationInOrder() throws Exception {
IMethods mockTwo = mock(IMethods.class);
mockTwo.simpleMethod();
Sub sub = mock(Sub.class);
setMockWithDowncast(sub);
say("Hello");
InOrder inOrder = inOrder(mock, mockTwo);
inOrder.verify(mockTwo).simpleMethod();
try {
inOrder.verify(sub).say("Hello");
fail();
assertThat(e, messageContains("Sub.say(class java.lang.String)"));
public void shouldUseArgumentTypeWhenMatcherUsed() throws Exception {
Sub sub = mock(Sub.class);
setMockWithDowncast(sub);
say("Hello world");
try {
verify(sub).say(contains("world"));
fail();
assertThat(e, messageContains("1: class java.lang.String"));
assertThat(e, causeMessageContains("1: class java.lang.Object"));
import org.junit.Before;
import org.mockito.Mockito;
import org.mockito.exceptions.verification.ArgumentsAreDifferentException;
private List mock;
private List mockTwo;
public void setup() {
mock = Mockito.mock(List.class);
mockTwo = Mockito.mock(List.class);
assertThat(e, causeMessageContains("    <no arguments>"));
public void shouldPrintTypesWhenMethodSupposablyTheSame() throws Exception {
mock.varargs((Object[]) new Object[] {});
try {
verify(mock).varargs((String[]) new String[] {});
fail();
assertThat(e, messageContains("1: class [Ljava.lang.String;"));
assertThat(e, causeMessageContains("1: class [Ljava.lang.Object;"));List<StackTraceElement> exceptionsPart = null;
List<StackTraceElement> exceptionsTrace = Arrays.asList(hasStackTrace.getStackTrace());
int length = exceptionsTrace.size();
for (int i = 0; i < length; i++) {
List<StackTraceElement> subList = exceptionsTrace.subList(i, length);
exceptionsPart = exceptionsTrace.subList(0, i);
assert exceptionsPart != null;
hasStackTrace.setStackTrace(exceptionsPart.toArray(new StackTraceElement[exceptionsPart.size()]));
List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);public boolean wantedCountIsZero() {
if (mode.wantedCountIsZero() && noMatchFound) {
assertTrue(times(0).wantedCountIsZero());
assertFalse(times(1).wantedCountIsZero());
assertFalse(times(20).wantedCountIsZero());
assertFalse(atLeastOnce().wantedCountIsZero());
VerificationModeImpl mode = times(0);
assertEquals(1, reporterStub.actualCount);
assertEquals(0, reporterStub.wantedCount);
import org.mockito.exceptions.verification.TooManyActualInvocations;
public void shouldUseCustomCharMatcher() {
stub(mock.oneArg(charThat(new IsSorZ()))).toReturn("foo");
assertEquals("foo", mock.oneArg('s'));
assertEquals("foo", mock.oneArg('z'));
assertEquals(null, mock.oneArg('x'));
assertThat(e, messageContains("Wanted 0 times but was 1"));
e.printStackTrace();
assertThat(e, messageContains("Wanted 0 times but was 1"));
import org.mockito.exceptions.verification.TooManyActualInvocations;Field[] fields = testClass.getClass().getDeclaredFields();return emptyReturnValueToType.get(type);
private static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();
static {
emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());
emptyReturnValueToType.put(Set.class, new HashSet<Object>());
emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());
emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        
emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());
emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        
emptyReturnValueToType.put(List.class, new LinkedList<Object>());       
emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());
emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());
emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());
emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());
emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        
emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());
emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;description.appendText(wanted.toString());MockUtil.validateMock(mock);
MockUtil.getMockHandler(mock).verifyNoMoreInteractions();
if (mocks.length == 0) {
"Method requires arguments.",
"verifyNoMoreInteractions(mockOne, mockTwo);"
"InOrder inOrder = inOrder(mockOne);",
"inOrder.verify(mockOne).doStuff();"
"Method requires arguments.",
"InOrder inOrder = inOrder(mockOne, mockTwo);"
"Unifinished stubbing detected, e.g. toReturn() is missing",
"Examples of proper stubbing:",
"stub(mock.isOk()).toReturn(true);",
"stub(mock.isOk()).toThrows(exception);",
"stubVoid(mock).toThrow(exception).on().someMethod();"
"stub() requires an argument which has to be a proper method call on a mock object"
"Should be something like that: verify(mock).doSomething()"
"See javadoc for Matchers class");
public NotAMockException(Object object) {
super("Not a mock: " + object.getClass().getName());
throw new MockitoException("Mock cannot be null");
throw new NotAMockException(mock);
throw new NotAMockException(mock);
public class MockUtilTest extends RequiresValidState {
public class MockitoTest extends RequiresValidState {
public class RequiresValidState {
public void requiresValidState() {
import org.mockito.RequiresValidState;
public class ReporterTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockitoAssertionErrorTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockitoExceptionTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class StackTraceRemoverTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class AllInvocationsFinderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockHandlerTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class CglibTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockFactoryTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvocationMatcherTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvocationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvocationsFinderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvocationsPrinterTest extends RequiresValidState{
import org.mockito.RequiresValidState;
public class EqualsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class EqualsBuilderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockingProgressImplTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationModeImplTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class EmptyReturnValuesTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ResultTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class StubberTest extends RequiresValidState{
import org.mockito.RequiresValidState;
public class ListUtilTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MissingInvocationInOrderVerifierTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MissingInvocationVerifierTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class NoMoreInvocationsVerifierTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class NumberOfInvocationsInOrderVerifierTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class NumberOfInvocationsVerifierTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerifyingRecorderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class AnnotationsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvalidStateDetectionTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class InvalidUsageTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MultiThreadedTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class PointingStackTraceToActualInvocationChunkInOrderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class PointingStackTraceToActualInvocationChunkTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class PointingStackTraceToActualInvocationInOrderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class PointingStackTraceToActualInvocationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ReflectionMatchersTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ReplacingObjectMethodsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class StackTraceFilteringTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class StackTrackeChangingTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class UsingVarargsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class BridgeMethodPuzzleTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class IncorectBindingPuzzleFixedTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ComparableMatchersTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class CustomMatchersTest extends RequiresValidState {
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.eq;
import org.mockito.RequiresValidState;
public class InvalidUseOfMatchersTest extends RequiresValidState {
assertEquals(
"\n" +
"No matchers found for Not(?)." +
"\n" +
"See javadoc for Matchers class"
, e.getMessage());
assertEquals(
"\n" +
"2 matchers expected, 1 recorded." +
"\n" +
"See javadoc for Matchers class"
, e.getMessage());
assertEquals(
"\n" +
"3 matchers expected, 1 recorded." +
"\n" +
"See javadoc for Matchers class"
, e.getMessage());
import org.mockito.RequiresValidState;
public class MatchersTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MatchersToStringTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationAndStubbingUsingMatchersTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class MockitoSampleTest extends RequiresValidState {
private ArticleCalculator mockCalculator;
private ArticleDatabase mockDatabase;
mockCalculator = mock(ArticleCalculator.class);
mockDatabase = mock(ArticleDatabase.class);
stub(mockCalculator.countArticlesInPolish("Guardian")).toReturn(5);
import org.mockito.RequiresValidState;
public class BasicStubbingTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ReturningDefaultValuesTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class StubbingWithThrowablesTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class AtLeastOnceVerificationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class BasicVerificationInOrderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class BasicVerificationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class DescriptiveMessagesWhenVerificationFailsTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class ExactNumberOfTimesVerificationTest extends RequiresValidState {
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.stub;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import org.mockito.RequiresValidState;
public class NoMoreInteractionsVerificationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class RelaxedVerificationInOrderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class SelectedMocksInOrderVerificationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationInOrderMixedWithOrdiraryVerificationTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationInOrderTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationOnMultipleMocksUsingMatchersTest extends RequiresValidState {
import org.mockito.RequiresValidState;
public class VerificationUsingMatchersTest extends RequiresValidState {package org.mockito.internal.invocation;
public class InvocationsAnalyzer {public class EqualsBuilder {public void shouldUseArgumentTypeWhenOverloadingPuzzleDetectedByVerificationInOrder() throws Exception {
InOrder inOrder = inOrder(mock);
inOrder.verify(sub).say("Hello");
"Wanted but not invoked:" +return reportMatcher(new GreaterOrEqual<T>(value)).returnNull();
return reportMatcher(new GreaterThan<T>(value)).returnNull();
return reportMatcher(new LessThan<T>(value)).returnNull();
return reportMatcher(new Find(regex)).returnNull();
return LastArguments.instance().reportAnd().returnNull();
return LastArguments.instance().reportOr().returnNull();
return LastArguments.instance().reportNot().returnNull();
return reportMatcher(new InstanceOf(clazz)).returnNull();
return reportMatcher(new Equals(value)).returnNull();
return reportMatcher(new Same(value)).returnNull();import org.mockito.internal.invocation.GlobalInvocationsFinder;
import org.mockito.internal.verification.StrictlyMissingInvocationVerifier;
import org.mockito.internal.matchers.ArgumentMatcher;
import org.mockito.internal.matchers.ArgumentMatcher;
import org.mockito.internal.invocation.InvocationsFinder;
import org.mockito.internal.invocation.InvocationsFinder;
import org.mockito.internal.invocation.InvocationsFinder;
import org.mockito.internal.invocation.InvocationsFinder;
import org.mockito.internal.invocation.InvocationsFinder;
import org.mockito.internal.invocation.GlobalInvocationsFinder;"Read more: http://code.google.com/p/mockito/matchers");
"Read more: http://code.google.com/p/mockito/matchers"
"Read more: http://code.google.com/p/mockito/matchers"
"Read more: http://code.google.com/p/mockito/matchers"import org.mockito.internal.matchers.*;
import org.mockito.internal.matchers.*;
import org.mockito.exceptions.*;
import org.mockito.internal.*;
import org.mockito.internal.progress.*;
private static final Reporter reporter = new Reporter();
static final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
MockControl<T> mockControl = new MockControl<T>(mockingProgress, new MatchersBinder());
mockingProgress.stubbingStarted();
OngoingStubbing stubable = mockingProgress.pullStubable();
reporter.missingMethodInvocation();
mockingProgress.verificationStarted(mode);
public static void verifyNoMoreInteractions(Object ... mocks) {
assertMocksNotEmpty(mocks);
mockingProgress.validateState();
for (Object mock : mocks) {
reporter.mocksHaveToBePassedAsArguments();
mockingProgress.stubbingStarted();
reporter.mocksHaveToBePassedWhenCreatingStrictly();
import java.util.*;
import org.mockito.exceptions.cause.*;
import org.mockito.exceptions.misusing.*;
import org.mockito.exceptions.parents.*;
import org.mockito.exceptions.verification.*;
"Checked exception is invalid for this method",
"Invalid: " + t
));
wanted        
), cause);  
import java.util.*;
for(int i=0 ; i<length; i++) {
protected StackTraceElement[] unfilteredStackTrace;
protected StackTraceElement[] unfilteredStackTrace;
import java.util.*;
enhancer.setInterfaces(new Class[] { toMock });
enhancer.setSuperclass(toMock);
if (mock.getClass().getInterfaces().length == 2) {
return mock.getClass().getInterfaces()[0].getSimpleName();
return mock.getClass().getSuperclass().getSimpleName();
public static Object newInstance(Class<?> clazz) throws InstantiationException {
if (o == null || !o.getClass().equals(this.getClass()))
protected final Invocation invocation;
protected final List<IArgumentMatcher> matchers;
public InvocationsCalculator() {}
public InvocationMatcher bindMatchers(Invocation invocation) throws InvalidUseOfMatchersException {
private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {
+ invocation.getArguments().length
private Any() {
if (o == null || !this.getClass().equals(o.getClass()))
private static ThreadLocal<LastArguments> INSTANCE = new ThreadLocal<LastArguments>();
protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();
abstract void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode);
import static org.junit.Assert.*;
import static org.mockito.internal.MockUtil.*;
import java.util.*;
import net.sf.cglib.proxy.*;
assertNull(Mockito.mockingProgress.pullStubable());
Mockito.mockingProgress.validateState();
Mockito.mockingProgress.reset();
import static org.junit.Assert.*;
import static org.junit.Assert.*;
import java.util.*;
for (int i = 0 ; i < methods.length ; i++) {
import java.util.*;
import static org.junit.Assert.*;
import org.mockito.internal.progress.*;
public InvocationMatcher bindMatchers(Invocation invocation)
throws InvalidUseOfMatchersException {
import net.sf.cglib.proxy.*;
import org.mockito.internal.creation.ObjenesisClassInstantiator;
import static org.junit.Assert.*;
import org.mockito.internal.creation.MockFactory;
import org.mockito.internal.creation.ObjectMethodsFilter;
import java.util.*;
import org.mockito.internal.invocation.Invocation;
import org.mockito.internal.invocation.InvocationMatcher;
import static org.junit.Assert.*;
import java.util.*;
import org.mockito.internal.invocation.Invocation;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.matchers.*;
public void setup() throws SecurityException, NoSuchMethodException {
invocation = new InvocationBuilder().args((String)null).toInvocation();
invocation = new InvocationBuilder().method("oneArray").args(new int[] {1,2,3}).toInvocation();
invocation = new InvocationBuilder().method(m).args((Object)null).toInvocation();
import static org.junit.Assert.*;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.MockingProgressImpl;
import org.mockito.internal.progress.VerificationMode;
import static java.util.Arrays.*;
import static org.mockito.internal.progress.VerificationMode.*;
import static org.junit.Assert.*;
import java.util.*;
import org.mockito.internal.stubbing.EmptyReturnValues;
assertTrue(((Collection)EmptyReturnValues.emptyValueFor(Collection.class)).isEmpty());
assertTrue(((Set)EmptyReturnValues.emptyValueFor(Set.class)).isEmpty());
assertTrue(((SortedSet)EmptyReturnValues.emptyValueFor(SortedSet.class)).isEmpty());
assertTrue(((HashSet)EmptyReturnValues.emptyValueFor(HashSet.class)).isEmpty());
assertTrue(((TreeSet)EmptyReturnValues.emptyValueFor(TreeSet.class)).isEmpty());
assertTrue(((LinkedHashSet)EmptyReturnValues.emptyValueFor(LinkedHashSet.class)).isEmpty());        
assertTrue(((List)EmptyReturnValues.emptyValueFor(List.class)).isEmpty());
assertTrue(((ArrayList)EmptyReturnValues.emptyValueFor(ArrayList.class)).isEmpty());
assertTrue(((LinkedList)EmptyReturnValues.emptyValueFor(LinkedList.class)).isEmpty());
assertTrue(((Map)EmptyReturnValues.emptyValueFor(Map.class)).isEmpty());
assertTrue(((SortedMap)EmptyReturnValues.emptyValueFor(SortedMap.class)).isEmpty());
assertTrue(((HashMap)EmptyReturnValues.emptyValueFor(HashMap.class)).isEmpty());
assertTrue(((TreeMap)EmptyReturnValues.emptyValueFor(TreeMap.class)).isEmpty());
assertTrue(((LinkedHashMap)EmptyReturnValues.emptyValueFor(LinkedHashMap.class)).isEmpty());
import static org.junit.Assert.*;
import static org.mockito.util.ExtraMatchers.*;
import static org.junit.Assert.*;
import org.junit.*;
import org.mockito.internal.stubbing.Stubber;
import static org.junit.Assert.*;
import java.util.*;
import org.hamcrest.*;
return ((String)string).contains(text); 
return ((Throwable)throwable).getMessage().contains(text); 
Throwable cause = ((Throwable)throwable).getCause();
return cause == null? false : cause.getMessage().contains(text); 
if (((Collection)collection).contains(element) == false) {
Collection actual = (Collection)collection;
public String throwsNothing(boolean value);
public String throwsIOException(int count) throws IOException;
public String throwsError(int count) throws Error;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import org.mockito.exceptions.misusing.*;
for(int i = 1 ; i <= numberOfThreads ; i++) {
boolean failed = false;        
failed = failed? true : t.isFailed();
import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import org.mockito.*;
import static org.junit.Assert.*;
import org.junit.*;
import org.mockito.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
public void withStringVarargs(int value, String... s);
public String withStringVarargsReturningString(int value, String... s);
public void withObjectVarargs(int value, Object... o);
public boolean withBooleanVarargs(int value, boolean... b);
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import static org.mockito.util.ExtraMatchers.*;
import static org.mockito.Mockito.*;
import org.mockito.*;
public void say(Object message);
public void say(String message);
String expected = 
"Invocation differs from actual" +
"\n" +
String expectedCause = 
import static org.junit.Assert.*;
import org.mockito.internal.matchers.*;
import static org.junit.Assert.*;
import org.junit.*;
import org.mockito.*;
"No matchers found for Not(?)." +
"\n" +
, e.getMessage());
"2 matchers expected, 1 recorded." +
import static org.junit.Assert.*;
import static org.mockito.CrazyMatchers.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
"Wanted but not invoked:" +
"\n" +
"IMethods.oneArray(null)";
import java.util.*;
import org.junit.*;
import org.mockito.internal.matchers.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import static org.mockito.Mockito.*;
import org.mockito.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import static org.junit.Assert.*;
import java.util.*;
import org.mockito.*;
assertEquals((byte)0, mock.byteReturningMethod(12));
assertEquals((short)0, mock.shortReturningMethod(12));
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import java.io.*;
import java.util.*;
import org.junit.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import org.mockito.exceptions.verification.*;
import static org.junit.Assert.*;
import static org.mockito.util.ExtraMatchers.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import org.mockito.exceptions.verification.*;
String expectedMessage = 
"Wanted but not invoked:" +
"\n" +
"IMethods.simpleMethod()";
assertEquals(expectedMessage, actualMessage);         
String expected = 
assertEquals(expectedCause, e.getCause().getMessage());      
String expectedMessage = 
"No interactions wanted";
assertEquals(expectedMessage, e.getMessage());         
"\n" +
"Undesired invocation:" +
"\n" +
"IMethods.oneArg(false)";
String expected = 
String expectedCause = 
assertEquals(e.getCause().getMessage(), expectedCause);         
String expectedMessage = 
assertEquals(expectedMessage, actualMessage);         
mock = Mockito.mock(LinkedList.class); 
String expected = 
"\n" +
"Wanted 100 times but was 3";
String expectedCause = 
String expected = 
String expectedCause = 
import static org.mockito.Mockito.*;
import java.util.*;
import org.junit.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.*;
import org.mockito.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import java.util.*;
import org.mockito.*;public class InvocationsPrinterTest {public class InvocationsCalculatorTest {
public class InvocationsChunkerTest {
public class InvocationsMarkerTest {
public class VerifyingRecorderTest {if (this.arguments.length != arguments.length) {
return false;
for (int i = 0; i < this.arguments.length; i++) {
Object myArgument = this.arguments[i];
Object otherArgument = arguments[i];
if (isPrimitiveParameter(i)) {
if (!myArgument.equals(otherArgument)) {
return false;
if (myArgument != otherArgument) {
return false;
return true;
private boolean isPrimitiveParameter(int parameterPosition) {
Class<?>[] parameterTypes = method.getParameterTypes();
if (method.isVarArgs()) {
parameterPosition = Math.min(parameterPosition,
parameterTypes.length - 1);
return parameterTypes[parameterPosition].isPrimitive();
private Invocation newStringObjectShouldNotBeEqual;
newStringObjectShouldNotBeEqual    = new InvocationBuilder().args(new String(" ")).mock("mock").seq(4).toInvocation();
assertFalse(call.equals(newStringObjectShouldNotBeEqual));import java.lang.reflect.Method;
matchers.add(new Equals(arg));
import org.mockito.*;
stub(mock.oneArg(CrazyMatchers.or(eq((byte) 1), eq((byte) 2)))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.or(eq((char) 1), eq((char) 2)))).andReturn("2");
stub(mock.oneArg(CrazyMatchers.or(eq((double) 1), eq((double) 2)))).andReturn("3");
stub(mock.oneArg(CrazyMatchers.or(eq((float) 1), eq((float) 2)))).andReturn("4");
stub(mock.oneArg(CrazyMatchers.or(eq((int) 1), eq((int) 2)))).andReturn("5");
stub(mock.oneArg(CrazyMatchers.or(eq((long) 1), eq((long) 2)))).andReturn("6");
stub(mock.oneArg(CrazyMatchers.or(eq((short) 1), eq((short) 2)))).andReturn("7");
stub(mock.oneArg(CrazyMatchers.or(eq("asd"), eq("jkl")))).andReturn("8");
stub(mock.oneArg(CrazyMatchers.or(eq(this.getClass()), eq(Object.class)))).andReturn("9");
stub(mock.oneArg(CrazyMatchers.not(eq(false)))).andReturn("0");
stub(mock.oneArg(CrazyMatchers.not(eq((byte) 1)))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.not(eq('a')))).andReturn("2");
stub(mock.oneArg(CrazyMatchers.not(eq((double) 1)))).andReturn("3");
stub(mock.oneArg(CrazyMatchers.not(eq((float) 1)))).andReturn("4");
stub(mock.oneArg(CrazyMatchers.not(eq((int) 1)))).andReturn("5");
stub(mock.oneArg(CrazyMatchers.not(eq((long) 1)))).andReturn("6");
stub(mock.oneArg(CrazyMatchers.not(eq((short) 1)))).andReturn("7");
stub(mock.oneArg(CrazyMatchers.not(contains("a")))).andReturn("8");
stub(mock.oneArg(CrazyMatchers.not(isA(Class.class)))).andReturn("9");
stub(mock.oneArg(CrazyMatchers.cmpEq(new BigDecimal("1.5")))).andReturn("0");
stub(mock.oneArray(CrazyMatchers.aryEq(new boolean[] { true, false, false }))).andReturn("0");
stub(mock.oneArray(CrazyMatchers.aryEq(new byte[] { 1 }))).andReturn("1");
stub(mock.oneArray(CrazyMatchers.aryEq(new char[] { 1 }))).andReturn("2");
stub(mock.oneArray(CrazyMatchers.aryEq(new double[] { 1 }))).andReturn("3");
stub(mock.oneArray(CrazyMatchers.aryEq(new float[] { 1 }))).andReturn("4");
stub(mock.oneArray(CrazyMatchers.aryEq(new int[] { 1 }))).andReturn("5");
stub(mock.oneArray(CrazyMatchers.aryEq(new long[] { 1 }))).andReturn("6");
stub(mock.oneArray(CrazyMatchers.aryEq(new short[] { 1 }))).andReturn("7");
stub(mock.oneArray(CrazyMatchers.aryEq(new String[] { "Test" }))).andReturn("8");
stub(mock.oneArray(CrazyMatchers.aryEq(new Object[] { "Test", new Integer(4) }))).andReturn("9");
stub(mock.oneArg(CrazyMatchers.or(eq(7), eq(9)))).andReturn("7 or 9");
stub(mock.threeArgumentMethod(eq(1), CrazyMatchers.not(isNull()), eq(""))).andReturn("2");
stub(mock.threeArgumentMethod(eq(1), CrazyMatchers.not(notNull()), eq(""))).andReturn("2");
stub(mock.oneArg(CrazyMatchers.find("([a-z]+)\\d"))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.startsWith("ab"))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.startsWith("bc"))).andReturn("2");
stub(mock.oneArg(CrazyMatchers.endsWith("ab"))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.endsWith("bc"))).andReturn("2");
stub(mock.oneArg(CrazyMatchers.same(one))).andReturn("1");
stub(mock.oneArg(CrazyMatchers.same(two))).andReturn("2");mockTwo.containsKey("ExceptionFour");StackTraceElement[] getUnfilteredStackTrace();
boolean firstOnStackIsMockitoClass = e.getClassName().equals("org.mockito.Mockito");
boolean firstOnStackIsMockObject = e.getClassName().contains("$$EnhancerByCGLIB$$");
return firstOnStackIsMockitoClass || firstOnStackIsMockObject;
throw throwable.fillInStackTrace();
import static org.mockito.util.ExtraMatchers.*;
assertThat(expected, firstMethodOnStackEqualsTo("shouldFilterStackTraceOnThrowingExceptionFromControl"));
import static org.mockito.util.ExtraMatchers.firstMethodOnStackEqualsTo;
public void shouldDoTheStackTraceProperly() throws Exception {
stub(mock.add("ExceptionOne")).andThrows(new ExceptionOne());
try {
addObjectToMockedList("ExceptionOne");
fail();
assertThat(e, firstMethodOnStackEqualsTo("addObjectToMockedList"));
private void addObjectToMockedList(String string) {
mock.add("ExceptionOne");import org.mockito.usage.*;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage;
package org.mockito.usage.binding;
package org.mockito.usage.binding;
package org.mockito.usage.matchers;
import org.mockito.usage.IMethods;
package org.mockito.usage.matchers;
package org.mockito.usage.matchers;
import org.mockito.usage.IMethods;
package org.mockito.usage.matchers;
import org.mockito.usage.IMethods;
package org.mockito.usage.matchers;
package org.mockito.usage.stubbing;
package org.mockito.usage.stubbing;
import org.mockito.usage.IMethods;
package org.mockito.usage.stubbing;
package org.mockito.usage.verification;
package org.mockito.usage.verification;
package org.mockito.usage.verification;
package org.mockito.usage.verification;
import org.mockito.usage.IMethods;
package org.mockito.usage.verification;
import org.mockito.usage.IMethods;
package org.mockito.usage.verification;
package org.mockito.usage.verification;
import org.mockito.usage.IMethods;
package org.mockito.usage.verification;
import org.mockito.usage.IMethods;
package org.mockito.usage.verification;
package org.mockito.usage.verification;
import org.mockito.usage.IMethods;import java.lang.reflect.Method;
import static org.junit.Assert.*;
import org.junit.*;
private MockitoBehavior behavior;
private ExpectedInvocation toLowerCaseInvocation;
public void setup() throws Exception {
Method toLowerCase = String.class.getMethod("toLowerCase", new Class[] {});
toLowerCaseInvocation = new ExpectedInvocation(new Invocation("mock", toLowerCase , new Object[] {}, 0), Collections.EMPTY_LIST);
behavior = new MockitoBehavior();
behavior.checkForWrongNumberOfInvocations(toLowerCaseInvocation, inOrder);import static org.junit.Assert.*;
import org.mockito.exceptions.NumberOfInvocationsAssertionError;
try {
behavior.checkForWrongNumberOfInvocations(toLowerCaseInvocation, VerifyingMode.inOrder(1, Arrays.asList(new Object())));
fail();verifyingMode.atLeastOnceMode() || verifyingMode.getExpectedNumberOfInvocations() >= verifiedSoFar;
private Method toLowerCase;
private Method toUpperCase;
toLowerCase = String.class.getMethod("toLowerCase", new Class[] {});
toUpperCase = String.class.getMethod("toUpperCase", new Class[] {});
public void shouldMarkVerifiedOnlyOneExecutionChunk() throws Exception {
ExpectedInvocation toLowerCaseInvocation = new ExpectedInvocation(new Invocation("mock", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);
ExpectedInvocation toUpperCaseInvocation = new ExpectedInvocation(new Invocation("mock", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);
behavior.addInvocation(toLowerCaseInvocation);
behavior.addInvocation(toLowerCaseInvocation);
behavior.addInvocation(toUpperCaseInvocation);
behavior.addInvocation(toLowerCaseInvocation);
behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.inOrder(2, Arrays.asList(new Object())));
List<ExpectedInvocation> invocations = behavior.getRegisteredInvocations();
assertEquals(true, invocations.get(0).getInvocation().isVerified());
assertEquals(true, invocations.get(1).getInvocation().isVerified());
assertEquals(false, invocations.get(2).getInvocation().isVerified());
assertEquals(false, invocations.get(3).getInvocation().isVerified());private void markInvocationsAsVerified(InvocationWithMatchers expected, VerifyingMode verifyingMode) {import org.mockito.exceptions.MissingMethodInvocationException;
void verifyNoMoreInteractions();
import static org.hamcrest.CoreMatchers.*;
assertThat(superClass, equalTo(Object.class));
assertThat(superClass, equalTo(ClassWithoutConstructor.class));
assertThat(mock, notNullValue());
public void shouldVerifyNoInteractions() throws Exception {
strictly.verifyNoMoreInteractions();public void shouldLetYouVerifyTheSameMethodAnyTimes() throws Exception {package org.mockito.usage.binding;
public class BaseClass<M extends BaseMessage, D extends IBaseInteface<M>> {
private final D object;
BaseClass(D object) {
this.object = object;
public void print(M message) {
object.print(message);
package org.mockito.usage.binding;
public class BaseMessage {
private String content;
public String getContent() {
return content;
protected void setContent(String content) {
this.content = content;
package org.mockito.usage.binding;
public class ClassUseDerivedInterface extends BaseClass<Message, IDerivedInterface> {
public ClassUseDerivedInterface(IDerivedInterface derivedIterfaceObject) {
super(derivedIterfaceObject);
package org.mockito.usage.binding;
public interface IBaseInteface <E extends BaseMessage>{
public void print(E message);
package org.mockito.usage.binding;
public interface IDerivedInterface extends IBaseInteface<Message>{
public void print(Message message);
package org.mockito.usage.binding;
public interface ISuperDerived extends IBaseInteface<Message> {
public void print(Message Message);
package org.mockito.usage.binding;
import org.junit.Test;
import org.mockito.Mockito;
public class IncorectBindingTest {
public void overriddenInterfaceMethod() throws Exception {
IDerivedInterface mock = Mockito.mock(IDerivedInterface.class);
ClassUseDerivedInterface superDerived = new ClassUseDerivedInterface(mock);
Message message = new Message("Shake it baby");
superDerived.print(message);
Mockito.verify(mock).print(message);
package org.mockito.usage.binding;
public class Message extends BaseMessage{
public Message(String content) {
setContent(content);
package org.mockito.usage.binding;
import org.junit.Test;
import org.mockito.Mockito;
public class OverriddenIntrefaceMethodTest {
public void virtualMethodTableBinding() throws Exception {
IDerivedInterface mock = Mockito.mock(IDerivedInterface.class);
ClassUseDerivedInterface superDerived = new ClassUseDerivedInterface(mock);
Message message = new Message("Shake it baby");
superDerived.print(message);
Mockito.verify(mock).print(message);
package org.mockito.usage.binding;
public class SuperClassUseSuperDerived extends BaseClass<Message, IDerivedInterface> {
public SuperClassUseSuperDerived(IDerivedInterface derivedIterfaceObject) {
super(derivedIterfaceObject);return 1; //invocation.hashCode();
package org.easymock.tests;
import static org.junit.Assert.*;
import org.easymock.AbstractMatcher;
import org.easymock.ArgumentsMatcher;
import org.easymock.MockControl;
import org.junit.Before;
import org.junit.Test;
public class ArgumentsMatcherTest {
MockControl<IMethods> control;
IMethods mock;
public void setUp() {
control = MockControl.createStrictControl(IMethods.class);
mock = control.getMock();
public void expectedArgumentsDelegatedToMatcher() {
mock.twoArgumentMethod(0, 5);
control.setMatcher(new AbstractMatcher() {
public boolean matches(Object[] expected, Object[] actual) {
assertEquals(0, ((Integer) expected[0]).intValue());
assertEquals(5, ((Integer) expected[1]).intValue());
assertEquals(1, ((Integer) actual[0]).intValue());
assertEquals(6, ((Integer) actual[1]).intValue());
return true;
mock.simpleMethod();
control.replay();
mock.twoArgumentMethod(1, 6);
mock.simpleMethod();
control.verify();
public void expectedArgumentsDelegatedToMatcher2() {
mock.threeArgumentMethod(7, "", "A test");
control.setMatcher(new AbstractMatcher() {
public boolean matches(Object[] expected, Object[] actual) {
int expectedInt = ((Integer) expected[0]).intValue();
int actualInt = ((Integer) actual[0]).intValue();
return expectedInt < actualInt;
control.setReturnValue("1");
mock.threeArgumentMethod(6, "", "A test");
control.setReturnValue("2");
mock.threeArgumentMethod(12, "", "A test");
control.setReturnValue("3");
control.replay();
mock.threeArgumentMethod(9, "test", "test");
mock.threeArgumentMethod(8, "test", "test");
mock.threeArgumentMethod(13, "test", "test");
control.verify();
public void errorString() {
mock.twoArgumentMethod(0, 5);
control.setMatcher(new ArgumentsMatcher() {
public boolean matches(Object[] expected, Object[] actual) {
return false;
public String toString(Object[] arguments) {
return "<<" + arguments[0] + ">>";
control.replay();
boolean failed = false;
try {
mock.twoArgumentMethod(1, 5);
failed = true;
assertEquals("\n  Unexpected method call twoArgumentMethod(1, 5):"
+ "\n    twoArgumentMethod(<<0>>): expected: 1, actual: 0",
expected.getMessage());
if (!failed) {
fail("exception expected");
public void settingTheSameMatcherIsOk() {
try {
mock.twoArgumentMethod(1, 2);
control.setMatcher(MockControl.ARRAY_MATCHER);
control.setMatcher(MockControl.ARRAY_MATCHER);
mock.twoArgumentMethod(1, 2);
control.setMatcher(MockControl.ARRAY_MATCHER);
fail("no exception should be thrown if the same matcher is set twice");
public void abstractMatcher() {
AbstractMatcher trueMatcher = new AbstractMatcher() {
protected boolean parameterMatches(Object expected, Object actual) {
return true;
Object[] arrayWithNull = new Object[] { null };
Object[] arrayWithObject = new Object[] { new Object() };
assertFalse(trueMatcher.matches(arrayWithNull, arrayWithObject));
assertFalse(trueMatcher.matches(arrayWithObject, arrayWithNull));
public void abstractMatcherToStringHandlesNullArray() {
AbstractMatcher matcher = new AbstractMatcher() {
assertEquals("", matcher.toString(null));
package org.easymock.tests;
import static org.junit.Assert.*;
import org.easymock.ArgumentsMatcher;
import org.easymock.MockControl;
import org.junit.Test;
public class ArrayMatcherTest {
private static ArgumentsMatcher MATCHER = MockControl.ARRAY_MATCHER;
public void booleanArray() {
assertTrue(equals(new boolean[] { true }, new boolean[] { true }));
assertFalse(equals(new boolean[] { true }, new boolean[] { false }));
public void byteArray() {
assertTrue(equals(new byte[] { 6 }, new byte[] { 6 }));
assertFalse(equals(new byte[] { 6 }, new byte[] { 7 }));
public void charArray() {
assertTrue(equals(new char[] { 'x' }, new char[] { 'x' }));
assertFalse(equals(new char[] { 'x' }, new char[] { 'y' }));
public void doubleArray() {
assertTrue(equals(new double[] { 6.0 }, new double[] { 6.0 }));
assertFalse(equals(new double[] { 6.0 }, new double[] { 7.0 }));
public void floatArray() {
assertTrue(equals(new float[] { 6.0F }, new float[] { 6.0F }));
assertFalse(equals(new float[] { 6.0F }, new float[] { 7.0F }));
public void intArray() {
assertTrue(equals(new int[] { 6 }, new int[] { 6 }));
assertFalse(equals(new int[] { 6 }, new int[] { 7 }));
public void longArray() {
assertTrue(equals(new long[] { 6 }, new long[] { 6 }));
assertFalse(equals(new long[] { 6 }, new long[] { 7 }));
public void shortArray() {
assertTrue(equals(new short[] { 6 }, new short[] { 6 }));
assertFalse(equals(new short[] { 6 }, new short[] { 7 }));
public void objectArray() {
assertTrue(equals(new String[] { "1", "2" }, new String[] { "1", "2" }));
assertFalse(equals(new String[] { "1", "2" }, new String[] { "2", "2" }));
public void nonArray() {
assertTrue(equals("1", "1"));
assertFalse(equals("1", "2"));
public void testToString() {
assertEquals("[true, false]", stringFor(new boolean[] { true, false }));
assertEquals("[6, 7]", stringFor(new byte[] { 6, 7 }));
assertEquals("['x', 'y']", stringFor(new char[] { 'x', 'y' }));
assertEquals("[6.0, 7.0]", stringFor(new double[] { 6, 7 }));
assertEquals("[6.0, 7.0]", stringFor(new float[] { 6, 7 }));
assertEquals("[6, 7]", stringFor(new int[] { 6, 7 }));
assertEquals("[6, 7]", stringFor(new long[] { 6, 7 }));
assertEquals("[6, 7]", stringFor(new short[] { 6, 7 }));
assertEquals("[\"1\", \"2\"]", stringFor(new String[] { "1", "2" }));
assertEquals("[\"1\", \"2\"]", stringFor(new Object[] { "1", "2" }));
public void toStringMixed() {
assertEquals("3, [\"1\", 2.0], \"Test\"", MATCHER
.toString(new Object[] { new Integer(3),
new Object[] { "1", new Float(2.0) }, "Test" }));
private String stringFor(Object argument) {
return MATCHER.toString(new Object[] { argument });
private boolean equals(Object o1, Object o2) {
Object[] expected = new Object[] { o1 };
Object[] actual = new Object[] { o2 };
return MATCHER.matches(expected, actual);
package org.easymock.tests;
import static org.junit.Assert.*;
import org.easymock.MockControl;
import org.junit.Before;
import org.junit.Test;
public class DefaultMatcherTest {
public static interface ArrayInterface {
void methodA(int[] argument);
void methodB(int[] argument);
private MockControl<ArrayInterface> control;
private ArrayInterface mock;
public void setup() {
control = MockControl.createControl(ArrayInterface.class);
mock = control.getMock();
public void defaultMatcher() {
control.setDefaultMatcher(MockControl.ARRAY_MATCHER);
mock.methodA(new int[] { 1, 1 });
mock.methodB(new int[] { 2, 2 });
control.replay();
mock.methodA(new int[] { 1, 1 });
mock.methodB(new int[] { 2, 2 });
control.verify();
public void failInReplayState() {
control.replay();
try {
control.setDefaultMatcher(MockControl.ARRAY_MATCHER);
fail();
public void failIfDefaultMatcherSetTwice() {
control.setDefaultMatcher(MockControl.ARRAY_MATCHER);
try {
control.setDefaultMatcher(MockControl.ARRAY_MATCHER);
fail();
assertEquals(
"default matcher can only be set once directly after creation of the MockControl",
expected.getMessage());
public void defaultMatcherSetTooLate() {
int[] integers = new int[] { 1, 1 };
int[] integers2 = new int[] { 2, 2 };
mock.methodA(integers);
control.setVoidCallable();
control.setDefaultMatcher(MockControl.ARRAY_MATCHER);
mock.methodA(integers2);
control.setVoidCallable();
control.replay();
boolean failed = true;
try {
mock.methodA(new int[] { 1, 1 });
failed = false;
if (!failed) {
fail();
mock.methodA(integers);
mock.methodA(new int[] { 2, 2 });
control.verify();
package org.easymock.tests;
import static org.junit.Assert.*;
import org.easymock.ArgumentsMatcher;
import org.easymock.MockControl;
import org.junit.Test;
public class EqualsMatcherTest {
final ArgumentsMatcher MATCHER = MockControl.EQUALS_MATCHER;
public void equalsMatcher() {
assertTrue(MATCHER.matches(null, null));
assertFalse(MATCHER.matches(null, new Object[0]));
assertFalse(MATCHER.matches(new Object[0], null));
assertFalse(MATCHER.matches(new Object[] { "" }, new Object[] { null }));
assertFalse(MATCHER.matches(new Object[] { null }, new Object[] { "" }));
assertTrue(MATCHER
.matches(new Object[] { null }, new Object[] { null }));
assertTrue(MATCHER.matches(new Object[] { "x" }, new Object[] { "x" }));
public void differentNumberOfArguments() {
assertFalse(MATCHER.matches(new Object[2], new Object[3]));
package org.easymock.tests;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import org.easymock.internal.ExpectedInvocation;
import org.easymock.internal.Invocation;
import org.junit.Before;
import org.junit.Test;
public class ExpectedMethodCallTest {
private ExpectedInvocation call;
public void setup() throws SecurityException, NoSuchMethodException {
Object[] arguments1 = new Object[] { "" };
Method m = Object.class.getMethod("equals",
new Class[] { Object.class });
call = new ExpectedInvocation(new Invocation(null, m, arguments1), null);
public void shouldMockString() throws Exception {
String s = Mockito.mock(String.class);
stub(s.concat("world")).andReturn("hello world");
assertThat(s.concat("world"), equalTo("hello world"));