millis = savedFields[i].set(millis, i == (count - 1));yearToUse++;
months -= iMax;if (appendable instanceof Writer) {
StringBuffer buf = new StringBuffer(estimatePrintedLength());
underlying.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
appendable.append(buf);
if (appendable instanceof Writer) {
StringBuffer buf = new StringBuffer(estimatePrintedLength());
underlying.printTo(buf, partial, locale);
appendable.append(buf);static final boolean JDK6;
boolean jdk6 = true;
try {
DateFormatSymbols.class.getMethod("getInstance", new Class[] {Locale.class});
jdk6 = false;
JDK6 = jdk6;
if (JDK6) {
public void testGetName_berlin() {
assertEquals("Central European Time", berlin.getName(TEST_TIME_WINTER, Locale.ENGLISH));
assertEquals("Central European Summer Time", berlin.getName(TEST_TIME_SUMMER, Locale.ENGLISH));
if (JDK6) {
assertEquals("Mitteleurop\u00e4ische Zeit", berlin.getName(TEST_TIME_WINTER, Locale.GERMAN));
assertEquals("Mitteleurop\u00e4ische Sommerzeit", berlin.getName(TEST_TIME_SUMMER, Locale.GERMAN));
assertEquals("Zentraleurop\u00e4ische Zeit", berlin.getName(TEST_TIME_WINTER, Locale.GERMAN));
assertEquals("Zentraleurop\u00e4ische Sommerzeit", berlin.getName(TEST_TIME_SUMMER, Locale.GERMAN));
assertEquals(dt.toString(), "AM", f.print(dt));
assertEquals(dt.toString(), "AM", f.print(dt));
assertEquals(dt.toString(), "PM", f.print(dt));
DateTimeFormatter f = DateTimeFormat.forPattern("z").withLocale(Locale.UK);
DateTimeFormatter f = DateTimeFormat.forPattern("zzzz").withLocale(Locale.UK);
assertEquals("$06-PM-2007", str);
assertEquals("$BC-0001", str);
DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S z");str = str.toLowerCase();BufferedReader in = new BufferedReader(new FileReader(sources[i]));
parseDataFile(in, "backward".equals(sources[i].getName()));
in.close();transitions.remove(size - 1);
return addTransition(transitions, tr);
if (offset == nextOffset
&& key.equals(nextKey)) {static final int MAX_LENGTH;
static {
int pos = prefixedStartPosition(text, position);
for (int i = pos; i < ALL_IDS.size(); i++) {
String id = ALL_IDS.get(i);
if (csStartsWith(text, position, id)) {
if (best == null || id.length() > best.length()) {
best = id;
break;
bucket.setZone(DateTimeZone.forID(best));
return position + best.length();
private static int prefixedStartPosition(CharSequence text, int position) {
int lo = 0;
int hi = ALL_IDS.size() - 1;
while (lo <= hi) {
int mid = (lo + hi) >>> 1;
String value = ALL_IDS.get(mid);
int compare = csCompare(text, position, value);
if (compare > 0) {
hi = mid - 1;
lo = mid + 1;
return mid;
return lo;
static int csCompare(CharSequence text, int position, String search) {
int matchLen = text.length() - position;
int searchLen = search.length();
int compareLen = Math.min(matchLen, searchLen);
for (int i = 0; i < compareLen; i++) {
int result = search.charAt(i) - text.charAt(position + i);
if (result != 0) {
return result;
return searchLen - matchLen;public Duration dividedBy(long divisor,RoundingMode roundingMode) {
if(divisor==1) {
return new Duration(FieldUtils.safeDivide(getMillis(),divisor,roundingMode));
assertEquals(123L,result.getMillis());
assertEquals(61L,result.getMillis());
assertEquals(18L,result.getMillis());
Duration result = test.dividedBy(1L,RoundingMode.FLOOR);
assertSame(test,result);
public void testSafeDivideRoundingModeLong()
assertEquals(3L,FieldUtils.safeDivide(15L, 5L, RoundingMode.UNNECESSARY));
assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L,RoundingMode.UNNECESSARY));
assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L,RoundingMode.UNNECESSARY));
assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L,RoundingMode.UNNECESSARY));
FieldUtils.safeDivide(Long.MIN_VALUE, -1L,RoundingMode.UNNECESSARY);
FieldUtils.safeDivide(1L, 0L,RoundingMode.UNNECESSARY);if (iLoader != null) {
in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
public InputStream run() {
in = ClassLoader.getSystemResourceAsStream(path);int yearToUse;
yearToUse = thisYear + (monthToUse / iMax);
yearToUse = thisYear + (monthToUse / iMax) - 1;private static final SystemMillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();writeTo(zoneID, (DataOutput)new DataOutputStream(out));DataOutputStream dout = new DataOutputStream(out);
writeTo(zoneID, (DataOutput)dout);
dout.flush();writeTo(zoneID, (DataOutput)new DataOutputStream(out));oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();
oos.close();int compareLen = Math.min(text.length() - position, search.length());
return 0;int compareLen = Math.min(text.length() - position, search.length());
return 0;
if (st.countTokens() < 4) {
throw new IllegalArgumentException("Attempting to create a Zone from an incomplete tokenizer");
static final String BROKEN_TIMEZONE_FILE_2 =
"# Incomplete Zone for building America/Los_Angeles time zone.\n" +
"\n" +
"Rule    CA  1948    only    -   Mar 14  2:00    1:00    D\n" +
"Rule    CA  1949    only    -   Jan  1  2:00    0   S\n" +
"\n" +
"Zone "; // this line is intentionally left incomplete
public void testCompileOnBrokenTimeZoneFile_2() throws Exception {
try {
Provider provider = compileAndLoad(BROKEN_TIMEZONE_FILE_2);
fail();
fail("NoSuchElementException was thrown; broken timezone file?");
assertEquals("Attempting to create a Zone from an incomplete tokenizer", iae.getMessage());if (localInstant > 0 && utcInstant < 0) {(c = text.charAt(position + length + 1)) < '0' || c > '9')
if (negative) {
length++;
position++;
value = Integer.parseInt(text.subSequence(position, position += length).toString());
if (negative) {if (iChronology.year().isSupported()) {
iChronology.year().set(iMillis, iChronology.year().get(iMillis));
return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
return getDateMidnightMillis(year, monthOfYear, dayOfMonth)
+ hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
+ minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
+ secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
+ millisOfSecond;
FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());
return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);
millis = iField.set(millis, iValue);
public void testConstructor_long_max() throws Throwable {
DateTime dt = new DateTime(292278993, 12, 31, 23, 59, 59, 999);
DateTime test = new DateTime(dt.getMillis());
assertEquals(dt, test);
try {
new DateTime(dt.getMillis() + 1);
fail();
public void testConstructor_long_min() throws Throwable {
DateTime dt = new DateTime(-292275054, 1, 1, 0, 0);
DateTime test = new DateTime(dt.getMillis());
assertEquals(dt, test);
try {
new DateTime(dt.getMillis() - 1);
fail();throw new IllegalArgumentException("The end instant must be greater or equal to the start");return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());public void testParse_noFormatter() throws Throwable {static final List<String> ALL_IDS;
int compare = csCompare(value, text, position);
static int csCompare(String search, CharSequence text, int position) {
if (result != 0) return result;if (strings != null && strings.length == 5 && id.equals(strings[0])) {
if (strings != null && strings.length == 5 && id.equals(strings[0])) {
if (strings != null && strings.length == 5 && id.equals(strings[0])) {
if (strings != null && strings.length == 5 && id.equals(strings[0])) {if (strings != null && strings.length == 5 && id.equals(strings[0])) {
setEn = strings;
break;
if (strings != null && strings.length == 5 && id.equals(strings[0])) {
setLoc = strings;
break;
byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
if (setEn[2].equals(setEn[4])) {
byNameKeyCache.put(setEn[4] + "-Summer", new String[] {setLoc[4], setLoc[3]});
byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
if (strings != null && strings.length == 5 && id.equals(strings[0])) {
setEn = strings;
break;
if (strings != null && strings.length == 5 && id.equals(strings[0])) {
setLoc = strings;
break;
byNameKeyCache.put(Boolean.TRUE, new String[] {setLoc[2], setLoc[1]});
byNameKeyCache.put(Boolean.FALSE, new String[] {setLoc[4], setLoc[3]});Interval interval = new Interval(start, end);
DateTime midnightTest = new DateTime(2004, 6, 9, 23, 23, 43, 53);
assertEquals(new DateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart());
assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd());if (ZoneInfoCompiler.verbose()) {
if (ZoneInfoCompiler.verbose()) {
static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
protected Boolean initialValue() {
return Boolean.FALSE;
public static boolean verbose() {
return cVerbose.get();
cVerbose.set(verbose);
if (ZoneInfoCompiler.verbose()) {
if (ZoneInfoCompiler.verbose()) {
if (ZoneInfoCompiler.verbose()) {boolean negative = c == '-';
if (wholeValue < 0) {long instant = getMillis();
instant = chrono.year().set(instant, year);
instant = chrono.monthOfYear().set(instant, monthOfYear);
instant = chrono.dayOfMonth().set(instant, dayOfMonth);
return withMillis(instant);
long instant = getMillis();
instant = chrono.hourOfDay().set(instant, hourOfDay);
instant = chrono.minuteOfHour().set(instant, minuteOfHour);
instant = chrono.secondOfMinute().set(instant, secondOfMinute);
instant = chrono.millisOfSecond().set(instant, millisOfSecond);
return withMillis(instant);int curMonth0 = partial.getValue(0) - 1;
MonthDay result = test.plusDays(30);
MonthDay expected = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
MonthDay result = test.plusDays(31);
MonthDay expected = new MonthDay(12, 1, ISOChronology.getInstanceUTC());ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale);
if (containsKey(b, "PeriodFormat.regex.separator")) {
pf = buildRegExFormatter(b);
pf = buildNonRegExFormatter(b);
FORMATTERS.putIfAbsent(locale, pf);
private static PeriodFormatter buildRegExFormatter(ResourceBundle b) {
return builder.toFormatter();
private static PeriodFormatter buildNonRegExFormatter(ResourceBundle b) {
.toFormatter();
private PeriodFormatter(LocalDate date = (day == -1 ?
new LocalDate(2001, month, 1).plusMonths(1) :
new LocalDate(2001, month, day).plusDays(1));
advance = (day != -1 && dayOfWeek != 0);
month = date.getMonthOfYear();
day = date.getDayOfMonth();
if (dayOfWeek != 0) {
dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;public void testWithTime_int_int_int() {private static void validateProvider(Provider provider) {
Provider provider = null;
provider = (Provider) Class.forName(providerClass).newInstance();
if (provider == null) {
try {
provider = new ZoneInfoProvider("org/joda/time/tz/data");
ex.printStackTrace();
if (provider == null) {
provider = new UTCProvider();
validateProvider(provider);
return provider;String name = getNameProvider().getShortName(locale, iID, nameKey);
String name = getNameProvider().getName(locale, iID, nameKey);import java.io.PrintStream;
assertEquals(value, zone.getID());
TimeZone juZone = TimeZone.getTimeZone("CAT");
DateTimeZone zone = DateTimeZone.forTimeZone(juZone);
assertTrue(zone.getID().equals("Africa/Harare") || zone.getID().equals("Africa/Maputo"));if (affixToIgnore.length() > shortestAffixLength) {
if (textLength < textToIgnoreLength
&& periodStr.regionMatches(true, position, affixToIgnore, 0, textToIgnoreLength)) {
if (periodStr.regionMatches(false, pos, text, 0, textLength)) {
if (periodStr.regionMatches
(true, position, text1, 0, text1.length())) {
if (periodStr.regionMatches
(true, position, text2, 0, text2.length())) {
periodStr.regionMatches
(true, position, parsedForm, 0, parsedForm.length())) {
.appendYears().appendSuffix("Y").appendSeparator(" ")
.appendWeeks().appendSuffix("W").appendSeparator(" ")
.appendDays().appendSuffix("D").appendSeparator(" ")
.appendHours().appendSuffix("h").appendSeparator(" ")
.appendSeconds().appendSuffix("s")map.put("CAT", "Africa/Harare");advance = (day != -1);
dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;if (time != null && getChronology() != time.getChronology()) {
long instant = DateTimeUtils.currentTimeMillis();
instant = chrono.set(this, instant);
if (time != null) {
instant = chrono.set(time, instant);
return new DateTime(instant, chrono);public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0);private String[] iOtherAffixes = new String[0];
private boolean iFinished = false;
if (!iFinished) {
iFinished = true;
for (String affixToIgnore : iOtherAffixes) {
int textToIgnoreLength = affixToIgnore.length();
if (textLength < textToIgnoreLength
&& periodStr.regionMatches(true, position, affixToIgnore, 0, textToIgnoreLength)) {
return true;
private boolean iFinished = false;
if (!iFinished) {
iFinished = true;
Set<PeriodFieldAffix> prefixesToIgnore = new HashSet<PeriodFieldAffix>();
Set<PeriodFieldAffix> suffixesToIgnore = new HashSet<PeriodFieldAffix>();
for (FieldFormatter fieldFormatter : fieldFormatters) {
if (fieldFormatter != null && !this.equals(fieldFormatter)) {
prefixesToIgnore.add(fieldFormatter.iPrefix);
suffixesToIgnore.add(fieldFormatter.iSuffix);
if (iPrefix != null) {
iPrefix.finish(prefixesToIgnore);                    
if (iSuffix != null) {
iSuffix.finish(suffixesToIgnore);                    private String[] iOtherAffixes = new String[]{};
iOtherAffixes = affixesToIgnore.toArray(new String[affixesToIgnore
.size()]);
&& periodStr.regionMatches(true, position, affixToIgnore, 0,
textToIgnoreLength)) {
return pos;                        
return pos;                        
Set<PeriodFieldAffix> prefixesToIgnore = new HashSet<PeriodFormatterBuilder.PeriodFieldAffix>();
Set<PeriodFieldAffix> suffixesToIgnore = new HashSet<PeriodFormatterBuilder.PeriodFieldAffix>();static class SimpleAffix implements PeriodFieldAffix {
return position + textLength;
return pos;
static class PluralAffix implements PeriodFieldAffix {
return position + text1.length();
return position + text2.length();
return pos;
return pos;
static class RegExAffix implements PeriodFieldAffix {
return position + text.length();
return pos;
static class CompositeAffix implements PeriodFieldAffix {
position = iLeft.parse(periodStr, position);
if (position >= 0) {
position = iRight.parse(periodStr, position);
return position;
if (rightPosition >= 0 && leftPosition > 0) { 
return leftPosition;
return rightPosition;
PeriodFormatter f = new PeriodFormatterBuilder().appendDays().appendSuffix("day", "days").toFormatter();
f.parsePeriod(twoDays);
PeriodFormatter f = new PeriodFormatterBuilder().appendDays()
f.parsePeriod(twoDays);
PeriodFormatter f = new PeriodFormatterBuilder().appendPrefix("d")
PeriodFormatter f = new PeriodFormatterBuilder().appendDays().appendSuffix("d")int pos = iLeft.scan(periodStr, position);
if (pos >= 0) {
return iRight.scan(periodStr, pos);for (String text : iSuffixes) {
for (String text : iSuffixes) {if (b.containsKey("PeriodFormat.regex.separator")) {
PeriodFormatterBuilder builder = new PeriodFormatterBuilder().appendYears();
if (b.containsKey("PeriodFormat.years.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.years.regex").split(regExSeparator),
b.getString("PeriodFormat.years.list").split(regExSeparator));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMonths();
if (b.containsKey("PeriodFormat.months.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.months.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendWeeks();
if (b.containsKey("PeriodFormat.weeks.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.weeks.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendDays();
if (b.containsKey("PeriodFormat.days.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.days.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendHours();
if (b.containsKey("PeriodFormat.hours.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.hours.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMinutes();
if (b.containsKey("PeriodFormat.minutes.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.minutes.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendSeconds();
if (b.containsKey("PeriodFormat.seconds.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.seconds.regex").split(regExSeparator),
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMillis();
if (b.containsKey("PeriodFormat.milliseconds.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.milliseconds.regex").split(regExSeparator),
if (regularExpressions == null || prefixes == null || regularExpressions.length < 1
|| regularExpressions.length != prefixes.length) {
if (regularExpressions == null || suffixes == null || regularExpressions.length < 1
|| regularExpressions.length != suffixes.length) {iSuffixes = texts;
assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat
.wordBased(FR).print(p));
assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat
.wordBased(FR).print(p));
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
public void test_wordBased_fr_from_en() {
assertEquals("1 dzie\u0144, 5 godzin, 6 minut, 7 sekund i 8 milisekund", PeriodFormat
.wordBased(PL).print(p));ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale);
if (b.containsKey("PeriodFormat.regex.separator")) {
pf = buildRegExFormatter(b);
pf = buildNonRegExFormatter(b);
FORMATTERS.putIfAbsent(locale, pf);
private static PeriodFormatter buildRegExFormatter(ResourceBundle b) {
String[] variants = retrieveVariants(b);
String regExSeparator = b.getString("PeriodFormat.regex.separator");
PeriodFormatterBuilder builder = new PeriodFormatterBuilder().appendYears();
if (b.containsKey("PeriodFormat.years.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.years.regex").split(regExSeparator),
b.getString("PeriodFormat.years.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.year"), b.getString("PeriodFormat.years"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMonths();
if (b.containsKey("PeriodFormat.months.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.months.regex").split(regExSeparator),
b.getString("PeriodFormat.months.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.month"), b.getString("PeriodFormat.months"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendWeeks();
if (b.containsKey("PeriodFormat.weeks.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.weeks.regex").split(regExSeparator),
b.getString("PeriodFormat.weeks.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.week"), b.getString("PeriodFormat.weeks"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendDays();
if (b.containsKey("PeriodFormat.days.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.days.regex").split(regExSeparator),
b.getString("PeriodFormat.days.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.day"), b.getString("PeriodFormat.days"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendHours();
if (b.containsKey("PeriodFormat.hours.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.hours.regex").split(regExSeparator),
b.getString("PeriodFormat.hours.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.hour"), b.getString("PeriodFormat.hours"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMinutes();
if (b.containsKey("PeriodFormat.minutes.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.minutes.regex").split(regExSeparator),
b.getString("PeriodFormat.minutes.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.minute"), b.getString("PeriodFormat.minutes"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendSeconds();
if (b.containsKey("PeriodFormat.seconds.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.seconds.regex").split(regExSeparator),
b.getString("PeriodFormat.seconds.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.second"), b.getString("PeriodFormat.seconds"));
builder.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMillis();
if (b.containsKey("PeriodFormat.milliseconds.regex")) {
builder.appendSuffix(b.getString("PeriodFormat.milliseconds.regex").split(regExSeparator),
b.getString("PeriodFormat.milliseconds.list").split(regExSeparator));
builder.appendSuffix(b.getString("PeriodFormat.millisecond"), b.getString("PeriodFormat.milliseconds"));
return builder.toFormatter();
private static PeriodFormatter buildNonRegExFormatter(ResourceBundle b) {
String[] variants = retrieveVariants(b);
return new PeriodFormatterBuilder()
.appendYears()
.appendSuffix(b.getString("PeriodFormat.year"), b.getString("PeriodFormat.years"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMonths()
.appendSuffix(b.getString("PeriodFormat.month"), b.getString("PeriodFormat.months"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendWeeks()
.appendSuffix(b.getString("PeriodFormat.week"), b.getString("PeriodFormat.weeks"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendDays()
.appendSuffix(b.getString("PeriodFormat.day"), b.getString("PeriodFormat.days"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendHours()
.appendSuffix(b.getString("PeriodFormat.hour"), b.getString("PeriodFormat.hours"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMinutes()
.appendSuffix(b.getString("PeriodFormat.minute"), b.getString("PeriodFormat.minutes"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendSeconds()
.appendSuffix(b.getString("PeriodFormat.second"), b.getString("PeriodFormat.seconds"))
.appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants)
.appendMillis()
.appendSuffix(b.getString("PeriodFormat.millisecond"), b.getString("PeriodFormat.milliseconds"))
.toFormatter();
private static String[] retrieveVariants(ResourceBundle b) {
return new String[] { b.getString("PeriodFormat.space"), b.getString("PeriodFormat.comma"),
b.getString("PeriodFormat.commandand"), b.getString("PeriodFormat.commaspaceand") };
public PeriodFormatterBuilder appendPrefix(String[] regularExpressions, String[] prefixes) {
if (regularExpressions == null || prefixes == null || regularExpressions.length < 1
|| regularExpressions.length != prefixes.length) {
throw new IllegalArgumentException();
return appendPrefix(new RegExAffix(regularExpressions, prefixes));
public PeriodFormatterBuilder appendSuffix(String[] regularExpressions, String[] suffixes) {
if (regularExpressions == null || suffixes == null || regularExpressions.length < 1
|| regularExpressions.length != suffixes.length) {
throw new IllegalArgumentException();
return appendSuffix(new RegExAffix(regularExpressions, suffixes));
static class RegExAffix implements PeriodFieldAffix {
private final String[] iSuffixes;
private final Pattern[] iPatterns;
RegExAffix(String[] regExes, String[] texts) {
iSuffixes = texts;
iPatterns = new Pattern[regExes.length];
for (int i = 0; i < regExes.length; i++) {
Pattern pattern = PATTERNS.get(regExes[i]);
if (pattern == null) {
pattern = Pattern.compile(regExes[i]);
PATTERNS.putIfAbsent(regExes[i], pattern);
iPatterns[i] = pattern;
private int selectSuffixIndex(int value) {
String valueString = String.valueOf(value);
for (int i = 0; i < iPatterns.length; i++) {
if (iPatterns[i].matcher(valueString).matches()) {
return i;
return iPatterns.length - 1;
public int calculatePrintedLength(int value) {
return iSuffixes[selectSuffixIndex(value)].length();
public void printTo(StringBuffer buf, int value) {
buf.append(iSuffixes[selectSuffixIndex(value)]);
public void printTo(Writer out, int value) throws IOException {
out.write(iSuffixes[selectSuffixIndex(value)]);
public int parse(String periodStr, int position) {
for (String text : iSuffixes) {
if (periodStr.regionMatches(true, position, text, 0, text.length())) {
return position + text.length();
return ~position;
public int scan(String periodStr, final int position) {
int sourceLength = periodStr.length();
for (int pos = position; pos < sourceLength; pos++) {
for (String text : iSuffixes) {
if (periodStr.regionMatches(true, pos, text, 0, text.length())) {
return pos;
return ~position;
private static final Locale PL = new Locale("pl");
public void test_wordBased_pl_formatStandard() {
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 dzie\u0144, 5 godzin, 6 minut, 7 sekund i 8 milisekund", PeriodFormat.wordBased(PL).print(p));
public void test_wordBased_pl_FormatOneField() {
Period p = Period.days(2);
assertEquals("2 dni", PeriodFormat.wordBased(PL).print(p));
public void test_wordBased_pl_formatTwoFields() {
Period p = Period.days(2).withHours(5);
assertEquals("2 dni i 5 godzin", PeriodFormat.wordBased(PL).print(p));
public void test_wordBased_pl_parseOneField() {
Period p = Period.days(2);
assertEquals(p, PeriodFormat.wordBased(PL).parsePeriod("2 dni"));
public void test_wordBased_pl_parseTwoFields() {
Period p = Period.days(2).withHours(5);
assertEquals(p, PeriodFormat.wordBased(PL).parsePeriod("2 dni i 5 godzin"));
public void test_wordBased_pl_checkRedundantSeparator() {
try {
PeriodFormat.wordBased(PL).parsePeriod("2 dni and 5 godzin ");
fail("No exception was caught");
assertEquals(IllegalArgumentException.class, e.getClass());
public void test_wordBased_pl_cached() {
assertSame(PeriodFormat.wordBased(PL), PeriodFormat.wordBased(PL));
public void test_wordBased_pl_regEx() {
PeriodFormatter pf = PeriodFormat.wordBased(PL);
assertEquals("1 rok", pf.print(Period.years(1)));
assertEquals("2 lata", pf.print(Period.years(2)));
assertEquals("5 lat", pf.print(Period.years(5)));
assertEquals("12 lat", pf.print(Period.years(12)));
assertEquals("15 lat", pf.print(Period.years(15)));
assertEquals("1112 lat", pf.print(Period.years(1112)));
assertEquals("1115 lat", pf.print(Period.years(1115)));
assertEquals("2112 lat", pf.print(Period.years(2112)));
assertEquals("2115 lat", pf.print(Period.years(2115)));
assertEquals("2212 lat", pf.print(Period.years(2212)));
assertEquals("2215 lat", pf.print(Period.years(2215)));
assertEquals("22 lata", pf.print(Period.years(22)));
assertEquals("25 lat", pf.print(Period.years(25)));
assertEquals("1122 lata", pf.print(Period.years(1122)));
assertEquals("1125 lat", pf.print(Period.years(1125)));
assertEquals("2122 lata", pf.print(Period.years(2122)));
assertEquals("2125 lat", pf.print(Period.years(2125)));
assertEquals("2222 lata", pf.print(Period.years(2222)));
assertEquals("2225 lat", pf.print(Period.years(2225)));
assertEquals("1 miesi\u0105c", pf.print(Period.months(1)));
assertEquals("2 miesi\u0105ce", pf.print(Period.months(2)));
assertEquals("5 miesi\u0119cy", pf.print(Period.months(5)));
assertEquals("12 miesi\u0119cy", pf.print(Period.months(12)));
assertEquals("15 miesi\u0119cy", pf.print(Period.months(15)));
assertEquals("1112 miesi\u0119cy", pf.print(Period.months(1112)));
assertEquals("1115 miesi\u0119cy", pf.print(Period.months(1115)));
assertEquals("2112 miesi\u0119cy", pf.print(Period.months(2112)));
assertEquals("2115 miesi\u0119cy", pf.print(Period.months(2115)));
assertEquals("2212 miesi\u0119cy", pf.print(Period.months(2212)));
assertEquals("2215 miesi\u0119cy", pf.print(Period.months(2215)));
assertEquals("22 miesi\u0105ce", pf.print(Period.months(22)));
assertEquals("25 miesi\u0119cy", pf.print(Period.months(25)));
assertEquals("1122 miesi\u0105ce", pf.print(Period.months(1122)));
assertEquals("1125 miesi\u0119cy", pf.print(Period.months(1125)));
assertEquals("2122 miesi\u0105ce", pf.print(Period.months(2122)));
assertEquals("2125 miesi\u0119cy", pf.print(Period.months(2125)));
assertEquals("2222 miesi\u0105ce", pf.print(Period.months(2222)));
assertEquals("2225 miesi\u0119cy", pf.print(Period.months(2225)));
assertEquals("1 tydzie\u0144", pf.print(Period.weeks(1)));
assertEquals("2 tygodnie", pf.print(Period.weeks(2)));
assertEquals("5 tygodni", pf.print(Period.weeks(5)));
assertEquals("12 tygodni", pf.print(Period.weeks(12)));
assertEquals("15 tygodni", pf.print(Period.weeks(15)));
assertEquals("1112 tygodni", pf.print(Period.weeks(1112)));
assertEquals("1115 tygodni", pf.print(Period.weeks(1115)));
assertEquals("2112 tygodni", pf.print(Period.weeks(2112)));
assertEquals("2115 tygodni", pf.print(Period.weeks(2115)));
assertEquals("2212 tygodni", pf.print(Period.weeks(2212)));
assertEquals("2215 tygodni", pf.print(Period.weeks(2215)));
assertEquals("22 tygodnie", pf.print(Period.weeks(22)));
assertEquals("25 tygodni", pf.print(Period.weeks(25)));
assertEquals("1122 tygodnie", pf.print(Period.weeks(1122)));
assertEquals("1125 tygodni", pf.print(Period.weeks(1125)));
assertEquals("2122 tygodnie", pf.print(Period.weeks(2122)));
assertEquals("2125 tygodni", pf.print(Period.weeks(2125)));
assertEquals("2222 tygodnie", pf.print(Period.weeks(2222)));
assertEquals("2225 tygodni", pf.print(Period.weeks(2225)));
assertEquals("1 dzie\u0144", pf.print(Period.days(1)));
assertEquals("2 dni", pf.print(Period.days(2)));
assertEquals("5 dni", pf.print(Period.days(5)));
assertEquals("12 dni", pf.print(Period.days(12)));
assertEquals("15 dni", pf.print(Period.days(15)));
assertEquals("22 dni", pf.print(Period.days(22)));
assertEquals("25 dni", pf.print(Period.days(25)));
assertEquals("1 godzina", pf.print(Period.hours(1)));
assertEquals("2 godziny", pf.print(Period.hours(2)));
assertEquals("5 godzin", pf.print(Period.hours(5)));
assertEquals("12 godzin", pf.print(Period.hours(12)));
assertEquals("15 godzin", pf.print(Period.hours(15)));
assertEquals("1112 godzin", pf.print(Period.hours(1112)));
assertEquals("1115 godzin", pf.print(Period.hours(1115)));
assertEquals("2112 godzin", pf.print(Period.hours(2112)));
assertEquals("2115 godzin", pf.print(Period.hours(2115)));
assertEquals("2212 godzin", pf.print(Period.hours(2212)));
assertEquals("2215 godzin", pf.print(Period.hours(2215)));
assertEquals("22 godziny", pf.print(Period.hours(22)));
assertEquals("25 godzin", pf.print(Period.hours(25)));
assertEquals("1122 godziny", pf.print(Period.hours(1122)));
assertEquals("1125 godzin", pf.print(Period.hours(1125)));
assertEquals("2122 godziny", pf.print(Period.hours(2122)));
assertEquals("2125 godzin", pf.print(Period.hours(2125)));
assertEquals("2222 godziny", pf.print(Period.hours(2222)));
assertEquals("2225 godzin", pf.print(Period.hours(2225)));
assertEquals("1 minuta", pf.print(Period.minutes(1)));
assertEquals("2 minuty", pf.print(Period.minutes(2)));
assertEquals("5 minut", pf.print(Period.minutes(5)));
assertEquals("12 minut", pf.print(Period.minutes(12)));
assertEquals("15 minut", pf.print(Period.minutes(15)));
assertEquals("1112 minut", pf.print(Period.minutes(1112)));
assertEquals("1115 minut", pf.print(Period.minutes(1115)));
assertEquals("2112 minut", pf.print(Period.minutes(2112)));
assertEquals("2115 minut", pf.print(Period.minutes(2115)));
assertEquals("2212 minut", pf.print(Period.minutes(2212)));
assertEquals("2215 minut", pf.print(Period.minutes(2215)));
assertEquals("22 minuty", pf.print(Period.minutes(22)));
assertEquals("25 minut", pf.print(Period.minutes(25)));
assertEquals("1122 minuty", pf.print(Period.minutes(1122)));
assertEquals("1125 minut", pf.print(Period.minutes(1125)));
assertEquals("2122 minuty", pf.print(Period.minutes(2122)));
assertEquals("2125 minut", pf.print(Period.minutes(2125)));
assertEquals("2222 minuty", pf.print(Period.minutes(2222)));
assertEquals("2225 minut", pf.print(Period.minutes(2225)));
assertEquals("1 sekunda", pf.print(Period.seconds(1)));
assertEquals("2 sekundy", pf.print(Period.seconds(2)));
assertEquals("5 sekund", pf.print(Period.seconds(5)));
assertEquals("12 sekund", pf.print(Period.seconds(12)));
assertEquals("15 sekund", pf.print(Period.seconds(15)));
assertEquals("1112 sekund", pf.print(Period.seconds(1112)));
assertEquals("1115 sekund", pf.print(Period.seconds(1115)));
assertEquals("2112 sekund", pf.print(Period.seconds(2112)));
assertEquals("2115 sekund", pf.print(Period.seconds(2115)));
assertEquals("2212 sekund", pf.print(Period.seconds(2212)));
assertEquals("2215 sekund", pf.print(Period.seconds(2215)));
assertEquals("22 sekundy", pf.print(Period.seconds(22)));
assertEquals("25 sekund", pf.print(Period.seconds(25)));
assertEquals("1122 sekundy", pf.print(Period.seconds(1122)));
assertEquals("1125 sekund", pf.print(Period.seconds(1125)));
assertEquals("2122 sekundy", pf.print(Period.seconds(2122)));
assertEquals("2125 sekund", pf.print(Period.seconds(2125)));
assertEquals("2222 sekundy", pf.print(Period.seconds(2222)));
assertEquals("2225 sekund", pf.print(Period.seconds(2225)));
assertEquals("1 milisekunda", pf.print(Period.millis(1)));
assertEquals("2 milisekundy", pf.print(Period.millis(2)));
assertEquals("5 milisekund", pf.print(Period.millis(5)));
assertEquals("12 milisekund", pf.print(Period.millis(12)));
assertEquals("15 milisekund", pf.print(Period.millis(15)));
assertEquals("1112 milisekund", pf.print(Period.millis(1112)));
assertEquals("1115 milisekund", pf.print(Period.millis(1115)));
assertEquals("2112 milisekund", pf.print(Period.millis(2112)));
assertEquals("2115 milisekund", pf.print(Period.millis(2115)));
assertEquals("2212 milisekund", pf.print(Period.millis(2212)));
assertEquals("2215 milisekund", pf.print(Period.millis(2215)));
assertEquals("22 milisekundy", pf.print(Period.millis(22)));
assertEquals("25 milisekund", pf.print(Period.millis(25)));
assertEquals("1122 milisekundy", pf.print(Period.millis(1122)));
assertEquals("1125 milisekund", pf.print(Period.millis(1125)));
assertEquals("2122 milisekundy", pf.print(Period.millis(2122)));
assertEquals("2125 milisekund", pf.print(Period.millis(2125)));
assertEquals("2222 milisekundy", pf.print(Period.millis(2222)));
assertEquals("2225 milisekund", pf.print(Period.millis(2225)));
public void test_wordBased_fr_from_de() {
Locale.setDefault(DE);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat
.wordBased(FR).print(p));
public void test_wordBased_fr_from_nl() {
Locale.setDefault(NL);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat
.wordBased(FR).print(p));
public void test_wordBased_en_from_de() {
Locale.setDefault(DE);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
public void test_wordBased_en_from_nl() {
Locale.setDefault(NL);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
public void test_wordBased_en_from_pl() {
Locale.setDefault(PL);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat
.wordBased(EN).print(p));
public void test_wordBased_fr_from_en() {
Locale.setDefault(FR);
Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);
assertEquals("1 dzie\u0144, 5 godzin, 6 minut, 7 sekund i 8 milisekund", PeriodFormat
.wordBased(PL).print(p));
public void testFormatPrefixRegEx1() {
PeriodFormatter f = builder.appendPrefix(new String[] { "^1$", "^.*$" }, new String[] { "Year:", "Years:" }).appendYears()
.toFormatter();
assertEquals("Year:1", f.print(PERIOD));
assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));
Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);
assertEquals("Years:0", f.print(p));
assertEquals(7, f.getPrinter().calculatePrintedLength(p, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));
public void testFormatPrefixRegEx2() {
PeriodFormatter f = builder.appendPrefix(new String[] { "^1$", "^.*$" }, new String[] { "Hour:", "Hours:" }).appendHours()
.toFormatter();
assertEquals("Hours:5", f.print(PERIOD));
assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));
Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);
assertEquals("Hours:0", f.print(p));
assertEquals(7, f.getPrinter().calculatePrintedLength(p, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));
public void testFormatPrefixRegEx3() {
try {
builder.appendPrefix(null, new String[0]);
fail();
try {
builder.appendPrefix(new String[0], null);
fail();
try {
builder.appendPrefix(NULL_STRING_ARRAY, null);
fail();
try {
builder.appendPrefix(new String[0], new String[0]);
fail();
try {
builder.appendPrefix(new String[1], new String[2]);
fail();
public void testFormatSuffixRegEx1() {
PeriodFormatter f = builder.appendYears().appendSuffix(new String[] { "^1$", "^2$" }, new String[] { " year", " years" })
.toFormatter();
assertEquals("1 year", f.print(PERIOD));
assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));
Period p2 = new Period(2, 0, 0, 0, 0, 0, 0, 0);
assertEquals("2 years", f.print(p2));
assertEquals(7, f.getPrinter().calculatePrintedLength(p2, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p2, Integer.MAX_VALUE, null));
Period p0 = new Period(0, 0, 0, 0, 0, 0, 0, 0);
assertEquals("0 years", f.print(p0));
assertEquals(7, f.getPrinter().calculatePrintedLength(p0, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p0, Integer.MAX_VALUE, null));
public void testFormatSuffixRegEx2() {
PeriodFormatter f = builder.appendHours().appendSuffix(new String[] { "^1$", "^2$" }, new String[] { " hour", " hours" }).toFormatter();
assertEquals("5 hours", f.print(PERIOD));
assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));
Period p2 = new Period(0, 0, 0, 0, 2, 0, 0, 0);
assertEquals("2 hours", f.print(p2));
assertEquals(7, f.getPrinter().calculatePrintedLength(p2, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p2, Integer.MAX_VALUE, null));
Period p0 = new Period(0, 0, 0, 0, 0, 0, 0, 0);
assertEquals("0 hours", f.print(p0));
assertEquals(7, f.getPrinter().calculatePrintedLength(p0, null));
assertEquals(1, f.getPrinter().countFieldsToPrint(p0, Integer.MAX_VALUE, null));
public void testFormatSuffixRegEx3() {
try {
builder.appendSuffix(null, new String[0]);
fail();
try {
builder.appendSuffix(new String[0], null);
fail();
try {
builder.appendSuffix(NULL_STRING_ARRAY, null);
fail();
try {
builder.appendSuffix(new String[0], new String[0]);
fail();
try {
builder.appendSuffix(new String[1], new String[2]);
fail();
public void testFormatSuffixRegEx4() {
try {
builder.appendSuffix(new String[] { "^1$", "^.*$" }, new String[] { " hour", " hours" });
fail();localInstant -= offset;
if (offset != zone.getOffset(localInstant)) {
return localInstant;
doTest_getOffsetFromLocal_Turk(-1, 23, 0, "2007-03-31T23:00:00.000-05:00");
doTest_getOffsetFromLocal_Turk(-1, 23, 30, "2007-03-31T23:30:00.000-05:00");
doTest_getOffsetFromLocal_Turk(0, 0, 0, "2007-04-01T01:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 0, 30, "2007-04-01T01:30:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 1, 0, "2007-04-01T01:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 1, 30, "2007-04-01T01:30:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 2, 0, "2007-04-01T02:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 3, 0, "2007-04-01T03:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 4, 0, "2007-04-01T04:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 5, 0, "2007-04-01T05:00:00.000-04:00");
doTest_getOffsetFromLocal_Turk(0, 6, 0, "2007-04-01T06:00:00.000-04:00");
private void doTest_getOffsetFromLocal_Turk(int days, int hour, int min, String expected) {
doTest_getOffsetFromLocal(3, 11, 1, 0, "2007-03-11T01:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 1,30, "2007-03-11T01:30:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 2, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 2,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 3, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 3,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 4, 0, "2007-03-11T04:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 5, 0, "2007-03-11T05:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 6, 0, "2007-03-11T06:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 7, 0, "2007-03-11T07:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 11, 8, 0, "2007-03-11T08:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 0, 0, "2007-11-04T00:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 0,30, "2007-11-04T00:30:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 1, 0, "2007-11-04T01:00:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 1,30, "2007-11-04T01:30:00.000-04:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 2, 0, "2007-11-04T02:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 2,30, "2007-11-04T02:30:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 3, 0, "2007-11-04T03:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 3,30, "2007-11-04T03:30:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 4, 0, "2007-11-04T04:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 5, 0, "2007-11-04T05:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 6, 0, "2007-11-04T06:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 7, 0, "2007-11-04T07:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(11, 4, 8, 0, "2007-11-04T08:00:00.000-05:00", ZONE_NEW_YORK);
doTest_getOffsetFromLocal(3, 25, 1, 0, "2007-03-25T01:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 1,30, "2007-03-25T01:30:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 2, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 2,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 3, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 3,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 4, 0, "2007-03-25T04:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 5, 0, "2007-03-25T05:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 6, 0, "2007-03-25T06:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 7, 0, "2007-03-25T07:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(3, 25, 8, 0, "2007-03-25T08:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 0, 0, "2007-10-28T00:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 0,30, "2007-10-28T00:30:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 1, 0, "2007-10-28T01:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 1,30, "2007-10-28T01:30:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2, 0, "2007-10-28T02:00:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2,30, "2007-10-28T02:30:00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2,30,59,999, "2007-10-28T02:30:59.999+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2,59,59,998, "2007-10-28T02:59:59.998+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2,59,59,999, "2007-10-28T02:59:59.999+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 3, 0, "2007-10-28T03:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 3,30, "2007-10-28T03:30:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 4, 0, "2007-10-28T04:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 5, 0, "2007-10-28T05:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 6, 0, "2007-10-28T06:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 7, 0, "2007-10-28T07:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 8, 0, "2007-10-28T08:00:00.000+03:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:0" + min + ":00.000+04:00", ZONE_MOSCOW);
doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:" + min + ":00.000+04:00", ZONE_MOSCOW);
"2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA);
"2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA);
"2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA);
"2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA);
"2006-10-01T00:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T00:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T01:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T01:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T02:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T02:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T03:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T03:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T04:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T04:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T05:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T05:30:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T06:00:00.000-06:00", ZONE_GUATEMALA);
"2006-10-01T06:30:00.000-06:00", ZONE_GUATEMALA);
private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {
doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);
private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {
doTest_getOffsetFromLocal(2007, month, day, hour, min, sec, milli, expected, zone);
private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, String expected, DateTimeZone zone) {
doTest_getOffsetFromLocal(year, month, day, hour, min, 0, 0, expected, zone);
private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {startInstant = field.add(startInstant, value);implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
DateTimeParser p = getFormatter(bucket.getLocale()).getParser();
private final DateTimeParser iParser;
this(DateTimePrinterInternalPrinter.of(printer), parser);
InternalPrinter printer, DateTimeParser parser) {
InternalPrinter printer, DateTimeParser parser,
DateTimeParser parser = requireParser();
DateTimeParser parser = requireParser();
DateTimeParser parser = requireParser();
DateTimeParser parser = requireParser();
DateTimeParser parser = requireParser();
private DateTimeParser requireParser() {
DateTimeParser parser = iParser;
DateTimeParser parser = null;
parser = (DateTimeParser) f;
return (DateTimeParser) f;
return append0(formatter.getPrinter0(), formatter.getParser());
return append0(null, parser);
return append0(DateTimePrinterInternalPrinter.of(printer), parser);
return append0(DateTimePrinterInternalPrinter.of(printer), parsers[0]);
DateTimeParser[] copyOfParsers = new DateTimeParser[length];
if ((copyOfParsers[i] = parsers[i]) == null) {
copyOfParsers[i] = parsers[i];
DateTimeParser[] parsers = new DateTimeParser[] {parser, null};
InternalPrinter printer, DateTimeParser parser) {
if (f instanceof DateTimeParser) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
if (text.regionMatches(true, position, iValue, 0, iValue.length())) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
value = Integer.parseInt(text.substring(position, position += length));
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
value = Integer.parseInt(text.substring(position, position += length));
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
String match = text.substring(position, i);
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {
private int digitCount(String text, int position, int amount) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
String str = text.substring(position);
if (str.startsWith(name)) {
implements InternalPrinter, DateTimeParser {
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
String str = text.substring(position);
if (str.startsWith(id)) {
implements InternalPrinter, DateTimeParser {
private final DateTimeParser[] iParsers;
iParsers = new DateTimeParser[size];
DateTimeParser parser = (DateTimeParser) parserList.get(i);
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
DateTimeParser[] elements = iParsers;
implements DateTimeParser {
private final DateTimeParser[] iParsers;
MatchingParser(DateTimeParser[] parsers) {
DateTimeParser parser = parsers[i];
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
DateTimeParser[] parsers = iParsers;
DateTimeParser parser = parsers[i];
return doParseMillis(parser, text);
long doParseMillis(DateTimeParser parser, CharSequence text) {
int newPos = parser.parseInto(this, text.toString(), 0);
static int parseTwoDigits(String text, int position) {
f2 = new DateTimeFormatter((InternalPrinter) null, f.getParser());if (types[i - 1].getRangeDurationType() == null) {
if (loopType.getRangeDurationType() == null) {
throw new IllegalArgumentException("Types array must not contain duplicate: " +
types[i - 1].getName() + " and " + loopType.getName());
if (loopType.getRangeDurationType() == null) {
throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
types[i - 1].getName() + " < " + loopType.getName());
DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
if (lastRangeField.compareTo(loopRangeField) < 0) {
throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
types[i - 1].getName() + " < " + loopType.getName());
if (lastRangeField.compareTo(loopRangeField) == 0) {
throw new IllegalArgumentException("Types array must not contain duplicate: " +
types[i - 1].getName() + " and " + loopType.getName());
public void testConstructorEx7_TypeArray_intArray() throws Throwable {
public void testConstructorEx8_TypeArray_intArray() throws Throwable {import org.joda.convert.ToString;
public String toString() {
return ISODateTimeFormat.dateTime().print(this);import java.lang.ref.WeakReference;
import java.util.WeakHashMap;
private static final int FAST_CACHE_SIZE = 64;
private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
private static WeakHashMap<Locale, GJLocaleSymbols> cCache = new WeakHashMap<Locale, GJLocaleSymbols>();
public static GJLocaleSymbols forLocale(Locale locale) {
int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
GJLocaleSymbols symbols = cFastCache[index];
if (symbols != null && symbols.iLocale.get() == locale) {
return symbols;
synchronized (cCache) {
symbols = cCache.get(locale);
if (symbols == null) {
symbols = new GJLocaleSymbols(locale);
cCache.put(locale, symbols);
cFastCache[index] = symbols;
private final WeakReference<Locale> iLocale;
iLocale = new WeakReference<Locale>(locale);convId = zone.getID();private static final DateTimeFormatter[] STYLE_CACHE = new DateTimeFormatter[25];
int index = ((dateStyle << 2) + dateStyle) + timeStyle;
if (index >= STYLE_CACHE.length) {
DateTimeFormatter f = STYLE_CACHE[index];
synchronized (STYLE_CACHE) {
f = STYLE_CACHE[index];
if (f == null) {
f = createDateTimeFormatter(dateStyle, timeStyle);
STYLE_CACHE[index] = f;import java.io.Writer;
return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(out, instant, chrono, displayOffset, displayZone, locale);
DateTimePrinter p = getFormatter(locale).getPrinter();
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(out, partial, locale);
DateTimePrinter p = getFormatter(locale).getPrinter();
private final DateTimePrinter iPrinter;
DateTimePrinter printer, DateTimeParser parser,
long millis = DateTimeUtils.getInstantMillis(instant);
Chronology chrono = DateTimeUtils.getInstantChronology(instant);
printTo(buf, millis, chrono);
long millis = DateTimeUtils.getInstantMillis(instant);
Chronology chrono = DateTimeUtils.getInstantChronology(instant);
printTo(out, millis, chrono);
printTo(buf, instant, null);
printTo(out, instant, null);
DateTimePrinter printer = requirePrinter();
if (partial == null) {
throw new IllegalArgumentException("The partial must not be null");
printer.printTo(buf, partial, iLocale);
DateTimePrinter printer = requirePrinter();
if (partial == null) {
throw new IllegalArgumentException("The partial must not be null");
printer.printTo(out, partial, iLocale);
DateTimePrinter printer = requirePrinter();
printTo(buf, instant);
printTo(buf, instant);
StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength());
printTo(builder, partial);
return builder.toString();
private void printTo(StringBuffer buf, long instant, Chronology chrono) {
try {
printTo((Appendable)buf, instant, chrono);
private void printTo(Writer out, long instant, Chronology chrono) throws IOException {
DateTimePrinter printer = requirePrinter();
chrono = selectChronology(chrono);
DateTimeZone zone = chrono.getZone();
int offset = zone.getOffset(instant);
long adjustedInstant = instant + offset;
if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {
zone = DateTimeZone.UTC;
offset = 0;
adjustedInstant = instant;
printer.printTo(out, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
DateTimePrinter printer = requirePrinter();
private DateTimePrinter requirePrinter() {
DateTimePrinter printer = iPrinter;
import java.io.Writer;
DateTimePrinter printer = null;
printer = (DateTimePrinter) f;
return (DateTimePrinter) f;
return append0(formatter.getPrinter(), formatter.getParser());
return append0(printer, null);
return append0(printer, parser);
return append0(printer, parsers[0]);
return append0(printer, new MatchingParser(copyOfParsers));
DateTimePrinter printer, DateTimeParser parser) {
if (f instanceof DateTimePrinter) {
static void appendUnknownString(StringBuffer buf, int len) {
for (int i = len; --i >= 0;) {
buf.append('\ufffd');
static void printUnknownString(Writer out, int len) throws IOException {
for (int i = len; --i >= 0;) {
out.write('\ufffd');
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
buf.append(iValue);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
out.write(iValue);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
buf.append(iValue);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
out.write(iValue);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
buf.append(iValue);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
out.write(iValue);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
buf.append(iValue);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
out.write(iValue);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
try {
printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
DateTimeField field = iFieldType.getField(chrono);
FormatUtils.writeUnpaddedInteger(out, field.get(instant));
out.write('\ufffd');
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
try {
printTo((Appendable)buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
if (partial.isSupported(iFieldType)) {
try {
FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
out.write('\ufffd');
out.write('\ufffd');
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
try {
printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
DateTimeField field = iFieldType.getField(chrono);
FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);
printUnknownString(out, iMinPrintedDigits);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
try {
printTo((Appendable)buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
if (partial.isSupported(iFieldType)) {
try {
FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
printUnknownString(out, iMinPrintedDigits);
printUnknownString(out, iMinPrintedDigits);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
int year = getTwoDigitYear(instant, chrono);
if (year < 0) {
buf.append('\ufffd');
buf.append('\ufffd');
FormatUtils.appendPaddedInteger(buf, year, 2);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
int year = getTwoDigitYear(instant, chrono);
if (year < 0) {
out.write('\ufffd');
out.write('\ufffd');
FormatUtils.writePaddedInteger(out, year, 2);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
int year = getTwoDigitYear(partial);
if (year < 0) {
buf.append('\ufffd');
buf.append('\ufffd');
FormatUtils.appendPaddedInteger(buf, year, 2);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
int year = getTwoDigitYear(partial);
if (year < 0) {
out.write('\ufffd');
out.write('\ufffd');
FormatUtils.writePaddedInteger(out, year, 2);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
try {
buf.append(print(instant, chrono, locale));
buf.append('\ufffd');
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
out.write(print(instant, chrono, locale));
out.write('\ufffd');
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
try {
buf.append(print(partial, locale));
buf.append('\ufffd');
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
try {
out.write(print(partial, locale));
out.write('\ufffd');
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
try {
printTo(buf, null, instant, chrono);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
printTo(null, out, instant, chrono);
printTo(appendable, null, instant, chrono);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
long millis = partial.getChronology().set(partial, 0L);
try {
printTo(buf, null, millis, partial.getChronology());
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
long millis = partial.getChronology().set(partial, 0L);
printTo(null, out, millis, partial.getChronology());
printTo(appendable, null , millis, partial.getChronology());
protected void printTo(Appendable appendable, Writer out, long instant, Chronology chrono)
if (appendable != null) {
appendUnknownString(appendable, minDigits);
printUnknownString(out, minDigits);
if (appendable != null) {
while (--minDigits >= 0) {
appendable.append('0');
while (--minDigits >= 0) {
out.write('0');
if (appendable != null) {
appendable.append('0');
out.write('0');
if (appendable != null) {
for (int i=0; i<length; i++) {
appendable.append(str.charAt(i));
for (int i=0; i<length; i++) {
out.write(str.charAt(i));
if (appendable != null) {
appendable.append(str);
out.write(str);
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
try {
printTo((Appendable) buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
if (displayZone == null) {
return;  // no zone
if (displayOffset == 0 && iZeroOffsetPrintText != null) {
out.write(iZeroOffsetPrintText);
return;
if (displayOffset >= 0) {
out.write('+');
out.write('-');
displayOffset = -displayOffset;
int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
FormatUtils.writePaddedInteger(out, hours, 2);
if (iMaxFields == 1) {
return;
displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
if (displayOffset == 0 && iMinFields == 1) {
return;
int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;
if (iShowSeparators) {
out.write(':');
FormatUtils.writePaddedInteger(out, minutes, 2);
if (iMaxFields == 2) {
return;
displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
if (displayOffset == 0 && iMinFields == 2) {
return;
int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;
if (iShowSeparators) {
out.write(':');
FormatUtils.writePaddedInteger(out, seconds, 2);
if (iMaxFields == 3) {
return;
displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
if (displayOffset == 0 && iMinFields == 3) {
return;
if (iShowSeparators) {
out.write('.');
FormatUtils.writePaddedInteger(out, displayOffset, 3);
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
buf.append(print(instant - displayOffset, displayZone, locale));
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
out.write(print(instant - displayOffset, displayZone, locale));
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
implements DateTimePrinter, DateTimeParser {
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
buf.append(displayZone != null ? displayZone.getID() : "");
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
out.write(displayZone != null ? displayZone.getID() : "");
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
implements DateTimePrinter, DateTimeParser {
private final DateTimePrinter[] iPrinters;
iPrinters = new DateTimePrinter[size];
DateTimePrinter printer = (DateTimePrinter) printerList.get(i);
public void printTo(
StringBuffer buf, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i = 0; i < len; i++) {
elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i = 0; i < len; i++) {
elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);
DateTimePrinter[] elements = iPrinters;
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i=0; i<len; i++) {
elements[i].printTo(buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i=0; i<len; i++) {
elements[i].printTo(out, partial, locale);
DateTimePrinter[] elements = iPrinters;
void printTo(Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
f2 = new DateTimeFormatter(null, f.getParser());public void printTo(
Appendable appenadble, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(appenadble, instant, chrono, displayOffset, displayZone, locale);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
DateTimePrinter p = getFormatter(locale).getPrinter();
p.printTo(appendable, partial, locale);
long millis = DateTimeUtils.getInstantMillis(instant);
Chronology chrono = DateTimeUtils.getInstantChronology(instant);
printTo(appendable, millis, chrono);
printTo(appendable, instant, null);
DateTimePrinter printer = requirePrinter();
if (partial == null) {
throw new IllegalArgumentException("The partial must not be null");
printer.printTo(appendable, partial, iLocale);
StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
try {
printTo(buf, instant);
StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
try {
printTo(buf, instant);
StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength());
try {
printTo(builder, partial);
return builder.toString();
try {
printTo((Appendable)buf, instant, chrono);
private void printTo(Writer out, long instant, Chronology chrono) throws IOException {
printer.printTo(out, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
private void printTo(Appendable appendable, long instant, Chronology chrono) throws IOException {
printer.printTo(appendable, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
static void appendUnknownString(Appendable appendable, int len) throws IOException {
for (int i = len; --i >= 0;) {
appendable.append('\ufffd');
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
appendable.append(iValue);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
appendable.append(iValue);
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
appendable.append(iValue);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
appendable.append(iValue);
printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
DateTimeField field = iFieldType.getField(chrono);
FormatUtils.appendUnpaddedInteger(appendable, field.get(instant));
appendable.append('\ufffd');
try {
printTo((Appendable)buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
out.write('\ufffd');
out.write('\ufffd');
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
FormatUtils.appendUnpaddedInteger(appendable, partial.get(iFieldType));
appendable.append('\ufffd');
appendable.append('\ufffd');
printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
DateTimeField field = iFieldType.getField(chrono);
FormatUtils.appendPaddedInteger(appendable, field.get(instant), iMinPrintedDigits);
appendUnknownString(appendable, iMinPrintedDigits);
try {
printTo((Appendable)buf, partial, locale);
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
printUnknownString(out, iMinPrintedDigits);
printUnknownString(out, iMinPrintedDigits);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
FormatUtils.appendPaddedInteger(appendable, partial.get(iFieldType), iMinPrintedDigits);
appendUnknownString(appendable, iMinPrintedDigits);
appendUnknownString(appendable, iMinPrintedDigits);
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
int year = getTwoDigitYear(instant, chrono);
if (year < 0) {
appendable.append('\ufffd');
appendable.append('\ufffd');
FormatUtils.appendPaddedInteger(appendable, year, 2);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
int year = getTwoDigitYear(partial);
if (year < 0) {
appendable.append('\ufffd');
appendable.append('\ufffd');
FormatUtils.appendPaddedInteger(appendable, year, 2);
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
try {
appendable.append(print(instant, chrono, locale));
appendable.append('\ufffd');
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
try {
appendable.append(print(partial, locale));
appendable.append('\ufffd');
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
printTo(appendable, null, instant, chrono);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
long millis = partial.getChronology().set(partial, 0L);
printTo(appendable, null , millis, partial.getChronology());
protected void printTo(Appendable appendable, Writer out, long instant, Chronology chrono)
if (appendable != null) {
appendUnknownString(appendable, minDigits);
if (appendable != null) {
appendable.append('0');
if (appendable != null) {
appendable.append('0');
if (appendable != null) {
appendable.append(str.charAt(i));
if (appendable != null) {
appendable.append(str);
try {
printTo((Appendable) buf, instant, chrono, displayOffset, displayZone, locale);
public void printTo(
Writer out, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
out.write(iZeroOffsetPrintText);
out.write('+');
out.write('-');
FormatUtils.writePaddedInteger(out, hours, 2);
if (displayOffset == 0 && iMinFields == 1) {
out.write(':');
FormatUtils.writePaddedInteger(out, minutes, 2);
if (displayOffset == 0 && iMinFields == 2) {
out.write(':');
FormatUtils.writePaddedInteger(out, seconds, 2);
if (displayOffset == 0 && iMinFields == 3) {
out.write('.');
FormatUtils.writePaddedInteger(out, displayOffset, 3);
Appendable buf, long instant, Chronology chrono,
buf.append(iZeroOffsetPrintText);
buf.append('+');
buf.append('-');
FormatUtils.appendPaddedInteger(buf, hours, 2);
buf.append(':');
FormatUtils.appendPaddedInteger(buf, minutes, 2);
buf.append(':');
FormatUtils.appendPaddedInteger(buf, seconds, 2);
buf.append('.');
FormatUtils.appendPaddedInteger(buf, displayOffset, 3);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
appendable.append(print(instant - displayOffset, displayZone, locale));
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
appendable.append(displayZone != null ? displayZone.getID() : "");
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
public void printTo(
Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i = 0; i < len; i++) {
elements[i].printTo(appendable, instant, chrono, displayOffset, displayZone, locale);
public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
DateTimePrinter[] elements = iPrinters;
if (elements == null) {
throw new UnsupportedOperationException();
if (locale == null) {
locale = Locale.getDefault();
int len = elements.length;
for (int i=0; i<len; i++) {
elements[i].printTo(appendable, partial, locale);
void printTo(Appendable appendable, long instant, Chronology chrono,
int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
try {
appendPaddedInteger((Appendable)buf, value, size);
public static void appendPaddedInteger(Appendable appenadble, int value, int size) throws IOException {
appenadble.append('-');
appenadble.append('0');
appenadble.append("" + -(long)Integer.MIN_VALUE);
appenadble.append('0');
appenadble.append((char)(value + '0'));
appenadble.append('0');
appenadble.append((char) (d + '0'));
appenadble.append((char) (value - (d << 3) - (d << 1) + '0'));
appenadble.append('0');
appenadble.append(Integer.toString(value));
try {
appendPaddedInteger((Appendable)buf, value, size);
public static void appendPaddedInteger(Appendable appendable, long value, int size) throws IOException {
appendPaddedInteger(appendable, intValue, size);
appendable.append(Long.toString(value));
appendable.append('-');
appendable.append('0');
appendable.append("9223372036854775808");
appendable.append('0');
appendable.append(Long.toString(value));
try {
appendUnpaddedInteger((Appendable) buf, value);
public static void appendUnpaddedInteger(Appendable appendable, int value) throws IOException {
appendable.append('-');
appendable.append("" + -(long)Integer.MIN_VALUE);
appendable.append((char)(value + '0'));
appendable.append((char) (d + '0'));
appendable.append((char) (value - (d << 3) - (d << 1) + '0'));
appendable.append(Integer.toString(value));
try {
appendUnpaddedInteger((Appendable) buf, value);
public static void appendUnpaddedInteger(Appendable appendable, long value) throws IOException {
appendUnpaddedInteger(appendable, intValue);
appendable.append(Long.toString(value));import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import org.joda.time.MutableDateTime.Property;
Set<String> validValues = null;
validValues = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(32));
validValues.add(property.getAsShortText(locale));
validValues.add(property.getAsShortText(locale).toLowerCase(locale));
validValues.add(property.getAsShortText(locale).toUpperCase(locale));
validValues.add(property.getAsText(locale));
validValues.add(property.getAsText(locale).toLowerCase(locale));
validValues.add(property.getAsText(locale).toUpperCase(locale));
validValues.add("BCE");
validValues.add("bce");
validValues.add("CE");
validValues.add("ce");
validValues = (Set<String>) array[0];
if (validValues.contains(match)) {import org.joda.time.DateTime.Property;return loadZoneData(id);import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;
new ConcurrentHashMap<Locale, Map<DateTimeFieldType, Object[]>>();
Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);
if (innerMap == null) {
innerMap = new ConcurrentHashMap<DateTimeFieldType, Object[]>();
cParseCache.put(locale, innerMap);
Object[] array = innerMap.get(iFieldType);
if (array == null) {
validValues = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(32));
MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);
Property property = dt.property(iFieldType);
int min = property.getMinimumValueOverall();
int max = property.getMaximumValueOverall();
if (max - min > 32) {  // protect against invalid fields
return ~position;
maxLength = property.getMaximumTextLength(locale);
for (int i = min; i <= max; i++) {
property.set(i);
validValues.add(property.getAsShortText(locale));
validValues.add(property.getAsShortText(locale).toLowerCase(locale));
validValues.add(property.getAsShortText(locale).toUpperCase(locale));
validValues.add(property.getAsText(locale));
validValues.add(property.getAsText(locale).toLowerCase(locale));
validValues.add(property.getAsText(locale).toUpperCase(locale));
if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {
validValues.add("BCE");
validValues.add("bce");
validValues.add("CE");
validValues.add("ce");
maxLength = 3;
array = new Object[] {validValues, Integer.valueOf(maxLength)};
innerMap.put(iFieldType, array);
validValues = (Set<String>) array[0];
maxLength = ((Integer) array[1]).intValue();if (durationField.isSupported()) {
return 1;if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());
throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());setMillis(type.getField(getChronology()).add(getMillis(), amount));
setMillis(getChronology().years().add(getMillis(), years));
setMillis(getChronology().weekyears().add(getMillis(), weekyears));
setMillis(getChronology().months().add(getMillis(), months));
setMillis(getChronology().weeks().add(getMillis(), weeks));
setMillis(getChronology().days().add(getMillis(), days));
setMillis(getChronology().hours().add(getMillis(), hours));
setMillis(getChronology().minutes().add(getMillis(), minutes));
setMillis(getChronology().seconds().add(getMillis(), seconds));
setMillis(getChronology().millis().add(getMillis(), millis));
private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");Partial newPartial = new Partial(iChronology, newTypes, newValues);if (loopField.getRangeDurationField().getType() != lastType) {fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);
fields.centuries = fields.centuryOfEra.getDurationField();
fields.year, DateTimeFieldType.yearOfEra());
field, DateTimeFieldType.centuryOfEra(), 100);
fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);
long cutover = gregorian.year().roundCeiling(iCutoverMillis);
fields.dayOfYear = new CutoverField(
julian.dayOfYear(), fields.dayOfYear, cutover);
long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
fields.weekOfWeekyear = new CutoverField(
julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);
fields.yearOfCentury = new ImpreciseCutoverField(
julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);
julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);
julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);
fields.weekyears = fields.weekyear.getDurationField();
DurationField rangeField = gregorianField.getRangeDurationField();
rangeField = julianField.getRangeDurationField();
(DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());
fields.centuries = fields.centuryOfEra.getDurationField();
assertEquals(null, test.yearOfEra().getRangeDurationField());
assertEquals(null, test.centuryOfEra().getRangeDurationField());
assertEquals(null, test.yearOfEra().getRangeDurationField());
assertEquals(null, test.centuryOfEra().getRangeDurationField());
assertEquals(null, test.yearOfEra().getRangeDurationField());
assertEquals(null, test.centuryOfEra().getRangeDurationField());Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());
years = FieldUtils.safeAdd(years, months / 12);
months = months % 12;
if (years != 0) {
result = result.withYears(years);
if (months != 0) {
result = result.withMonths(months);private final Info[] iInfoCache = new Info[cInfoCacheMask + 1];public Duration multipliedBy(long multiplicand)
if(multiplicand == 1)
public Duration dividedBy(long divisor)
if(divisor == 1)
public Duration negated()
if(getMillis() == Long.MIN_VALUE)
public static long safeDivide(long dividend, long divisor)
if(dividend == Long.MIN_VALUE && divisor == -1L)private transient volatile int iHash;String providerClass =
System.getProperty("org.joda.time.DateTimeZone.Provider");
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
Thread t = Thread.currentThread();
t.getThreadGroup().uncaughtException(t, ex);
PrintStream syserr = System.err;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
System.setErr(new PrintStream(baos));
String str = new String(baos.toByteArray());
assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);
System.setErr(syserr);
assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());
PrintStream syserr = System.err;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
System.setErr(new PrintStream(baos));
DateTimeZone.setNameProvider(null);
String str = new String(baos.toByteArray());
assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);
System.setErr(syserr);
DateTimeZone.setNameProvider(null);
assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());private static DateTimeFormatter
ye,  // year element (yyyy)
mye, // monthOfYear element (-MM)
dme, // dayOfMonth element (-dd)
we,  // weekyear element (xxxx)
wwe, // weekOfWeekyear element (-ww)
dwe, // dayOfWeek element (-ee)
dye, // dayOfYear element (-DDD)
hde, // hourOfDay element (HH)
mhe, // minuteOfHour element (:mm)
sme, // secondOfMinute element (:ss)
fse, // fractionOfSecond element (.SSSSSSSSS)
ze,  // zone offset element
lte, // literal 'T' element
ym,  // year month
ymd, // year month day
ww,  // weekyear week
wwd, // weekyear week day
hm,   // hour minute
hms,  // hour minute second
hmsl, // hour minute second millis
hmsf, // hour minute second fraction
dh,    // date hour
dhm,   // date hour minute
dhms,  // date hour minute second
dhmsl, // date hour minute second millis
dhmsf, // date hour minute second fraction
t,  // time
tx,  // time no millis
tt,  // Ttime
ttx,  // Ttime no millis
dt, // date time
dtx, // date time no millis
wdt, // week date time
wdtx, // week date time no millis
od,  // ordinal date (same as yd)
odt, // ordinal date time
odtx, // ordinal date time no millis
bd,  // basic date
bt,  // basic time
btx,  // basic time no millis
btt, // basic Ttime
bttx, // basic Ttime no millis
bdt, // basic date time
bdtx, // basic date time no millis
bod,  // basic ordinal date
bodt, // basic ordinal date time
bodtx, // basic ordinal date time no millis
bwd,  // basic week date
bwdt, // basic week date time
bwdtx, // basic week date time no millis
dpe, // date parser element
tpe, // time parser element
dp,  // date parser
ldp, // local date parser
tp,  // time parser
ltp, // local time parser
dtp, // date time parser
dotp, // date optional time parser
ldotp; // local date optional time parser
bld.append(yearElement());
bld.append(weekyearElement());
bld.append(yearElement());
bld.append(yearElement());
bld.append(weekyearElement());
if (dp == null) {
DateTimeParser tOffset = new DateTimeFormatterBuilder()
.appendLiteral('T')
.append(offsetElement()).toParser();
dp = new DateTimeFormatterBuilder()
.append(dateElementParser())
.appendOptional(tOffset)
.toFormatter();
return dp;
if (ldp == null) {
ldp = dateElementParser().withZoneUTC();
return ldp;
if (dpe == null) {
dpe = new DateTimeFormatterBuilder()
.append(null, new DateTimeParser[] {
new DateTimeFormatterBuilder()
.append(yearElement())
.appendOptional
(new DateTimeFormatterBuilder()
.append(monthElement())
.appendOptional(dayOfMonthElement().getParser())
.toParser())
.toParser(),
new DateTimeFormatterBuilder()
.append(weekyearElement())
.append(weekElement())
.appendOptional(dayOfWeekElement().getParser())
.toParser(),
new DateTimeFormatterBuilder()
.append(yearElement())
.append(dayOfYearElement())
.toParser()
.toFormatter();
return dpe;
if (tp == null) {
tp = new DateTimeFormatterBuilder()
.appendOptional(literalTElement().getParser())
.append(timeElementParser())
.appendOptional(offsetElement().getParser())
.toFormatter();
return tp;
if (ltp == null) {
ltp = new DateTimeFormatterBuilder()
.appendOptional(literalTElement().getParser())
.append(timeElementParser())
.toFormatter().withZoneUTC();
return ltp;
if (tpe == null) {
DateTimeParser decimalPoint = new DateTimeFormatterBuilder()
.append(null, new DateTimeParser[] {
new DateTimeFormatterBuilder()
.appendLiteral('.')
.toParser(),
new DateTimeFormatterBuilder()
.appendLiteral(',')
.toParser()
.toParser();
tpe = new DateTimeFormatterBuilder()
.append(hourElement())
.append
(null, new DateTimeParser[] {
new DateTimeFormatterBuilder()
.append(minuteElement())
.append
(null, new DateTimeParser[] {
new DateTimeFormatterBuilder()
.append(secondElement())
.appendOptional(new DateTimeFormatterBuilder()
.append(decimalPoint)
.appendFractionOfSecond(1, 9)
.toParser())
.toParser(),
new DateTimeFormatterBuilder()
.append(decimalPoint)
.appendFractionOfMinute(1, 9)
.toParser(),
null
.toParser(),
new DateTimeFormatterBuilder()
.append(decimalPoint)
.appendFractionOfHour(1, 9)
.toParser(),
null
.toFormatter();
return tpe;
if (dtp == null) {
DateTimeParser time = new DateTimeFormatterBuilder()
.appendLiteral('T')
.append(timeElementParser())
.appendOptional(offsetElement().getParser())
.toParser();
dtp = new DateTimeFormatterBuilder()
.append(null, new DateTimeParser[] {time, dateOptionalTimeParser().getParser()})
.toFormatter();
return dtp;
if (dotp == null) {
DateTimeParser timeOrOffset = new DateTimeFormatterBuilder()
.appendLiteral('T')
.appendOptional(timeElementParser().getParser())
.appendOptional(offsetElement().getParser())
.toParser();
dotp = new DateTimeFormatterBuilder()
.append(dateElementParser())
.appendOptional(timeOrOffset)
.toFormatter();
return dotp;
if (ldotp == null) {
DateTimeParser time = new DateTimeFormatterBuilder()
.appendLiteral('T')
.append(timeElementParser())
.toParser();
ldotp = new DateTimeFormatterBuilder()
.append(dateElementParser())
.appendOptional(time)
.toFormatter().withZoneUTC();
return ldotp;
if (t == null) {
t = new DateTimeFormatterBuilder()
.append(hourMinuteSecondFraction())
.append(offsetElement())
.toFormatter();
return t;
if (tx == null) {
tx = new DateTimeFormatterBuilder()
.append(hourMinuteSecond())
.append(offsetElement())
.toFormatter();
return tx;
if (tt == null) {
tt = new DateTimeFormatterBuilder()
.append(literalTElement())
.append(time())
.toFormatter();
return tt;
if (ttx == null) {
ttx = new DateTimeFormatterBuilder()
.append(literalTElement())
.append(timeNoMillis())
.toFormatter();
return ttx;
if (dt == null) {
dt = new DateTimeFormatterBuilder()
.append(date())
.append(tTime())
.toFormatter();
return dt;
if (dtx == null) {
dtx = new DateTimeFormatterBuilder()
.append(date())
.append(tTimeNoMillis())
.toFormatter();
return dtx;
if (od == null) {
od = new DateTimeFormatterBuilder()
.append(yearElement())
.append(dayOfYearElement())
.toFormatter();
return od;
if (odt == null) {
odt = new DateTimeFormatterBuilder()
.append(ordinalDate())
.append(tTime())
.toFormatter();
return odt;
if (odtx == null) {
odtx = new DateTimeFormatterBuilder()
.append(ordinalDate())
.append(tTimeNoMillis())
.toFormatter();
return odtx;
return weekyearWeekDay();
if (wdt == null) {
wdt = new DateTimeFormatterBuilder()
.append(weekDate())
.append(tTime())
.toFormatter();
return wdt;
if (wdtx == null) {
wdtx = new DateTimeFormatterBuilder()
.append(weekDate())
.append(tTimeNoMillis())
.toFormatter();
return wdtx;
if (bd == null) {
bd = new DateTimeFormatterBuilder()
.appendYear(4, 4)
.appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)
.appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)
.toFormatter();
return bd;
if (bt == null) {
bt = new DateTimeFormatterBuilder()
.appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)
.appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)
.appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)
.appendLiteral('.')
.appendFractionOfSecond(3, 9)
.appendTimeZoneOffset("Z", false, 2, 2)
.toFormatter();
return bt;
if (btx == null) {
btx = new DateTimeFormatterBuilder()
.appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)
.appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)
.appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)
.appendTimeZoneOffset("Z", false, 2, 2)
.toFormatter();
return btx;
if (btt == null) {
btt = new DateTimeFormatterBuilder()
.append(literalTElement())
.append(basicTime())
.toFormatter();
return btt;
if (bttx == null) {
bttx = new DateTimeFormatterBuilder()
.append(literalTElement())
.append(basicTimeNoMillis())
.toFormatter();
return bttx;
if (bdt == null) {
bdt = new DateTimeFormatterBuilder()
.append(basicDate())
.append(basicTTime())
.toFormatter();
return bdt;
if (bdtx == null) {
bdtx = new DateTimeFormatterBuilder()
.append(basicDate())
.append(basicTTimeNoMillis())
.toFormatter();
return bdtx;
if (bod == null) {
bod = new DateTimeFormatterBuilder()
.appendYear(4, 4)
.appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3)
.toFormatter();
return bod;
if (bodt == null) {
bodt = new DateTimeFormatterBuilder()
.append(basicOrdinalDate())
.append(basicTTime())
.toFormatter();
return bodt;
if (bodtx == null) {
bodtx = new DateTimeFormatterBuilder()
.append(basicOrdinalDate())
.append(basicTTimeNoMillis())
.toFormatter();
return bodtx;
if (bwd == null) {
bwd = new DateTimeFormatterBuilder()
.appendWeekyear(4, 4)
.appendLiteral('W')
.appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2)
.appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1)
.toFormatter();
return bwd;
if (bwdt == null) {
bwdt = new DateTimeFormatterBuilder()
.append(basicWeekDate())
.append(basicTTime())
.toFormatter();
return bwdt;
if (bwdtx == null) {
bwdtx = new DateTimeFormatterBuilder()
.append(basicWeekDate())
.append(basicTTimeNoMillis())
.toFormatter();
return bwdtx;
return yearElement();
if (ym == null) {
ym = new DateTimeFormatterBuilder()
.append(yearElement())
.append(monthElement())
.toFormatter();
return ym;
if (ymd == null) {
ymd = new DateTimeFormatterBuilder()
.append(yearElement())
.append(monthElement())
.append(dayOfMonthElement())
.toFormatter();
return ymd;
return weekyearElement();
if (ww == null) {
ww = new DateTimeFormatterBuilder()
.append(weekyearElement())
.append(weekElement())
.toFormatter();
return ww;
if (wwd == null) {
wwd = new DateTimeFormatterBuilder()
.append(weekyearElement())
.append(weekElement())
.append(dayOfWeekElement())
.toFormatter();
return wwd;
return hourElement();
if (hm == null) {
hm = new DateTimeFormatterBuilder()
.append(hourElement())
.append(minuteElement())
.toFormatter();
return hm;
if (hms == null) {
hms = new DateTimeFormatterBuilder()
.append(hourElement())
.append(minuteElement())
.append(secondElement())
.toFormatter();
return hms;
if (hmsl == null) {
hmsl = new DateTimeFormatterBuilder()
.append(hourElement())
.append(minuteElement())
.append(secondElement())
.appendLiteral('.')
.appendFractionOfSecond(3, 3)
.toFormatter();
return hmsl;
if (hmsf == null) {
hmsf = new DateTimeFormatterBuilder()
.append(hourElement())
.append(minuteElement())
.append(secondElement())
.append(fractionElement())
.toFormatter();
return hmsf;
if (dh == null) {
dh = new DateTimeFormatterBuilder()
.append(date())
.append(literalTElement())
.append(hour())
.toFormatter();
return dh;
if (dhm == null) {
dhm = new DateTimeFormatterBuilder()
.append(date())
.append(literalTElement())
.append(hourMinute())
.toFormatter();
return dhm;
if (dhms == null) {
dhms = new DateTimeFormatterBuilder()
.append(date())
.append(literalTElement())
.append(hourMinuteSecond())
.toFormatter();
return dhms;
if (dhmsl == null) {
dhmsl = new DateTimeFormatterBuilder()
.append(date())
.append(literalTElement())
.append(hourMinuteSecondMillis())
.toFormatter();
return dhmsl;
if (dhmsf == null) {
dhmsf = new DateTimeFormatterBuilder()
.append(date())
.append(literalTElement())
.append(hourMinuteSecondFraction())
.toFormatter();
return dhmsf;
private static DateTimeFormatter yearElement() {
if (ye == null) {
ye = new DateTimeFormatterBuilder()
.appendYear(4, 9)
.toFormatter();
return ye;
private static DateTimeFormatter monthElement() {
if (mye == null) {
mye = new DateTimeFormatterBuilder()
.appendLiteral('-')
.appendMonthOfYear(2)
.toFormatter();
return mye;
private static DateTimeFormatter dayOfMonthElement() {
if (dme == null) {
dme = new DateTimeFormatterBuilder()
.appendLiteral('-')
.appendDayOfMonth(2)
.toFormatter();
return dme;
private static DateTimeFormatter weekyearElement() {
if (we == null) {
we = new DateTimeFormatterBuilder()
.appendWeekyear(4, 9)
.toFormatter();
return we;
private static DateTimeFormatter weekElement() {
if (wwe == null) {
wwe = new DateTimeFormatterBuilder()
.appendLiteral("-W")
.appendWeekOfWeekyear(2)
.toFormatter();
return wwe;
private static DateTimeFormatter dayOfWeekElement() {
if (dwe == null) {
dwe = new DateTimeFormatterBuilder()
.appendLiteral('-')
.appendDayOfWeek(1)
.toFormatter();
return dwe;
private static DateTimeFormatter dayOfYearElement() {
if (dye == null) {
dye = new DateTimeFormatterBuilder()
.appendLiteral('-')
.appendDayOfYear(3)
.toFormatter();
return dye;
private static DateTimeFormatter literalTElement() {
if (lte == null) {
lte = new DateTimeFormatterBuilder()
.appendLiteral('T')
.toFormatter();
return lte;
private static DateTimeFormatter hourElement() {
if (hde == null) {
hde = new DateTimeFormatterBuilder()
.appendHourOfDay(2)
.toFormatter();
return hde;
private static DateTimeFormatter minuteElement() {
if (mhe == null) {
mhe = new DateTimeFormatterBuilder()
.appendLiteral(':')
.appendMinuteOfHour(2)
.toFormatter();
return mhe;
private static DateTimeFormatter secondElement() {
if (sme == null) {
sme = new DateTimeFormatterBuilder()
.appendLiteral(':')
.appendSecondOfMinute(2)
.toFormatter();
return sme;
private static DateTimeFormatter fractionElement() {
if (fse == null) {
fse = new DateTimeFormatterBuilder()
.appendLiteral('.')
.appendFractionOfSecond(3, 9)
.toFormatter();
return fse;
private static DateTimeFormatter offsetElement() {
if (ze == null) {
ze = new DateTimeFormatterBuilder()
.appendTimeZoneOffset("Z", true, 2, 4)
.toFormatter();
return ze;final Calendar calendar = Calendar.getInstance(timeZone);
calendar.clear();
calendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(),
getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());
Date date = calendar.getTime();
date.setTime(date.getTime() + getMillisOfSecond());
return correctDstTransition(date, timeZone);
Calendar calendar = Calendar.getInstance(timeZone);
calendar.setTime(date);
LocalDateTime check = LocalDateTime.fromCalendarFields(calendar);
if (check.isBefore(this)) {
while (check.isBefore(this)) {
calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000);
check = LocalDateTime.fromCalendarFields(calendar);
while (check.isBefore(this) == false) {
calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000);
check = LocalDateTime.fromCalendarFields(calendar);
calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000);
final Calendar earlier = Calendar.getInstance(timeZone);
earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings());
check = LocalDateTime.fromCalendarFields(earlier);
if (check.equals(this)) {
calendar = earlier;
return calendar.getTime();private static final Map<String, DateTimeFormatter> PATTERN_CACHE = new LinkedHashMap<String, DateTimeFormatter>(7){
private static final long serialVersionUID = 23L;
protected boolean removeEldestEntry(final Map.Entry<String,DateTimeFormatter> eldest) {
return size() > PATTERN_CACHE_SIZE;
private static DateTimeFormatter createFormatterForPattern(final String pattern) {
final DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
private static DateTimeFormatter createFormatterForStyleIndex(final int dateStyle, final int timeStyle) {
final int index = ((dateStyle << 2) + dateStyle) + timeStyle;
if (index >= STYLE_CACHE.length) {
return createDateTimeFormatter(dateStyle, timeStyle);
DateTimeFormatter f = null;
synchronized (STYLE_CACHE) {
f = STYLE_CACHE[index];
if (f == null) {
f = createDateTimeFormatter(dateStyle, timeStyle);
STYLE_CACHE[index] = f;
return f;
private static DateTimeFormatter createDateTimeFormatter(final int dateStyle, final int timeStyle){
int type = DATETIME;
final StyleFormatter llf = new StyleFormatter(
dateStyle, timeStyle, type);instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));return super.equals(obj);
return super.equals(obj);
return super.equals(obj);
return "GJ".hashCode() * 11 + iJulianChronology.hashCode() +
iGregorianChronology.hashCode() + iCutoverInstant.hashCode();
return super.equals(obj);BuddhistChronology chrono = cCache.get(zone);
if (chrono == null) {
chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");
cCache.put(zone, chrono);
ArrayList<GJChronology> chronos = cCache.get(zone);
if (chronos == null) {
chronos = new ArrayList<GJChronology>(2);
cCache.put(zone, chronos);
for (int i=chronos.size(); --i>=0; ) {
chrono = chronos.get(i);
if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
cutoverInstant.equals(chrono.getGregorianCutover())) {
return chrono;
if (zone == DateTimeZone.UTC) {
chrono = new GJChronology
(JulianChronology.getInstance(zone, minDaysInFirstWeek),
GregorianChronology.getInstance(zone, minDaysInFirstWeek),
cutoverInstant);
chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);
chrono = new GJChronology
(ZonedChronology.getInstance(chrono, zone),
chrono.iJulianChronology,
chrono.iGregorianChronology,
chrono.iCutoverInstant);
chronos.add(chrono);import java.io.FileOutputStream;
import org.joda.time.field.DelegatedDurationField;
import org.joda.time.field.MillisDurationField;
private static class MockDelegatedDurationField extends DelegatedDurationField implements Serializable {
private static final long serialVersionUID = 1878496002811998493L;        
public MockDelegatedDurationField() {
super(MillisDurationField.INSTANCE);
private void store(Serializable test, String filename) throws Exception {
FileOutputStream fos = new FileOutputStream("src/test/resources/" + filename);
ObjectOutputStream oos = new ObjectOutputStream(fos);
try {
oos.writeObject(test);
oos.close();
oos.close();DateMidnight test = new DateMidnight(TEST_TIME_NOW);
assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH")));
assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null));if (minutesOffset < 0 || minutesOffset > 59) {
minutesOffset = hoursInMinutes - minutesOffset;
assertEquals(DateTimeZone.forID("+03:15"), DateTimeZone.forOffsetHoursMinutes(3, 15));
assertEquals(DateTimeZone.forID("-02:30"), DateTimeZone.forOffsetHoursMinutes(-2, 30));
try {
DateTimeZone.forOffsetHoursMinutes(2, -1);
fail();
try {
DateTimeZone.forOffsetHoursMinutes(-2, -1);
fail();import org.joda.time.format.DateTimeFormat;
int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
import java.lang.reflect.Method;
DateTimeZone.forOffsetHoursMinutes(999999, 0);int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
public void testFactory_daysBetween_RPartial() {
public void testFactory_monthsBetween_RPartial() {bucket.setZone(parseLookup.get(name));
return position + name.length();static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
static {
cVerbose.set(Boolean.FALSE);else {
assert(seconds >= 0L);if ((str.charAt(i) >= '0' && str.charAt(i) <= '9') ||
(i == 0 && str.charAt(0) == '-')) {
seconds = Long.parseLong(str.substring(0, dot));
if (seconds < 0) {
return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), -millis);return setCopy(getMaximumValue());
return setCopy(getMinimumValue());position += (parsedForm == null ? 0 : parsedForm.length());
if (found && position == oldPos) {return (value > 28 ? getDaysInMonthMax(instant) : 28);calendar.get(Calendar.YEAR),
calendar.get(Calendar.YEAR),
public void testFactory_FromCalendarFields() throws Exception {
public void testFactory_FromDateFields_after1970() throws Exception {
try {
LocalDateTime.fromDateFields((Date) null);
fail();
public void testFactory_FromDateFields_before1970() throws Exception {
public void testFactory_FromCalendarFields() throws Exception {
public void testFactory_FromDateFields() throws Exception {put(map, "CST", "America/Chigaco");
put(map, "CDT", "America/Chigaco");Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);
DateTimeZone zone = instantChrono.getZone();
if (zone != null) {
instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);assertEquals("1 dia, 5 horas, 6 minutos, 7 segundos y 8 milisegundos", PeriodFormat.wordBased(ES).print(p));
assertEquals("2 dias", PeriodFormat.wordBased(ES).print(p));
assertEquals("2 dias y 5 horas", PeriodFormat.wordBased(ES).print(p));
assertEquals(p, PeriodFormat.wordBased(ES).parsePeriod("2 dias"));
assertEquals(p, PeriodFormat.wordBased(ES).parsePeriod("2 dias y 5 horas"));(int) (date.getTime() % 1000)
public void testFactory_FromDateFields() throws Exception {sum = Math.max(sum, 4);
Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);if (printerList.size() <= 0) {
if (parserList.size() <= 0) {
if (element instanceof DateTimePrinter) {
if (element instanceof Composite) {
addArrayToList(printerList, ((Composite)element).iPrinters);
printerList.add(element);
if (element instanceof DateTimeParser) {
if (element instanceof Composite) {
addArrayToList(parserList, ((Composite)element).iParsers);
parserList.add(element);
assertEquals("XYZ", bld2.toFormatter().print(0L));throw new ArithmeticException
("The calculation caused an overflow: " + val1 + " * " + val2);
public static long safeMultiply(long val1, int scalar) {
switch (scalar) {
case -1:
return -val1;
case 0:
return 0L;
case 1:
return val1;
long total = val1 * scalar;
if (total / scalar != val1) {
throw new ArithmeticException
("The calculation caused an overflow: " + val1 + " * " + scalar);
assertEquals(0L, FieldUtils.safeMultiply(0L, 0L));
assertEquals(1L, FieldUtils.safeMultiply(1L, 1L));
assertEquals(3L, FieldUtils.safeMultiply(1L, 3L));
assertEquals(3L, FieldUtils.safeMultiply(3L, 1L));
assertEquals(6L, FieldUtils.safeMultiply(2L, 3L));
assertEquals(-6L, FieldUtils.safeMultiply(2L, -3L));
assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3L));
assertEquals(6L, FieldUtils.safeMultiply(-2L, -3L));
assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1L));
assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1L));
assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1L));
try {
FieldUtils.safeMultiply(Long.MIN_VALUE, -1L);
fail();
try {
FieldUtils.safeMultiply(-1L, Long.MIN_VALUE);
fail();
try {
FieldUtils.safeMultiply(Long.MIN_VALUE, 100L);
fail();
try {
FieldUtils.safeMultiply(Long.MIN_VALUE, Long.MAX_VALUE);
fail();
try {
FieldUtils.safeMultiply(Long.MAX_VALUE, Long.MIN_VALUE);
fail();instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);(DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);if (val2 == 0) {
if (total / val2 != val1) {
throw new ArithmeticException
("The calculation caused an overflow: " + val1 + " * " + val2);long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
if (before == after) {
return instant;
long local = convertUTCToLocal(instant);
return convertLocalToUTC(local, false, earlierOrLater ? after : before);
assertEquals(baseAfter, baseAfter.withLaterOffsetAtOverlap());Locale.setDefault(Locale.UK);cache.put(inPartType, checkedType);
cache.put(inPartType, type);long instant = iGregorianChronology.getDateTimeMillis
(year, monthOfYear, dayOfMonth,
hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);bucket.setZone(DateTimeZone.forID(id));
return position + id.length();String[][] zoneStrings = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
for (int i=0; i<zoneStrings.length; i++) {
String[] set = zoneStrings[i];
if (set != null && set.length == 5 && id.equals(set[0])) {
byNameKeyCache.put(set[2], new String[] {set[2], set[1]});
if (set[2].equals(set[4])) {
byNameKeyCache.put(set[4] + "-Summer", new String[] {set[4], set[3]});
byNameKeyCache.put(set[4], new String[] {set[4], set[3]});
break;
return (String[])byNameKeyCache.get(nameKey);if (iOffsetParsed && bucket.getOffset() != null) {
int parsedOffset = bucket.getOffset();
if (bucket.getOffset() != null) {  // treat withOffsetParsed() as being true
int parsedOffset = bucket.getOffset();
if (iOffsetParsed && bucket.getOffset() != null) {
int parsedOffset = bucket.getOffset();
if (iOffsetParsed && bucket.getOffset() != null) {
int parsedOffset = bucket.getOffset();
bucket.setOffset(0);
bucket.setOffset(0);
bucket.setOffset(negative ? -offset : offset);
public Integer getOffset() {private final long iMillis;
private final Chronology iChronology;
instant = checkInstant(instant, iChronology);
MutableHelper.setDateTimeMillis(this, instant);
chronology = checkChronology(chronology);
MutableHelper.setDateTimeChrono(this, chronology);
private final long iMillis;
MutableHelper.setDurationMillis(this, duration);
private final Chronology iChronology;
private final long iStartMillis;
private final long iEndMillis;
MutableHelper.setInterval(this, startInstant, endInstant, DateTimeUtils.getChronology(chrono));
private final int iPeriod;
MutableHelper.setSingleFieldPeriodValue(this, value);
package org.joda.time.base;
import java.lang.reflect.Field;
import org.joda.time.Chronology;
final class MutableHelper {
private static final Field DATE_TIME_MILLIS;
private static final Field DATE_TIME_CHRONO;
private static final Field DURATION_MILLIS;
private static final Field SINGLE_FIELD_PERIOD;
private static final Field INTERVAL_START;
private static final Field INTERVAL_END;
private static final Field INTERVAL_CHRONO;
static {
try {
DATE_TIME_MILLIS = BaseDateTime.class.getDeclaredField("iMillis");
DATE_TIME_MILLIS.setAccessible(true);
DATE_TIME_CHRONO = BaseDateTime.class.getDeclaredField("iChronology");
DATE_TIME_CHRONO.setAccessible(true);
DURATION_MILLIS = BaseDuration.class.getDeclaredField("iMillis");
DURATION_MILLIS.setAccessible(true);
SINGLE_FIELD_PERIOD = BaseSingleFieldPeriod.class.getDeclaredField("iPeriod");
SINGLE_FIELD_PERIOD.setAccessible(true);
INTERVAL_START = BaseInterval.class.getDeclaredField("iStartMillis");
INTERVAL_START.setAccessible(true);
INTERVAL_END = BaseInterval.class.getDeclaredField("iEndMillis");
INTERVAL_END.setAccessible(true);
INTERVAL_CHRONO = BaseInterval.class.getDeclaredField("iChronology");
INTERVAL_CHRONO.setAccessible(true);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);
private MutableHelper() {
static void setDateTimeMillis(BaseDateTime target, long instant) {
try {
DATE_TIME_MILLIS.set(target, instant);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);
static void setDateTimeChrono(BaseDateTime target, Chronology chrono) {
try {
DATE_TIME_CHRONO.set(target, chrono);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);
static void setDurationMillis(BaseDuration target, long duration) {
try {
DURATION_MILLIS.set(target, duration);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);
static void setSingleFieldPeriodValue(BaseSingleFieldPeriod target, int value) {
try {
SINGLE_FIELD_PERIOD.set(target, value);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);
static void setInterval(BaseInterval target, long startMillis, long endMillis, Chronology chrono) {
try {
INTERVAL_START.set(target, startMillis);
INTERVAL_END.set(target, endMillis);
INTERVAL_CHRONO.set(target, chrono);
throw new RuntimeException("Joda-Time mutable classes require reflection", ex);super(duration, null, null);
super(duration, null, null);
long length =
(4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +
5L * DateTimeConstants.MILLIS_PER_HOUR +
6L * DateTimeConstants.MILLIS_PER_MINUTE +
7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;
Duration test = new Duration(length);
Period result = test.toPeriod();
assertEquals(new Period(test), result);
assertEquals(new Period(test.getMillis()), result);private long iLocalMillis;
private Chronology iChronology;
private long iLocalMillis;
private Chronology iChronology;
private long iLocalMillis;
private Chronology iChronology;
import java.io.FileNotFoundException;
try {
fis = new FileInputStream("src/test/resources/" + filename + "2.dat");
ois = new ObjectInputStream(fis);
obj = ois.readObject();
ois.close();
if (same) {
assertSame(test, obj);
assertEquals(test, obj);FormatUtils.appendUnpaddedInteger(buf, millis / 1000);
long part = Math.abs(millis % 1000);
if (part > 0) {
buf.append('.');
FormatUtils.appendPaddedInteger(buf, part, 3);
private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
test = new Duration(0L);
assertEquals("PT0S", test.toString());
test = new Duration(12345L);
assertEquals("PT12.345S", test.toString());
test = new Duration(-12345L);
assertEquals("PT-12.345S", test.toString());temp = forID(System.getProperty("user.timezone"));int compareTo(ReadableDuration obj);
int compareTo(ReadableInstant readableInstant);import org.joda.time.*;
import org.joda.time.format.*;
millis = iZone.nextTransition(millis);private static class DateTimeOfYear {
millis = parseTime(str);(int) (date.getTime() % 1000)
(int) (date.getTime() % 1000)
public void testFactory_FromDateFields_Date() throws Exception {
public void testFactory_FromDateFields() throws Exception {package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.UserType;
public abstract class AbstractStringBasedJodaType implements UserType, Serializable {
private static final int[] SQL_TYPES = new int[]{Types.VARCHAR};
public int[] sqlTypes() {
return SQL_TYPES;
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException {
String s = (String) Hibernate.STRING.nullSafeGet(resultSet, strings[0]);
if (s == null) {
return null;
return fromNonNullString(s);
protected abstract Object fromNonNullString(String s);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException {
if (value == null) {
Hibernate.STRING.nullSafeSet(preparedStatement, null, index);
Hibernate.STRING.nullSafeSet(preparedStatement, toNonNullString(value), index);
protected abstract String toNonNullString(Object value);
public boolean equals(Object x, Object y) throws HibernateException {
if (x == y) {
return true;
if (x == null || y == null) {
return false;
return x.equals(y);
public int hashCode(Object object) throws HibernateException {
return object.hashCode();
public Object deepCopy(Object value) throws HibernateException {
return value;
public boolean isMutable() {
return false;
public Serializable disassemble(Object value) throws HibernateException {
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException {
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException {
return original;
public final static PersistentDateTime INSTANCE = new PersistentDateTime();
private static final int[] SQL_TYPES = new int[]
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return new DateTime(timestamp);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);
else
Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((DateTime) value).toDate(), index);
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new DateTime(string);
public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();
private static final int[] SQL_TYPES = new int[]
package org.joda.time.contrib.hibernate;
import org.joda.time.Duration;
public class PersistentDuration extends AbstractStringBasedJodaType {
public Class returnedClass() {
return Duration.class;
protected Object fromNonNullString(String s) {
return new Duration(s);
protected String toNonNullString(Object value) {
return value.toString();
public final static PersistentInstantAsBigInt INSTANCE = new PersistentInstantAsBigInt();
private static final int[] SQL_TYPES = new int[] {Types.BIGINT};
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return Instant.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
Instant ix = (Instant) x;
Instant iy = (Instant) y;
return ix.equals(iy);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] names, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, names[0]);
public Object nullSafeGet(ResultSet resultSet, String name) throws HibernateException, SQLException
Object value = Hibernate.LONG.nullSafeGet(resultSet, name);
if (value == null)
return null;
return new Instant(value);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.LONG.nullSafeSet(preparedStatement, null, index);
else
Hibernate.LONG.nullSafeSet(preparedStatement, new Long(((Instant)value).getMillis()), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new Instant(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable)value;
public Object assemble(Serializable serializable, Object value) throws HibernateException
return serializable;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new Instant(string);
package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.EnhancedUserType;
import org.joda.time.LocalDate;
public class PersistentLocalDate implements EnhancedUserType, Serializable
public final static PersistentLocalDate INSTANCE = new PersistentLocalDate();
private static final int[] SQL_TYPES = new int[]
Types.DATE,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return LocalDate.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
LocalDate dtx = (LocalDate) x;
LocalDate dty = (LocalDate) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.DATE.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return new LocalDate(timestamp);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.DATE.nullSafeSet(preparedStatement, null, index);
else
Hibernate.DATE.nullSafeSet(preparedStatement, ((LocalDate) value).toDateTimeAtStartOfDay().toDate(), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new LocalDate(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new LocalDate(string);
package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.EnhancedUserType;
import org.joda.time.LocalDateTime;
public class PersistentLocalDateTime implements EnhancedUserType, Serializable
public final static PersistentLocalDateTime INSTANCE = new PersistentLocalDateTime();
private static final int[] SQL_TYPES = new int[]
Types.TIMESTAMP,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return LocalDateTime.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
LocalDateTime dtx = (LocalDateTime) x;
LocalDateTime dty = (LocalDateTime) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.TIMESTAMP.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return new LocalDateTime(timestamp);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, null, index);
else
Hibernate.TIMESTAMP.nullSafeSet(preparedStatement, ((LocalDateTime) value).toDateTime().toDate(), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new LocalDateTime(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new LocalDateTime(string);
package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.EnhancedUserType;
import org.joda.time.LocalTime;
public class PersistentLocalTimeAsString implements EnhancedUserType, Serializable
public final static PersistentLocalTimeAsString INSTANCE = new PersistentLocalTimeAsString();
private static final int[] SQL_TYPES = new int[]
Types.VARCHAR,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return LocalTime.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
LocalTime dtx = (LocalTime) x;
LocalTime dty = (LocalTime) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.STRING.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return new LocalTime(timestamp.toString());
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.STRING.nullSafeSet(preparedStatement, null, index);
else
LocalTime lt = ((LocalTime) value);
Hibernate.STRING.nullSafeSet(preparedStatement, lt.toString(), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new LocalTime(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new LocalTime(string);
package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.EnhancedUserType;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalTime;
public class PersistentLocalTimeAsTime implements EnhancedUserType, Serializable
public final static PersistentLocalTimeAsTime INSTANCE = new PersistentLocalTimeAsTime();
private static final int[] SQL_TYPES = new int[]
Types.TIME,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return LocalTime.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
LocalTime dtx = (LocalTime) x;
LocalTime dty = (LocalTime) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.TIME.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return new LocalTime(timestamp, DateTimeZone.UTC);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.TIME.nullSafeSet(preparedStatement, null, index);
else
LocalTime lt = ((LocalTime) value);
Time time = new Time(lt.getMillisOfDay());
Hibernate.TIME.nullSafeSet(preparedStatement, time, index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new LocalTime(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new LocalTime(string);
package org.joda.time.contrib.hibernate;
import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.EnhancedUserType;
import org.joda.time.LocalTime;
public class PersistentLocalTimeExact implements EnhancedUserType, Serializable
public final static PersistentLocalTimeExact INSTANCE = new PersistentLocalTimeExact();
private static final int[] SQL_TYPES = new int[]
Types.INTEGER,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return LocalTime.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
LocalTime dtx = (LocalTime) x;
LocalTime dty = (LocalTime) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object timestamp = Hibernate.INTEGER.nullSafeGet(resultSet, string);
if (timestamp == null)
return null;
return LocalTime.fromMillisOfDay(((Number) timestamp).intValue());
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.INTEGER.nullSafeSet(preparedStatement, null, index);
else
LocalTime lt = ((LocalTime) value);
Hibernate.INTEGER.nullSafeSet(preparedStatement, new Integer(lt.getMillisOfDay()), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new LocalTime(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new LocalTime(string);
package org.joda.time.contrib.hibernate;
import org.joda.time.Period;
public class PersistentPeriod extends AbstractStringBasedJodaType {
public Class returnedClass() {
return Period.class;
protected Object fromNonNullString(String s) {
return new Period(s);
protected String toNonNullString(Object value) {
return value.toString();
private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);
public final static PersistentTimeOfDay INSTANCE = new PersistentTimeOfDay();
private static final int[] SQL_TYPES = new int[]
Types.TIME,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return TimeOfDay.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
TimeOfDay dtx = (TimeOfDay) x;
TimeOfDay dty = (TimeOfDay) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object date = Hibernate.TIME.nullSafeGet(resultSet, string);
if (date == null)
return null;
return new TimeOfDay(date);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.TIME.nullSafeSet(preparedStatement, null, index);
else
Hibernate.TIME.nullSafeSet(preparedStatement, new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new TimeOfDay(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new TimeOfDay(string);
private final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);
public final static PersistentTimeOfDayExact INSTANCE = new PersistentTimeOfDayExact();
private static final int[] SQL_TYPES = new int[]
Types.INTEGER,
public int[] sqlTypes()
return SQL_TYPES;
public Class returnedClass()
return TimeOfDay.class;
public boolean equals(Object x, Object y) throws HibernateException
if (x == y)
return true;
if (x == null || y == null)
return false;
TimeOfDay dtx = (TimeOfDay) x;
TimeOfDay dty = (TimeOfDay) y;
return dtx.equals(dty);
public int hashCode(Object object) throws HibernateException
return object.hashCode();
public Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
int value = resultSet.getInt(string);
if (resultSet.wasNull())
return null;
return new TimeOfDay(value);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
preparedStatement.setNull(index, SQL_TYPES[0]);
else
preparedStatement.setInt(index, (int) ((TimeOfDay) value).toDateTime(timeBase).getMillis());
public Object deepCopy(Object value) throws HibernateException
if (value == null)
return null;
return new TimeOfDay(value);
public boolean isMutable()
return false;
public Serializable disassemble(Object value) throws HibernateException
return (Serializable) value;
public Object assemble(Serializable cached, Object value) throws HibernateException
return cached;
public Object replace(Object original, Object target, Object owner) throws HibernateException
return original;
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new TimeOfDay(string);
public final static PersistentYearMonthDay INSTANCE = new PersistentYearMonthDay();
private static final int[] SQL_TYPES = new int[]
return nullSafeGet(resultSet, strings[0]);
public Object nullSafeGet(ResultSet resultSet, String string) throws SQLException
Object date = Hibernate.DATE.nullSafeGet(resultSet, string);
if (date == null)
return null;
return new YearMonthDay(date);
public void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException
if (value == null)
Hibernate.DATE.nullSafeSet(preparedStatement, null, index);
else
Hibernate.DATE.nullSafeSet(preparedStatement, ((YearMonthDay) value).toDateMidnight().toDate(), index);
public String objectToSQLString(Object object)
throw new UnsupportedOperationException();
public String toXMLString(Object object)
return object.toString();
public Object fromXMLString(String string)
return new YearMonthDay(string);private PeriodPrinter iBeforePrinter;
private PeriodPrinter iAfterPrinter;
private PeriodParser iBeforeParser;
private PeriodParser iAfterParser;assertEquals(BUDDHIST_PARIS, f2.getChronolgy());
assertEquals(null, f2.getChronolgy());return toDateMidnight(zone).toInterval();
DateTime start = base.toDateTimeAtMidnight();
DateTime start = base.toDateTimeAtMidnight(TOKYO);
DateTime start = base.toDateTimeAtMidnight(LONDON);static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {
Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());
System.out.println("     - " + new DateTime(trans[i]) + " - " + new DateTime(trans[i + 1]));
if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {
System.out.println("Fixing duplicate recurrent name key - " + tailZone.iStartRecurrence.getNameKey());
return new PrecalculatedZone((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone);import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.usertype.UserType;
import org.joda.time.Period;for (; i >= 0 && i <= MAX_FIELD; i++) {if (partial.isSupported(iFieldType)) {
long millis = partial.getChronology().set(partial, 0L);
try {
printTo(buf, null, millis, partial.getChronology());
buf.append('\ufffd');
if (partial.isSupported(iFieldType)) {
long millis = partial.getChronology().set(partial, 0L);
printTo(null, out, millis, partial.getChronology());
out.write('\ufffd');
lse, // millisOfSecond element (.SSS)
.append(hourMinuteSecondMillis())
.appendMonthOfYear(2)
.appendDayOfMonth(2)
.appendHourOfDay(2)
.appendMinuteOfHour(2)
.appendSecondOfMinute(2)
.appendMillisOfSecond(3)
.appendHourOfDay(2)
.appendMinuteOfHour(2)
.appendSecondOfMinute(2)
.appendDayOfYear(3)
.appendWeekOfWeekyear(2)
.appendDayOfWeek(1)
.append(millisElement())
private static DateTimeFormatter millisElement() {
if (lse == null) {
lse = new DateTimeFormatterBuilder()
.appendLiteral('.')
.appendMillisOfSecond(3)
.toFormatter();
return lse;
assertParse(parser, true, "2006-06-09");
assertParse(parser, true, "T10:20:30.040");
assertParse(parser, true, "T10.5");
assertParse(parser, true, "T10:20:30.040+02:00");
assertParse(parser, true, "T10.5+02:00");return iTimeField ? iField.isPrecise() : this.iZone.isFixed();long localInstant = iZone.convertUTCToLocal(instant);
localInstant = iField.roundFloor(localInstant);
return iZone.convertLocalToUTC(localInstant, false);
long localInstant = iZone.convertUTCToLocal(instant);
localInstant = iField.roundCeiling(localInstant);
return iZone.convertLocalToUTC(localInstant, false);if (offsetLocal < 0) {
public void test_DateTime_plusHour_NewYork_Autumm() {
public void test_DateTime_minusHour_NewYork_Autumm() {
public void test_DateTime_plusHour_Moscow_Autumm() {
public void test_DateTime_minusHour_Moscow_Autumm() {
private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {
DateTime dt = new DateTime(2007, month, day, hour, min, 0, 0, DateTimeZone.UTC);DateTime now = new DateTime();
DateTime now = new DateTime();int limit = text.length();
int i = position;
for (; i<limit; i++) {
char c = text.charAt(i);
if (c < 'A') {
break;
if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || Character.isLetter(c)) {
continue;
break;
if (i == position) {
return ~position;
Locale locale = bucket.getLocale();
bucket.saveField(iFieldType, text.substring(position, i), locale);
return i;if (locale == null) {
locale = Locale.getDefault();throw new IllegalArgumentException("Field is not supported");throw new IllegalArgumentException("Field is not supported");return getOffset(instantLocal - getOffset(instantLocal));
Number lowerBound, Number upperBound) {
super(createMessage(fieldType.getName(), value, lowerBound, upperBound));
super(createMessage(fieldType.getName(), value, lowerBound, upperBound));
super(createMessage(fieldName, value, lowerBound, upperBound));
private static final DateTimeField convertField(DateTimeField field) {
return LenientDateTimeField.getInstance(field);
int offset = this.iZone.getOffset(instant);
long sum = instant + offset;
if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {
throw new ArithmeticException("Adding time zone offset caused overflow");
return sum;
return iField.get(addOffset(instant));
return iField.getAsText(addOffset(instant), locale);
return iField.getAsShortText(addOffset(instant), locale);
int offset = getOffsetToAdd(instant);
instant = iField.add(instant + offset, value);
return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));
int offset = getOffsetToAdd(instant);
instant = iField.add(instant + offset, value);
return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));
int offset = getOffsetToAdd(instant);
instant = iField.addWrapField(instant + offset, value);
return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));
long offset = getOffsetToAdd(instant);
instant = iField.set(instant + offset, value);
long offsetFromLocal = getOffsetFromLocalToSubtract(instant);
instant -= offsetFromLocal;
if (offset != offsetFromLocal) {
if (get(instant) != value) {
throw new IllegalFieldValueException
(iField.getType(), new Integer(value), null, null);
return instant;
instant = iField.set(addOffset(instant), text, locale);
return instant - getOffsetFromLocalToSubtract(instant);
return iField.isLeap(addOffset(instant));
return iField.getLeapAmount(addOffset(instant));
int offset = getOffsetToAdd(instant);
instant = iField.roundFloor(instant + offset);
return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));
int offset = getOffsetToAdd(instant);
instant = iField.roundCeiling(instant + offset);
return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));
return iField.remainder(addOffset(instant));
return iField.getMinimumValue(addOffset(instant));
return iField.getMaximumValue(addOffset(instant));
private int getOffsetFromLocalToSubtract(long instant) {
int offset = this.iZone.getOffsetFromLocal(instant);
long diff = instant - offset;
if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {
throw new ArithmeticException("Subtracting time zone offset caused overflow");
return offset;
private long addOffset(long instant) {
int offset = this.iZone.getOffset(instant);
long sum = instant + offset;
if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {
throw new ArithmeticException("Adding time zone offset caused overflow");
return sum;
public static DateTimeField getInstance(DateTimeField field) {
return new LenientDateTimeField(field);
protected LenientDateTimeField(DateTimeField field) {
return add(instant, difference);int min = getMinimumValue(instant);
if (value >= min && value <= getMaximumValue(instant)) {
return super.set(instant, value);
return add(super.set(instant, min), value - min);private long TEST_TIME1 =
(y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY
+ 12L * DateTimeConstants.MILLIS_PER_HOUR
+ 24L * DateTimeConstants.MILLIS_PER_MINUTE;
private long TEST_TIME2 =
(y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY
+ 14L * DateTimeConstants.MILLIS_PER_HOUR
+ 28L * DateTimeConstants.MILLIS_PER_MINUTE;
DateTimeZone zone = DateTimeZone.forID("Asia/Gaza");
DateTime now = new DateTime(1944, 1, 1, 0, 0, 0, 0);public DateTimeZone toDateTimeZone(String id) {
PrecalculatedZone zone = new PrecalculatedZone(id, transitions, tailZone);
public void writeTo(OutputStream out) throws IOException {
writeTo((DataOutput)out);
writeTo((DataOutput)new DataOutputStream(out));
public void writeTo(DataOutput out) throws IOException {
DateTimeZone zone = toDateTimeZone("");
private final int iStandardOffset;
private final Recurrence iStartRecurrence;
private final Recurrence iEndRecurrence;
private final long[] iTransitions;
private final int[] iWallOffsets;
private final int[] iStandardOffsets;
private final String[] iNameKeys;
private final DSTZone iTailZone;
PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,
int[] standardOffsets, String[] nameKeys, DSTZone tailZone)
super(id);
iTransitions = transitions;
iWallOffsets = wallOffsets;
iStandardOffsets = standardOffsets;
iNameKeys = nameKeys;
iTailZone = tailZone;
PrecalculatedZone(String id, ArrayList transitions, DSTZone tailZone) {
super(id);
iTransitions = new long[size];
iWallOffsets = new int[size];
iStandardOffsets = new int[size];
iNameKeys = new String[size];
iTransitions[i] = tr.getMillis();
iWallOffsets[i] = tr.getWallOffset();
iStandardOffsets[i] = tr.getStandardOffset();
iNameKeys[i] = tr.getNameKey();
byNameKeyCache.put(set[4], new String[] {set[4], set[3]});
final DateTimeZone original = builder.toDateTimeZone(zone.iName);
builder.writeTo(out);
return buildAmericaLosAngelesBuilder().toDateTimeZone("America/Los_Angeles");
builder.writeTo(out);
DateTimeZone tz = builder.toDateTimeZone("Test");if (value >= min && value < getMaximumValue(instant)) {sum++; // decimal point
(Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {if (readableInstant instanceof ReadableInstant) {
ReadableInstant otherInstant = (ReadableInstant) readableInstant;
if (getMillis() == otherInstant.getMillis()) {
Chronology chrono = getChronology();
if (chrono == otherInstant.getChronology()) {
return true;
if (chrono != null && chrono.equals(otherInstant.getChronology())) {
return true;
return false;
return (getStartMillis() == other.getStartMillis() &&
getEndMillis() == other.getEndMillis() &&
getChronology() == other.getChronology());
return (getChronology() == other.getChronology());
public String toString() {
return getBase().toString();
if (object instanceof AbstractPartialFieldProperty) {
AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;
if (get() == other.get() &&
getFieldType() == other.getFieldType() &&
getReadablePartial().getChronology() == other.getReadablePartial().getChronology()) {
return true;
return false;
if (object instanceof AbstractReadableInstantFieldProperty) {
AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;
if (get() == other.get() &&
getField().equals(other.getField())) {
return true;
return false;
return get() * 17 + getField().hashCode();return dateElementParser();
.toFormatter();
.toFormatter();
public void testConstructor_Object2_DateTimeZone() throws Throwable {
LocalTime test = new LocalTime("T10:20");
assertEquals(10, test.getHourOfDay());
assertEquals(0, test.getSecondOfMinute());
assertEquals(0, test.getMillisOfSecond());
try {
new LocalTime("T1020");
fail();
import org.joda.time.DateTime;
import org.joda.time.DateTimeConstants;
import org.joda.time.DateTimeUtils;
import org.joda.time.Period;
import org.joda.time.PeriodType;return (millisInstant >= thisStart && millisInstant < thisEnd) ||
(thisStart == millisInstant && thisEnd == millisInstant);
return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) ||
(thisStart == otherStart && thisEnd == otherEnd);
return containsNow();
long otherStart = interval.getStartMillis();
long otherEnd = interval.getEndMillis();
long thisStart = getStartMillis();
long thisEnd = getEndMillis();
return (thisStart < otherEnd && otherStart < thisEnd) ||
(thisStart == otherStart &&
(thisStart == thisEnd || otherStart == otherEnd));
assertEquals(true,  test1020.overlaps(interval));
assertEquals(true,  interval.overlaps(test1020));
assertEquals(true,  test1010.overlaps(test1010));
assertEquals(true,  test1010.contains(test1010));
assertEquals(true,  interval33.contains(3));
assertEquals(true,  interval33.containsNow());
assertEquals(true,  interval33.contains(new Instant(3)));
assertEquals(true,  interval33.contains(interval33));
assertEquals(true,  interval33.contains((ReadableInterval) null));
assertEquals(true,  interval37.overlaps(new Interval(3, 3)));
assertEquals(true,  interval37.overlaps((ReadableInterval) null));
assertEquals(true,  interval33.overlaps((ReadableInterval) null));
assertEquals(true,  interval33.overlaps(interval33));
assertEquals(true,  interval33.overlaps(interval37));
assertEquals(true,  interval37.overlaps(interval33));
assertEquals(new Interval(3, 3), interval37.overlap(new Interval(3, 3)));
assertEquals(new Interval(3, 3), interval37.overlap((ReadableInterval) null));
assertEquals(new Interval(3, 3), interval33.overlap((ReadableInterval) null));
assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1)));
assertEquals(true, empty.overlaps(empty));
assertEquals(true, empty.overlaps(test));
assertEquals(true, test.overlaps(empty));return new Interval(start, end);
return new Interval(otherEnd, thisStart);
return new Interval(thisEnd, otherStart);
DateTimeZone.setDefault(LONDON);
TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));
Locale.setDefault(Locale.UK);import org.joda.time.convert.InstantConverter;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
long millis = converter.getInstantMillis
(instant, chronology, ISODateTimeFormat.dateParser());
long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
chronology = chronology.withUTC();
chronology.dayOfMonth().roundFloor(localMillis);
iLocalMillis = localMillis;
iChronology = chronology;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
Chronology chrono = DateTimeUtils.getChronology
(converter.getChronology(instant, chronology));
long millis = converter.getInstantMillis
(instant, chronology, ISODateTimeFormat.dateParser());
long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
chrono = chrono.withUTC();
chrono.dayOfMonth().roundFloor(localMillis);
iLocalMillis = localMillis;
iChronology = chrono;
import org.joda.time.convert.InstantConverter;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
long millis = converter.getInstantMillis(instant, chronology);
long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
iLocalMillis = localMillis;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
Chronology chrono = DateTimeUtils.getChronology(converter.getChronology(instant, chronology));
long millis = converter.getInstantMillis(instant, chrono);
long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
iLocalMillis = localMillis;
iChronology = chrono.withUTC();
import org.joda.time.convert.InstantConverter;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
long millis = converter.getInstantMillis
(instant, chronology, ISODateTimeFormat.timeParser());
long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
chronology = chronology.withUTC();
chronology.millisOfDay().get(localMillis);
iLocalMillis = localMillis;
iChronology = chronology;
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
Chronology chrono = DateTimeUtils.getChronology
(converter.getChronology(instant, chronology));
long millis = converter.getInstantMillis
(instant, chronology, ISODateTimeFormat.timeParser());
long localMillis = chrono.getZone().getMillisKeepLocal(DateTimeZone.UTC, millis);
chrono = chrono.withUTC();
chrono.millisOfDay().get(localMillis);
iLocalMillis = localMillis;
iChronology = chrono;
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) {
return getInstantMillis(object, chrono);
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono,
DateTimeFormatter parser)
long instant = getInstantMillis(object, chrono, parser);
return chrono.get(fieldSource, instant);
import org.joda.time.format.DateTimeFormatter;
long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser);
if (input.size() != size) {
throw new IllegalArgumentException("Partial field type lists are different");
if (fieldSource.getFieldType(i) != input.getFieldType(i)) {
throw new IllegalArgumentException("Partial field type lists are different");
values[i] = input.getValue(i);
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) {
return parser.withChronology(chrono).parseMillis((String) object);
dtp; // date time parser
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }
public long getInstantMillis(Object object, Chronology chrono, DateTimeFormatter parser) { return 0; }public long getInstantMillis(Object object) { return 0;}
public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}
public Chronology getChronology(Object object) {return null;}
public long getInstantMillis(Object object) { return 0;}
public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}
public Chronology getChronology(Object object) {return null;}
public long getInstantMillis(Object object) { return 0;}
public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}
public Chronology getChronology(Object object) {return null;}
public long getInstantMillis(Object object) { return 0;}
public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}
public Chronology getChronology(Object object) {return null;}
public long getInstantMillis(Object object) { return 0;}
public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}
public Chronology getChronology(Object object) {return null;}static {
DateTimeZone.setDefault(LONDON);
private static final ISOChronology ISO_DEFAULT = ISOChronology.getInstance();
private static final GJChronology GJ_DEFAULT = GJChronology.getInstance();
private static final GregorianChronology GREGORIAN_DEFAULT = GregorianChronology.getInstance();
private static final BuddhistChronology BUDDHIST_DEFAULT = BuddhistChronology.getInstance();
private static final CopticChronology COPTIC_DEFAULT = CopticChronology.getInstance();
static {
DateTimeZone.setDefault(LONDON);
private static final ISOChronology ISO_DEFAULT = ISOChronology.getInstance();
private static final GJChronology GJ_DEFAULT = GJChronology.getInstance();
private static final GregorianChronology GREGORIAN_DEFAULT = GregorianChronology.getInstance();
private static final BuddhistChronology BUDDHIST_DEFAULT = BuddhistChronology.getInstance();
private static final CopticChronology COPTIC_DEFAULT = CopticChronology.getInstance();super(instant, null);
super(instant, DateTimeUtils.getChronology(chronology));return value > maxLessOne ? getMaximumValue(instant) : maxLessOne;long unitMillis = getAverageMillisPerYear();
long i2 = instant + getApproxMillisAtEpoch();
long yearStart;
try {
yearStart = getYearMillis(year);
if (instant > 0) {
throw new ArithmeticException("Instant too large: " + instant);
throw new ArithmeticException("Instant too small: " + instant);
abstract long getApproxMillisAtEpoch();
private static final int MAX_YEAR = 292271022;
if (year > MAX_YEAR) {
throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR);
if (year < MIN_YEAR) {
throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR);
long getApproxMillisAtEpoch() {
return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;
private static final int MAX_YEAR = 292271022;
if (year > MAX_YEAR) {
throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR);
if (year < MIN_YEAR) {
throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR);
long getApproxMillisAtEpoch() {
return 1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;
private static final int MAX_YEAR = 292277023;
if (year > MAX_YEAR) {
throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR);
if (year < MIN_YEAR) {
throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR);
long getApproxMillisAtEpoch() {
return 1970L * MILLIS_PER_YEAR;
long getApproxMillisAtEpoch() {
return -MILLIS_YEAR_1;
private static final int MAX_YEAR = 292271022;
if (year > MAX_YEAR) {
throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR);
if (year < MIN_YEAR) {
throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR);
long getApproxMillisAtEpoch() {
return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;
assertEquals(292277023, test.year().getMaximumValue());
assertEquals(292277023, test.year().getMaximumValueOverall());
assertEquals(292277023, test.year().getMaximumValue());
assertEquals(292277023, test.year().getMaximumValueOverall());
test.year().addToCopy(292277023 - 2004 + 1);
copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);
assertEquals(292277023, copy.getYear());
assertEquals(292277023, test.year().getMaximumValue());
assertEquals(292277023, test.year().getMaximumValueOverall());
copy = test.year().plus(292277023 - 1972);
check(copy, 292277023, 6, 9);
test.year().plus(292277023 - 1972 + 1);
copy = test.year().plusWrapField(292277023 - 1972 + 1);
check(copy, 292277023, 6, 9);
assertEquals(292277023, test.year().getMaximumValue());
assertEquals(292277023, test.year().getMaximumValueOverall());
assertEquals(292277023, test.year().getMaximumValue());
assertEquals(292277023, test.year().getMaximumValueOverall());
test.year().addToCopy(292277023 - 1972 + 1);
copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);
check(copy, 292277023, 6, 9);
try {
chrono.year().get(Long.MAX_VALUE);
fail();
try {
chrono.year().get(Long.MIN_VALUE);
fail();return (thisStart < otherEnd && otherStart < thisEnd);import org.joda.time.chrono.CopticChronology;
private static final JulianChronology JULIAN = JulianChronology.getInstance();
LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1, JULIAN);
LocalTime test = LocalTime.now(JULIAN);
LocalTime test = LocalTime.forInstant(TEST_TIME2, JULIAN);
LocalTime test = LocalTime.forInstant(date, JULIAN);
LocalTime test = LocalTime.forInstant((Object) null, JULIAN);
LocalTime test = new LocalTime(10, 20, 30, 40, JULIAN);
new LocalTime(-1, 20, 30, 40, JULIAN);
new LocalTime(24, 20, 30, 40, JULIAN);
new LocalTime(10, -1, 30, 40, JULIAN);
new LocalTime(10, 60, 30, 40, JULIAN);
new LocalTime(10, 20, -1, 40, JULIAN);
new LocalTime(10, 20, 60, 40, JULIAN);
new LocalTime(10, 20, 30, -1, JULIAN);
new LocalTime(10, 20, 30, 1000, JULIAN);public void testToDateMidnight() {
DateMidnight test = new DateMidnight(TEST_TIME1_UTC);
assertEquals(TEST_TIME1_LONDON, result.getMillis());
assertEquals(LONDON, result.getZone());
DateMidnight test = new DateMidnight(TEST_TIME1_UTC);
assertEquals(ISOChronology.getInstance(), result.getChronology());
DateMidnight test = new DateMidnight(TEST_TIME1_UTC);
assertEquals(ISOChronology.getInstance(), result.getChronology());
DateMidnight test = new DateMidnight(TEST_TIME1_UTC);
assertEquals(ISOChronology.getInstance(), result.getChronology());
DateTime test = new DateTime(TEST_TIME1);
assertEquals(ISOChronology.getInstance(), result.getChronology());
DateTime test = new DateTime(TEST_TIME1);
assertEquals(ISOChronology.getInstance(), result.getChronology());
assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
MutableDateTime test = new MutableDateTime(TEST_TIME1);
assertEquals(test.getChronology(), result.getChronology());
MutableDateTime test = new MutableDateTime(TEST_TIME1);
assertEquals(ISOChronology.getInstance(), result.getChronology());
MutableDateTime test = new MutableDateTime(TEST_TIME1);
assertEquals(ISOChronology.getInstance(), result.getChronology());
MutableDateTime test = new MutableDateTime(TEST_TIME1);
assertEquals(ISOChronology.getInstance(), result.getChronology());return new DateTime(getMillis());
return new DateTime(getMillis(), ISOChronology.getInstance());
return new MutableDateTime(getMillis());
return new MutableDateTime(getMillis(), ISOChronology.getInstance());
assertEquals(ISOChronology.getInstance(), result.getChronology());
assertEquals(ISOChronology.getInstance(), result.getChronology());
assertEquals(ISOChronology.getInstance(), result.getChronology());
assertEquals(ISOChronology.getInstance(), result.getChronology());DateTimeField field = type.getField(getChronology());
if (DATE_DURATION_TYPES.contains(type.getDurationType()) ||
field.getDurationField().getUnitMillis() >= getChronology().days().getUnitMillis()) {
return field.isSupported();
return false;
return new LocalDate(
getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());len = est;case 'h': // hour of day (number, 1..12)
case 'a': // am/pm marker (text)
builder.appendHalfdayOfDayText();
break;
case 'k': // hour of day (1..24)
builder.appendClockhourOfDay(tokenLen);
break;
case 'K': // hour of day (0..11)
builder.appendClockhourOfHalfday(tokenLen);
break;return iGregorianField.getMaximumValue(partial);
return iGregorianField.getMaximumValue(partial, values);
if (getRangeDurationField() != nextField.getDurationField()) {
if (getRangeDurationField() != nextField.getDurationField()) {
if (getRangeDurationField() != nextField.getDurationField()) {
if (getRangeDurationField() != nextField.getDurationField()) {
private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
private void check(YearMonthDay test, int hour, int min, int sec) {
assertEquals(hour, test.getYear());
assertEquals(min, test.getMonthOfYear());
assertEquals(sec, test.getDayOfMonth());public void testConstructor_Object() throws Throwable {
assertEquals(1 + OFFSET, test.getHourOfDay());
assertEquals(1 + OFFSET, test.getHourOfDay());
assertEquals(1 + OFFSET, test.getHourOfDay());
assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));
cal.setTime(new Date(12345678L));
int[] expected = ISOChronology.getInstance().get(tod, 12345678L);
assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));
assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));
int[] expected = CopticChronology.getInstance().get(tod, 12345678L);
int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), CopticChronology.getInstance());long millisLocal = millis - TimeZone.getDefault().getOffset(millis);
return new Date(millisLocal + getZone().getOffsetFromLocal(millisLocal));
long millisLocal = millis - cal.getTimeZone().getOffset(millis);
millis = millisLocal + getZone().getOffsetFromLocal(millisLocal);import org.joda.time.DurationField;
import org.joda.time.DurationFieldType;
import org.joda.time.field.PreciseDurationField;
static final DurationField MONTH_DURATION_FIELD;
static {
MONTH_DURATION_FIELD =  new PreciseDurationField
(DurationFieldType.months(), MILLIS_PER_MONTH);
package org.joda.time.chrono;
import org.joda.time.DateTimeConstants;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DurationField;
import org.joda.time.field.PreciseDurationDateTimeField;
final class BasicFixedMonthOfYearDateTimeField extends PreciseDurationDateTimeField {
private static final long serialVersionUID = 7741038885247700323L;
private final BaseGJChronology iChronology;
private static final int MONTH_LENGTH = 30;
BasicFixedMonthOfYearDateTimeField(BaseGJChronology chronology, DurationField months) {
super(DateTimeFieldType.monthOfYear(), months);
iChronology = chronology;
public int get(long instant) {
return (iChronology.getDayOfYear(instant) - 1) / MONTH_LENGTH + 1;
public long set(long instant, int value) {
instant = super.set(instant, value);
if (value == 13) {
int day = iChronology.getDayOfYear(instant);
if (day < MONTH_LENGTH) {
instant -= (long)DateTimeConstants.MILLIS_PER_DAY * day;
return instant;
public DurationField getRangeDurationField() {
return iChronology.years();
public boolean isLeap(long instant) {
return get(instant) > 12 && iChronology.isLeapYear(iChronology.getYear(instant));
public int getLeapAmount(long instant) {
return isLeap(instant) ? 1 : 0;
public DurationField getLeapDurationField() {
return iChronology.days();
public int getMinimumValue() {
return 1;
public int getMaximumValue() {
return 13;
private Object readResolve() {
return iChronology.monthOfYear();
private static final int MAX = DateTimeConstants.DECEMBER;
yearToUse = thisYear + (monthToUse / MAX);
monthToUse = (monthToUse % MAX) + 1;
yearToUse = thisYear + (monthToUse / MAX) - 1;
int remMonthToUse = monthToUse % MAX;
remMonthToUse = MAX;
monthToUse = MAX - remMonthToUse + 1;
yearToUse = thisYear + (monthToUse / MAX);
monthToUse = (monthToUse % MAX) + 1;
yearToUse = thisYear + (monthToUse / MAX) - 1;
int remMonthToUse = (int)(monthToUse % MAX);
remMonthToUse = MAX;
monthToUse = MAX - remMonthToUse + 1;
return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));
long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;
FieldUtils.verifyValueBounds(this, month, MIN, MAX);
return MAX;
fields.months = MONTH_DURATION_FIELD;
fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);
fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);
fields.months = MONTH_DURATION_FIELD;
fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);
fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);
private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;
(y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;
assertEquals(true, CopticChronology.getInstanceUTC().months().isPrecise());
assertEquals(1720, dt.getYearOfEra());
private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;
(y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;
SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;
assertEquals(true, EthiopicChronology.getInstanceUTC().months().isPrecise());
System.out.println(dt);
assertEquals(1996, dt.getYearOfEra());buf.append(print(instant, displayZone, locale));
out.write(print(instant, displayZone, locale));cal.setTime(toDate());
cal.setTime(toDate());
return ((Calendar) object).getTime().getTime();
return ((Date) object).getTime();private final YearInfo[] iYearInfoCache = new YearInfo[CACHE_SIZE];return ((int) ((millis - getYearMillis(year)) / 30)) + 1;if (bodyContent != null && bodyContent.getString() != null)if (f instanceof DateTimeFormatter) {
if (f instanceof Composite) {
return ((Composite)f).isPrinter()
|| ((Composite)f).isParser();
return true;
return false;return new TimeOfDay(this, newChronology);
return new YearMonthDay(this, newChronology);DateTimeZone test = PARIS;if (c == '-') {private final DateMidnight iInstant;
private final DateTimeField iField;
private final DateTime iInstant;
private final DateTimeField iField;
private final MutableDateTime iInstant;
private final DateTimeField iField;
loadAndCompare(test, "Instant.dat");
inlineCompare(test);
loadAndCompare(test, "DateTime.dat");
inlineCompare(test);
loadAndCompare(test, "MutableDateTime.dat");
inlineCompare(test);
loadAndCompare(test, "DateMidnight.dat");
inlineCompare(test);
loadAndCompare(test, "YearMonthDay.dat");
inlineCompare(test);
loadAndCompare(test, "TimeOfDay.dat");
inlineCompare(test);
loadAndCompare(test, "DateTimeZoneUTC.dat");
inlineCompare(test);
loadAndCompare(test, "DateTimeZone.dat");
inlineCompare(test);
loadAndCompare(test, "CopticChronology.dat");
inlineCompare(test);
loadAndCompare(test, "ISOChronology.dat");
inlineCompare(test);
loadAndCompare(test, "GJChronology.dat");
inlineCompare(test);
private void loadAndCompare(Serializable test, String filename) throws Exception {
assertEquals(test, obj);
public void inlineCompare(Serializable test) throws Exception {
assertEquals(test, obj);String pluralText) {
if (position + length != suffixPos) {private int compareReverse(Comparable a, Comparable b) {
if (a == null) {
if (b == null) {
if (b == null) {builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);
builder.appendTwoDigitYear(new DateTime().getYear() - 30);
return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot));
return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot));
value = Integer.parseInt
(text.substring(position, position += length));
value = text.charAt(i++) - '0';
TwoDigitYear(DateTimeFieldType type, int pivot) {
return 2;
int pivot = iPivot;
if (bucket.getPivotYear() != null) {
pivot = bucket.getPivotYear().intValue();
int limit = Math.min(2, text.length() - position);
if (limit < 2) {
return ~position;DateTime date = new DateTime(
assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));
DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).parse(expect));int calculatePrintedLength(ReadablePeriod period, Locale iLocale);
int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale iLocale);
void printTo(StringBuffer buf, ReadablePeriod period, Locale iLocale);
void printTo(Writer out, ReadablePeriod period, Locale iLocale) throws IOException;fields.year = new OffsetDateTimeField(field, BUDDHIST_OFFSET);
fields.yearOfEra = new OffsetDateTimeField(
fields.year, DateTimeFieldType.yearOfEra(), BUDDHIST_OFFSET);
fields.weekyear = new OffsetDateTimeField(field, BUDDHIST_OFFSET);
protected DelegatedDateTimeField(DateTimeField field) {
protected DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {if (value == 0) {int index = indexOfSupported(fieldType);
int index = indexOfSupported(fieldType);assertEquals(" 10", test.toString("yyyy HH"));
assertEquals("2002 ", test.toString("yyyy HH"));
assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));
assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));
assertEquals("Sun 9/6", test.toString("EEE d/M", null));int offset = -(int) offsetFormatter().parseMillis(id, ISOChronology.getInstance(UTC));
id = printTimeZone(offset);
String id = printTimeZone(offset);
int offset = -(int) offsetFormatter().parseMillis
(convId, ISOChronology.getInstance(UTC));
convId = printTimeZone(offset);
private static synchronized DateTimeFormatter offsetFormatter() {
if (cOffsetFormatter == null) {
cOffsetFormatter = new DateTimeFormatterBuilder()
.appendTimeZoneOffset(null, true, 2, 4)
.toFormatter();
return cOffsetFormatter;
private static String printTimeZone(int offset) {
return printTimeZone(getOffset(instant));
return printTimeZone(getOffset(instant));int offset = -(int) offsetFormatter().parseMillis(id);
int offset = -(int) offsetFormatter().parseMillis(convId);.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
.appendSeparator(", ", " and ")
return appendSeparator(text, text, true, true);
return appendSeparator(text, text, false, true);
return appendSeparator(text, text, true, false);
return appendSeparator(text, finalText, true, true);
private PeriodFormatterBuilder appendSeparator(String text, String finalText, boolean useBefore, boolean useAfter) {
formatters.add(new Separator(text, finalText, Literal.EMPTY, useBefore, useAfter));
formatters.add(new Separator(text, finalText, composite, useBefore, useAfter));
Separator(String text, String finalText, BasePeriodFormatter before, boolean useBefore, boolean useAfter) {
final int oldPos = position;
position = iBefore.parseInto(period, periodStr, position);
if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {
position += iText.length();
(true, position, iFinalText, 0, iFinalText.length())) {
position += iFinalText.length();if (iFieldType >= 8) {
if (iFieldType >= 8) {
if (iFieldType >= 8) {
if (iFieldType >= 8) {
if (iFieldType >= 8) {
boolean negative = false;
int dp = -1;
negative = (c == '-');
if (negative) {
if (c < '0' || c > '9') {
if (c == '.' && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {
if (dp >= 0) {
return position + length;
dp = length;
if (length == 0 || (length == 1 && dp == 0) || (dp == -1 && iFieldType == SECONDS_MILLIS)) {
if (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS) {
if (dp == -1) {
position = parseField(period, text, position, negative, length, SECONDS);
setFieldValue(period, MILLIS, 0);
if (dp > 0) {
position = parseField(period, text, position, negative, dp, SECONDS);
setFieldValue(period, SECONDS, 0);
position++; // skip dp
int millisLength = length - 1 - dp;
if (millisLength > 3) {
position = parseField(period, text, position, false, 3, MILLIS);
position += (millisLength - 3);
setFieldValue(period, MILLIS, 0);
position = parseField(period, text, position, false, millisLength, MILLIS);
position = parseField(period, text, position, negative, length, iFieldType);
private int parseField(
ReadWritablePeriod period, String text, int position,
boolean negative, int length, int type) {
int value;
if (length >= 9) {
value = Integer.parseInt
(text.substring(position, position += length));
int i = position;
if (negative) {
i++;
value = text.charAt(i++) - '0';
position += length;
while (i < position) {
value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';
if (negative) {
value = -value;
setFieldValue(period, type, value);
return position;
int value;
value = seconds * DateTimeConstants.MILLIS_PER_SECOND + millis;return isAfterNow();
return isAfter(interval.getEndMillis());
assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));
assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));if (field.getWrappedField() == wrappedField) {case ERAS:
return chronology.eras();
case CENTURIES:
return chronology.centuries();
case WEEKYEARS:
return chronology.weekyears();
case YEARS:
return chronology.years();
case MONTHS:
return chronology.months();
case WEEKS:
return chronology.weeks();
case DAYS:
return chronology.days();
case HALFDAYS:
return chronology.halfdays();
case HOURS:
return chronology.hours();
case MINUTES:
return chronology.minutes();
case SECONDS:
return chronology.seconds();
case MILLIS:
return chronology.millis();
default:
throw new InternalError();
case ERAS:
return ERAS_TYPE;
case CENTURIES:
return CENTURIES_TYPE;
case WEEKYEARS:
return WEEKYEARS_TYPE;
case YEARS:
return YEARS_TYPE;
case MONTHS:
return MONTHS_TYPE;
case WEEKS:
return WEEKS_TYPE;
case DAYS:
return DAYS_TYPE;
case HALFDAYS:
return HALFDAYS_TYPE;
case HOURS:
return HOURS_TYPE;
case MINUTES:
return MINUTES_TYPE;
case SECONDS:
return SECONDS_TYPE;
case MILLIS:
return MILLIS_TYPE;
default:
return this;
case ROUND_NONE:
break;
case ROUND_FLOOR:
instant = iRoundingField.roundFloor(instant);
break;
case ROUND_CEILING:
instant = iRoundingField.roundCeiling(instant);
break;
case ROUND_HALF_FLOOR:
instant = iRoundingField.roundHalfFloor(instant);
break;
case ROUND_HALF_CEILING:
instant = iRoundingField.roundHalfCeiling(instant);
break;
case ROUND_HALF_EVEN:
instant = iRoundingField.roundHalfEven(instant);
break;
return (MutableDateTime)clone();
return (MutablePeriod)clone();public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)
throws IllegalArgumentException;
int secondOfMinute, int millisOfSecond)
throws IllegalArgumentException;
int secondOfMinute, int millisOfSecond)
throws IllegalArgumentException;
private transient final DurationFieldType iUnitType;
private transient final DurationFieldType iRangeType;
case ERA:
return chronology.era();
case YEAR_OF_ERA:
return chronology.yearOfEra();
case CENTURY_OF_ERA:
return chronology.centuryOfEra();
case YEAR_OF_CENTURY:
return chronology.yearOfCentury();
case YEAR:
return chronology.year();
case DAY_OF_YEAR:
return chronology.dayOfYear();
case MONTH_OF_YEAR:
return chronology.monthOfYear();
case DAY_OF_MONTH:
return chronology.dayOfMonth();
case WEEKYEAR_OF_CENTURY:
return chronology.weekyearOfCentury();
case WEEKYEAR:
return chronology.weekyear();
case WEEK_OF_WEEKYEAR:
return chronology.weekOfWeekyear();
case DAY_OF_WEEK:
return chronology.dayOfWeek();
case HALFDAY_OF_DAY:
return chronology.halfdayOfDay();
case HOUR_OF_HALFDAY:
return chronology.hourOfHalfday();
case CLOCKHOUR_OF_HALFDAY:
return chronology.clockhourOfHalfday();
case CLOCKHOUR_OF_DAY:
return chronology.clockhourOfDay();
case HOUR_OF_DAY:
return chronology.hourOfDay();
case MINUTE_OF_DAY:
return chronology.minuteOfDay();
case MINUTE_OF_HOUR:
return chronology.minuteOfHour();
case SECOND_OF_DAY:
return chronology.secondOfDay();
case SECOND_OF_MINUTE:
return chronology.secondOfMinute();
case MILLIS_OF_DAY:
return chronology.millisOfDay();
case MILLIS_OF_SECOND:
return chronology.millisOfSecond();
default:
throw new InternalError();
case ERA:
return ERA_TYPE;
case YEAR_OF_ERA:
return YEAR_OF_ERA_TYPE;
case CENTURY_OF_ERA:
return CENTURY_OF_ERA_TYPE;
case YEAR_OF_CENTURY:
return YEAR_OF_CENTURY_TYPE;
case YEAR:
return YEAR_TYPE;
case DAY_OF_YEAR:
return DAY_OF_YEAR_TYPE;
case MONTH_OF_YEAR:
return MONTH_OF_YEAR_TYPE;
case DAY_OF_MONTH:
return DAY_OF_MONTH_TYPE;
case WEEKYEAR_OF_CENTURY:
return WEEKYEAR_OF_CENTURY_TYPE;
case WEEKYEAR:
return WEEKYEAR_TYPE;
case WEEK_OF_WEEKYEAR:
return WEEK_OF_WEEKYEAR_TYPE;
case DAY_OF_WEEK:
return DAY_OF_WEEK_TYPE;
case HALFDAY_OF_DAY:
return HALFDAY_OF_DAY_TYPE;
case HOUR_OF_HALFDAY:
return HOUR_OF_HALFDAY_TYPE;
case CLOCKHOUR_OF_HALFDAY:
return CLOCKHOUR_OF_HALFDAY_TYPE;
case CLOCKHOUR_OF_DAY:
return CLOCKHOUR_OF_DAY_TYPE;
case HOUR_OF_DAY:
return HOUR_OF_DAY_TYPE;
case MINUTE_OF_DAY:
return MINUTE_OF_DAY_TYPE;
case MINUTE_OF_HOUR:
return MINUTE_OF_HOUR_TYPE;
case SECOND_OF_DAY:
return SECOND_OF_DAY_TYPE;
case SECOND_OF_MINUTE:
return SECOND_OF_MINUTE_TYPE;
case MILLIS_OF_DAY:
return MILLIS_OF_DAY_TYPE;
case MILLIS_OF_SECOND:
return MILLIS_OF_SECOND_TYPE;
default:
return this;
static abstract class MillisProvider {
int offset = -(int)offsetFormatter().parseMillis(convId);
provider = (Provider)Class.forName(providerClass).newInstance();
catch (Exception ex) {
offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
protected Object readResolve() throws ObjectStreamException {public DateMidnight minus(ReadableDuration durationToAdd) {
return withDurationAdded(durationToAdd, -1);
public DateTime minus(ReadableDuration durationToAdd) {
return withDurationAdded(durationToAdd, -1);
public Instant minus(ReadableDuration durationToAdd) {
return withDurationAdded(durationToAdd, -1);
public Period withFieldAdded(DurationFieldType field, int valueToAdd) {
if (valueToAdd == 0) {
super.addFieldInto(newValues, field, valueToAdd);assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());
assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());
assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());
assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());
assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());
assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());
assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());
assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());
assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());public long add(long instant, int amount) {
return instant + amount * iUnitMillis;
public long add(long instant, long amount) {
return instant + amount * iUnitMillis;
public int getDifference(long minuendInstant, long subtrahendInstant) {
return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
return (minuendInstant - subtrahendInstant) / iUnitMillis;
if (instant >= 0) {bwdt; // basic week date time
if (t == null) {
t = new DateTimeFormatterBuilder(iChrono)
.appendLiteral('T')
return t;
.appendLiteral('T')
.append(time())
.appendTimeZoneOffset("", false, 1, 2)
if (bt == null) {
bt = new DateTimeFormatterBuilder(iChrono)
.appendLiteral('T')
return bt;
.appendLiteral('T')
.append(basicTime())
.appendLiteral('T')
.appendLiteral('T')
.appendLiteral('T')
.appendLiteral('T')
.appendLiteral('T')public static final Interval ALWAYS = new Interval(Long.MIN_VALUE, Long.MAX_VALUE);
return new Interval(startInstant, getEndMillis());
return new Interval(getStartMillis(), endInstant);
long endMillis = getChronology().add(startMillis, durationMillis, 1);
return new Interval(startMillis, endMillis);
long startMillis = getChronology().add(endMillis, durationMillis, -1);
return new Interval(startMillis, endMillis);
return this;
long endMillis = getChronology().add(period, startMillis, 1);
return new Interval(startMillis, endMillis);
return this;
long startMillis = getChronology().add(period, endMillis, -1);
return new Interval(startMillis, endMillis);
return new Interval(getStartMillis(), getEndMillis());
return new MutableInterval(getStartMillis(), getEndMillis());
return new Period(getStartMillis(), getEndMillis());
return new Period(getStartMillis(), getEndMillis(), type);
Interval test4 = new Interval(TEST_TIME1, TEST_TIME1, Chronology.getGJ());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);
Interval test = new Interval(dt1, dt2);
Period result = test.toPeriod();
assertEquals(PeriodType.standard(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(2, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(4, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);
Interval test = new Interval(dt1, dt2);
Period result = test.toPeriod(null);
assertEquals(PeriodType.standard(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(2, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(4, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
Interval test = new Interval(dt1, dt2);
Period result = test.toPeriod(PeriodType.yearWeekDayTime());
assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(0, result.getMonths());
assertEquals(9, result.getWeeks());
assertEquals(2, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
public void testToPeriod_PeriodType3() {
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);
Interval test = new Interval(dt1, dt2);
Period result = test.toPeriod(PeriodType.yearWeekDayTime());
assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(0, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(0, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
public void testAlways() {
Interval test = Interval.ALWAYS;
assertEquals(Long.MIN_VALUE, test.getStartMillis());
assertEquals(Long.MAX_VALUE, test.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withStartMillis(TEST_TIME1 - 1);
assertEquals(TEST_TIME1 - 1, result.getStartMillis());
assertEquals(TEST_TIME2, result.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withStartMillis(TEST_TIME1);
assertSame(test, result);
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withStart(new Instant(TEST_TIME1 - 1));
assertEquals(TEST_TIME1 - 1, result.getStartMillis());
assertEquals(TEST_TIME2, result.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withStart(null);
assertEquals(TEST_TIME_NOW, result.getStartMillis());
assertEquals(TEST_TIME2, result.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withEndMillis(TEST_TIME2 - 1);
assertEquals(TEST_TIME1, result.getStartMillis());
assertEquals(TEST_TIME2 - 1, result.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withEndMillis(TEST_TIME2);
assertSame(test, result);
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withEnd(new Instant(TEST_TIME2 - 1));
assertEquals(TEST_TIME1, result.getStartMillis());
assertEquals(TEST_TIME2 - 1, result.getEndMillis());
Interval test = new Interval(TEST_TIME1, TEST_TIME2);
Interval result = test.withEnd(null);
assertEquals(TEST_TIME1, result.getStartMillis());
assertEquals(TEST_TIME_NOW, result.getEndMillis());
MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2);
assertEquals(true, test1.equals(test4));
assertEquals(true, test2.equals(test4));
assertEquals(false, test3.equals(test4));
assertEquals(true, test4.equals(test1));
assertEquals(true, test4.equals(test2));
assertEquals(false, test4.equals(test3));
assertEquals(true, test1.hashCode() == test4.hashCode());
assertEquals(true, test2.hashCode() == test4.hashCode());
assertEquals(false, test3.hashCode() == test4.hashCode());
MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);
MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);
MutableInterval test = new MutableInterval(dt1, dt2);
Period result = test.toPeriod();
assertEquals(PeriodType.standard(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(2, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(4, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);
MutableInterval test = new MutableInterval(dt1, dt2);
Period result = test.toPeriod(null);
assertEquals(PeriodType.standard(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(2, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(4, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
MutableInterval test = new MutableInterval(dt1, dt2);
Period result = test.toPeriod(PeriodType.yearWeekDayTime());
assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(0, result.getMonths());
assertEquals(9, result.getWeeks());
assertEquals(2, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
public void testToPeriod_PeriodType3() {
DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);
DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);
MutableInterval test = new MutableInterval(dt1, dt2);
Period result = test.toPeriod(PeriodType.yearWeekDayTime());
assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());
assertEquals(1, result.getYears());
assertEquals(0, result.getMonths());
assertEquals(0, result.getWeeks());
assertEquals(0, result.getDays());
assertEquals(5, result.getHours());
assertEquals(6, result.getMinutes());
assertEquals(7, result.getSeconds());
assertEquals(8, result.getMillis());
MutableInterval test = new MutableInterval(123L, 456L);
MutableInterval test = new MutableInterval(123L, 456L);Interval i = new Interval(0L, 123L);
MutableInterval m = new MutableInterval(-1000L, 1000L, Chronology.getCoptic());
Interval i = new Interval(0L, 123L);
MutableInterval m = new MutableInterval(-1000L, 1000L);Duration test = new Duration("P72.345S");private static final int PRINT_ZERO_RARELY = 1;
private static final int PRINT_ZERO_IF_SUPPORTED = 2;
private static final int PRINT_ZERO_ALWAYS = 3;
private boolean iFavorFirstFieldForZero;
private List iAlternateFormatters;
List altFormatters = iAlternateFormatters;
if (altFormatters.size() > 0) {
for (int i=altFormatters.size(); --i>=0; ) {
if (altFormatters.get(i) instanceof FieldFormatter) {
formatter = new AlternateSelector
(formatter, altFormatters, iFavorFirstFieldForZero);
break;
iFavorFirstFieldForZero = false;
iPrintZeroSetting = PRINT_ZERO_RARELY;
if (iAlternateFormatters == null) {
iAlternateFormatters = new ArrayList();
iAlternateFormatters.clear();
iAlternateFormatters.add(literal);
public PeriodFormatterBuilder printZeroRarely() {
iPrintZeroSetting = PRINT_ZERO_RARELY;
appendField(1);
appendField(2);
appendField(3);
appendField(4);
appendField(5);
appendField(6);
appendField(7);
appendField(9);
appendField(10);
appendField(8);
appendField(8, 3);
iMaxParsedDigits, iRejectSignedValues, type, iPrefix, null);
if (iPrintZeroSetting == PRINT_ZERO_RARELY) {
iAlternateFormatters.add(field);
Object newField = new FieldFormatter((FieldFormatter) originalField, suffix);
int index = iAlternateFormatters.lastIndexOf(originalField);
if (index >= 0) {
iAlternateFormatters.set(index, newField);
public PeriodFormatterBuilder favorLastFieldForZero() {
iFavorFirstFieldForZero = false;
return this;
public PeriodFormatterBuilder favorFirstFieldForZero() {
iFavorFirstFieldForZero = true;
return this;
int fieldType, PeriodFieldAffix prefix, PeriodFieldAffix suffix) {
FieldFormatter(FieldFormatter field, int printZeroSetting) {
iMinPrintedDigits = field.iMinPrintedDigits;
iPrintZeroSetting = printZeroSetting;
iMaxParsedDigits = field.iMaxParsedDigits;
iRejectSignedValues = field.iRejectSignedValues;
iFieldType = field.iFieldType;
iPrefix = field.iPrefix;
iSuffix = field.iSuffix;
if (iFieldType >= 9) {
if (iFieldType == 10 && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {
PeriodFieldAffix affix;
if ((affix = iPrefix) != null) {
sum += affix.calculatePrintedLength(value);
if ((affix = iSuffix) != null) {
sum += affix.calculatePrintedLength(value);
if (iFieldType >= 9) {
PeriodFieldAffix affix;
if ((affix = iPrefix) != null) {
affix.printTo(buf, value);
if (iFieldType >= 9) {
if (iFieldType == 9 || dp > 0) {
if ((affix = iSuffix) != null) {
affix.printTo(buf, value);
if (iFieldType >= 9) {
PeriodFieldAffix affix;
if ((affix = iPrefix) != null) {
affix.printTo(out, value);
if (iFieldType >= 9) {
if (iFieldType == 9 || dp > 0) {
if ((affix = iSuffix) != null) {
affix.printTo(out, value);
if (!mustParse && !isSupported(period.getPeriodType())) {
setFieldValue(period, value);
case 1:
if (type != null && type.years().isSupported() == false) {
return Long.MAX_VALUE;
case 2:
if (type != null && type.months().isSupported() == false) {
return Long.MAX_VALUE;
case 3:
if (type != null && type.weeks().isSupported() == false) {
return Long.MAX_VALUE;
case 4:
if (type != null && type.days().isSupported() == false) {
return Long.MAX_VALUE;
case 5:
if (type != null && type.hours().isSupported() == false) {
return Long.MAX_VALUE;
case 6:
if (type != null && type.minutes().isSupported() == false) {
return Long.MAX_VALUE;
case 7:
if (type != null && type.seconds().isSupported() == false) {
return Long.MAX_VALUE;
case 8:
if (type != null && type.millis().isSupported() == false) {
return Long.MAX_VALUE;
case 9: // drop through
case 10:
if (type != null && type.seconds().isSupported() == false && type.millis().isSupported() == false) {
return Long.MAX_VALUE;
if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {
return Long.MAX_VALUE;
boolean isSupported(PeriodType type) {
switch (iFieldType) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9: // drop through
case 10:
void setFieldValue(ReadWritablePeriod period, int value) {
switch (iFieldType) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
int getPrintZeroSetting() {
return iPrintZeroSetting;
private static final class AlternateSelector extends AbstractPeriodFormatter
implements PeriodFormatter
private final PeriodFormatter iPrimaryFormatter;
private final PeriodPrinter[] iAlternatePrinters;
private final boolean iFavorFirstFieldForZero;
AlternateSelector(PeriodFormatter primaryFormatter,
List alternatePrinters,
boolean favorFirstFieldForZero) {
iPrimaryFormatter = primaryFormatter;
iAlternatePrinters = (PeriodPrinter[])alternatePrinters.toArray
(new PeriodPrinter[alternatePrinters.size()]);
iFavorFirstFieldForZero = favorFirstFieldForZero;
public int countFieldsToPrint(ReadablePeriod period, int stopAt) {
int count = iPrimaryFormatter.countFieldsToPrint(period, stopAt);
if (count < 1 && stopAt >= 1) {
if (chooseFieldToPrint(period) != null) {
return 1;
return count;
public int calculatePrintedLength(ReadablePeriod period) {
if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {
return iPrimaryFormatter.calculatePrintedLength(period);
Object chosenOne = chooseFieldToPrint(period);
int sum = 0;
PeriodPrinter[] printers = iAlternatePrinters;
for (int i=printers.length; --i>=0; ) {
PeriodPrinter dp = printers[i];
if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
sum += dp.calculatePrintedLength(period);
return sum;
public void printTo(StringBuffer buf, ReadablePeriod period) {
if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {
iPrimaryFormatter.printTo(buf, period);
return;
Object chosenOne = chooseFieldToPrint(period);
PeriodPrinter[] printers = iAlternatePrinters;
int len = printers.length;
for (int i=0; i<len; i++) {
PeriodPrinter dp = printers[i];
if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
dp.printTo(buf, period);
public void printTo(Writer out, ReadablePeriod period) throws IOException {
if (iPrimaryFormatter.countFieldsToPrint(period, 1) > 0) {
iPrimaryFormatter.printTo(out, period);
return;
Object chosenOne = chooseFieldToPrint(period);
PeriodPrinter[] printers = iAlternatePrinters;
int len = printers.length;
for (int i=0; i<len; i++) {
PeriodPrinter dp = printers[i];
if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
dp.printTo(out, period);
public int parseInto(ReadWritablePeriod period,
String periodStr, int position) {
return iPrimaryFormatter.parseInto(period, periodStr, position);
private FieldFormatter chooseFieldToPrint(ReadablePeriod period) {
PeriodType type = period.getPeriodType();
PeriodPrinter[] printers = iAlternatePrinters;
if (iFavorFirstFieldForZero) {
int len = printers.length;
for (int i=0; i<len; i++) {
PeriodPrinter dp = printers[i];
if (dp instanceof FieldFormatter) {
FieldFormatter ff = (FieldFormatter) dp;
if (ff.isSupported(type)) {
if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {
ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);
printers[i] = ff;
return ff;
for (int i=printers.length; --i>=0; ) {
PeriodPrinter dp = printers[i];
if (dp instanceof FieldFormatter) {
FieldFormatter ff = (FieldFormatter) dp;
if (ff.isSupported(type)) {
if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {
ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);
printers[i] = ff;
return ff;
return null;
public void testFormatPrintZeroRarely() {
.printZeroRarely()
public void testFormatPrintZeroRarelyFavorFirst() {
.printZeroRarely().favorFirstFieldForZero()
public void testFormatPrintZeroRarelyFavorLast() {
PeriodFormatter f =
new PeriodFormatterBuilder()
.printZeroRarely().favorLastFieldForZero()
.appendYears().appendLiteral("-")
.appendMonths().appendLiteral("-")
.appendWeeks().appendLiteral("-")
.appendDays().toFormatter();
assertEquals("1-2-3-4", f.print(PERIOD));
assertEquals(7, f.calculatePrintedLength(PERIOD));
assertEquals(4, f.countFieldsToPrint(PERIOD));
assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD));
assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));
assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));
assertEquals("1---4", f.print(YEAR_DAY_PERIOD));
assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));
assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));
assertEquals("---0", f.print(EMPTY_PERIOD));
assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));
assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + 1).isEqual(null));
assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC).isEqual(null));
assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - 1).isEqual(null));
assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + 1).isBefore(null));
assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC).isBefore(null));
assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC - 1).isBefore(null));
assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC + 1).isAfter(null));
assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC).isAfter(null));
assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - 1).isAfter(null));return new Instant(addTo(instantMillis, scalar, instant.getChronology()));
setStartMillis(FieldUtils.safeAdd(getStartMillis(), -durationMillis));writableInterval.setStartMillis(interval.getStartMillis());
writableInterval.setEndMillis(interval.getEndMillis());
writableInterval.setStartMillis(startInstant);
writableInterval.setEndMillis(endInstant);return parseMillis(text, 0);
millis = savedFields[i].set(millis);
long set(long millis) {
return iField.set(millis, iValue);
return iField.set(millis, iText, iLocale);c = ConverterManager.getInstance().getDurationConverter(new Period(PeriodType.getMillisType()));
assertEquals(ReadableDuration.class, c.getSupportedType());
PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(PeriodType.getMillisType()));
assertEquals(3, m.getDays());
assertEquals(0, m.getHours());public abstract class AbstractDuration implements ReadableDuration {
return new Period(this, PeriodType.getAllType());
return new Period(this, type);
private Duration iDuration;
public Duration withMillis(long length) {
if (length == getMillis()) {
return new Duration(length);
import org.joda.time.chrono.ISOChronology;
public void testGetPeriodType() {
TimePeriod test = new TimePeriod(0L);
assertEquals(PeriodType.getAllType(), test.getPeriodType());
public void testGetIsPrecise() {
TimePeriod test = new TimePeriod(123L);
assertEquals(true, test.isPrecise());
test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(false, test.isPrecise());
public void testGetMethods() {
TimePeriod test = new TimePeriod(0L);
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
TimePeriod test1 = new TimePeriod(123L);
TimePeriod test2 = new TimePeriod(123L);
TimePeriod test3 = new TimePeriod(321L);
assertEquals(false, test1.equals(new TimePeriod(123L, PeriodType.getDayHourType())));
class MockDuration extends AbstractPeriod {
super(value, null);
protected PeriodType checkPeriodType(PeriodType type) {
return PeriodType.getAllType();
TimePeriod test1 = new TimePeriod(123L);
TimePeriod test1a = new TimePeriod(123L);
TimePeriod test2 = new TimePeriod(321L);
TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());
assertEquals(-1, test1.compareTo(test3));
assertEquals(+1, test3.compareTo(test1));
assertEquals(0, test3.compareTo(test2));
try {
test1.compareTo(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));
fail();
TimePeriod test1 = new TimePeriod(123L);
TimePeriod test1a = new TimePeriod(123L);
TimePeriod test2 = new TimePeriod(321L);
TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());
assertEquals(false, test1.isEqual(test3));
assertEquals(false, test3.isEqual(test1));
assertEquals(true, test3.isEqual(test2));
assertEquals(true, new TimePeriod(0L).isEqual(null));
TimePeriod test1 = new TimePeriod(123L);
TimePeriod test1a = new TimePeriod(123L);
TimePeriod test2 = new TimePeriod(321L);
TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());
assertEquals(true, test1.isShorterThan(test3));
assertEquals(false, test3.isShorterThan(test1));
assertEquals(false, test3.isShorterThan(test2));
assertEquals(false, new TimePeriod(0L).isShorterThan(null));
TimePeriod test1 = new TimePeriod(123L);
TimePeriod test1a = new TimePeriod(123L);
TimePeriod test2 = new TimePeriod(321L);
TimePeriod test3 = new TimePeriod(321L, PeriodType.getAllType());
assertEquals(false, test1.isLongerThan(test3));
assertEquals(true, test3.isLongerThan(test1));
assertEquals(false, test3.isLongerThan(test2));
assertEquals(false, new TimePeriod(0L).isLongerThan(null));
TimePeriod test = new TimePeriod(123L);
TimePeriod result = (TimePeriod) ois.readObject();
public void testAddTo1() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
long added = test.addTo(TEST_TIME_NOW, 1);
assertEquals(expected, added);
public void testAddTo2() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
long added = test.addTo(TEST_TIME_NOW, -2);
assertEquals(expected, added);
public void testAddTo3() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstanceUTC().years().add(expected, -2);
expected = ISOChronology.getInstanceUTC().months().add(expected, -4);
expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);
expected = ISOChronology.getInstanceUTC().days().add(expected, -8);
expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);
expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);
expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);
expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
long added = test.addTo(TEST_TIME_NOW, -2);
assertEquals(expected, added);
public void testAddTo4() {
long expected = TEST_TIME_NOW;
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
long added = test.addTo(TEST_TIME_NOW, 0);
assertEquals(expected, added);
public void testAddTo5() {
long expected = TEST_TIME_NOW + 100L;
TimePeriod test = new TimePeriod(100L);
long added = test.addTo(TEST_TIME_NOW, 1);
assertEquals(expected, added);
public void testAddToWithChronology1() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());
assertEquals(expected, added);
public void testAddToWithChronology2() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it
assertEquals(expected, added);
public void testAddToWithChronology3() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstanceUTC().years().add(expected, -2);
expected = ISOChronology.getInstanceUTC().months().add(expected, -4);
expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);
expected = ISOChronology.getInstanceUTC().days().add(expected, -8);
expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);
expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);
expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);
expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)
assertEquals(expected, added);
public void testAddToRI1() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
Instant added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)
assertEquals(expected, added.getMillis());
public void testAddToRI2() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstanceUTC().years().add(expected, -2);
expected = ISOChronology.getInstanceUTC().months().add(expected, -4);
expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);
expected = ISOChronology.getInstanceUTC().days().add(expected, -8);
expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);
expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);
expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);
expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
Instant added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)
assertEquals(expected, added.getMillis());
public void testAddToRI3() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
Instant added = test.addTo(new DateTime(), -2);  // DateTime has local time zone
assertEquals(expected, added.getMillis());
public void testAddToRI4() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstanceUTC().years().add(expected, -2);
expected = ISOChronology.getInstanceUTC().months().add(expected, -4);
expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);
expected = ISOChronology.getInstanceUTC().days().add(expected, -8);
expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);
expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);
expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);
expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
Instant added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)
assertEquals(expected, added.getMillis());
public void testAddIntoRWI1() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
MutableDateTime mdt = new MutableDateTime();
test.addInto(mdt, 1);
assertEquals(expected, mdt.getMillis());
public void testAddIntoRWI2() {
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));
MutableDateTime mdt = new MutableDateTime();
test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it
assertEquals(expected, mdt.getMillis());
public void testAddIntoRWI3() {
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
try {
test.addInto(null, 1);
fail();
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
test = new TimePeriod(0, 0, 0, 0, 0, 0, 0, 0);
test = new TimePeriod(12345L);
public void testToTimePeriod() {
TimePeriod test = new TimePeriod(123L);
TimePeriod result = test.toTimePeriod();
public void testToMutableTimePeriod() {
TimePeriod test = new TimePeriod(123L);
MutablePeriod result = test.toMutableTimePeriod();
assertEquals(test, result);
public void testToDurationMillis() {
TimePeriod test = new TimePeriod(123L);
assertEquals(123L, test.toDurationMillis());
public void testWithPeriodTypeUsingTotalMillis1() {
TimePeriod test = new TimePeriod(123L);
TimePeriod result = test.withPeriodTypeUsingTotalMillis(PeriodType.getAllType());
assertSame(test, result);
public void testWithPeriodTypeUsingTotalMillis2() {
TimePeriod test = new TimePeriod(3123L);
TimePeriod result = test.withPeriodTypeUsingTotalMillis(PeriodType.getDayHourType());
assertEquals(3, result.getSeconds());
assertEquals(123, result.getMillis());
assertEquals(3123L, result.getTotalMillis());
assertEquals(PeriodType.getDayHourType(), result.getPeriodType());
public void testWithPeriodTypeUsingTotalMillis3() {
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());
try {
test.withPeriodTypeUsingTotalMillis(PeriodType.getDayHourType());
fail();
public void testWithPeriodTypeUsingTotalMillis4() {
TimePeriod test = new TimePeriod(3123L);
TimePeriod result = test.withPeriodTypeUsingTotalMillis(null);
assertEquals(3, result.getSeconds());
assertEquals(123, result.getMillis());
assertEquals(3123L, result.getTotalMillis());
public void testWithPeriodTypeUsingFields1() {
TimePeriod test = new TimePeriod(123L);
TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getAllType());
assertSame(test, result);
public void testWithPeriodTypeUsingFields2() {
TimePeriod test = new TimePeriod(3123L);
TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getDayHourType());
assertEquals(3, result.getSeconds());
assertEquals(123, result.getMillis());
assertEquals(3123L, result.getTotalMillis());
assertEquals(PeriodType.getDayHourType(), result.getPeriodType());
public void testWithPeriodTypeUsingFields3() {
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());
try {
test.withPeriodTypeUsingFields(PeriodType.getDayHourType());
fail();
public void testWithPeriodTypeUsingFields4() {
TimePeriod test = new TimePeriod(3123L);
TimePeriod result = test.withPeriodTypeUsingFields(null);
assertEquals(3, result.getSeconds());
assertEquals(123, result.getMillis());
assertEquals(3123L, result.getTotalMillis());
public void testWithPeriodTypeUsingFields5() {
TimePeriod test = new TimePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());
TimePeriod result = test.withPeriodTypeUsingFields(PeriodType.getYearMonthType());
assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());
assertEquals(0, result.getWeeks());
public void testWithFieldsNormalized1() {
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());
TimePeriod result = test.withFieldsNormalized();
assertEquals(1, result.getYears());
assertEquals(2, result.getMonths());
assertEquals(3, result.getWeeks());
assertEquals(4, result.getDays());
assertEquals(5, result.getHours());
assertEquals(7, result.getMinutes());
assertEquals(1, result.getSeconds());
assertEquals(8, result.getMillis());
public void testWithFieldsNormalized2() {
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());
try {
test.withFieldsNormalized();
fail();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetDuration_ints();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetTotalMillis_1();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetTotalMillis_2();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetYears();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetMonths();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetWeeks();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetDays();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetHours();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetMinutes();
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testSetSeconds();
assertEquals(111L, test.getTotalMillis());
assertEquals(111L, test.getTotalMillis());
test = new MockChangeDuration(111L);
test.testNormalize();
assertEquals(111L, test.getTotalMillis());
static class MockChangeDuration extends TimePeriod {
public void testSetDuration_ints() {
setDuration(1, 2, 3, 4, 5, 6, 7, 8);
public void testSetTotalMillis_1() {
setTotalMillis(123L);
public void testSetTotalMillis_2() {
setTotalMillis(123L, 321L);
public void testSetYears() {
setYears(1);
public void testSetMonths() {
setMonths(1);
public void testSetWeeks() {
setWeeks(1);
public void testSetDays() {
setDays(1);
public void testSetHours() {
setHours(1);
public void testSetMinutes() {
setMinutes(1);
public void testSetSeconds() {
setSeconds(1);
setMillis(1);
public void testNormalize() {
super.normalize();
MillisDuration test = MillisDuration.ZERO;
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(true, test.isPrecise());
assertEquals(0, test.getTotalMillis());
MillisDuration test = new MillisDuration(length);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(length, test.getTotalMillis());
public void testConstructor_long_PeriodType1() throws Throwable {
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR +
6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8;
MillisDuration test = new MillisDuration(length, null);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(length, test.getTotalMillis());
public void testConstructor_long_PeriodType2() throws Throwable {
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR +
6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8;
MillisDuration test = new MillisDuration(length, PeriodType.getMillisType());
assertEquals(PeriodType.getMillisType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(true, test.isPrecise());
assertEquals(length, test.getTotalMillis());
public void testConstructor_long_PeriodType3() throws Throwable {
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR +
6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8;
MillisDuration test = new MillisDuration(length, PeriodType.getPreciseDayHourType());
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(length, test.getTotalMillis());
public void testConstructor_long_PeriodType4() throws Throwable {
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR +
6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8;
MillisDuration test = new MillisDuration(length, PeriodType.getPreciseAllType().withMillisRemoved());
assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(length - 8, test.getTotalMillis());
public void testConstructor_4int1() throws Throwable {
MillisDuration test = new MillisDuration(5, 6, 7, 8);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
public void testConstructor_8int1() throws Throwable {
MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(2, test.getMonths());
assertEquals(3, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
public void testConstructor_8int__PeriodType1() throws Throwable {
MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, null);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(2, test.getMonths());
assertEquals(3, test.getWeeks());
assertEquals(4, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
public void testConstructor_8int__PeriodType2() throws Throwable {
MillisDuration test = new MillisDuration(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getPreciseDayHourType());
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(5, test.getHours());
assertEquals(6, test.getMinutes());
assertEquals(7, test.getSeconds());
assertEquals(8, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
public void testConstructor_8int__PeriodType3() throws Throwable {
try {
new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());
fail();
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_long_long2() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_long_long_PeriodType1() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), null);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_long_long_PeriodType2() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), PeriodType.getPreciseDayHourType());
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(31, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_long_long_PeriodType3() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), PeriodType.getPreciseAllType().withMillisRemoved());
assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
DateTime dt1 = null;  // 2002-06-09T01:00+01:00
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(3, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(0, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
public void testConstructor_RI_RI4() throws Throwable {
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(-3, test.getYears());
assertEquals(-1, test.getMonths());
assertEquals(-1, test.getWeeks());
assertEquals(-2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(0, test.getHours());
assertEquals(-1, test.getMinutes());
assertEquals(-1, test.getSeconds());
assertEquals(-1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_RI_RI5() throws Throwable {
DateTime dt1 = null;  // 2002-06-09T01:00+01:00
DateTime dt2 = null;  // 2002-06-09T01:00+01:00
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0L, test.getTotalMillis());
public void testConstructor_RI_RI_PeriodType1() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1, dt2, null);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_RI_RI_PeriodType2() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseDayHourType());
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(31, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_RI_RI_PeriodType3() throws Throwable {
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType().withMillisRemoved());
assertEquals(PeriodType.getPreciseAllType().withMillisRemoved(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
public void testConstructor_RI_RI_PeriodType4() throws Throwable {
DateTime dt1 = null;  // 2002-06-09T01:00+01:00
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType());
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(3, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(0, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
public void testConstructor_RI_RI_PeriodType5() throws Throwable {
MillisDuration test = new MillisDuration(dt1, dt2, PeriodType.getPreciseAllType());
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0L, test.getTotalMillis());
MillisDuration test = new MillisDuration("P1Y2M3D");
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(2, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(3, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
(365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getTotalMillis());
MillisDuration test = new MillisDuration((Object) null);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0, test.getTotalMillis());
MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType());
MillisDuration test = new MillisDuration(base);
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(1, test.getHours());
assertEquals(2, test.getMinutes());
assertEquals(3, test.getSeconds());
assertEquals(4, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
MillisDuration base = new MillisDuration(dt1, dt2);  // AllType and precise
MillisDuration test = new MillisDuration(base);
assertEquals(PeriodType.getPreciseAllType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(1, test.getHours());
assertEquals(1, test.getMinutes());
assertEquals(1, test.getSeconds());
assertEquals(1, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType());
try {
new MillisDuration(base);
fail();
public void testConstructor_Object_PeriodType1() throws Throwable {
MillisDuration test = new MillisDuration("P1Y2M3D", PeriodType.getPreciseYearMonthType());
assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());
assertEquals(1, test.getYears());
assertEquals(2, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(3, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getTotalMillis());
public void testConstructor_Object_PeriodType2() throws Throwable {
MillisDuration test = new MillisDuration((Object) null, PeriodType.getPreciseYearMonthType());
assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0, test.getTotalMillis());
public void testConstructor_Object_PeriodType3() throws Throwable {
MillisDuration test = new MillisDuration(
new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType()), PeriodType.getPreciseYearMonthType());
assertEquals(PeriodType.getPreciseYearMonthType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(1, test.getHours());
assertEquals(2, test.getMinutes());
assertEquals(3, test.getSeconds());
assertEquals(4, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
public void testConstructor_Object_PeriodType4() throws Throwable {
MillisDuration test = new MillisDuration(new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getPreciseDayHourType()), null);
assertEquals(PeriodType.getPreciseDayHourType(), test.getPeriodType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(1, test.getHours());
assertEquals(2, test.getMinutes());
assertEquals(3, test.getSeconds());
assertEquals(4, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
result = ISOChronology.getInstance().monthOfYear().add(result, 6);
result = ISOChronology.getInstance().hourOfDay().add(result, 1);
Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);
result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);
result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);
assertEquals(true, dt == test.getStartInstant());
result = ISOChronology.getInstance().millisOfSecond().add(result, 23);
public void testConstructor_RI_RP4() throws Throwable {
public void testConstructor_RI_RP5() throws Throwable {
public void testConstructor_RI_RP6() throws Throwable {
Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);
result = ISOChronology.getInstanceUTC().monthOfYear().add(result, 6);
result = ISOChronology.getInstanceUTC().hourOfDay().add(result, 1);return new TimePeriod(this, DurationType.getPreciseAllType());
add(new TimePeriod(duration.getMillis()));
add(new TimePeriod(duration));
assertEquals(true, test.isPrecise());
assertEquals(length, test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(length, test.toDurationMillis());
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
assertEquals(4, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);
TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
public void testSetTimePeriod_long3() {
assertEquals(0, test.getWeeks());
try {
test.add(100L);
fail();
public void testAdd_RP1() {
test.add(new TimePeriod(100L));
public void testAdd_RP2() {
test.add(new TimePeriod(1, 0, 12, 1, 5, 6, 7, 8, DurationType.getPreciseYearWeekType()));
assertEquals(25, test.getDays());
MutableTimePeriod test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
test.add(new TimePeriod(100L));
try {
test.add(new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8));
fail();
public void testAdd_RP6() {
test.add((ReadableTimePeriod) null);assertEquals(true, test.isPrecise());
assertEquals(length, test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(length, test.toDurationMillis());
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
assertEquals(4, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());
DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);
assertEquals(1, test.getYears());
assertEquals(1, test.getMonths());
assertEquals(1, test.getWeeks());
assertEquals(1, test.getDays());
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.toDurationMillis());
DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);
TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise
assertEquals(true, test.isPrecise());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.toDurationMillis());suite.addTest(TestDuration_Constructors.suite());
suite.addTest(TestDuration_Basics.suite());
suite.addTest(TestMillisDuration_Constructors.suite());
suite.addTest(TestMutableDuration_Constructors.suite());
suite.addTest(TestMutableDuration_Basics.suite());
suite.addTest(TestMutableDuration_Updates.suite());
public void testGetIsTotalMillisBased() {
TimePeriod test = new TimePeriod(123L);
assertEquals(false, test.isTotalMillisBased());
test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(false, test.isTotalMillisBased());
public void testGetTotalMillis() {
TimePeriod test = new TimePeriod(123L);
assertEquals(123L, test.getTotalMillis());
super(value, null, false);
public void testToDuration() {
TimePeriod result = test.toDuration();
public void testToMutableDuration() {
MutableTimePeriod result = test.toMutableDuration();
assertEquals(test.getDurationType(), result.getDurationType());
assertEquals(test.isPrecise(), result.isPrecise());
assertEquals(test.getTotalMillis(), result.getTotalMillis());
public void testConstant() {
assertEquals(0L, TimePeriod.ZERO.getTotalMillis());
assertEquals(DurationType.getAllType(), TimePeriod.ZERO.getDurationType());
TimePeriod test = TimePeriod.ZERO;
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(length);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(length, null);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(length, DurationType.getMillisType());
TimePeriod test = new TimePeriod(length, DurationType.getDayHourType());
assertEquals(DurationType.getDayHourType(), test.getDurationType());
TimePeriod test = new TimePeriod(length, DurationType.getAllType().withMillisRemoved());
assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());
TimePeriod test = new TimePeriod(5, 6, 7, 8);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(false, test.isPrecise());
try {
test.getTotalMillis();
fail();
TimePeriod test = new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(false, test.isPrecise());
try {
test.getTotalMillis();
fail();
TimePeriod test = new TimePeriod(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getDayHourType());
assertEquals(DurationType.getDayHourType(), test.getDurationType());
new TimePeriod(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());
TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis());
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), null);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());
assertEquals(DurationType.getDayHourType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());
assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2);
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(1, test.getDays());
TimePeriod test = new TimePeriod(dt1, dt2);
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(-1, test.getDays());
TimePeriod test = new TimePeriod(dt1, dt2);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2, null);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getDayHourType());
assertEquals(DurationType.getDayHourType(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType().withMillisRemoved());
assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());
TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(1, test.getDays());
TimePeriod test = new TimePeriod(dt1, dt2, DurationType.getAllType());
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod("P1Y2M3D");
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(false, test.isPrecise());
try {
test.getTotalMillis();
fail();
TimePeriod test = new TimePeriod((Object) null);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));
assertEquals(DurationType.getDayHourType(), test.getDurationType());
TimePeriod base = new TimePeriod(dt1, dt2);  // AllType and precise
TimePeriod test = new TimePeriod(base);
assertEquals(DurationType.getAllType(), test.getDurationType());
TimePeriod test = new TimePeriod("P1Y2M3D", DurationType.getYearMonthType());
assertEquals(DurationType.getYearMonthType(), test.getDurationType());
assertEquals(false, test.isPrecise());
try {
test.getTotalMillis();
fail();
TimePeriod test = new TimePeriod((Object) null, DurationType.getYearMonthType());
assertEquals(DurationType.getYearMonthType(), test.getDurationType());
TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());
assertEquals(DurationType.getYearMonthType(), test.getDurationType());
TimePeriod test = new TimePeriod(new TimePeriod(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);
assertEquals(DurationType.getDayHourType(), test.getDurationType());
public void testConstructor_RI_RD1() throws Throwable {
assertEquals(false, dur == test.getDuration());
public void testConstructor_RI_RD2() throws Throwable {
assertEquals(false, dur == test.getDuration());
public void testConstructor_RI_RD3() throws Throwable {
assertEquals(true, dur == test.getDuration());
public void testConstructor_RI_RD4() throws Throwable {
public void testConstructor_RI_RD5() throws Throwable {
public void testConstructor_RI_RD6() throws Throwable {
public class TestMillisDuration_Constructors extends TestCase {
return new TestSuite(TestMillisDuration_Constructors.class);
public TestMillisDuration_Constructors(String name) {
public void testZERO() throws Throwable {
MillisDuration test = MillisDuration.ZERO;
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0, test.getTotalMillis());
MillisDuration test = new MillisDuration(length);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(length, test.getTotalMillis());
MillisDuration test = new MillisDuration(length, null);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(length, test.getTotalMillis());
MillisDuration test = new MillisDuration(length, DurationType.getMillisType());
assertEquals(length, test.getTotalMillis());
MillisDuration test = new MillisDuration(length, DurationType.getPreciseDayHourType());
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
assertEquals(length, test.getTotalMillis());
MillisDuration test = new MillisDuration(length, DurationType.getPreciseAllType().withMillisRemoved());
assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());
assertEquals(length - 8, test.getTotalMillis());
MillisDuration test = new MillisDuration(5, 6, 7, 8);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
MillisDuration test = new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, null);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
MillisDuration test = new MillisDuration(0, 0, 0, 0, 5, 6, 7, 8, DurationType.getPreciseDayHourType());
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
new MillisDuration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis());
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), null);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getPreciseDayHourType());
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1.getMillis(), dt2.getMillis(), DurationType.getPreciseAllType().withMillisRemoved());
assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(-2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(0L, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2, null);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseDayHourType());
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType().withMillisRemoved());
assertEquals(DurationType.getPreciseAllType().withMillisRemoved(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType());
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(2, test.getDays());  // one more due to 2004 leap year and fixed 365 day years
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
MillisDuration test = new MillisDuration(dt1, dt2, DurationType.getPreciseAllType());
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(0L, test.getTotalMillis());
MillisDuration test = new MillisDuration("P1Y2M3D");
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getTotalMillis());
MillisDuration test = new MillisDuration((Object) null);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(0, test.getTotalMillis());
MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType());
MillisDuration test = new MillisDuration(base);
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
MillisDuration base = new MillisDuration(dt1, dt2);  // AllType and precise
MillisDuration test = new MillisDuration(base);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
public void testConstructor_Object5() throws Throwable {
MillisDuration base = new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType());
try {
new MillisDuration(base);
fail();
MillisDuration test = new MillisDuration("P1Y2M3D", DurationType.getPreciseYearMonthType());
assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());
assertEquals(true, test.isPrecise());
assertEquals(
(365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getTotalMillis());
MillisDuration test = new MillisDuration((Object) null, DurationType.getPreciseYearMonthType());
assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());
assertEquals(0, test.getTotalMillis());
MillisDuration test = new MillisDuration(
new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType()), DurationType.getPreciseYearMonthType());
assertEquals(DurationType.getPreciseYearMonthType(), test.getDurationType());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
MillisDuration test = new MillisDuration(new MillisDuration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getPreciseDayHourType()), null);
assertEquals(DurationType.getPreciseDayHourType(), test.getDurationType());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
public class TestMutableDuration_Basics extends TestCase {
return new TestSuite(TestMutableDuration_Basics.class);
public TestMutableDuration_Basics(String name) {
public void testGetIsTotalMillisBased() {
MutableTimePeriod test = new MutableTimePeriod(123L);
assertEquals(false, test.isTotalMillisBased());
test = new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8);
assertEquals(false, test.isTotalMillisBased());
public void testGetTotalMillis() {
MutableTimePeriod test = new MutableTimePeriod(123L);
assertEquals(123L, test.getTotalMillis());
assertEquals(true, test1.equals(new MockMutableDuration(123L)));
class MockMutableDuration extends AbstractTimePeriod {
public MockMutableDuration(long value) {
super(value, null, false);
public void testCompareTo() {
MutableTimePeriod test1 = new MutableTimePeriod(123L);
MutableTimePeriod test1a = new MutableTimePeriod(123L);
assertEquals(0, test1.compareTo(test1a));
assertEquals(0, test1a.compareTo(test1));
assertEquals(0, test1.compareTo(test1));
assertEquals(0, test1a.compareTo(test1a));
MutableTimePeriod test2 = new MutableTimePeriod(321L);
assertEquals(-1, test1.compareTo(test2));
assertEquals(+1, test2.compareTo(test1));
MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());
assertEquals(-1, test1.compareTo(test3));
assertEquals(+1, test3.compareTo(test1));
assertEquals(0, test3.compareTo(test2));
assertEquals(+1, test2.compareTo(new MockMutableDuration(123L)));
assertEquals(0, test1.compareTo(new MockMutableDuration(123L)));
try {
test1.compareTo(null);
fail();
try {
test1.compareTo(new Long(123L));
fail();
try {
test1.compareTo(new MutableTimePeriod(1, 2, 3, 4, 5, 6, 7, 8));
fail();
public void testIsEqual() {
MutableTimePeriod test1 = new MutableTimePeriod(123L);
MutableTimePeriod test1a = new MutableTimePeriod(123L);
assertEquals(true, test1.isEqual(test1a));
assertEquals(true, test1a.isEqual(test1));
assertEquals(true, test1.isEqual(test1));
assertEquals(true, test1a.isEqual(test1a));
MutableTimePeriod test2 = new MutableTimePeriod(321L);
assertEquals(false, test1.isEqual(test2));
assertEquals(false, test2.isEqual(test1));
MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());
assertEquals(false, test1.isEqual(test3));
assertEquals(false, test3.isEqual(test1));
assertEquals(true, test3.isEqual(test2));
assertEquals(false, test2.isEqual(new MockMutableDuration(123L)));
assertEquals(true, test1.isEqual(new MockMutableDuration(123L)));
assertEquals(false, test1.isEqual(null));
assertEquals(true, new MutableTimePeriod(0L).isEqual(null));
public void testIsBefore() {
MutableTimePeriod test1 = new MutableTimePeriod(123L);
MutableTimePeriod test1a = new MutableTimePeriod(123L);
assertEquals(false, test1.isShorterThan(test1a));
assertEquals(false, test1a.isShorterThan(test1));
assertEquals(false, test1.isShorterThan(test1));
assertEquals(false, test1a.isShorterThan(test1a));
MutableTimePeriod test2 = new MutableTimePeriod(321L);
assertEquals(true, test1.isShorterThan(test2));
assertEquals(false, test2.isShorterThan(test1));
MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());
assertEquals(true, test1.isShorterThan(test3));
assertEquals(false, test3.isShorterThan(test1));
assertEquals(false, test3.isShorterThan(test2));
assertEquals(false, test2.isShorterThan(new MockMutableDuration(123L)));
assertEquals(false, test1.isShorterThan(new MockMutableDuration(123L)));
assertEquals(false, test1.isShorterThan(null));
assertEquals(false, new MutableTimePeriod(0L).isShorterThan(null));
public void testIsAfter() {
MutableTimePeriod test1 = new MutableTimePeriod(123L);
MutableTimePeriod test1a = new MutableTimePeriod(123L);
assertEquals(false, test1.isLongerThan(test1a));
assertEquals(false, test1a.isLongerThan(test1));
assertEquals(false, test1.isLongerThan(test1));
assertEquals(false, test1a.isLongerThan(test1a));
MutableTimePeriod test2 = new MutableTimePeriod(321L);
assertEquals(false, test1.isLongerThan(test2));
assertEquals(true, test2.isLongerThan(test1));
MutableTimePeriod test3 = new MutableTimePeriod(321L, DurationType.getAllType());
assertEquals(false, test1.isLongerThan(test3));
assertEquals(true, test3.isLongerThan(test1));
assertEquals(false, test3.isLongerThan(test2));
assertEquals(true, test2.isLongerThan(new MockMutableDuration(123L)));
assertEquals(false, test1.isLongerThan(new MockMutableDuration(123L)));
assertEquals(true, test1.isLongerThan(null));
assertEquals(false, new MutableTimePeriod(0L).isLongerThan(null));
public void testToDuration() {
TimePeriod result = test.toDuration();
assertEquals(test.getDurationType(), result.getDurationType());
assertEquals(test.isPrecise(), result.isPrecise());
assertEquals(test.getTotalMillis(), result.getTotalMillis());
public void testToMutableDuration() {
MutableTimePeriod result = test.toMutableDuration();
assertEquals(test.getDurationType(), result.getDurationType());
assertEquals(test.isPrecise(), result.isPrecise());
assertEquals(test.getTotalMillis(), result.getTotalMillis());
assertEquals(test.getTotalMillis(), copy.getTotalMillis());
assertEquals(test.getTotalMillis(), copy.getTotalMillis());
public class TestMutableDuration_Constructors extends TestCase {
return new TestSuite(TestMutableDuration_Constructors.class);
public TestMutableDuration_Constructors(String name) {
assertEquals(0, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(0, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(0, test.getTotalMillis());
public void testConstructor_DurationType_boolean1() throws Throwable {
MutableTimePeriod test = new MutableTimePeriod(null, true);
assertEquals(DurationType.getPreciseAllType(), test.getDurationType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0L, test.getTotalMillis());
assertEquals(true, test.isTotalMillisBased());
public void testConstructor_DurationType_boolean2() throws Throwable {
long length = 4 * DateTimeConstants.MILLIS_PER_DAY +
5 * DateTimeConstants.MILLIS_PER_HOUR +
6 * DateTimeConstants.MILLIS_PER_MINUTE +
7 * DateTimeConstants.MILLIS_PER_SECOND + 8;
MutableTimePeriod test = new MutableTimePeriod(null, false);
assertEquals(DurationType.getAllType(), test.getDurationType());
assertEquals(0, test.getYears());
assertEquals(0, test.getMonths());
assertEquals(0, test.getWeeks());
assertEquals(0, test.getDays());
assertEquals(0, test.getHours());
assertEquals(0, test.getMinutes());
assertEquals(0, test.getSeconds());
assertEquals(0, test.getMillis());
assertEquals(true, test.isPrecise());
assertEquals(0L, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
public void testConstructor_DurationType_boolean3() throws Throwable {
try {
new MutableTimePeriod(DurationType.getAllType(), true);
fail();
assertEquals(length, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(length, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(length, test.getTotalMillis());
assertEquals(length, test.getTotalMillis());
assertEquals(length - 8, test.getTotalMillis());
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
test.getTotalMillis();
assertEquals(false, test.isTotalMillisBased());
test.getTotalMillis();
assertEquals(false, test.isTotalMillisBased());
7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
assertEquals(0L, test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(false, test.isTotalMillisBased());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());
assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());
assertEquals(0L, test.getTotalMillis());
test.getTotalMillis();
assertEquals(false, test.isTotalMillisBased());
assertEquals(0, test.getTotalMillis());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());
test.getTotalMillis();
assertEquals(false, test.isTotalMillisBased());
assertEquals(0, test.getTotalMillis());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());
public class TestMutableDuration_Updates extends TestCase {
return new TestSuite(TestMutableDuration_Updates.class);
public TestMutableDuration_Updates(String name) {
public void testSetDuration_8ints1() {
test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);
public void testSetDuration_8ints2() {
test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);
assertEquals(100, test.getTotalMillis());
public void testSetDuration_8ints3() {
test.setDuration(0, 0, 0, 0, 0, 0, 0, 18);
assertEquals(18, test.getTotalMillis());
public void testSetDuration_8ints4() {
test.setDuration(11, 12, 13, 14, 15, 16, 17, 18);
public void testSetDuration_RD1() {
test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));
public void testSetDuration_RD2() {
test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));
assertEquals(100, test.getTotalMillis());
public void testSetDuration_RD3() {
test.setDuration(new MutableTimePeriod(0, 0, 0, 0, 0, 0, 0, 18));
assertEquals(18, test.getTotalMillis());
public void testSetDuration_RD4() {
test.setDuration(new MutableTimePeriod(11, 12, 13, 14, 15, 16, 17, 18));
public void testSetDuration_RD5() {
test.setDuration(null);
public void testSetTotalMillis_long_long1() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long2() {
test.setTotalMillis(dt2.getMillis(), dt1.getMillis());
public void testSetTotalMillis_long_long3() {
test.setTotalMillis(dt1.getMillis(), dt1.getMillis());
public void testSetTotalMillis_long_long_NoYears() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoMonths() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoWeeks() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoDays() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoHours() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoMinutes() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoSeconds() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long_long_NoMillis() {
test.setTotalMillis(dt1.getMillis(), dt2.getMillis());
public void testSetTotalMillis_long1() {
test.setTotalMillis(100L);
public void testSetTotalMillis_long2() {
test.setTotalMillis(
public void testSetTotalMillis_long3() {
test.setTotalMillis(
public void testSetTotalMillis_long_NoYears() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoMonths() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoWeeks() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoDays() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoHours() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoMinutes() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoSeconds() {
test.setTotalMillis(ms);
assertEquals(ms, test.getTotalMillis());
public void testSetTotalMillis_long_NoMillis() {
test.setTotalMillis(ms);
assertEquals(ms - 8, test.getTotalMillis());
assertEquals(200L, test.getTotalMillis());
assertEquals(ms + 100L, test.getTotalMillis());
assertEquals(100L, test.getTotalMillis());
public void testAdd_RD1() {
assertEquals(200L, test.getTotalMillis());
public void testAdd_RD2() {
public void testAdd_RD3() {
test.add(TimePeriod.ZERO);
assertEquals(100L, test.getTotalMillis());
public void testAdd_RD4() {
public void testAdd_RD5() {
public void testAdd_RD6() {
test.add(null);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, array.length);
public boolean isPrecise(Object object) {return false;}
public void setInto(ReadWritableTimePeriod duration, Object object) {}
public DurationType getDurationType(Object object, boolean tmm) {return null;}
assertEquals(6, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
public boolean isPrecise(Object object) {return false;}
public void setInto(ReadWritableTimePeriod duration, Object object) {}
public DurationType getDurationType(Object object, boolean tmm) {return null;}
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(4, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
public boolean isPrecise(Object object) {return false;}
public void setInto(ReadWritableTimePeriod duration, Object object) {}
public DurationType getDurationType(Object object, boolean tmm) {return null;}
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals(5, ConverterManager.getInstance().getDurationConverters().length);
assertEquals("ConverterManager[6 instant,5 duration,2 interval]", ConverterManager.getInstance().toString());
public void testIsPrecise_Object() throws Exception {
assertEquals(true, LongConverter.INSTANCE.isPrecise(new Long(123L)));
assertEquals(123L, m.getTotalMillis());
public void testIsPrecise_Object() throws Exception {
assertEquals(true, NullConverter.INSTANCE.isPrecise(null));
assertEquals(0L, m.getTotalMillis());
import org.joda.time.TimePeriod;
import org.joda.time.MillisDuration;
assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new TimePeriod(123L)));
try {
ReadableDurationConverter.INSTANCE.getDurationMillis(new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0));
fail();
assertEquals(DurationType.getMillisType(),
ReadableDurationConverter.INSTANCE.getDurationType(
new TimePeriod(123L, DurationType.getMillisType()), false));
assertEquals(DurationType.getAllType(),
ReadableDurationConverter.INSTANCE.getDurationType(
new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0), false));
ReadableDurationConverter.INSTANCE.getDurationType(
new MillisDuration(1, 2, 0, 1, 0, 0, 0, 0), true));
public void testIsPrecise_Object() throws Exception {
assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new TimePeriod(123L)));
assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new TimePeriod(1, 2, 0, 1, 0, 0, 0, 0)));
ReadableDurationConverter.INSTANCE.setInto(m, new TimePeriod(1, 2, 0, 3, 0, 0, 0, 0));
assertEquals(1, m.getYears());
assertEquals(2, m.getMonths());
assertEquals(0, m.getMinutes());
assertEquals(0, m.getMillis());
Interval i = new Interval(0L, 123L);
Interval i = new Interval(0L, 123L);
public void testIsPrecise_Object() throws Exception {
Interval i = new Interval(0L, 123L);
assertEquals(true, ReadableIntervalConverter.INSTANCE.isPrecise(i));
Interval i = new Interval(0L, 123L);
try {
StringConverter.INSTANCE.getDurationMillis("P2Y6M9D");
fail();
public void testIsPrecise_Object() throws Exception {
assertEquals(false, StringConverter.INSTANCE.isPrecise("P2Y6M9D"));return new FixedDateTimeZone(id, null, offset, offset);
return new FixedDateTimeZone(convId, null, offset, offset);
public static Set getAvailableIDs(int rawOffset) {
String[] ids = TimeZone.getAvailableIDs(rawOffset);
Set set = new HashSet();
for (int i = 0; i < ids.length; i++) {
if (cZones.containsKey(ids[i])) {
set.add(ids[i]);
return Collections.unmodifiableSet(set);expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
Instant added = test.addTo(new Instant(), 1);
Instant added = test.addTo(new Instant(), -2);
public void testAddToRI3() {
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
Instant added = test.addTo(null, 1);
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
expected = ISOChronology.getInstance().years().add(expected, -2);
expected = ISOChronology.getInstance().months().add(expected, -4);
expected = ISOChronology.getInstance().weeks().add(expected, -6);
expected = ISOChronology.getInstance().days().add(expected, -8);
expected = ISOChronology.getInstance().hours().add(expected, -10);
expected = ISOChronology.getInstance().minutes().add(expected, -12);
expected = ISOChronology.getInstance().seconds().add(expected, -14);
expected = ISOChronology.getInstance().millis().add(expected, -16);
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
Instant added = test.addTo(new Instant(), 1);
Instant added = test.addTo(new Instant(), -2);
public void testAddToRI3() {
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);
Instant added = test.addTo(null, 1);
long expected = TEST_TIME_NOW;
expected = ISOChronology.getInstance().years().add(expected, 1);
expected = ISOChronology.getInstance().months().add(expected, 2);
expected = ISOChronology.getInstance().weeks().add(expected, 3);
expected = ISOChronology.getInstance().days().add(expected, 4);
expected = ISOChronology.getInstance().hours().add(expected, 5);
expected = ISOChronology.getInstance().minutes().add(expected, 6);
expected = ISOChronology.getInstance().seconds().add(expected, 7);
expected = ISOChronology.getInstance().millis().add(expected, 8);return new Instant(addTo(instant.getMillis(), scalar));
instant.setMillis(addTo(instant.getMillis(), scalar));private static void checkPrecise(DurationField field, String name) {
if (!field.isPrecise()) {
throw new UnsupportedOperationException
("The field \"" + name + "\" is imprecise");
setDuration(iType, duration);
if (duration == null) {
throw new IllegalArgumentException("The duration must not be null");
if (type == null) {
throw new IllegalArgumentException("The type must not be null");
if (type == null) {
throw new IllegalArgumentException("The type must not be null");
private void setTotalMillis(DurationType type, final long duration) {
if (type == null) {
throw new IllegalArgumentException("The type must not be null");
if (duration == null) {
throw new IllegalArgumentException("The duration must not be null");
add(duration.getTotalMillis());(iUpperLimit == null ? 0 : iUpperLimit.hashCode());
return "DateTimeComparator["
+ (iLowerLimit == null ? "" : iLowerLimit.getName())
+ (iLowerLimit == null && iUpperLimit == null ? "" : "-")
+ (iUpperLimit == null ? "" : iUpperLimit.getName())
+ "]";assertEquals(2004, test.getYear());
assertEquals(8, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
assertEquals(2004, test.getYear());
assertEquals(8, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
assertEquals(2004, test.getYear());
assertEquals(3, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
assertEquals(2005, test.getYear());
assertEquals(4, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
assertEquals(2005, test.getYear());
assertEquals(4, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
assertEquals(2004, test.getYear());
assertEquals(4, test.getMonthOfYear());
assertEquals(9, test.getDayOfMonth());
DateMidnight test = new DateMidnight(2004, 7, 16);
assertEquals("2004-07-00T00:00:00.000+01:00", copy.toString());
DateMidnight test = new DateMidnight(2004, 7, 16);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
DateMidnight test = new DateMidnight(2004, 7, 16);
assertEquals("2004-07-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 17);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 15);
assertEquals("2004-07-00T00:00:00.000+01:00", copy.toString());
DateMidnight test = new DateMidnight(2004, 7, 16);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 17);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 15);
assertEquals("2004-07-00T00:00:00.000+01:00", copy.toString());
DateMidnight test = new DateMidnight(2004, 7, 16);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 8, 16);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 17);
assertEquals("2004-08-00T00:00:00.000+01:00", copy.toString());
test = new DateMidnight(2004, 7, 15);
assertEquals("2004-07-00T00:00:00.000+01:00", copy.toString());
assertEquals(9L * DateTimeConstants.MILLIS_PER_DAY, test.monthOfYear().remainder());return getInstance(getBase().getZone());
return getInstance(getBase().getZone());
return getInstance(getBase().getZone());
return getInstance(getBase().getZone());private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
DateTimeField field;
if ((field = iLowerLimit) != null) {
lhsMillis = field.roundFloor(lhsMillis);
rhsMillis = field.roundFloor(rhsMillis);
if ((field = iUpperLimit) != null) {
lhsMillis = field.remainder(lhsMillis);
rhsMillis = field.remainder(rhsMillis);
return "DateTimeComparator[lowerLimit:"
+ (iLowerLimit == null ? "none" : iLowerLimit.getName())
+ ",upperLimit:"
+ (iUpperLimit == null ? "none" : iUpperLimit.getName())
public final class DateTimeUtils {
private DateTimeUtils() {
public static long currentTimeMillis() {
public static void setCurrentMillisSystem() throws SecurityException {
public static void setCurrentMillisFixed(long fixedMillis) throws SecurityException {
public static void setCurrentMillisOffset(long offsetMillis) throws SecurityException {assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis));
MutableDateTime test = new MutableDateTime(TEST_TIME1);
test.setDate(null);
assertEquals(TEST_TIME_NOW, test.getMillis());
MutableDateTime test = new MutableDateTime(TEST_TIME1);
test.setTime(null);
assertEquals(TEST_TIME_NOW, test.getMillis());static final long serialVersionUID = 2852608688135209575L;
public void setRoundingField(DateTimeField field) {
iRoundingField = field;
if (field != null) {
if (iRoundingMode == ROUND_NONE) {
iRoundingMode = ROUND_FLOOR;
setMillis(getMillis());
public void setRoundingField(DateTimeField field, int mode) {
if (mode < ROUND_NONE || mode > ROUND_HALF_EVEN) {
iRoundingField = field;
iRoundingMode = mode;
if (field != null && mode != ROUND_NONE) {
setMillis(getMillis());
public boolean equals(Object readableInstant) {
if (this == readableInstant) {
return true;
if (super.equals(readableInstant)) {
if (readableInstant instanceof ReadWritableInstant) {
ReadWritableInstant other = (ReadWritableInstant) readableInstant;
if (getRoundingMode() == other.getRoundingMode()) {
DateTimeField field = getRoundingField();
if (field == other.getRoundingField() ||
field != null && field.equals(other.getRoundingField())) {
return true;
return true;
return false;public boolean equals(Object readableInstant) {
public int hashCode() {assertEquals(false, zone5.equals(zone5));assertEquals(0L, LongConverter.INSTANCE.getDurationMillis(null));
assertEquals(DurationType.getMillisType(), LongConverter.INSTANCE.getDurationType(null));
assertEquals(true, LongConverter.INSTANCE.isPrecise(null));
LongConverter.INSTANCE.setInto(m, null);try
aDateTime = getADate( "2000-01-01T00:00:00" );
assertEquals("NULLDT Expected Fail", 0,     // should not matter
cYear.compare( null, aDateTime ) );
catch(IllegalArgumentException iae)
return;
fail("null object failed");
try
aDateTime = getADate( "2000-01-01T00:00:00" );
assertEquals("INVLO Expected Fail", 0,  // should not matter
cYear.compare( "FreeBird" , aDateTime ) );
catch(ClassCastException cce)
return;
catch(IllegalArgumentException iae)
return;
fail("Invalid object failed");
try
retDT = new DateTime( s, DateTimeZone.UTC );
catch(IllegalArgumentException pe)
try
newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );
catch(IllegalArgumentException pe)
private boolean isListSorted( List tl ) {return "Converter[" + getSupportedType() + "]";
if (object instanceof GregorianCalendar) {
return BuddhistChronology.getInstance(zone);
return DurationType.getAverageYearMonthType();import org.joda.time.convert.ConverterManager;
import org.joda.time.format.ISODateTimeFormat;
iChronology = converter.getChronology(instant);
iChronology = converter.getChronology(instant, zone);
iChronology = converter.getChronology(instant, chronology);
public String toString() {
return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
public String toString(String pattern) throws IllegalArgumentException {
if (instant instanceof ReadableInstant) {
setMillis(((ReadableInstant) instant).getMillis());
InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
setMillis(converter.getInstantMillis(instant));
if (zone == trusted && this instanceof DateTime
&& getChronology() instanceof ISOChronology) {
public final int compareTo(Object readableInstant) {
if (this == readableInstant) {
ReadableInstant otherInstant = (ReadableInstant) readableInstant;
public final boolean isAfter(ReadableInstant readableInstant) {
if (readableInstant == null) {
throw new IllegalArgumentException("The instant must not be null");
return (getMillis() > readableInstant.getMillis());
public final boolean isBefore(ReadableInstant readableInstant) {
if (readableInstant == null) {
throw new IllegalArgumentException("The instant must not be null");
return (getMillis() < readableInstant.getMillis());
public final boolean isEqual(ReadableInstant readableInstant) {
if (readableInstant == null) {
throw new IllegalArgumentException("The instant must not be null");
return (getMillis() == readableInstant.getMillis());int limit = text.length() - position;System.err.println("DateTimeBrowser <options> <filename>");cOffsetFormatter = new DateTimeFormatterBuilder(UTC)
chrono = ISOChronology.getInstance();
iChrono = chrono;
iChronoUTC = chrono.withUTC();
DateTimeZone zone = chrono.getZone();Chronology original = converter.getChronology(instant, chronology);
protected DateTimeField getField(int index) {
protected int getValue(int index) {return getAsText(get(instant));
return getAsText(fieldValue);
return getAsShortText(get(instant));
return getAsShortText(fieldValue);(fields.yearOfEra, "centuryOfEra", "centuries", 100);chrono = getInstance(DateTimeZone.UTC, gregorianCutover, minDaysInFirstWeek);
chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone));
private GJChronology(Chronology base) {
super(base, null);
Instant cutover = iCutoverInstant;
if (cutover == null) {
iCutoverInstant = cutover = new Instant(iCutoverMillis);
return cutover;
if (getBase() != null) {
return;
iJulianChronology = julian;
iGregorianChronology = gregorian;
iCutoverInstant = cutoverInstant;return appendDecimal
(iChronoUTC.weekyear(), minDigits, maxDigits);
bucket.undoChanges(originalState);
bucket.undoChanges(bestValidState);final Chronology chronology = converter.getChronology(instant);
iChronology = selectChronologyUTC(chronology);
(toLocalTime(converter.getInstantMillis(instant), chronology, iChronology));
iChronology = selectChronologyUTC(chronology);
(toLocalTime(converter.getInstantMillis(instant),
converter.getChronology(instant), iChronology));private static long convert(long instant, Chronology from, Chronology to) {
iGapDuration = cutoverInstant - julianToGregorian(cutoverInstant);
(julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover);
iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear());
long julianToGregorian(long instant) {
return convert(instant, iJulianChronology, iGregorianChronology);
long gregorianToJulian(long instant) {
return convert(instant, iGregorianChronology, iJulianChronology);
this(julianField, gregorianField, iCutoverInstant);
this(julianField, gregorianField, null);
super(julianField, gregorianField);"YearOfWY",return append(printer, parsers[0]);
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
Object state = bucket.saveState();
int bestInvalidParser = 0;
int bestValidPos = position;
int bestValidParser = 0;
if (i != 0) {
bucket.undoChanges(state);
if (bestValidPos > position) {
break;
return position;
if (parsePos >= text.length()) {
return parsePos;
bestValidParser = i;
parsePos = ~parsePos;
if (parsePos > bestInvalidPos) {
bestInvalidPos = parsePos;
bestInvalidParser = i;
if (bestValidPos > position) {
if (bestValidParser == length - 1) {
return bestValidPos;
bucket.undoChanges(state);
return parsers[bestValidParser].parseInto(bucket, text, position);
if (bestInvalidParser == length - 1) {
return ~bestInvalidPos;
bucket.undoChanges(state);
return parsers[bestInvalidParser].parseInto(bucket, text, position);cDefault = getInstance(java.util.TimeZone.getDefault());Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());if (text.length() <= sampleLen) {