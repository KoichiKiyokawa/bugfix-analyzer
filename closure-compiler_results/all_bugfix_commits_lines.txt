private final Deque<JSType> currentClassStack = new LinkedList<JSType>();
private JSType bestInstanceTypeForMethodOrCtor(Node n, Node parent) {
if (parent.isAssign()) {
Node lValue = parent.getFirstChild();
if (NodeUtil.isGet(lValue)) {
JSType lValueType = lValue.getJSType();
if (lValueType != null && (lValueType.isConstructor() || lValueType.isInterface())) {
return normalizeClassType(lValueType);
return normalizeClassType(NodeUtil.getPrototypeClassName(lValue).getJSType());
return normalizeClassType(lValue.getFirstChild().getJSType());
return normalizeClassType(lValue.getJSType());
|| NodeUtil.isClassDeclaration(n)
|| parent.isName()) {
return normalizeClassType(n.getJSType());
|| parent.isGetterDef()
|| parent.isSetterDef()
|| parent.isMemberFunctionDef()
|| parent.isComputedProp()) {
Node objectLitParent = parent.getGrandparent();
if (!objectLitParent.isAssign()) {
Node className = NodeUtil.getPrototypeClassName(objectLitParent.getFirstChild());
if (className != null) {
return normalizeClassType(className.getJSType());
return null;
private static JSType normalizeClassType(JSType type) {
if (type == null || type.isUnknownType()) {
return type;
return normalizePrototypeObject(type.toMaybeObjectType());
return type;
private static ObjectType normalizePrototypeObject(ObjectType type) {
FunctionType owner = type.getOwnerFunction();
if (owner.hasInstanceType()) {
return owner.getInstanceType();
return type;
checkFinalClassOverrides(t, n, parent);
private void checkFinalClassOverrides(NodeTraversal t, Node ctor, Node parent) {
JSType finalParentClass =
getSuperClassInstanceIfFinal(bestInstanceTypeForMethodOrCtor(ctor, parent));
JSType ownerType = normalizeClassType(objectType);
NodeTraversal t, PropertyReference propRef, boolean isClassType, JSType ownerType) {
ownerType.equals(propRef.getReceiverType())
NodeTraversal t, PropertyReference propRef, JSType ownerType) {
for (JSType scopeType : currentClassStack) {
if (scopeType == null) {
continue;
return;
&& getTypeDeprecationInfo(bestInstanceTypeForMethodOrCtor(scopeRoot, scopeRootParent))
!= null);DiagnosticType.error("PARSE_TREE_TOO_DEEP",
"Parse tree too deep.");
DiagnosticType.warning("INVALID_OCTAL_LITERAL",
DiagnosticType.error("ES6_TYPED",
DiagnosticType.error("MISPLACED_TYPE_SYNTAX",
"Can only have JSDoc or inline type annotations, not both");new UnionTypeBuilder(registry)
UnionTypeBuilder unionTypeBuilder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);
private static final int PROPERTY_CHECKING_UNION_SIZE = 3000;
propertyName, k -> new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE));
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
builder.addAlternate(alternate, true);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
builder.addAlternate(alternate);
alternatesWithoutStucturalTyping = builder.getAlternates();
builder = new UnionTypeBuilder(registry);
for (JSType alternate : alternatesWithoutStucturalTyping) {
builder.addAlternate(alternate, true);
alternates = builder.getAlternates();
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
public class UnionTypeBuilder implements Serializable {
private final int maxUnionSize;
public UnionTypeBuilder(JSTypeRegistry registry) {
this(registry, DEFAULT_MAX_UNION_SIZE);
UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {
private boolean isSubtype(
JSType rightType, JSType leftType, boolean isStructural) {
if (isStructural && !thisUnresolved && !thatUnresolved) {
public UnionTypeBuilder addAlternate(JSType alternate, boolean isStructural) {
if (alternate.isEquivalentTo(current, isStructural)) {
if (isSubtype(alternate, current, isStructural)) {
if (isSubtype(current, alternate, isStructural)) {
public UnionTypeBuilder addAlternate(JSType alternate) {
return addAlternate(alternate, false);
JSType type = null;
type = typeRegistry.createObjectType("type: " + i, null);
assertFalse(typeRegistry.getGreatestSubtypeWithProperty(type, "foo").isUnknownType());
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);((NamedType) this).getReferenceName(), ((NamedType) that).getReferenceName());
return getConcreteNominalTypeName(this.toObjectType())
.equals(getConcreteNominalTypeName(that.toObjectType()));
private String getConcreteNominalTypeName(ObjectType objType) {
if (objType instanceof ProxyObjectType) {
ObjectType internal = ((ProxyObjectType) objType)
.getReferencedObjTypeInternal();
if (internal != null && internal.isNominalType()) {
return getConcreteNominalTypeName(internal);
return objType.getReferenceName();
return nominalHashCode(this);
if (isResolved() && !result.isNoResolvedType()) {
message + (message.isEmpty() ? "" : "\n")
+ " Equals is not symmetric.\n"
+ "Type: " + b + "\n",
message + (message.isEmpty() ? "" : "\n")
+ " Equals is not symmetric.\n"
+ "Type: " + b + "\n",
public static void assertTypeEquals(String message, JSType a, JSType b) {
checkNotNull(a);
checkNotNull(b);
message + (message.isEmpty() ? "" : "\n")
+ "Expected: " + a + "\n"
+ "Actual  : " + b,
a.isEquivalentTo(b, true));
message
+ " Equals is not symmetric.\n"
+ "Expected: " + b + "\n"
+ "Actual  : " + a,
b.isEquivalentTo(a, true));
Assert.assertTrue(a.isEquivalentTo(b));
Assert.assertTrue(a.isEquivalentTo(a));
Assert.assertTrue(b.isEquivalentTo(b));
Assert.assertTrue(b.isEquivalentTo(a));
registry = new JSTypeRegistry(errorReporter, ImmutableSet.of("forwardDeclared"));
public void testShadowedForwardReference() {
"/** @constructor */ var C = function() { /** @type {string} */ this.prop = 's'; };",
"/** @type {C} */ var x",
"/** @constructor */ var C = function() { /** @type {number} */ this.prop = 1; };",
"/** @return {C} */ function fn() { return new C(); };",
"/** @type {number} */ var n1 = x.prop;",
"/** @type {number} */ var n2 = new C().prop;",
"}"),
"initializing variable", //
"found   : string", // should be "number"
"required: number"));
String.format("getLeastSupertype not symmetrical:\n" +
"typeA: %s\ntypeB: %s\n" +
"a.getLeastSupertype(b): %s\n" +
"b.getLeastSupertype(a): %s\n",
typeA, typeB, aOnB, bOnA),
String.format("getGreatestSubtype not symmetrical:\n" +
"typeA: %s\ntypeB: %s\n" +
"a.getGreatestSubtype(b): %s\n" +
"b.getGreatestSubtype(a): %s\n",
typeA, typeB, aOnB, bOnA),
public void testForwardDeclaredNamedTypeEquals() {
NamedType a = new NamedType(EMPTY_SCOPE, registry, "forwardDeclared", "source", 1, 0);
NamedType b = new NamedType(EMPTY_SCOPE, registry, "forwardDeclared", "source", 1, 0);
assertTypeEquals(a, b);
a.resolve(null);
assertTrue(a.isResolved());
assertFalse(b.isResolved());
assertTypeEquals(a, b);
assertFalse(a.isEquivalentTo(UNKNOWN_TYPE));
assertFalse(b.isEquivalentTo(UNKNOWN_TYPE));
assertTrue(a.isEmptyType());
assertFalse(a.isNoType());
assertTrue(a.isNoResolvedType());
public void testForwardDeclaredNamedType() {
NamedType a = new NamedType(EMPTY_SCOPE, registry, "forwardDeclared", "source", 1, 0);
assertTypeEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE));
assertTypeEquals(CHECKED_UNKNOWN_TYPE,
a.getLeastSupertype(CHECKED_UNKNOWN_TYPE));
assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a));
assertTypeEquals(CHECKED_UNKNOWN_TYPE,
CHECKED_UNKNOWN_TYPE.getLeastSupertype(a));
public void testNamedTypeProperties() {
FunctionType ctorA = registry.createConstructorType("TypeA", null, null, null, null, false);
MapBasedScope scope = new MapBasedScope(ImmutableMap.of("TypeA", ctorA));
ObjectType typeA = ctorA.getInstanceType();
NamedType namedA = new NamedType(scope, registry, "TypeA", "source", 1, 0);
namedA.defineDeclaredProperty("foo", NUMBER_TYPE, null);
namedA.resolve(null);
assertTypeEquals(NUMBER_TYPE, typeA.getPropertyType("foo"));
NamedType activeXObject = new NamedType(scope, registry, "ActiveXObject", "source", 1, 0);t, n, n.getFirstChild(), getJSType(n.getSecondChild()), "default value has wrong type");
visitInterfacePropertyAssignment(t, object, rvalue);
checkEnumAlias(t, info, rvalue);
validator.expectCanAssignToPrototype(t, objectJsType, rvalue, getJSType(rvalue));
checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, expectedPropertyType);
t, assign, getJSType(rvalue), expectedPropertyType, object, pname);
JSType rightType = getJSType(rvalue);
checkCanAssignToWithScope(t, assign, lvalue, rightType, "assignment");
ensureTyped(assign, rightType);
private void checkCanAssignToWithScope(
NodeTraversal t, Node assign, Node lvalue, JSType rightType, String msg) {
validator.expectCanAssignTo(t, assign, rightType, leftType, msg);
private void visitInterfacePropertyAssignment(NodeTraversal t, Node object, Node rvalue) {
if (lhs.isGetProp()) {
Node object = lhs.getFirstChild();
if (object.isGetProp() && object.getLastChild().getString().equals("prototype")) {
JSType jsType = getJSType(object.getFirstChild());
if (jsType.isInterface()) {
reportInvalidInterfaceMemberDeclaration(t, object);
checkPropCreation(t, lhs);
JSType objectJsType = getJSType(object);
Node property = lhs.getLastChild();
String pname = property.getString();
ObjectType objectCastType = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());
JSType expectedPropertyType = getPropertyTypeIfDeclared(objectCastType, pname);
if (!expectedPropertyType.isUnknownType()) {
if (!propertyIsImplicitCast(objectCastType, pname)) {
validator.expectCanAssignToPropertyOf(
t, iterable, actualType, expectedPropertyType, object, pname);
return;
for (Node name : n.children()) {
Node value = name.getFirstChild();
TypedVar var = t.getTypedScope().getVar(name.getString());
if (value != null) {
JSType nameType = var.getType();
nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;
JSDocInfo info = name.getJSDocInfo();
if (info == null) {
info = varInfo;
checkEnumAlias(t, info, value);
if (var.isTypeInferred()) {
ensureTyped(name, valueType);
validator.expectCanAssignTo(
t, value, valueType, nameType, "initializing variable");
NodeTraversal t, JSDocInfo declInfo, Node value) {
JSType valueType = getJSType(value);
validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,private Map<String, String> browserResolverPrefixReplacements = ImmutableMap.of();valid = isTypeAnnotationAllowedForNameOrPattern(n);
private boolean isTypeAnnotationAllowedForNameOrPattern(Node n) {
checkState(n.isName() || n.isArrayPattern() || n.isObjectPattern(), n);
final boolean isAllowed;
Node parent = n.getParent();
switch (parent.getToken()) {
case GETTER_DEF: // { /** typeAnnotation */ get n() {} }
case SETTER_DEF: // { /** typeAnnotation */ set n() {} }
case CATCH: // } catch ( /** typeAnnotation */ n ) {
case FUNCTION: // function /** typeAnnotation */ n() {}
case VAR: // var /** typeAnnotation */ n;
case LET:
case CONST:
case PARAM_LIST: // function f( /** typeAnnotation */ n ) {}
case ARRAY_PATTERN: // ([ /** typeAnnotation */ n ] = iterable);
case DEFAULT_VALUE: // function f( /** typeAnnotation */ n = 1 ) {}
isAllowed = true;
break;
case STRING_KEY:
Node stringKeyParent = parent.getParent();
if (stringKeyParent.isObjectPattern()) {
isAllowed = true;
checkState(stringKeyParent.isObjectLit(), stringKeyParent);
isAllowed = false;
break;
case COMPUTED_PROP:
Node computedProp = parent;
Node computedPropParent = parent.getParent();
if (computedPropParent.isObjectPattern()) {
isAllowed = n.isSecondChildOf(computedProp);
checkState(computedPropParent.isObjectLit(), computedPropParent);
isAllowed = false;
break;
default:
isAllowed = false;
break;
return isAllowed;
valueNode = transform(targetTree);
targetNode = transform(targetTree);import java.util.function.Consumer;
Diagnostic diagnostic,
testInternal(compiler, inputs, expected, diagnostic, postconditions);
Sources inputsObj,  // TODO remove this parameter
Diagnostic diagnostic,
String errorMsg = LINE_JOINER.join(compiler.getErrors());
if (root == null && expected == null
&& diagnostic != null
&& diagnostic.level == CheckLevel.ERROR) {
assertWithMessage("Expected one parse error, but got " + errorMsg)
.that(compiler.getErrorCount())
.isEqualTo(1);
JSError actualError = compiler.getErrors()[0];
assertWithMessage("Unexpected parse error(s): " + errorMsg)
.that(actualError.getType())
.isEqualTo(diagnostic.diagnostic);
diagnostic.verifyMessage(actualError.description);
assertWithMessage("Unexpected parse error(s): " + errorMsg).that(root).isNotNull();
if (diagnostic == null || diagnostic.level != CheckLevel.ERROR) {
if (diagnostic == null || diagnostic.level != CheckLevel.WARNING) {
"There should be one warning, repeated "
for (int i = 0; i < numRepetitions; ++i) {
JSError[] warnings = errorManagers[i].getWarnings();
JSError actual = warnings[0];
assertError(actual).hasType(diagnostic.diagnostic);
validateSourceLocation(actual);
diagnostic.verifyMessage(actual.description);
assertNull("expected must be null if error != null", expected);
assertEquals(
"There should be one error of type '" + diagnostic.diagnostic.key + "' but there were: "
+ Arrays.toString(compiler.getErrors()),
1, compiler.getErrorCount());
JSError actualError = compiler.getErrors()[0];
assertEquals(errorMsg, diagnostic.diagnostic, actualError.getType());
validateSourceLocation(actualError);
diagnostic.verifyMessage(actualError.description);
assertWithMessage("Some placeholders in the error message were not replaced")
.that(actualError.description)
.doesNotContainMatch("\\{\\d\\}");
if (diagnostic != null && diagnostic.level == CheckLevel.WARNING) {
String warnings = "";
for (JSError actualWarning : compiler.getWarnings()) {
warnings += actualWarning.description + "\n";
assertWithMessage("Some placeholders in the warning message were not replaced")
.that(actualWarning.description)
.doesNotContainMatch("\\{\\d\\}");
assertEquals("There should be one warning. " + warnings, 1, compiler.getWarningCount());
assertEquals(warnings, diagnostic.diagnostic, compiler.getWarnings()[0].getType());
protected static Sources srcs(String[] srcTexts) {
Diagnostic diagnostic = null;
checkState(diagnostic == null);
diagnostic = (Diagnostic) part;
testInternal(externs, srcs, expected, diagnostic, postconditions);
final Consumer<String> messagePostcondition;
Diagnostic(CheckLevel level, DiagnosticType diagnostic, Consumer<String> messagePostcondition) {
this.messagePostcondition = messagePostcondition;
protected void verifyMessage(String message) {
if (messagePostcondition != null) {
messagePostcondition.accept(message);
checkState(messagePostcondition == null);
return new Diagnostic(level, diagnostic, message -> assertThat(message).isEqualTo(expected));
checkState(messagePostcondition == null);
return new Diagnostic(level, diagnostic, message -> assertThat(message).contains(substring));void expectExtends(Node n, FunctionType subCtor, FunctionType superCtor) {
if (superCtor == null || (!superCtor.isConstructor() && !superCtor.isInterface())) {
if (superCtor.isConstructor() != subCtor.isConstructor()) {
ObjectType superInstance = superCtor.getInstanceType();
ObjectType declaredSuper = subCtor.getSuperClassConstructor().getInstanceType();
if (!superInstance.isEquivalentTo(declaredSuper)) {
mismatch(n, "mismatch in declaration of superclass type", superInstance, declaredSuper);
if (!subCtor.explicitlyImplOrExtInterface(superCtor)) {
ObjectType extended = subCtor.getExtendedInterfaces().get(0);
mismatch(n, "mismatch in declaration of superclass type", superInstance, extended);pushScope(s);
Node args = n.getSecondChild();
Node body = args.getNext();
traverseBranch(args, n);
traverseBranch(body, n);
popScope();
pushScope(s);
traverseChildren(n);
popScope();
checkState(scopeCreator.hasBlockScope());
pushScope(s);
Node forAssignmentParam = n.getFirstChild();
Node forIterableParam = forAssignmentParam.getNext();
Node forBodyScope = forIterableParam.getNext();
traverseBranch(forAssignmentParam, n);
traverseBranch(forIterableParam, n);
traverseBranch(forBodyScope, n);
popScope();
checkState(scopeCreator.hasBlockScope());
pushScope(s);
traverseChildren(n);
popScope();
final Node extendsClause = n.getSecondChild();
final Node body = extendsClause.getNext();
NodeTraversal.traverseTyped(compiler, scriptRoot, scopeBuilder);
NodeTraversal.traverse(compiler, currentScope.getRootNode(), this);
if (inCurrentScope(t)) {import com.google.javascript.rhino.jstype.EnumType;
class InferJSDocInfo extends AbstractPostOrderCallback
implements HotSwapCompilerPass {
attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());
if (objType.isConstructor() ||
objType.isEnumType() ||
objType.isInterface()) {
if (objType.hasReferenceName() &&
objType.getReferenceName().equals(qName)) {
objType.setJSDocInfo(docInfo);
if (objType.isConstructor() || objType.isInterface()) {
JSType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(docInfo);
((EnumType) objType).getElementsType().setJSDocInfo(docInfo);
import static com.google.common.truth.Truth.assertWithMessage;
import com.google.javascript.rhino.JSDocInfo;
private static final String OBJECT_EXTERNS = ""
+ "/**\n"
+ " * Object.\n"
+ " * @param {*=} x\n"
+ " * @return {!Object}\n"
+ " * @constructor\n"
+ " */\n"
+ "function Object(x) {};";
(new TypeInferencePass(
compiler, compiler.getReverseAbstractInterpreter(),
topScope, scopeCreator)).process(externs, root);
NodeTraversal t = new NodeTraversal(
compiler, callback, scopeCreator);
(new InferJSDocInfo(compiler)).process(externs, root);
public void testNativeCtor() {
externs(OBJECT_EXTERNS),
srcs("var x = new Object();" + "/** Another object. */ var y = new Object();"));
assertEquals(
"Object.",
findGlobalNameType("x").getJSDocInfo().getBlockDescription());
assertEquals(
"Object.",
findGlobalNameType("y").getJSDocInfo().getBlockDescription());
assertEquals(
"Object.",
globalScope.getVar("y").getType().getJSDocInfo().getBlockDescription());
public void testStructuralFunctions() {
externs(OBJECT_EXTERNS),
"/** Function. \n * @param {*} x */ "
+ "function fn(x) {};"
+ "var goog = {};"
+ "/** Another object. \n * @type {Object} */ goog.x = new Object();"
+ "/** Another function. \n * @param {number} x */ goog.y = fn;"));
assertEquals(
"(Object|null)",
globalScope.getVar("goog.x").getType().toString());
assertEquals(
"Object.",
globalScope.getVar("goog.x").getType().restrictByNotNullOrUndefined()
.getJSDocInfo().getBlockDescription());
assertEquals(
"Another function.",
globalScope.getVar("goog.y").getType()
.getJSDocInfo().getBlockDescription());
public void testInstanceObject() {
"/** @constructor */ function Foo() {}" +
"var f = new Foo();" +
"/** @type {number} */ f.bar = 4;");
ObjectType type = (ObjectType) globalScope.getVar("f").getType();
assertEquals("Foo", type.toString());
assertFalse(type.hasProperty("bar"));
assertNull(type.getOwnPropertyJSDocInfo("bar"));
public void testInterface() {
testInterface("var");
testInterface("let");
testInterface("const");
private void testInterface(String varOrLetOrConst) {
"/**", // preserve newlines
" * An interface.",
" * @interface",
" */",
varOrLetOrConst + " Foo = function Foo() {}",
""));
assertThat(getGlobalVarTypeJSDocInfoBlockDescription("Foo")).isEqualTo("An interface.");
private String getGlobalVarTypeJSDocInfoBlockDescription(String varName) {
TypedVar var = globalScope.getVar(varName);
assertWithMessage("%s is not defined", varName).that(var).isNotNull();
ObjectType type = (ObjectType) var.getType();
assertWithMessage("%s has no type", varName).that(type).isNotNull();
JSDocInfo jsDocInfo = type.getJSDocInfo();
assertWithMessage("%s type has no JSDocInfo", varName).that(jsDocInfo).isNotNull();
return jsDocInfo.getBlockDescription();
public void testNamespacedCtor() {
"var goog = {};" +
"/** Hello! \n * @constructor */ goog.Foo = function() {};" +
"goog.Foo.bar = goog.Foo;" +
"/** Bye! \n * @param {string=} opt_x */" +
"goog.Foo.prototype.baz = goog.Foo;" +
"/** Blargh */ var x = new goog.Foo();");
assertEquals(
"Hello!",
findGlobalNameType("x").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType("goog.Foo").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType(
"goog.Foo.bar").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType(
"goog.Foo.prototype.baz").getJSDocInfo().getBlockDescription());
ObjectType proto = (ObjectType) findGlobalNameType("goog.Foo.prototype");
assertEquals(
"Bye!",
proto.getPropertyType("baz").getJSDocInfo().getBlockDescription());
public void testAbstractMethod() {
"/** Abstract method. \n * @type {!Function} */ var abstractMethod;" +
"/** @constructor */ function Foo() {}" +
"/** Block description. \n * @param {number} x */" +
"Foo.prototype.bar = abstractMethod;");
FunctionType abstractMethod =
(FunctionType) findGlobalNameType("abstractMethod");
assertNull(abstractMethod.getJSDocInfo());
FunctionType ctor = (FunctionType) findGlobalNameType("Foo");
ObjectType proto = ctor.getInstanceType().getImplicitPrototype();
FunctionType method = (FunctionType) proto.getPropertyType("bar");
assertEquals(
"Block description.",
method.getJSDocInfo().getBlockDescription());
assertEquals(
"Block description.",
proto.getOwnPropertyJSDocInfo("bar").getBlockDescription());
public void testPrototypeObjectLiteral() {
"/** @constructor */ function Foo() {}",
FunctionType ctor = findGlobalNameType("Foo").toMaybeFunctionType();
private JSType findGlobalNameType(String name) {
return findNameType(name, globalScope);
private JSType findNameType(String name, TypedScope scope) {validateFeature(Feature.DEFAULT_PARAMETERS, n);
FeatureSet.BARE_MINIMUM.with(Feature.DEFAULT_PARAMETERS, Feature.OBJECT_PATTERN_REST);convertAsyncFunction(context);
private void convertAsyncFunction(LexicalContext functionContext) {private static final long serialVersionUID = 1L;
private int hashcode;
this.hashcode = this.alternatesWithoutStucturalTyping.hashCode();
hashcode = alternatesWithoutStucturalTyping.hashCode();
int recursionUnsafeHashCode() {
return this.hashcode;case NEW_TARGET:
case SUPER:
case ASSIGN_EXPONENT:
case EXPONENT:
validateFeature(Feature.ARROW_FUNCTIONS, n);
case OBJECTLIT:
if (!compiler.getFeatureSet().has(feature)) {
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
private static final FeatureSet transpiledFeatures =
FeatureSet.BARE_MINIMUM.with(Feature.CLASSES, Feature.SUPER);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
if (!compiler.hasHaltingErrors()) {
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, features);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, features);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
Feature.EXTENDED_OBJECT_LITERALS,
Feature.FOR_OF,
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
TranspilationPasses.markFeaturesAsTranspiledAway(compiler, transpiledFeatures);
static void markFeaturesAsTranspiledAway(
compiler.setFeatureSet(compiler.getFeatureSet().without(transpiledFeatures));
static void markFeaturesAsTranspiledAway(
compiler.setFeatureSet(
compiler.getFeatureSet().without(transpiledFeature, moreTranspiledFeatures));
markFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
markFeaturesAsTranspiledAway(compiler, featureToRemove, moreFeaturesToRemove);
.without(Feature.NEW_TARGET)
.without(Feature.SUPER);
setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);private static final long serialVersionUID = 1L;
private int hashcode;
this.hashcode = this.alternatesWithoutStucturalTyping.hashCode();
hashcode = alternatesWithoutStucturalTyping.hashCode();
public int hashCode() {
return this.hashcode;return newNode(Token.REST, transformNodeWithInlineJsDoc(tree.assignmentTarget));final ImmutableList<JSType> templateTypes;
transient TemplateTypeMapReplacer replacer;
ImmutableList<TemplateType> filledTemplateKeys =
objectType.getTemplateTypeMap().getUnfilledTemplateKeys();
for (TemplateType filledTemplateKey : filledTemplateKeys) {
builder.add(getTemplateTypeMap().getResolvedTemplateType(filledTemplateKey));
replacer = new TemplateTypeMapReplacer(registry, getTemplateTypeMap());
if (templateTypes.isEmpty()) {
public void setUp() throws Exception {
super.setUp();
private void assertTypeCanAssignToItself(JSType type) {
assertTrue(type.isSubtypeOf(type));
public void testCustomTemplatizedType() throws Exception {
FunctionType ctor =
"Foo",
ObjectType baseType = ctor.getInstanceType();
JSType templatizedType1 = registry.createTemplatizedType(
baseType, ImmutableList.of(STRING_TYPE, NUMBER_TYPE));
JSType templatizedType2 = registry.createTemplatizedType(
baseType, ImmutableList.of(STRING_TYPE, ALL_TYPE));
JSType templatizedType3 = registry.createTemplatizedType(
baseType, ImmutableList.of(STRING_TYPE, UNKNOWN_TYPE));
JSType templatizedType4 = registry.createTemplatizedType(
baseType, ImmutableList.<JSType>of(UNKNOWN_TYPE, UNKNOWN_TYPE));
assertTrue(templatizedType1.isSubtypeOf(baseType));
assertTrue(templatizedType2.isSubtypeOf(baseType));
assertTrue(templatizedType3.isSubtypeOf(baseType));
assertTrue(templatizedType4.isSubtypeOf(baseType));
assertFalse(templatizedType1.isEquivalentTo(baseType));
assertFalse(templatizedType2.isEquivalentTo(baseType));
assertFalse(templatizedType3.isEquivalentTo(baseType));
assertTrue(templatizedType4.isEquivalentTo(baseType));
assertTrue(baseType.isSubtypeOf(templatizedType1));
assertTrue(baseType.isSubtypeOf(templatizedType2));
assertTrue(baseType.isSubtypeOf(templatizedType3));
assertTrue(baseType.isSubtypeOf(templatizedType4));
assertFalse(templatizedType1.isSubtypeOf(templatizedType2));
assertFalse(templatizedType2.isSubtypeOf(templatizedType1));
assertTrue(templatizedType2.isSubtypeOf(templatizedType3));
assertTrue(templatizedType3.isSubtypeOf(templatizedType2));return ownerName + "." + getObjectLitKeyName(lValue);"var x = new ns.Foo.Bar;"));arg.getJSDocInfo().getType().evaluate(scope, typeRegistry);
"function tag(strings, /** number */ var_args){}", // preserve newlineJSType maybeThisType = null;
maybeThisType = info.getThisType().evaluate(scope, typeRegistry)
.restrictByNotNullOrUndefined();
if (maybeThisType != null) {
thisType = maybeThisType;boolean isExtern = t.getInput() != null && t.getInput().isExtern();
if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName))
&& ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {
ownerType.defineDeclaredProperty(propName, valueType, n);
private final ObjectType thisTypeForProperties;
thisTypeForProperties = getThisTypeForCollectingProperties();
if (thisTypeForProperties != null && n.getParent().isExprResult()) {
if (n.isAssign()) {
maybeCollectMember(n.getFirstChild(), n, n.getLastChild());
maybeCollectMember(n, n, null);
private ObjectType getThisTypeForCollectingProperties() {
Node rootNode = currentHoistScope.getClosestContainerScope().getRootNode();
if (rootNode.isFromExterns()) {
return null;
JSType type = rootNode.getJSType();
if (type == null || !type.isFunctionType()) {
return null;
FunctionType fnType = type.toMaybeFunctionType();
JSType fnThisType = fnType.getTypeOfThis();
return fnThisType == null ? null : fnThisType.toObjectType();
private void maybeCollectMember(Node member,
Node nodeWithJsDocInfo, @Nullable Node value) {
JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();
if (info == null || !member.isGetProp() || !member.getFirstChild().isThis()) {
return;
JSType jsType = getDeclaredType(info, member, value);
Node name = member.getLastChild();
if (jsType != null) {
thisTypeForProperties.defineDeclaredProperty(
name.getString(),
jsType,
member);
"/** @constructor */ function Extern() {}"
+ "/** @type {Extern} */ var extern;"
+ "/** @return {number} */ extern.one;"),
"/** @constructor */ function Normal() {}"
+ "/** @type {Normal} */ var normal;"
+ "/** @return {number} */ normal.one;"));
externs("/** @type {Object} */ var extern;" + "/** @return {number} */ extern.one;"),
srcs("/** @type {Object} */ var normal;" + "/** @return {number} */ normal.one;"));if (options.needsTranspilationFrom(FeatureSet.ES6)) {
if (options.needsTranspilationFrom(ES6) || options.needsTranspilationFrom(ES7)) {
FeatureSet features = (FeatureSet) script.getProp(Node.FEATURE_SET);
if (isScriptEs6OrHigher(singleRoot)) {
if (isScriptEs6OrHigher(scriptRoot)) {
test(options, "alert(2 ** 5);", "alert(Math.pow(2, 5));");public void inferSlotType(String symbol, JSType type) {
public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,
JSType inferredType, boolean declared) {
return;
return;
this.functionScope = LinkedFlowScope.createEntryLattice(syntacticScope);
inferDeclarativelyUnboundVarsWithoutTypes(functionScope);
private void inferDeclarativelyUnboundVarsWithoutTypes(FlowScope flow) {
return;
flow.inferSlotType(var.getName(), getNativeType(VOID_TYPE));
inferDeclarativelyUnboundVarsWithoutTypes(output);
redeclareSimpleVar(informed, item, iterKeyType);
redeclareSimpleVar(informed, item, newType);
redeclareSimpleVar(scope, name, type);
return scope;
updateScopeForAssignment(scope, target, targetType, valueType);
return scope;
updateScopeForAssignment(scope, left, leftType, resultType, null);
return scope;
private void updateScopeForAssignment(
updateScopeForAssignment(scope, target, targetType, resultType, target);
private void updateScopeForAssignment(
redeclareSimpleVar(scope, target, varType);
redeclareSimpleVar(scope, target, resultType);
scope.inferQualifiedSlot(
target, qualifiedName, safeLeftType, resultType, declaredSlotType);
updateScopeForAssignment(scope, n, n.getJSType() /* could be null */, getJSType(value));
return scope;
updateScopeForAssignment(scope, n, type, resultType);
scope.inferQualifiedSlot(name, qKeyName,
oldType == null ? unknownType : oldType,
valueType, false);
updateScopeForAssignment(scope, left, leftType, type);
scope.inferQualifiedSlot(
redeclareSimpleVar(scope, node, narrowed);
return scope;
private void redeclareSimpleVar(FlowScope scope, Node nameNode, JSType varType) {
return;
scope.inferSlotType(varName, varType);
protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
scope.inferSlotType(node.getString(), type);
break;
scope.inferQualifiedSlot(node, qualifiedName, origType, type, false);
break;
break;
private FlowScope restrictParameter(Node parameter, JSType type,
FlowScope blindScope, Function<TypeRestriction, JSType> restriction,
declareNameInScope(informed, parameter, type);
return informed;
void inferSlotType(String symbol, JSType type);
void inferQualifiedSlot(Node node, String symbol, JSType bottomType,
JSType inferredType, boolean declare);
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
FlowScope blindScope, boolean outcome) {
private FlowScope caseEquality(Node condition, FlowScope blindScope,
Function<TypePair, TypePair> merging) {
private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,
Function<TypePair, TypePair> merging) {
private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,
FlowScope blindScope, boolean outcome) {
private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,
FlowScope blindScope, boolean outcome) {
informed.inferSlotType(leftVar.getName(), type);
return informed;
private FlowScope maybeRestrictName(FlowScope blindScope, Node node,
JSType originalType, JSType restrictedType) {
declareNameInScope(informed, node, restrictedType);
return informed;
Node left, JSType originalLeftType, JSType restrictedLeftType,
Node right, JSType originalRightType, JSType restrictedRightType) {
declareNameInScope(informed, left, restrictedLeftType);
declareNameInScope(informed, right, restrictedRightType);
private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,
boolean outcome) {
private FlowScope caseTypeOf(Node node, JSType type, String value,
boolean resultEqualsValue, FlowScope blindScope) {
private FlowScope caseInstanceOf(Node left, Node right, FlowScope blindScope,
boolean outcome) {
JSType unknownType = typeRegistry.getNativeType(
JSTypeNative.UNKNOWN_TYPE);
informed.inferQualifiedSlot(
return informed;
private class RestrictByTrueInstanceOfResultVisitor
extends RestrictByTrueTypeOfResultVisitor {
public void inferSlotType(String symbol, JSType type) {
delegate.inferSlotType(symbol, type);
public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,
JSType inferredType, boolean declare) {
delegate.inferQualifiedSlot(node, symbol, bottomType, inferredType, declare);
FlowScope optimized = delegate.optimize();
return optimized != delegate ? new RefinementTrackingFlowScope(optimized, refinements) : this;
flowScope.inferSlotType("a", type);
child.inferSlotType("localB", getNativeNumberType());
childA.inferSlotType("localB", getNativeNumberType());
childAB.inferSlotType("localB", getNativeStringType());
childB.inferSlotType("localB", getNativeBooleanType());
childA.inferSlotType("localA", getNativeStringType());
childB.inferSlotType("globalB", getNativeBooleanType());
childA.inferSlotType("localC", getNativeNumberType());
childA.inferSlotType("localD", getNativeBooleanType());
chainA.inferSlotType(
"local" + i, i % 2 == 0 ? getNativeNumberType() : getNativeBooleanType());
chainB.inferSlotType(
"local" + i, i % 3 == 0 ? getNativeStringType() : getNativeBooleanType());
chainA.inferSlotType(
"local" + i, i % 2 == 0 ? getNativeNumberType() : getNativeBooleanType());
chainB.inferSlotType(
"local" + i, i % 3 == 0 ? getNativeStringType() : getNativeBooleanType());
chainA.inferSlotType(
"local" + j, j % 2 == 0 ? getNativeNumberType() : getNativeBooleanType());
chainB.inferSlotType(
"local" + j, j % 3 == 0 ? getNativeStringType() : getNativeBooleanType());
childA.inferSlotType("localB", getNativeNumberType());
childAB.inferSlotType("localB", getNativeStringType());
childABC.inferSlotType("localA", getNativeBooleanType());
childB.inferSlotType("localB", getNativeStringType());
childBC.inferSlotType("localA", getNativeNoType());
childA.inferSlotType("localA", getNativeNumberType());
childB.inferSlotType("localA", getNativeNoType());
public FlowScope newScope() {
return LinkedFlowScope.createEntryLattice(functionScope);
FlowScope blind = newScope();
FlowScope informedTrue = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, true);
FlowScope informedFalse = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, false);
FlowScope blind = newScope();
FlowScope informedTrue = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, true);
FlowScope informedFalse = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, false);
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
FlowScope blind = newScope();
private void testBinop(FlowScope blind, Token binop, Node left, Node right,
FlowScope informedTrue = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, true);
FlowScope informedFalse = interpreter.
getPreciserScopeKnowingConditionOutcome(condition, blind, false);
private Node createVar(FlowScope scope, String name, JSType type) {
scope.inferSlotType(name, type);ModuleLoader.PathResolver.RELATIVE,
options.moduleResolutionMode,
inputPathByWebpackId);
if (options.moduleResolutionMode == ModuleLoader.ResolutionMode.NODE) {
this.moduleLoader =
new ModuleLoader(
null,
options.moduleRoots,
inputs,
ModuleLoader.PathResolver.RELATIVE,
options.moduleResolutionMode,
processJsonInputs(inputs));
ModuleLoader.ResolutionMode moduleResolutionMode;
public ModuleLoader.ResolutionMode getModuleResolutionMode() {
public void setModuleResolutionMode(ModuleLoader.ResolutionMode mode) {
this.moduleResolutionMode = mode;
"BROWSER"));
ModuleLoader.ModulePath path = file.resolveJsModule(arg);
if (path == null) {
path = file.resolveModuleAsPath(arg);
import java.util.HashMap;
import java.util.Map.Entry;
PathResolver pathResolver,
ResolutionMode resolutionMode,
Map<String, String> lookupMap) {
switch (resolutionMode) {
case BROWSER:
this.moduleResolver =
new BrowserModuleResolver(this.modulePaths, this.moduleRootPaths, this.errorHandler);
break;
case NODE:
this.moduleResolver =
new NodeModuleResolver(
this.modulePaths, this.moduleRootPaths, lookupMap, this.errorHandler);
break;
case WEBPACK:
Map<String, String> normalizedPathsById = new HashMap<>();
for (Entry<String, String> moduleEntry : lookupMap.entrySet()) {
String canonicalizedPath =
normalize(ModuleNames.escapePath(moduleEntry.getValue()), moduleRootPaths);
if (isAmbiguousIdentifier(canonicalizedPath)) {
canonicalizedPath = MODULE_SLASH + canonicalizedPath;
normalizedPathsById.put(moduleEntry.getKey(), canonicalizedPath);
this.moduleResolver =
new WebpackModuleResolver(
this.modulePaths, this.moduleRootPaths, normalizedPathsById, this.errorHandler);
break;
default:
throw new RuntimeException("Unexpected resolution mode " + resolutionMode);
public ModuleLoader(
Iterable<String> moduleRoots,
Iterable<? extends DependencyInfo> inputs,
ResolutionMode resolutionMode) {
this(errorHandler, moduleRoots, inputs, PathResolver.RELATIVE, resolutionMode);
PathResolver pathResolver,
ResolutionMode resolutionMode) {
this(errorHandler, moduleRoots, inputs, pathResolver, resolutionMode, null);
if (!moduleAddress.endsWith(".js")) {
moduleAddress += ".js";
String path = ModuleNames.escapePath(moduleAddress);
if (isRelativeIdentifier(moduleAddress)) {
String ourPath = this.path;
int lastIndex = ourPath.lastIndexOf(MODULE_SLASH);
path =
ModuleNames.canonicalizePath(
ourPath.substring(0, lastIndex + MODULE_SLASH.length()) + path);
return new ModulePath(normalize(path, moduleRootPaths));
private static String normalize(String path, Iterable<String> moduleRootPaths) {
null,
ResolutionMode.BROWSER);
WEBPACK
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.PathResolver.ABSOLUTE,
ModuleLoader.ResolutionMode.BROWSER));
ImmutableList.<DependencyInfo>of(),
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.NODE);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.NODE,
packageJsonMainEntries);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.NODE,
packageJsonMainEntries);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.NODE,
packageJsonMainEntries);
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.BROWSER);
null, ImmutableList.of("a", "b", "/c"), inputs(), ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.ResolutionMode.BROWSER);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.NODE,
packageJsonMainEntries);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.NODE,
packageJsonMainEntries);
ModuleLoader.PathResolver.RELATIVE,
ModuleLoader.ResolutionMode.WEBPACK,
webpackModulesById);if (!nodes.isEmpty() && windowInExterns) {
addExtern(node);
private static void addExtern(Node node) {
Node window = IR.name("window");
Node getprop = IR.getprop(window, string);
if (c.getString().equals("window")) {
testExternChanges("var a", "", "var a");
testExternChanges("function f() {}", "var b", "function f(){}");
testExternChanges("var x = function f() {}", "var b", "var x=function f(){}");
"('undefined'!=typeof window&&window===this?this:'undefined'!=typeof ",
"global&&null!=global?global:this).",
"c.defineProperties(function() {},",
"{e:{a:!0,b:!0,d:function(){}},",  // renamed from init
"f:{a:!0,b:!0,g:function(){}}})");  // renamed from prop
options.declaredGlobalExternsOnWindow = false;
SymbolTable table =
createSymbolTable("var x = this; function f() { return this + this + this; }");
SymbolTable table = createSymbolTable("");
SymbolTable table = createSymbolTable("this.foo = {}; this.foo.bar = {};");
assertThat(refs).hasSize(2);private static final String WINDOW_NAME = "window";
if (!nodes.isEmpty()) {
addExtern(node, windowInExterns);
private static void addExtern(Node node, boolean defineOnWindow) {
Node globalRef = defineOnWindow ? IR.name(WINDOW_NAME) : IR.thisNode();
Node getprop = IR.getprop(globalRef, string);
if (c.getString().equals(WINDOW_NAME)) {
testExternChanges("var a;", "", "var a;this.a");
testExternChanges("function f() {}", "var b", "function f(){}this.f");
testExternChanges("var x = function f() {};", "var b", "var x=function f(){};this.x");
"('undefined'!=typeof window&&window===this?this:'undefined'!=typeof ",
"global&&null!=global?global:this).",
"Object.defineProperties(function() {},",
"{d:{a:!0,b:!0,c:function(){}},", // renamed from init
"e:{a:!0,b:!0,f:function(){}}})"); // renamed from prop
SymbolTable table = createSymbolTable(
"var x = this; function f() { return this + this + this; }",
SymbolTable table = createSymbolTable("", /* externsCode= */ "");
SymbolTable table =
createSymbolTable("this.foo = {}; this.foo.bar = {};", /* externsCode= */ "");
assertThat(refs).hasSize(3);
private SymbolTable createSymbolTable(String input, String externsCode) {
List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", input));
List<SourceFile> externs = ImmutableList.of(SourceFile.fromCode("externs1", externsCode));
Compiler compiler = new Compiler(new BlackHoleErrorManager());
compiler.compile(externs, inputs, options);
return assertSymbolTableValid(compiler.buildKnownSymbolTable());if (!nodes.isEmpty() && windowInExterns) {
addExtern(node);
private static void addExtern(Node node) {
Node window = IR.name("window");
Node getprop = IR.getprop(window, string);
if (c.getString().equals("window")) {
testExternChanges("var a", "", "var a");
testExternChanges("function f() {}", "var b", "function f(){}");
testExternChanges("var x = function f() {}", "var b", "var x=function f(){}");
"('undefined'!=typeof window&&window===this?this:'undefined'!=typeof ",
"global&&null!=global?global:this).",
"c.defineProperties(function() {},",
"{e:{a:!0,b:!0,d:function(){}},",  // renamed from init
"f:{a:!0,b:!0,g:function(){}}})");  // renamed from prop
options.declaredGlobalExternsOnWindow = false;
SymbolTable table =
createSymbolTable("var x = this; function f() { return this + this + this; }");
SymbolTable table = createSymbolTable("");
SymbolTable table = createSymbolTable("this.foo = {}; this.foo.bar = {};");
assertThat(refs).hasSize(2);private void expectNoTypeInformation(Node n) {
TypeI typeI = n.getTypeI();
if (typeI != null) {
violation("Unexpected type information: " + getTypeAnnotationString(typeI), n);
violation("Type information missing", n);
IR.call(createGenerator, genFuncName.cloneNode(), program),
expression == null ? IR.name("undefined").useSourceInfoFrom(sourceNode) : expression);
Node newThis = context.getScopedName(GENERATOR_THIS).useSourceInfoFrom(n);
"/** @constructor */ function f() {}\n" +
"f.prototype.init_f = function() {" +
"  /** @const */ this.foo = !!unknown;" +
"};" +
"var x = new f();");
"/** @constructor */ function f() {}\n" +
"f.prototype.init_f = function() {" +
"  /** @const */ this.foo = +unknown;" +
"};" +
"var x = new f();");
"/** @constructor */ function f() {}\n" +
"f.prototype.init_f = function() {" +
"  /** @const */ this.foo = unknown + '';" +
"};" +
"var x = new f();");
"var goog = {};\n" +
"goog.array = {};\n" +
"/**\n" +
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, !T, number, !Array<!T>):boolean} f\n" +
" * @param {!S=} opt_obj\n" +
" * @return {!Array<T>}\n" +
" * @template T,S\n" +
" */\n" +
"goog.array.filter = function(arr, f, opt_obj) {\n" +
"  var res = [];\n" +
"  for (var i = 0; i < arr.length; i++) {\n" +
"     if (f.call(opt_obj, arr[i], i, arr)) {\n" +
"        res.push(val);\n" +
"     }\n" +
"  }\n" +
"  return res;\n" +
"}" +
"/** @constructor */\n" +
"function Foo() {}\n" +
"/** @type {Array<string>} */\n" +
"var arr = [];\n" +
"var result = goog.array.filter(arr," +
"  function(a,b,c) {var self=this;}, new Foo());");
"var goog = {};\n" +
"goog.array = {};\n" +
"/**\n" +
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, !T, number, !Array<T>):boolean} f\n" +
" * @param {!S=} opt_obj\n" +
" * @return {!Array<T>}\n" +
" * @template T,S\n" +
" */\n" +
"goog.array.filter = function(arr, f, opt_obj) {\n" +
"  var res = [];\n" +
"  for (var i = 0; i < arr.length; i++) {\n" +
"     if (f.call(opt_obj, arr[i], i, arr)) {\n" +
"        res.push(val);\n" +
"     }\n" +
"  }\n" +
"  return res;\n" +
"}" +
"/** @constructor */\n" +
"function Foo() {}\n" +
"/** @type {Array<string>} */\n" +
"var arr = [];\n" +
"var result = goog.array.filter(arr," +
"  function(a,b,c) {var self=this;}, new Foo());");
"var goog = {};\n" +
"goog.array = {};\n" +
"/**\n" +
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, T, number, Array<T>):boolean} f\n" +
" * @param {!S=} opt_obj\n" +
" * @return {!Array<T>}\n" +
" * @template T,S\n" +
" */\n" +
"goog.array.filter = function(arr, f, opt_obj) {\n" +
"  var res = [];\n" +
"  for (var i = 0; i < arr.length; i++) {\n" +
"     if (f.call(opt_obj, arr[i], i, arr)) {\n" +
"        res.push(val);\n" +
"     }\n" +
"  }\n" +
"  return res;\n" +
"}" +
"/** @constructor */\n" +
"function Foo() {}\n" +
"/** @type {Array<string>} */\n" +
"var arr = [];\n" +
"var result = goog.array.filter(arr," +
"  function(a,b,c) {var self=this;}, new Foo());");
"/**\n" +
" * @constructor\n" +
" * @template T\n" +
" */\n" +
"function C() {};\n" +
"" +
"C.prototype.method = function() {\n" +
"  var local = /** @type {T} */ (x);" +
"}\n");protected JSType MATH_TYPE;
protected JSType NUMBER_STRING_BOOLEAN_SYMBOL;
protected JSType OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL;
protected JSType SYMBOL_OBJECT_FUNCTION_TYPE;
NUMBER_STRING_BOOLEAN_SYMBOL =
registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN_SYMBOL);
OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL =
registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL);
SYMBOL_OBJECT_FUNCTION_TYPE =
registry.getNativeType(JSTypeNative.SYMBOL_OBJECT_FUNCTION_TYPE);
protected final void assertTypeNotEquals(String msg, JSType a, JSType b) {
Asserts.assertTypeNotEquals(msg, a, b);
testClosureFunction("goog.isDef",
createOptionalType(NUMBER_TYPE),
NUMBER_TYPE,
VOID_TYPE);
testClosureFunction("goog.isDef",
createNullableType(NUMBER_TYPE),
createNullableType(NUMBER_TYPE),
NO_TYPE);
testClosureFunction("goog.isDef",
ALL_TYPE,
createUnionType(OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL, NULL_TYPE),
VOID_TYPE);
testClosureFunction("goog.isDef",
UNKNOWN_TYPE,
UNKNOWN_TYPE,  // TODO(johnlenz): should be CHECKED_UNKNOWN_TYPE
UNKNOWN_TYPE);
testClosureFunction("goog.isNull",
createOptionalType(NUMBER_TYPE),
NO_TYPE,
createOptionalType(NUMBER_TYPE));
testClosureFunction("goog.isNull",
createNullableType(NUMBER_TYPE),
NULL_TYPE,
NUMBER_TYPE);
testClosureFunction("goog.isNull",
ALL_TYPE,
NULL_TYPE,
createUnionType(OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL, VOID_TYPE));
testClosureFunction("goog.isNull",
UNKNOWN_TYPE,
UNKNOWN_TYPE,
UNKNOWN_TYPE); // TODO(johnlenz): this should be CHECK_UNKNOWN
testClosureFunction("goog.isDefAndNotNull",
createOptionalType(NUMBER_TYPE),
NUMBER_TYPE,
VOID_TYPE);
testClosureFunction("goog.isDefAndNotNull",
createNullableType(NUMBER_TYPE),
NUMBER_TYPE,
NULL_TYPE);
testClosureFunction("goog.isDefAndNotNull",
createOptionalType(createNullableType(NUMBER_TYPE)),
NUMBER_TYPE,
NULL_VOID);
testClosureFunction("goog.isDefAndNotNull",
ALL_TYPE,
OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL,
NULL_VOID);
testClosureFunction("goog.isDefAndNotNull",
UNKNOWN_TYPE,
UNKNOWN_TYPE,  // TODO(johnlenz): this should be "CHECKED_UNKNOWN"
UNKNOWN_TYPE);
testClosureFunction("goog.isString",
createNullableType(STRING_TYPE),
STRING_TYPE,
NULL_TYPE);
testClosureFunction("goog.isString",
createNullableType(NUMBER_TYPE),
createNullableType(NUMBER_TYPE),
createNullableType(NUMBER_TYPE));
testClosureFunction("goog.isBoolean",
createNullableType(BOOLEAN_TYPE),
BOOLEAN_TYPE,
NULL_TYPE);
testClosureFunction("goog.isBoolean",
createUnionType(BOOLEAN_TYPE, STRING_TYPE, NO_OBJECT_TYPE),
BOOLEAN_TYPE,
createUnionType(STRING_TYPE, NO_OBJECT_TYPE));
testClosureFunction("goog.isBoolean",
ALL_TYPE,
BOOLEAN_TYPE,
ALL_TYPE); // TODO(johnlenz): this should be:
testClosureFunction("goog.isBoolean",
UNKNOWN_TYPE,
BOOLEAN_TYPE,
CHECKED_UNKNOWN_TYPE);
testClosureFunction("goog.isNumber",
createNullableType(NUMBER_TYPE),
NUMBER_TYPE,
NULL_TYPE);
testClosureFunction("goog.isFunction",
createNullableType(OBJECT_FUNCTION_TYPE),
OBJECT_FUNCTION_TYPE,
NULL_TYPE);
testClosureFunction("goog.isFunction",
OBJECT_NUMBER_STRING_BOOLEAN,
U2U_CONSTRUCTOR_TYPE,
OBJECT_NUMBER_STRING_BOOLEAN);
testClosureFunction("goog.isFunction",
OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL,
U2U_CONSTRUCTOR_TYPE,
OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL);
testClosureFunction("goog.isFunction",
createUnionType(U2U_CONSTRUCTOR_TYPE, NUMBER_STRING_BOOLEAN),
U2U_CONSTRUCTOR_TYPE,
NUMBER_STRING_BOOLEAN);
testClosureFunction("goog.isFunction",
null,
U2U_CONSTRUCTOR_TYPE,
null);
testClosureFunction("goog.isArray",
OBJECT_TYPE,
ARRAY_TYPE,
OBJECT_TYPE);
testClosureFunction("goog.isArray",
ALL_TYPE,
ARRAY_TYPE,
ALL_TYPE);
testClosureFunction("goog.isArray",
UNKNOWN_TYPE,
CHECKED_UNKNOWN_TYPE,
CHECKED_UNKNOWN_TYPE);
testClosureFunction("goog.isArray",
createUnionType(ARRAY_TYPE, NULL_TYPE),
ARRAY_TYPE,
NULL_TYPE);
testClosureFunction("goog.isArray",
null,
ARRAY_TYPE,
null);
testClosureFunction("goog.isObject",
null,
OBJECT_TYPE,
null);
testClosureFunction("goog.isObject",
ALL_TYPE,
NO_OBJECT_TYPE,
createUnionType(NUMBER_STRING_BOOLEAN_SYMBOL, NULL_TYPE, VOID_TYPE));
testClosureFunction("goog.isObject",
createUnionType(OBJECT_TYPE, NUMBER_STRING_BOOLEAN),
OBJECT_TYPE,
NUMBER_STRING_BOOLEAN);
testClosureFunction("goog.isObject",
createUnionType(OBJECT_TYPE, NUMBER_STRING_BOOLEAN_SYMBOL),
OBJECT_TYPE,
NUMBER_STRING_BOOLEAN_SYMBOL);
testClosureFunction("goog.isObject",
createUnionType(
OBJECT_TYPE, NUMBER_STRING_BOOLEAN, NULL_TYPE, VOID_TYPE),
OBJECT_TYPE,
createUnionType(NUMBER_STRING_BOOLEAN, NULL_TYPE, VOID_TYPE));
testClosureFunction("goog.isObject",
createUnionType(
OBJECT_TYPE, NUMBER_STRING_BOOLEAN_SYMBOL, NULL_TYPE, VOID_TYPE),
OBJECT_TYPE,
createUnionType(NUMBER_STRING_BOOLEAN_SYMBOL, NULL_TYPE, VOID_TYPE));
testClosureFunction("goog.isObject",
UNKNOWN_TYPE,
NO_OBJECT_TYPE,  // ? Should this be CHECKED_UNKNOWN?
CHECKED_UNKNOWN_TYPE);
import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
abstract class CompilerTypeTestCase extends BaseJSTypeTestCase {
initTypes();
child.inferSlotType("localB", NUMBER_TYPE);
childA.inferSlotType("localB", NUMBER_TYPE);
childAB.inferSlotType("localB", STRING_TYPE);
childB.inferSlotType("localB", BOOLEAN_TYPE);
assertTypeEquals(STRING_TYPE, childAB.getSlot("localB").getType());
assertTypeEquals(BOOLEAN_TYPE, childB.getSlot("localB").getType());
assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),
assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),
childA.inferSlotType("localA", STRING_TYPE);
childB.inferSlotType("globalB", BOOLEAN_TYPE);
assertTypeEquals(STRING_TYPE, childA.getSlot("localA").getType());
assertTypeEquals(BOOLEAN_TYPE, childB.getSlot("globalB").getType());
assertTypeEquals(STRING_TYPE, joined.getSlot("localA").getType());
assertTypeEquals(BOOLEAN_TYPE, joined.getSlot("globalB").getType());
assertTypeEquals(STRING_TYPE, joined.getSlot("localA").getType());
assertTypeEquals(BOOLEAN_TYPE, joined.getSlot("globalB").getType());
localScope.declare("localC", null, STRING_TYPE, null);
localScope.declare("localD", null, STRING_TYPE, null);
childA.inferSlotType("localC", NUMBER_TYPE);
childA.inferSlotType("localD", BOOLEAN_TYPE);
assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),
assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),
assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),
assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),
chainA.inferSlotType("local" + i,
i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);
chainB.inferSlotType("local" + i,
i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);
chainA.inferSlotType("local" + i,
i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);
chainB.inferSlotType("local" + i,
i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);
chainA.inferSlotType("local" + j,
j % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);
chainB.inferSlotType("local" + j,
j % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);
i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE,
i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE,
assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joinedSlotType);
assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),
joinedSlotType);
assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),
joinedSlotType);
assertTypeEquals(BOOLEAN_TYPE, joinedSlotType);
childA.inferSlotType("localB", NUMBER_TYPE);
childAB.inferSlotType("localB", STRING_TYPE);
childABC.inferSlotType("localA", BOOLEAN_TYPE);
assertTypeEquals(BOOLEAN_TYPE,
childABC.findUniqueRefinedSlot(childAB).getType());
assertTypeEquals(STRING_TYPE,
childAB.findUniqueRefinedSlot(childA).getType());
assertTypeEquals(STRING_TYPE,
childAB.findUniqueRefinedSlot(localEntry).getType());
assertTypeEquals(NUMBER_TYPE,
childA.findUniqueRefinedSlot(localEntry).getType());
childA.inferSlotType("localB", NUMBER_TYPE);
childAB.inferSlotType("localB", STRING_TYPE);
childABC.inferSlotType("localA", BOOLEAN_TYPE);
childB.inferSlotType("localB", STRING_TYPE);
childBC.inferSlotType("localA", NO_TYPE);
childA.inferSlotType("localA", NUMBER_TYPE);
childB.inferSlotType("localA", NO_TYPE);
Node condition = createVar(blind, "a", createNullableType(STRING_TYPE));
assertTypeEquals(STRING_TYPE, getVarType(informedTrue, "a"));
assertTypeEquals(createNullableType(STRING_TYPE),
getVarType(informedFalse, "a"));
Node a = createVar(blind, "a", createNullableType(STRING_TYPE));
assertTypeEquals(createNullableType(STRING_TYPE),
getVarType(informedTrue, "a"));
assertTypeEquals(STRING_TYPE, getVarType(informedFalse, "a"));
testBinop(blind,
createVar(blind, "a", createNullableType(OBJECT_TYPE)),
createVar(blind, "b", createNullableType(OBJECT_TYPE)),
new TypedName("a", OBJECT_TYPE),
new TypedName("b", OBJECT_TYPE)),
new TypedName("a", NULL_TYPE),
new TypedName("b", NULL_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a", NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE))));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a", NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE))));
testBinop(blind,
createVar(blind, "b", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a", STRING_TYPE),
new TypedName("b", STRING_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE)),
new TypedName("b",
createUnionType(STRING_TYPE, BOOLEAN_TYPE))));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(VOID_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)),
ImmutableSet.of(new TypedName("a", STRING_TYPE),
new TypedName("b", VOID_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(NULL_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(VOID_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)),
ImmutableSet.of(new TypedName("a", NULL_TYPE),
new TypedName("b", VOID_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(NUMBER_TYPE, VOID_TYPE)),
new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)),
new TypedName("a",
createUnionType(STRING_TYPE, VOID_TYPE)),
new TypedName("b",
createUnionType(NUMBER_TYPE, VOID_TYPE))));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE))),
ImmutableSet.of(new TypedName("a", NUMBER_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE))),
ImmutableSet.of(new TypedName("a", NUMBER_TYPE)));
testBinop(blind,
createVar(blind, "b", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),
createVar(blind, "a", createUnionType(STRING_TYPE, NUMBER_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE)),
new TypedName("b",
createUnionType(STRING_TYPE, BOOLEAN_TYPE))),
ImmutableSet.of(new TypedName("a", STRING_TYPE),
new TypedName("b", STRING_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(VOID_TYPE)),
ImmutableSet.of(new TypedName("a", STRING_TYPE),
new TypedName("b", VOID_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(NULL_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(NULL_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE),
new TypedName("b", NULL_TYPE)),
ImmutableSet.of(new TypedName("a", NULL_TYPE),
new TypedName("b", NULL_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
createVar(blind, "b", createUnionType(NUMBER_TYPE, VOID_TYPE)),
new TypedName("a",
createUnionType(STRING_TYPE, VOID_TYPE)),
new TypedName("b",
createUnionType(NUMBER_TYPE, VOID_TYPE))),
new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE)),
ImmutableSet.of(new TypedName("a", BOOLEAN_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),
ImmutableSet.of(new TypedName("a", BOOLEAN_TYPE)),
ImmutableSet.of(new TypedName("a", VOID_TYPE)));
createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE);
JSType nullUndefined =
createUnionType(VOID_TYPE, NULL_TYPE);
testBinop(blind,
ImmutableSet.of(new TypedName("a", NUMBER_TYPE)));
testBinop(blind,
createVar(blind, "a", VOID_TYPE),
createVar(blind, "b", VOID_TYPE),
new TypedName("a", VOID_TYPE),
new TypedName("b", VOID_TYPE)),
new TypedName("a", NO_TYPE),
new TypedName("b", NO_TYPE)));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
new TypedName("a", STRING_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, VOID_TYPE))));
testBinop(blind,
createVar(blind, "a",
createUnionType(STRING_TYPE, NUMBER_TYPE, VOID_TYPE)),
createVar(blind, "b",
createUnionType(NUMBER_TYPE, NULL_TYPE)),
new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE)),
new TypedName("b",
createUnionType(NUMBER_TYPE, NULL_TYPE))),
new TypedName("a",
createUnionType(STRING_TYPE, NUMBER_TYPE, VOID_TYPE)),
new TypedName("b",
createUnionType(NUMBER_TYPE, NULL_TYPE))));
testBinop(blind,
createVar(blind, "a", createUnionType(STRING_TYPE, VOID_TYPE)),
new TypedName("a", STRING_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(STRING_TYPE, VOID_TYPE))));
testBinop(blind,
Token.AND,
createVar(blind, "b", createUnionType(STRING_TYPE, NULL_TYPE)),
createVar(blind, "a", createUnionType(NUMBER_TYPE, VOID_TYPE)),
ImmutableSet.of(new TypedName("a", NUMBER_TYPE),
new TypedName("b", STRING_TYPE)),
ImmutableSet.of(new TypedName("a",
createUnionType(NUMBER_TYPE, VOID_TYPE)),
new TypedName("b",
createUnionType(STRING_TYPE, NULL_TYPE))));
testBinop(blind,
new Node(Token.TYPEOF, createVar(blind, "a", OBJECT_TYPE)),
ImmutableSet.of(
new TypedName("a", U2U_CONSTRUCTOR_TYPE)),
ImmutableSet.of(
new TypedName("a", OBJECT_TYPE)));
testBinop(blind,
new Node(Token.TYPEOF, createVar(blind, "a", ALL_TYPE)),
ImmutableSet.of(
new TypedName("a", U2U_CONSTRUCTOR_TYPE)),
ImmutableSet.of(
new TypedName("a", ALL_TYPE)));
testBinop(blind,
new Node(Token.TYPEOF, createVar(
blind, "a", OBJECT_NUMBER_STRING_BOOLEAN)),
ImmutableSet.of(
new TypedName("a", U2U_CONSTRUCTOR_TYPE)),
ImmutableSet.of(
new TypedName("a", OBJECT_NUMBER_STRING_BOOLEAN)));
testBinop(blind,
new Node(Token.TYPEOF, createVar(
blind, "a", createUnionType(
U2U_CONSTRUCTOR_TYPE, NUMBER_STRING_BOOLEAN))),
ImmutableSet.of(
new TypedName("a", U2U_CONSTRUCTOR_TYPE)),
ImmutableSet.of(
new TypedName("a", NUMBER_STRING_BOOLEAN)));
testBinop(blind,
createVar(blind, "x", UNKNOWN_TYPE),
createVar(blind, "s", STRING_OBJECT_FUNCTION_TYPE),
ImmutableSet.of(
new TypedName("x", STRING_OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)));
testBinop(blind,
createVar(blind, "x",
createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE)),
createVar(blind, "s", STRING_OBJECT_FUNCTION_TYPE),
new TypedName("x", STRING_OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)),
new TypedName("x", NUMBER_OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)));
testBinop(blind,
createVar(blind, "x", OBJECT_TYPE),
createVar(blind, "s", STRING_OBJECT_FUNCTION_TYPE),
new TypedName("x", STRING_OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)),
new TypedName("x", OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)));
testBinop(blind,
createVar(blind, "x", ALL_TYPE),
createVar(blind, "s", STRING_OBJECT_FUNCTION_TYPE),
ImmutableSet.of(
new TypedName("x", STRING_OBJECT_TYPE),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)),
new TypedName("s", STRING_OBJECT_FUNCTION_TYPE)));
n.setJSType(NULL_TYPE);
number.setJSType(NUMBER_TYPE);
assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType());
assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,
s.getVar("Boolean").getType());
assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar("Date").getType());
assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar("Error").getType());
assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE,
s.getVar("EvalError").getType());
assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE,
s.getVar("Number").getType());
assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar("Object").getType());
assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE,
s.getVar("RangeError").getType());
assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE,
s.getVar("ReferenceError").getType());
assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar("RegExp").getType());
assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE,
s.getVar("String").getType());
assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE,
s.getVar("SyntaxError").getType());
assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE,
s.getVar("TypeError").getType());
assertTypeEquals(URI_ERROR_FUNCTION_TYPE,
s.getVar("URIError").getType());
testTypes("/** @param {string} x */ function f(x) {}" +
"f([].length);" ,
"actual parameter 1 of f does not match formal parameter\n" +
"found   : number\n" +
"required: string");
testTypes("/** @param {number|string} x\n@return {string} */\n" +
"function f(x) {\n" +
"return typeof x == 'string' && x.length == 3 ? x : 'a';\n" +
"}");
testTypes(
testTypes(
testTypes(
testTypes(
testTypes("/** @constructor */function O() {};" +
"/**@override*/O.prototype.valueOf = function() { return 1; };" +
"/**@param {!O} a\n@param {!O} b*/ function f(a,b) { return a < b; }");
testTypes("/** @constructor */function O() {};" +
"/**@override*/O.prototype.valueOf = function() { return 1; };" +
"/**@param {!O} a\n@param {number} b*/" +
"function f(a,b) { return a < b; }");
testTypes("/** @constructor */function O() {};" +
"/**@override*/O.prototype.toString = function() { return 'o'; };" +
"/**@param {!O} a\n@param {string} b*/" +
"function f(a,b) { return a < b; }");
testTypes(lines(
"/**",
" * @template T",
" * @param {...number} x",
" */",
"function f(...x) {",
"  var /** string */ s = x[0];",
"}"),
"initializing variable",
testTypes(lines(
"/**",
" * @constructor",
" * @template T",
" */",
"function Foo() {}",
"/**",
" * @template T",
" * @param {...!Foo<T>} x",
" */",
"function f(...x) {",
"  return 123;",
"}"));
"/** @constructor */ function f() { " +
"  /** @type {Function} */ this.foo;" +
"}",
createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
"/** @constructor */ function f() {} " +
"/** @type {Function} */ f.prototype.foo;",
createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
"/** @constructor */ function f() {} " +
"/** @type {Function} */ f.prototype.foo = function() {};",
createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
testTypes(
"/** @param {boolean} x */ function f(x) {}" +
"/** @constructor */ var E = function(){};" +
"/** @override */ E.prototype.toString = function() { return ''; };" +
"/** @type {Object<!E, number>} */ var obj = {};" +
"for (var k in obj) {" +
"  f(k);" +
"}",
"actual parameter 1 of f does not match formal parameter\n" +
"found   : string\n" +
"required: boolean");
assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE),
p.scope.getVar("a").getType());
assertTypeEquals(NUMBER_TYPE, p.scope.getVar("a").getType());
assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),
testTypes(
"/** @constructor */ function F() {}" +
"F.prototype.moveTo = function(x, y) {};" +
"F.prototype.lineTo = function(x, y) {};" +
"function demo() {" +
"  var path = new F();" +
"  var points = [[1,1], [2,2]];" +
"  for (var i = 0; i < points.length; i++) {" +
"    (i == 0 ? path.moveTo : path.lineTo)(" +
"       points[i][0], points[i][1]);" +
"  }" +
"}",
"\"function(this:F, ?, ?): undefined\" " +
"must be called with a \"this\" type");
assertTypeEquals(NUMBER_TYPE, n.getJSType());
assertTypeEquals(STRING_TYPE, n.getJSType());
assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType());
assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType());
assertTypeEquals(VOID_TYPE, n.getJSType());
testTypes(
"Array.indexOf = function() {};" +
"var s = 'hello';" +
"alert(s.toLowerCase.indexOf('1'));",
testTypes(
"/** @type { function(string): {innerHTML: string} } */\n" +
"document.getElementById;\n" +
"var list = /** @type {!Array<string>} */ ['hello', 'you'];\n" +
"list.push('?');\n" +
"document.getElementById('node').innerHTML = list.toString();");
testTypes(
"/** @constructor */ function C() {" +
"  /** @type {?Array} */ this.a = [];" +
"}" +
"C.prototype.f = function() {" +
"  if (this.a.length > 0) {" +
"    g(this.a);" +
"  }" +
"};" +
"/** @param {number} a */ function g(a) {}",
"actual parameter 1 of g does not match formal parameter\n" +
"found   : Array\n" +
"required: number");
testTypes("/** @type {String} */var s = new String('foo');" +
"var b = s.match(/a/) != null;");
testTypes(
"/**\n" +
" * @param {Array<T>} x\n" +
" * @param {function(T)} y\n" +
" * @template T\n" +
" */\n" +
"var forEach = function(x, y) {\n" +
"  for (var i = 0; i < x.length; i++) y(x[i]);\n" +
"};" +
"/** @param {number} x */" +
"function f(x) {}" +
"/** @param {?} x */" +
"function h(x) {" +
"  var top = null;" +
"  forEach(x, function(z) { top = z; });" +
"  if (top) f(top);" +
"}");
assertTypeEquals(ARRAY_TYPE, a.getType());
assertTypeEquals(VOID_TYPE, testNameNode("undefined"));
assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode("Object"));
assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode("Array"));
assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode("Date"));
assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode("RegExp"));
testTypesWithCommonExterns(
assertTypeEquals("bar property on goog.foo type incorrectly inferred",
NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType("bar"));
assertEquals(NATIVE_PROPERTIES_COUNT + 2, instanceType.getPropertiesCount());
checkObjectType(instanceType, "m1", NUMBER_TYPE);
assertEquals(NATIVE_PROPERTIES_COUNT + 2, goog.getPropertiesCount());
assertEquals(NATIVE_PROPERTIES_COUNT + 2, classA.getPropertiesCount());
checkObjectType(classA, "m1", NUMBER_TYPE);
assertEquals(NATIVE_PROPERTIES_COUNT + 3, instanceType.getPropertiesCount());
checkObjectType(instanceType, "m1", NUMBER_TYPE);
checkObjectType(instanceType, "m2", BOOLEAN_TYPE);
assertTypeEquals(UNKNOWN_TYPE,
U2U_FUNCTION_TYPE.getPropertyType("m1"));
assertTypeEquals(UNKNOWN_TYPE,
U2U_FUNCTION_TYPE.getPropertyType("m2"));
assertEquals(NATIVE_PROPERTIES_COUNT + 4, instanceType.getPropertiesCount());
checkObjectType(instanceType, "m1", NUMBER_TYPE);
checkObjectType(instanceType, "m2", BOOLEAN_TYPE);
checkObjectType(instanceType, "m3", STRING_TYPE);
assertEquals(NATIVE_PROPERTIES_COUNT + 7, instanceType.getPropertiesCount());
checkObjectType(instanceType, "m1", STRING_TYPE);
checkObjectType(instanceType, "m2",
createUnionType(OBJECT_TYPE, NULL_TYPE));
checkObjectType(instanceType, "m3", BOOLEAN_TYPE);
checkObjectType(instanceType, "m4", STRING_TYPE);
checkObjectType(instanceType, "m5", NUMBER_TYPE);
checkObjectType(instanceType, "m6", BOOLEAN_TYPE);
Node node = parseAndTypeCheck("\"x\".charAt(0)");
assertTypeEquals(STRING_TYPE, node.getFirstFirstChild().getJSType());
Node node = parseAndTypeCheck(
"/** @constructor */ var String = function(opt_str) {};\n" +
"(new String(\"x\")).charAt(0)");
assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());
assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());
assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());
assertTypeEquals(NUMBER_TYPE, type);
assertTypeEquals(NUMBER_TYPE, type);
assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType("m1"));
assertTypeEquals(STRING_TYPE, objectType.getPropertyType("m2"));
assertTypeEquals(STRING_TYPE, n.getFirstFirstChild().getJSType());
assertTypeEquals(ERROR_TYPE,
n.getFirstFirstChild().getJSType());
assertTypeEquals(ARRAY_TYPE,
n.getFirstFirstChild().getJSType());
assertTypeEquals(type, OBJECT_TYPE);
Node externs = IR.root();
IR.root(externs, n);
String js = ""
+ "/** @constructor */\n"
+ "var Foo = function() {}\n"
+ "/** @param {number} a */\n"
+ "Foo.prototype.foo = function(a) {\n"
+ "  return this.baz().toString();\n"
+ "};\n"
+ "/** @return {Baz} */\n"
+ "Foo.prototype.baz = function() { return new Baz(); };\n"
+ "/** @constructor\n"
+ "  * @extends Foo */\n"
+ "var Bar = function() {};"
+ "/** @constructor */\n"
+ "var Baz = function() {};";
assertEquals(100.0, getTypedPercent(js), 0.1);
testTypes(
"/** @return {string|number} */ function f() { return 3; }" +
"f().length;");
testTypes(
"/** @return {string|number} */ function f() { return 3; }" + "f().length;"
assertTypeEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
n.getFirstChild().getJSType());
assertTypeEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),
n.getFirstFirstChild().getJSType());
assertTypeEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),
n.getFirstChild().getLastChild().getLastChild().getFirstChild()
.getNext().getFirstChild().getJSType());
assertTypeEquals(registry.createNullableType(registry.getGlobalType("Foo")),
n.getLastChild().getLastChild().getLastChild().getLastChild()
.getLastChild().getLastChild().getJSType());
compiler,
new SemanticReverseAbstractInterpreter(registry),
registry, topScope, scopeCreator)
testTypes(
"/** @type {!Array<string>} */\n" +
"var query = [];\n" +
"query.push(1);\n");
testTypes(""
+ "/** @param {string} x */ function f(x) {}"
+ "/**\n"
+ " * @param {?function(this:T, ...)} fn\n"
+ " * @param {T=} opt_obj\n"
+ " * @template T\n"
+ " */\n"
+ "function baz(fn, opt_obj) {}\n"
+ "function g() { baz(function() { f(this.length); }, []); }",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : number\n"
+ "required: string");
CLOSURE_DEFS +
"/** @type {string} */" +
"var out;" +
"/** @type {Array<string>} */ var arr;\n" +
"var out4 = goog.array.filter(" +
"   arr," +
"   function(item,index,srcArr) {out = srcArr;});",
"assignment\n" +
"found   : (null|{length: number})\n" +
"required: string");
JSType arrayOfNumber = createTemplatizedType(
ARRAY_TYPE, NUMBER_TYPE);
JSType arrayOfString = createTemplatizedType(
ARRAY_TYPE, STRING_TYPE);
assertFalse(arrayOfString.isSubtypeOf(createUnionType(arrayOfNumber, NULL_VOID)));
testTypes(
"/** @constructor */\n" +
"var MyClass = function() {};\n" +
"/** @override*/\n" +
"MyClass.prototype.toString = function() { return ''; };\n" +
"/** @type {!Object<!MyClass, number>} */\n" +
"var k;");
testTypes(
"/** @constructor */\n" +
"var Parent = function() {};\n" +
"/** @override */\n" +
"Parent.prototype.toString = function() { return ''; };\n" +
"/** @constructor @extends {Parent} */\n" +
"var Child = function() {};\n" +
"/** @type {!Object<!Child, number>} */\n" +
"var k;");
testTypes(
"/** @constructor */\n" +
"var MyClass = function() {};\n" +
"/** @override*/\n" +
"MyClass.prototype.toString = function() { return ''; };\n" +
"/** @enum{!MyClass} */\n" +
"var Enum = {};\n" +
"/** @type {!Object<Enum, number>} */\n" +
"var k;");
testTypes(
"sign operator",
Node externs = IR.root();
static final String EXTRA_TYPE_DEFS = lines(
"/** @typedef {!Array<?>} */ var ArrayAlias;",
"",
"/** @constructor */",
"function Bar() {}",
"",
"/** @type {number} */",
"var n = 10;");
typeVars = new ImmutableMap.Builder<String, JSType>()
.put("S", STRING_TYPE)
.put("N", NUMBER_TYPE)
.put("B", BOOLEAN_TYPE)
.put("BOT", NO_TYPE)
.put("TOP", ALL_TYPE)
.put("UNK", UNKNOWN_TYPE)
.put("CHKUNK", CHECKED_UNKNOWN_TYPE)
.put("SO", STRING_OBJECT_TYPE)
.put("NO", NUMBER_OBJECT_TYPE)
.put("BO", BOOLEAN_OBJECT_TYPE)
.put("NULL", NULL_TYPE)
.put("OBJ", OBJECT_TYPE)
.put("UNDEF", VOID_TYPE)
.put("ARR", ARRAY_TYPE)
.put("ARRNUM", type(ARRAY_TYPE, NUMBER_TYPE))
.put("REC", recordTypeTest)
.put("NESTEDREC", nestedRecordTypeTest)
.put("ASYNCH", asynchRecord)
.build();
testTTL(NUMBER_TYPE, "'number'");
testTTL(UNKNOWN_TYPE, "'foo'",
"Reference to an unknown type name foo");
testTTL(STRING_TYPE, "S");
testTTL(STRING_TYPE, "S");
testTTL(NUMBER_TYPE, "N");
testTTL(union(NUMBER_TYPE, STRING_TYPE), "union(N, S)");
testTTL(union(NUMBER_TYPE, STRING_TYPE),
"union('number', 'string')");
testTTL(union(NUMBER_TYPE, STRING_TYPE), "union(S, 'number')");
testTTL(UNKNOWN_TYPE, "union(foo, 'number')",
testTTL(UNKNOWN_TYPE, "union(N, 'foo')",
"Reference to an unknown type name foo");
testTTL(union(NUMBER_TYPE, NULL_TYPE, STRING_TYPE),
testTTL(union(NUMBER_TYPE, NULL_TYPE, STRING_TYPE),
testTTL(NUMBER_TYPE, "union('number', 'number')");
testTTL(UNKNOWN_TYPE, "foo", "Reference to an unknown type variable foo");
testTTL(STRING_TYPE, "cond(eq(N, N), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(eq(N, S), 'string', 'number')");
testTTL(STRING_TYPE,
"cond( sub('Number', 'Object'), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond( sub('Number', 'String'), 'string', 'number')");
testTTL(STRING_TYPE, "cond(streq(n, 'number'), 'string', 'number')");
testTTL(STRING_TYPE, "cond(streq(n, n), 'string', 'number')");
testTTL(STRING_TYPE, "cond(streq('number', 'number'), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(streq('number', 'foo'), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(streq(n, 'foo'), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(streq(n, s), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(eq(foo, S), 'string', 'number')",
testTTL(NUMBER_TYPE, "cond(streq(foo, s), 'string', 'number')",
testTTL(STRING_TYPE,
"cond( eq( cond(eq(N, N), 'string', 'number'), 'string'),"
+ "'string', "
+ "'number')");
testTTL(STRING_TYPE,
"cond( eq( 'string', cond(eq(N, N), 'string', 'number')),"
+ "'string', "
+ "'number')");
testTTL(STRING_OBJECT_TYPE,
"cond( eq(N, N),"
+ "cond(eq(N, S), 'string', 'String'),"
+ "'number')");
testTTL(STRING_OBJECT_TYPE,
"cond( eq(N, S),"
+     "'number',"
+     "cond(eq(N, S), 'string', 'String'))");
testTTL(STRING_TYPE, "mapunion(union(S, N), (x) => S)");
testTTL(union(NUMBER_TYPE, STRING_TYPE),
"mapunion(union(N, S), (x) => x)");
testTTL(NUMBER_TYPE,
"mapunion(union(N, 'number'), (x) => x)");
testTTL(STRING_TYPE,
"mapunion(union(S, B, N), (x) => cond(eq(x, S), x, BOT))");
testTTL(NUMBER_TYPE, "mapunion(S, (x) => cond(eq(x, S), N, BOT))");
testTTL(union(NUMBER_TYPE, BOOLEAN_TYPE),
"mapunion(union(union(S, B), union(N, S)),"
+ "(x) => cond(eq(x, S), BOT, x))");
testTTL(STRING_TYPE,
+ "(x) => mapunion(union(S, N), "
+          "(y) => cond(eq(x, y), x, BOT)))");
testTTL(OBJECT_TYPE,
+ "union(S, N, B, NULL, UNDEF, ARR),"
+ "(x) => "
+ "cond(eq(x, S), SO,"
+ "cond(eq(x, N), NO,"
+ "cond(eq(x, B), BO,"
+ "cond(eq(x, NULL), OBJ,"
+ "cond(eq(x, UNDEF), OBJ,"
+ "x ))))))");
testTTL(UNKNOWN_TYPE, "none()");
testTTL(UNKNOWN_TYPE, "cond(eq(BOT, none()), none(), N)");
testTTL(STRING_TYPE,
"mapunion(union(S, B, N), (x) => cond(eq(x, S), x, none()))");
testTTL(ALL_TYPE, "all()");
testTTL(ALL_TYPE, "cond(eq(TOP, all()), all(), N)");
testTTL(ALL_TYPE,
"mapunion(union(S, B, N), (x) => cond(eq(x, S), x, all()))");
testTTL(UNKNOWN_TYPE, "unknown()");
testTTL(NUMBER_TYPE, "cond(eq(UNK, unknown()), N, S)");
testTTL(UNKNOWN_TYPE,
"mapunion(union(S, B, N), (x) => cond(eq(x, S), x, unknown()))");
testTTL(type(ARRAY_TYPE, NUMBER_TYPE), "type('Array', 'number')");
testTTL(type(ARRAY_TYPE, NUMBER_TYPE), "type(ARR, 'number')");
testTTL(type(ARRAY_TYPE, NUMBER_TYPE), "type(ARR, N)");
testTTL(UNKNOWN_TYPE, "type('string', 'number')",
testTTL(UNKNOWN_TYPE, "type(S, 'number')",
"The type string cannot be templatized");
testTTL(UNKNOWN_TYPE, "type('ArrayAlias', number)",
testTTL(ARRAY_TYPE, "rawTypeOf(type('Array', 'number'))");
testTTL(ARRAY_TYPE, "rawTypeOf(ARRNUM)");
testTTL(ARRAY_TYPE, "rawTypeOf(type('Array', rawTypeOf(ARRNUM)))");
testTTL(UNKNOWN_TYPE, "rawTypeOf(N)",
testTTL(NUMBER_TYPE, "templateTypeOf(type('Array', 'number'), 0)");
testTTL(NUMBER_TYPE, "templateTypeOf(ARRNUM, 0)");
testTTL(NUMBER_TYPE,
"templateTypeOf("
+ "templateTypeOf(type('Array', type('Array', 'number')), 0),"
+ "0)");
testTTL(UNKNOWN_TYPE, "templateTypeOf(N, 0)",
testTTL(UNKNOWN_TYPE, "templateTypeOf(ARRNUM, 2)",
testTTL(record("x", NUMBER_TYPE),
"record({x:'number'})");
testTTL(record("0", NUMBER_TYPE),
"record({0:'number'})");
testTTL(record("x", NUMBER_TYPE, "y", STRING_TYPE),
testTTL(record("x", record("z", BOOLEAN_TYPE), "y", STRING_TYPE),
testTTL(record("x", NUMBER_TYPE),
"record(record({x:N}))");
testTTL(record("x", NUMBER_TYPE, "y", STRING_TYPE, "z", BOOLEAN_TYPE),
testTTL(record("x", NUMBER_TYPE),
"record({x:N}, {x:N}, {x:N})");
testTTL(record("x", NUMBER_TYPE),
"record({x:N}, {})");
testTTL(UNKNOWN_TYPE, "record(N)",
"Expected a record type, found number");
testTTL(UNKNOWN_TYPE, "record({x:N}, N)",
"Expected a record type, found number");
testTTL(union(NUMBER_TYPE, STRING_TYPE),
"mapunion(templateTypeOf(type(ARR, union(N, S)), 0),"
+ "(x) => x)");
testTTL(UNKNOWN_TYPE,
+ "(x) => mapunion(union(S, N), "
+          "(x) => cond(eq(x, x), x, BOT)))",
testTTL(record("number", NUMBER_TYPE, "string", STRING_TYPE,
"boolean", BOOLEAN_TYPE),
testTTL(UNKNOWN_TYPE, "record({[Foo]:N})",
testTTL(record("n", STRING_TYPE, "s", STRING_TYPE, "b", STRING_TYPE),
testTTL(OBJECT_TYPE, "maprecord(REC, (k, v) => BOT)");
testTTL(UNKNOWN_TYPE, "maprecord(REC, (k, v) => 'number')",
testTTL(record("s", STRING_TYPE),
testTTL(UNKNOWN_TYPE, "maprecord(N, (k, v) => BOT)",
testTTL(OBJECT_TYPE, "maprecord(OBJ, (k, v) => record({[k]:v}))");
testTTL(UNKNOWN_TYPE,
testTTL(UNKNOWN_TYPE, "maprecord(union(record({n:N}), record({s:S})), "
+ "(k, v) => record({[k]:v}))",
testTTL(record("r", record("s", STRING_TYPE, "b", BOOLEAN_TYPE)),
"maprecord(NESTEDREC,"
+ "(k, v) => cond(eq(v, S), BOT, record({[k]:v})))");
testTTL(record("r", record("b", BOOLEAN_TYPE)),
"maprecord(NESTEDREC,"
+ "(k1, v1) => "
+  "cond(sub(v1, 'Object'), "
+        "maprecord(v1, (k2, v2) => "
+             "cond(eq(v2, S), BOT, record({[k1]:record({[k2]:v2})}))),"
+        "cond(eq(v1, S), BOT, record({[k1]:v1}))))");
testTTL(record("r",
record("b", BOOLEAN_TYPE, "s", STRING_TYPE)),
"maprecord(record({r:record({b:B, s:S})}),"
+ "(k1, v1) => "
+   "maprecord(v1, "
+     "(k2, v2) => "
+       "record({[k1]:record({[k2]:v2})})))");
testTTL(record("r",
record("b", BOOLEAN_TYPE, "s", STRING_TYPE)),
"maprecord(record({r:record({b:B, s:S})}),\n"
+ "(k1, v1) =>\n"
+   "record({[k1]:\n"
+     "maprecord(v1, "
+       "(k2, v2) => record({[k2]:v2}))}))");
testTTL(record("r", record("r2",
record("n", NUMBER_TYPE, "s", STRING_TYPE))),
"maprecord(record({r:record({r2:record({n:N, s:S})})}),"
+ "(k1, v1) => "
+    "maprecord(v1, "
+      "(k2, v2) => "
+        "maprecord(v2, "
+          "(k3, v3) =>"
+             "record({[k1]:"
+               "record({[k2]:"
+                 "record({[k3]:v3})})}))))");
testTTL(record("r", record("r2",
record("n", NUMBER_TYPE, "s", STRING_TYPE))),
"maprecord(record({r:record({r2:record({n:N, s:S})})}),"
+ "(k1, v1) => "
+    "record({[k1]:"
+      "maprecord(v1, "
+        "(k2, v2) => "
+          "record({[k2]:"
+            "maprecord(v2, "
+              "(k3, v3) =>"
+                "record({[k3]:v3}))}))}))");
testTTL(record("r", record("r2", record("r3",
record("n", NUMBER_TYPE, "s", STRING_TYPE)))),
"maprecord(record({r:record({r2:record({r3:record({n:N, s:S})})})}),"
+ "(k1, v1) => "
+    "maprecord(v1, "
+      "(k2, v2) => "
+        "maprecord(v2, "
+          "(k3, v3) =>"
+            "maprecord(v3,"
+              "(k4, v4) =>"
+               "record({[k1]:"
+                 "record({[k2]:"
+                   "record({[k3]:"
+                     "record({[k4]:v4})})})})))))");
testTTL(record("r", record("r2", record("r3",
record("n", NUMBER_TYPE, "s", STRING_TYPE)))),
"maprecord(record({r:record({r2:record({r3:record({n:N, s:S})})})}),"
+ "(k1, v1) => "
+   "record({[k1]:"
+     "maprecord(v1, "
+       "(k2, v2) => "
+         "record({[k2]:"
+           "maprecord(v2, "
+             "(k3, v3) =>"
+               "record({[k3]:"
+                 "maprecord(v3,"
+                   "(k4, v4) =>"
+                     "record({[k4]:v4}))}))}))}))");
testTTL(record("r", record("n", NUMBER_TYPE, "s", STRING_TYPE)),
"maprecord(record({r:record({r2:record({r3:record({n:N, s:S})})})}),"
+ "(k1, v1) => "
+    "maprecord(v1, "
+      "(k2, v2) => "
+        "maprecord(v2, "
+          "(k3, v3) =>"
+            "maprecord(v3,"
+              "(k4, v4) =>"
+               "record({[k1]:"
+                 "record({[k4]:v4})})))))");
testTTL(record("r", record("n", NUMBER_TYPE, "s", STRING_TYPE)),
"maprecord(record({r:record({r2:record({r3:record({n:N, s:S})})})}),"
+ "(k1, v1) => "
+   "record({[k1]:"
+     "maprecord(v1, "
+       "(k2, v2) => "
+         "maprecord(v2, "
+           "(k3, v3) =>"
+             "maprecord(v3,"
+               "(k4, v4) =>"
+                 "record({[k4]:v4}))))}))");
testTTL(record("foo", record("n", NUMBER_TYPE)),
"maprecord(record({a:ARR, b:record({n:N})}),"
+ "(k, v) => record({foo:v}))");
testTTL(record("foo", ARRAY_TYPE),
"maprecord(record({a:record({n:N}), b:ARR}),"
+ "(k, v) =>  record({foo:v}))");
testTTL(record("foo", record("n", NUMBER_TYPE, "s", ARRAY_TYPE)),
"maprecord(record({a:record({n:N}), b:record({s:ARR})}),"
+ "(k, v) => record({foo:v}))");
testTTL(record("foo", record("n", NUMBER_TYPE, "s", ARRAY_TYPE,
"r", record("x", NUMBER_TYPE, "y", NUMBER_TYPE))),
"maprecord(record({a:record({n:N, r:record({x:N})}), "
+ "b:record({s:ARR, r:record({y:N})})}),"
+ "(k, v) => record({foo:v}))");
testTTL(record("service", NUMBER_TYPE),
"cond(sub(ASYNCH, 'Object'),\n"
+       "maprecord(ASYNCH, \n"
+       "(k, v) => cond(eq(rawTypeOf(v), 'Array'),\n"
+                   "record({[k]:templateTypeOf(v, 0)}),\n"
+                   "record({[k]:'undefined'})) "
+               "),\n"
+       "ASYNCH)");
testTTL(UNKNOWN_TYPE,
testTTL(record("bool", NUMBER_TYPE, "str", STRING_TYPE),
+ "(k, v) => record({[k]:cond(streq(k, 'bool'), N, v)}))");
testTTL(NUMBER_TYPE, "typeOfVar('n')");
testTTL(UNKNOWN_TYPE, "typeOfVar('foo')",
"Variable foo is undefined in the scope");
testTTL(STRING_TYPE, "cond(isCtor(typeOfVar('Bar')), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(isCtor(N), 'string', 'number')");
testTTL(STRING_TYPE, "cond(isTemplatized(type(ARR, N)), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(isTemplatized(ARR), 'string', 'number')");
testTTL(STRING_TYPE, "cond(isRecord(REC), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(isRecord(N), 'string', 'number')");
testTTL(STRING_TYPE, "cond(isDefined(N), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(isDefined(Foo), 'string', 'number')");
testTTL(STRING_TYPE, "cond(isUnknown(UNK), 'string', 'number')");
testTTL(STRING_TYPE, "cond(isUnknown(CHKUNK), 'string', 'number')");
testTTL(NUMBER_TYPE, "cond(isUnknown(N), 'string', 'number')");
testTTL(STRING_TYPE,
"cond(isDefined(N) && isDefined(N), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond(isDefined(N) && isDefined(Foo), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond(isDefined(Foo) && isDefined(N), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond(isDefined(Foo) && isDefined(Foo), 'string', 'number')");
testTTL(STRING_TYPE,
"cond(isDefined(N) || isDefined(N), 'string', 'number')");
testTTL(STRING_TYPE,
"cond(isDefined(Foo) || isDefined(N), 'string', 'number')");
testTTL(STRING_TYPE,
"cond(isDefined(N) || isDefined(Foo), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond(isDefined(Foo) || isDefined(Foo), 'string', 'number')");
testTTL(STRING_TYPE,
"cond(!isDefined(Foo), 'string', 'number')");
testTTL(NUMBER_TYPE,
"cond(!isDefined(N), 'string', 'number')");
testTTL(NUMBER_OBJECT_TYPE, "instanceOf(typeOfVar('Number'))");
testTTL(UNKNOWN_TYPE, "instanceOf(N)",
"Expected a constructor type, found number");
testTTL(UNKNOWN_TYPE, "instanceOf(foo)",
testTTL(NUMBER_TYPE, "typeExpr('number')");
testTTL(union(NUMBER_TYPE, BOOLEAN_TYPE), "typeExpr('number|boolean')");
testTTL(record("foo", NUMBER_TYPE, "bar", BOOLEAN_TYPE),
testTTL(union(NUMBER_TYPE, NULL_TYPE), "typeExpr('?number')");
testTTL(NUMBER_TYPE, "typeExpr('!number')");
testTTL(NUMBER_TYPE, "printType('Test message: ', N)");
testTTL(NUMBER_TYPE, "propType('a', record({a:N, b:record({x:B})}))");
testTTL(record("x", BOOLEAN_TYPE),
"propType('b', record({a:N, b:record({x:B})}))");
testTTL(UNKNOWN_TYPE, "propType('c', record({a:N, b:record({x:B})}))");
testTTL(UNKNOWN_TYPE, "propType('c', N)",
"Expected object type, found number");
testTTL(OBJECT_TYPE, "record(type(OBJ, N))");
testTTL(record("length", NUMBER_TYPE), "record(type(ARR, N))");
testTTL(UNKNOWN_TYPE, "record(union(OBJ, NULL))",
recordTypeTest = record("n", NUMBER_TYPE, "s", STRING_TYPE,
"b", BOOLEAN_TYPE);
nestedRecordTypeTest = record("s", STRING_TYPE,
"r", record("s", STRING_TYPE, "b", BOOLEAN_TYPE));
asynchRecord = record("service", type(ARRAY_TYPE, NUMBER_TYPE));boolean useConstRequire = usesConstGoogRequires(metadata, script);
if (useConstRequire) {
HasConstRequireOrModuleCallback callback = new HasConstRequireOrModuleCallback(metadata);
return callback.getUsesConstRequires();
private static class HasConstRequireOrModuleCallback extends AbstractPreOrderCallback {
private boolean usesConstRequires;
public HasConstRequireOrModuleCallback(NodeMetadata metadata) {
this.usesConstRequires = false;
boolean getUsesConstRequires() {
return usesConstRequires;
if (Matchers.googModule().matches(n, metadata) || isConstRequire(n, metadata)) {
usesConstRequires = true;
private static boolean isConstRequire(Node node, NodeMetadata metadata) {
return node.isConst()boolean declared = iArgument.getJSDocInfo() != null;
iArgument.setJSType(
matchFunction(restrictedParameter, argFnType, declared));if (!fix(filename)) {
private static boolean fix(String filename) throws IOException {
FixingErrorManager errorManager = new FixingErrorManager();
public FixingErrorManager() {}
fixes.putAll(error, ErrorToFixMapper.getFixesForJsError(error, compiler));return (AbstractScope<?, ?>) scopes.peek().getClosestHoistScope();import java.nio.charset.StandardCharsets;
private static final String BASE64_URL_PREFIX = "data:application/json;base64,";
byte[] data =
BaseEncoding.base64().decode(sourceMapURL.substring(BASE64_URL_PREFIX.length()));
String source = new String(data, StandardCharsets.UTF_8);
return SourceFile.fromCode(jsFile.getName() + ".inline.map", source);
StandardCharsets.UTF_8);LINE_JOINER.join(
"const {bar} = goog.require('goog.util');",
"alert(bar('7'));"));Scope scope = t.getScope();"output_wrapper_file"))checkArgument(node.isCall() || node.isArrayLit() || node.isNew());
Node callee = node.isArrayLit() ? null : node.removeFirstChild();
Node currElement = node.removeFirstChild();
if (currGroup != null) {
groups.add(currGroup);
currGroup = null;
groups.add(Es6ToEs3Util.arrayFromIterable(compiler, currElement.removeFirstChild()));
currElement = node.removeFirstChild();
Node result = null;
Node firstGroup = node.isNew() ? IR.arraylit(IR.nullNode()) : IR.arraylit();
IR.call(IR.getprop(firstGroup, IR.string("concat")), groups.toArray(new Node[0]));
if (node.isArrayLit()) {
result = joinedGroups;
if (NodeUtil.mayHaveSideEffects(callee) && callee.isGetProp()) {
Node statement = node;
while (!NodeUtil.isStatement(statement)) {
statement = statement.getParent();
Node freshVar = IR.name(FRESH_SPREAD_VAR + compiler.getUniqueNameIdSupplier().get());
Node n = IR.var(freshVar.cloneTree());
n.useSourceInfoIfMissingFromForTree(statement);
statement.getParent().addChildBefore(n, statement);
callee.addChildToFront(IR.assign(freshVar.cloneTree(), callee.removeFirstChild()));
result = IR.call(
IR.getprop(callee, IR.string("apply")),
freshVar,
joinedGroups);
Node context = callee.isGetProp() ? callee.getFirstChild().cloneTree() : IR.nullNode();
result = IR.call(IR.getprop(callee, IR.string("apply")), context, joinedGroups);
if (compiler.getOptions().getLanguageOut() == LanguageMode.ECMASCRIPT3) {
Es6ToEs3Util.cannotConvert(
compiler, node, "\"...\" passed to a constructor (consider using --language_out=ES5)");
Node bindApply = NodeUtil.newQName(compiler,
"Function.prototype.bind.apply");
result = IR.newNode(IR.call(bindApply, callee, joinedGroups));
"  D.apply(this, [].concat($jscomp.arrayFromIterable(args)));",
test("var arr = [1, 2, ...mid, 4, 5];",
"var arr = [].concat([1, 2], $jscomp.arrayFromIterable(mid), [4, 5]);");
test("var arr = [1, 2, ...mid(), 4, 5];",
"var arr = [].concat([1, 2], $jscomp.arrayFromIterable(mid()), [4, 5]);");
test("var arr = [1, 2, ...mid, ...mid2(), 4, 5];",
"var arr = [].concat([1, 2], $jscomp.arrayFromIterable(mid),"
+ " $jscomp.arrayFromIterable(mid2()), [4, 5]);");
test("var arr = [...mid()];",
"var arr = [].concat($jscomp.arrayFromIterable(mid()));");
test("f(1, [2, ...mid, 4], 5);",
"f(1, [].concat([2], $jscomp.arrayFromIterable(mid), [4]), 5);");
test("f(...arr);", "f.apply(null, [].concat($jscomp.arrayFromIterable(arr)));");
test("f(0, ...g());", "f.apply(null, [].concat([0], $jscomp.arrayFromIterable(g())));");
test("f(0, ...g(), 2);", "f.apply(null, [].concat([0], $jscomp.arrayFromIterable(g()), [2]));");
test("obj.m(...arr);", "obj.m.apply(obj, [].concat($jscomp.arrayFromIterable(arr)));");
test("x.y.z.m(...arr);", "x.y.z.m.apply(x.y.z, [].concat($jscomp.arrayFromIterable(arr)));");
test("f(a, ...b, c, ...d, e);",
"f.apply(null, [].concat([a], $jscomp.arrayFromIterable(b),"
+ " [c], $jscomp.arrayFromIterable(d), [e]));");
test("Factory.create().m(...arr);",
lines(
"var $jscomp$spread$args0;",
"($jscomp$spread$args0 = Factory.create()).m.apply("
+ "$jscomp$spread$args0, [].concat($jscomp.arrayFromIterable(arr)));"
));
test("var x = b ? Factory.create().m(...arr) : null;",
"    [].concat($jscomp.arrayFromIterable(arr))) : null;"));
test("getF()(...args);", "getF().apply(null, [].concat($jscomp.arrayFromIterable(args)));");
"    [].concat($jscomp.arrayFromIterable(a)));",
"    [].concat($jscomp.arrayFromIterable(b)));"));
"    $jscomp$spread$args0, [].concat($jscomp.arrayFromIterable(arr)));"));
"isFunction = function(a){ var b={}; return a && '[object Function]' === b.b.a(a); }";import java.util.Objects;
implements StaticSlot, StaticRef {
public boolean equals(Object other) {
if (!(other instanceof AbstractVar)) {
return false;
return Objects.equals(name, ((AbstractVar<?, ?>) other).name)
&& Objects.equals(scope.getRootNode(), ((AbstractVar<?, ?>) other).scope.getRootNode());
public int hashCode() {
return Objects.hash(name, scope.getRootNode());if (c.getString().equals(right.getString())) {
switch (c.getToken()) {
case SETTER_DEF:
case GETTER_DEF:
case STRING_KEY:
break;
default:
throw new IllegalStateException();import com.google.javascript.jscomp.parsing.parser.FeatureSet;
import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
import java.util.ArrayList;
compiler.setFeatureSet(compiler.getFeatureSet().without(Feature.MODULES));
Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
Node externsNode = compiler.getInput(new InputId("[externs]"))
.getAstRoot(compiler);
if (compiler.getOptions().needsTranspilationFrom(FeatureSet.ES6)) {
List<PassFactory> passes = new ArrayList<>();
TranspilationPasses.addEs6ModulePass(passes);
TranspilationPasses.addEs2017Passes(passes);
TranspilationPasses.addEs2016Passes(passes);
TranspilationPasses.addEs6EarlyPasses(passes);
TranspilationPasses.addEs6LatePasses(passes);
TranspilationPasses.addRewritePolyfillPass(passes);
PhaseOptimizer phaseopt = new PhaseOptimizer(compiler, null);
phaseopt.consume(passes);
phaseopt.process(externsNode, externAndJsRoot);
Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler);
Node externsNode = compiler.getInput(new InputId("[externs]"))
.getAstRoot(compiler);
Node externAndJsRoot = IR.root(externsNode, n);
compiler.jsRoot = n;
TranspilationPasses.addRewritePolyfillPass(passes);
phaseopt.process(externsNode, externAndJsRoot);
TypedScope s = makeTypeCheck().processForTesting(externsNode, n);
return new TypeCheckResult(n, s);reportError("ERROR - renaming cannot be disabled when ADVANCED_OPTMIZATIONS is used.");
"renaming cannot be disabled when ADVANCED_OPTMIZATIONS is used");defineSlot(n, parent, unknownType, true);
propName, unknownType, n);
propName, ownerType == null ? unknownType : ownerType);currentModule.importsByLongRequiredName.put(extractFirstArgumentName(callNode), parent);
if (script != null) {
Node child = script.getFirstChild();
while (child != null) {
if ((NodeUtil.isExprCall(child)
&& Matchers.googRequire(namespace).matches(child.getFirstChild(), metadata))
|| (NodeUtil.isNameDeclaration(child)
&& child.getFirstFirstChild() != null && Matchers.googRequire(namespace)
.matches(child.getFirstFirstChild(), metadata))) {
return child;
child = child.getNext();
import org.junit.Ignore;
public void testBothFormsOfRequire() {if (options.closurePass) {private JSType getInheritedInterfacePropertyType(ObjectType obj, String propName) {
if (obj != null && obj.isPrototypeObject()) {
FunctionType f = obj.getOwnerFunction();
for (ObjectType i : f.getImplementedInterfaces()) {
if (i.hasProperty(propName)) {
return i.getPropertyType(propName);
return null;
JSType inheritedType = getInheritedInterfacePropertyType(ownerType, propName);
JSType stubType = inheritedType == null ? unknownType : inheritedType;
defineSlot(n, parent, stubType, true);
propName, stubType, n);
propName, ownerType == null ? stubType : ownerType);
public void testStubMethodDeclarationDoesntBlockTypechecking_1() {
testTypes(
lines(
"/** @interface */",
"function Foo() {}",
"/** @return {number} */",
"Foo.prototype.method = function() {};",
"/**",
" * @constructor",
" * @implements {Foo}",
" */",
"function Bar() {}",
"Bar.prototype.method;",
"var /** null */ n = (new Bar).method();"),
lines(
"initializing variable",
"found   : number",
"required: null"));
public void testStubMethodDeclarationDoesntBlockTypechecking_2() {
testTypes(
lines(
"/** @constructor */",
"function Foo() {}",
"/** @return {number} */",
"Foo.prototype.method = function() {};",
"/**",
" * @constructor",
" * @extends {Foo}",
" */",
"function Bar() {}",
"Bar.prototype.method;",
"var /** null */ n = (new Bar).method();"),
lines(
"initializing variable",
"found   : number",
"required: null"));assertSideEffect(false, "({[a]: x})");
assertSideEffect(true, "({[a()]: x})");
assertSideEffect(true, "({[a]: x()})");public void disabledTestAssignmentToThisPrototype() {
"};"));private ImmutableList<RefasterJsTemplate> templates;
private RefasterJsTemplate matchedTemplate;
matchedTemplate = null;
matchedTemplate = null;
for (RefasterJsTemplate template : templates) {
if (template.matcher.matches(node, metadata)) {
matchedTemplate = template;
SuggestedFix.Builder fix = new SuggestedFix.Builder();
if (matchedTemplate
.beforeTemplate
.getLastChild()
.isEquivalentTo(matchedTemplate.afterTemplate.getLastChild())) {
return ImmutableList.of();
HashMap<String, String> shortNames = new HashMap<>();
for (String require : matchedTemplate.getGoogRequiresToAdd()) {
fix.addGoogRequire(match, require);
shortNames.put(require, fix.getRequireName(match, require));
Node newNode =
transformNode(
matchedTemplate.matcher.getTemplateNodeToMatchMap(),
shortNames);
Node nodeToReplace = match.getNode();
fix.attachMatchedNodeInfo(nodeToReplace, match.getMetadata().getCompiler());
fix.replace(nodeToReplace, newNode, match.getMetadata().getCompiler());
Node n = match.getNode().getNext();
int count = matchedTemplate.beforeTemplate.getLastChild().getChildCount();
for (int i = 1; i < count; i++) {
Preconditions.checkNotNull(
n,
"Found mismatched sibling count between before template and matched node.\n"
+ "Template: %s\nMatch: %s",
matchedTemplate.beforeTemplate.getLastChild(),
match.getNode());
fix.delete(n);
n = n.getNext();
for (String require : matchedTemplate.getGoogRequiresToRemove()) {
fix.removeGoogRequire(match, require);
return ImmutableList.of(fix.build());
Map<String, Node> beforeTemplates = new LinkedHashMap<>();
Map<String, Node> afterTemplates = new HashMap<>();
afterTemplates.put(templateName, templateNode);
afterTemplates.put(templateName, templateNode);
ImmutableList.Builder<RefasterJsTemplate> builder = ImmutableList.builder();
afterTemplates.containsKey(templateName),
"Found before template without a corresponding after template. Make sure there is an "
+ "after_%s function defined.", templateName);
builder.add(
new RefasterJsTemplate(
compiler.getTypeIRegistry(),
typeMatchingStrategy,
beforeTemplates.get(templateName),
afterTemplates.get(templateName)));
this.templates = builder.build();
return new SuggestedFix(matchedNodeInfo, replacements.build(), description);
String expectedFile)
final String expectedFilePath = testDataPathPrefix + File.separator + expectedFile;
String newCode =
ApplySuggestedFixes.applySuggestedFixesToCode(
.get(originalFilePath);
assertThat(replaceTrailingWhitespace(newCode))
.isEqualTo(replaceTrailingWhitespace(slurpFile(expectedFilePath)));
private static String replaceTrailingWhitespace(String contents) {
return contents.replaceAll("[ \t]*\n", "\n");
assertChanges("", originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges("", originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(
externs + "/** @type {!T} */ var theT;",
originalCode,
expectedCode,
template);
null, // No changes.
template);
assertChanges(
externs + "var theT;",
originalCode,
null, // No changes.
template);
assertChanges(
externs + "/** @type {!S} */ var theT;",
originalCode,
expectedCode,
template);
null, // No changes.
template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, null, template);
assertChanges(externs, originalCode, null, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
assertChanges(externs, originalCode, expectedCode, template);
String externs, String originalCode, String expectedCode, String refasterJsTemplate)
String newCode = ApplySuggestedFixes.applySuggestedFixesToCode(
fixes, ImmutableMap.of("input", originalCode)).get("input");
assertEquals(expectedCode, newCode);
protected void assertChanges(String originalCode, String expectedCode) {
String newCode =
ApplySuggestedFixes.applySuggestedFixesToCode(fixes, ImmutableMap.of("input", originalCode))
.get("input");
assertThat(newCode).isEqualTo(expectedCode);
fixes.isEmpty() || (fixes.size() == 1 && fixes.get(0).getReplacements().isEmpty()));if ("arguments".equals(name) && NodeUtil.isVanillaFunction(scope.getRootNode())) {
public V getArgumentsVar() {
private static final String ARGUMENTS = "arguments";
if (!scope.isDeclared(name, false)
&& !(scope.isLocal() && name.equals(ARGUMENTS))) {
public Var getArgumentsVar() {
throw new IllegalStateException("Method getArgumentsVar cannot be called on typed scopes.");for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
check(c);return ES5;static String getClassName(Node functionNode) {
public void processFile(Node scriptNode) {
currentFile.recordNameDeclaration(n.getFirstChild(), t.getScope());
currentFile.recordNameDeclaration(n.getFirstChild(), t.getScope());
currentFile.recordMethod(n, t.getScope());
currentFile.recordDefine(expr, t.getScope());
currentFile.recordNameDeclaration(lhs, t.getScope());
currentFile.recordNameDeclaration(expr, t.getScope());
recordNameDeclaration(t, n);
void recordNameDeclaration(NodeTraversal t, Node decl) {
currentFile.recordNameDeclaration(name, t.getScope());
JSDocInfo jsdoc = jsdocNode.getJSDocInfo();
if (!isConstToBeInferred(jsdoc, nameNode, false)) {
JSDocInfo newJsdoc = JsdocUtil.getJSDocForRhs(rhs, jsdoc);
newJsdoc = JsdocUtil.getJSDocForName(decl, jsdoc);
private static boolean isExportLhs(Node lhs) {
return (lhs.isName() && lhs.matchesQualifiedName("exports"))
|| (lhs.isGetProp() && lhs.getFirstChild().matchesQualifiedName("exports"));
|| NodeUtil.isCallTo(rhs, "goog.defineClass")
if (isConstToBeInferred(jsdoc, nameNode, isExport)) {
Node jsdocNode = NodeUtil.getBestJSDocInfoNode(nameNode);
jsdocNode.setJSDocInfo(JsdocUtil.pullJsdocTypeFromAst(compiler, jsdoc, nameNode));
Node jsdocNode = NodeUtil.getBestJSDocInfoNode(nameNode);
jsdocNode.setJSDocInfo(JsdocUtil.getAllTypeJSDoc());
boolean isExport = isExportLhs(decl.getLhs());
if (isConstToBeInferred(decl.getJsDoc(), decl.getLhs(), isExport)
JSDocInfo jsdoc, Node nameNode, boolean isImpliedConst) {
isImpliedConst
|| nameNode.getParent().isConst()
import com.google.javascript.jscomp.Scope;
void recordNameDeclaration(Node qnameNode, Scope scope) {
recordDeclaration(PotentialDeclaration.fromName(qnameNode));
void recordMethod(Node functionNode, Scope scope) {
void recordDefine(Node callNode, Scope scope) {
void recordDeclaration(PotentialDeclaration decl) {
import static com.google.common.base.Preconditions.checkArgument;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.JSError;
static JSDocInfo updateJsdoc(AbstractCompiler compiler, Node nameNode) {
checkArgument(nameNode.isStringKey(), nameNode);
Node jsdocNode = nameNode;
JSDocInfo jsdoc = jsdocNode.getJSDocInfo();
if (jsdoc == null) {
jsdoc = JsdocUtil.getAllTypeJSDoc();
jsdoc = JsdocUtil.pullJsdocTypeFromAst(compiler, jsdoc, nameNode);
jsdocNode.setJSDocInfo(jsdoc);
return jsdoc;
static JSDocInfo pullJsdocTypeFromAst(
AbstractCompiler compiler, JSDocInfo oldJSDoc, Node nameNode) {
checkArgument(nameNode.isQualifiedName() || nameNode.isStringKey(), nameNode);
if (oldJSDoc != null && oldJSDoc.getDescription() != null) {
return getConstJSDoc(oldJSDoc, "string");
if (!nameNode.isFromExterns() && !isPrivate(oldJSDoc)) {
compiler.report(
JSError.make(nameNode, ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE));
private static boolean isPrivate(@Nullable JSDocInfo jsdoc) {
return jsdoc != null && jsdoc.getVisibility().equals(Visibility.PRIVATE);
static JSDocInfo getAllTypeJSDoc() {
return getConstJSDoc(null, new Node(Token.STAR));
default:
JsdocUtil.updateJsdoc(compiler, key);if (!NodeUtil.isLValue(n) && !parent.isGetProp()) {return true;String sourceExcerpt = source == null ? null :
excerpt.get(
source, sourceName, lineNumber, excerptFormatter);fix(filename);
static void fix(String filename) throws IOException {
Compiler compiler = new Compiler(System.out);
FixingErrorManager errorManager = new FixingErrorManager();
compiler.setErrorManager(errorManager);
errorManager.setCompiler(compiler);
lint(Paths.get(filename), compiler);
ApplySuggestedFixes.applySuggestedFixesToFiles(errorManager.getAllFixes());boolean isDeclaration = n.getParent().isDestructuringLhs();
if (isDeclaration
&& hasCrossModuleName
parent.removeChild(n);
parent.removeChild(value);
Node assign = IR.assign(n, value).srcref(n);
nameDeclaration.replaceChild(parent, assign);options.setPreferSingleQuotes(false);
preferSingleQuotes = true;
"goog.module('Foo');",
"goog.module('bar');",
"goog.module('baz');",
"goog.module('leaf');",
"var module$contents$leaf_Foo=goog.require('Foo');",
"var {doBar:module$contents$leaf_doBar}=goog.require('bar');",
"var {doBaz:module$contents$leaf_doooBaz}=goog.require('baz')"
assertPrintNode("eval('1')", n);
assertPrintNode("(0,eval)('1')", n);
assertEquals("'f';\n'g';\n", result);
assertPrintNode("x['function']=2", nodes);
assertPrintNode("x={'function':2}", nodes);
options.setPreferSingleQuotes(false);
assertThat(compiler.toSource()).isEqualTo("var b;var c;b.exportSymbol('a',c);");
assertThat(compiler.toSource()).isEqualTo("var b;var c={};b.exportSymbol('a',c);");
testSame("function f(){startMarker('FOO');startMarker('BAR');"
+ "if(x)return;endMarker('BAR');y();if(a)return;endMarker('FOO');b()}");
checkCost("function a() {return 'monkey'}",
"function xx(){return'monkey'}");
assertEquals("/**\n @template T := 'Promise' =:\n */\n", jsDocInfoPrinter.print(info));
assertMapping("$", "a.prototype['XXX']");
assertMapping("$", "a.prototype['\\n']");
assertMapping("$", "a['prototype'].b");
assertMapping("$", "document.getElementById('x').onClick");
assertMapping("$", "a.b['c'].d");
assertMapping("$", "win['x'+this.id]");
assertMapping("$", "foo['-']");
assertMapping("$", "A.prototype.'foo'+bar()");
assertEquals("['test',base+'-active']", compiler.toSource(root));
+ "'use strict';"
+ "goog.module('test');"
"__jscov.instrumentedLines.push('01');",
"__jscov.fileNames.push('source.js');",
assertThat(runtime).contains("$jscomp.polyfill('Map'");
assertThat(runtime).contains("$jscomp.polyfill('Map'");options.setPreferSingleQuotes(true);
compilerOptions.setPreferSingleQuotes(true);
"goog.module(\"Foo\");",
"goog.module(\"bar\");",
"goog.module(\"baz\");",
"goog.module(\"leaf\");",
"var module$contents$leaf_Foo=goog.require(\"Foo\");",
"var {doBar:module$contents$leaf_doBar}=goog.require(\"bar\");",
"var {doBaz:module$contents$leaf_doooBaz}=goog.require(\"baz\")"
assertPrintNode("eval(\"1\")", n);
assertPrintNode("(0,eval)(\"1\")", n);
assertEquals("\"f\";\n\"g\";\n", result);
assertPrintNode("x[\"function\"]=2", nodes);
assertPrintNode("x={\"function\":2}", nodes);
assertThat(compiler.toSource()).isEqualTo("var b;var c;b.exportSymbol(\"a\",c);");
assertThat(compiler.toSource()).isEqualTo("var b;var c={};b.exportSymbol(\"a\",c);");
testSame("function f(){startMarker(\"FOO\");startMarker(\"BAR\");" +
"if(x)return;endMarker(\"BAR\");y();if(a)return;" +
"endMarker(\"FOO\");b()}");
checkCost("function a() {return \"monkey\"}",
"function xx(){return\"monkey\"}");
assertEquals("/**\n @template T := \"Promise\" =:\n */\n", jsDocInfoPrinter.print(info));
assertMapping("$", "a.prototype[\"XXX\"]");
assertMapping("$", "a.prototype[\"\\n\"]");
assertMapping("$", "a[\"prototype\"].b");
assertMapping("$", "document.getElementById(\"x\").onClick");
assertMapping("$", "a.b[\"c\"].d");
assertMapping("$", "win[\"x\"+this.id]");
assertMapping("$", "foo[\"-\"]");
assertMapping("$", "A.prototype.\"foo\"+bar()");
assertEquals("[\"test\",base+\"-active\"]", compiler.toSource(root));
+ "\"use strict\";"
+ "goog.module(\"test\");"
"__jscov.instrumentedLines.push(\"01\");",
"__jscov.fileNames.push(\"source.js\");",
assertThat(runtime).contains("$jscomp.polyfill(\"Map\"");
options.setPreferSingleQuotes(true);
assertThat(runtime).contains("$jscomp.polyfill(\"Map\"");String moduleName;
String importName = n.getLastChild().getString();
boolean isNamespaceImport = importName.startsWith("goog:");
if (isNamespaceImport) {
moduleName = importName.substring("goog:".length());
ModuleLoader.ModulePath modulePath =
t.getInput()
.getPath()
.resolveJsModule(importName, n.getSourceFileName(), n.getLineno(), n.getCharno());
if (modulePath == null) {
modulePath = t.getInput().getPath().resolveModuleAsPath(importName);
moduleName = modulePath.toModuleName();
if (moduleName.startsWith("goog.")) {
t.getInput().addOrderedRequire("goog");
t.getInput().addOrderedRequire(moduleName);public void testGetRValueOfLValueDestructuring() {builder.append("$");
+ "Foo.$Foo$a = 0;"
+ "Bar.$Bar$a = 0;";
"{a=[[$Bar], [$Foo]]}");
"Expected : $Bar",
"Found    : $Foo",Name superclassNameObj = getOrCreateName(superclassName, false);import com.google.common.collect.ArrayListMultimap;
private final Set<Var> referenced = new HashSet<>();
private List<Var> maybeUnreferenced = new ArrayList<>();
private final Multimap<Var, Removable> assignsByVar =
ArrayListMultimap.create();
private final Set<Node> assignsByNode = new HashSet<>();
private final Multimap<Var, Node> classDefiningCalls =
ArrayListMultimap.create();
private final Multimap<Var, Continuation> continuations =
ArrayListMultimap.create();
private final ScopeCreator scopeCreator;
traverseNode(root, null, scope);
if (removeGlobals) {
collectMaybeUnreferencedVars(scope);
interpretAssigns();
private void traverseNode(Node n, Node parent, Scope scope) {
if (NodeUtil.isFunctionDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
traverseFunction(n, scope);
return;
Assign maybeAssign = Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
var = scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var, maybeAssign);
assignsByNode.add(maybeAssign.nameNode);
if (isRemovableVar(var)
&& !maybeAssign.mayHaveSecondarySideEffects) {
continuations.put(var, new Continuation(n, scope));
return;
Var modifiedVar = null;
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
modifiedVar = scope.getVar(subclassRelationship.subclassName);
String className = codingConvention.getSingletonGetterClassName(n);
if (className != null) {
modifiedVar = scope.getVar(className);
if (modifiedVar != null && modifiedVar.isGlobal()
&& !referenced.contains(modifiedVar)) {
classDefiningCalls.put(modifiedVar, parent);
continuations.put(modifiedVar, new Continuation(n, scope));
return;
case BLOCK:
if (NodeUtil.createsBlockScope(n)) {
Scope blockScope = scopeCreator.createScope(n, scope);
collectMaybeUnreferencedVars(blockScope);
scope = blockScope;
if (NodeUtil.isClassDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
return;
case DEFAULT_VALUE: {
Node target = n.getFirstChild();
if (target.isName()) {
Node value = n.getLastChild();
var = scope.getVar(target.getString());
if (!NodeUtil.mayHaveSideEffects(value)) {
continuations.put(var, new Continuation(n, scope));
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
markReferencedVar(var);
assignsByNode.add(target);
break;
case REST: {
Node target = n.getFirstChild();
if (target.isName()) {
assignsByNode.add(target);
var = scope.getVar(target.getString());
assignsByVar.put(var, new DestructuringAssign(n, target));
break;
case ARRAY_PATTERN:
for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {
if (c.isName()) {
assignsByNode.add(c);
var = scope.getVar(c.getString());
assignsByVar.put(var, new DestructuringAssign(c, c));
case COMPUTED_PROP:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
Node value = n.getFirstChild();
if (!NodeUtil.mayHaveSideEffects(value)) {
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
Node defaultTarget = target.getFirstChild();
var = scope.getVar(defaultTarget.getString());
markReferencedVar(var);
case STRING_KEY:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
case NAME:
if (parent.isParamList()) {
break;
var = scope.getVar(n.getString());
if (NodeUtil.isNameDeclaration(parent)) {
Node value = n.getFirstChild();
if (value != null && var != null && isRemovableVar(var)
&& !NodeUtil.mayHaveSideEffects(value, compiler)) {
continuations.put(var, new Continuation(n, scope));
return;
if (var != null
&& "arguments".equals(n.getString())
&& var.equals(scope.getArgumentsVar())) {
Scope fnScope = var.getScope();
Node paramList = NodeUtil.getFunctionParameters(fnScope.getRootNode());
for (Node p : NodeUtil.findLhsNodesInNode(paramList)) {
Var paramVar = fnScope.getOwnSlot(p.getString());
checkNotNull(paramVar);
markReferencedVar(paramVar);
if (isRemovableVar(var)) {
if (!assignsByNode.contains(n)) {
markReferencedVar(var);
markReferencedVar(var);
traverseChildren(n, scope);
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, n, scope);
private boolean isRemovableVar(Var var) {
if (var.equals(var.getScope().getArgumentsVar())) {
return false;
if (!removeGlobals && var.isGlobal()) {
return false;
if (var.getParentNode() != null && NodeUtil.isEnhancedFor(var.getParentNode().getParent())) {
return false;
if (referenced.contains(var)) {
return false;
return !codingConvention.isExported(var.getName());
collectMaybeUnreferencedVars(fparamScope);
collectMaybeUnreferencedVars(fbodyScope);
private void collectMaybeUnreferencedVars(Scope scope) {
for (Var var : scope.getVarIterable()) {
if (isRemovableVar(var)) {
maybeUnreferenced.add(var);
if (!referenced.contains(var)) {
if (!referenced.contains(var)) {
private void interpretAssigns() {
boolean changes = false;
do {
changes = false;
int removedCount = 0;
for (int current = 0; current < maybeUnreferenced.size(); current++) {
Var var = maybeUnreferenced.get(current);
if (var == null) {
continue;
if (referenced.contains(var)) {
maybeUnreferenced.set(current, null);
removedCount++;
boolean assignedToUnknownValue = false;
if (NodeUtil.isNameDeclaration(var.getParentNode())
&& !var.getParentNode().getParent().isForIn()) {
Node value = var.getInitialValue();
assignedToUnknownValue = value != null
&& !NodeUtil.isLiteralValue(value, true);
assignedToUnknownValue = false;
assignedToUnknownValue = true;
boolean maybeEscaped = false;
boolean hasPropertyAssign = false;
for (Removable removable : assignsByVar.get(var)) {
if (removable instanceof DestructuringAssign) {
assignedToUnknownValue = true;
continue;
Assign assign = (Assign) removable;
if (assign.isPropertyAssign) {
hasPropertyAssign = true;
assign.assignNode.getLastChild(), true)) {
assignedToUnknownValue = true;
if (assign.maybeAliased) {
maybeEscaped = true;
if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
changes = markReferencedVar(var) || changes;
maybeUnreferenced.set(current, null);
removedCount++;
if (removedCount > 0) {
int size = maybeUnreferenced.size();
ArrayList<Var> refreshed = new ArrayList<>(size - removedCount);
for (int i = 0; i < size; i++) {
Var var = maybeUnreferenced.get(i);
if (var != null) {
refreshed.add(var);
maybeUnreferenced = refreshed;
private void removeAllAssigns(Var var) {
for (Removable removable : assignsByVar.get(var)) {
removable.remove(compiler);
private boolean markReferencedVar(Var var) {
if (referenced.add(var)) {
for (Continuation c : continuations.get(var)) {
c.apply();
return true;
return false;
for (Var var : maybeUnreferenced) {
for (Node exprCallNode : classDefiningCalls.get(var)) {
compiler.reportChangeToEnclosingScope(exprCallNode);
NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);
removeAllAssigns(var);
compiler.addToDebugLog("Unreferenced var: ", var.name);
Node nameNode = var.nameNode;
if (toRemove == null) {
continue;
Node parent = toRemove != null ? toRemove.getParent() : null;
Node grandParent = parent != null ? parent.getParent() : null;
if (toRemove.isDefaultValue() || toRemove.isRest()) {
checkState(parent == null || grandParent == null);
checkState(parent == null, "unremoved destructuring ", toRemove);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(toRemove, nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
compiler.reportChangeToEnclosingScope(nameNode);
NodeUtil.removeChild(toRemove, nameNode);
&& nameNode.hasChildren()
&& NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {
if (toRemove.hasOneChild()) {
compiler.reportChangeToEnclosingScope(toRemove);
parent.replaceChild(toRemove,
IR.exprResult(nameNode.removeFirstChild()));
compiler.reportChangeToEnclosingScope(toRemove);
toRemove.removeChild(nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
NodeUtil.markFunctionsDeleted(toRemove, compiler);
if (NodeUtil.isFunctionDeclaration(node)) {
for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {
traverseNode(child, node, scope);
private static interface Removable {
public void remove(AbstractCompiler compiler);
private class DestructuringAssign implements Removable {
DestructuringAssign(Node removableNode, Node nameNode) {
public void remove(AbstractCompiler compiler) {
private static class Assign implements Removable {
final boolean isPropertyAssign;
final boolean mayHaveSecondarySideEffects;
Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {
this.isPropertyAssign = isPropertyAssign;
this.mayHaveSecondarySideEffects =
maybeAliased
|| NodeUtil.mayHaveSideEffects(assignNode.getFirstChild())
|| NodeUtil.mayHaveSideEffects(assignNode.getLastChild());
static Assign maybeCreateAssign(Node assignNode) {
checkState(NodeUtil.isAssignmentOp(assignNode));
boolean isPropAssign = false;
Node current = assignNode.getFirstChild();
if (NodeUtil.isGet(current)) {
current = current.getFirstChild();
isPropAssign = true;
if (current.isGetProp()
&& current.getLastChild().getString().equals("prototype")) {
current = current.getFirstChild();
if (current.isName()) {
return new Assign(assignNode, current, isPropAssign);
return null;
public void remove(AbstractCompiler compiler) {
compiler.reportChangeToEnclosingScope(assignNode);
if (mayHaveSecondarySideEffects) {
Node replacement = assignNode.getLastChild().detach();
for (Node current = assignNode.getFirstChild();
!current.isName();
current = current.getFirstChild()) {
if (current.isGetElem()) {
replacement = IR.comma(
current.getLastChild().detach(), replacement);
replacement.useSourceInfoIfMissingFrom(current);
assignNode.replaceWith(replacement);
Node parent = assignNode.getParent();
if (parent.isExprResult()) {
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).srcref(assignNode));
super("function alert() {}");
testSame("for(let x; ;){}");
testSame("for(let x, y; ;) {x} ");
testSame("for(let x=0,y=0;;y++){}");
testSame("for(item in items){}");
testSame("for(item of items){}");return nt.isLiteralObject() || obj.isPrototypeObject() || obj.isNamespace()
? this : nt.getInstanceAsJSType();ObjectTypeI iterableType = null;
iterableType = iterable.getTypeI().autobox().toMaybeObjectType();
typeParam = iterableType.getTemplateTypes().get(0);
public JSType getInstantiatedTypeArgument(JSType supertype) {
supertype.getNominalTypeIfSingletonObj().getRawNominalType();
"function Map(key, val) {};",
" * @param {!Map<K, (V | !Box<V>)>} inMap",
"var inMap = new Map('asdf', getUnion(123));",
CompilerTypeTestCase.DEFAULT_EXTERNS + LINE_JOINER.join(
private final void parseAndTypeCheck(String externs, String js) {
TranspilationPasses.addEs6LatePasses(passes);
TranspilationPasses.addRewritePolyfillPass(passes);
protected final void typeCheck(String js, DiagnosticType... warningKinds) {
typeCheck(DEFAULT_EXTERNS, js, warningKinds);
typeCheck(DEFAULT_EXTERNS, js, warningKinds);
private final void typeCheck(
String externs, String js, DiagnosticType... warningKinds) {
private final void typeCheckMessageContentsHelper(
"}"));
"function f(/** Array<string> */ y) {",
"  for (var x of new Map([['a', 'b'], ['c', 'd']])) { y = x; }",
"function f(/** string */ y, /** number */ z) {",
"  for (var x of new Map([['a', 1], ['c', 1]])) { [y,z] = x; }",
"function f(/** string */ y, /** string */ z) {",
"  for (var x of new Map([['a', 1], ['c', 1]])) { [y,z] = x; }",
"function f(/** number */ z) {",
"}"));
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck("for (var x of 123) ;", NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(/** Array<number>? */ m) { for (var x of m); }",
NewTypeInference.INVALID_ARGUMENT_TYPE);import static com.google.common.base.Preconditions.checkArgument;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
private final Deque<Continuation> worklist = new ArrayDeque<>();
private final Map<Var, VarInfo> varInfoMap = new HashMap<>();
private final Set<String> referencedPropertyNames = new HashSet<>();
private final Multimap<String, VarInfo> varInfoForPropertyNameMap = HashMultimap.create();
private final List<Scope> allFunctionParamScopes = new ArrayList<>();
private final boolean removeUnusedProperties = false;
worklist.add(new Continuation(root, scope));
while (!worklist.isEmpty()) {
Continuation continuation = worklist.remove();
continuation.apply();
if (removeUnusedProperties) {
removeUnreferencedProperties();
private void removeUnreferencedProperties() {
for (VarInfo varInfo : varInfoForPropertyNameMap.values()) {
varInfo.removeUnreferencedProperties();
private void traverseNode(Node n, Scope scope) {
Node parent = n.getParent();
case CATCH:
traverseCatch(n, scope);
break;
case FUNCTION:
VarInfo varInfo = null;
if (NodeUtil.isFunctionDeclaration(n)) {
varInfo = getVarInfo(scope.getVar(n.getFirstChild().getString()));
FunctionDeclaration functionDeclaration =
new RemovableBuilder()
.addContinuation(new Continuation(n, scope))
.buildFunctionDeclaration(n);
varInfo.addRemovable(functionDeclaration);
if (parent.isExport()) {
varInfo.markAsReferenced();
traverseFunction(n, scope);
case ASSIGN:
traverseAssign(n, scope);
break;
case CALL:
traverseCall(n, scope);
traverseChildren(
n, NodeUtil.createsBlockScope(n) ? scopeCreator.createScope(n, scope) : scope);
case MODULE_BODY:
traverseChildren(n, scopeCreator.createScope(n, scope));
break;
case CLASS:
traverseClass(n, scope);
break;
case DEFAULT_VALUE:
traverseDefaultValue(n, scope);
break;
case REST:
traverseRest(n, scope);
break;
traverseArrayPattern(n, scope);
case OBJECT_PATTERN:
traverseObjectPattern(n, scope);
case OBJECTLIT:
traverseObjectLiteral(n, scope);
case FOR:
traverseVanillaFor(n, scope);
break;
case FOR_IN:
case FOR_OF:
traverseEnhancedFor(n, scope);
break;
case LET:
case CONST:
case VAR:
checkState(NodeUtil.isStatement(n));
traverseDeclarationStatement(n, scope);
break;
case NAME:
checkState(!n.hasChildren());
if (!parent.isParamList()) {
checkState(!NodeUtil.isNameDeclaration(parent));
checkState(!((parent.isFunction() || parent.isClass()) && parent.getFirstChild() == n));
var = scope.getVar(n.getString());
getVarInfo(var).markAsReferenced();
case GETPROP:
Node objectNode = n.getFirstChild();
Node propertyNameNode = objectNode.getNext();
String propertyName = propertyNameNode.getString();
markPropertyNameReferenced(propertyName);
traverseNode(objectNode, scope);
break;
traverseChildren(n, scope);
private void traverseCall(Node callNode, Scope scope) {
Node parent = callNode.getParent();
String classVarName = null;
if (parent.isExprResult() || parent.isComma() && parent.getFirstChild() == callNode) {
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(callNode);
if (subclassRelationship != null) {
classVarName = subclassRelationship.subclassName;
classVarName = codingConvention.getSingletonGetterClassName(callNode);
Var classVar = (classVarName == null) ? null : scope.getVar(classVarName);
if (classVar == null || !classVar.isGlobal()) {
traverseChildren(callNode, scope);
VarInfo classVarInfo = getVarInfo(classVar);
RemovableBuilder builder = new RemovableBuilder();
for (Node child = callNode.getFirstChild(); child != null; child = child.getNext()) {
builder.addContinuation(new Continuation(child, scope));
classVarInfo.addRemovable(builder.buildClassSetupCall(callNode));
private void traverseRest(Node restNode, Scope scope) {
Node target = restNode.getOnlyChild();
if (!target.isName()) {
traverseNode(target, scope);
Var var = scope.getVar(target.getString());
if (var != null) {
VarInfo varInfo = getVarInfo(var);
varInfo.addRemovable(new RemovableBuilder().buildDestructuringAssign(restNode, target));
private void traverseObjectLiteral(Node objectLiteral, Scope scope) {
for (Node propertyNode = objectLiteral.getFirstChild();
propertyNode != null;
propertyNode = propertyNode.getNext()) {
if (propertyNode.isStringKey() && !propertyNode.isQuotedString()) {
markPropertyNameReferenced(propertyNode.getString());
traverseNode(propertyNode.getFirstChild(), scope);
traverseNode(propertyNode, scope);
private void traverseCatch(Node catchNode, Scope scope) {
Node exceptionNameNode = catchNode.getFirstChild();
Node block = exceptionNameNode.getNext();
VarInfo exceptionVarInfo = getVarInfo(scope.getVar(exceptionNameNode.getString()));
exceptionVarInfo.setCannotRemoveAnything();
traverseNode(block, scope);
private void traverseEnhancedFor(Node enhancedFor, Scope scope) {
Scope forScope = scopeCreator.createScope(enhancedFor, scope);
Node iterationTarget = enhancedFor.getFirstChild();
Node collection = iterationTarget.getNext();
Node body = collection.getNext();
if (iterationTarget.isName()) {
VarInfo varInfo = getVarInfo(forScope.getVar(iterationTarget.getString()));
varInfo.setCannotRemoveAnything();
Node declNode = iterationTarget.getOnlyChild();
if (declNode.isDestructuringLhs()) {
traverseNode(declNode, forScope);
checkState(declNode.isName());
checkState(!declNode.hasChildren());
VarInfo varInfo = getVarInfo(forScope.getVar(declNode.getString()));
varInfo.setCannotRemoveAnything();
traverseNode(iterationTarget, forScope);
traverseNode(collection, forScope);
traverseNode(body, forScope);
private void traverseVanillaFor(Node forNode, Scope scope) {
Scope forScope = scopeCreator.createScope(forNode, scope);
Node initialization = forNode.getFirstChild();
Node condition = initialization.getNext();
Node update = condition.getNext();
Node block = update.getNext();
if (NodeUtil.isNameDeclaration(initialization)) {
traverseVanillaForNameDeclarations(initialization, forScope);
traverseNode(initialization, forScope);
traverseNode(condition, forScope);
traverseNode(update, forScope);
traverseNode(block, forScope);
private void traverseVanillaForNameDeclarations(Node nameDeclaration, Scope scope) {
for (Node child = nameDeclaration.getFirstChild(); child != null; child = child.getNext()) {
if (!child.isName()) {
traverseNode(child, scope);
Node nameNode = child;
VarInfo varInfo = getVarInfo(scope.getVar(nameNode.getString()));
if (valueNode == null) {
varInfo.addRemovable(new RemovableBuilder().buildVanillaForNameDeclaration(nameNode));
varInfo.setIsExplicitlyNotRemovable();
traverseNode(valueNode, scope);
VanillaForNameDeclaration vanillaForNameDeclaration =
new RemovableBuilder()
.setAssignedValue(valueNode)
.addContinuation(new Continuation(valueNode, scope))
.buildVanillaForNameDeclaration(nameNode);
varInfo.addRemovable(vanillaForNameDeclaration);
private void traverseDeclarationStatement(Node declarationStatement, Scope scope) {
Node nameNode = declarationStatement.getOnlyChild();
if (!nameNode.isName()) {
traverseNode(nameNode, scope);
Node valueNode = nameNode.getFirstChild();
VarInfo varInfo = getVarInfo(checkNotNull(scope.getVar(nameNode.getString())));
RemovableBuilder builder = new RemovableBuilder();
if (valueNode == null) {
varInfo.addRemovable(builder.buildNameDeclarationStatement(declarationStatement));
if (NodeUtil.mayHaveSideEffects(valueNode)) {
traverseNode(valueNode, scope);
builder.addContinuation(new Continuation(valueNode, scope));
NameDeclarationStatement removable =
builder.setAssignedValue(valueNode).buildNameDeclarationStatement(declarationStatement);
varInfo.addRemovable(removable);
private void traverseAssign(Node assignNode, Scope scope) {
checkState(NodeUtil.isAssignmentOp(assignNode));
Node lhs = assignNode.getFirstChild();
Node nameNode = null;
Node propertyNode = null;
boolean isVariableAssign = false;
boolean isComputedPropertyAssign = false;
boolean isNamedPropertyAssign = false;
if (lhs.isName()) {
isVariableAssign = true;
nameNode = lhs;
propertyNode = lhs.getLastChild();
Node possibleNameNode = lhs.getFirstChild();
if (possibleNameNode.isGetProp()
&& possibleNameNode.getSecondChild().getString().equals("prototype")) {
possibleNameNode = possibleNameNode.getFirstChild();
if (possibleNameNode.isName()) {
nameNode = possibleNameNode;
if (lhs.isGetProp()) {
isNamedPropertyAssign = true;
checkState(lhs.isGetElem());
isComputedPropertyAssign = true;
Var var = (nameNode == null) ? null : scope.getVar(nameNode.getString());
if (var == null) {
traverseChildren(assignNode, scope);
Node valueNode = assignNode.getLastChild();
RemovableBuilder builder = new RemovableBuilder().setAssignedValue(valueNode);
if (NodeUtil.isExpressionResultUsed(assignNode) || NodeUtil.mayHaveSideEffects(valueNode)) {
traverseNode(valueNode, scope);
builder.addContinuation(new Continuation(valueNode, scope));
VarInfo varInfo = getVarInfo(var);
if (isNamedPropertyAssign) {
varInfo.addRemovable(builder.buildNamedPropertyAssign(assignNode, nameNode, propertyNode));
varInfo.addRemovable(builder.buildVariableAssign(assignNode, nameNode));
checkState(isComputedPropertyAssign);
if (NodeUtil.mayHaveSideEffects(propertyNode)) {
traverseNode(propertyNode, scope);
builder.addContinuation(new Continuation(propertyNode, scope));
varInfo.addRemovable(
builder.buildComputedPropertyAssign(assignNode, nameNode, propertyNode));
private void traverseDefaultValue(Node defaultValueNode, Scope scope) {
Var var;
Node target = defaultValueNode.getFirstChild();
Node value = target.getNext();
if (!target.isName()) {
traverseNode(target, scope);
traverseNode(value, scope);
var = scope.getVar(target.getString());
if (var == null) {
traverseNode(value, scope);
VarInfo varInfo = getVarInfo(var);
if (NodeUtil.mayHaveSideEffects(value)) {
varInfo.markAsReferenced();
traverseNode(value, scope);
DestructuringAssign assign =
new RemovableBuilder()
.addContinuation(new Continuation(value, scope))
.buildDestructuringAssign(defaultValueNode, target);
varInfo.addRemovable(assign);
private void traverseArrayPattern(Node arrayPattern, Scope scope) {
for (Node c = arrayPattern.getFirstChild(); c != null; c = c.getNext()) {
if (!c.isName()) {
traverseNode(c, scope);
Var var = scope.getVar(c.getString());
if (var != null) {
VarInfo varInfo = getVarInfo(var);
varInfo.addRemovable(new RemovableBuilder().buildDestructuringAssign(c, c));
private void traverseObjectPattern(Node objectPattern, Scope scope) {
for (Node propertyNode = objectPattern.getFirstChild();
propertyNode != null;
propertyNode = propertyNode.getNext()) {
traverseObjectPatternElement(propertyNode, scope);
private void traverseObjectPatternElement(Node elm, Scope scope) {
Node propertyExpression = null;
String propertyName = null;
Node target = null;
Node defaultValue = null;
if (elm.isComputedProp()) {
propertyExpression = elm.getFirstChild();
target = elm.getLastChild();
checkState(elm.isStringKey());
target = elm.getOnlyChild();
if (!elm.isQuotedString()) {
propertyName = elm.getString();
if (target.isDefaultValue()) {
target = target.getFirstChild();
defaultValue = checkNotNull(target.getNext());
Var var = target.isName() ? scope.getVar(target.getString()) : null;
boolean cannotRemove =
var == null
|| (propertyExpression != null && NodeUtil.mayHaveSideEffects(propertyExpression))
|| (defaultValue != null && NodeUtil.mayHaveSideEffects(defaultValue));
if (cannotRemove) {
if (propertyExpression != null) {
traverseNode(propertyExpression, scope);
if (propertyName != null) {
markPropertyNameReferenced(propertyName);
traverseNode(target, scope);
if (defaultValue != null) {
traverseNode(defaultValue, scope);
if (var != null) {
getVarInfo(var).markAsReferenced();
RemovableBuilder builder = new RemovableBuilder();
if (propertyName != null) {
markPropertyNameReferenced(propertyName);
if (propertyExpression != null) {
builder.addContinuation(new Continuation(propertyExpression, scope));
if (defaultValue != null) {
builder.addContinuation(new Continuation(defaultValue, scope));
getVarInfo(var).addRemovable(builder.buildDestructuringAssign(elm, target));
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, scope);
private void traverseClass(Node classNode, Scope scope) {
checkArgument(classNode.isClass());
Node classNameNode = classNode.getFirstChild();
Node baseClassExpression = classNameNode.getNext();
Node classBodyNode = baseClassExpression.getNext();
Scope classScope = scopeCreator.createScope(classNode, scope);
if (!NodeUtil.isNamedClass(classNode) || classNode.getParent().isExport()) {
traverseNode(baseClassExpression, classScope);
traverseNode(classBodyNode, classScope);
traverseNode(baseClassExpression, classScope);
traverseNode(classBodyNode, classScope);
RemovableBuilder builder =
new RemovableBuilder()
.addContinuation(new Continuation(baseClassExpression, classScope))
.addContinuation(new Continuation(classBodyNode, classScope));
VarInfo varInfo = getVarInfo(classScope.getVar(classNameNode.getString()));
if (NodeUtil.isClassDeclaration(classNode)) {
varInfo.addRemovable(builder.buildClassDeclaration(classNode));
varInfo.addRemovable(builder.buildNamedClassExpression(classNode));
getFunctionNameVarInfo(function, fparamScope);
if (NodeUtil.isVarArgsFunction(function)) {
for (Node p : NodeUtil.findLhsNodesInNode(paramlist)) {
Var paramVar = checkNotNull(fparamScope.getOwnSlot(p.getString()));
getVarInfo(paramVar).markAsReferenced();
private VarInfo getFunctionNameVarInfo(Node function, Scope scope) {
Node nameNode = checkNotNull(function.getFirstChild());
checkState(nameNode.isName());
String name = nameNode.getString();
if (name.isEmpty()) {
return null;
Var var = checkNotNull(scope.getVar(name));
return getVarInfo(var);
private void markPropertyNameReferenced(String propertyName) {
if (referencedPropertyNames.add(propertyName)) {
for (VarInfo varInfo : varInfoForPropertyNameMap.get(propertyName)) {
varInfo.markPropertyNameReferenced(propertyName);
VarInfo varInfo = getVarInfo(var);
if (varInfo.isRemovable()) {
VarInfo varInfo = getVarInfo(var);
if (varInfo.isRemovable()) {
private VarInfo getVarInfo(Var var) {
checkNotNull(var);
VarInfo varInfo = varInfoMap.get(var);
if (varInfo == null) {
varInfo = new VarInfo(var);
varInfoMap.put(var, varInfo);
return varInfo;
for (VarInfo varInfo : varInfoMap.values()) {
if (!varInfo.isRemovable()) {
continue;
varInfo.removeAllRemovables();
compiler.addToDebugLog("Unreferenced var: ", varInfo.var.name);
Node nameNode = varInfo.var.nameNode;
if (toRemove == null || alreadyRemoved(toRemove)) {
throw new IllegalStateException("unremoved code");
if (node.isFunction()) {
traverseNode(node, scope);
private abstract class Removable {
private final List<Continuation> continuations;
private boolean continuationsAreApplied = false;
private boolean isRemoved = false;
Removable(RemovableBuilder builder) {
continuations = builder.continuations;
propertyName = builder.propertyName;
assignedValue = builder.assignedValue;
String getPropertyName() {
checkState(isNamedPropertyAssignment());
return checkNotNull(propertyName);
abstract void removeInternal(AbstractCompiler compiler);
void remove(AbstractCompiler compiler) {
if (!isRemoved) {
isRemoved = true;
removeInternal(compiler);
public void applyContinuations() {
if (!continuationsAreApplied) {
continuationsAreApplied = true;
for (Continuation c : continuations) {
worklist.add(c);
continuations.clear();
boolean isLiteralValueAssignment() {
return assignedValue == null
|| NodeUtil.isLiteralValue(assignedValue, /* includeFunctions */ true);
boolean isVariableAssignment() {
return false;
boolean isPropertyAssignment() {
return false;
boolean isNamedPropertyAssignment() {
return propertyName != null;
boolean assignedValueMayEscape() {
return false;
private class RemovableBuilder {
final List<Continuation> continuations = new ArrayList<>();
RemovableBuilder addContinuation(Continuation continuation) {
continuations.add(continuation);
return this;
RemovableBuilder setAssignedValue(@Nullable Node assignedValue) {
this.assignedValue = assignedValue;
return this;
DestructuringAssign buildDestructuringAssign(Node removableNode, Node nameNode) {
return new DestructuringAssign(this, removableNode, nameNode);
ClassDeclaration buildClassDeclaration(Node classNode) {
return new ClassDeclaration(this, classNode);
NamedClassExpression buildNamedClassExpression(Node classNode) {
return new NamedClassExpression(this, classNode);
FunctionDeclaration buildFunctionDeclaration(Node functionNode) {
return new FunctionDeclaration(this, functionNode);
NameDeclarationStatement buildNameDeclarationStatement(Node declarationStatement) {
return new NameDeclarationStatement(this, declarationStatement);
Assign buildNamedPropertyAssign(Node assignNode, Node nameNode, Node propertyNode) {
this.propertyName = propertyNode.getString();
checkNotNull(assignedValue);
return new Assign(this, assignNode, nameNode, Kind.NAMED_PROPERTY, propertyNode);
Assign buildComputedPropertyAssign(Node assignNode, Node nameNode, Node propertyNode) {
checkNotNull(assignedValue);
return new Assign(this, assignNode, nameNode, Kind.COMPUTED_PROPERTY, propertyNode);
Assign buildVariableAssign(Node assignNode, Node nameNode) {
return new Assign(this, assignNode, nameNode, Kind.VARIABLE, /* propertyNode */ null);
ClassSetupCall buildClassSetupCall(Node callNode) {
return new ClassSetupCall(this, callNode);
VanillaForNameDeclaration buildVanillaForNameDeclaration(Node nameNode) {
return new VanillaForNameDeclaration(this, nameNode);
private class DestructuringAssign extends Removable {
DestructuringAssign(RemovableBuilder builder, Node removableNode, Node nameNode) {
super(builder);
boolean isVariableAssignment() {
return true;
boolean isLiteralValueAssignment() {
return false;
public void removeInternal(AbstractCompiler compiler) {
if (alreadyRemoved(removableNode)) {
return;
private class ClassDeclaration extends Removable {
final Node classDeclarationNode;
ClassDeclaration(RemovableBuilder builder, Node classDeclarationNode) {
super(builder);
this.classDeclarationNode = classDeclarationNode;
public void removeInternal(AbstractCompiler compiler) {
NodeUtil.deleteNode(classDeclarationNode, compiler);
private class NamedClassExpression extends Removable {
final Node classNode;
NamedClassExpression(RemovableBuilder builder, Node classNode) {
super(builder);
this.classNode = classNode;
public void removeInternal(AbstractCompiler compiler) {
if (!alreadyRemoved(classNode)) {
Node nameNode = classNode.getFirstChild();
if (!nameNode.isEmpty()) {
classNode.replaceChild(nameNode, IR.empty().useSourceInfoFrom(nameNode));
compiler.reportChangeToEnclosingScope(classNode);
private class FunctionDeclaration extends Removable {
final Node functionDeclarationNode;
FunctionDeclaration(RemovableBuilder builder, Node functionDeclarationNode) {
super(builder);
this.functionDeclarationNode = functionDeclarationNode;
public void removeInternal(AbstractCompiler compiler) {
NodeUtil.deleteNode(functionDeclarationNode, compiler);
private class NameDeclarationStatement extends Removable {
private final Node declarationStatement;
public NameDeclarationStatement(RemovableBuilder builder, Node declarationStatement) {
super(builder);
this.declarationStatement = declarationStatement;
void removeInternal(AbstractCompiler compiler) {
Node nameNode = declarationStatement.getOnlyChild();
Node valueNode = nameNode.getFirstChild();
if (valueNode != null && NodeUtil.mayHaveSideEffects(valueNode)) {
compiler.reportChangeToEnclosingScope(declarationStatement);
valueNode.detach();
declarationStatement.replaceWith(IR.exprResult(valueNode).useSourceInfoFrom(valueNode));
NodeUtil.deleteNode(declarationStatement, compiler);
boolean isVariableAssignment() {
return true;
enum Kind {
VARIABLE,
NAMED_PROPERTY,
COMPUTED_PROPERTY;
private class Assign extends Removable {
final Node assignNode;
final Kind kind;
Assign(
RemovableBuilder builder,
Node assignNode,
Node nameNode,
Kind kind,
super(builder);
if (kind == Kind.VARIABLE) {
checkArgument(
propertyNode == null,
"got property node for simple variable assignment: %s",
propertyNode);
checkArgument(propertyNode != null, "missing property node");
if (kind == Kind.NAMED_PROPERTY) {
checkArgument(propertyNode.isString(), "property name is not a string: %s", propertyNode);
this.kind = kind;
this.propertyNode = propertyNode;
boolean assignedValueMayEscape() {
return maybeAliased;
boolean isVariableAssignment() {
return kind == Kind.VARIABLE;
boolean isPropertyAssignment() {
return isNamedPropertyAssignment() || isComputedPropertyAssignment();
boolean isNamedPropertyAssignment() {
return kind == Kind.NAMED_PROPERTY;
boolean isComputedPropertyAssignment() {
return kind == Kind.COMPUTED_PROPERTY;
public void removeInternal(AbstractCompiler compiler) {
if (alreadyRemoved(assignNode)) {
return;
Node parent = assignNode.getParent();
compiler.reportChangeToEnclosingScope(parent);
Node lhs = assignNode.getFirstChild();
Node rhs = assignNode.getSecondChild();
boolean mustPreserveRhs =
NodeUtil.mayHaveSideEffects(rhs) || NodeUtil.isExpressionResultUsed(assignNode);
boolean mustPreserveGetElmExpr =
lhs.isGetElem() && NodeUtil.mayHaveSideEffects(lhs.getLastChild());
if (mustPreserveRhs && mustPreserveGetElmExpr) {
Node replacement =
IR.comma(lhs.getLastChild().detach(), rhs.detach()).useSourceInfoFrom(assignNode);
assignNode.replaceWith(lhs.getLastChild().detach());
NodeUtil.markFunctionsDeleted(rhs, compiler);
assignNode.replaceWith(rhs.detach());
NodeUtil.markFunctionsDeleted(lhs, compiler);
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).useSourceInfoFrom(assignNode));
NodeUtil.markFunctionsDeleted(assignNode, compiler);
private class ClassSetupCall extends Removable {
final Node callNode;
ClassSetupCall(RemovableBuilder builder, Node callNode) {
super(builder);
this.callNode = callNode;
public void removeInternal(AbstractCompiler compiler) {
Node parent = callNode.getParent();
if (parent.isExprResult()) {
NodeUtil.deleteNode(parent, compiler);
checkState(parent.isComma());
Node rhs = checkNotNull(callNode.getNext());
compiler.reportChangeToEnclosingScope(parent);
parent.replaceWith(rhs.detach());
private class VarInfo {
final Var var;
final List<Removable> removables = new ArrayList<>();
Multimap<String, Removable> namedPropertyRemovables = null;
boolean isEntirelyRemovable = true;
boolean unreferencedPropertiesMayBeRemoved = removeUnusedProperties;
boolean propertyAssignmentsWillPreventRemoval = false;
boolean hasPropertyAssignments = false;
VarInfo(Var var) {
this.var = var;
boolean isGlobal = var.isGlobal();
if (isGlobal && !removeGlobals) {
setCannotRemoveAnything();
setCannotRemoveAnything();
setCannotRemoveAnything();
propertyAssignmentsWillPreventRemoval = true;
unreferencedPropertiesMayBeRemoved = false;
void addRemovable(Removable removable) {
if (removable.isPropertyAssignment()) {
hasPropertyAssignments = true;
if (propertyAssignmentsWillPreventRemoval) {
setIsExplicitlyNotRemovable();
&& (removable.assignedValueMayEscape() || !removable.isLiteralValueAssignment())) {
propertyAssignmentsWillPreventRemoval = true;
if (hasPropertyAssignments) {
setIsExplicitlyNotRemovable();
if (removable.isNamedPropertyAssignment()) {
String propertyName = removable.getPropertyName();
if (isPropertyRemovable(propertyName)) {
if (namedPropertyRemovables == null) {
namedPropertyRemovables = HashMultimap.create();
namedPropertyRemovables.put(propertyName, removable);
varInfoForPropertyNameMap.put(propertyName, this);
removable.applyContinuations();
removables.add(removable);
removable.applyContinuations();
boolean markAsReferenced() {
return setIsExplicitlyNotRemovable();
void markPropertyNameReferenced(String propertyName) {
if (!isEntirelyRemovable && namedPropertyRemovables != null) {
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.applyContinuations();
boolean isRemovable() {
return isEntirelyRemovable;
void setCannotRemoveAnything() {
unreferencedPropertiesMayBeRemoved = false;
setIsExplicitlyNotRemovable();
boolean isPropertyRemovable(String propertyName) {
return isEntirelyRemovable
|| unreferencedPropertiesMayBeRemoved && !referencedPropertyNames.contains(propertyName);
boolean setIsExplicitlyNotRemovable() {
if (isEntirelyRemovable) {
isEntirelyRemovable = false;
for (Removable r : removables) {
r.applyContinuations();
removables.clear();
if (namedPropertyRemovables != null) {
for (String propertyName : ImmutableList.copyOf(namedPropertyRemovables.keySet())) {
if (!isPropertyRemovable(propertyName)) {
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.applyContinuations();
return true;
return false;
void removeAllRemovables() {
checkState(isEntirelyRemovable);
for (Removable removable : removables) {
removable.remove(compiler);
removables.clear();
if (namedPropertyRemovables != null) {
for (Removable removable : namedPropertyRemovables.values()) {
removable.remove(compiler);
namedPropertyRemovables.clear();
namedPropertyRemovables = null;
void removeUnreferencedProperties() {
checkState(!isEntirelyRemovable && unreferencedPropertiesMayBeRemoved);
if (namedPropertyRemovables != null) {
for (String propertyName : ImmutableList.copyOf(namedPropertyRemovables.keySet())) {
checkState(!referencedPropertyNames.contains(propertyName));
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.remove(compiler);
private class VanillaForNameDeclaration extends Removable {
private final Node nameNode;
private VanillaForNameDeclaration(RemovableBuilder builder, Node nameNode) {
super(builder);
this.nameNode = nameNode;
void removeInternal(AbstractCompiler compiler) {
Node declaration = checkNotNull(nameNode.getParent());
compiler.reportChangeToEnclosingScope(declaration);
if (nameNode.getPrevious() == null && nameNode.getNext() == null) {
declaration.replaceWith(IR.empty().useSourceInfoFrom(declaration));
declaration.removeChild(nameNode);
NodeUtil.markFunctionsDeleted(nameNode, compiler);
public void testUsageBeforeDefinition() {
test("function f(a) { x[a] = 1; } var x; x = {}; f();", "function f() {} f();");
public void testReferencedPropertiesOnUnreferencedVar() {
test("var x = {}; x.a = 1; var y = {a: 2}; y.a;", "var y = {a: 2}; y.a;");
public void testPropertyValuesAddedAfterReferenceAreRemoved() {
testSame("var x = 1; var y = {}; y; y.foo = x;");
public void testReferenceInObjectLiteral() {
testSame(LINE_JOINER.join(
"function f(a) {",
"  return {a: a};",
"}",
"f(1);"));
public void testSelfOverwrite() {
testSame("var a = function() { a = function() {}; }; a();");
public void testPropertyReferenceAddsPropertyReference() {
testSame("var a = {}; a.foo = function() { b.foo = 1; }; var b = {}; a.foo(); b.foo;");
public void testUnknownVarDestructuredAssign() {
testSame("({a:x} = {a:1});");
testSame("({a:x = 1} = {});");
testSame("({['a']:x} = {a:1});");
testSame("({['a']:x = 1} = {});");
testSame("[x] = [1];");
testSame("[x = 1] = [];");
testSame("[, ...x] = [1];");
testSame("[, ...[x = 1]] = [1];");
public void testRemoveVarDeclaration1() {
test("var a = 0, b = a = 1", "");
public void testRemoveVarDeclaration2() {
test("var a;var b = 0, c = a = b = 1", "");
public void testDollarSuperParameterNotRemoved() {
testSame("function f($super) {} f();");
public void testFunctionArgRemovalWithLeadingUnderscore() {
test("function f(__$jscomp$1) {__$jscomp$1 = 1;} f();", "function f() {} f();");
public void testES6ModuleExports() {
test("const X = 1; function f() {}", "");
test("const X = 1; export function f() {}", "function f() {} export {f as f}");
test("const X = 1; export class C {}", "class C {} export { C as C }");
test("const X = 1; export default function f() {};", "export default function f() {}");
test("const X = 1; export default class C {}", "export default class C {}");
public void testRemoveInheritedClass12() {
testSame(
LINE_JOINER.join(
"function goog$inherits(){}",
"function a(){}",
"function b(){}",
"goog$inherits(b, a) + 1;"));
test(
LINE_JOINER.join(
"function goog$inherits(){}",
"function a(){}",
"function b(){}",
"(goog$inherits(b, a), 1);"),
"1");
test("var C = class {};", "");
test("var C = class X {}; new C;", "var C = class {}; new C;");
public void testReferencesInClasses() {
testSame(
LINE_JOINER.join(
"const A = 15;",
"const C = class {",
"  constructor() {",
"    this.a = A;",
"  }",
"}",
"new C;"));
test("for(let x; ;){}", "for(;;){}");
test("for(let x, y; ;) {x}", "for(let x; ;) {x}");
test("for(let x, y; ;) {y}", "for(let y; ;) {y}");
test("for(let x=0,y=0;;y++){}", "for(let y=0;;y++){}");
testSame("let item; for(item in items){}");
testSame("for(let item in items){}");
testSame("let item; for(item of items){}");import com.google.common.collect.ArrayListMultimap;
private final Set<Var> referenced = new HashSet<>();
private List<Var> maybeUnreferenced = new ArrayList<>();
private final Multimap<Var, Removable> assignsByVar =
ArrayListMultimap.create();
private final Set<Node> assignsByNode = new HashSet<>();
private final Multimap<Var, Node> classDefiningCalls =
ArrayListMultimap.create();
private final Multimap<Var, Continuation> continuations =
ArrayListMultimap.create();
private final ScopeCreator scopeCreator;
traverseNode(root, null, scope);
if (removeGlobals) {
collectMaybeUnreferencedVars(scope);
interpretAssigns();
private void traverseNode(Node n, Node parent, Scope scope) {
if (NodeUtil.isFunctionDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
traverseFunction(n, scope);
return;
Assign maybeAssign = Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
var = scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var, maybeAssign);
assignsByNode.add(maybeAssign.nameNode);
if (isRemovableVar(var)
&& !maybeAssign.mayHaveSecondarySideEffects) {
continuations.put(var, new Continuation(n, scope));
return;
Var modifiedVar = null;
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
modifiedVar = scope.getVar(subclassRelationship.subclassName);
String className = codingConvention.getSingletonGetterClassName(n);
if (className != null) {
modifiedVar = scope.getVar(className);
if (modifiedVar != null && modifiedVar.isGlobal()
&& !referenced.contains(modifiedVar)) {
classDefiningCalls.put(modifiedVar, parent);
continuations.put(modifiedVar, new Continuation(n, scope));
return;
case BLOCK:
if (NodeUtil.createsBlockScope(n)) {
Scope blockScope = scopeCreator.createScope(n, scope);
collectMaybeUnreferencedVars(blockScope);
scope = blockScope;
if (NodeUtil.isClassDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
return;
case DEFAULT_VALUE: {
Node target = n.getFirstChild();
if (target.isName()) {
Node value = n.getLastChild();
var = scope.getVar(target.getString());
if (!NodeUtil.mayHaveSideEffects(value)) {
continuations.put(var, new Continuation(n, scope));
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
markReferencedVar(var);
assignsByNode.add(target);
break;
case REST: {
Node target = n.getFirstChild();
if (target.isName()) {
assignsByNode.add(target);
var = scope.getVar(target.getString());
assignsByVar.put(var, new DestructuringAssign(n, target));
break;
case ARRAY_PATTERN:
for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {
if (c.isName()) {
assignsByNode.add(c);
var = scope.getVar(c.getString());
assignsByVar.put(var, new DestructuringAssign(c, c));
case COMPUTED_PROP:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
Node value = n.getFirstChild();
if (!NodeUtil.mayHaveSideEffects(value)) {
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
Node defaultTarget = target.getFirstChild();
var = scope.getVar(defaultTarget.getString());
markReferencedVar(var);
case STRING_KEY:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
case NAME:
if (parent.isParamList()) {
break;
var = scope.getVar(n.getString());
if (NodeUtil.isNameDeclaration(parent)) {
Node value = n.getFirstChild();
if (value != null && var != null && isRemovableVar(var)
&& !NodeUtil.mayHaveSideEffects(value, compiler)) {
continuations.put(var, new Continuation(n, scope));
return;
if (var != null
&& "arguments".equals(n.getString())
&& var.equals(scope.getArgumentsVar())) {
Scope fnScope = var.getScope();
Node paramList = NodeUtil.getFunctionParameters(fnScope.getRootNode());
for (Node p : NodeUtil.findLhsNodesInNode(paramList)) {
Var paramVar = fnScope.getOwnSlot(p.getString());
checkNotNull(paramVar);
markReferencedVar(paramVar);
if (isRemovableVar(var)) {
if (!assignsByNode.contains(n)) {
markReferencedVar(var);
markReferencedVar(var);
traverseChildren(n, scope);
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, n, scope);
private boolean isRemovableVar(Var var) {
if (var.equals(var.getScope().getArgumentsVar())) {
return false;
if (!removeGlobals && var.isGlobal()) {
return false;
if (var.getParentNode() != null && NodeUtil.isEnhancedFor(var.getParentNode().getParent())) {
return false;
if (referenced.contains(var)) {
return false;
return !codingConvention.isExported(var.getName());
collectMaybeUnreferencedVars(fparamScope);
collectMaybeUnreferencedVars(fbodyScope);
private void collectMaybeUnreferencedVars(Scope scope) {
for (Var var : scope.getVarIterable()) {
if (isRemovableVar(var)) {
maybeUnreferenced.add(var);
if (!referenced.contains(var)) {
if (!referenced.contains(var)) {
private void interpretAssigns() {
boolean changes = false;
do {
changes = false;
int removedCount = 0;
for (int current = 0; current < maybeUnreferenced.size(); current++) {
Var var = maybeUnreferenced.get(current);
if (var == null) {
continue;
if (referenced.contains(var)) {
maybeUnreferenced.set(current, null);
removedCount++;
boolean assignedToUnknownValue = false;
if (NodeUtil.isNameDeclaration(var.getParentNode())
&& !var.getParentNode().getParent().isForIn()) {
Node value = var.getInitialValue();
assignedToUnknownValue = value != null
&& !NodeUtil.isLiteralValue(value, true);
assignedToUnknownValue = false;
assignedToUnknownValue = true;
boolean maybeEscaped = false;
boolean hasPropertyAssign = false;
for (Removable removable : assignsByVar.get(var)) {
if (removable instanceof DestructuringAssign) {
assignedToUnknownValue = true;
continue;
Assign assign = (Assign) removable;
if (assign.isPropertyAssign) {
hasPropertyAssign = true;
assign.assignNode.getLastChild(), true)) {
assignedToUnknownValue = true;
if (assign.maybeAliased) {
maybeEscaped = true;
if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
changes = markReferencedVar(var) || changes;
maybeUnreferenced.set(current, null);
removedCount++;
if (removedCount > 0) {
int size = maybeUnreferenced.size();
ArrayList<Var> refreshed = new ArrayList<>(size - removedCount);
for (int i = 0; i < size; i++) {
Var var = maybeUnreferenced.get(i);
if (var != null) {
refreshed.add(var);
maybeUnreferenced = refreshed;
private void removeAllAssigns(Var var) {
for (Removable removable : assignsByVar.get(var)) {
removable.remove(compiler);
private boolean markReferencedVar(Var var) {
if (referenced.add(var)) {
for (Continuation c : continuations.get(var)) {
c.apply();
return true;
return false;
for (Var var : maybeUnreferenced) {
for (Node exprCallNode : classDefiningCalls.get(var)) {
compiler.reportChangeToEnclosingScope(exprCallNode);
NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);
removeAllAssigns(var);
compiler.addToDebugLog("Unreferenced var: ", var.name);
Node nameNode = var.nameNode;
if (toRemove == null) {
continue;
Node parent = toRemove != null ? toRemove.getParent() : null;
Node grandParent = parent != null ? parent.getParent() : null;
if (toRemove.isDefaultValue() || toRemove.isRest()) {
checkState(parent == null || grandParent == null);
checkState(parent == null, "unremoved destructuring ", toRemove);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(toRemove, nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
compiler.reportChangeToEnclosingScope(nameNode);
NodeUtil.removeChild(toRemove, nameNode);
&& nameNode.hasChildren()
&& NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {
if (toRemove.hasOneChild()) {
compiler.reportChangeToEnclosingScope(toRemove);
parent.replaceChild(toRemove,
IR.exprResult(nameNode.removeFirstChild()));
compiler.reportChangeToEnclosingScope(toRemove);
toRemove.removeChild(nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
NodeUtil.markFunctionsDeleted(toRemove, compiler);
if (NodeUtil.isFunctionDeclaration(node)) {
for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {
traverseNode(child, node, scope);
private static interface Removable {
public void remove(AbstractCompiler compiler);
private class DestructuringAssign implements Removable {
DestructuringAssign(Node removableNode, Node nameNode) {
public void remove(AbstractCompiler compiler) {
private static class Assign implements Removable {
final boolean isPropertyAssign;
final boolean mayHaveSecondarySideEffects;
Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {
this.isPropertyAssign = isPropertyAssign;
this.mayHaveSecondarySideEffects =
maybeAliased
|| NodeUtil.mayHaveSideEffects(assignNode.getFirstChild())
|| NodeUtil.mayHaveSideEffects(assignNode.getLastChild());
static Assign maybeCreateAssign(Node assignNode) {
checkState(NodeUtil.isAssignmentOp(assignNode));
boolean isPropAssign = false;
Node current = assignNode.getFirstChild();
if (NodeUtil.isGet(current)) {
current = current.getFirstChild();
isPropAssign = true;
if (current.isGetProp()
&& current.getLastChild().getString().equals("prototype")) {
current = current.getFirstChild();
if (current.isName()) {
return new Assign(assignNode, current, isPropAssign);
return null;
public void remove(AbstractCompiler compiler) {
compiler.reportChangeToEnclosingScope(assignNode);
if (mayHaveSecondarySideEffects) {
Node replacement = assignNode.getLastChild().detach();
for (Node current = assignNode.getFirstChild();
!current.isName();
current = current.getFirstChild()) {
if (current.isGetElem()) {
replacement = IR.comma(
current.getLastChild().detach(), replacement);
replacement.useSourceInfoIfMissingFrom(current);
assignNode.replaceWith(replacement);
Node parent = assignNode.getParent();
if (parent.isExprResult()) {
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).srcref(assignNode));
testSame("for(let x; ;){}");
testSame("for(let x, y; ;) {x} ");
testSame("for(let x=0,y=0;;y++){}");
testSame("for(item in items){}");
testSame("for(item of items){}");abstract DefinitionUseSiteFinder getDefinitionFinder();
abstract void setDefinitionFinder(DefinitionUseSiteFinder defFinder);
private DefinitionUseSiteFinder defFinder = null;
DefinitionUseSiteFinder getDefinitionFinder() {
return this.defFinder;
void setDefinitionFinder(DefinitionUseSiteFinder defFinder) {
this.defFinder = defFinder;
boolean runOptimizeCalls = options.optimizeCalls
|| options.optimizeParameters
|| options.optimizeReturns;
if (!runOptimizeCalls) {
passes.add(getRemoveUnusedVars(PassNames.REMOVE_UNUSED_VARS, false));
if (runOptimizeCalls) {
if (options.optimizeCalls) {
passes.add(getRemoveUnusedVars("removeUnusedVars_afterOptimizeCalls", true));
private PassFactory getRemoveUnusedVars(String name, final boolean modifyCallSites) {
return getRemoveUnusedVars(name, modifyCallSites, false /* isOneTimePass */);
return getRemoveUnusedVars(PassNames.REMOVE_UNUSED_VARS, false, true /* isOneTimePass */);
private PassFactory getRemoveUnusedVars(
String name, final boolean modifyCallSites, boolean isOneTimePass) {
return new PassFactory(name, isOneTimePass) {
preserveAnonymousFunctionNames,
modifyCallSites);
class DevirtualizePrototypeMethods
implements OptimizeCalls.CallGraphCompilerPass, CompilerPass {
List<CallGraphCompilerPass> passes = new ArrayList<>();
private AbstractCompiler compiler;
interface CallGraphCompilerPass {
void process(Node externs, Node root, DefinitionUseSiteFinder definitions);
DefinitionUseSiteFinder defFinder = new DefinitionUseSiteFinder(compiler);
defFinder.process(externs, root);
compiler.setDefinitionFinder(defFinder);
pass.process(externs, root, defFinder);
import com.google.common.collect.Lists;
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import java.util.Collection;
class OptimizeParameters
implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {
DefinitionUseSiteFinder definitionFinder = new DefinitionUseSiteFinder(compiler);
definitionFinder.process(externs, root);
process(externs, root, definitionFinder);
public void process(
Node externs, Node root, DefinitionUseSiteFinder definitionFinder) {
List<DefinitionSite> definitionSites =
Lists.newArrayList(definitionFinder.getDefinitionSites());
for (DefinitionSite definitionSite : definitionSites) {
if (canChangeSignature(definitionSite, definitionFinder)) {
tryEliminateConstantArgs(definitionSite, definitionFinder);
tryEliminateOptionalArgs(definitionSite, definitionFinder);
private static boolean canChangeSignature(
DefinitionSite definitionSite, DefinitionUseSiteFinder definitionFinder) {
Definition definition = definitionSite.definition;
if (definitionSite.inExterns) {
return false;
Node rValue = definition.getRValue();
if (rValue == null ||
!rValue.isFunction() ||
NodeUtil.isVarArgsFunction(rValue)) {
return false;
Node lValue = definition.getLValue();
if (lValue.matchesQualifiedName("$jscomp.inherits")
|| lValue.matchesQualifiedName("$jscomp$inherits")) {
if (!NodeUtil.isSimpleFunctionDeclaration(rValue)) {
if (!definitionFinder.canModifyDefinition(definition)) {
Collection<UseSite> useSites = definitionFinder.getUseSites(definition);
if (useSites.isEmpty()) {
for (UseSite site : useSites) {
if (!DefinitionUseSiteFinder.isCallOrNewSite(site)) {
Node nameNode = site.node;
Collection<Definition> singleSiteDefinitions =
definitionFinder.getDefinitionsReferencedAt(nameNode);
if (singleSiteDefinitions.size() > 1) {
return false;
checkState(!singleSiteDefinitions.isEmpty());
checkState(singleSiteDefinitions.contains(definition));
return true;
private void tryEliminateOptionalArgs(
DefinitionSite definitionSite, DefinitionUseSiteFinder definitionFinder) {
Definition definition = definitionSite.definition;
Collection<UseSite> useSites = definitionFinder.getUseSites(definition);
for (UseSite site : useSites) {
checkState(DefinitionUseSiteFinder.isCallOrNewSite(site));
Node call = site.node.getParent();
int numArgs = call.getChildCount() - 1;
if (numArgs > maxArgs) {
maxArgs = numArgs;
eliminateParamsAfter(definition.getRValue(), maxArgs, definitionFinder);
private void tryEliminateConstantArgs(
DefinitionSite definitionSite, DefinitionUseSiteFinder definitionFinder) {
Definition definition = definitionSite.definition;
Collection<UseSite> useSites = definitionFinder.getUseSites(definition);
for (UseSite site : useSites) {
checkState(DefinitionUseSiteFinder.isCallOrNewSite(site));
Node call = site.node.getParent();
Node cur = call.getFirstChild();
if (firstCall) {
continueLooking = buildParameterList(parameters, cur, site.scope);
firstCall = false;
continueLooking = findFixedParameters(parameters, cur);
if (!continueLooking) {
return;
for (UseSite site : useSites) {
checkState(DefinitionUseSiteFinder.isCallOrNewSite(site));
Node call = site.node.getParent();
optimizeCallSite(definitionFinder, parameters, call);
Node function = definition.getRValue();
if (function.isFunction()) {
optimizeFunctionDefinition(parameters, function, definitionFinder);
while ((cur = cur.getNext()) != null) {
private boolean buildParameterList(
List<Parameter> parameters, Node cur, Scope s) {
while ((cur = cur.getNext()) != null) {
boolean movable = isMovableValue(cur, s);
private static boolean isMovableValue(Node n, Scope s) {
Var v = s.getVar(n.getString());
if (v != null &&
(v.isLocal() ||
v.nameNode.getParent().isCatch())) {
if (!isMovableValue(c, s)) {
private void optimizeFunctionDefinition(List<Parameter> parameters,
Node function, DefinitionUseSiteFinder definitionFinder) {
Node paramName = eliminateFunctionParamAt(function, index, definitionFinder);
private void optimizeCallSite(
DefinitionUseSiteFinder definitionFinder, List<Parameter> parameters, Node call) {
eliminateCallParamAt(definitionFinder, p, call, index);
private void eliminateParamsAfter(
Node function, int argIndex, DefinitionUseSiteFinder definitionFinder) {
Node formalArgPtr = function.getSecondChild().getFirstChild();
eliminateParamsAfter(function, formalArgPtr, definitionFinder);
private void eliminateParamsAfter(
Node fnNode, Node argNode, DefinitionUseSiteFinder definitionFinder) {
eliminateParamsAfter(fnNode, argNode.getNext(), definitionFinder);
compiler.reportChangeToEnclosingScope(argNode);
private Node eliminateFunctionParamAt(
Node function, int argIndex, DefinitionUseSiteFinder definitionFinder) {
Node formalArgPtr = NodeUtil.getArgumentForFunction(function, argIndex);
if (formalArgPtr != null) {
compiler.reportChangeToEnclosingScope(formalArgPtr);
definitionFinder.removeReferences(formalArgPtr);
function.getSecondChild().removeChild(formalArgPtr);
return formalArgPtr;
private void eliminateCallParamAt(
DefinitionUseSiteFinder definitionFinder, Parameter p, Node call, int argIndex) {
checkArgument(NodeUtil.isCallOrNew(call), "Node must be a call or new.");
Node formalArgPtr = NodeUtil.getArgumentForCallOrNew(
call, argIndex);
if (formalArgPtr != null) {
compiler.reportChangeToEnclosingScope(formalArgPtr);
if (p.getArg() != formalArgPtr) {
definitionFinder.removeReferences(formalArgPtr);
call.removeChild(formalArgPtr);
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import java.util.Collection;
class OptimizeReturns
implements OptimizeCalls.CallGraphCompilerPass, CompilerPass {
DefinitionUseSiteFinder defFinder = new DefinitionUseSiteFinder(compiler);
defFinder.process(externs, root);
process(externs, root, defFinder);
public void process(
Node externs, Node root, DefinitionUseSiteFinder definitions) {
List<Node> toOptimize = new ArrayList<>();
for (DefinitionSite defSite : definitions.getDefinitionSites()) {
if (!defSite.inExterns && !callResultsMaybeUsed(definitions, defSite)) {
toOptimize.add(defSite.definition.getRValue());
for (Node node : toOptimize) {
rewriteReturns(definitions, node);
private static boolean callResultsMaybeUsed(
DefinitionUseSiteFinder defFinder, DefinitionSite definitionSite) {
Definition definition = definitionSite.definition;
Node rValue = definition.getRValue();
if (rValue == null || !rValue.isFunction()) {
return true;
if (!NodeUtil.isSimpleFunctionDeclaration(rValue)) {
return true;
if (!defFinder.canModifyDefinition(definition)) {
return true;
Collection<UseSite> useSites = defFinder.getUseSites(definition);
for (UseSite site : useSites) {
Node useNodeParent = site.node.getParent();
if (isCall(site)) {
Node callNode = useNodeParent;
checkState(callNode.isCall());
return true;
if (!useNodeParent.isVar()) {
return true;
private void rewriteReturns(
final DefinitionUseSiteFinder defFinder, Node fnNode) {
public void visit(Node node) {
if (node.isReturn() && node.hasOneChild()) {
boolean keepValue = NodeUtil.mayHaveSideEffects(
node.getFirstChild(), compiler);
if (!keepValue) {
defFinder.removeReferences(node.getFirstChild());
Node result = node.removeFirstChild();
node.getParent().addChildBefore(
IR.exprResult(result).srcref(result), node);
private static boolean isCall(UseSite site) {
Node node = site.node;
Node parent = node.getParent();
return (parent.getFirstChild() == node) && parent.isCall();
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import java.util.Collection;
class RemoveUnusedVars implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {
private boolean modifyCallSites;
private CallSiteOptimizer callSiteOptimizer;
boolean preserveFunctionExpressionNames,
boolean modifyCallSites) {
this.modifyCallSites = modifyCallSites;
boolean shouldResetModifyCallSites = false;
if (this.modifyCallSites) {
if (compiler.getDefinitionFinder() == null) {
this.modifyCallSites = false;
shouldResetModifyCallSites = true;
process(externs, root, compiler.getDefinitionFinder());
compiler.setDefinitionFinder(null);
if (shouldResetModifyCallSites) {
this.modifyCallSites = true;
public void process(
Node externs, Node root, DefinitionUseSiteFinder defFinder) {
if (modifyCallSites) {
checkNotNull(defFinder);
callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);
if (callSiteOptimizer != null) {
callSiteOptimizer.applyChanges();
boolean modifyCallers = modifyCallSites
&& callSiteOptimizer.canModifyCallers(function);
if (!modifyCallers) {
maybeRemoveUnusedTrailingParameters(argList, fparamScope);
callSiteOptimizer.optimize(fparamScope, referenced);
private static class CallSiteOptimizer {
private final AbstractCompiler compiler;
private final DefinitionUseSiteFinder defFinder;
private final List<Node> toRemove = new ArrayList<>();
private final List<Node> toReplaceWithZero = new ArrayList<>();
CallSiteOptimizer(
AbstractCompiler compiler,
DefinitionUseSiteFinder defFinder) {
this.compiler = compiler;
this.defFinder = defFinder;
public void optimize(Scope fparamScope, Set<Var> referenced) {
Node function = fparamScope.getRootNode();
checkState(function.isFunction());
Node argList = NodeUtil.getFunctionParameters(function);
boolean changeCallSignature = canChangeSignature(function);
markUnreferencedFunctionArgs(
fparamScope, function, referenced,
argList.getFirstChild(), 0, changeCallSignature);
public void applyChanges() {
for (Node n : toRemove) {
if (alreadyRemoved(n)) {
continue;
compiler.reportChangeToEnclosingScope(n);
n.detach();
NodeUtil.markFunctionsDeleted(n, compiler);
for (Node n : toReplaceWithZero) {
if (alreadyRemoved(n)) {
continue;
compiler.reportChangeToEnclosingScope(n);
n.replaceWith(IR.number(0).srcref(n));
NodeUtil.markFunctionsDeleted(n, compiler);
private boolean markUnreferencedFunctionArgs(
Scope scope, Node function, Set<Var> referenced,
Node param, int paramIndex,
boolean canChangeSignature) {
if (param != null) {
boolean hasFollowing = markUnreferencedFunctionArgs(
scope, function, referenced, param.getNext(), paramIndex + 1,
canChangeSignature);
Var var = scope.getVar(param.getString());
if (!referenced.contains(var)) {
checkNotNull(var);
boolean modifyAllCallSites = canChangeSignature || !hasFollowing;
if (modifyAllCallSites) {
modifyAllCallSites = canRemoveArgFromCallSites(
function, paramIndex);
tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);
if (modifyAllCallSites || !hasFollowing) {
toRemove.add(param);
return hasFollowing;
return true;
tryRemoveAllFollowingArgs(function, paramIndex - 1);
return false;
private boolean canRemoveArgFromCallSites(Node function, int argIndex) {
Definition definition = getFunctionDefinition(function);
for (UseSite site : defFinder.getUseSites(definition)) {
if (isModifiableCallSite(site)) {
Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);
if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {
return false;
return false;
return true;
private void tryRemoveArgFromCallSites(
Node function, int argIndex, boolean canModifyAllSites) {
Definition definition = getFunctionDefinition(function);
for (UseSite site : defFinder.getUseSites(definition)) {
if (isModifiableCallSite(site)) {
Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);
if (arg != null) {
if (canModifyAllSites
|| (arg.getNext() == null && !NodeUtil.mayHaveSideEffects(arg, compiler))) {
toRemove.add(arg);
if (!NodeUtil.mayHaveSideEffects(arg, compiler)
&& (!arg.isNumber() || arg.getDouble() != 0)) {
toReplaceWithZero.add(arg);
private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {
Definition definition = getFunctionDefinition(function);
for (UseSite site : defFinder.getUseSites(definition)) {
if (!isModifiableCallSite(site)) {
continue;
Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);
while (arg != null) {
if (!NodeUtil.mayHaveSideEffects(arg)) {
toRemove.add(arg);
arg = arg.getNext();
private static Node getArgumentForCallOrNewOrDotCall(UseSite site,
final int argIndex) {
int adjustedArgIndex = argIndex;
Node parent = site.node.getParent();
if (NodeUtil.isFunctionObjectCall(parent)) {
adjustedArgIndex++;
return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);
boolean canModifyCallers(Node function) {
if (NodeUtil.isVarArgsFunction(function)) {
return false;
DefinitionSite defSite = defFinder.getDefinitionForFunction(function);
if (defSite == null) {
return false;
Definition definition = defSite.definition;
if (!NodeUtil.isSimpleFunctionDeclaration(function)) {
return false;
return defFinder.canModifyDefinition(definition);
private static boolean isModifiableCallSite(UseSite site) {
return DefinitionUseSiteFinder.isCallOrNewSite(site)
&& !NodeUtil.isFunctionObjectApply(site.node.getParent());
private boolean canChangeSignature(Node function) {
Definition definition = getFunctionDefinition(function);
CodingConvention convention = compiler.getCodingConvention();
checkState(!definition.isExtern());
Collection<UseSite> useSites = defFinder.getUseSites(definition);
for (UseSite site : useSites) {
Node parent = site.node.getParent();
if (parent == null) {
continue; // Ignore it.
if (parent.isCall()
&& convention.getClassesDefinedByCall(parent) != null) {
continue;
if (!DefinitionUseSiteFinder.isCallOrNewSite(site)) {
if (!(parent.isGetProp()
&& NodeUtil.isFunctionObjectCall(parent.getParent()))) {
return false;
if (NodeUtil.isFunctionObjectApply(parent)) {
return false;
Node nameNode = site.node;
Collection<Definition> singleSiteDefinitions =
defFinder.getDefinitionsReferencedAt(nameNode);
checkState(singleSiteDefinitions.size() == 1);
checkState(singleSiteDefinitions.contains(definition));
return true;
private Definition getFunctionDefinition(Node function) {
DefinitionSite definitionSite = defFinder.getDefinitionForFunction(
function);
checkNotNull(definitionSite);
Definition definition = definitionSite.definition;
checkState(!definitionSite.inExterns);
checkState(definition.getRValue() == function);
return definition;
+ "a.prototype.a = function(d, c) { alert(c); };\n"
+ "(new a).a(1, 2);\n"
+ "(new b).a(1, 2);");
test(options, code, "function f(a) {return;} f(true);");
return new RemoveUnusedVars(compiler, false, false, false);
final OptimizeCalls passes = new OptimizeCalls(compiler);
passes.addPass(new OptimizeReturns(compiler));
passes.addPass(new OptimizeParameters(compiler));
passes.addPass(new RemoveUnusedVars(compiler, true, false, true));
DefinitionUseSiteFinder definitionFinder = new DefinitionUseSiteFinder(compiler);
definitionFinder.process(externs, root);
new PureFunctionIdentifier(compiler, definitionFinder).process(externs, root);
"function f1(x) { } function f2(x) { }"
+ "function f3(x) { } function f4(x) { }"
+ "f3(f1(f2()));",
"function f3(){}f3()");
test("var foo = function(a){}; function bar(){var x;x = foo} bar(); foo(1)",
"var foo = function( ){}; function bar(){             } bar(); foo()");
testSame("function foo(p1) { } foo(1); foo(2)");
testSame("function foo(p1) { } foo(1,2); foo(3,4)");
test("function foo(p1) { } foo(); foo()",
"function foo() {var p1;} foo(); foo()");
test("function foo(p1) { } foo(1); foo(1)",
"function foo() {var p1 = 1;} foo(); foo()");
test("function foo(p1) { } foo(1,2); foo(1,4)",
"function foo() {var p1 = 1;} foo(2); foo(4)");
public void testOptimizeOnlyImmutableValues() {
test("function foo(a) {}; foo(undefined);",
"function foo() {var a = undefined}; foo()");
testSame("var foo = function (a, b) {}; foo(1); foo.call(this, 1);");
testSame("var foo = function (a, b) {}; foo(1); foo.call(null, 1);");
testSame("var foo = function (a, b) {}; foo.call(this, 1);");
testSame("var foo = function (a, b) {}; foo.call(null, 1);");
testSame("var foo; foo = function (p1) { }; foo()");
test("function foo(p1, p2) { } foo(1); foo(2)",
test( "function foo(p1, p2) { } foo(1); foo(2); foo()",
String src = "var goog = {};" +
"goog.foo = function (p1, p2) { };" +
"goog.foo = function (q1, q2) { };" +
"goog.foo = function (r1, r2) { };" +
"goog.foo(1); goog.foo(2); goog.foo()";
testSame(src);
String src = "var goog = {};" +
"goog.foo = function (p1, p2, p3, p4) { };" +
"goog.foo = function (q1, q2, q3, q4) { };" +
"goog.foo = function (r1, r2, r3, r4) { };" +
"goog.foo(1,0); goog.foo(2,1); goog.foo()";
testSame(src);
String src = "var goog1 = {};" +
"goog1.foo = function () { };" +
"var goog2 = {};" +
"goog2.foo = function (p1) { };" +
"var x = getGoog();" +
"x.foo()";
testSame(src);
"baz = function(a) {};",
"baz = function(a) {};",
testSame("var goog;" +
"goog.foo = function(a, opt) {};" +
"var bar = function(){goog.foo.call(this, 1)};" +
"goog.foo(1);");
public void testOptimizeThis() {
String src = "function foo() {" +
"var bar = function (a, b) {};" +
"this.bar = function (a, b) {};" +
"this.bar(3);" +
"bar(2);}";
String expected = "function foo() {" +
"var bar = function () {var b; var a = 2;};" +
"this.bar = function () {var b; var a = 3;};" +
"this.bar();" +
"bar();}";
public void testCrash() {
test("f(g()); function f(){}",
"f(); function f(){g()}");
test("f(g(),h()); function f(){}",
"f(); function f(){g();h()}");
private static String newlineJoin(String ... parts) {
return LINE_JOINER.join(parts);
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
"a.prototype.foo = function(args) {return};",
String source = newlineJoin(
String expected = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
String source = newlineJoin(
String expected = newlineJoin(
expected = newlineJoin(
expected = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
"function a(){return function() {}}",
String expected = newlineJoin(
"function a(){return}",
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String result = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
String source = newlineJoin(
testSame("function a() {return 1}; a.call(new foo);");
String source = newlineJoin(
String expected = newlineJoin(
"function a() { return }",
private boolean modifyCallSites;
return modifyCallSites ? 2 : 1;
modifyCallSites = false;
if (modifyCallSites) {
DefinitionUseSiteFinder defFinder = new DefinitionUseSiteFinder(compiler);
defFinder.process(externs, root);
compiler.setDefinitionFinder(defFinder);
compiler, removeGlobal, preserveFunctionExpressionNames,
modifyCallSites).process(externs, root);
public void testFunctionArgRemovalFromCallSites() {
this.modifyCallSites = true;
test("var b=function(c,d){return};b(1,2)",
"var b=function(){return};b()");
testSame("var b=function(c,d){return c+d};b(1,2)");
test("var b=function(e,f,c,d){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b()");
test("var b=function(c,d,e,f){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b(1,2)");
test("var b=function(e,c,f,d,g){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b(2)");
public void testFunctionArgRemoval_defaultValue4() {
test("var f = (unusedParam = 0) => {}; f();", "var f = (               ) => {}; f();");
this.modifyCallSites = true;
test("var a=3;function f(b, c){b=a; alert(c);} f();",
"function f(c) { alert(c); } f();");
this.modifyCallSites = true;
test("var b=function(c){};b.call(null, x)",
"var b=function(){};b.call(null)");
test("var b=function(c){};b.apply(null, x)",
"var b=function(){};b.apply(null, x)");
test("var b=function(c){return};b(1)",
"var b=function(){return};b()");
test("var b=function(c){return};b(1,2)",
"var b=function(){return};b()");
test("var b=function(c){return};b(1,2);b(3,4)",
"var b=function(){return};b();b()");
test("var b=function(c,d){return d};b(1,2);b(3,4);b.length",
"var b=function(c,d){return d};b(0,2);b(0,4);b.length");
test("var b=function(c){return};b(1,2);b(3,new x())",
"var b=function(){return};b();b(new x())");
test("var b=function(c){return};b(1,2);b(new x(),4)",
"var b=function(){return};b();b(new x())");
test("var b=function(c,d){return d};b(1,2);b(new x(),4)",
"var b=function(c,d){return d};b(0,2);b(new x(),4)");
test("var b=function(c,d,e){return d};b(1,2,3);b(new x(),4,new x())",
"var b=function(c,d){return d};b(0,2);b(new x(),4,new x())");
test("var b=function(c,d){b(1,2);return d};b(3,4);b(5,6)",
"var b=function(d){b(2);return d};b(4);b(6)");
test("var b=function(c,d){return};b(1,2)",
"var b=function(){return};b()");
testSame("var b=function(c,d){return c+d};b(1,2)");
test("var b=function(e,f,c,d){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b()");
test("var b=function(c,d,e,f){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b(1,2)");
test("var b=function(e,c,f,d,g){return c+d};b(1,2)",
"var b=function(c,d){return c+d};b(2)");
test("var b=function(c,d){};var b=function(e,f){};b(1,2)",
"var b=function(){};var b=function(){};b(1,2)");
this.modifyCallSites = true;
test("var Ctor1=function(a,b){return a};" +
"var Ctor2=function(a,b){Ctor1.call(this,a,b)};" +
"goog$inherits(Ctor2, Ctor1);" +
"new Ctor2(1,2)",
"var Ctor1=function(a){return a};" +
"var Ctor2=function(a){Ctor1.call(this,a)};" +
"goog$inherits(Ctor2, Ctor1);" +
"new Ctor2(1)");
public void testFunctionArgRemovalCausingInconsistency() {
this.modifyCallSites = true;
test("var a=function(x,y){};" +
"var b=function(z){};" +
"a(new b, b)",
"var a=function(){};" +
"var b=function(){};" +
"a(new b)");
this.modifyCallSites = true;
test("var a = [];" +
"var register = function(callback) {a[0] = callback};" +
"register(function(transformer) {});" +
"var register=function(){};register();register()");
this.modifyCallSites = true;
this.modifyCallSites = true;
this.modifyCallSites = true;if (this.fn != null) {
if (ns == null || !props.isEmpty()) {
+ "Foo.Foo__function_new_Foo___undefined__$a = 0;"
+ "Bar.Bar__function_new_Bar___undefined__$a = 0;";
"{a=[[Bar<|function(new:Bar): undefined|>], [Foo<|function(new:Foo): undefined|>]]}");
"Expected : Bar<|function(new:Bar): ?|>",
"Found    : Foo<|function(new:Foo): undefined|>",
.toStringIsEqualTo("Math.pow<|function(?,?): number|>{prototype: ?}");
.toStringIsEqualTo("Math.pow<|function(?,?): number|>{prototype: ?}");new PassFactory("rewriteAsyncFunctions", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
new PassFactory("convertEs7ToEs6", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
protected static final ImmutableList<SourceFile> EXTERNS =
Result result = compiler.compile(EXTERNS, inputs, options);
"/** @interface */",
"function IThenable () {}",
"IThenable.prototype.then = function(onFulfilled) {};",
"/**",
" * @template T",
" * @constructor",
" * @implements {IThenable}",
" */",
"function Promise(resolver) {};",
"/**",
" * @param {VALUE} value",
" * @return {!Promise<VALUE>}",
" * @template VALUE",
" */",
"Promise.resolve = function(value) {};",
"/**",
" * @template RESULT",
" * @param {function(): RESULT} onFulfilled",
" * @return {RESULT}",
" */",
"Promise.prototype.then = function(onFulfilled) {};",
Result result = compiler.compile(EXTERNS, inputs, options);
Result result = compiler.compile(EXTERNS, inputs, options);
compiler.compile(EXTERNS, inputs, options);
public void testFunctionInference21() throws Exception {
public void testBug901455() throws Exception {
public void testBug911118() throws Exception {
testTypes("/** @constructor */ function Foo() {} \n" +
"/** @type {Foo} */ var x = /** @type {Foo} */ (y)");
public void testCast33() throws Exception {
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {string|undefined} */(x);");
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {string?} */(x);");
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {null} */(x);");
public void testMissingProperty28() throws Exception {
public void testGenerics1() throws Exception {
testTypes(
fnDecl +
"/** @type {string} */" +
"var out;" +
"var result = f(0, function(x){ out = x; return x; });",
"assignment\n" +
"found   : number\n" +
"required: string");
fnDecl +
"var out;" +
"/** @type {string} */" +
"var result = f(0, function(x){ out = x; return x; });",
"assignment\n" +
"found   : number\n" +
"required: string");
public void testIssue1024() throws Exception {
testTypes(
"/** @param {Object} a */\n" +
"function f(a) {\n" +
"  a.prototype = {foo:3};\n" +
"}\n" +
"/** @param {Object} b\n" +
" */\n" +
"function g(b) {\n" +
"  b.prototype = function(){};\n" +
"}\n",
"assignment to property prototype of Object\n" +
"found   : {foo: number}\n" +
"required: function(): undefined");
public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules() throws Exception {private JSType TOP;
this.TOP = this.commonTypes.TOP;
lhsPair = analyzeExprFwd(lhs, preciseEnv,
UNKNOWN, lhsPair.type.specialize(rhsPair.type));
rhsPair = analyzeExprFwd(rhs, lhsPair.env,
UNKNOWN, rhsPair.type.specialize(lhsPair.type));
(comparisonOp == Token.SHNE && specializedType.isTrueOrTruthy())) {
return maybeCtor;import elemental2.core.RegExp;
pattern.regExp = new RegExp(string);import java.util.Collection;
if (!inputsToRewrite.isEmpty()) {
forceToEs6Modules(inputsToRewrite.values());
this.moduleLoader = ModuleLoader.EMPTY;
void forceToEs6Modules(Collection<CompilerInput> inputsToProcess) {
for (CompilerInput input : inputsToProcess) {
input.setCompiler(this);
input.addProvide(input.getPath().toModuleName());
Node root = input.getAstRoot(this);
if (root == null) {
continue;
Es6RewriteModules moduleRewriter = new Es6RewriteModules(this);
moduleRewriter.forceToEs6Module(root);
ProcessCommonJSModules cjs = new ProcessCommonJSModules(this, true);
import java.util.HashSet;
private final Set<ModuleIdentifier> entryPoints = new HashSet<>();
import com.google.common.collect.ImmutableSet;
private Node googRequireInsertSpot;
public boolean forceToEs6Module(Node root) {
if (isEs6ModuleRoot(root)) {
return true;
FindGoogProvideOrGoogModule finder = new FindGoogProvideOrGoogModule();
NodeTraversal.traverseEs6(compiler, root, finder);
if (finder.isFound()) {
return false;
Node moduleNode = new Node(Token.MODULE_BODY).srcref(root);
moduleNode.addChildrenToBack(root.removeChildren());
root.addChildToBack(moduleNode);
return true;
this.googRequireInsertSpot = null;
if (alreadyRequired.add(moduleName)) {
Node require = IR.exprResult(
IR.call(NodeUtil.newQName(compiler, "goog.require"), IR.string(moduleName)));
require.useSourceInfoIfMissingFromForTree(importDecl);
parent.addChildAfter(require, googRequireInsertSpot);
googRequireInsertSpot = require;
t.getInput().addRequire(moduleName);
Node googProvide = IR.exprResult(
IR.call(NodeUtil.newQName(compiler, "goog.provide"),
IR.string(moduleName)));
script.addChildToFront(googProvide.useSourceInfoIfMissingFromForTree(script));
t.getInput().addProvide(moduleName);
JSDocInfoBuilder jsDocInfo = script.getJSDocInfo() == null
? new JSDocInfoBuilder(false)
: JSDocInfoBuilder.copyFrom(script.getJSDocInfo());
if (!jsDocInfo.isPopulatedWithFileOverview()) {
jsDocInfo.recordFileOverview("");
jsDocInfo.recordSuppressions(ImmutableSet.of("missingProvide", "missingRequire"));
script.setJSDocInfo(jsDocInfo.build());
List<CompilerInput> transitiveClosure =
sorter.getDependenciesOf(
entryPointInputsPerModule.get(module),
depOptions.shouldSortDependencies());
for (CompilerInput input : absoluteOrder) {
if (depOptions.shouldPruneDependencies()) {
CompilerInput baseJs = sorter.maybeGetInputProviding("goog");
if (baseJs != null) {
entryPointInputs.add(baseJs);
import java.util.HashSet;
import java.util.Set;
private final boolean reportDependencies;
this(compiler, true);
public ProcessCommonJSModules(Compiler compiler, boolean reportDependencies) {
this.reportDependencies = reportDependencies;
if (finder.isCommonJsModule()) {
compiler, root, new RewriteModule(finder.isCommonJsModule(), exports.build()));
finder.addGoogProvideAndRequires();
Set<String> imports = new HashSet<>();
if (n.matchesQualifiedName("module.exports")) {
Var v = t.getScope().getVar(MODULE);
if (v == null) {
if (n.isCall()
&& n.hasTwoChildren()
&& n.getFirstChild().matchesQualifiedName("require")
&& n.getSecondChild().isString()) {
String requireName = require.getSecondChild().getString();
String moduleName = modulePath.toModuleName();
imports.add(moduleName);
void addGoogProvideAndRequires() {
CompilerInput ci = compiler.getInput(this.script.getInputId());
ModulePath modulePath = ci.getPath();
if (modulePath == null) {
return;
String moduleName = modulePath.toModuleName();
for (String importName : imports) {
if (reportDependencies) {
ci.addRequire(importName);
this.script.addChildToFront(
IR.exprResult(
IR.call(
IR.getprop(IR.name("goog"), IR.string("require")), IR.string(importName)))
.useSourceInfoIfMissingFromForTree(this.script));
if (isCommonJsModule()) {
if (reportDependencies) {
ci.addProvide(moduleName);
this.script.addChildToFront(
IR.exprResult(
IR.call(
IR.getprop(IR.name("goog"), IR.string("provide")), IR.string(moduleName)))
.useSourceInfoIfMissingFromForTree(this.script));
compiler.reportChangeToEnclosingScope(this.script);
compiler.reportChangeToEnclosingScope(this.script);
String fnName = newStatements.getFirstFirstChild().getString();
if (n.hasTwoChildren()
&& n.getFirstChild().matchesQualifiedName("require")
&& n.getSecondChild().isString()) {
String requireName = require.getSecondChild().getString();
if (rValue.hasTwoChildren()
&& rValue.getFirstChild().matchesQualifiedName("require")
&& rValue.getSecondChild().isString()
String requireName = rValue.getSecondChild().getString();
test(new String[] {
"goog.require('a');\n" +
"var COMPILED = false;",
new String[] {
"var a={};",
"var COMPILED=!1"
test(new String[] {
"var COMPILED = false;",
new String[] {
"var COMPILED = !1;",
"var x = 3;"
test(new String[] {
new String[] {
"var beer = {};",
"var scotch = {}, x = 3;",
test(new String[] {
"goog.require('beer');",
"goog.provide('beer');",
"goog.provide('scotch'); var x = 3;"
new String[] {
"var beer = {};",
"",
"var scotch = {}, x = 3;",
test(new String[] {
"var COMPILED = false;",
new String[] {
"var module$app = {}, baz$$module$app = new module$foo();",
"console.log(baz$$module$app.bar());")
"/** @const */ var module$foo={};",
"function foo$$module$foo(){ alert('foo'); }",
"foo$$module$foo();"),
"var module$app = {};"
CompilerTestCase.LINE_JOINER.join(
CompilerTestCase.LINE_JOINER.join(
"/** @const */ var module$foo={};",
"function foo$$module$foo(){ alert(module$message.default); }",
"foo$$module$foo();"),
"var module$app = {};"
"/** @const */ var module$foo={};",
ModulesTestUtils.testModules(
this,
"testcode.js",
input,
LINE_JOINER.join(
"/** @fileoverview",
" *  @suppress {missingProvide|missingRequire}",
" */",
"goog.provide('module$testcode');",
expected));
testModules(
"import name from './other.js';\n use(name);",
"goog.require('module$other'); use(module$other.default);");
testModules("import {n as name} from './other.js';", "goog.require('module$other');");
"goog.require('module$other'); use(module$other.default);");
"import {default as name} from './other.js';\n use(name);",
"goog.require('module$other'); use(module$other.default);");
"import {class as name} from './other.js';\n use(name);",
"goog.require('module$other'); use(module$other.class);");
testModules(
"import * as name from './other.js';\n use(name.foo);",
"goog.require('module$other');\n use(module$other.foo)");
"goog.require('module$other');"
+ "/** @type {module$other.foo} */ var x$$module$testcode;");
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"export class Foo {",
"  /** @param {/other.Baz} baz */",
"  useBaz(baz) {}",
"}"),
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
"import * as s from './other.js';\ngoog.require('foo.bar');",
"goog.require('module$other'); goog.require('foo.bar');");
"goog.require('foo.bar');\nimport * as s from './other.js';",
"goog.require('module$other'); goog.require('foo.bar'); ");
"goog.require('module$other');",
"goog.require('module$other');",
"goog.require('module$other');",
LINE_JOINER.join(
"import Foo from 'goog:other.Foo';",
"use(Foo);"),
LINE_JOINER.join(
"goog.require('other.Foo');",
"use(other.Foo)"));
LINE_JOINER.join(
"import {x, y} from 'goog:other.Foo';",
"use(x);",
"use(y);"),
LINE_JOINER.join(
"goog.require('other.Foo');",
"use(other.Foo.x);\n use(other.Foo.y);"));
"goog.require('other.Foo');",
"goog.require('module$other');",
testModules("import './other.js';", "goog.require('module$other');");
testModules(
"import './other.js';\nimport './yet_another.js';",
"goog.require('module$other'); goog.require('module$yet_another');");
SourceFile.fromCode(
Compiler.joinPathParts("base", "mod", "name.js"),
LINE_JOINER.join(
"/** @fileoverview",
" * @suppress {missingProvide|missingRequire}",
" */",
"goog.provide('module$mod$name');")),
SourceFile.fromCode(
Compiler.joinPathParts("base", "test", "sub.js"),
"goog.provide('module$test$sub'); goog.require('module$mod$name');")));
LINE_JOINER.join(
"goog.require('module$other');",
"var bar$$module$testcode={a: 1, f: module$other.f};"));
LINE_JOINER.join(
"goog.require('module$other');",
"var bar$$module$testcode={a: 1, foo: module$other.f};"));
LINE_JOINER.join(
"goog.require('module$other');",
"var bar$$module$testcode={a: 1, f: module$other.default};"));
LINE_JOINER.join(
"goog.require('module$other');",
"var bar$$module$testcode={a: 1, f: module$other};"));
"goog.require('module$other');",
SourceFile.fromCode(
Compiler.joinPathParts("mod", "name.js"),
LINE_JOINER.join(
"/** @fileoverview",
" * @suppress {missingProvide|missingRequire}",
" */",
"goog.provide('module$mod$name');")),
"goog.require('module$mod$name');",
"var name = module$mod$name;",
"(function() { module$mod$name(); })();"))));
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test_test');",
"goog.require('module$other');",
"goog.provide('module$foo$index');",
"goog.require('module$other');",
"goog.provide('module$testcode');",
"goog.provide('module$foo$bar');",
"goog.require('module$other');",
SourceFile.fromCode(
Compiler.joinPathParts("foo", "name.js"),
LINE_JOINER.join(
"/** @fileoverview",
" * @suppress {missingProvide|missingRequire}",
" */",
"goog.provide('module$foo$name');")),
"goog.provide('module$foo$bar');",
"goog.require('module$foo$name');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.provide('module$testcode');",
testModules("test.js", "require('./other');", "goog.require('module$other');");
"goog.require('module$other');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
LINE_JOINER.join(
"class foo extends Array {}",
"module.exports = foo;"),
LINE_JOINER.join(
"goog.provide('module$test');",
"let module$test = class extends Array {}"));
LINE_JOINER.join(
"class foo {}",
"module.exports = foo;"),
LINE_JOINER.join(
"goog.provide('module$test');",
"let module$test = class {}"));
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test')",
"goog.require('module$other');",
"goog.provide('module$test');",
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"var name = require('/mod/name');",
"(function() { module$mod$name(); })();"))),
SourceFile.fromCode(
Compiler.joinPathParts("base", "mod", "name.js"),
LINE_JOINER.join(
"/** @fileoverview",
" * @suppress {missingProvide|missingRequire}",
" */",
"goog.provide('module$mod$name');")),
"goog.require('module$mod$name');",
"var name = module$mod$name;",
"(function() { module$mod$name(); })();"))));
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",
LINE_JOINER.join(
"goog.provide('module$test');",
"var module$test = {foo: 'bar'};"));
"goog.provide('module$test');",
"goog.provide('module$test');",
"goog.provide('module$test');",import com.google.common.collect.Lists;
import java.util.HashMap;
import java.util.Map;
private final Multimap<Var, Assign> assignsByVar =
private final Map<Node, Assign> assignsByNode = new HashMap<>();
assignsByNode.put(maybeAssign.nameNode, maybeAssign);
if (n.getParent().isDestructuringLhs()) {
if (NodeUtil.isNestedArrayPattern(n)) {
break;
return;
case OBJECT_PATTERN:
if (n.getParent().isDestructuringLhs()) {
if (NodeUtil.isNestedObjectPattern(n)) {
break;
return;
if (!assignsByNode.containsKey(n)) {
collectMaybeUnreferencedVars(fparamScope);
collectMaybeUnreferencedVars(fbodyScope);
removeUnusedDestructuringNames(argList, fparamScope);
private void removeUnusedDestructuringNames(Node argList, Scope fparamScope) {
List<Node> destructuringDeclarations = NodeUtil.getLhsNodesOfDeclaration(argList);
for (Node patternElt : Lists.reverse(destructuringDeclarations)) {
Node toRemove = patternElt;
if (patternElt.getParent().isDefaultValue()) {
Node defaultValueRhs = patternElt.getNext();
if (NodeUtil.mayHaveSideEffects(defaultValueRhs)) {
continue;
toRemove = patternElt.getParent();
if (toRemove.getParent().isParamList()) {
continue;
Var var = fparamScope.getVar(patternElt.getString());
if (!referenced.contains(var)) {
if (toRemove.getParent().isStringKey()) {
toRemove = toRemove.getParent();
NodeUtil.markFunctionsDeleted(toRemove, compiler);
compiler.reportChangeToEnclosingScope(toRemove.getParent());
NodeUtil.removeChild(toRemove.getParent(), toRemove);
Node defaultValueSecondChild = lValue.getNext();
if (NodeUtil.mayHaveSideEffects(defaultValueSecondChild)) {
lValue = lValue.getFirstChild();
for (Assign assign : assignsByVar.get(var)) {
for (Assign assign : assignsByVar.get(var)) {
compiler.reportChangeToEnclosingScope(assign.assignNode);
assign.remove(compiler);
Node parent = toRemove.getParent();
Node grandParent = toRemove.getGrandparent();
checkState(
NodeUtil.isNameDeclaration(toRemove)
|| toRemove.isFunction()
|| (toRemove.isParamList() && parent.isFunction())
|| NodeUtil.isDestructuringDeclaration(grandParent)
|| toRemove.isArrayPattern() // Array Pattern
|| parent.isObjectPattern() // Object Pattern
|| toRemove.isClass()
|| (toRemove.isDefaultValue()
&& NodeUtil.getEnclosingScopeRoot(toRemove).isFunction())
|| (toRemove.isRest() && NodeUtil.getEnclosingScopeRoot(toRemove).isFunction()),
"We should only declare Vars and functions and function args and classes");
if ((toRemove.isParamList() && parent.isFunction())
|| (toRemove.isDefaultValue() && NodeUtil.getEnclosingScopeRoot(toRemove).isFunction())
|| (toRemove.isRest() && NodeUtil.getEnclosingScopeRoot(toRemove).isFunction())) {
private static class Assign {
void remove(AbstractCompiler compiler) {
Node parent = assignNode.getParent();
parent.replaceChild(assignNode, replacement);
Node grandparent = parent.getParent();
grandparent.removeChild(parent);
parent.replaceChild(assignNode, IR.number(0).srcref(assignNode));
testSame("var {['a']:a, ['b']:b} = {a:1, b:2};");
testSame("function f(unusedParam = undefined, z) { z; }; f();");
public void testDefaultParamsWithSideEffects() {
public void testDestructuringArrayPattern() {
testSame(
LINE_JOINER.join(
"[a, b] = [1, 2]"));
LINE_JOINER.join(
LINE_JOINER.join(
"var a; ",
"[a] = [1]"
));
public void testDestructuringObjectPattern() {
testSame("var a; var b; ({a, b} = {a:1, b:2})");
test("var a; var b; ({a} = {a:1})", "var a; ({a} = {a:1})");
testSame("const someObject = {a:{ b:1 }}; var {a: {b}} = someObject; someObject.a.b;");
public void testRemoveUnusedVarsDeclaredInDestructuring() {
testSame("var {a, b:{c}} = {a:1, b:{c:5}}; f(a);");
testSame("var {a, b:{c}} = obj;");declNode.putBooleanProp(Node.ANALYZED_DURING_GTI, true);
String catchVarname = n.getFirstChild().getString();
case GETPROP:
private boolean isFunctionBind(Node expr, TypeEnv env, boolean isFwd) {
if (NodeUtil.isFunctionBind(expr)) {
if (!expr.isGetProp() || !expr.isQualifiedName()
|| !expr.getLastChild().getString().equals("bind")) {
Node recv = expr.getFirstChild();
JSType recvType = isFwd ? analyzeExprFwd(recv, env).type : analyzeExprBwd(recv, env).type;
warnings.add(JSError.make(n, UNKNOWN_NAMESPACE_PROPERTY,
n.getQualifiedName()));
Node vdecl = expr.getFirstChild();
String name = vdecl.getString();
checkState(!vdecl.hasChildren());
"var /** !Foo */ x = goog.asserts.assertInstanceOf((new Bar).method(), Foo);"));
NewTypeInference.UNKNOWN_ASSERTION_TYPE);
typeCheck("goog.asserts.assert(false, 'this code should not run');");
typeCheck(CLOSURE_BASE
+ "function f(x) { var /** boolean */ b = goog.isNull(x); }");
typeCheck(CLOSURE_BASE
+ "function f(x) { if (goog.isNull(x)) { var /** undefined */ y = x; } }",
typeCheck(CLOSURE_DEFS
+ "var o = {superClass_: 'str'}; var /** string */ s = o.superClass_;");
typeCheck(
"goog.bind(123, null);", NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
typeCheck("goog.partial(function(x) {}, 123)");
typeCheck("goog.bind(function() {}, null)();");
"goog.asserts.assertInstanceOf;",compilerOptions.setLineLengthThreshold(80);if (NodeUtil.isNameDeclaration(parent)) {
if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isNameDeclaration(parent)) {
Node var = name.getParent();
public static void makeDeclarationVar(Var coalescedName) {
Node coalesceVarParent = coalescedName.getParentNode();
if (coalesceVarParent.isLet() || coalesceVarParent.isConst()) {
coalesceVarParent.setToken(Token.VAR);
checkState(coalesceVarParent.isVar());if (importLhs == null || !importLhs.isName()) {
t.report(n, REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME,
n.getQualifiedName(), importLhs.getQualifiedName());
REFERENCE_TO_FULLY_QUALIFIED_IMPORT_NAME);Var v = t.getScope().getVar(name);
if (v == null || v.isGlobal()) {
exportMap.put(name, new NameNodePair(name, maybeName));
return n.isFunction() && !isStatement(n);
assertThat(redeclarations).hasCount("x", 0);
"export function foo$jscomp$unique_1(x$jscomp$unique_0) {",
"  return foo$jscomp$unique_1(x$jscomp$unique_0) - 1;",import static com.google.common.base.Preconditions.checkNotNull;
checkNotNull(inputId);
private Node inlineFunction(
Reference ref, Node fnNode, String fnName) {
FunctionToBlockMutator mutator = new FunctionToBlockMutator(
compiler, this.safeNameIdSupplier);
NodeTraversal.traverseEs6(
fnNode,
false));
class MakeDeclaredNamesUnique implements NodeTraversal.ScopedCallback {
if (NodeUtil.isFunctionBlock(declarationRoot)) {
return;
checkState(t.inGlobalScope());
if (!declarationRoot.isFunction()) {
findDeclaredNames(t, declarationRoot);
if (NodeUtil.isFunctionBlock(t.getScopeRoot())) {
return;
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
switch (n.getToken()) {
case FUNCTION: {
Renamer renamer = renamerStack.peek().createForChildScope(n, false);
String name = n.getFirstChild().getString();
if (!name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {
renamer.addDeclaredName(name, false);
renamerStack.push(renamer);
break;
case PARAM_LIST: {
Renamer renamer = renamerStack.peek().createForChildScope(n, true);
for (Node lhs : NodeUtil.getLhsNodesOfDeclaration(n)) {
renamer.addDeclaredName(lhs.getString(), true);
Node functionBody = n.getNext();
renamerStack.push(renamer);
findDeclaredNames(t, functionBody);
break;
default:
break;
return true;
case FUNCTION:
renamerStack.pop();
renamerStack.pop();
break;
case PARAM_LIST:
break;
findDeclaredNamesHelper(t, n, false);
private void findDeclaredNamesHelper(NodeTraversal t, Node n, boolean recursive) {
Renamer renamer = renamerStack.peek();
Node parent = n.getParent();
if (recursive && parent.isFunction() && n != parent.getFirstChild()) {
return;
if (NodeUtil.isBlockScopedDeclaration(n)) {
if (t.getScopeRoot() == NodeUtil.getEnclosingScopeRoot(n)) {
renamer.addDeclaredName(n.getString(), false);
&& NodeUtil.getEnclosingScopeRoot(n) == NodeUtil.getFunctionBody(t.getScopeRoot())) {
renamer.addDeclaredName(n.getString(), false);
renamer.addDeclaredName(n.getString(), true);
Node nameNode = n.getFirstChild();
renamer.addDeclaredName(nameNode.getString(), false);
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
findDeclaredNamesHelper(t, c, true);
checkState(NodeUtil.createsScope(scopeRoot) || scopeRoot.isParamList(), scopeRoot);
return name + ContextualRenamer.UNIQUE_ID_SEPARATOR
+ idPrefix + uniqueIdSupplier.get();
private class Traversal extends NodeTraversal.AbstractPostOrderCallback
MakeDeclaredNamesUnique uniquifier =
new MakeDeclaredNamesUnique(renamer);
Node parent = t.getScopeRoot().getParent();
NodeTraversal.traverseEs6(compiler, parent, uniquifier);
private void renameBleedingFunctionName(Node fnName) {
MakeDeclaredNamesUnique.Renamer renamer =
new MakeDeclaredNamesUnique.WhitelistedRenamer(
new MakeDeclaredNamesUnique.ContextualRenamer(),
ImmutableSet.of(fnName.getString()));
renamer.addDeclaredName(fnName.getString(), false);
MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer);
NodeTraversal.traverseEs6(compiler, fnName.getGrandparent(), uniquifier);
renameBleedingFunctionName(n);
test(
"var fn = function f(f){f = 1}",
"var fn = function f(f$jscomp$1){f$jscomp$1 = 1}");
test(
"var fn = function f(f){var f; f = 1}",
"var fn = function f(f$jscomp$1){var f$jscomp$1; f$jscomp$1 = 1}");
"var JSCompiler__a$jscomp$unique_0 = function JSCompiler__b$jscomp$unique_1("
+ "JSCompiler__c$jscomp$unique_2) { var JSCompiler__d$jscomp$unique_3; };");
"const JSCompiler__a$jscomp$unique_0 = function JSCompiler__b$jscomp$unique_1("
+ "JSCompiler__c$jscomp$unique_2) { let JSCompiler__d$jscomp$unique_3; };");
public void disabled_testRestParamWithContextWithInversion() {
test(
"f();"),
LINE_JOINER.join(
"if (true) {",
"  function f$jscomp$1(){};",
"}",
"f();"
));
"{function foo() {return 1;}",
"{function foo$jscomp$unique_1() {return 1;}",
"    function foo$jscomp$unique_2() {return 2;}",
"export function foo$jscomp$unique_1(x$jscomp$unique_2) {",
"  return foo$jscomp$unique_1(x$jscomp$unique_2) - 1;",
public void disabled_testDefaultParameterWithContextWithInversion2() {
test("var a; export {a as a};",
"var a$jscomp$1; export {a$jscomp$1 as a};");
test("var a; import {a as a} from './bar.js'",
"var a$jscomp$1; import {a as a$jscomp$1} from './bar.js'");
test("var a; export {a};", "var a$jscomp$1; export {a$jscomp$1 as a};");
test("export var a;",
"var a$jscomp$1; export {a$jscomp$1 as a};");
test("export var a = 4;",
"var a$jscomp$1 = 4; export {a$jscomp$1 as a};");
test("export var a, b;",
"var a$jscomp$1;",
"var b$jscomp$1;",
"export {a$jscomp$1 as a, b$jscomp$1 as b};"));
test("export var a = {b};",
"var a$jscomp$1 = {b: b}; export {a$jscomp$1 as a};");
"function bar$jscomp$1() {}",
"export {bar$jscomp$1 as bar};"
test("export default function foo() {};", "export default function foo$jscomp$1() {};");
"ns.fact = function y$jscomp$1(n) {",
"  return n == 1 ? 1 : n * y$jscomp$1(n - 1);",
"ns.fact = function y$jscomp$1(n) {",
"  return n == 1 ? 1 : n * y$jscomp$1(n - 1);",
"  const y = function y$jscomp$1() {",
"    use(y$jscomp$1);","Unexpected expression node" + value + "\n parent:" + value.getParent());protected void testError(Sources srcs, ErrorDiagnostic error) {
assertNotNull(error);
protected void testError(Externs externs, Sources srcs, ErrorDiagnostic error) {
assertNotNull(error);
protected void testError(List<SourceFile> inputs, DiagnosticType warning) {
assertNotNull(warning);
test(srcs(inputs), error(warning));
protected void testError(List<SourceFile> inputs, DiagnosticType warning, String description) {
assertNotNull(warning);
test(srcs(inputs), error(warning, description));
protected void testWarning(Sources srcs, WarningDiagnostic warning) {
assertNotNull(warning);
protected void testWarning(Externs externs, Sources srcs, WarningDiagnostic warning) {
assertNotNull(warning);
Diagnostic diagnostic) {
testInternal(compiler, inputs, expected, diagnostic);
protected void testInternal(
Diagnostic diagnostic) {
if (diagnostic.match != null) {
assertThat(actualError.description).isEqualTo(diagnostic.match);
if (diagnostic.match != null) {
assertThat(actual.description).isEqualTo(diagnostic.match);
if (diagnostic.match != null) {
assertThat(actualError.description).isEqualTo(diagnostic.match);
protected static WarningDiagnostic warning(DiagnosticType type) {
return warning(type, null);
protected static WarningDiagnostic warning(DiagnosticType type, String match) {
return type != null ? new WarningDiagnostic(type, match) : null;
protected static ErrorDiagnostic error(DiagnosticType type) {
return error(type, null);
protected static ErrorDiagnostic error(DiagnosticType type, String match) {
return type != null ? new ErrorDiagnostic(type, match) : null;
testInternal(externs, srcs, expected, diagnostic);
final String match;
Diagnostic(CheckLevel level, DiagnosticType diagnostic, String match) {
this.match = match;
protected static class ErrorDiagnostic extends Diagnostic {
ErrorDiagnostic(DiagnosticType diagnostic, String match) {
super(CheckLevel.ERROR, diagnostic, match);
protected static class WarningDiagnostic extends Diagnostic {
WarningDiagnostic(DiagnosticType diagnostic, String match) {
super(CheckLevel.WARNING, diagnostic, match);
import static com.google.common.truth.Truth.assertThat;
testError("function addSingletonGetter(foo) { foo.foobar = 'a'; };",
DisambiguateProperties.Warnings.INVALIDATION);
assertThat(getLastCompiler().getErrors()[0].toString()).contains("foobar");
testError(
"/** @constructor */ function F() {}"
+ "/** @type {number} */ F.prototype.foobar = 3;"
+ "/** @return {number} */ function g() { return new F(); }",
DisambiguateProperties.Warnings.INVALIDATION);
assertThat(getLastCompiler().getErrors()[0].toString()).contains("Consider fixing errors");
String externs = ""
+ "/** @constructor */ function Baz() {}"
+ "Baz.prototype.foobar";
String js = ""
+ "/** @constructor */ function Ind() {this.foobar=0}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.foobar = 0;\n"
+ "/** @constructor */ function Bar() {}\n"
+ "Bar.prototype.foobar = 0;\n"
+ "/** @type {Foo|Bar} */\n"
+ "var F = new Foo;\n"
+ "F.foobar = 1\n;"
+ "F = new Bar;\n"
+ "/** @type {Baz} */\n"
+ "var Z = new Baz;\n"
+ "Z.foobar = 1\n;";
testError(
DEFAULT_EXTERNS + externs, js,
DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE);
assertThat(getLastCompiler().getErrors()[0].toString()).contains("foobar");
private void testSets(String js, String expected, String fieldTypes) {
test(js, expected);
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
private void testSets(String externs, String js, String expected, String fieldTypes) {
test(DEFAULT_EXTERNS + externs, js, expected);
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
String fieldTypes, DiagnosticType warning, String description) {
test(DEFAULT_EXTERNS + externs, js, expected, warning(warning, description));
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
private void testSets(String js, String fieldTypes) {
testNoWarning(js);
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
private void testSets(String js, String fieldTypes, DiagnosticType warning) {
testWarning(js, warning);
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
this.mode = TypeInferenceMode.OTI_ONLY;
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(
source,
ImmutableList.<String>of("Constructor"),
NewTypeInference.GLOBAL_THIS);
this.mode = TypeInferenceMode.OTI_ONLY;
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(source, ImmutableList.of("C"), NewTypeInference.GLOBAL_THIS);
this.mode = TypeInferenceMode.OTI_ONLY;
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(source, ImmutableList.of("F.f.apply", "h"), NewTypeInference.GLOBAL_THIS);
this.mode = TypeInferenceMode.OTI_ONLY;
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(
"var a = {}; a.f(); a.f = function (){}",
ImmutableList.of("a.f"),
NewTypeInference.INEXISTENT_PROPERTY);
this.mode = TypeInferenceMode.OTI_ONLY;
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(source, ImmutableList.of("A", "f"), NewTypeInference.GLOBAL_THIS);
this.mode = TypeInferenceMode.OTI_ONLY;
assertPureCallsMarked(source, ImmutableList.of("F"));
Node lastRoot = getLastCompiler().getRoot();
Node call = findQualifiedNameNode("g.call", lastRoot).getParent();
assertEquals(
new Node.SideEffectFlags()
.clearAllFlags().setMutatesArguments().valueOf(),
call.getSideEffectFlags());
this.mode = TypeInferenceMode.NTI_ONLY;
assertPureCallsMarked(source, ImmutableList.of("F"), NewTypeInference.GLOBAL_THIS);
lastRoot = getLastCompiler().getRoot();
call = findQualifiedNameNode("g.call", lastRoot).getParent();
assertEquals(
new Node.SideEffectFlags()
.clearAllFlags().setMutatesArguments().valueOf(),
call.getSideEffectFlags());
assertPureCallsMarked(source, ImmutableList.of("goog.reflect.cache"));
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isTrue();
assertThat(call.mayMutateGlobalStateOrThrow()).isFalse();
assertPureCallsMarked(source, ImmutableList.of("goog.reflect.cache"));
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isTrue();
assertThat(call.mayMutateGlobalStateOrThrow()).isFalse();
assertPureCallsMarked(source, ImmutableList.of("goog.reflect.cache"));
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isTrue();
assertThat(call.mayMutateGlobalStateOrThrow()).isFalse();
assertNoPureCalls(source);
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isFalse();
assertThat(call.mayMutateGlobalStateOrThrow()).isTrue();
assertNoPureCalls(source);
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isFalse();
assertThat(call.mayMutateGlobalStateOrThrow()).isTrue();
assertNoPureCalls(source);
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node call = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(call.isNoSideEffectsCall()).isFalse();
assertThat(call.mayMutateGlobalStateOrThrow()).isTrue();
assertPureCallsMarked(source, ImmutableList.of("goog.reflect.cache", "helper"));
Node lastRoot = getLastCompiler().getRoot().getLastChild();
Node cacheCall = findQualifiedNameNode("goog.reflect.cache", lastRoot).getParent();
assertThat(cacheCall.isNoSideEffectsCall()).isTrue();
assertThat(cacheCall.mayMutateGlobalStateOrThrow()).isFalse();
Node helperCall = Iterables.getLast(findQualifiedNameNodes("helper", lastRoot)).getParent();
assertThat(helperCall.isNoSideEffectsCall()).isTrue();
assertThat(helperCall.mayMutateGlobalStateOrThrow()).isFalse();
void assertPureCallsMarked(String source, List<String> expected, DiagnosticType warning) {
if (warning != null) {
testSame(source, warning);
testSame(source);
assertEquals(expected, noSideEffectCalls);
void checkLocalityOfMarkedCalls(String source, List<String> expected) {
testSame(source);
assertEquals(expected, localResultCalls);
Externs externs, Sources js, Expected expected, Diagnostic diagnostic) {
testOTI(externs, js, expected, diagnostic);
testNTI(externs, js, expected, diagnostic);
super.testInternal(externs, js, expected, diagnostic);
private void testOTI(Externs externs, Sources js, Expected expected, Diagnostic diagnostic) {
super.testInternal(externs, js, expected, oti);
private void testNTI(Externs externs, Sources js, Expected expected, Diagnostic diagnostic) {
super.testInternal(externs, js, expected, nti);private boolean newEmptyClinitMethod = false;
getNonNestedParentScopeNodes(),
compiler, root, changedScopeNodes, new EmptyClinitPruner(), false);
if (newEmptyClinitMethod) {
new PureFunctionIdentifier.Driver(compiler, null).process(externs, root);
private List<Node> getNonNestedParentScopeNodes() {
newEmptyClinitMethod = true;
LINE_JOINER.join("var someClass = {};", "someClass.$clinit = function() {};"));compiler.reportChangeToEnclosingScope(node);
parent.replaceChild(node, NodeUtil.newUndefinedNode(node));
tryRemovingClinit(node, parent);
private void tryRemovingClinit(Node node, Node parent) {
parent.replaceChild(node, NodeUtil.newUndefinedNode(node));
compiler.reportChangeToEnclosingScope(parent);
body.removeChild(firstExpr);
NodeUtil.markFunctionsDeleted(firstExpr, compiler);
compiler.reportChangeToEnclosingScope(body);
n.detach();
compiler.reportChangeToEnclosingScope(parent);
public static void removeChild(Node parent, Node node) {
removeChild(parent.getParent(), parent);
removeChild(parent.getParent(), parent);
removeChild(parent.getParent(), parent);
parent.detach();
throw new IllegalStateException("Invalid attempt to remove: " + node + " from " + parent);
throw new IllegalStateException("Invalid attempt to remove node: " + node + " of " + parent);
test(
LINE_JOINER.join("Asserts.$assert(true);", "Asserts.$assert(goo());"),
LINE_JOINER.join("void 0;", "void 0;"));
test("Asserts.$assertWithMessage(true, goo());", "void 0;");
"  void 0;",
"  (void 0, true);",
"    void 0;",
"    while(true) {",
"      void 0;",
"    }",
"  } else {",
"    void 0;",
"  }",
"  var a = (void 0, true) ? (void 0, void 0) : void 0;",
"  var b = function() { void 0; };",
"  var c = function c() { void 0; };",
"  [].forEach(function() { void 0; });",
"  void 0;",
LINE_JOINER.join("var someClass = {};", "someClass.$clinit = function() {void 0;}"));
"function someClass$$0clinit() {void 0;}");
"    void 0;",n.addChildToBack(IR.name(newName).useSourceInfoIfMissingFrom(n));
if (pair.originalName.isEmpty()) {
n.replaceWith(moduleAccess.useSourceInfoIfMissingFromForTree(n));
n.replaceWith(
IR.getprop(moduleAccess, IR.string(pair.originalName))
.useSourceInfoIfMissingFromForTree(n));
t.reportCodeChange(moduleAccess);Node maybeBind = parent.isCall() ? parent.getFirstChild() : parent;
if (NodeUtil.isFunctionBind(maybeBind) && !NodeUtil.isGoogPartial(maybeBind)) {
Node call = maybeBind.getParent();
Bind bindComponents = convention.describeFunctionBind(call, true, false);
JSType recvType = bindComponents.thisValue == null
? null : simpleInferExprType(bindComponents.thisValue);
if (recvType == null) {
return null;
return allButRecvType.withReceiverType(recvType);
case THROW:
TypeEnv exitEnv = getInEnv(this.cfg.getImplicitReturn());
TypeEnv outEnv = collectTypesForFreeVarsFwd(expr, inEnv);
tmpEnv = collectTypesForFreeVarsFwd(callee, tmpEnv);
private TypeEnv collectTypesForFreeVarsFwd(Node n, TypeEnv env) {
FunctionType summary = summaries.get(innerScope).getFunType();
env = envPutType(env, freeVar,
n.isFunction() ? JSType.join(innerType, outerType) : innerType);
TypeEnv env = analyzeExprBwd(
expr.getLastChild(), outEnv, commonTypes.topFunction()).env;
TypeEnv getEntryTypeEnv() {
return evalInternal(
ttlAst,
new NameResolver(typeVars, nameVars));
if (this.typeMap.isEmpty()) {
return other.instantiationIsUnknownOrIdentity();
if (other.typeMap.isEmpty()) {
return instantiationIsUnknownOrIdentity();
private boolean instantiationIsUnknownOrIdentity() {
if (this.typeMap.isEmpty()) {
return true;
for (String typeVar : this.rawType.getTypeParameters()) {
Preconditions.checkState(this.typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, this.typeMap.keySet());
JSType t = this.typeMap.get(typeVar);
if (!(t.isUnknown() || t.equals(JSType.fromTypeVar(getCommonTypes(), typeVar)))) {
return false;
return true;
"Foo.prototype.f.bind(new Foo('asdf'), 1, 2);"),
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
verify("result", JSTypeNative.NO_TYPE);
testTTL(NO_TYPE, "none()");
testTTL(NO_TYPE, "cond(eq(BOT, none()), none(), N)");import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
import static com.google.javascript.jscomp.Es6ToEs3Converter.makeIterator;
import static com.google.javascript.jscomp.Es6ToEs3Converter.makeIterator;
Es6ToEs3Converter.CANNOT_CONVERT_YET,
Es6ToEs3Converter.CANNOT_CONVERT_YET,
Es6ToEs3Converter.CANNOT_CONVERT_YET,
JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT, "Undecomposable expression"));
compiler.report(JSError.make(export, Es6ToEs3Converter.CANNOT_CONVERT_YET,
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import java.util.Locale;
public final class Es6ToEs3Converter implements NodeTraversal.Callback, HotSwapCompilerPass {
static final DiagnosticType CANNOT_CONVERT = DiagnosticType.error(
"JSC_CANNOT_CONVERT",
"This code cannot be converted from ES6. {0}");
static final DiagnosticType CANNOT_CONVERT_YET = DiagnosticType.error(
"JSC_CANNOT_CONVERT_YET",
"ES6 transpilation of ''{0}'' is not yet implemented.");
private static final String FRESH_COMP_PROP_VAR = "$jscomp$compprop";
private static final String ITER_BASE = "$jscomp$iter$";
private static final String ITER_RESULT = "$jscomp$key$";
public Es6ToEs3Converter(AbstractCompiler compiler) {
cannotConvert(n, "ES5 getters/setters (consider using --language_out=ES5)");
case OBJECTLIT:
visitObject(n);
break;
case MEMBER_FUNCTION_DEF:
if (parent.isObjectLit()) {
visitMemberFunctionDefInObjectLit(n, parent);
break;
case FOR_OF:
visitForOf(n, parent);
break;
case STRING_KEY:
visitStringKey(n);
break;
case TAGGED_TEMPLATELIT:
Es6TemplateLiterals.visitTaggedTemplateLiteral(t, n);
break;
case TEMPLATELIT:
if (!parent.isTaggedTemplateLit()) {
Es6TemplateLiterals.visitTemplateLiteral(t, n);
break;
private void visitMemberFunctionDefInObjectLit(Node n, Node parent) {
String name = n.getString();
Node nameNode = n.getFirstFirstChild();
Node stringKey = IR.stringKey(name, n.getFirstChild().detach());
stringKey.setJSDocInfo(n.getJSDocInfo());
parent.replaceChild(n, stringKey);
stringKey.useSourceInfoFrom(nameNode);
compiler.reportChangeToEnclosingScope(stringKey);
private void visitStringKey(Node n) {
if (!n.hasChildren()) {
Node name = IR.name(n.getString());
name.useSourceInfoIfMissingFrom(n);
n.addChildToBack(name);
compiler.reportChangeToEnclosingScope(name);
private void visitForOf(Node node, Node parent) {
Node variable = node.removeFirstChild();
Node iterable = node.removeFirstChild();
Node body = node.removeFirstChild();
JSDocInfo varJSDocInfo = variable.getJSDocInfo();
Node iterName = IR.name(ITER_BASE + compiler.getUniqueNameIdSupplier().get());
iterName.makeNonIndexable();
Node getNext = IR.call(IR.getprop(iterName.cloneTree(), IR.string("next")));
String variableName;
Token declType;
if (variable.isName()) {
declType = Token.NAME;
variableName = variable.getQualifiedName();
Preconditions.checkState(NodeUtil.isNameDeclaration(variable),
"Expected var, let, or const. Got %s", variable);
declType = variable.getToken();
variableName = variable.getFirstChild().getQualifiedName();
Node iterResult = IR.name(ITER_RESULT + variableName);
iterResult.makeNonIndexable();
Node init = IR.var(iterName.cloneTree(), makeIterator(compiler, iterable));
Node initIterResult = iterResult.cloneTree();
initIterResult.addChildToFront(getNext.cloneTree());
init.addChildToBack(initIterResult);
Node cond = IR.not(IR.getprop(iterResult.cloneTree(), IR.string("done")));
Node incr = IR.assign(iterResult.cloneTree(), getNext.cloneTree());
Node declarationOrAssign;
if (declType == Token.NAME) {
declarationOrAssign = IR.assign(
IR.name(variableName).useSourceInfoFrom(variable),
IR.getprop(iterResult.cloneTree(), IR.string("value")));
declarationOrAssign.setJSDocInfo(varJSDocInfo);
declarationOrAssign = IR.exprResult(declarationOrAssign);
declarationOrAssign = new Node(
declType,
IR.name(variableName).useSourceInfoFrom(variable.getFirstChild()));
declarationOrAssign.getFirstChild().addChildToBack(
IR.getprop(iterResult.cloneTree(), IR.string("value")));
declarationOrAssign.setJSDocInfo(varJSDocInfo);
Node newBody = IR.block(declarationOrAssign, body).useSourceInfoFrom(body);
Node newFor = IR.forNode(init, cond, incr, newBody);
newFor.useSourceInfoIfMissingFromForTree(node);
parent.replaceChild(node, newFor);
compiler.reportChangeToEnclosingScope(newFor);
groups.add(arrayFromIterable(compiler, currElement.removeFirstChild()));
cannotConvert(node, "\"...\" passed to a constructor (consider using --language_out=ES5)");
private void visitObject(Node obj) {
for (Node child : obj.children()) {
if (child.isComputedProp()) {
visitObjectWithComputedProperty(obj);
return;
private void visitObjectWithComputedProperty(Node obj) {
checkArgument(obj.isObjectLit());
List<Node> props = new ArrayList<>();
Node currElement = obj.getFirstChild();
while (currElement != null) {
if (currElement.getBooleanProp(Node.COMPUTED_PROP_GETTER)
|| currElement.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
cannotConvertYet(currElement, "computed getter/setter in an object literal");
return;
currElement = currElement.getNext();
Node nextNode = currElement.getNext();
obj.removeChild(currElement);
props.add(currElement);
currElement = nextNode;
String objName = FRESH_COMP_PROP_VAR + compiler.getUniqueNameIdSupplier().get();
props = Lists.reverse(props);
Node result = IR.name(objName);
for (Node propdef : props) {
if (propdef.isComputedProp()) {
Node propertyExpression = propdef.removeFirstChild();
Node value = propdef.removeFirstChild();
result = IR.comma(
IR.assign(
IR.getelem(
IR.name(objName),
propertyExpression),
value),
result);
if (!propdef.hasChildren()) {
Node name = IR.name(propdef.getString()).useSourceInfoIfMissingFrom(propdef);
propdef.addChildToBack(name);
Node val = propdef.removeFirstChild();
propdef.setToken(Token.STRING);
Token type = propdef.isQuotedString() ? Token.GETELEM : Token.GETPROP;
Node access = new Node(type, IR.name(objName), propdef);
result = IR.comma(IR.assign(access, val), result);
Node statement = obj;
while (!NodeUtil.isStatement(statement)) {
statement = statement.getParent();
result.useSourceInfoIfMissingFromForTree(obj);
obj.replaceWith(result);
Node var = IR.var(IR.name(objName), obj);
var.useSourceInfoIfMissingFromForTree(statement);
statement.getParent().addChildBefore(var, statement);
compiler.reportChangeToEnclosingScope(var);
private void cannotConvert(Node n, String message) {
compiler.report(JSError.make(n, CANNOT_CONVERT, message));
private void cannotConvertYet(Node n, String feature) {
compiler.report(JSError.make(n, CANNOT_CONVERT_YET, feature));
static Node makeIterator(AbstractCompiler compiler, Node iterable) {
return callEs6RuntimeFunction(compiler, iterable, "makeIterator");
private static Node arrayFromIterable(AbstractCompiler compiler, Node iterable) {
return callEs6RuntimeFunction(compiler, iterable, "arrayFromIterable");
private static Node callEs6RuntimeFunction(
AbstractCompiler compiler, Node iterable, String function) {
compiler.ensureLibraryInjected("es6/util/" + function.toLowerCase(Locale.US), false);
return IR.call(
NodeUtil.newQName(compiler, "$jscomp." + function),
iterable);
passes.add(convertEs6ToEs3);
static final HotSwapPassFactory convertEs6ToEs3 =
new HotSwapPassFactory("convertEs6", true) {
return new Es6ToEs3Converter(compiler);
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
Es6ToEs3Converter.CANNOT_CONVERT);
Es6ToEs3Converter.CANNOT_CONVERT_YET);
Es6ToEs3Converter.CANNOT_CONVERT_YET);
Es6ToEs3Converter.CANNOT_CONVERT_YET);
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
optimizer.addOneTimePass(makePassFactory("convertEs6", new Es6ToEs3Converter(compiler)));
Es6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);
Es6ToEs3Converter.BAD_REST_PARAMETER_ANNOTATION);if (parent.isClass()) {
case INC:
case DEC:
return true;
case DELPROP:
case IN:n.setQuotedString();
compiler.reportChangeToEnclosingScope(n);
"cr.define('my.namespace', function() { class X {} return {X: X}; });",
"var my = my || {};",
CompilationLevel.ADVANCED_OPTIMIZATIONS
.setOptionsForCompilationLevel(options);
"/** @type {number} */ (g.foo) = 3;",import com.google.javascript.jscomp.Normalize.PropagateConstantAnnotationsOverVars;
(new PropagateConstantAnnotationsOverVars(compiler, false)).process(externs, root);
if (options.convertToDottedProperties) {
passes.add(convertToDottedProperties);
if (!n.isQuotedString()) {
compiler.reportChangeToEnclosingScope(n);
n.setQuotedString();
import com.google.javascript.jscomp.CompilerOptions.DevMode;
"var cr = {}; cr.define('my.namespace', function() { class X {} return {X: X}; });",
"var cr = {},",
"    my = my || {};",
options.setDevMode(DevMode.OFF);
options.setDevMode(DevMode.OFF);
options.setDevMode(DevMode.OFF);
"/** @type {number} */ g.foo = 3;",
options.setDevMode(DevMode.EVERY_PASS);
"",
"Object.prototype;",
"",if (options.convertToDottedProperties) {
passes.add(convertToDottedProperties);
n.setQuotedString();
compiler.reportChangeToEnclosingScope(n);
"cr.define('my.namespace', function() { class X {} return {X: X}; });",
"var my = my || {};",
"/** @type {number} */ (g.foo) = 3;",abstract void addToDebugLog(String message);
void addToDebugLog(String str) {
debugLog.append(str);
logger.fine(str);
if (ref.module != fnModule &&
!moduleGraph.dependsOn(ref.module, fnModule)) {
int referencesUsingDirectInlining = referenceCount -
referencesUsingBlockInlining;
if (referenceCount == 1 && isRemovable &&
referencesUsingDirectInlining == 1) {
int costDeltaFunctionOverhead = 15 + commaCount +
(paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);
t.getCompiler().addToDebugLog("Inlined function: " + fn.getName());
if ((n.isName() || n.isStringKey())) {
compiler.addToDebugLog("Overriding @define variable " + defineName);
compiler.addToDebugLog("Unreferenced var: " + var.name);
compiler.addToDebugLog("label renamed: " + name + " => " + newName);
CompilationLevel.ADVANCED_OPTIMIZATIONS
.setOptionsForCompilationLevel(options);
assertThat(e.getMessage()).contains("Unexpected variable x");Node aliasNode = importSpec.hasChildren() ? importSpec.getFirstChild() : importSpec;checkState(importSpec.hasChildren());
Node aliasNode = importSpec.getFirstChild();
safeSetString(aliasNode, currentScript.contentsPrefix + aliasName);
private boolean preserveClosurePrimitives = false;
options.setPreserveClosurePrimitives(this.preserveClosurePrimitives);
public void testImportInliningShadowsDestructuredImport() {
testError(
new String[] {
LINE_JOINER.join(
"goog.provide('a.b.c');",
"a.b.c.d = 5;"),
LINE_JOINER.join(
"goog.module('a.b.d');",
"const {d} = goog.require('a.b.c');",
"function foo() {",
"  var a = 10;",
"  var b = d;",
"}")},
IMPORT_INLINING_SHADOWS_VAR);
public void testRewriteGoogModuleAliasesWithPreservedPrimitivies() {
preserveClosurePrimitives = true;
disableCompareAsTree();
test(
new String[] {
LINE_JOINER.join(
"goog.module('Foo');",
"",
"/** @constructor */ exports = function() {};"),
LINE_JOINER.join(
"goog.module('bar');",
"",
"exports.doBar = function() {};"),
LINE_JOINER.join(
"goog.module('baz');",
"",
"exports.doBaz = function() {};"),
LINE_JOINER.join(
"goog.module('leaf');",
"",
"var Foo = goog.require('Foo');",
"var {doBar} = goog.require('bar');",
"var {doBaz: doooBaz} = goog.require('baz')"),
new String[] {
"goog.module(\"Foo\");",
"var module$exports$Foo=function(){};",
"goog.module(\"bar\");",
"var module$exports$bar={};",
"module$exports$bar.doBar=function(){};",
"goog.module(\"baz\");",
"var module$exports$baz={};",
"module$exports$baz.doBaz=function(){};",
"goog.module(\"leaf\");",
"var module$exports$leaf={};",
"var module$contents$leaf_Foo=goog.require(\"Foo\");",
"var {doBar:module$contents$leaf_doBar}=goog.require(\"bar\");",
"var {doBaz:module$contents$leaf_doooBaz}=goog.require(\"baz\")"if (!firstParam.hasUninstantiatedTypeVariables()) {
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType();
public boolean hasUninstantiatedTypeVariables() {
return nt == null ? false : nt.isUninstantiatedGenericType();
boolean hasUninstantiatedTypeVariables();
public boolean hasUninstantiatedTypeVariables() {
return getTemplateTypeMap().hasUnfilledTemplateKeys();
boolean hasUnfilledTemplateKeys() {
return numUnfilledTemplateKeys() > 0;
import junit.framework.TestCase;Node aliasNode = importSpec.hasChildren() ? importSpec.getFirstChild() : importSpec;return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType()
&& !type.hasUninstantiatedTypeVariables();
public void testIsTemplatized() {
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized('Array'), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 'asdf'; }",
"var /** string */ s = f();"));
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized(type('Array', 'number')), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 123; }",
"var /** number */ n = f();"));
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized('number'), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 'asdf'; }",
"var /** string */ s = f();"));if (ast instanceof JsAst && JsFileParser.isSupported()) {
DepsFinder finder = new DepsFinder(compiler.getCodingConvention());
private final CodingConvention codingConvention;
DepsFinder(CodingConvention codingConvention) {
this.codingConvention = codingConvention;
boolean isModuleDetected = codingConvention.extractIsModuleFile(n, parent);
if (isModuleDetected) {
loadFlags.put("module", "goog");
String require = codingConvention.extractClassNameIfRequire(n, parent);
if (require != null) {
requires.add(require);
String provide = codingConvention.extractClassNameIfProvide(n, parent);
if (provide != null) {
provides.add(provide);
default:
if (parent != null && !parent.isExprResult() && !NodeUtil.isTopLevel(parent)) {
return;
this.modulePath = compiler.getModuleLoader().resolve(getName());
if (root == null) {validChildren.put(getContainingScript(scope.getRootNode()), scope);
checkArgument(newParent == null || newParent.isValid());
checkState((parent == null) == (newParent == null));
if (parent != null && (!valid || this.parent != newParent)) {
this.parent = newParent;
if (!valid) {
getParent().addChildScope(this);
this.depth = parent.getDepth() + 1;
if (!this.valid) {
this.valid = true;
Node root1 = IR.root();
Node root2 = IR.root();
Compiler compiler = new Compiler();
compiler.initOptions(new CompilerOptions());
assertNotSame(scopeA, creator.createScope(root2, null));
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
SourceFile.fromCode("testcode1.js", "var a; var b; function foo() {}"),
compiler.init(externs, srcs, options);
compiler.parseInputs();
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
compiler.init(externs, srcs, options);
compiler.parseInputs();
public void testPreconditionCheck() throws Exception {
Compiler compiler = new Compiler();
compiler.initOptions(new CompilerOptions());
Node root = IR.root();
Scope scopeA = creator.createScope(root, null);
try {
creator.createScope(root, scopeA);
fail();"Variable {0} declared more than once. First occurence: {1}");
String message = "Variable x declared more than once. First occurence: input0";
String message = "Variable x declared more than once. First occurence: input0";protected CompilerPass create(final AbstractCompiler compiler) {
final GatherRawExports pass = new GatherRawExports(compiler);
return new CompilerPass() {
public void process(Node externs, Node root) {
pass.process(externs, root);
compiler.addExportedNames(pass.getExportedVariableNames());
public FeatureSet featureSet() {
return ES8;
return ES8;
test(options, "function f(x) { if (x) var x=5; }", "function f(x) { if (x) var x=5; }");DiagnosticType.warning("JSC_MISPLACED_MSG_ANNOTATION",
options.setWarningLevel(DiagnosticGroups.INVALID_CASTS, CheckLevel.WARNING);if (!operand.isValidAssignmentTarget()) {parent != null && (parent.isExprResult() || parent.isNormalBlock() || parent.isScript());
insertBefore(existingNode, "const " + shortName + " = ");IR.shne(IR.name(GENERATOR_THROW_ARG), IR.name("undefined")),
Node genBlock = compiler.parseSyntheticCode(Joiner.on('\n').join(
"function generatorBody() {",
"  var " + GENERATOR_STATE + " = " + generatorCaseCount + ";",
"  function $jscomp$generator$impl(" + GENERATOR_NEXT_ARG + ", ",
"      " + GENERATOR_THROW_ARG + ") {",
"    while (1) switch (" + GENERATOR_STATE + ") {",
"      case " + generatorCaseCount + ":",
"      default:",
"        return {value: undefined, done: true};",
"    }",
"  }",
"  var iterator = /** @type {!Generator<?>} */ ({",
"    next: function(arg) { return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg) { return $jscomp$generator$impl(undefined, arg); },",
"    return: function(arg) { throw Error('Not yet implemented'); },",
"  });",
"  $jscomp.initSymbolIterator();",
"  /** @this {!Generator<?>} */",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"))
.getFirstChild() // function
.getLastChild().detach();
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"    next: function(arg) { return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  var i;",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"var $jscomp$generator$switch$val1; var $jscomp$generator$switch$entered0;",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    if (!($jscomp$generator$throw$arg !== undefined)) {",
"    if (!($jscomp$generator$throw$arg !== undefined)) {",import com.google.javascript.rhino.JSDocInfo;
static boolean isCtorDefinedByCall(Node qnameNode) {
if (!qnameNode.isName() && !qnameNode.isGetProp()) {
return false;
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(qnameNode);
Node rhs = NodeUtil.getRValueOfLValue(qnameNode);
return jsdoc != null && jsdoc.isConstructor() && rhs != null && rhs.isCall();
checkSuperProperty(rawType, superClass, pname,
propMethodTypesToProcess, propTypesToProcess);
if (GlobalTypeInfo.isCtorDefinedByCall(NodeUtil.getBestLValue(current.getDefSite()))) {
PropertyDef propdef = checkNotNull(
getPropDefFromClass(superType, pname),
"getPropDefFromClass(%s, %s) returned null", superType, pname);
&& !GlobalTypeInfo.isCtorDefinedByCall(NodeUtil.getBestLValue(current.getDefSite()))
if (GlobalTypeInfo.isCtorDefinedByCall(lhs)) {
if (GlobalTypeInfo.isCtorDefinedByCall(nameNode)) {
if (classType.hasCtorProp(pname)
if (GlobalTypeInfo.isCtorDefinedByCall(getProp)) {
|| (ns.hasProp(pname)
|| (GlobalTypeInfo.isCtorDefinedByCall(nameNode)
|| (GlobalTypeInfo.isCtorDefinedByCall(lhs)
public final boolean hasProp(String pname) {
return maybeWin.getProp(pname);
Property getProp(String pname) {
Property p = this.rawType.getProp(pname);
Property p = this.rawType.getOwnProp(pname);
Property p = this.rawType.getProp(pname);
Property prop2 = other.getProp(pname);
Property prop1 = this.getProp(pname);
Property otherProp = resultNominalType.getProp(pname);
Property otherProp = resultNominalType.getProp(pname);
return nom.getProp(pname);
return this.nominalType.getProp(pname);
Property getOwnProp(String pname) {
p = randomProps.get(pname);
if (p != null) {
return p;
Property p = getPropFromClass(pname);
private Property getPropFromClass(String pname) {
Property p = getOwnProp(pname);
p = this.superclass.getProp(pname);
private Property getPropFromInterface(String pname) {
Property p = getOwnProp(pname);
p = interf.getProp(pname);
Property getProp(String pname) {
return getPropFromInterface(pname);
return getPropFromClass(pname);
return getOwnProp(pname) != null;
return getProp(pname) != null;
Property p = getProp(pname);
public boolean hasCtorProp(String pname) {
return super.hasProp(pname);Node value = n.isFromExterns() ? null : n.getChildAtIndex(2).detach();
Node replacement = NodeUtil.newQNameDeclaration(
compiler, name, value, n.getJSDocInfo());private final CompilerExecutor compilerExecutor = getCompilerExecutor();
protected CompilerExecutor getCompilerExecutor() {
return new CompilerExecutor();
final class CompilerExecutor {
private final ExecutorService compilerExecutor;
CompilerExecutor() {
this(getDefaultExecutorService());
CompilerExecutor(ExecutorService compilerExecutorService) {
this.compilerExecutor = compilerExecutorService;
static ExecutorService getDefaultExecutorService() {
Future<T> future = compilerExecutor.submit(bootCompilerThread);
CompilerExecutor() {}return "Expected : " + expected + "\n"
+ "Found    : " + found + "\n";
.append(expected)
.append(found)
.append(mismatch.getExpectedType())
.append(mismatch.getFoundType());
.append(mismatch.getExpectedType())
.append(mismatch.getFoundType());
.append(mismatch.getExpectedType())
.append(mismatch.getFoundType());
.append(mismatch.getFoundType());private boolean forceRewrite;
this.forceRewrite = true;
forceRewrite = false;
forceRewrite = false;
if (!exportMap.isEmpty() || forceRewrite) {
Node googProvide = IR.exprResult(
IR.call(NodeUtil.newQName(compiler, "goog.provide"),
IR.string(moduleName)));
script.addChildToFront(googProvide.useSourceInfoIfMissingFromForTree(script));
t.getInput().addProvide(moduleName);
"var baz$$module$app = new module$foo();", "console.log(baz$$module$app.bar());")
"'use strict';"
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode(
"/index[0].js", "import foo from './foo'; foo('hello');"),
SourceFile.fromCode("/foo.js",
"export default (foo) => { alert(foo); }"));
ModuleIdentifier.forFile("/index[0]"));
options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT_2017);
options.setLanguageOut(CompilerOptions.LanguageMode.ECMASCRIPT5);
ModulesTestUtils.testModules(this, input,
"/** @fileoverview\n * @suppress {missingProvide|missingRequire}\n */" + expected);
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.provide('module$testcode');",
"goog.require('module$mod$name');")));
"goog.require('module$i1'); alert(module$i1.x);",if (!currentScript.declareLegacyNamespace) {
compiler.reportChangeToEnclosingScope(statementNode);
statementNode.detach();
compiler.reportChangeToEnclosingScope(statementNode);
statementNode.detach();
if (targetIsNonLegacyGoogModule) {
NodeUtil.getEnclosingStatement(requireNode).detach();
private boolean preserveGoogProvidesAndRequires;
preserveGoogProvidesAndRequires = false;
this.preserveGoogProvidesAndRequires = preserveGoogProvidesAndRequires;
return this.preserveGoogProvidesAndRequires || this.shouldGenerateTypedExterns();
.add("preserveGoogProvidesAndRequires", preserveGoogProvidesAndRequires)
compiler.report(t.makeError(n, INVALID_CLOSURE_CALL_ERROR));
return false;
this.localVarMatches.set(paramIndex, ast.getString());
return anyOf(functionCall("goog.module"), functionCall("goog.provide"));
options.setClosurePass(true);
options.setPreserveGoogProvidesAndRequires(true);
matchedTemplate.matcher.getTemplateNodeToMatchMap());
for (String require : matchedTemplate.getGoogRequiresToAdd()) {
fix.addGoogRequire(match, require);
private Node transformNode(Node templateNode, Map<String, Node> templateNodeToMatchMap) {
clone.addChildToBack(transformNode(child, templateNodeToMatchMap));
if (jsDoc != null) {
if (script.isModuleBody()) {
if (shortName.compareTo(child.getFirstChild().getString()) < 0) {
"const Xray = goog.require('goog.rays.Xray');",
RefactoringDriver driver = new RefactoringDriver.Builder(scanner)
.addExternsFromCode("function Symbol() {};" + externs)
.addInputsFromCode(originalCode)
.build();static final DiagnosticType MISSING_REQUIRE_WARNING =
static final DiagnosticType MISSING_REQUIRE_STRICT_WARNING =
if (error.getType().equals(EXTRA_REQUIRE_WARNING) && containsFixableShorthandModuleWarning) {for (Node arg = callee.getNext(); arg != null; arg = arg.getNext()) {
builder.addReqFormal(isImpreciseType(argType) ? BOTTOM : argType);
"var /** !Array<!Foo>|undefined */ foos;",
"/** @constructor */ function Foo() {};",
"/** @param {string} str\n @param {number} num */",
"  if (foos) {",
"    Array.prototype.forEach.call(foos, function(foo) { foo.bar(str, num); });",
"  }",import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;
import java.util.Iterator;
Iterator<Declaration> it = info.declarationIterator();
while (it.hasNext()) {
Declaration decl = it.next();
checkState(decl.module == info.declModule);
Node declParent = decl.node.getParent();
checkState(
!declParent.isVar() || declParent.hasOneChild(),
"AST not normalized.");
compiler.reportChangeToEnclosingScope(declParent);
declParent.detach();
destParent.addChildToFront(declParent);
compiler.reportChangeToEnclosingScope(declParent);
boolean allowMove = true;
private final Deque<Declaration> declarations =
new ArrayDeque<>();
boolean isAllowedToMove() {
return allowMove;
void disallowMovement() {
allowMove = false;
modulesWithReferences = null;
preferredModule = declModule;
void addUsedModule(JSModule m) {
if (allowMove) {
if (modulesWithReferences == null) {
modulesWithReferences = new BitSet(graph.getModuleCount());
modulesWithReferences.set(m.getIndex());
preferredModule = null;
checkState(allowMove);
boolean addDeclaration(Declaration d) {
if (declModule != null && d.module != declModule) {
return false;
declarations.push(d);
declModule = d.module;
return true;
Iterator<Declaration> declarationIterator() {
return declarations.iterator();
private static class Declaration {
final JSModule module;
final Node node;
Declaration(JSModule module, Node node) {
this.module = checkNotNull(module);
this.node = checkNotNull(node);
private static boolean hasConditionalAncestor(Node n) {
for (Node ancestor : n.getAncestors()) {
switch (ancestor.getToken()) {
case DO:
case FOR:
case FOR_IN:
case HOOK:
case IF:
case SWITCH:
case WHILE:
case FUNCTION:
return true;
default:
break;
return false;
private void processRead(Reference ref, NamedInfo info) {
String name = ref.getNode().getString();
boolean recursive = false;
Scope hoistTarget = ref.getScope().getClosestHoistScope();
if (hoistTarget.isFunctionBlockScope()) {
Node rootNode = hoistTarget.getRootNode().getParent();
String scopeFuncName = rootNode.getFirstChild().getString();
Node scopeFuncParent = rootNode.getParent();
if (scopeFuncName.equals(name)) {
recursive = true;
scopeFuncParent.getString().equals(name)) {
recursive = true;
for (Scope s = ref.getScope();
s.getParent() != null; s = s.getParent()) {
Node curRoot = s.getRootNode();
if (curRoot.getParent().isAssign()) {
Node owner = curRoot.getParent().getFirstChild();
while (owner.isGetProp()) {
owner = owner.getFirstChild();
if (owner.isName() &&
owner.getString().equals(name)) {
recursive = true;
break;
if (!recursive) {
info.addUsedModule(getModule(ref));
for (Var v : collector.getAllSymbols()) {
NamedInfo info = getNamedInfo(v);
if (info.isAllowedToMove()) {
ReferenceCollection refCollection = collector.getReferences(v);
for (Reference ref : refCollection) {
processReference(collector, ref, info, v);
private void processReference(
CrossModuleReferenceCollector collector, Reference ref, NamedInfo info, Var v) {
Node n = ref.getNode();
if (isRecursiveDeclaration(v, n)) {
return;
Node parent = n.getParent();
if (maybeProcessDeclaration(collector, ref, info)) {
if (hasConditionalAncestor(parent.getParent())) {
info.disallowMovement();
if (!parentModuleCanSeeSymbolsDeclaredInChildren) {
processRead(ref, info);
if (isUnguardedInstanceofReference(n)) {
instanceofNodes.put(parent, new InstanceofInfo(getModule(ref), info));
processRead(ref, info);
private boolean isRecursiveDeclaration(Var variable, Node referenceNode) {
if (!referenceNode.getParent().isAssign()) {
return false;
Node enclosingFunction = NodeUtil.getEnclosingFunction(referenceNode);
return enclosingFunction != null
&& variable.getName().equals(NodeUtil.getNearestFunctionName(enclosingFunction));
private boolean maybeProcessDeclaration(
CrossModuleReferenceCollector collector, Reference ref, NamedInfo info) {
Node name = ref.getNode();
Node parent = name.getParent();
Node grandparent = parent.getParent();
switch (parent.getToken()) {
case VAR:
if (canMoveValue(collector, ref.getScope(), name.getFirstChild())) {
return info.addDeclaration(
new Declaration(getModule(ref), name));
return false;
case FUNCTION:
if (NodeUtil.isFunctionDeclaration(parent)) {
return info.addDeclaration(
new Declaration(getModule(ref), name));
return false;
case ASSIGN:
case GETPROP:
Node child = name;
for (Node current : name.getAncestors()) {
if (current.isGetProp()) {
current.getFirstChild() == child) {
Node currentParent = current.getParent();
if (currentParent.isExprResult() &&
canMoveValue(
collector, ref.getScope(), current.getLastChild())) {
return info.addDeclaration(
new Declaration(getModule(ref), current));
return false;
child = current;
return false;
case CALL:
if (NodeUtil.isExprCall(grandparent)) {
SubclassRelationship relationship =
compiler.getCodingConvention().getClassesDefinedByCall(parent);
if (relationship != null &&
name.getString().equals(relationship.subclassName)) {
return info.addDeclaration(
new Declaration(getModule(ref), parent));
return false;
default:
return false;
private static boolean canMoveValue(
CrossModuleReferenceCollector collector, Scope scope, Node n) {
if (n == null || NodeUtil.isLiteralValue(n, true) ||
n.isFunction()) {
return true;
Node functionName = n.getFirstChild();
return functionName.isName() &&
(functionName.getString().equals(
CrossModuleMethodMotion.STUB_METHOD_NAME) ||
functionName.getString().equals(
CrossModuleMethodMotion.UNSTUB_METHOD_NAME));
boolean isObjectLit = n.isObjectLit();
for (Node child = n.getFirstChild(); child != null;
child = child.getNext()) {
if (!canMoveValue(collector, scope,
isObjectLit ? child.getFirstChild() : child)) {
return false;
return true;
Var v = scope.getVar(n.getString());
if (v != null && v.isGlobal()) {
ReferenceCollection refCollection = collector.getReferences(v);
if (refCollection != null &&
refCollection.isWellDefined() &&
refCollection.isAssignedOnceInLifetime()) {
return true;
return false;
if (n.isName() || (n.isStringKey() && !n.hasChildren())) {
String varName = n.getString();
Var v = t.getScope().getVar(varName);
if (v != null) {
if (v.isGlobal() && !compiler.getCodingConvention().isExported(v.getName())) {
if (varsByName.containsKey(varName)) {
checkState(Objects.equals(varsByName.get(varName), v));
varsByName.put(varName, v);
addReference(v, new Reference(n, t, peek(blockStack)));
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
Node parent) {
topLevelStatements.add(new TopLevelStatement(nodeTraversal.getModule(), n));
private void addReference(Var v, Reference reference) {
peek(topLevelStatements).addReference(reference);
static final class TopLevelStatement {
private final List<Reference> containedReferences = new ArrayList<>();
TopLevelStatement(JSModule module, Node statementNode) {
this.module = module;
this.statementNode = statementNode;
private void addReference(Reference reference) {
containedReferences.add(reference);
List<Reference> getContainedReferences() {
return Collections.unmodifiableList(containedReferences);
assertThat(topLevelStatements.get(0).getContainedReferences())
.containsExactly(xReferences.get(0));
assertThat(topLevelStatements.get(1).getContainedReferences())
assertThat(topLevelStatements.get(2).getContainedReferences())
assertThat(topLevelStatements.get(3).getContainedReferences())
.containsExactly(fReferences.get(0), zReferences.get(1));if (filename != null && filename.startsWith(" [synthetic")
|| JSType.mockToString) {
private WarningReporter warnings;
private Map<DiGraphEdge<Node, ControlFlowGraph.Branch>, TypeEnv> envs;
private Map<NTIScope, JSType> summaries;
private Map<Node, DeferredCheck> deferredChecks;
if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
EnvTypePair objPair, ctorPair;
if (NodeUtil.isGoogBind(call.getFirstChild()) && callChildCount <= 2
|| !NodeUtil.isGoogPartial(call.getFirstChild()) && callChildCount == 1) {
mayWarnAboutGlobalThis(expr, currentScope);
if (tokenType == Token.EQ && specializedType.isTrueOrTruthy()
|| tokenType == Token.NE && specializedType.isFalseOrFalsy()) {
|| tokenType == Token.NE && specializedType.isTrueOrTruthy()) {
JSType reqPtype, specPtype;
|| !recvType.isLoose() && recvType.hasProp(propQname)) {
private void mayWarnAboutGlobalThis(Node thisExpr, NTIScope currentScope) {
JSType recvReqType, recvSpecType;
Preconditions.checkArgument(n.isFunction()
|| n.isName() && NodeUtil.isCallOrNewTarget(n));
&& (n.isName() || n.isFunction() && !outerType.isUndefined())
|| expr.isNew() && !funType.isSomeConstructorOrInterface()) {
"Expected : "
+ expected.toString()
+ "\n"
+ "Found    : "
+ actual.toString()
+ "\n"));
mayWarnAboutGlobalThis(expr, currentScope);AstChangeProxy() {
listeners = new ArrayList<>();
import java.util.HashMap;
import java.util.Map;
private final Map<Node, Node> map = new HashMap<>();
map.clear();
if (NodeUtil.isChangeScopeRoot(n)) {
map.put(n, snapshot);
private void verifyScopeChangesHaveBeenRecorded(
String passName, Node root) {
NodeUtil.visitPreOrder(root,
Node clone = map.get(n);
passNameMsg + "new scope not explicitly marked as changed: " + n.toStringTree());
Node moduleBlockNode = call.getLastChild().getLastChild();
root.removeChildren();
Node extern = externs.removeFirstChild();
root.addChildToBack(extern);
compiler.reportChangeToChangeScope(extern);
NodeTraversal.traverseEs6(compiler, root, new RemoveNonDeclarations());
t.reportCodeChange();
parent.removeFirstChild();
Node objectLit = getKey.getParent().getParent().getParent();
getKey.getParent().getParent().detach();
changeProxy.replaceWith(grandparent, parent,
parent.getLastChild().detach());
this.changeProxy = new AstChangeProxy();
changeProxy.replaceWith(
parent, n, collapseReplacements(newReplacements));
assign.remove();
void remove() {
TRANSPILED = 93;            // Indicates that a SCRIPT represents a transpiled file
case TYPE_BEFORE_CAST: return "type_before_cast";
case OPT_ES6_TYPED:    return "opt_es6_typed";
case IMPLEMENTS:       return "implements";
case ACCESS_MODIFIER: return "access_modifier";
case IS_ES6_CLASS: return "is_es6_class";
case TRANSPILED:   return "transpiled";if (n == null || !options.shouldDoExternsHoisting()) {
public boolean shouldDoExternsHoisting() {
return incrementalCheckMode != IncrementalCheckMode.GENERATE_IJS;n.putBooleanProp(Node.GOOG_MODULE, true);
new Es6RewriteModules(this).processFile(root, forceRewrite);
private boolean isEs6Module;
public void processFile(Node root, boolean forceRewrite) {
return;
isEs6Module = forceRewrite;
isEs6Module = true;
isEs6Module = true;
Node script = NodeUtil.getEnclosingScript(parent);
script.addChildAfter(require, googRequireInsertSpot);
if (!isEs6Module) {
return;
if (isGoogModuleFile(scriptNode)) {
assertThat(root.getFirstFirstChild().getFirstChild().getJSDocInfo()).isNotNull();
Node export = n.getFirstChild();return !found;Preconditions.checkArgument(root.isRoot());
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.ObjectType;
JSType type = node.getJSType();
return "/** @enum {" +
type.toMaybeEnumType().getElementsType().toAnnotationString() +
"} */\n";
&& !type.isEmptyType()
&& !type.isFunctionPrototypeType()) {
return "/** @type {" + node.getJSType().toAnnotationString() + "} */\n";
JSType type = fnNode.getJSType();
FunctionType funType = type.toMaybeFunctionType();
if (JSType.isEquivalent(
type, (JSType) registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) {
int i = 0;
for (Node n : funType.getParameters()) {
appendAnnotation(sb, "param", getParameterNodeJSDocType(n));
i++;
JSType retType = funType.getReturnType();
if (retType != null &&
!retType.isEmptyType() && // There is no annotation for the empty type.
!funType.isInterface() && // Interfaces never return a value.
!(funType.isConstructor() && retType.isVoidType())) {
FunctionType superConstructor = funType.getSuperClassConstructor();
if (superConstructor != null) {
ObjectType superInstance =
funType.getSuperClassConstructor().getInstanceType();
if (!superInstance.toString().equals("Object")) {
appendAnnotation(sb, "extends", superInstance.toAnnotationString());
if (funType.isInterface()) {
for (ObjectType interfaceType : funType.getExtendedInterfaces()) {
appendAnnotation(sb, "extends", interfaceType.toAnnotationString());
Set<String> interfaces = new TreeSet<>();
for (ObjectType interfaze : funType.getImplementedInterfaces()) {
interfaces.add(interfaze.toAnnotationString());
for (String interfaze : interfaces) {
sb.append(" * ");
appendAnnotation(sb, "implements", interfaze);
sb.append("\n");
if (funType.isConstructor()) {
if (!funType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {
Joiner.on(",").appendTo(sb, funType.getTemplateTypeMap().getTemplateKeys());
private String getParameterNodeJSDocType(Node parameterNode) {
JSType parameterType = parameterNode.getJSType();
String typeString;
if (parameterNode.isOptionalArg()) {
typeString = restrictByUndefined(parameterType).toNonNullAnnotationString() +
"=";
typeString = "..." +
restrictByUndefined(parameterType).toNonNullAnnotationString();
typeString = parameterType.toNonNullAnnotationString();
return typeString;
private JSType restrictByUndefined(JSType type) {
if (type.isUnionType()) {
return type.toMaybeUnionType().getRestrictedUnion(
(JSType) registry.getNativeType(JSTypeNative.VOID_TYPE));
return type;
boolean isEnumObject() {
return false;
EnumType e = null;
e = Iterables.getOnlyElement(t.getEnums());
break;
return e != null && this.equals(e.toJSType().getObjTypeIfSingletonObj());
return sb.append(forAnnotations ? "Object" : getReferenceName());
if (forAnnotations && isObject()
&& !isUnknownType() && !isTemplateType() && !isRecordType() && !isFunctionType()) {
assertPrettyPrintSame(
"var x = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;\n");
"/**\n * @constructor\n */\n"
+ "function Foo() {\n}\n");
Joiner.on("\n").join(
Joiner.on("\n").join(
"/** @typedef {Array<number>} */ goog.java.Long;\n"
+ "/** @param {!goog.java.Long} a*/\n"
+ "function f(a){};\n",
"goog.java.Long;\n"
+ "/**\n"
+ " * @param {(Array<number>|null)} a\n"
+ " * @return {undefined}\n"
+ " */\n"
+ "function f(a) {\n}\n");
assertTypeAnnotations("/** @constructor */ var Foo = function(){}",
"/**\n * @constructor\n */\n"
+ "var Foo = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){};"
+ "/** @constructor \n @extends {a.Foo} */ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @constructor\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @interface */ a.Foo = function(){};"
+ "/** @interface \n @extends {a.Foo} */ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @interface\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @interface */ a.Foo1 = function(){};"
+ "/** @interface */ a.Foo2 = function(){};"
+ "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
+ "a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo1 = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo2 = function() {\n};\n"
+ "/**\n * @extends {a.Foo1}\n"
+ " * @extends {a.Foo2}\n"
+ " * @interface\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){}"
+ "/** @param {string} foo\n"
+ "  * @return {number} */\n"
+ "a.Foo.prototype.foo = function(foo) { return 3; };"
+ "/** @type {string|undefined} */"
+ "a.Foo.prototype.bar = '';",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n"
+ " * @param {string} foo\n"
+ " * @return {number}\n"
+ " */\n"
+ "a.Foo.prototype.foo = function(foo) {\n  return 3;\n};\n"
+ "/** @type {string} */\n"
+ "a.Foo.prototype.bar = \"\";\n");
assertTypeAnnotations("/** @interface */ function I(){};"
+ "/** @return {undefined} @param {number} x */ I.prototype.method;",
"/**\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {\n"
+ "}\n"
+ "I.prototype.method;\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){};\n"
+ "/** @interface */ a.I = function(){};\n"
+ "/** @interface */ a.I2 = function(){};\n"
+ "/** @constructor \n @extends {a.Foo}\n"
+ " * @implements {a.I} \n @implements {a.I2}\n"
+ "*/ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.I = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.I2 = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @implements {a.I}\n"
+ " * @implements {a.I2}\n * @constructor\n */\n"
+ "a.Bar = function() {\n};\n");
"/** @type {!Function} */\n" +
"var x = function() {\n};\n");
"/** @type {!Function} */\n" +
"var x = function() {\n};\n");
"/**\n" +
" * @param {?} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"/**\n" +
" * @param {string=} x \n" +
" */\n" +
"var a = function(x) {}",
"/**\n" +
" * @param {string=} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"/**\n" +
" * @param {...string} x \n" +
" */\n" +
"var a = function(x) {}",
"/**\n" +
" * @param {...string} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"var x = function() {\n/**\n * @constructor\n */\nfunction t1() {}\n" +
" /**\n * @constructor\n */\nfunction t2() {}\n" +
" t1.prototype = t2.prototype}",
"/**\n * @return {undefined}\n */\nvar x = function() {\n" +
"  /**\n * @constructor\n */\n" +
"function t1() {\n  }\n" +
"  /**\n * @constructor\n */\n" +
"function t2() {\n  }\n" +
"  t1.prototype = t2.prototype;\n};\n"
);
"var goog = goog || {};" +
"/** @enum {string} */ goog.Enum = {FOO: 'x', BAR: 'y'};" +
"/** @const */ goog.Enum2 = goog.x ? {} : goog.Enum;",
"var goog = goog || {};\n" +
"/** @enum {string} */\ngoog.Enum = {FOO:\"x\", BAR:\"y\"};\n" +
"/** @type {(Object|{})} */\ngoog.Enum2 = goog.x ? {} : goog.Enum;\n");
"goog.removeHashCode = goog.removeUid;",
""));
String js = LINE_JOINER.join(
"/**",
" @type {number}",
" @deprecated See {@link replacementClass} for more details.",
" */",
"var x;",
"");
assertEquals(expected,
new CodePrinter.Builder(parse(js, true))
Node call =  n.getFirstFirstChild();
Node call =  n.getFirstFirstChild();
String result = defaultBuilder(parse("var x", true)).setTagAsStrict(true).build();
String result = defaultBuilder(parse("var x", true)).setTagAsExterns(true).build();
import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Token;
return parse(js, false);
Node parse(String js, boolean checkTypes) {
compiler.initOptions(options);
Node n = compiler.parseTestCode(js);
if (checkTypes) {
Node externs = new Node(Token.SCRIPT);
externs.setInputId(new InputId("externs"));
Node externAndJsRoot = new Node(Token.ROOT, externs, n);
typeResolver.process(externs, n);
inferTypes.process(externs, n);
return n;addSimplifiedExpression(pred, n);
protected void setUp() {
super.enableNormalize();
protected int getNumRepetitions() {
return 1;
protected CompilerPass getProcessor(Compiler compiler) {
return new MarkNoSideEffectCallsAndNameAnalyzerRunner(compiler);
private static class MarkNoSideEffectCallsAndNameAnalyzerRunner implements CompilerPass {
MarkNoSideEffectCalls markNoSideEffectCalls;
NameAnalyzer analyzer;
MarkNoSideEffectCallsAndNameAnalyzerRunner(Compiler compiler) {
this.markNoSideEffectCalls = new MarkNoSideEffectCalls(compiler);
this.analyzer = new NameAnalyzer(compiler, true, null);
public void process(Node externs, Node root) {
markNoSideEffectCalls.process(externs, root);
analyzer.process(externs, root);maybeRecordAlias(name, parent, referring, referringName);
maybeRecordAlias(name, parent, referring, referringName);
if (!maybeRecordAlias(name, parent, referring, referringName)) {
String name, Node parent,
parent.isAssign()
&& NodeUtil.isPrototypeProperty(parent.getFirstChild());
if ((parent.isName() || parent.isAssign()) && !isPrototypePropAssignment && referring != null
&& scopes.containsEntry(parent, referring)) {
test(
"var self_ = window['gbar'] || {};\n" +
"self_.qs = function() {};",
"");
test(
"var self_; self_ = window.gbar || {};\n" +
"self_.qs = function() {};",
"");
test(
"var self_ = window || {};\n" +
"self_['qs'] = function() {};",
"");
test(
"var self_; self_ = window || {};\n" +
"self_['qs'] = function() {};",
"");
test(
"function Foo() {}" +
"function Bar() {}" +
"var b = x ? Foo : Bar;" +
"var y = new Foo();" +
"if (y instanceof b) {}",
"function Foo() {}" +
"var y = new Foo;" +
"if (false){}");JSDocInfo jsdoc = parent.getJSDocInfo();
boolean isOverride = jsdoc != null
&& parent.isAssign()
&& parent.getFirstChild() == getprop;if (parentModuleCanSeeSymbolsDeclaredInChildren &&
parent.isInstanceOf() && parent.getLastChild() == n) {
instanceofNodes.put(parent, new InstanceofInfo(getModule(ref), info));
processRead(ref, info);
Node parent = n.getParent();
if (parent.isAnd() && parent.getLastChild() == n
&& parent.getFirstChild().isNE()) {
Node ne = parent.getFirstChild();
if (ne.getFirstChild().isString()
&& "undefined".equals(ne.getFirstChild().getString())
&& ne.getLastChild().isTypeOf()) {
Node ref = ne.getLastChild().getFirstChild();
if (ref.isEquivalentTo(n.getLastChild())) {
continue;
Node reference = n.getLastChild().cloneNode();t.reportCodeChange(parent);
if (parent.isExprResult()) {
parent.detach();
parent.removeChild(n);
varNode.removeChild(parent);
t.reportCodeChange(varNode);
if (!varNode.hasChildren()) {
varNode.detach();
t.reportCodeChange(exprResult);
exprResult.detach();"goog.provide('a.b');", "goog.provide('a.b.c');", "a.b = function(x,y) {};", "a.b.c;"),
"goog.provide('a.b');", "a.b = function(x,y) {};", "goog.provide('a.b.c');", "a.b.c;"),
"goog.provide('a.b');", "a.b = function(x,y) {};", "goog.provide('a.b.c');", "a.b.c;"),
"/** @const */", "goog.a={};", "if(x)", "  goog.a.b=1;", "else", "  goog.a.b=2;"));
"/** @const */", "goog.a={};", "if(x)", "  goog.a.b=1;", "else", "  goog.a.b=2;"));"Unexpected declaration format: " + declaration.toStringTree());
cannotConvertYet(n, "async function");
public void testAsyncFunction() {
setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
testError("f = async function() {};", CANNOT_CONVERT_YET);
testError("async function f() {};", CANNOT_CONVERT_YET);private boolean checkAstChangeMarking = false;
public void setUp() {
super.enableLineNumberCheck(false);
public void setUp() {
public void setUp() {
public void testRenamingConstantProperties() {
new WithCollapse().testConstantProperties();
private static class WithCollapse extends CompilerTestCase {
super.allowExternsChanges(true);
public void testRemoveUselessOps() {
public void setUp() throws Exception {
public void setUp() throws Exception {
public void setUp() throws Exception {
public void setUp() {
public void setUp() {
protected void setUp()  {
protected void setUp()  {
public void testFunctionStatements() {
new StringCompare().testFreeCallSemantics();void setScope(Node n) {
if (phaseOptimizer != null) {
phaseOptimizer.setScope(n);
void reportChangeToEnclosingScope(Node n) {
if (phaseOptimizer != null) {
phaseOptimizer.reportChangeToEnclosingScope(n);
phaseOptimizer.startCrossScopeReporting();
reportCodeChange();
phaseOptimizer.endCrossScopeReporting();
reportCodeChange();
void setPhaseOptimizer(PhaseOptimizer po) {
this.phaseOptimizer = po;
public void reportCodeChange() {
if (main.isFunction()) {
public static void verifyScopeChanges(Map<Node, Node> map, Node main,
boolean verifyUnchangedNodes) {
final boolean checkUnchanged = verifyUnchangedNodes;
if (n.isFunction() && mtoc.containsKey(n)) {
!isEquivalentToExcludingFunctions(n, clone));
isEquivalentToExcludingFunctions(n, clone));
if (!thisNode.isEquivalentToShallow(thatNode)) {
private Node currentScope;
private int timestamp;
private boolean crossScopeReporting;
this.crossScopeReporting = false;
this.timestamp = this.lastChange = START_TIME;
String hashCodeMsg = "AST hashCode after " + passName + ": " +
compiler.toSource(root).hashCode();
private void maybeSanityCheck(Node externs, Node root) {
NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);
maybeSanityCheck(externs, root);
void setScope(Node n) {
if (inLoop) {
currentScope = n.isFunction() ? n : getEnclosingScope(n);
private Node getEnclosingScope(Node n) {
while (n.getParent() != null) {
n = n.getParent();
if (n.isFunction() || n.isScript()) {
return n;
return n;
void reportChangeToEnclosingScope(Node n) {
lastChange = timestamp;
getEnclosingScope(n).setChangeTime(timestamp);
timestamp++;
void startCrossScopeReporting() {
crossScopeReporting = true;
void endCrossScopeReporting() {
crossScopeReporting = false;
this.lastCodeChangeQuery = timestamp;
if (crossScopeReporting) {
return;
lastChange = timestamp;
currentScope.setChangeTime(timestamp);
timestamp++;
lastCodeChangeQuery = timestamp;
timestamp++;
setScope(root);
timestamp++;
lastRuns.put(pass, timestamp);
public final boolean isEquivalentToShallow(Node node) {
return isEquivalentTo(node, false, false, false, false);
Map<Node, Node> mtoc = NodeUtil.mapMainToClone(mainRoot, mainRootClone);
NodeUtil.verifyScopeChanges(mtoc, mainRoot, false);import com.google.common.base.Preconditions;
Preconditions.checkState(n.hasOneChild(), n);
checkState(child.parent == this);
String code =
"function f() {var x = {}; x.FOO = 5; x.bar = 3;}";
test(options, code,
"function f(){" +
"var JSCompiler_object_inline_FOO_0;" +
"var JSCompiler_object_inline_bar_1;" +
"JSCompiler_object_inline_FOO_0=5;" +
"JSCompiler_object_inline_bar_1=3}");if (!assumeMinimumCapture && hasLocalNames(fnNode) && !NodeUtil.isIIFE(fnNode)) {
static boolean isIIFE(Node n) {
Node parent = n.getParent();
return n.isFunction()
&& parent.isCall()
&& parent.getFirstChild() == n
&& parent.getParent().isExprResult();
test(
LINE_JOINER.join(
"var a=3;",
"function foo(){return a}",
"(function(){var a=5;(function(){foo()})()})()"),
"var a=3;{var a$jscomp$inline_1=5;{a}}");
test(
LINE_JOINER.join(
"var a=3;",
"function foo(){return a}",
"(function(){var a=5;(function(){foo()})()})()"),
"var a=3;{var a$jscomp$inline_1=5;{a}}");
test(
LINE_JOINER.join(
"var a=3;",
"function foo(){return a}",
"(function(){var a=5;(function(){foo()})()})()"),
"var a=3;{var a$jscomp$inline_1=5;{a}}");
test(
LINE_JOINER.join(
"var a=3;",
"function foo(){return a}",
"(function(){var a=5;(function(){foo()})()})()"),
"var a=3;{var a$jscomp$inline_1=5;{a}}");
test(
"(function(){var f = function(a){call(function(){return a})};f()})()",
LINE_JOINER.join(
"{",
"  var f$jscomp$inline_0=function(a$jscomp$inline_1){",
"    call(function(){return a$jscomp$inline_1})",
"  };",
"  f$jscomp$inline_0()",
"}"));
"{",
"  var $$jscomp$inline_0 = jQuery;",
"  $$jscomp$inline_0.fn.multicheck = function(options$jscomp$inline_4) {",
"      options$jscomp$inline_4.checkboxes =",
"          $$jscomp$inline_0(this).siblings(':checkbox');",
"      { $$jscomp$inline_0(this).data('checkboxes'); }",
"}"));
test(
"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();",
LINE_JOINER.join(
"{",
"  var a$jscomp$inline_2=10;",
"  {",
"    var b$jscomp$inline_0=a$jscomp$inline_2;",
"    a$jscomp$inline_2++;",
"    alert(b$jscomp$inline_0)",
"  }",
"}"));
test(
"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();",
LINE_JOINER.join(
"{",
"  var a$jscomp$inline_2=10;",
"  {",
"    var b$jscomp$inline_0=a$jscomp$inline_2;",
"    a$jscomp$inline_2++;",
"    alert(b$jscomp$inline_0)",
"  }",
"}"));
test(
"(function(){var a=10;(function(){arguments;})()})();",
"{var a$jscomp$inline_0=10;(function(){arguments})()}");
LINE_JOINER.join(
"/** @constructor */ function F() {}",
"var x = new F();",
"/** @this {F} */",
"function g(y) { y.bar = function() { alert(3); }; }",
"g(x);",
"x.bar();");
"var x = new function() {};x.bar = function(){ alert(3); };x.bar();";
CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
options.setRenamingPolicy(VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);import com.google.common.base.Preconditions;
class Denormalize implements CompilerPass, Callback {
Preconditions.checkState(n.hasOneChild(), n);
checkState(child.parent == this);
NodeTraversal.traverseEs6(compiler, root, denormalizePass);
test(options, code,
"function f(){" +
"var JSCompiler_object_inline_FOO_0;" +
"var JSCompiler_object_inline_bar_1;" +
"JSCompiler_object_inline_FOO_0=5;" +
"JSCompiler_object_inline_bar_1=3}");
test(options, code, "function f() { var x; 3; 4; x = 5; return x; } f();");
String result = LINE_JOINER.join(
"function some_function() {",
"  var a, b;",
"  any_expression && (b = external_ref, a = function(a) {",
"    return b()",
"  });",
"  return {",
"    method1: function() {",
"      a && a();",
"      return !0",
"    },",
"    method2: function() {",
"      return !1",
"    }",
"  };",
"}");import com.google.javascript.rhino.Token;
if (namedImports.getToken() == Token.IMPORT_SPECS) {
child.getToken() == Token.IMPORT_STAR,
"Expected an IMPORT_STAR node, but was: %s",
child);
Node importNode = new Node(Token.IMPORT, moduleIdentifier.cloneNode());
propdef.isStringKey() || propdef.isMemberFunctionDef() ||
propdef.isGetterDef() || propdef.isSetterDef());
return start == 0 && !name.isEmpty() &&
name.length() == endIndex && qname.startsWith(name);if (nodeToReplace != null) {
public void testShortRequireInGoogModule() {GlobalNamespace namespace = new GlobalNamespace(compiler, root);
inlineAliases(namespace);
compiler.reportCodeChange();
compiler.reportCodeChange();
new PassFactory("aggressiveInlineAliases", false) {
+ "var y = $jscomp.scope.Foo.staticprop.A");
+ "var y = $jscomp.scope.Foo.staticprop.A");
"var y = $jscomp$scope$Foo$staticprop$A;"));
"var y = $jscomp$scope$Foo$staticprop$A;"));pushOverloads();
return true;
case SCRIPT:
case INTERFACE:
case CLASS:
pushOverloads();
popOverloads();
popOverloads();
popOverloads();
popOverloads();
Token.NAMESPACE_ELEMENTS);Matcher fullNameMatcher = FULLY_QUALIFIED_NAME.matcher(error.description);
Preconditions.checkState(fullNameMatcher.matches(), error.description);
String namespace = fullNameMatcher.group(1);
shortName = namespace.substring(namespace.lastIndexOf('.') + 1);
fix.addLhsToGoogRequire(match, namespace);
return fix.replace(error.node, NodeUtil.newQName(compiler, shortName), compiler).build();int numOfStmsInBody = body.getChildCount();
"function foo() {} ",
"if (x) return;",
"foo(); ",
"function bar() {} ",
"function foo() {}",
"function bar() {}",
"if (x) return;",
"foo();",public void testUsePseduoNames() {TypeI methodClassType = registry.getType(prop.type);
if (methodClassType != null && lhs.getTypeI() != null) {
TypeI targetType = lhs.getTypeI().restrictByNotNullOrUndefined();
if (targetType.isSomeUnknownType()
|| targetType.isTypeVariable()
|| targetType.isBottom()
|| targetType.isTop()
|| targetType.isEquivalentTo(
registry.getNativeType(JSTypeNative.OBJECT_TYPE))) {
if (matchesPrototype(methodClassType, targetType)) {if (!n.isName() || n.getString().isEmpty()) {
return false;
Node parent = n.getParent();
return isFunctionExpression(parent) && n == parent.getFirstChild();
private void renameBleedingFunctionName(Node fnName) {
MakeDeclaredNamesUnique.Renamer renamer =
new MakeDeclaredNamesUnique.WhitelistedRenamer(
new MakeDeclaredNamesUnique.ContextualRenamer(),
ImmutableSet.of(fnName.getString()));
renamer.addDeclaredName(fnName.getString(), false);
MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer);
NodeTraversal.traverseEs6(compiler, fnName.getParent().getParent(), uniquifier);
if (NodeUtil.isBleedingFunctionName(n)) {
renameBleedingFunctionName(n);
if (aliasVar != null) {
aliasUsages.add(new AliasedNode(aliasVar, n));
JSDocInfo info = n.getJSDocInfo();
if (info != null && !injectedDecls.contains(n)) {
for (Node node : info.getTypeNodes()) {
fixTypeNode(node);
public void testIssue2210() {
test(
LINE_JOINER.join(
"var ns = {};",
"var y = 1;",
"goog.scope(function () {",
"  ns.fact = function y(n) {",
"    return n == 1 ? 1 : n * y(n - 1);",
"  };",
"});"),
LINE_JOINER.join(
"var ns = {};",
"var y = 1;",
"ns.fact = function y$jscomp$1(n) {",
"  return n == 1 ? 1 : n * y$jscomp$1(n - 1);",
"};"));
public void testIssue2210b() {
test(
LINE_JOINER.join(
"var ns = {};",
"var y = 1;",
"goog.scope(function () {",
"  function x(y) {}",
"  ns.fact = function y(n) {",
"    return n == 1 ? 1 : n * y(n - 1);",
"  };",
"});"),
LINE_JOINER.join(
SCOPE_NAMESPACE,
"var ns = {};",
"var y = 1;",
"$jscomp.scope.x = function (y) {};",
"ns.fact = function y$jscomp$1(n) {",
"  return n == 1 ? 1 : n * y$jscomp$1(n - 1);",
"};"));
public void testObjectPattern() {
testScopedNoChanges("", "{foo: ({bar}) => baz};", LanguageMode.ECMASCRIPT6);"Index out of bounds in templateTypeOf: {0} > {1}");
if (index > templateTypes.size()) {
"Index out of bounds in templateTypeOf: 2 > 1");if (!target.getParent().isScript() && !target.getParent().isBlock()) {
if (body.isBlock()) {
&& destination.isBlock()
if (destination.isBlock()) {
if (child.isBlock()) {
if (n.isExprResult() || n.isBlock()) {
Preconditions.checkState(block.isBlock());
first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
if (!last.isBlock()) {
if (last.isBlock()) {
if (!allowNonBlockChild && !n.isBlock()) {
if (n.isBlock()) {
if (!labeledStatement.isBlock()) {
Preconditions.checkState(caseBody.isBlock());
if (c.isBlock()) {
if (c.isBlock()) {
Preconditions.checkState(n.isBlock(), n);
if (!(parent.isScript() ||
grandparent != null &&
grandparent.isFunction() &&
parent.isBlock())) {
for (; !currentParent.isScript() &&
!currentParent.isBlock();
current = currentParent,
currentParent = currentParent.getParent()) {}
if (node.isFunction() && !NodeUtil.getFunctionBody(node).isBlock()) {
if (n.isBlock()) {
Preconditions.checkArgument(blockNode.isBlock());
checkState(body.isBlock(), body);
if (!n.isFunction() || !n.getLastChild().isBlock()) {
if (!body.isBlock()) {
if (guard.isBlock()) {
body.addChildToBack(incr.isBlock() ? incr : IR.exprResult(incr));
if (maybeAssign.isBlock() || maybeAssign.isScript() ||
NodeUtil.isStatement(maybeAssign)) {
if (!n.isScript() && !n.isBlock()) {
Preconditions.checkArgument(node.isBlock());
return  expectedBlock.isBlock() ?
expectedBlock : null;
&& node.getParent().getParent().isBlock()
&& isClinitMethod(node.getParent().getParent().getParent());
if (!getFunction.hasChildren() || !getFunction.getLastChild().isBlock()) {
|| !setFunction.getLastChild().isBlock()
if (!n.isBlock() || !n.hasChildren()) {
if (srcBlock.isBlock()) {
if (parent.isScript()
|| (parent.isBlock() && parent.getParent().isFunction())) {
Preconditions.checkState(block.isBlock());
return n.isBlock() && n.getParent() != null && n.getParent().isFunction();
Preconditions.checkState(addingRoot.isBlock() || addingRoot.isModuleBody()
|| addingRoot.isScript());
return n.isBlock()
|| (!n.isFunction() && (parent == null
|| isControlStructure(parent)
|| isStatementBlock(parent)));
Preconditions.checkArgument(n.isBlock());
Preconditions.checkArgument(block.isBlock(),
"Node must be a block.");
if (!subtree.isScript() && !subtree.isBlock()) {
if (n.isBlock()) {
if (n.isBlock()) {
if (n.isBlock()) {
if (n.isBlock()) {
Preconditions.checkState(block.isBlock());
return (n.isBlock() && n.isSyntheticBlock()) || n.isScript();
if (body.isBlock() && !body.hasChildren()) {
if (NodeUtil.isControlStructureCodeBlock(n, c) && !c.isBlock()) {
if (umdPattern.activeBranch.isBlock() && umdPattern.activeBranch.getChildCount() == 1) {
Preconditions.checkState(body.getNext() == null && body.isBlock(), body);
if (newChild.isBlock()) {
if (!originalBody.isBlock()) {
while (!n.getParent().isScript() && !n.getParent().isBlock()) {
if (isGoogScopeFunctionBody(enclosingFunctionBody) && scopeRoot.isBlock()
boolean isVar = NodeUtil.isNameDeclaration(parent) && parent.getParent().isBlock();
if (s.isFunctionScope() && s.getRootNode().getLastChild().isBlock()) {
if (!favorsCommaOverSemiColon && !block.isBlock()) {
if (!body.isBlock() || !body.hasOneChild() || !body.getFirstChild().isReturn()) {
if (parent != null
&& (parent.isBlock()
|| parent.isScript())) {
while (next != null && next.isBlock()) {
if (n.isEmpty() || (n.isBlock() && !n.hasChildren())) {|| statement.isBlock()
return n.isBlock() && n.hasChildren() && isReturnTypeNullable(n.getParent())
Preconditions.checkState(n.getFirstChild().isBlock(), n);
assertTrue(mainFunction.getBodyNode().isBlock());
assertTrue(mainFunction.getAstNode().isBlock());
assertTrue(functionA.getBodyNode().isBlock());return parseReader(filePath, closureRelativePath,
new StringReader(fileContents));public void testMultipleIndenticalImportantComments() throws Exception {
public void testMultipleIndenticalLicenses() throws Exception {
SourceFile.fromCode("testcode2", js2));
public void testIndenticalLicenseAndImportantComent() throws Exception {if (options.chromePass) {
checks.add(chromePass);NewTypeInference.INVALID_INDEX_TYPE,
|| allowPropertyOnSubtypes && recvType.mayContainUnknownObject()) {
case "Object":
return maybeMakeNullable(n.hasChildren()
? this.commonTypes.getTopDict() : this.commonTypes.getTopObject());
Preconditions.checkState(n.getFirstChild().isBlock(), n);
typeList.add(
getTypeFromCommentHelper(child, registry, outerTypeParameters));
ImmutableList<JSType> typeArguments = typeList.build();
ImmutableList<String> typeParameters = rawType.getTypeParameters();
return maybeMakeNullable(JSType.fromObjectType(ObjectType.fromNominalType(
uninstantiated.instantiateGenerics(
fixLengthOfTypeList(typeParameters.size(), typeArguments)))));
private List<JSType> fixLengthOfTypeList(
int desiredLength, List<JSType> typeList) {
if (!keyType.isNumber() && !keyType.isString()) {
if (!ptype.isSubtypeOf(valueType, subSuperMap)) {
private Node parseTypeExpressionList(JsDocToken token) {
Node memberType = parseTypeExpressionList(next());
.transpilesTo("var s: Object<number>;");
public void testIObjectAccesses() {recordInvalidatingType(mis.typeA, mis.src);
recordInvalidatingType(mis.typeB, mis.src);
recordInvalidatingType(mis.typeA, mis.src);
recordInvalidatingType(mis.typeB, mis.src);
private void recordInvalidationError(JSType t, JSError error) {
private void recordInvalidatingType(JSType type, JSError error) {
recordInvalidatingType(alt, error);
type.toMaybeEnumElementType().getPrimitiveType(), error);
recordInvalidationError(type, error);
recordInvalidationError(objType.getImplicitPrototype(), error);
private int numImplicitUses = 0;
String msg;
if (numImplicitUses < 10) {
msg = "Implicit use of type " + sourceType + " as " + targetType;
msg = "";
numImplicitUses++;
JSError err = JSError.make(src, TYPE_MISMATCH_WARNING, msg);SourceFile getSourceFileByName(String sourceName) {
lastIndex = replacement.getStartPosition() + replacement.getLength();
start = Math.max(start, replacement.getStartPosition() + replacement.getLength());NewTypeInference.INVALID_INDEX_TYPE,
|| allowPropertyOnSubtypes && recvType.mayContainUnknownObject()) {
case "Object":
return maybeMakeNullable(n.hasChildren()
? this.commonTypes.getTopDict() : this.commonTypes.getTopObject());
Preconditions.checkState(n.getFirstChild().isBlock(), n);
typeList.add(
getTypeFromCommentHelper(child, registry, outerTypeParameters));
ImmutableList<JSType> typeArguments = typeList.build();
ImmutableList<String> typeParameters = rawType.getTypeParameters();
return maybeMakeNullable(JSType.fromObjectType(ObjectType.fromNominalType(
uninstantiated.instantiateGenerics(
fixLengthOfTypeList(typeParameters.size(), typeArguments)))));
private List<JSType> fixLengthOfTypeList(
int desiredLength, List<JSType> typeList) {
if (!keyType.isNumber() && !keyType.isString()) {
private Node parseTypeExpressionList(JsDocToken token) {
Node memberType = parseTypeExpressionList(next());
.transpilesTo("var s: Object<number>;");
public void testIObjectAccesses() {builder.addOptFormal(JSType.join(
this.commonTypes.getArrayInstance(), this.commonTypes.getArgumentsArrayType()));private static final Pattern MSG_EXTERNAL_PATTERN =
Pattern.compile("MSG_EXTERNAL_(\\d+)");
Pattern.compile("MSG_UNNAMED_\\d+");
extractMessagesSafely("var MSG_UNNAMED_2 = goog.getMsg('Hullo');");
public void testMessageIsNoUnnamed() {
extractMessagesSafely("var MSG_UNNAMED_ITEM = goog.getMsg('Hullo');");
assertThat(messages).hasSize(1);
JsMessage msg = messages.get(0);
assertEquals("MSG_UNNAMED_ITEM", msg.getKey());
assertFalse(msg.isHidden());public Renamer forChildScope(boolean hoistintTargetScope) {
return new ContextualRenamer(nameUsage, hoistintTargetScope, this);if (returnTypeInferred) {
hashCode += 1;
if (paramType != null) {
hashCode += paramType.hashCode();
if (isConstructor()) {
if (that.isConstructor()) {
return this == that;
if (isInterface()) {
if (that.isInterface()) {
return false;
if (that.isInterface()) {
return false;
return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod, eqCache) &&
call.checkArrowEquivalenceHelper(that.call, eqMethod, eqCache);
return isInterface() ? getReferenceName().hashCode() : call.hashCode();private static final ImmutableList<String> COVARIANT_TYPES =
ImmutableList.of("Object", "IArrayLike", "Array");
for (JSType alt : unionType.getAlternates()) {
ImmutableList<JSType> alternatesList = unionType.getAlternatesList();FunctionTypeI functionType = n.getFirstChild()
.getTypeI()
.toMaybeFunctionType();options.setLanguageIn(LanguageMode.ECMASCRIPT6);
options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE, CheckLevel.ERROR);Matcher m = USE_SHORT_NAME.matcher(error.description);
if (m.matches()) {
return new SuggestedFix.Builder()
.attachMatchedNodeInfo(error.node, compiler)
.replace(error.node, NodeUtil.newQName(compiler, m.group(1)), compiler)
.build();
return null;if (excerpt.equals(LINE)
&& 0 <= charno && charno <= sourceExcerpt.length()) {
b.append("^\n");
"        ^\n", formatter.formatError(error));
"\t\t    ^\n", formatter.formatError(error));
"               ^\n",import com.google.common.annotations.VisibleForTesting;
private Map<FunctionType, Iterable<ObjectType>> implementedInterfaces;
this.implementedInterfaces = new HashMap<>();
ObjectType getTypeWithProperty(String field, JSType type) {
private void recordInterfaces(FunctionType constructor, JSType relatedType,
DisambiguateProperties.Property p) {
Preconditions.checkArgument(constructor.isConstructor());
Iterable<ObjectType> interfaces = implementedInterfaces.get(constructor);
interfaces = constructor.getImplementedInterfaces();
implementedInterfaces.put(constructor, interfaces);
return constructor != null && constructor.isConstructor()
? constructor : null;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.testing.TestErrorReporter;
public void runFindHighestTypeInChain() {
new DisambiguateProperties(new Compiler(), new HashMap<String, CheckLevel>())
.getTypeWithProperty("no",
new JSTypeRegistry(new TestErrorReporter(null, null))
.getNativeType(JSTypeNative.OBJECT_PROTOTYPE));class CheckRequiresForConstructors implements HotSwapCompilerPass, NodeTraversal.Callback {
public static enum Mode {
static final DiagnosticType EXTRA_REQUIRE_WARNING = DiagnosticType.disabled(
visitRequire(stringKey.getFirstChild().getString(), call);
visitRequire(stringKey.getString(), call);
static final DiagnosticType REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME =
static final DiagnosticType JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME =
DiagnosticType.disabled(
"JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME",
"Reference to fully qualified import name ''{0}'' in JSDoc."
+ " Please use the short name ''{1}'' instead.");
private static final Pattern EXTRA_REQUIRE =
Pattern.compile("extra require: '([^']+)'");
Matcher regexMatcher = EXTRA_REQUIRE.matcher(error.description);
Preconditions.checkState(regexMatcher.matches(),
"Unexpected error description: %s", error.description);
String namespace = regexMatcher.group(1);
NodeMetadata metadata = new NodeMetadata(compiler);
Match match = new Match(error.node, metadata);
return new SuggestedFix.Builder()
.attachMatchedNodeInfo(error.node, compiler)
.removeGoogRequire(match, namespace)
.build();
fixes.addAll(getFixesForJsError(error));
fixes.addAll(getFixesForJsError(warning));import com.google.common.collect.ImmutableSet;
import java.util.List;
private static final ImmutableSet<String> COVARIANT_TYPES =
ImmutableSet.of("Object", "IArrayLike", "Array");
List<JSType> alternates = this.toMaybeUnionType().getAlternates();
for (int i = 0; i < alternates.size(); i++) {
JSType alternate = alternates.get(i);
List<JSType> alternates = unionType.getAlternates();
for (int i = 0; i < alternates.size(); i++) {
JSType alt = alternates.get(i);
List<JSType> alternates = union.alternatesWithoutStucturalTyping;
for (int i = 0; i < alternates.size(); i++) {
if (thisType.isSubtype(alternates.get(i), implicitImplCache, subtypingMode)) {
List<JSType> alternatesWithoutStucturalTyping;
List<JSType> alternates;
UnionType(JSTypeRegistry registry, List<JSType> alternatesWithoutStructuralTyping) {
public List<JSType> getAlternates() {
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
public List<JSType> getAlternatesWithoutStructuralTyping() {
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
List<JSType> alternates = getAlternates();
for (int i = 0; i < alternates.size(); i++) {
JSType typ = alternates.get(i);
List<JSType> alternates = getAlternates();
for (int i = 0; i < alternates.size(); i++) {
JSType typ = alternates.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
List<JSType> thoseAlternatesWithoutStucturalTyping =
that.toMaybeUnionType().alternatesWithoutStucturalTyping;
for (int i = 0; i < thoseAlternatesWithoutStucturalTyping.size(); i++) {
JSType otherAlternate = thoseAlternatesWithoutStucturalTyping.get(i);
List<JSType> thatAlternates = that.getAlternatesWithoutStructuralTyping();
for (int i = 0; i < thatAlternates.size(); i++) {
JSType thatAlternate = thatAlternates.get(i);
if (!hasAlternate(thatAlternate, eqMethod, eqCache)) {
List<JSType> alternatesWithoutStructuralTyping = getAlternatesWithoutStructuralTyping();
for (int i = 0; i < alternatesWithoutStructuralTyping.size(); i++) {
JSType alternate = alternatesWithoutStructuralTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alt = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType t = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType element = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType a = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType a = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
for (int i = 0; i < alternatesWithoutStucturalTyping.size(); i++) {
JSType alternate = alternatesWithoutStucturalTyping.get(i);
List<JSType> getAlternates() {
List<JSType> alternatesWithoutStructuralTyping =
union.getAlternatesWithoutStructuralTyping();
for (int i = 0; i < alternatesWithoutStructuralTyping.size(); i++) {
JSType unionAlt = alternatesWithoutStructuralTyping.get(i);options.setLanguageOut(LanguageMode.ECMASCRIPT5_STRICT);
assertThat(result.source).isEqualTo("'use strict';var x = function() {\n  return 42;\n};\n");
assertThat(result.source).isEqualTo("'use strict';var x = 42;\n");GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR,
static final DiagnosticType STRUCTDICT_WITHOUT_CTOR = DiagnosticType.warning(
"JSC_NTI_STRUCTDICT_WITHOUT_CTOR",
"{0} used without @constructor.");
STRUCTDICT_WITHOUT_CTOR,
if (fnDoc.usesImplicitMatch()) {
commonTypes, defSite, qname, typeParameters);
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeStructClass(
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeDictClass(
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeUnrestrictedClass(
commonTypes, defSite, qname, typeParameters);
warnings.add(JSError.make(defSite, STRUCTDICT_WITHOUT_CTOR, "@struct"));
warnings.add(JSError.make(defSite, STRUCTDICT_WITHOUT_CTOR, "@dict"));
class ObjectKind {
static final ObjectKind UNRESTRICTED = new ObjectKind(UNRESTRICTED_MASK);
static final ObjectKind STRUCT = new ObjectKind(STRUCT_MASK);
static final ObjectKind DICT = new ObjectKind(DICT_MASK);
public static RawNominalType makeUnrestrictedClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.UNRESTRICTED);
public static RawNominalType makeStructClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.STRUCT);
public static RawNominalType makeDictClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.DICT);
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.INTERFACE, ObjectKind.UNRESTRICTED);
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.RECORD, ObjectKind.UNRESTRICTED);
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);if (obj1.isTopObject() || obj2.isTopObject()) {setModuleType(ModuleType.WRAPPED_GOOG_MODULE);
true);
true);IR.getprop(superClass.cloneTree(), IR.string("apply")),
Node nullNode = superCall.getSecondChild();
checkState(nullNode.isNull(), nullNode);
Node thisNode = IR.thisNode().useSourceInfoFrom(nullNode);
superCall.replaceChild(nullNode, thisNode);
NominalType superClass = Preconditions.checkNotNull(thisClass.getInstantiatedSuperclass());
NominalType superClass = Preconditions.checkNotNull(thisClass.getInstantiatedSuperclass());
typeCheck("class Foo extends Foo {}",
JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE);switch (options.getLanguageIn()) {
case ECMASCRIPT3:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT3, Config.StrictMode.SLOPPY);
externsParserConfig =
createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.SLOPPY);
break;
case ECMASCRIPT5:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.SLOPPY);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT5_STRICT:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT6, Config.StrictMode.SLOPPY);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6_STRICT:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT6, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6_TYPED:
parserConfig =
createConfig(Config.LanguageMode.TYPESCRIPT, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT7:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT7, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT8:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT8, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
default:
throw new IllegalStateException("unexpected language mode: "
+ options.getLanguageIn());googRequireNode = IR.var(IR.name(shortName), googRequireNode);
"var Xray = goog.require('goog.Xray');",
"var Anteater = goog.require('goog.Anteater');",
"var DomHelper = goog.require('goog.dom.DomHelper');",
"var Anteater = goog.require('goog.Anteater');",
"var Xray = goog.require('goog.Xray');",
"var DomHelper = goog.require('goog.dom.DomHelper');",
"var Anteater = goog.require('goog.Anteater');",
"var Xray = goog.require('goog.rays.Xray');",
"var Anteater = goog.require('goog.Anteater');",
"var DomHelper = goog.require('goog.dom.DomHelper');",
"var C = goog.require('a.b.C');",
"var C = goog.require('a.b.C');",
"var b = goog.require('a.b');",
"var Animal = goog.require('world.util.Animal');",
"var Animal = goog.require('world.util.Animal');",
"var Animal = goog.require('world.util.Animal');",
"var A = goog.require('a.A');",
"var C = goog.require('c.C');",
"var A = goog.require('a.A');",
"var B = goog.require('x.B');",
"var C = goog.require('c.C');",
public void testMissingRequireInGoogModule_alwaysInsertsVar() {
"const A = goog.require('a.A');",
"const C = goog.require('c.C');",
"const A = goog.require('a.A');",
"var B = goog.require('x.B');",
"const C = goog.require('c.C');",if (parent.isCall()) {import static com.google.common.collect.ObjectArrays.concat;
import com.google.javascript.refactoring.ErrorToFixMapper;
import com.google.javascript.refactoring.SuggestedFix;
options.setWarningLevel(DiagnosticGroups.STRICT_MISSING_REQUIRE, CheckLevel.WARNING);
options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE, CheckLevel.WARNING);
List<SuggestedFix> fixes = new ArrayList<>();
for (JSError warning : concat(compiler.getErrors(), compiler.getWarnings(), JSError.class)) {
SuggestedFix suggestedFix = ErrorToFixMapper.getFixForJsError(warning, compiler);
if (suggestedFix != null) {
fixes.add(suggestedFix);
ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
import com.google.common.collect.ImmutableSetMultimap;
ImmutableSetMultimap.Builder<String, CodeReplacement> builder = ImmutableSetMultimap.builder();
builder.putAll(fix.getReplacements());
SetMultimap<String, CodeReplacement> replacementsMap = builder.build();
for (Map.Entry<String, Set<CodeReplacement>> entry
: Multimaps.asMap(replacementsMap).entrySet()) {
throw new IllegalArgumentException(
"Found overlap between code replacements!\n" + Joiner.on("\n\n").join(replacements));
import com.google.common.annotations.VisibleForTesting;
return fixes.values();
options.setWarningLevel(DiagnosticGroups.LINT_CHECKS, ERROR);if (options.skipNonTranspilationPasses) {
return checks;
assertAllOneTimePasses(checks);
assertValidOrder(checks);
return checks;
if (NodeUtil.getNameNode(clazz) == null) {
return;
if (methodName.equals("constructor")) {
baseMethodName = baseClass + ".call";
baseMethodName = Joiner.on('.').join(baseClass, "prototype", methodName, "call");
"testcode$classdecl$var0.prototype.f = function() {super.g(); };",
"  D.call.apply(D, [].concat([this], $jscomp.arrayFromIterable(args)));",
compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT6);
compiler.getOptions().setLanguageOut(LanguageMode.ECMASCRIPT5);
compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT6);
compiler.getOptions().setLanguageOut(LanguageMode.ECMASCRIPT5);checks.add(markTranspilationDone);
if (options.skipNonTranspilationPasses) {
return checks;
assertAllOneTimePasses(checks);
assertValidOrder(checks);
return checks;
if (NodeUtil.getNameNode(clazz) == null) {
return;
if (methodName.equals("constructor")) {
baseMethodName = baseClass + ".call";
baseMethodName = Joiner.on('.').join(baseClass, "prototype", methodName, "call");
"testcode$classdecl$var0.prototype.f = function() {super.g(); };",
"  D.call.apply(D, [].concat([this], $jscomp.arrayFromIterable(args)));",
compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT6);
compiler.getOptions().setLanguageOut(LanguageMode.ECMASCRIPT5);
compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT6);
compiler.getOptions().setLanguageOut(LanguageMode.ECMASCRIPT5);assertAllOneTimePasses(passes);
new PassFactory("aggressiveInlineAliases", true) {Pattern argPattern = Pattern.compile("(--?[a-zA-Z_]+)=(.*)");Preconditions.checkState(NodeUtil.isNameDeclaration(parent), parent);return n.isVar() || n.isLet() || n.isConst();
private final Function<Node, String> getNamespace =
Preconditions.checkState(n.isCall(), n);
return n.getLastChild().getString();
private final Ordering<Node> alphabetical = Ordering.natural().onResultOf(getNamespace);
if (!containsShorthandRequire) {
reportIfOutOfOrder(requires, REQUIRES_NOT_SORTED);
requires.clear();
provides.clear();
containsShorthandRequire = false;
requires.add(n);
provides.add(n);
private static String getNamespaceFromClosureNode(Node exprResult) {
Preconditions.checkState(exprResult.isExprResult());
return exprResult.getFirstChild().getLastChild().getString();
String namespace1 = getNamespaceFromClosureNode(n1);
String namespace2 = getNamespaceFromClosureNode(n2);
Node googRequireNode = IR.exprResult(IR.call(
IR.getprop(IR.name("goog"), IR.string("require")),
IR.string(namespace)));
if (child.isExprResult() && child.getFirstChild().isCall()) {
Node grandchild = child.getFirstChild();
if (Matchers.googRequire().matches(child.getFirstChild(), metadata)
&& grandchild.getLastChild().isString()
&& namespace.equals(grandchild.getLastChild().getString())) {
return child;
if (child.isExprResult() && child.getFirstChild().isCall()) {
public void testGoogModuleWithShorthand() {
testSame(
"var d = goog.require('a.b.d');",
testSame(
"alert(1);"));
public void testGoogModuleNoShorthand() {
public void testSortRequiresInGoogModule() {
"alert(1);"),
"alert(1);"));
"goog.require('a.b.C');",public boolean apply(Node n) {
import junit.framework.TestCase;
assertPasses("x", "y", "x", "y", "x", "x", "y");
assertPasses("a", "x", "y", "x", "y", "x", "x", "y", "z");
assertPasses("a", "b", "c", "d", "b", "c", "d", "c", "b", "d", "e", "f");import java.util.Collection;lateLintChecks,
checkVariableReferences);
private final PassFactory checkVariableReferences =
new PassFactory("checkVariableReferences", true) {
protected CompilerPass create(AbstractCompiler compiler) {
return new VariableReferenceCheck(compiler);
options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.WARNING);
import com.google.javascript.rhino.IR;
case "JSC_REDECLARED_VARIABLE":
return getFixForRedeclaration(error, compiler);
private static SuggestedFix getFixForRedeclaration(JSError error, AbstractCompiler compiler) {
Node name = error.node;
Preconditions.checkState(name.isName(), name);
Node parent = name.getParent();
Preconditions.checkState(NodeUtil.isNameDeclaration(parent), parent);
SuggestedFix.Builder fix = new SuggestedFix.Builder().attachMatchedNodeInfo(name, compiler);
if (!name.hasChildren()) {
Node nodeToDelete = parent.hasOneChild() ? parent : error.node;
return fix.delete(nodeToDelete).build();
Node assign = IR.exprResult(
IR.assign(name.cloneNode(), name.getFirstChild().cloneTree()));
if (parent.hasOneChild()) {
return fix.replace(parent, assign, compiler).build();
List<Node> childrenOfAddedVarStatement = new ArrayList<>();
for (Node n : parent.children()) {
if (n == name) {
break;
childrenOfAddedVarStatement.add(n);
if (!childrenOfAddedVarStatement.isEmpty()) {
Node var = new Node(parent.getToken());
for (Node n : childrenOfAddedVarStatement) {
var.addChildToBack(n.cloneTree());
fix.insertBefore(parent, var, compiler);
if (name.getNext() != null) {
for (Node n : childrenOfAddedVarStatement) {
fix.delete(n);
fix.delete(name);
fix.insertBefore(parent, assign, compiler);
fix.replace(parent, assign, compiler);
return fix.build();
import java.util.Collection;
options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES, ERROR);
public void testRedeclaration() {
String code = "function f() { var x; var x; }";
String expectedCode = "function f() { var x; }";
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars1() {
String code = "function f() { var x; var x, y; }";
String expectedCode = "function f() { var x; var y; }";
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars2() {
String code = "function f() { var x; var y, x; }";
String expectedCode = "function f() { var x; var y; }";
assertChanges(code, expectedCode);
public void testRedeclaration_withValue() {
String code = LINE_JOINER.join(
"function f() {",
"  var x;",
"  var x = 0;",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var x;",
"  x = 0;",
"}");
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars_withValue1() {
String code = LINE_JOINER.join(
"function f() {",
"  var x;",
"  var x = 0, y;",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var x;",
"  x = 0;",
"var y;",
"}");
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars_withValue2() {
String code = LINE_JOINER.join(
"function f() {",
"  var x;",
"  var y, x = 0;",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var x;",
"  var y;",
"x = 0;",
"}");
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars_withValue3() {
String code = LINE_JOINER.join(
"function f() {",
"  var y;",
"  var x = getX(), y = getY(), z = getZ();",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var y;",
"  var x = getX();",
"y = getY();",
"var z = getZ();",
"}");
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars_withValue4() {
String code = LINE_JOINER.join(
"function f() {",
"  var x;",
"  var x = getX(), y = getY(), z = getZ();",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var x;",
"  x = getX();",
"var y = getY(), z = getZ();",
"}");
assertChanges(code, expectedCode);
public void testRedeclaration_multipleVars_withValue5() {
String code = LINE_JOINER.join(
"function f() {",
"  var z;",
"  var x = getX(), y = getY(), z = getZ();",
"}");
String expectedCode = LINE_JOINER.join(
"function f() {",
"  var z;",
"  var x = getX(), y = getY();",
"z = getZ();",
"}");
assertChanges(code, expectedCode);lateLintChecks);
import java.util.Collection;public static void main(String[] args) throws IOException {
for (String filename : args) {
lint(filename);String parent = outputFile.getParent();
if (parent != null) {
exPath = parent + File.separatorChar + exPath;
private boolean printSourceAfterEachPass = false;
usage = "Create an externs file from @export annotations, and store it in the specified "
+ "output file.")
private String createExternsFromExports;
options.setExternExportsPath(flags.createExternsFromExports);
private List<Export> exports;
case SCRIPT:
sortAndProcessExports();
break;
private void sortAndProcessExports() {
Set<Export> sorted =
new TreeSet<>(new Comparator<Export>() {
public int compare(Export e1, Export e2) {
return e1.getExportedPath().compareTo(e2.getExportedPath());
sorted.addAll(exports);
for (Export export : sorted) {
export.generateExterns();
exports = new ArrayList<>();
import java.util.ArrayList;
public void testDependencyOrderingOfExterns() throws Exception {
compileAndCheck(ImmutableList.of(
Joiner.on("\n").join(
"goog.provide('ns.a');",
"goog.require('ns.b');",
"/**",
" * @param {ns.b} b",
" * @return {number}",
" */",
"ns.a = function(b) {",
"  return b.x + b.y.length;",
"};",
"goog.exportSymbol('ns.a', ns.a);"),
Joiner.on("\n").join(
"goog.provide('ns.b');",
"/** @constructor */",
"ns.b = function() {",
"  /** @type {number} */ this.x = 5;",
"  /** @type {string} */ this.y = 'foo';",
"};",
"goog.exportSymbol('ns.b', ns.b);"),
Joiner.on("\n").join(
"goog.provide('ns.c');",
"goog.require('ns.b');",
"/**",
" * @param {ns.b} b",
" * @return {string}",
" */",
"ns.c = function(b) {",
"  return 'b: {x: ' + b.x + ', y: \"' + b.y + '\"}';",
"};",
"goog.exportSymbol('ns.c', ns.c);")),
Joiner.on("\n").join(
"/**",
" @const",
" @suppress {const,duplicate}",
" */",
"var ns = {};",
"/**",
" * @constructor",
" */",
"ns.b = function() {",
"};",
"/**",
" * @param {(ns.b|null)} b",
" * @return {number}",
" */",
"ns.a = function(b) {",
"};",
"/**",
" * @param {(ns.b|null)} b",
" * @return {string}",
" */",
"ns.c = function(b) {",
"};",
""));
checkResult(result, expected);
private void compileAndCheck(List<String> jsList, String expected) {
Result result = compileAndExportExterns(jsList);
checkResult(result, expected);
private void checkResult(Result result, String expected) {
private Result compileAndExportExterns(List<String> jsList) {
return compileAndExportExterns(jsList, "");
private Result compileAndExportExterns(String js, String externs) {
List<String> jsList = ImmutableList.of(js);
return compileAndExportExterns(jsList, externs);
private Result compileAndExportExterns(List<String> jsList, String externs) {
options.setClosurePass(true);
options.getDependencyOptions().setDependencySorting(true);
List<SourceFile> inputs = new ArrayList<SourceFile>();
inputs.add(SourceFile.fromCode(
"goog",
+ "goog.exportProperty = function(a, b, c) {};"));
for (int i = 0; i < jsList.size(); ++i) {
String name = "source" + i;
String code = jsList.get(i);
inputs.add(SourceFile.fromCode(name, code));
inputs = ImmutableList.copyOf(inputs);if (isEnumElementType()) {
return toMaybeEnumElementType().getReferenceName();
public void testExportEnum() {
compileAndCheck(
Joiner.on("\n").join(
"/**",
" * @enum {string}",
" * @export",
"*/",
"var E = {A:8, B:9};",
"goog.exportSymbol('E', E);"),
Joiner.on("\n").join(
"/** @enum {string} */",
"var E = {A:1, B:2};",
""));
public void testExportEnumFunctionParameter() {
compileAndCheck(
Joiner.on("\n").join(
"/**",
" * @enum {number}",
" * @export",
"*/",
"var E = {A:8, B:9};",
"goog.exportSymbol('E', E);",
"/** @param {E} e */",
"function f(e) {}",
"goog.exportSymbol('f', f);"),
Joiner.on("\n").join(
"/** @enum {number} */",
"var E = {A:1, B:2};",
"/**",
" * @param {E} e",
" * @return {undefined}",
" */",
"var f = function(e) {",
"};",
""));
"var id = function() {return 'id'};\n"
+ "var ft = function() {\n"
+ "  var id;\n"
+ "  return 1;\n"
+ "};\n"
+ "goog.exportSymbol('id', id);\n",
"/**\n"
+ " * @return {?}\n"
+ " */\n"
+ "var id = function() {\n"
+ "};\n");
compileAndCheck(
"/**\n"
+ " * @param {string} param1\n"
+ " * @return {string}\n"
+ " */\n"
+ "function internalName(param1) {"
+ "  return param1"
+ "};"
+ "goog.exportSymbol('externalName', internalName)",
"/**\n"
+ " * @param {string} param1\n"
+ " * @return {string}\n"
+ " */\n"
+ "var externalName = function(param1) {\n};\n");
compileAndCheck(
"/**\n"
+ " * @param {string} param1\n"
+ " */\n"
+ "var y = function(param1) {"
+ "};"
+ "/**\n"
+ " * @param {string} param1\n"
+ " * @param {string} param2\n"
+ " */\n"
+ "var x = function y(param1, param2) {"
+ "};"
+ "goog.exportSymbol('externalName', y)",
"/**\n"
+ " * @param {string} param1\n"
+ " * @return {undefined}\n"
+ " */\n"
+ "var externalName = function(param1) {\n};\n");
"/**\n"
+ " * @param {number} a\n"
+ " * @return {number}\n"
+ " */\n "
+ "var InternalName = function(a,b,c) {\n"
+ "  return 6;\n"
+ "};\n"
+ "goog.exportSymbol('ExternalName', InternalName)";final CompilerOptions options;exPath = outputFile.getParent() + File.separatorChar + exPath;
private boolean printSourceAfterEachPass = false;
private final List<Export> exports;
Set<Export> sorted =
new TreeSet<>(new Comparator<Export>() {
public int compare(Export e1, Export e2) {
return e1.getExportedPath().compareTo(e2.getExportedPath());
sorted.addAll(exports);
for (Export export : sorted) {
export.generateExterns();
import java.util.List;
private Result compileAndExportExterns(String js, String externs) {
List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(
"testcode",
+ "goog.exportProperty = function(a, b, c) {}; " + js));if (options.enables(DiagnosticGroups.ES5_STRICT)) {
checks.add(checkStrictMode);
"variables, functions, and arguments cannot be deleted in "
+ "ES5 strict mode");
static final DiagnosticType DUPLICATE_OBJECT_KEY = DiagnosticType.warning(
testSame("var x = 3; delete x;");
options.setWarningLevel(DiagnosticGroups.MISSING_PROVIDE,
CheckLevel.WARNING);
public void testClosureDefinesDuplicates2() {
CompilerOptions options = createCompilerOptions();
CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;
level.setOptionsForCompilationLevel(options);
WarningLevel warnings = WarningLevel.DEFAULT;
warnings.setOptionsForWarningLevel(options);
options.setDefineToNumberLiteral("FOO", 3);
String code = "" +
"var CLOSURE_DEFINES = {\n" +
"  'FOO': 1,\n" +
"  'FOO': 2\n" +
"};\n" +
"\n" +
"/** @define {number} */ var FOO = 0;\n" +
"";
String result = "" +
"var CLOSURE_DEFINES = {\n" +
"  FOO: 1,\n" +
"  FOO: 2\n" +
"}," +
"FOO = 3" +
"";
test(options, code, result);
testSame("var o = {a: 1, b: 2, a: 3};",
testSame("var x = { get a() {}, get a() {} };",
testSame("var x = { get a() {}, a: 1 };",
testSame("var x = { set a(p) {}, a: 1 };",
testWarningEs6("var x = {a: 2, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6("var x = {a, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6("var x = {a(){}, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6(LINE_JOINER.join(checks.add(checkStrictMode);
"variables, functions, and arguments cannot be deleted in ES5 strict mode");
static final DiagnosticType DUPLICATE_OBJECT_KEY = DiagnosticType.error(
test("var x = 3; delete x;", StrictModeCheck.DELETE_VARIABLE);
options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.OFF);
testError("var o = {a: 1, b: 2, a: 3};",
testError("var x = { get a() {}, get a() {} };",
testError("var x = { get a() {}, a: 1 };",
testError("var x = { set a(p) {}, a: 1 };",
testErrorEs6("var x = {a: 2, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testErrorEs6("var x = {a, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testErrorEs6("var x = {a(){}, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testErrorEs6(LINE_JOINER.join(if (options.enables(DiagnosticGroups.ES5_STRICT)) {
checks.add(checkStrictMode);
"variables, functions, and arguments cannot be deleted in "
+ "ES5 strict mode");
static final DiagnosticType DUPLICATE_OBJECT_KEY = DiagnosticType.warning(
testSame("var x = 3; delete x;");
options.setWarningLevel(DiagnosticGroups.MISSING_PROVIDE,
CheckLevel.WARNING);
public void testClosureDefinesDuplicates2() {
CompilerOptions options = createCompilerOptions();
CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;
level.setOptionsForCompilationLevel(options);
WarningLevel warnings = WarningLevel.DEFAULT;
warnings.setOptionsForWarningLevel(options);
options.setDefineToNumberLiteral("FOO", 3);
String code = "" +
"var CLOSURE_DEFINES = {\n" +
"  'FOO': 1,\n" +
"  'FOO': 2\n" +
"};\n" +
"\n" +
"/** @define {number} */ var FOO = 0;\n" +
"";
String result = "" +
"var CLOSURE_DEFINES = {\n" +
"  FOO: 1,\n" +
"  FOO: 2\n" +
"}," +
"FOO = 3" +
"";
test(options, code, result);
testSame("var o = {a: 1, b: 2, a: 3};",
testSame("var x = { get a() {}, get a() {} };",
testSame("var x = { get a() {}, a: 1 };",
testSame("var x = { set a(p) {}, a: 1 };",
testWarningEs6("var x = {a: 2, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6("var x = {a, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6("var x = {a(){}, a(){}}", StrictModeCheck.DUPLICATE_OBJECT_KEY);
testWarningEs6(LINE_JOINER.join(passes.add(peepholeOptimizations);
new PassFactory("peepholeOptimizations", false) {
final boolean late = false;
return new PeepholeOptimizationsPass(compiler,
new PeepholeMinimizeConditions(late, options.useTypesForOptimization),
new PeepholeSubstituteAlternateSyntax(late),
new PeepholeReplaceKnownMethods(late),
new PeepholeRemoveDeadCode(),
new PeepholeFoldConstants(late, options.useTypesForOptimization),
new PeepholeCollectPropertyAssignments());for (Scope s = referencedIn; s != declaredIn; s = s.getParent()) {
if (s.isFunctionBlockScope()) {
Node function = s.getRootNode().getParent();
if (functionHandledMap.containsEntry(function, name)) {
return;
functionHandledMap.put(function, name);
if (!loopObjectMap.containsKey(loopNode)) {
loopObjectMap.put(loopNode,
new LoopObject(
LOOP_OBJECT_NAME + "$" + compiler.getUniqueNameIdSupplier().get()));
LoopObject object = loopObjectMap.get(loopNode);
object.vars.add(var);
functionLoopObjectsMap.put(function,  object);
return;private final JSTypeRegistry registry;
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(registry, this);
TemplateTypeMap resolvedMap = this.addUnknownValues();
int index = resolvedMap.getTemplateTypeIndex(key);
return (index == -1) ? registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) :
resolvedMap.resolvedTemplateValues[index];
if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {&& n.getTypeI().isSomeUnknownType()
return isUnknown();return c2.isNominalSubtypeOf(c1) ? c1 : null;
private static ObjectType join(ObjectType obj1, ObjectType obj2) {
Preconditions.checkState(areRelatedNominalTypes(nom1, nom2));
ImmutableSet.Builder<ObjectType> newObjs = ImmutableSet.builder();
ImmutableSet.Builder<ObjectType> newObjs = ImmutableSet.builder();if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
return this.rawType.isPropDefinedOnSubtype(this, pname);
Preconditions.checkState(!nt.isBuiltinObject());
return nt.isPropDefinedOnSubtype(pname);
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
private final Multimap<NominalType, RawNominalType> subtypes = LinkedHashMultimap.create();
addSubtypeTo(superclass, this);
private static void addSubtypeTo(NominalType supertype, RawNominalType subtype) {
RawNominalType rawSupertype = supertype.getRawNominalType();
Preconditions.checkState(!rawSupertype.isFinalized);
if (!rawSupertype.isBuiltinWithName("Object")) {
rawSupertype.subtypes.put(supertype, subtype);
boolean isPropDefinedOnSubtype(NominalType thisAsNominal, QualifiedName qname) {
Preconditions.checkArgument(qname.isIdentifier());
String pname = qname.getLeftmostName();
for (RawNominalType subtype : this.subtypes.get(thisAsNominal)) {
if (subtype.mayHaveProp(pname)) {
addSubtypeTo(interf, this);static final DiagnosticType REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME =
"JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME",
"Reference to fully qualified import name ''{0}''. Please use the short name instead.");
t.report(n, REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME, n.getQualifiedName());
ClosureCheckModule.REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME,
import static com.google.javascript.jscomp.ClosureCheckModule.REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME;
REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);
REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);
REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);
REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);COVERT_TO_DOTTED_PROPERTIES {import com.google.javascript.rhino.IR;
String typeName = n.getString();
if (!namedType.isUnknownType() && (typeList != null || nAllowedTypes > 0)) {
if (typeList == null) {
if (typeName.equals("Object") || typeName.equals("Array")) {
return createDefaultObjectUnion(namedType);
typeList = IR.empty();
ImmutableList.Builder<JSType> templateTypes = ImmutableList.builder();
if ((typeName.equals("Object") || typeName.equals("window.Object"))
for (Node templateNode : typeList.children()) {
for (int i = typeList.getChildCount(); i < nAllowedTypes; i++) {
templateTypes.add(getNativeType(UNKNOWN_TYPE));
public void testFillInMissingGenerics1() {
testTypes(
LINE_JOINER.join(
"/**",
" * @constructor",
" * @template T",
" */",
"function Foo() {}",
"/**",
" * @constructor",
" * @template T",
" */",
"function Bar() {}",
"/** @type {!Foo<T>} */",
"Bar.prototype.myprop;",
"/** @param {!Bar} x */",
"function f(x) {",
"  var /** null */ n = x.myprop;",
"}"),
LINE_JOINER.join(
"initializing variable",
"found   : Foo<?>",
"required: null"));
public void testFillInMissingGenerics2() {
testTypes(
LINE_JOINER.join(
"/**",
" * @constructor",
" * @template T",
" */",
"function Foo() {}",
"/**",
" * @constructor",
" * @template T,U",
" */",
"function Bar() {}",
"/** @type {!Foo<U>} */",
"Bar.prototype.myprop;",
"/** @param {!Bar<number>} x */",
"function f(x) {",
"  var /** null */ n = x.myprop;",
"}"),
LINE_JOINER.join(
"initializing variable",
"found   : Foo<?>",
"required: null"));
public void testFillInMissingGenerics3() {
testTypes(
LINE_JOINER.join(
"/**",
" * @constructor",
" * @template T",
" */",
"function Foo() {}",
"/**",
" * @interface",
" * @template T",
" */",
"function High1() {}",
"/** @type {!Foo<T>} */",
"High1.prototype.myprop;",
"/**",
" * @interface",
" * @template T",
" */",
"function High2() {}",
"/** @type {!Foo<T>} */",
"High2.prototype.myprop;",
"/**",
" * @interface",
" * @extends {High1}",
" * @extends {High2}",
" */",
"function Low() {}"));
assertEquals("?", findNameType("result3", globalScope).toString());return typeInJsdoc != null && previousType != null
&& typeInJsdoc.equals(previousType);
this.mode = TypeInferenceMode.OtiOnly;TypeI type = getprop.getTypeIIfOld();
new FunctionNamespace(commonTypes, funQname.getQualifiedName(), s));
new FunctionNamespace(getCommonTypes(), varName, s));
new FunctionNamespace(getCommonTypes(), qname.toString(), s));
new NamespaceLit(getCommonTypes(), qnameNode.getQualifiedName()));
private EnumType(JSTypes commonTypes, String name,
super(commonTypes, name);
public static EnumType make(JSTypes commonTypes, String name,
return new EnumType(commonTypes, name, typeExpr, props);
JSTypes commonTypes, String name, DeclaredTypeRegistry scope) {
super(commonTypes, name);
protected Namespace(JSTypes commonTypes, String name) {
return Property.make(subns.namespaceType, subns.namespaceType);
public NamespaceLit(JSTypes commonTypes, String name) {
super(commonTypes, name);
private final Node defSite;
super(commonTypes, name);
this.defSite = defSite;
public Node getDefSite() {
return this.defSite;
this.mode = TypeInferenceMode.OtiOnly;testClosureTypesMultipleWarnings(
"/** @record \n * @extends {F} */var G = function() {};" +
"/** @record \n * @extends {G} */var F = function() {};" +
"/** @constructor \n * @implements {F} */var H = function() {};" +
ImmutableList.of(
"extends loop involving F, "
+ "loop: F -> G -> F",
"extends loop involving G, "
+ "loop: G -> F -> G"));if (lhs.isStringKey()) {
lhs.addChildToFront(IR.name(name).srcref(lhs));if ((node.isAssign() || node.isName())import com.google.common.collect.Sets;
import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
Set<PropertyMap> identitySet = Sets.newIdentityHashSet();
collectPropertyNamesHelper(props, identitySet);
private void collectPropertyNamesHelper(
Set<String> props, Set<PropertyMap> cache) {
if (cache.contains(this)) {
return;
cache.add(this);
primaryParent.collectPropertyNamesHelper(props, cache);
p.collectPropertyNamesHelper(props, cache);
cache.remove(this);
public Iterable<ObjectType> getCtorExtendedInterfaces() {
return this.referencedObjType == null
? Collections.<ObjectType>emptyList()
: this.referencedObjType.getCtorExtendedInterfaces();
public void testPropInParentInterface1() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" * @template T",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection<?>}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
public void testPropInParentInterface2() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection<?>}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
public void testPropInParentInterface3() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
testClosureTypes(
"Parse error. Cycle detected in inheritance chain of type F");if (options.dartPass && !options.getLanguageOut().isEs6OrHigher()) {
checks.add(dartSuperAccessorsPass);
passes.add(es6ConvertSuper);ProcessClosurePrimitives.DEFINITION_NOT_IN_GLOBAL_SCOPE,
ProcessClosurePrimitives.DUPLICATE_DEFINITION_ERROR,
ProcessClosurePrimitives.DUPLICATE_DEFINITION_ERROR,
static final DiagnosticType DUPLICATE_DEFINITION_ERROR =
DiagnosticType.error(
"JSC_DUPLICATE_DEFINITION_ERROR",
"Found multiple definitions of goog.provided name {0}.");
static final DiagnosticType DEFINITION_NOT_IN_GLOBAL_SCOPE =
DiagnosticType.error(
"JSC_DEFINITION_NOT_IN_GLOBAL_SCOPE",
"Definition of goog.provided name {0} must be in the global hoist scope");
private void handleCandidateProvideDefinition(NodeTraversal t, Node n, Node parent) {
String name = null;
if (n.isName() && NodeUtil.isNameDeclaration(parent)) {
name = n.getString();
name = n.getFirstChild().getQualifiedName();
if (name != null) {
if (parent.getBooleanProp(Node.IS_NAMESPACE)) {
processProvideFromPreviousPass(t, name, parent);
ProvidedName pn = providedNames.get(name);
if (pn != null) {
if (t.inGlobalHoistScope()) {
Var var = t.getScope().getVar(name);
if (var == null || var.isGlobal()) {
compiler.report(JSError.make(n, DEFINITION_NOT_IN_GLOBAL_SCOPE, name));
if (candidateDefinition != null) {
Node errorNode = node.isExprResult() ? node.getFirstChild() : node;
compiler.report(
JSError.make(
errorNode, DUPLICATE_DEFINITION_ERROR, namespace, candidateDefinition.toString()));
return;
candidateDefinition = node;
updateMinimumModule(module);
ProcessClosurePrimitives.DUPLICATE_DEFINITION_ERROR);
public void testProvidedNamespaceCannotBeReassigned1() {
ProcessClosurePrimitives.DEFINITION_NOT_IN_GLOBAL_SCOPE);
public void testProvidedNamespaceCannotBeReassigned2() {
options.setWarningLevel(DiagnosticGroups.ACCESS_CONTROLS, CheckLevel.ERROR);
"foo.bar = function() {};",
ProcessClosurePrimitives.DEFINITION_NOT_IN_GLOBAL_SCOPE);
public void testProvidedNamespaceCannotBeReassigned3() {
CompilerOptions options = createCompilerOptions();
options.setClosurePass(true);
options.setInlineConstantVars(true);
options.setCollapseProperties(true);
options.setWarningLevel(DiagnosticGroups.ACCESS_CONTROLS, CheckLevel.ERROR);
test(
options,
"var goog = {};",
"goog.provide('foo.bar');",
"function f() { foo.bar = {};}"),
ProcessClosurePrimitives.DEFINITION_NOT_IN_GLOBAL_SCOPE);
import static com.google.javascript.jscomp.ProcessClosurePrimitives.DEFINITION_NOT_IN_GLOBAL_SCOPE;
import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_DEFINITION_ERROR;
testError(
DUPLICATE_DEFINITION_ERROR);
public void testMultipleAssignment1() {
testError(
"goog.provide('foo'); foo = 0; foo = 1",
DUPLICATE_DEFINITION_ERROR);
public void testMultipleAssignment2() {
testError(
"goog.provide('foo'); var foo = 0; foo = 1",
DUPLICATE_DEFINITION_ERROR);
testErrorEs6(
"goog.provide('foo'); let foo = 0; let foo = 1",
DUPLICATE_DEFINITION_ERROR);
public void testMultipleAssignment3() {
testError(
"goog.provide('foo'); foo = 0; var foo = 1",
DUPLICATE_DEFINITION_ERROR);
testErrorEs6(
"goog.provide('foo'); foo = 0; let foo = 1",
DUPLICATE_DEFINITION_ERROR);
public void testMultipleAssignment4() {
testError(
DUPLICATE_DEFINITION_ERROR);
testError(
DEFINITION_NOT_IN_GLOBAL_SCOPE);
testError(
"goog.provide('foo.bar'); var foo = {}; if (true) { foo.bar = 0 } else { foo.bar = 1 }",
DUPLICATE_DEFINITION_ERROR);
testError(
DUPLICATE_DEFINITION_ERROR);
testError(
DUPLICATE_DEFINITION_ERROR);
public void testProvideOrder4() {
testError(
DUPLICATE_DEFINITION_ERROR);private JSType pickReqObjType(Node expr) {
return expr.hasChildren()
? JSType.TOP_OBJECT : this.commonTypes.getIObjectAnyAny();
public JSType getIObjectAnyAny() {
return this.iObject == null
? JSType.TOP_OBJECT
: JSType.fromObjectType(
ObjectType.fromNominalType(
this.iObject.getAsNominalType().instantiateGenericsWithUnknown()));
private boolean isIObject() {
NominalType instantiateGenericsWithUnknown() {
return instantiateGenerics(JSType.MAP_TO_UNKNOWN);
NominalType thisNt = this.nominalType;
NominalType otherNt = other.nominalType;
if (otherNt != null && otherNt.isStructuralInterface()) {
if (thisNt == null || !thisNt.isNominalSubtypeOf(otherNt)) {
&& (thisNt == null || !thisNt.isNominalSubtypeOf(otherNt))) {
this.kind = kind;
"  var /** { prop: number} */ y = x;",case '>':                       // Break --> into --\> or ]]> into ]]\>
sb.append("\\>");
sb.append("<\\");
sb.append("<\\");return getFixForExtraRequire(error, compiler);
private static SuggestedFix getFixForExtraRequire(JSError error, AbstractCompiler compiler) {
Matcher regexMatcher = EXTRA_REQUIRE.matcher(error.description);
"/** @fileoverview foo */",
"/** @fileoverview foo */",private static final String PREFIX = "(function(){var $wnd=this;var $doc={};";DiagnosticType.warning(
"JSC_REQUIRES_NOT_SORTED", "goog.require() statements are not sorted.");
DiagnosticType.warning(
"JSC_PROVIDES_NOT_SORTED", "goog.provide() statements are not sorted.");
if (!alphabetical.isOrdered(requires)) {
t.report(requires.get(0), REQUIRES_NOT_SORTED);
if (!alphabetical.isOrdered(provides)) {
t.report(provides.get(0), PROVIDES_NOT_SORTED);
testWarning("goog.require('a.c');\ngoog.require('a.b')", REQUIRES_NOT_SORTED);public void testMissingGoogRequireFromGoogScope() {
testMissingRequire(js, warning);"Name {0} in JSDoc is implicitly nullable.\n"
+ "Please add a '!' to make it non-nullable,"
+ " or a '?' to make it explicitly nullable.");
return ImmutableList.of(qmark, bang);Node var = IR.var(callsiteId, cooked).useSourceInfoIfMissingFromForTree(n);
"var $jscomp$templatelit$0 = [''];",
"var $jscomp$templatelit$0 = ['', ' world'];",
"var $jscomp$templatelit$0 = ['', ' ', ''];",
"var $jscomp$templatelit$0 = ['\\\"'];",
"var $jscomp$templatelit$0 = ['a\tb'];",
"var $jscomp$templatelit$0 = ['', ' world'];",
"var $jscomp$templatelit$0 = ['', ' world'];",
"var $jscomp$templatelit$0 = ['<p class=\"foo\">', '</p>'];",
"var $jscomp$templatelit$0 = ['<p class=\\'foo\\'>', '</p>'];",
"var window;");String content = RESOURCES.get(path);
return RESOURCES.get(path) != null;
public final native String get(String key) /*-{
return this[key];String binaryNamespace; // "module$exports$a$b$c
boolean targetNamespaceIsAGoogModule = rewriteState.containsModule(legacyNamespace);
String aliasedNamespace =
targetNamespaceIsAGoogModule
? toBinaryNamespace(legacyNamespace)
: legacyNamespace;
boolean targetIsAGoogModule = rewriteState.containsModule(prefixTypeName);
&& !targetIsAGoogModule) {
if (targetIsAGoogModule) {
safeSetString(typeRefNode, toBinaryNamespace(prefixTypeName) + suffix);
currentScript.binaryNamespace = toBinaryNamespace(legacyNamespace);
if (!currentScript.isModule || !n.getString().equals("exports") || !isAssignTarget(n)) {
boolean targetIsGoogModule = rewriteState.containsModule(legacyNamespace);
boolean targetIsAGoogModuleGetted =
if (currentScript.isModule || (targetIsGoogModule && targetIsAGoogModuleGetted)) {
Node replacementNamespaceName =
NodeUtil.newQName(
compiler,
targetIsGoogModule ? toBinaryNamespace(legacyNamespace) : legacyNamespace);
Node binaryNamespaceName = IR.name(toBinaryNamespace(legacyNamespace));
if (targetIsGoogModule) {
Node binaryNamespaceName = IR.name(toBinaryNamespace(legacyNamespace));
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, legacyNamespace);
call.getParent().replaceChild(call, binaryNamespaceName);
safeSetString(exportsNameNode, currentScript.binaryNamespace);
boolean targetNamespaceIsAGoogModule = rewriteState.containsModule(legacyNamespace);
String namespaceToInline =
targetNamespaceIsAGoogModule ? toBinaryNamespace(legacyNamespace) : legacyNamespace;
if (!currentScript.isModule || !n.getString().equals("exports") || !isAssignTarget(n)) {
Node exprResultNode = assignNode.getParent();
rhs.detachFromParent();
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, currentScript.legacyNamespace);
Node exportsObjectCreationNode = IR.var(binaryNamespaceName, rhs);
exportsObjectCreationNode.srcrefTree(exprResultNode);
exportsObjectCreationNode.putBooleanProp(Node.IS_NAMESPACE, true);
exprResultNode.getParent().replaceChild(exprResultNode, exportsObjectCreationNode);
currentScript.hasCreatedExportObject = true;
markConstAndCopyJsDoc(assignNode, exportsObjectCreationNode, rhs);
maybeExportLegacyNamespaceAfter(exportsObjectCreationNode, assignNode);
if (!currentScript.isModule || !"exports".equals(n.getString())) {
safeSetString(n, currentScript.binaryNamespace);
Preconditions.checkState(currentScript.hasCreatedExportObject);
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
maybeExportLegacyNamespaceAfter(binaryNamespaceExportNode, null);
private void maybeExportLegacyNamespaceAfter(Node afterNode, Node jsDocSourceNode) {
if (!currentScript.declareLegacyNamespace) {
return;
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, currentScript.legacyNamespace);
Node assignmentNode =
IR.assign(NodeUtil.newQName(compiler, currentScript.legacyNamespace), binaryNamespaceName);
Node binaryToLegacyBridgeStatement = IR.exprResult(assignmentNode);
binaryToLegacyBridgeStatement.srcrefTree(afterNode);
if (jsDocSourceNode != null) {
markConstAndCopyJsDoc(jsDocSourceNode, assignmentNode, binaryNamespaceName);
markConst(assignmentNode);
afterNode.getParent().addChildAfter(binaryToLegacyBridgeStatement, afterNode);
compiler.reportCodeChange();
private static String toBinaryNamespace(String legacyNamespace) {
return MODULE_EXPORTS_PREFIX + legacyNamespace.replace('.', '$');
test(
LINE_JOINER.join(
"goog.module('ns.a');",
"goog.module.declareLegacyNamespace();"),
LINE_JOINER.join(
"goog.provide('ns.a');",
"/** @const */ var module$exports$ns$a = {};",
"/** @const */ ns.a = module$exports$ns$a;"));
LINE_JOINER.join(
"goog.module('ns.b');",
"goog.module.declareLegacyNamespace();",
"",
"alert('hello world');"),
LINE_JOINER.join(
"goog.module('ns.a');",
"",
"goog.require('ns.b');")},
LINE_JOINER.join(
"goog.provide('ns.b');",
"/** @const */ var module$exports$ns$b = {};",
"/** @const */ ns.b = module$exports$ns$b;",
"alert('hello world');"),
"/** @const */ var module$exports$ns$a = {}; goog.require('ns.b');"});
LINE_JOINER.join(
"/** @const */ var module$exports$ns$b = {};",
"goog.provide('ns.a');",
"/** @const */ var module$exports$ns$a = {};",
"/** @const */ ns.a = module$exports$ns$a;"));
"/** @const */ var module$exports$xid = function(id) {",
"/** @const */ xid = module$exports$xid;",
"var module$contents$xid_xid = module$exports$xid"));
"/** @const @public */ var module$exports$a$b$c = 5;",
"/** @const @public */ a.b.c = module$exports$a$b$c;"));
"goog.provide('a.b.c');",
"/** @const */ var module$exports$a$b$c={};",
"/** @const */ a.b.c = module$exports$a$b$c"),
"goog.require('a.b.c'); use(a.b.c);"import javax.annotation.Nullable;
if (this.declareLegacyNamespace) {
return null;
return MODULE_EXPORTS_PREFIX + this.legacyNamespace.replace('.', '$');
String aliasedNamespace = rewriteState.getExportedNamespace(legacyNamespace);
String binaryNamespaceIfModule = rewriteState.getBinaryNamespace(prefixTypeName);
&& binaryNamespaceIfModule == null) {
if (binaryNamespaceIfModule != null) {
safeSetString(typeRefNode, binaryNamespaceIfModule + suffix);
ScriptDescription script = scriptDescriptionsByGoogModuleNamespace.get(legacyNamespace);
return script == null ? null : script.getBinaryNamespace();
String getExportedNamespace(String legacyNamespace) {
String binaryNamespace = getBinaryNamespace(legacyNamespace);
return binaryNamespace != null ? binaryNamespace : legacyNamespace;
if (!currentScript.isModule
|| currentScript.declareLegacyNamespace
|| !n.getString().equals("exports")
|| !isAssignTarget(n)) {
boolean targetIsNonLegacyGoogModule =
rewriteState.containsModule(legacyNamespace)
&& !rewriteState.isLegacyModule(legacyNamespace);
boolean targetIsGoogModuleGetted =
if (currentScript.isModule || (targetIsNonLegacyGoogModule && targetIsGoogModuleGetted)) {
String exportedNamespace = rewriteState.getExportedNamespace(legacyNamespace);
Node replacementNamespaceName = NodeUtil.newQName(compiler, exportedNamespace);
Node binaryNamespaceName = IR.name(rewriteState.getBinaryNamespace(legacyNamespace));
if (targetIsNonLegacyGoogModule) {
Node exportedNamespaceName =
NodeUtil.newQName(compiler, rewriteState.getExportedNamespace(legacyNamespace))
.srcrefTree(call);
exportedNamespaceName.putProp(Node.ORIGINALNAME_PROP, legacyNamespace);
call.getParent().replaceChild(call, exportedNamespaceName);
String exportedNamespace =
currentScript.declareLegacyNamespace
? currentScript.legacyNamespace
: currentScript.getBinaryNamespace();
safeSetMaybeQualifiedString(exportsNameNode, exportedNamespace);
String namespaceToInline = rewriteState.getExportedNamespace(legacyNamespace);
if (!currentScript.isModule
|| !n.getString().equals("exports")
|| !isAssignTarget(n)) {
Node jsdocNode;
if (currentScript.declareLegacyNamespace) {
Node legacyQname = NodeUtil.newQName(compiler, currentScript.legacyNamespace).srcrefTree(n);
assignNode.replaceChild(n, legacyQname);
jsdocNode = assignNode;
rhs.detachFromParent();
Node exprResultNode = assignNode.getParent();
Node binaryNamespaceName = IR.name(currentScript.getBinaryNamespace());
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, currentScript.legacyNamespace);
Node exportsObjectCreationNode = IR.var(binaryNamespaceName, rhs);
exportsObjectCreationNode.srcrefTree(exprResultNode);
exportsObjectCreationNode.putBooleanProp(Node.IS_NAMESPACE, true);
exprResultNode.getParent().replaceChild(exprResultNode, exportsObjectCreationNode);
jsdocNode = exportsObjectCreationNode;
currentScript.hasCreatedExportObject = true;
markConstAndCopyJsDoc(assignNode, jsdocNode, rhs);
if (!currentScript.isModule || !"exports".equals(n.getString()) || n.getParent() == null) {
if (currentScript.declareLegacyNamespace) {
Node legacyQname = NodeUtil.newQName(compiler, currentScript.legacyNamespace).srcrefTree(n);
n.getParent().replaceChild(n, legacyQname);
return;
safeSetString(n, currentScript.getBinaryNamespace());
Preconditions.checkState(
currentScript.declareLegacyNamespace || currentScript.hasCreatedExportObject);
if (currentScript.declareLegacyNamespace) {
return;
Node binaryNamespaceName = IR.name(currentScript.getBinaryNamespace());
test("goog.module('ns.a'); goog.module.declareLegacyNamespace();", "goog.provide('ns.a');");
LINE_JOINER.join(
"goog.module('ns.b');",
"goog.module.declareLegacyNamespace();",
"",
"alert('hello world');"),
LINE_JOINER.join("goog.module('ns.a');", "", "goog.require('ns.b');")
"goog.provide('ns.b'); alert('hello world');",
"/** @const */ var module$exports$ns$a = {}; goog.require('ns.b');"
LINE_JOINER.join("/** @const */ var module$exports$ns$b = {};", "goog.provide('ns.a');"));
"/** @const */ xid = function(id) {",
"var module$contents$xid_xid = xid"));
"/** @const @public */ a.b.c = 5;"));
public void testLegacyGoogModuleValidReferences() {
new String[] {
"goog.provide('a.b.c');",
"goog.require('a.b.c'); use(a.b.c);"
test(
new String[] {
"goog.module('a.b.c'); goog.module.declareLegacyNamespace();",
"goog.module('x.y.z'); var c = goog.require('a.b.c'); use(c);"
new String[] {
"goog.provide('a.b.c');",
"/** @const */ var module$exports$x$y$z={}; goog.require('a.b.c'); use(a.b.c);"
test(
"goog.module('a.b.Foo');",
"goog.module.declareLegacyNamespace();",
"",
"/** @constructor */ exports = function() {};"),
"/** @param {a.b.Foo} x */ function f(x) {}"
new String[] {
"goog.provide('a.b.Foo'); /** @constructor */ a.b.Foo = function() {};",
"/** @param {a.b.Foo} x */ function f(x) {}"
test(
new String[] {
LINE_JOINER.join(
"goog.module('a.b.c');",
"goog.module.declareLegacyNamespace();",
"",
"exports = function() {};"),
"function f() { return goog.module.get('a.b.c'); }"
new String[] {
"goog.provide('a.b.c'); /** @const */ a.b.c = function() {};",
"function f() { return a.b.c; }"
test(
new String[] {
LINE_JOINER.join(
"goog.module('a.b.Foo');",
"goog.module.declareLegacyNamespace();",
"",
"/** @constructor */ function Foo() {};",
"",
"exports = Foo;"),
"/** @param {a.b.Foo} x */ function f(x) {}"
new String[] {
LINE_JOINER.join(
"goog.provide('a.b.Foo');",
"/** @constructor */ function module$contents$a$b$Foo_Foo() {};",
"/** @const */ a.b.Foo = module$contents$a$b$Foo_Foo;"),
"/** @param {a.b.Foo} x */ function f(x) {}"
test(
new String[] {
LINE_JOINER.join(
"goog.module('a.b');",
"goog.module.declareLegacyNamespace();",
"",
"/** @constructor */ function Foo() {};",
"",
"exports.Foo = Foo;"),
"/** @param {a.b.Foo} x */ function f(x) {}"
new String[] {
LINE_JOINER.join(
"goog.provide('a.b');",
"/** @constructor */ function module$contents$a$b_Foo() {};",
"/** @const */ a.b.Foo = module$contents$a$b_Foo;"),
"/** @param {a.b.Foo} x */ function f(x) {}"
public void testLegacyGoogModuleExport() {
CompilerOptions options = new CompilerOptions();
options.setClosurePass(true);
options.setCodingConvention(new ClosureCodingConvention());
options.setGenerateExports(true);
test(
options,
new String[] {
LINE_JOINER.join(
"var goog = {};",
"goog.exportSymbol = function(path, symbol) {};"),
LINE_JOINER.join(
"goog.module('foo.example.ClassName');",
"goog.module.declareLegacyNamespace();",
"",
"/** @constructor */ function ClassName() {}",
"",
"/** @export */",
"exports = ClassName;"),
new String[] {
LINE_JOINER.join(
"var goog = {};",
"goog.exportSymbol = function(path, symbol) {};"),
LINE_JOINER.join(
"var foo = {};",
"foo.example = {};",
"function module$contents$foo$example$ClassName_ClassName() {}",
"foo.example.ClassName = module$contents$foo$example$ClassName_ClassName;",
"goog.exportSymbol('foo.example.ClassName', foo.example.ClassName);"),
test(
options,
new String[] {
LINE_JOINER.join(
"var goog = {};",
"goog.exportSymbol = function(path, symbol) {};"),
LINE_JOINER.join(
"goog.module('foo.ns');",
"goog.module.declareLegacyNamespace();",
"",
"/** @constructor */ function ClassName() {}",
"",
"/** @export */",
"exports.ExportedName = ClassName;"),
new String[] {
LINE_JOINER.join(
"var goog = {};",
"goog.exportSymbol = function(path, symbol) {};"),
LINE_JOINER.join(
"var foo = {};",
"foo.ns = {};",
"function module$contents$foo$ns_ClassName() {}",
"foo.ns.ExportedName = module$contents$foo$ns_ClassName;",
"goog.exportSymbol('foo.ns.ExportedName', foo.ns.ExportedName);"),String binaryNamespace; // "module$exports$a$b$c
boolean targetNamespaceIsAGoogModule = rewriteState.containsModule(legacyNamespace);
String aliasedNamespace =
targetNamespaceIsAGoogModule
? toBinaryNamespace(legacyNamespace)
: legacyNamespace;
boolean targetIsAGoogModule = rewriteState.containsModule(prefixTypeName);
&& !targetIsAGoogModule) {
if (targetIsAGoogModule) {
safeSetString(typeRefNode, toBinaryNamespace(prefixTypeName) + suffix);
currentScript.binaryNamespace = toBinaryNamespace(legacyNamespace);
if (!currentScript.isModule || !n.getString().equals("exports") || !isAssignTarget(n)) {
boolean targetIsGoogModule = rewriteState.containsModule(legacyNamespace);
boolean targetIsAGoogModuleGetted =
if (currentScript.isModule || (targetIsGoogModule && targetIsAGoogModuleGetted)) {
Node replacementNamespaceName =
NodeUtil.newQName(
compiler,
targetIsGoogModule ? toBinaryNamespace(legacyNamespace) : legacyNamespace);
Node binaryNamespaceName = IR.name(toBinaryNamespace(legacyNamespace));
if (targetIsGoogModule) {
Node binaryNamespaceName = IR.name(toBinaryNamespace(legacyNamespace));
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, legacyNamespace);
call.getParent().replaceChild(call, binaryNamespaceName);
safeSetString(exportsNameNode, currentScript.binaryNamespace);
boolean targetNamespaceIsAGoogModule = rewriteState.containsModule(legacyNamespace);
String namespaceToInline =
targetNamespaceIsAGoogModule ? toBinaryNamespace(legacyNamespace) : legacyNamespace;
if (!currentScript.isModule || !n.getString().equals("exports") || !isAssignTarget(n)) {
Node exprResultNode = assignNode.getParent();
rhs.detachFromParent();
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, currentScript.legacyNamespace);
Node exportsObjectCreationNode = IR.var(binaryNamespaceName, rhs);
exportsObjectCreationNode.srcrefTree(exprResultNode);
exportsObjectCreationNode.putBooleanProp(Node.IS_NAMESPACE, true);
exprResultNode.getParent().replaceChild(exprResultNode, exportsObjectCreationNode);
currentScript.hasCreatedExportObject = true;
markConstAndCopyJsDoc(assignNode, exportsObjectCreationNode, rhs);
maybeExportLegacyNamespaceAfter(exportsObjectCreationNode, assignNode);
if (!currentScript.isModule || !"exports".equals(n.getString())) {
safeSetString(n, currentScript.binaryNamespace);
Preconditions.checkState(currentScript.hasCreatedExportObject);
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
maybeExportLegacyNamespaceAfter(binaryNamespaceExportNode, null);
private void maybeExportLegacyNamespaceAfter(Node afterNode, Node jsDocSourceNode) {
if (!currentScript.declareLegacyNamespace) {
return;
Node binaryNamespaceName = IR.name(currentScript.binaryNamespace);
binaryNamespaceName.putProp(Node.ORIGINALNAME_PROP, currentScript.legacyNamespace);
Node assignmentNode =
IR.assign(NodeUtil.newQName(compiler, currentScript.legacyNamespace), binaryNamespaceName);
Node binaryToLegacyBridgeStatement = IR.exprResult(assignmentNode);
binaryToLegacyBridgeStatement.srcrefTree(afterNode);
if (jsDocSourceNode != null) {
markConstAndCopyJsDoc(jsDocSourceNode, assignmentNode, binaryNamespaceName);
markConst(assignmentNode);
afterNode.getParent().addChildAfter(binaryToLegacyBridgeStatement, afterNode);
compiler.reportCodeChange();
private static String toBinaryNamespace(String legacyNamespace) {
return MODULE_EXPORTS_PREFIX + legacyNamespace.replace('.', '$');
test(
LINE_JOINER.join(
"goog.module('ns.a');",
"goog.module.declareLegacyNamespace();"),
LINE_JOINER.join(
"goog.provide('ns.a');",
"/** @const */ var module$exports$ns$a = {};",
"/** @const */ ns.a = module$exports$ns$a;"));
LINE_JOINER.join(
"goog.module('ns.b');",
"goog.module.declareLegacyNamespace();",
"",
"alert('hello world');"),
LINE_JOINER.join(
"goog.module('ns.a');",
"",
"goog.require('ns.b');")},
LINE_JOINER.join(
"goog.provide('ns.b');",
"/** @const */ var module$exports$ns$b = {};",
"/** @const */ ns.b = module$exports$ns$b;",
"alert('hello world');"),
"/** @const */ var module$exports$ns$a = {}; goog.require('ns.b');"});
LINE_JOINER.join(
"/** @const */ var module$exports$ns$b = {};",
"goog.provide('ns.a');",
"/** @const */ var module$exports$ns$a = {};",
"/** @const */ ns.a = module$exports$ns$a;"));
"/** @const */ var module$exports$xid = function(id) {",
"/** @const */ xid = module$exports$xid;",
"var module$contents$xid_xid = module$exports$xid"));
"/** @const @public */ var module$exports$a$b$c = 5;",
"/** @const @public */ a.b.c = module$exports$a$b$c;"));
"goog.provide('a.b.c');",
"/** @const */ var module$exports$a$b$c={};",
"/** @const */ a.b.c = module$exports$a$b$c"),
"goog.require('a.b.c'); use(a.b.c);"types.add(sym);
for (Symbol s : types) {if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
liveness.markAllParametersEscaped();
public void testParameter4() {"Illegal instantiation in function type {0} for the type variable "
+ "{1}.\n You can only specify one type. Found {2}.");
callNode, NOT_UNIQUE_INSTANTIATION, funType.toString(),
types.toString()));String nameToReport = Iterables.getFirst(classNames, namespace);
"missing require: 'goog.dom.getElement'");
testMissingRequireCall(js, "missing require: 'foo.bar.baz'");
testMissingRequireCall(js, "missing require: 'foo.bar.baz'");
testMissingRequireCall(js, "missing require: 'foo.bar.baz'");
"missing require: 'goog.array.forEach'");
"missing require: 'goog.dom.getElement'");if (!Annotation.recognizedAnnotations.containsKey(
if (annotation == null) {
if (startLineno == endLineno) {
if (startCharno >= endCharno) {
throw new IllegalStateException(
"Recorded bad position information\n" +
"start-char: " + startCharno + "\n" +
"end-char: " + endCharno);
if (startLineno > endLineno) {
throw new IllegalStateException(
"Recorded bad position information\n" +
"start-line: " + startLineno + "\n" +
"end-line: " + endLineno);private static final Pattern GOOG_PROVIDE_REQUIRE_PATTERN = Pattern.compile(
"(?:^|;|=)\\s*goog\\.(provide|module|require|addDependency)\\s*\\((.*?)\\)");for (String part : Splitter.on('.').split(qualifiedName)) {
classNames.add(qualifiedName.substring(0, qualifiedName.indexOf(part) + part.length()));"JSC_MISSING_REQUIRE_CALL_WARNING", "No matching require found for ''{0}''");
"No matching require found for 'goog.dom.getElement'");
testMissingRequireCall(js, "No matching require found for 'foo.bar.baz'");
testMissingRequireCall(js, "No matching require found for 'foo.bar.baz'");
testMissingRequireCall(js, "No matching require found for 'foo.bar.baz'");
"No matching require found for 'goog.array.forEach'");
"No matching require found for 'goog.dom.getElement'");
"No matching require found for 'goog.Timer'");t.report(call, DUPLICATE_MODULE);
t.report(call, DUPLICATE_NAMESPACE);
t.report(call, DUPLICATE_NAMESPACE);
static final DiagnosticType JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR =
t.report(key, JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR);
JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR,
static final DiagnosticType NAME_ERROR =
ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR;
testErrorEs6(LINE_JOINER.join(
"var jQuery={}; jQuery.expandedEach=function(vals, callback){};",
"jQuery.expandedEach({ [comp + 'Prop']: 1},",
"function(key, val) { var a = key; jQuery[key] = val; });"), NAME_ERROR);String ctor = ctorEntry.getKey();
if (ctor.startsWith("$jscomp.")) {
index = ctor.indexOf('.', index + 1);
String provideKey = index == -1 ? ctor : ctor.substring(0, index);
private void visitQualifiedName(Node getprop) {
for (; getprop != null; getprop = getprop.getFirstChild()) {
weakUsages.put(getprop.getQualifiedName(), getprop);
|| var.getSourceFile() == newNode.getStaticSourceFile())) {
if (var != null && (var.isLocal() || var.isExtern())) {
if (var == null || !var.isExtern()) {
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
final class ClosureRewriteModule implements NodeTraversal.Callback, HotSwapCompilerPass {
static final DiagnosticType INVALID_MODULE_IDENTIFIER =
"JSC_GOOG_MODULE_INVALID_MODULE_IDENTIFIER",
"Module identifiers must be string literals");
static final DiagnosticType INVALID_REQUIRE_IDENTIFIER =
"JSC_GOOG_MODULE_INVALID_REQUIRE_IDENTIFIER",
static final DiagnosticType INVALID_GET_IDENTIFIER =
"JSC_GOOG_MODULE_INVALID_GET_IDENTIFIER",
private class ModuleDescription {
Node moduleDecl;
String moduleNamespace = "";
Node requireInsertNode = null;
final Node moduleScopeRoot;
final Node moduleStatementRoot;
final List<Node> requires = new ArrayList<>();
final List<Node> provides = new ArrayList<>();
final List<Node> exports = new ArrayList<>();
public Scope moduleScope = null;
ModuleDescription(Node n) {
if (isLoadModuleCall(n)) {
this.moduleScopeRoot = getModuleScopeRootForLoadModuleCall(n);
this.moduleStatementRoot = getModuleStatementRootForLoadModuleCall(n);
this.moduleScopeRoot = n;
this.moduleStatementRoot = n;
private ModuleDescription current = null;
ClosureRewriteModule(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {
Preconditions.checkState(c.isScript());
hotSwapScript(c, null);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverseEs6(compiler, scriptRoot, this);
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
boolean isModuleFile = NodeUtil.isModuleFile(n);
if (isModuleFile) {
checkStrictModeDirective(t, n);
if (isModuleFile || isLoadModuleCall(n)) {
enterModule(n);
if (isGetModuleCall(n)) {
rewriteGetModuleCall(t, n);
if (inModule()) {
case Token.SCRIPT:
current.moduleScope = t.getScope();
case Token.BLOCK:
if (current.moduleScopeRoot == parent && parent.isFunction()) {
current.moduleScope = t.getScope();
case Token.ASSIGN:
if (isGetModuleCallAlias(n)) {
rewriteGetModuleCallAlias(t, n);
default:
if (current.moduleScopeRoot == parent && parent.isBlock()) {
current.moduleScope = t.getScope();
return true;
private static void checkStrictModeDirective(NodeTraversal t, Node n) {
Preconditions.checkState(n.isScript(), n);
Set<String> directives = n.getDirectives();
if (directives != null && directives.contains("use strict")) {
t.report(n, USELESS_USE_STRICT_DIRECTIVE);
if (directives == null) {
n.setDirectives(USE_STRICT_ONLY);
ImmutableSet.Builder<String> builder = new ImmutableSet.Builder<String>().add("use strict");
builder.addAll(directives);
n.setDirectives(builder.build());
private static boolean isCallTo(Node n, String qname) {
return n.isCall()
&& n.getFirstChild().matchesQualifiedName(qname);
private static boolean isLoadModuleCall(Node n) {
return isCallTo(n, "goog.loadModule");
private static boolean isGetModuleCall(Node n) {
return isCallTo(n, "goog.module.get");
private void rewriteGetModuleCall(NodeTraversal t, Node n) {
Node namespace = n.getSecondChild();
if (!namespace.isString()) {
t.report(namespace, INVALID_GET_IDENTIFIER);
if (!inModule() && t.inGlobalScope()) {
t.report(namespace, INVALID_GET_CALL_SCOPE);
Node replacement = NodeUtil.newQName(compiler, namespace.getString());
replacement.srcrefTree(namespace);
n.getParent().replaceChild(n, replacement);
compiler.reportCodeChange();
private void rewriteGetModuleCallAlias(NodeTraversal t, Node n) {
Preconditions.checkArgument(NodeUtil.isExprAssign(n.getParent()));
Preconditions.checkArgument(n.getFirstChild().isName());
Preconditions.checkArgument(isGetModuleCall(n.getLastChild()));
rewriteGetModuleCall(t, n.getLastChild());
String aliasName = n.getFirstChild().getQualifiedName();
Var alias = t.getScope().getVar(aliasName);
if (alias == null) {
t.report(n, INVALID_GET_ALIAS);
Node forwardDeclareCall = NodeUtil.getRValueOfLValue(alias.getNode());
if (forwardDeclareCall == null
|| !isCallTo(forwardDeclareCall, "goog.forwardDeclare")
|| forwardDeclareCall.getChildCount() != 2) {
t.report(n, INVALID_GET_ALIAS);
Node argument = forwardDeclareCall.getLastChild();
if (!argument.isString() || !n.getLastChild().matchesQualifiedName(argument.getString())) {
t.report(n, INVALID_GET_ALIAS);
Node replacement = NodeUtil.newQName(compiler, argument.getString());
replacement.srcrefTree(forwardDeclareCall);
forwardDeclareCall.getParent().replaceChild(forwardDeclareCall, replacement);
n.getParent().detachFromParent();
private void enterModule(Node n) {
current = new ModuleDescription(n);
private boolean inModule() {
return current != null;
private static boolean isGetModuleCallAlias(Node n) {
return NodeUtil.isExprAssign(n.getParent())
&& n.getFirstChild().isName() && isGetModuleCall(n.getLastChild());
public void visit(NodeTraversal t, Node n, Node parent) {
if (!inModule()) {
switch (n.getType()) {
case Token.EXPR_RESULT:
if (isCallTo(n.getFirstChild(),
"goog.module.declareLegacyNamespace")) {
n.detachFromParent();
break;
case Token.CALL:
if (isCallTo(n, "goog.module")) {
recordAndUpdateModule(t, n);
recordRequire(t, n);
rewriteModuleAsScope(n);
break;
case Token.GETPROP:
if (isExportPropAssign(n)) {
Node rhs = parent.getLastChild();
maybeUpdateExportDeclToNode(t, parent, rhs);
break;
case Token.NAME:
if (n.getString().equals("exports")) {
current.exports.add(n);
if (isAssignTarget(n)) {
maybeUpdateExportObjectDecl(t, n);
break;
case Token.SCRIPT:
rewriteModuleAsScope(n);
break;
case Token.RETURN:
if (parent == current.moduleStatementRoot) {
n.detachFromParent();
break;
private void maybeUpdateExportObjectDecl(NodeTraversal t, Node n) {
maybeUpdateExportDeclToNode(t, parent, rhs);
private void maybeUpdateExportDeclToNode(
NodeTraversal t, Node target, Node value) {
JSDocInfo info = target.getJSDocInfo();
if ((info != null && info.isConstructorOrInterface()
|| isCallTo(value, "goog.defineClass"))) {
return;
JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(info);
builder.recordConstancy();
target.setJSDocInfo(builder.build());
private static boolean isExportPropAssign(Node n) {
Preconditions.checkState(n.isGetProp(), n);
Node target = n.getFirstChild();
return isAssignTarget(n) && target.isName()
&& target.getString().equals("exports");
private static boolean isAssignTarget(Node n) {
Node parent = n.getParent();
return parent.isAssign() && parent.getFirstChild() == n;
private void recordAndUpdateModule(NodeTraversal t, Node call) {
Node idNode = call.getLastChild();
if (!idNode.isString()) {
t.report(idNode, INVALID_MODULE_IDENTIFIER);
current.moduleNamespace = idNode.getString();
current.moduleDecl = call;
Node target = call.getFirstChild();
target.getLastChild().setString("provide");
current.provides.add(call);
private void recordRequire(NodeTraversal t, Node call) {
Node idNode = call.getLastChild();
if (!idNode.isString()) {
t.report(idNode, INVALID_REQUIRE_IDENTIFIER);
current.requires.add(call);
private void updateRequires(List<Node> requires) {
for (Node node : requires) {
updateRequire(node);
private void updateRequire(Node call) {
if (call.getParent().isExprResult()) {
String namespace = call.getLastChild().getString();
if (current.requireInsertNode == null) {
current.requireInsertNode = getInsertRoot(call);
Node replacement = NodeUtil.newQName(compiler, namespace).srcrefTree(call);
call.getParent().replaceChild(call, replacement);
Node require = IR.exprResult(call).srcref(call);
Node insertAt = current.requireInsertNode;
insertAt.getParent().addChildBefore(require, insertAt);
private List<String> collectRoots(ModuleDescription module) {
List<String> result = new ArrayList<>();
for (Node n : module.provides) {
result.add(getRootName(n.getSecondChild()));
for (Node n : module.requires) {
result.add(getRootName(n.getSecondChild()));
return result;
private String getRootName(Node n) {
String qname = n.getString();
int endPos = qname.indexOf('.');
return (endPos == -1) ? qname : qname.substring(0, endPos);
private void rewriteModuleAsScope(Node root) {
Node moduleRoot = current.moduleStatementRoot;
Node srcref = current.moduleDecl != null ? current.moduleDecl : root;
ImmutableSet<String> roots = ImmutableSet.copyOf(collectRoots(current));
updateRootShadows(current.moduleScope, roots);
updateRequires(current.requires);
updateExports(current.exports);
Node block = IR.block();
Node scope = IR.exprResult(IR.call(
IR.getprop(IR.name("goog"), IR.string("scope")),
IR.function(IR.name(""), IR.paramList(), block)))
.srcrefTree(srcref);
Node fromNode = skipHeaderNodes(moduleRoot);
Preconditions.checkNotNull(fromNode);
moveChildrenAfter(fromNode, block);
moduleRoot.addChildAfter(scope, fromNode);
if (root.isCall()) {
Node expr = root.getParent();
Preconditions.checkState(expr.isExprResult(), expr);
expr.getParent().addChildrenAfter(moduleRoot.removeChildren(), expr);
expr.detachFromParent();
compiler.reportCodeChange();
current = null;
private void updateExports(List<Node> exports) {
for (Node n : exports) {
Node replacement = NodeUtil.newQName(compiler, current.moduleNamespace);
replacement.srcrefTree(n);
n.getParent().replaceChild(n, replacement);
private void updateRootShadows(Scope s, ImmutableSet<String> roots) {
final Map<String, String> nameMap = new HashMap<>();
for (String root : roots) {
if (s.getOwnSlot(root) != null) {
nameMap.put(root, root + "_module");
if (nameMap.isEmpty()) {
return;
NodeTraversal.traverseEs6(compiler, s.getRootNode(), new AbstractPostOrderCallback() {
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isName()) {
String rename = nameMap.get(n.getString());
if (rename != null) {
n.setString(rename);
private Node getModuleScopeRootForLoadModuleCall(Node n) {
Preconditions.checkState(n.isCall(), n);
Node fn = n.getLastChild();
Preconditions.checkState(fn.isFunction());
return fn.getLastChild();
private Node getModuleStatementRootForLoadModuleCall(Node n) {
Node scopeRoot = getModuleScopeRootForLoadModuleCall(n);
if (scopeRoot.isFunction()) {
return scopeRoot.getLastChild();
return scopeRoot;
private Node skipHeaderNodes(Node script) {
Node lastHeaderNode = null;
Node child = script.getFirstChild();
while (child != null && isHeaderNode(child)) {
lastHeaderNode = child;
child = child.getNext();
return lastHeaderNode;
private boolean isHeaderNode(Node n) {
if (n.isEmpty()) {
return true;
if (NodeUtil.isExprCall(n)) {
Node target = n.getFirstFirstChild();
return (
target.matchesQualifiedName("goog.module")
|| target.matchesQualifiedName("goog.provide")
|| target.matchesQualifiedName("goog.require")
|| target.matchesQualifiedName("goog.setTestOnly"));
return false;
private void moveChildrenAfter(Node fromNode, Node targetBlock) {
Node parent = fromNode.getParent();
while (fromNode.getNext() != null) {
Node child = parent.removeChildAfter(fromNode);
targetBlock.addChildToBack(child);
private Node getInsertRoot(Node n) {
while (n.getParent() != current.moduleStatementRoot) {
n = n.getParent();
return n;
return n.isVar() && isWhitelistedName(n.getFirstChild().getString());
return name.equals("$jscomp") || name.startsWith("$jscomp$compprop");
CheckProvides.MISSING_PROVIDE_WARNING);
ProcessClosurePrimitives.LATE_PROVIDE_ERROR);
testSame(
EXTERNS,
testSame(
EXTERNS,
testSame(
"goog.provide('x');");
testSame(
EXTERNS,
testSame(
EXTERNS,
"/** @constructor */foo.bar.Baz = function(){};",
testSame(
testSame(
testSame(
EXTERNS,
testSame(
testSame(
testSame(
EXTERNS,
testSame(
testSame(
testSame("goog.provide('foo.bar');");
testSame(
testSame("var foo");
testSame("var foo = 42;");
testSame("goog.provide('foo');\n" +
"'use strict'; /** @const */ var foo={};",
"/** \n"
+ "* @fileoverview \n"
+ "* @suppress {missingProvide,missingRequire}\n"
+ "*/\n"
+ ""
+ "'use strict';"
+ " /** @const */ var module$testcode={};"
+ "var x$$module$testcode=2;module$testcode.x=x$$module$testcode;",
private void testError(String[] js, DiagnosticType error) {
test(js, null, error);
import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_GET_IDENTIFIER;
import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_MODULE_IDENTIFIER;
import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_REQUIRE_IDENTIFIER;
"goog.provide('a');" +
"goog.scope(function(){});");
"goog.module('ns.a');" +
"var b = goog.require('ns.b');",
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
LINE_JOINER.join(
"goog.module('ns.a');",
"var {foo, bar} = goog.require('ns.b');"),
LINE_JOINER.join(
"goog.provide('ns.a');",
"goog.require('ns.b');",
"goog.scope(function(){",
"  var {foo, bar} = ns.b;",
"});"));
LINE_JOINER.join(
"goog.module('ns.a');",
"const {foo, bar} = goog.require('ns.b');"),
LINE_JOINER.join(
"goog.provide('ns.a');",
"goog.require('ns.b');",
"goog.scope(function(){",
"  const {foo, bar} = ns.b;",
"});"));
"goog.module('ns.a');"
+ "goog.module.declareLegacyNamespace();"
+ "var b = goog.require('ns.b');",
"goog.provide('ns.a');"
+ "goog.require('ns.b');"
+ "goog.scope(function(){"
+ "  var b = ns.b;"
+ "});");
LINE_JOINER.join(
"goog.loadModule(function(exports) {",
"  goog.module('ns.a');",
"  var b = goog.require('ns.b');",
"  return exports;",
"});"),
LINE_JOINER.join(
"goog.provide('ns.a');",
"goog.require('ns.b');",
"goog.scope(function() {",
"  var b = ns.b;",
"});"));
"goog.provide('ns.a');",
"goog.require('ns.b');",
"goog.scope(function() {",
"  var b = ns.b;",
"});",
"goog.provide('ns.c');",
"goog.require('ns.b');",
"goog.scope(function() {",
"  var b = ns.b;",
"});"));
"'use strict';",
"goog.require('ns.b');",
"goog.scope(function() {",
"  var b = ns.b;",
"});"));
"'use strict';",
"goog.provide('ns.a');",
"goog.require('goog.asserts');",
"goog.scope(function() {",
"  var b = goog.asserts;",
"});"));
"goog.require('goog.asserts');",
"  var asserts = goog.asserts;",
"  /** @const */ xid = function(id) {",
"    return xid_module.internal_(id);",
"  };",
"  var xid_module = xid;",
public void testAliasShadowsGlobal1() {
"goog.module('ns.a');",
"var b = goog.require('b');",
"var c = new b();"),
"goog.provide('ns.a');",
"goog.require('b');",
"goog.scope(function(){",
"  var b_module = b;",
"  var c = new b_module();",
"});"));
public void testAliasShadowsGlobal2() {
"goog.module('a'); goog.require('b'); var a,b,c;",
"goog.provide('a');",
"goog.require('b');",
"goog.scope(function() {",
"  var a_module, b_module, c;",
"});"));
public void testAliasShadowsGlobal3() {
"goog.module('a.c'); goog.require('b.c'); var a,b,c;",
"goog.provide('a.c');",
"goog.require('b.c');",
"goog.scope(function() {",
"  var a_module, b_module, c;",
"});"));
"goog.module('a'); this;",
"goog.provide('a');"
+ "goog.scope(function(){this});");
testError("goog.module(a);", INVALID_MODULE_IDENTIFIER, PARSE_ERROR);
testError("goog.module('ns.a');" + "goog.require(a);", INVALID_REQUIRE_IDENTIFIER, PARSE_ERROR);
"function f() { var x = goog.module.get('a'); }",
"function f() { var x = a; }");
"function f() { var x = goog.module.get('a.b.c'); }",
"function f() { var x = a.b.c; }");
LINE_JOINER.join(
"goog.module('a');",
"",
"var x = goog.forwardDeclare('b');",
"function f() { x = goog.module.get('b'); }"),
LINE_JOINER.join(
"goog.provide('a'); goog.scope(function(){",
"  var x = b;",
"  function f() {}",
"});"));
"goog.module('a');",
"",
"var x = goog.forwardDeclare('x.y.z');",
"function f() { x = goog.module.get('x.y.z'); }"),
"goog.provide('a'); goog.scope(function(){",
"  var x = x.y.z;",
"  function f() {}",
"});"));
public void testInvalidGoogModeuleGetAlias() {
testError("goog.module('a'); x = goog.module.get('g');", INVALID_GET_ALIAS);
testError("goog.module('a'); var x; x = goog.module.get('g');", INVALID_GET_ALIAS);
"goog.module('a'); var x = goog.forwardDeclare(); x = goog.module.get('g');",
"goog.module('a'); var x = goog.forwardDeclare('z'); x = goog.module.get('g');",
testError("function f() {" + "goog.module.get(a);" + "}", INVALID_GET_IDENTIFIER);
testError("goog.module.get('a');", INVALID_GET_CALL_SCOPE);
"goog.module('ns.a');" +
"exports = {};",
"goog.provide('ns.a');" +
"goog.scope(function(){" +
"  /** @const */ ns.a = {};" +
"});");
"goog.module('ns.a');" +
"exports.x = 1;",
"goog.provide('ns.a');" +
"goog.scope(function(){" +
"  /** @const */ ns.a.x = 1;" +
"});");
"goog.module('xid');" +
"var xid = function() {};" +
"exports = xid;",
"goog.provide('xid');" +
"goog.scope(function(){" +
"  var xid_module = function() {};" +
"  /** @const */ xid = xid_module;" +
"});");
"goog.module('ns.a');" +
"exports = { something: 1 };",
"goog.provide('ns.a');" +
"goog.scope(function(){" +
"  /** @const */ ns.a = { /** @const */ something: 1 };" +
"});");
"goog.module('ns.a');"
+ "/** @typedef {string} */ var x;"
+ "exports.x = x;",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  /** @typedef {string} */ var x;"
+ "  /** @typedef {string} */ ns.a.x = x;"
+ "});");
"goog.module('ns.a');"
+ "/** @typedef {string} */ var x;"
+ "exports = { something: x };",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  /** @typedef {string} */ var x;"
+ "  /** @const */ ns.a = { /** @typedef {string} */ something: x };"
+ "});");
public void testExport7() {
"goog.module('ns.a');"
+ "/** @constructor */"
+ "exports = function() {};",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  /** @constructor */ ns.a = function() {};"
+ "});");
public void testExport8() {
"goog.module('ns.a');"
+ "exports = goog.defineClass({});",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  ns.a = goog.defineClass({});"
+ "});");
"goog.module('ns.a');" +
"exports = { something };",
"goog.provide('ns.a');" +
"goog.scope(function(){" +
"  /** @const */ ns.a = { /** @const */ something };" +
"});");
"goog.module('ns.a');" +
"exports = { [something]: 3 };",
ClosureRewriteModule.INVALID_EXPORT_COMPUTED_PROPERTY);
public void testRequiresRetainOrder() {
"goog.module('ns.a');" +
"var b = goog.require('ns.b');" +
"var c = goog.require('ns.c');",
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.require('ns.c');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"  var c = ns.c;" +
"});");
"goog.module('ns.a');" +
"goog.setTestOnly();" +
"var b = goog.require('ns.b');",
"goog.provide('ns.a');" +
"goog.setTestOnly();" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
"/** @constructor */ function Hello() {} " +
"module.exports = Hello;",
"var Hello = require('./i0');" +
"var hello = new Hello();"
"function Hello$$module$i0(){}" +
"var module$i0 = Hello$$module$i0;",
"var Hello = Hello$$module$i0;" +
"var hello = new Hello();"
new String[] {
"/** @constructor */ function Hello() {} " +
"/** @type {!Hello} */ var hello = new Hello();" +
"module.exports = Hello;"
new String[] {
"function Hello$$module$i0(){}" +
"var hello$$module$i0 = new Hello$$module$i0();" +
"var module$i0 = Hello$$module$i0;"
"/** @constructor */ function Hello() {} " +
"module.exports = Hello;",
"var Hello = require('./i0');" +
"/** @type {!Hello} */ var hello = new Hello();"
"function Hello$$module$i0(){}" +
"var module$i0 = Hello$$module$i0;",
"var Hello = Hello$$module$i0;" +
"var hello = new Hello();"
"/** @constructor */ function Hello() {} ",
"/** @constructor */ function Bar() {} ",
"show.foobar();")
"function Hello$$module$i0(){} ",
"Bar$$module$i0.prototype.foobar=function(){alert(\"foobar\")};",
"module$i0=Bar$$module$i0;"),
"show.foobar();")
"/** @constructor */ function Hello() {} ",
"show.foobar();")
"Bar$$module$i0.prototype.foobar=function(){alert(\"foobar\")};",
"module$i0.foo=Bar$$module$i0;"),
"show.foobar();")
"/** @constructor */ function Hello() {} ",
"show.foobar();")
"Bar$$module$i0.prototype.foobar=function(){alert(\"foobar\")};",
"module$i0.foo=Bar$$module$i0;"),
"show.foobar();")
LINE_JOINER.join(
"/** @constructor */ function Hello() {} ",
"module.exports = Hello;"),
LINE_JOINER.join(
"var Hello = require('./i0');",
"var util = {inherits: function (x, y){}};",
"/**",
" * @constructor",
" * @extends {Hello}",
" */",
"var SubHello = function () {};",
"util.inherits(SubHello, Hello);")
"function Hello$$module$i0(){}",
"var module$i0=Hello$$module$i0;"),
"var util = {inherits: function (x, y){}};",
"var SubHello = function () {};",
"util.inherits(SubHello, Hello);")
"/** @constructor */ function Hello() {} ",
"util.inherits(SubHello, Hello);")
"var module$i0=Hello$$module$i0;"),
"var util = {inherits:function(x,y){}};",
"util.inherits(SubHello, Hello);")
"util.inherits(SubHello, Hello);")
"var module$i0=Hello$$module$i0;"),
"var util = {inherits:function(x,y){}};",
"util.inherits(SubHello, Hello);")
"var util = {inherits: function (x, y){}};",
"util.inherits(SubHello, i0.Hello);")
"var module$i0={Hello: Hello$$module$i0};"),
"var util = {inherits:function(x,y){}};",
"util.inherits(SubHello,i0.Hello);")
"/** @constructor */ function Hello() {} ",
"util.inherits(SubHello, Hello);")
"var module$i0=Hello$$module$i0;"),
"var util = {inherits:function(x,y){}};",
"util.inherits(SubHello, Hello);")
"/** @constructor */ function Hello() {} ",
"util.inherits(SubHello, i0.Hello);")
"var module$i0={Hello: Hello$$module$i0};"),
"util.inherits(SubHello, i0.Hello);")
assertEquals("There should be one error. " + errorMsg, 1, compiler.getErrorCount());
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"/** @const */ var base = $jscomp.scope.Base;")),
"/** @const */ var leaf =",
"  /** @constructor @extends {$jscomp.scope.Base} */ function Foo(){}"))));
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
" /** @const */ var ns = {}; ",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
"/** @const */ var leaf =",
"  /** @constructor @extends {$jscomp.scope.Base} */function Foo(){}"))));
"/** @constructor */ Base.Foo = function(){};",
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"/** @const */ var ns = {}; ",
"/** @constructor */ $jscomp.scope.Base = function(){}",
"/** @constructor */ $jscomp.scope.Base.Foo = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
" /**@const*/ var leaf =",
"  /**@constructor @extends {$jscomp.scope.Base.Foo}*/function Foo(){}"))));
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"/** @const */ var ns = {}; ",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
"/** @const */ var leaf = new $jscomp.scope.Base;")));
"/**@const */var $jscomp = {}; /**@const */$jscomp.scope = {};",
"/**@interface */$jscomp.scope.B = /**@interface */function() {};",
"$jscomp.scope.B.prototype.f = function() {};",
"/** @const */var mod_B = $jscomp.scope.B;")),
"/**@const */var mod_A = {};",
"/**@type {$jscomp.scope.B} */$jscomp.scope.b;"))));
"/**@const */var $jscomp = {}; /**@const */$jscomp.scope = {};",
"/**@interface */$jscomp.scope.B = /**@interface */function() {};",
"/** @const */var mod_B = $jscomp.scope.B;")),
"/**@const */var mod_A = {};",
"$jscomp.scope.B.prototype;",
"/**@type {$jscomp.scope.B} */$jscomp.scope.b;"))));
"/** @define {boolean} */ var COMPILED = false; var goog = {};" +
"goog.exportSymbol = function() {};";
test(options, CLOSURE_BOILERPLATE + "goog.provide('FOO.BAR'); FOO.BAR = 3;",
CLOSURE_COMPILED + "var FOO$BAR = 3;");
"/** @define{foo.bar} */ foo.bar = {};" };
"goog.provide('foo.Bar.Type');\n"
+ "goog.provide('foo.Bar');\n"
+ "/** @typedef {number} */ foo.Bar.Type;\n"
+ "foo.Bar = function() {};",
"var foo = {}; foo.Bar.Type; foo.Bar = function() {};");
"goog.provide('foo.Bar.Type');\n"
+ "goog.provide('foo.Bar');\n"
+ "/** @typedef {number} */ foo.Bar.Type;\n"
+ "foo.Bar = function() {};",
"var foo$Bar$Type; var foo$Bar = function() {};");
"var goog = {};",
"goog.provide('goog.testing.testSuite');\n"
+ "goog.testing.testSuite = function(a) {};\n",
" goog.module('testing');\n"
+ "var testSuite = goog.require('goog.testing.testSuite');\n"
+ "testSuite({testMethod:function(){}});\n"
"",
"var $goog$testing$testSuite$$=function($a$$){};",
"$goog$testing$testSuite$$({\"testMethod\":function(){}})"
CLOSURE_BOILERPLATE + "goog.provide('Foo'); /** @constructor */ Foo = function() {};"
+ "var x = new Foo();",
"var COMPILED=true;var goog={};goog.exportSymbol=function(){};"
+ "var Foo=function(){};var x=new Foo");
test(options,
"var goog = {}; goog.provide('foo'); "
+ "function f() { foo = {};}",
"var foo = {}; function f() { foo = {}; }", ConstCheck.CONST_REASSIGNED_VALUE_ERROR);
"var goog = {}; goog.provide('foo.bar'); "
+ "function f() { foo.bar = {};}",
"var foo$bar = {};"
+ "function f() { foo$bar = {}; }",
test(options, "goog.provide('x');\ngoog.require('x');", "var x = {};");
assertThat(compiler.getErrors()).isEmpty();for (JSError warning : compiler.getWarnings()) {static TernaryValue evaluateComparison(int op, Node left, Node right, boolean useTypes) {
if (NodeUtil.mayHaveSideEffects(left) || NodeUtil.mayHaveSideEffects(right)) {
return TernaryValue.UNKNOWN;
if (op == Token.SHEQ || op == Token.SHNE) {
if (leftValueType != rightValueType) {
return TernaryValue.forBoolean(op != Token.SHEQ);
return TernaryValue.forBoolean(op == Token.SHEQ);
if (op == Token.EQ || op == Token.NE) {
switch (leftValueType) {
case OBJECT:
case NUMBER:
case BOOLEAN:
case STRING:
if (rightValueType == ValueType.NULL || rightValueType == ValueType.VOID) {
return TernaryValue.forBoolean(op != Token.EQ);
break;
case NULL:
case VOID:
if (rightValueType == ValueType.NULL || rightValueType == ValueType.VOID) {
return TernaryValue.forBoolean(op == Token.EQ);
return TernaryValue.forBoolean(op != Token.EQ);
default:
throw new IllegalStateException("unexpected");
if (leftValueType == ValueType.VOID || rightValueType == ValueType.VOID) {
switch (op) {
case Token.GE:
case Token.LE:
case Token.GT:
case Token.LT:
return TernaryValue.FALSE;
int lhType = getNormalizedNodeType(left);
int rhType = getNormalizedNodeType(right);
switch (lhType) {
case Token.NULL:
case Token.TRUE:
case Token.FALSE:
boolean rhIsBooleanLike =
rhType == Token.TRUE || rhType == Token.FALSE || rhType == Token.NULL;
switch (op) {
case Token.SHEQ:
case Token.EQ:
return rhIsBooleanLike
? TernaryValue.forBoolean(lhType == rhType) : TernaryValue.UNKNOWN;
case Token.SHNE:
case Token.NE:
return rhIsBooleanLike
? TernaryValue.forBoolean(lhType != rhType) : TernaryValue.UNKNOWN;
case Token.GE:
case Token.LE:
case Token.GT:
case Token.LT:
return compareAsNumbers(op, left, right, useTypes);
return TernaryValue.UNKNOWN;
case Token.THIS:
if (right.isThis()) {
switch (op) {
case Token.SHEQ:
case Token.EQ:
return TernaryValue.TRUE;
case Token.SHNE:
case Token.NE:
return TernaryValue.FALSE;
return TernaryValue.UNKNOWN;
case Token.STRING:
if (right.isString()) {
switch (op) {
case Token.SHEQ:
case Token.EQ:
return areStringsEqual(left.getString(), right.getString());
case Token.SHNE:
case Token.NE:
return areStringsEqual(left.getString(), right.getString()).not();
return TernaryValue.UNKNOWN;
case Token.NUMBER:
if (right.isNumber()) {
return compareAsNumbers(op, left, right, useTypes);
return TernaryValue.UNKNOWN; // Only eval if they are the same type
case Token.NAME:
if (right.isName()) {
if (left.getString().equals(right.getString())) {
switch (op) {
case Token.LT:
case Token.GT:
return TernaryValue.FALSE;
return TernaryValue.UNKNOWN;
default:
return TernaryValue.UNKNOWN;
private static TernaryValue areStringsEqual(String a, String b) {
if (a.indexOf('\u000B') != -1 || b.indexOf('\u000B') != -1) {
return TernaryValue.UNKNOWN;
return a.equals(b) ? TernaryValue.TRUE : TernaryValue.FALSE;
private static int getNormalizedNodeType(Node n) {
int type = n.getType();
if (type == Token.NOT) {
TernaryValue value = NodeUtil.getPureBooleanValue(n);
switch (value) {
case TRUE:
return Token.TRUE;
case FALSE:
return Token.FALSE;
case UNKNOWN:
return type;
return type;
private static TernaryValue compareAsNumbers(int op, Node left, Node right, boolean useTypes) {
Double leftValue = NodeUtil.getNumberValue(left, useTypes);
if (leftValue == null) {
Double rightValue = NodeUtil.getNumberValue(right, useTypes);
if (rightValue == null) {
return TernaryValue.UNKNOWN;
double lv = leftValue;
double rv = rightValue;
case Token.EQ:
Preconditions.checkState(
left.isNumber() && right.isNumber());
return TernaryValue.forBoolean(lv == rv);
case Token.NE:
Preconditions.checkState(
left.isNumber() && right.isNumber());
return TernaryValue.forBoolean(lv != rv);
return TernaryValue.forBoolean(lv <= rv);
case Token.LT:
return TernaryValue.forBoolean(lv <  rv);
return TernaryValue.forBoolean(lv >= rv);
case Token.GT:
return TernaryValue.forBoolean(lv >  rv);
default:
return TernaryValue.UNKNOWN;  // don't handle that op
sb.append(Pattern.quote(function) + "|");
sb.append(code.substring(lastIndex));
sb.append("Replacements for file: " + entry.getKey() + "\n");
foldSame("0 < null"); // foldable
foldSame("'hi' >= null"); // foldable
fold("x = y == y", "x = y==y");
foldSame("NaN == NaN");
foldSame("Infinity == Infinity");
foldSame("Infinity == NaN");
foldSame("Infinity >= Infinity");
foldSame("NaN >= NaN");
foldSame(join(a, op, b));
foldSame(join(a, inverse, b));
assertSameResultsOrUncollapsed(join(a, op, b), join(b, op, a));
private void assertSameResultsOrUncollapsed(String exprA, String exprB) {
String resultA = process(exprA);
if (resultA.equals(print(exprA))) {
foldSame(exprA);
foldSame(exprB);
assertSameResults(exprA, exprB);
private String print(String js) {
return printHelper(js, false);
foldSame("switch (0) {\n" +
"}");Preconditions.checkState(parent.isBlock() || parent.isFor()
|| parent.isForOf() || parent.isScript() || parent.isLabel());
assertFalse(globalScope.isDeclared("x", false));"Module idenifiers must be string literals");Scope scope = t.getScope();
Node parent = t.getScopeRoot();
if (parent.isFunction()) {
parent = parent.getLastChild();
if (parent.isSyntheticBlock() && parent.getFirstChild().isScript()) {
parent = parent.getFirstChild();
CompilerInput input = compiler.getInput(parent.getInputId());
Node argumentsVar = IR.declaration(name, IR.name("arguments"), Token.CONST);
argumentsVar.useSourceInfoIfMissingFromForTree(parent);
parent.addChildToFront(argumentsVar);
Node thisVar = IR.declaration(name, IR.thisNode(), Token.CONST);
thisVar.useSourceInfoIfMissingFromForTree(parent);
parent.addChildToFront(thisVar);
"    const $jscomp$this = this;",JSDocInfo fnJSDoc = function.getJSDocInfo();JSType restrictedReplacement = replacement.restrictByNotNullOrUndefined();
if (restrictedReplacement.isTemplatizedType()) {
Iterable<JSType> replacementTemplateTypes =
restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes();
for (JSType replacementTemplateType : replacementTemplateTypes) {
if (!replacementTemplateType.differsFrom(type)) {
return type;import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ModificationVisitor;
import com.google.javascript.rhino.jstype.TemplateType;
import com.google.javascript.rhino.jstype.TemplateTypeMap;
if (restrictedReplacement.isTemplatizedType()
&& restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
return type;"JSC_MISSING_REQUIRE_WARNING", "''{0}'' used but not required");
"''{0}'' required but not used");
"''{0}'' required more than once.");
&& (var.isExtern()
|| var.getSourceFile() == newNode.getStaticSourceFile())) {
if (mode == Mode.SINGLE_FILE && extendClass.isName()) {
weakUsages.put(extendClass.getString(), extendClass);
return;
Class<?> paramClasses[] = ctor.getParameterTypes();
makeIterator(compiler, rhs.detachFromParent()));
makeIterator(compiler, n.removeFirstChild()));
Node init = IR.var(iterName.cloneTree(), makeIterator(compiler, iterable));
groups.add(arrayFromIterable(compiler, currElement.removeFirstChild()));
static Node makeIterator(AbstractCompiler compiler, Node iterable) {
private static Node arrayFromIterable(AbstractCompiler compiler, Node iterable) {
return callEs6RuntimeFunction(compiler, iterable, "arrayFromIterable");
private static final String GLOBAL_THIS_NAMES[] = {
if (n.isName() || (n.isStringKey() && !n.hasChildren())) {
String varName = n.getString();
if (varName.isEmpty()) {
Preconditions.checkState(parent.isFunction());
Preconditions.checkState(NodeUtil.isFunctionExpression(parent));
return;
if ((parent.isVar()
|| NodeUtil.isFunctionDeclaration(parent))
&& varsToDeclareInExterns.contains(varName)) {
createSynthesizedExternVar(varName);
JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(n.getJSDocInfo());
builder.addSuppression("duplicate");
n.setJSDocInfo(builder.build());
Scope scope = t.getScope();
Var var = scope.getVar(varName);
if (var == null) {
if (NodeUtil.isFunctionExpression(parent) || NodeUtil.isClassExpression(parent)) {
boolean isArguments = scope.isLocal() && ARGUMENTS.equals(varName);
if (!isArguments && !(strictExternCheck && t.getInput().isExtern())) {
t.report(n, UNDEFINED_VAR_ERROR, varName);
if (sanityCheck) {
throw new IllegalStateException("Unexpected variable " + varName);
createSynthesizedExternVar(varName);
scope.getGlobalScope().declare(varName, n, compiler.getSynthesizedExternsInput());
return;
CompilerInput currInput = t.getInput();
CompilerInput varInput = var.input;
if (currInput == varInput || currInput == null || varInput == null) {
return;
JSModule currModule = currInput.getModule();
JSModule varModule = varInput.getModule();
JSModuleGraph moduleGraph = compiler.getModuleGraph();
if (!sanityCheck && varModule != currModule && varModule != null && currModule != null) {
if (moduleGraph.dependsOn(currModule, varModule)) {
if (scope.isGlobal()) {
if (moduleGraph.dependsOn(varModule, currModule)) {
t.report(n, VIOLATED_MODULE_DEP_ERROR,
currModule.getName(), varModule.getName(), varName);
t.report(n, MISSING_MODULE_DEP_ERROR,
currModule.getName(), varModule.getName(), varName);
t.report(n, STRICT_MODULE_DEP_ERROR,
String tokens[] = sourceMapLocationMapping.split("\\|", -1);
public static final DiagnosticType CONSTRUCTOR_DISALLOWED_JSDOC =
DiagnosticType.warning("JSC_CONSTRUCTOR_DISALLOWED_JSDOC",
"Visibility annotations on constructors are not supported.\n"
+ "Please mark the visibility on the class instead.");
visitFunction(t, n, parent);
private void visitFunction(NodeTraversal t, Node function, Node parent) {
if (parent.isMemberFunctionDef()
&& "constructor".equals(parent.getString())
&& jsDoc != null
&& !jsDoc.getVisibility().equals(Visibility.INHERITED)) {
t.report(function, CONSTRUCTOR_DISALLOWED_JSDOC);
Pattern.compile("'([^']+)' used but not required");
Pattern.compile("'([^']+)' required but not used");
"  var $jscomp$destructuring$var0 = $jscomp.makeIterator(arguments);",
"/** @constructor @template T */",
"function Arguments() {}",
"",
"/**",
" * @constructor",
" * @param {...*} var_args",
" * @return {!Array}",
" * @template T",
" */",
"function Array(var_args) {}",
"",
"/** @constructor @template T */",
"function Iterable() {}",
"",
"/** @constructor @template T */",
"function Iterator() {}",
"",
"Iterator.prototype.next = function() {};",
"",
"/**",
" * @record",
" * @template VALUE",
" */",
"function IIterableResult() {}",
"",
"/** @type {boolean} */",
"IIterableResult.prototype.done;",
"",
"/** @type {VALUE} */",
"IIterableResult.prototype.value;",
"",
"/**",
" * @param {function(new: ?)} subclass",
" * @param {function(new: ?)} superclass",
" */",
"$jscomp.inherits = function(subclass, superclass) {};",
"",
"/**",
" * @param {string|!Array<T>|!Iterable<T>|!Iterator<T>|!Arguments<T>} iterable",
" * @return {!Iterator<T>}",
" * @template T",
" */",
"$jscomp.makeIterator = function(iterable) {};",
"",
"/**",
" * @param {string|!Array<T>|!Iterable<T>|!Iterator<T>|!Arguments<T>} iterable",
" * @return {!Array<T>}",
" * @template T",
" */",
"$jscomp.arrayFromIterable = function(iterable) {};");
public Es6ToEs3ConverterTest() {
super(EXTERNS_BASE);
"(new Sub).f();"));
testWarning(
"$jscomp.inherits(Sub, Foo);"));
"  return [].concat($jscomp.arrayFromIterable(arguments));",
"  return [].concat($jscomp.arrayFromIterable(arguments), [2]);",
public void testArgumentsEscaped() {
public void testForOfOnNonIterable() {
enableTypeCheck();
testWarning(
LINE_JOINER.join(
"var arrayLike = {",
"  0: 'x',",
"  1: 'y',",
"  length: 2,",
"};",
"for (var x of arrayLike) {}"),
TypeValidator.TYPE_MISMATCH_WARNING);
testWarning(
test(
LINE_JOINER.join(
"class C { m(a) {} }",
"class Factory {",
"  /** @return {C} */",
"  static create() {return new C()}",
"}",
"var arr = [1,2]",
"Factory.create().m(...arr);"),
LINE_JOINER.join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.m = function(a) {};",
"/** @constructor @struct */",
"var Factory = function() {};",
"/** @return {C} */",
"Factory.create = function() {return new C()};",
"var arr = [1,2]",
"var $jscomp$spread$args0;",
"($jscomp$spread$args0 = Factory.create()).m.apply(",
"    $jscomp$spread$args0, [].concat($jscomp.arrayFromIterable(arr)));"));
String[] js = new String[] {"goog.provide('foo'); var bar = new foo.bar();"};
String warning = "'foo.bar' used but not required";
String warning = "'goog.foo.Bar.Inner' used but not required";
String warning = "'SomethingWithoutNS' used but not required";
new String[] {
"goog.require('goog.foo.Bar'); var str = new goog.foo.Bar(new goog.foo.Baz('5'));"
String warning = "'goog.foo.Baz' used but not required";
String warning = "'example.Foo' used but not required";
String warning = "'some.other.Interface' used but not required";
String warning = "'example.Foo' used but not required";
String warning = "'Foo' used but not required";
String warning = "'tempCtor' used but not required";
String warning = "'Bar' used but not required";
String warning = "'Baz' used but not required";
String warning = "'Bar' used but not required";
LINE_JOINER.join("goog.require('Foo');", "var foo = new Foo();"),
String warning = "'Bar' used but not required";
String js = "goog.provide('foo'); var bar = new foo.bar.goo();";
String expectation = "'foo.bar.goo' used but not required";
String warning = "'goog.Forgot' used but not required";
String warning = "'foo.Bar' used but not required";
String warning = "'foo.Bar' used but not required";
String warning = "'foo.bar.Baz' used but not required";
String warning = "'foo.Atom' used but not required";
public void testReferenceToLocalNamespace() {
testSame(
LINE_JOINER.join(
"/** @constructor */ function FooBar() {};",
"FooBar.Subclass = constructorFactory();",
"new FooBar.Subclass();"));
String warning = "'example.X' used but not required";
public void testCtorExtendsSingleName() {
public void testClassExtendsSingleName() {
testSameEs6("class MyFoo extends Foo {}");
testSameEs6("class MyError extends Error {}");
testSameEs6("class MyArray extends Array {}");
public void testShorthandObjLit() {
testErrorEs6("var x = {y};", VarCheck.UNDEFINED_VAR_ERROR);
testSameEs6("var {x} = {x: 5}; let y = x;");
testSame("var y; try { y=1 } catch (x) {} try { y=1 } catch (x) {}");
import static com.google.javascript.jscomp.lint.CheckJSDocStyle.CONSTRUCTOR_DISALLOWED_JSDOC;
testSame("/** @export */ class Foo { constructor(/** string */ inlineArg) {} }");
public void testConstructorsDontHaveVisibility() {
testSame(inIIFE("/** @private */ class Foo { constructor() {} }"));
testWarning(
inIIFE("class Foo { /** @private */ constructor() {} }"), CONSTRUCTOR_DISALLOWED_JSDOC);&& (var.isLocal()
|| var.isExtern()
|| qNameNode.isName() && var.getSourceFile() == newNode.getStaticSourceFile())) {
"var goog = {};",
"var goog = {};",
"var goog = {};",
String[] js = new String[] {"var foo = {}; var bar = new foo.bar();"};
"var goog = {};",
"var goog = {};",
"var goog = {};",
"var goog = {};",
new String[] {"var goog = {}; goog.require('goog.foo.Bar'); "
+ "var str = new goog.foo.Bar(new goog.foo.Baz('5')); "};
"var goog = {};",
"var goog = {};",
LINE_JOINER.join("var goog = {};", "goog.require('Foo');", "var foo = new Foo();"),
"var goog = {};",
String js = "var foo = {}; var bar = new foo.bar.goo();";
"var goog = {};",
"var goog = {};",
"var goog = {};",public static List<SourceFile> getBuiltinExterns(CompilerOptions options)
CompilerOptions.Environment env = options.getEnvironment();
List<SourceFile> builtinExterns = getBuiltinExterns(options);
return getBuiltinExterns(new CompilerOptions());
return CommandLineRunner.getBuiltinExterns(options);
.addExterns(CommandLineRunner.getBuiltinExterns(options))DiagnosticGroups.registerGroup("suspiciousCode",
this.languageIn = CompilerOptions.LanguageMode.ECMASCRIPT3;
super.enableNormalize();
super.enableLineNumberCheck(false);
compareJsDoc = false;
String src =
"/** @constructor */" +
"function Person(){}; Person.prototype.run = function(a, b) {};" +
"Person.run(1, 'a'); Person.run(2, 'a')";
String expected =
"function Person(){}; Person.prototype.run = " +
"function(a) {var b = 'a'};" +
"Person.run(1); Person.run(2)";
test(src, expected);
String src =
"/** @constructor */ function person(){}; " +
"person.prototype.run = function(a, b) {};" +
"person.prototype.walk = function() {};" +
"person.prototype.foo = function() { this.run(this.walk, 0.1)};" +
"person.foo();";
String expected =
"function person(){}; person.prototype.run = function(a) {" +
"  var b = 0.1;};" +
"person.prototype.walk = function() {};" +
"person.prototype.foo = function() { this.run(this.walk)};" +
"person.foo();";
test(src, expected);Es6RewriteArrowFunction.THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT,
static final DiagnosticType THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT = DiagnosticType.warning(
"JSC_THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT",
"You have 'this' reference in an arrow function inside an object literal. "
+ "The reference may refer to an unintended target after rewrite.");
if (n.getParent().isStringKey() && NodeUtil.referencesThis(n)) {
compiler.report(JSError.make(n, THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT));
import static com.google.javascript.jscomp.Es6RewriteArrowFunction.
THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT;
protected int getNumRepetitions() {
return 1;
public void testArrowFuncInObjLitWithThis1() {
testWarning("var f = {wThis: () => this.whatIsThis}",
THIS_REFERENCE_IN_ARROWFUNC_OF_OBJLIT);
public void testArrowFuncInObjLitWithThis2() {
test(
LINE_JOINER.join(
"var f = {",
"  ultiObj: () => ({",
"    ulti: 42,",
"    showUlti: function() {",
"      return this.ulti;",
"    }",
"  })",
"}"),
LINE_JOINER.join(
"var f = {",
"  ultiObj: function() {",
"    return {",
"      ulti: 42,",
"      showUlti: function() {",
"        return this.ulti;",
"      }",
"    }",
"  }",
"}"));if (typeExprNode.getType() == Token.QMARK) {String originalMessageKey;
originalMessageKey = (String) node.getProp(Node.ORIGINALNAME_PROP);
originalMessageKey = (String) propNode.getProp(Node.ORIGINALNAME_PROP);
originalMessageKey = (String) node.getProp(Node.ORIGINALNAME_PROP);
if (originalMessageKey != null) {
messageKey = originalMessageKey;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
private static class RenameMessagesVisitor extends AbstractPostOrderCallback {
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isName() && n.getString() != null && n.getString().startsWith("MSG_")) {
String originalName = n.getString();
n.putProp(Node.ORIGINALNAME_PROP, originalName);
n.setString("some_prefix_" + originalName);
private boolean renameMessages = false;
renameMessages = false;
public void testRenamedMessages() {
renameMessages = true;
extractMessagesSafely(
"/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')");
assertThat(compiler.getWarnings()).isEmpty();
assertThat(messages).hasSize(1);
JsMessage msg = messages.get(0);
assertEquals("MSG_HELLO", msg.getKey());
assertEquals("Hello", msg.getDesc());
assertEquals("[testcode]", msg.getSourceName());
if (renameMessages) {
RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor();
NodeTraversal.traverseEs6(compiler, root, renameMessagesVisitor);"JSC_POLYMER_INVALID_DECLARAION", "A Polymer() declaration cannot use 'let' or 'const'.");
if (!n.isVar() && !n.isAssign()) {
if (n.isVar()) {
if (parent.getParent().isConst() || parent.getParent().isLet()) {
if (NodeUtil.isNameDeclaration(parent.getParent()) || parent.isAssign()) {
rewritePolymerClass(parent.getParent(), def, t);
if (exprRoot.isVar()) {
testErrorEs6(
"});"), PolymerPass.POLYMER_INVALID_DECLARATION);"var Array = function f(a){};\n";List<DependencyOptions.ModuleIdentifier> entryPoints)
throws FlagUsageException {
protected void setRunOptions(CompilerOptions options)
throws FlagUsageException, IOException {
if (config.languageIn.length() > 0) {
CompilerOptions.LanguageMode languageMode =
CompilerOptions.LanguageMode.fromString(config.languageIn);
if (languageMode != null) {
options.setLanguageIn(languageMode);
throw new FlagUsageException("Unknown language `" + config.languageIn
+ "' specified.");
if (config.languageOut.isEmpty()) {
options.setLanguageOut(options.getLanguageIn());
CompilerOptions.LanguageMode languageMode =
CompilerOptions.LanguageMode.fromString(config.languageOut);
if (languageMode != null) {
options.setLanguageOut(languageMode);
throw new FlagUsageException("Unknown language `" + config.languageOut +
"' specified.");
public static class FlagUsageException extends Exception {
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,
boolean allowStdIn, List<JsModuleSpec> jsModuleSpecs)
throws FlagUsageException, IOException {
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,
List<JsonFileSpec> jsonFiles, List<JsModuleSpec> jsModuleSpecs)
throws FlagUsageException, IOException {
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,
List<JsonFileSpec> jsonFiles, boolean allowStdIn,
List<JsModuleSpec> jsModuleSpecs) throws FlagUsageException, IOException {
throws FlagUsageException, IOException {
private List<SourceFile> createExternInputs(List<String> files)
throws FlagUsageException, IOException {
List<JSModule> createJsModules(
List<JsModuleSpec> specs, List<SourceFile> inputs)
throws FlagUsageException, IOException {
protected void checkModuleName(String name)
throws FlagUsageException {
static Map<String, String> parseModuleWrappers(List<String> specs,
List<JSModule> modules) throws FlagUsageException {
void writeModuleOutput(Appendable out, JSModule m)
throws FlagUsageException, IOException {
protected int doRun() throws FlagUsageException, IOException {
int processResults(Result result, List<JSModule> modules, B options)
throws FlagUsageException, IOException {
private void outputModuleBinaryAndSourceMaps(
List<JSModule> modules, B options)
throws FlagUsageException, IOException {
private Charset getInputCharset() throws FlagUsageException {
private Charset getLegacyOutputCharset() throws FlagUsageException {
private Charset getOutputCharset2() throws FlagUsageException {
protected List<SourceFile> createExterns(CompilerOptions options)
throws FlagUsageException, IOException {
private void outputNameMaps() throws FlagUsageException,
IOException {
private String languageIn = "";
private String languageOut = "";
CommandLineConfig setLanguageIn(String languageIn) {
this.languageIn = languageIn;
return this;
CommandLineConfig setLanguageOut(String languageOut) {
this.languageOut = languageOut;
return this;
static JsModuleSpec create(String specString, boolean isFirstModule)
throws FlagUsageException {
.setLanguageIn(flags.languageIn)
.setLanguageOut(flags.languageOut)
protected void checkModuleName(String name)
throws FlagUsageException {
protected List<SourceFile> createExterns(CompilerOptions options)
throws FlagUsageException, IOException {
allJsInputs.add(pattern);
if (File.separator.equals("\\")) {
pattern = pattern.replace('\\', '/');
List<String> patternParts = Splitter.on('/').splitToList(pattern);
if (i == 0) {
break;
prefix = Joiner.on(File.separator).join(patternParts.subList(0, i));
pattern = Joiner.on(File.separator).join(patternParts.subList(i, patternParts.size()));
final PathMatcher matcher = fs.getPathMatcher("glob:" + (prefix.equals(".")
? pattern
: prefix + File.separator + pattern));
if (matcher.matches(p.normalize())) {
String pathString = p.toString();
import com.google.common.collect.ImmutableMap;
import com.google.javascript.jscomp.parsing.parser.FeatureSet;
import java.util.Map;
import java.util.TreeMap;
private ImmutableMap<String, String> loadFlags;
loadFlags = ImmutableMap.copyOf(finder.loadFlags);
FeatureSet features = ((JsAst) ast).getFeatures(compiler);
Map<String, String> loadFlagsBuilder = new TreeMap<>();
loadFlagsBuilder.putAll(info.getLoadFlags());
loadFlagsBuilder.put("lang", features.version());
if (features.hasEs6Modules()) {
loadFlagsBuilder.put("module", "es6"); // NOTE: may be overridden by goog.module
loadFlags = ImmutableMap.copyOf(loadFlagsBuilder);
private final Map<String, String> loadFlags = new TreeMap<>();
loadFlags.put("module", "goog");
public ImmutableMap<String, String> getLoadFlags() {
return loadFlags;
return ImmutableMap.of();
public boolean isModule() {
return "goog".equals(getLoadFlags().get("module"));
Preconditions.checkNotNull(options);
.add(new CheckUnusedPrivateProperties(compiler));
Node objectLit = IR.objectlit();
objectLit.addChildToBack(IR.stringKey(var.name, IR.name("undefined")));
IR.stringKey(var.name, IR.getprop(IR.name(object.name),
IR.string(var.name))));
loopNode.getParent().addChildBefore(
IR.var(IR.name(object.name), objectLit)
.useSourceInfoIfMissingFromForTree(loopNode),
loopNode);
exprResult.useSourceInfoIfMissingFromForTree(superclassNameNode);
if (info.isExport()) {
sb.append("@export ");
if (info.getVisibility() != null
import com.google.common.collect.ImmutableMap;
public ImmutableMap<String, String> getLoadFlags() {
throw new UnsupportedOperationException();
new CheckPrototypeProperties(compiler)));
static boolean isClassDeclaration(Node n) {
case "Number": {
int paramCount = n.getChildCount() - 1;
if (paramCount == 0 || paramCount == 1) {
Node replacement;
if (paramCount == 0) {
replacement = IR.number(0);
Node value = n.getLastChild().detachFromParent();
if (NodeUtil.isNumericResult(value)) {
replacement = value;
replacement =  IR.pos(value);
n.getParent().replaceChild(n, replacement);
reportCodeChange();
break;
ClassDefinition def = new ClassDefinition(target, descriptor, classInfo,
new MemberDefinition(ctorInfo, null, constructor), nativeBaseElement, allProperties,
private final List<UnrecognizedRequire> unrecognizedRequires =
new ArrayList<>();
parent.detachFromParent();
compiler.reportCodeChange();
import com.google.common.collect.ImmutableSet;
checkDefaultParam(v, scope);
private void checkDefaultParam(Var v, Scope scope) {
NodeTraversal.traverseEs6(compiler, v.getParentNode().getSecondChild(), check);
if (!scope.isDeclared(refName, true)) {
compiler.report(JSError.make(ref, EARLY_REFERENCE_ERROR, v.name));
ImmutableSet<Reference> referenceSet = ImmutableSet.copyOf(references);
import com.google.common.collect.ImmutableMap;
public ImmutableMap<String, String> getLoadFlags();
public abstract class Base implements DependencyInfo {
return "goog".equals(getLoadFlags().get("module"));
import com.google.common.collect.ImmutableMap;
import java.util.Map;
"\\s*([^,]*), (\\[[^\\]]*\\]), (\\[[^\\]]*\\])"
+ "(?:, (true|false|\\{[^{}]*\\}))?\\s*")
.matcher("");
parseLoadFlags(depArgsMatch.group(4))
private Map<String, String> parseLoadFlags(String loadFlags) throws ParseException {
if (loadFlags == null || loadFlags.equals("false")) {
return ImmutableMap.of();
return ImmutableMap.of("module", "goog");
return parseJsStringMap(loadFlags);
import com.google.common.base.CharMatcher;
import java.util.LinkedHashMap;
import java.util.Map;
Map<String, String> parseJsStringMap(String input) throws ParseException {
input = CharMatcher.WHITESPACE.trimFrom(input);
check(
!input.isEmpty() && input.charAt(0) == '{' && input.charAt(input.length() - 1) == '}',
"Syntax error when parsing JS object");
input = input.substring(1, input.length() - 1).trim();
Map<String, String> results = new LinkedHashMap<>();
boolean done = input.isEmpty();
valueMatcher.reset(input);
while (!done) {
check(valueMatcher.lookingAt(), "Bad key in JS object literal");
String key = valueMatcher.group(1) != null ? valueMatcher.group(1) : valueMatcher.group(2);
check(!valueMatcher.hitEnd(), "Missing value in JS object literal");
check(input.charAt(valueMatcher.end()) == ':', "Missing colon in JS object literal");
valueMatcher.region(valueMatcher.end() + 1, valueMatcher.regionEnd());
check(valueMatcher.lookingAt(), "Bad value in JS object literal");
String val = valueMatcher.group(1) != null ? valueMatcher.group(1) : valueMatcher.group(2);
results.put(key, val);
if (!valueMatcher.hitEnd()) {
check(input.charAt(valueMatcher.end()) == ',', "Missing comma in JS object literal");
valueMatcher.region(valueMatcher.end() + 1, valueMatcher.regionEnd());
done = true;
return results;
private static void check(boolean condition, String message) throws ParseException {
if (!condition) {
throw new ParseException(message, true /* fatal */);
import com.google.common.collect.ImmutableMap;
import java.util.Map;
private final ImmutableMap<String, String> loadFlags;
public SimpleDependencyInfo(
String srcPathRelativeToClosure, String pathOfDefiningFile,
List<String> provides, List<String> requires, boolean isModule) {
this(srcPathRelativeToClosure, pathOfDefiningFile, provides, requires, loadFlags(isModule));
List<String> provides, List<String> requires, Map<String, String> loadFlags) {
this.loadFlags = ImmutableMap.copyOf(loadFlags);
public ImmutableMap<String, String> getLoadFlags() {
return loadFlags;
private static Map<String, String> loadFlags(boolean isModule) {
return isModule ? ImmutableMap.of("module", "goog") : ImmutableMap.<String, String>of();
return "goog".equals(getLoadFlags().get("module"));
Objects.equals(other.loadFlags, this.loadFlags);
+ "provides=%3$s, requires=%4$s, loadFlags=%5$s)", srcPathRelativeToClosure,
pathOfDefiningFile, provides, requires, loadFlags);
srcPathRelativeToClosure, pathOfDefiningFile, loadFlags);
if (t.inGlobalScope()
&& (NodeUtil.isFunctionDeclaration(function)
|| NodeUtil.isNameDeclaration(function.getGrandparent())
|| function.getParent().isAssign())) {
import java.util.Collection;
if (allowCovariantGenerics(this)) {
if (!thisType.isSubtypeOf(otherType)) {
return false;
&& JSType.unifyUnknowns(thisType, otherType) == null) {
private static boolean allowCovariantGenerics(NominalType nt) {
return nt.rawType.name.equals("Array");
return hasUnified && (allowCovariantGenerics(this)
|| isInvariantWith(typeMultimap, other));
private boolean isInvariantWith(Multimap<String, JSType> typeMultimap, NominalType other) {
Preconditions.checkState(isGeneric());
Preconditions.checkState(this.rawType == other.rawType);
Map<String, JSType> newTypeMap = new LinkedHashMap<>();
for (String typeVar : typeMultimap.keySet()) {
Collection<JSType> c = typeMultimap.get(typeVar);
if (c.size() != 1) {
return false;
newTypeMap.put(typeVar, Preconditions.checkNotNull(Iterables.getOnlyElement(c)));
NominalType instantiated = instantiateGenerics(newTypeMap);
Map<String, JSType> otherMap = other.typeMap;
for (Map.Entry<String, JSType> entry : instantiated.typeMap.entrySet()) {
JSType t1 = entry.getValue();
JSType t2 = otherMap.get(entry.getKey());
if (!t1.isSubtypeOf(t2) || !t2.isSubtypeOf(t1)) {
return false;
return true;
new JsDocTokenStream(typeString),
typeString,
return parser.parseTopLevelTypeExpression(parser.next());
JSTypeExpression baseType = null;
List<JSTypeExpression> extendedInterfaces = null;
List<JSTypeExpression> implementedInterfaces = null;
Map<String, JSTypeExpression> parameters = null;
List<JSTypeExpression> thrownTypes = null;
List<String> templateTypeNames = null;
Set<String> disposedParameters = null;
Map<String, Node> typeTransformations = null;
String description = null;
String meaning = null;
String deprecated = null;
String license = null;
ImmutableSet<String> suppressions = null;
ImmutableSet<String> modifies = null;
String lendsName = null;
private int propertyBitField = 0;
String sourceComment = null;
List<Marker> markers = null;
LinkedHashMap<String, String> parameters = null;
Map<JSTypeExpression, String> throwsDescriptions = null;
String blockDescription = null;
String fileOverview = null;
String returnDescription = null;
String version = null;
List<String> authors = null;
List<String> sees = null;
private TrimmedStringPosition annotation = null;
private TrimmedStringPosition name = null;
private SourcePosition<Node> nameNode = null;
private StringPosition description = null;
private TypePosition type = null;
private LazilyInitializedInfo info = null;
private LazilyInitializedDocumentation documentation = null;
private Visibility visibility = null;
private int bitset = 0x00;
private JSTypeExpression type = null;
private JSTypeExpression thisType = null;
private boolean inlineType = false;
private boolean includeDocumentation = false;
private boolean populated = false;
private boolean parseDocumentation = false;
private JSDocInfo.Marker currentMarker = null;
if (getProp(STATIC_SOURCE_FILE) == null) {
putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));
putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));
if (getProp(STATIC_SOURCE_FILE) == null) {
putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));
if (propB.isVoidable() && !propB.isUnknownType()) {
if (that.isUnknownType()) {
int size = alternates.size();
if (size > maxUnionSize) {
return registry.getNativeType(UNKNOWN_TYPE);
return null;
return alternates.get(0);
return registry.getNativeType(NO_TYPE);
result = new UnionType(registry, getAlternateListCopy());
private Collection<JSType> getAlternateListCopy() {
return ImmutableList.copyOf(alternates);
import java.nio.file.Files;
public void testGlobJs1() throws IOException, FlagUsageException {
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "utest2.js"));
String glob = new File(jsFile1.value).getParent() + File.separator + "**.js";
public void testGlobJs2() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "utest2.js"));
String glob = new File(jsFile1.value).getParent() + File.separator + "*test*.js";
compileFiles(
"var a;var b;", new FlagEntry<>(JsSourceType.JS, glob));
public void testGlobJs3() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "test2.js"));
String glob1 = new File(jsFile1.value).getParent() + File.separator + "**.js";
String glob2 = "!" + new File(jsFile1.value).getParent() + File.separator + "**test2.js";
compileFiles(
"var a;", new FlagEntry<>(JsSourceType.JS, glob1),
new FlagEntry<>(JsSourceType.JS, glob2));
public void testGlobJs4() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "test2.js"));
String glob1 = "!" + new File(jsFile1.value).getParent() + File.separator + "**test2.js";
String glob2 = new File(jsFile1.value).getParent() + File.separator + "**.js";
compileFiles(
"var a;", new FlagEntry<>(JsSourceType.JS, glob1),
new FlagEntry<>(JsSourceType.JS, glob2));
public void testJsonStreamInputFlag() throws FlagUsageException {
public void testJsonStreamOutputFlag() throws FlagUsageException {
public void testJsonStreamBothFlag() throws FlagUsageException {
public void testOutputModuleNaming() throws FlagUsageException {
private void compileFiles(String expectedOutput, FlagEntry<JsSourceType>... entries)
args.add("--" + entry.flag.flagName + "=" + entry.value);
inst2.order = i + 1;
enableAstValidation(true);
enableAstValidation(true);
enableAstValidation(true);
enableAstValidation(true);
"var $jscomp$loop$0 = {i: undefined};",
"var $jscomp$loop$0 = {y: undefined};",
"var $jscomp$loop$0 = {i: undefined}",
"var $jscomp$loop$0 = {y: undefined, i: undefined};",
"var $jscomp$loop$1 = {i$0: undefined};",
"var $jscomp$loop$1 = {i$0: undefined};",
"var $jscomp$loop$2 = {i$0 : undefined, i$1: undefined};",
test("for (;;) { /** @type {number} */ let x = 3; var f = function() { return x; } }",
"var $jscomp$loop$0 = {x: undefined};",
test("for (;;) { const /** number */ x = 3; var f = function() { return x; } }",
"var $jscomp$loop$0 = {x: undefined};",
"var $jscomp$loop$0={x: undefined};",
LINE_JOINER.join(
"for (foo();;) {",
"var $jscomp$loop$0={x: undefined};",
"var $jscomp$loop$0={x: undefined};",
"var $jscomp$loop$1 = {i$0: undefined, j: undefined};",
"var $jscomp$loop$0 = {i: undefined};",
"var $jscomp$loop$0 = {i: undefined, j: undefined};",
"var $jscomp$loop$0 = {j: undefined};",
"var $jscomp$loop$0 = {i: undefined};",
"var $jscomp$loop$0 = {i: undefined};",
"  var $jscomp$loop$1 = {i : undefined};",
"    var $jscomp$loop$0 = {j : undefined};",
"  var $jscomp$loop$1 = {i : undefined};",
"    var $jscomp$loop$2 = {i$0 : undefined};",
"var $jscomp$loop$0 = {i: undefined};",
"var $jscomp$loop$1 = {i$0: undefined};",
"var $jscomp$loop$0 = {a: undefined};",
"var $jscomp$loop$1 = {special: undefined};",
"  var $jscomp$loop$0 = {i: undefined};",
test(LINE_JOINER.join(
"while (true) {",
"  let x = null;",
"  var f = function() {",
"    x();",
"  }",
"}"),
"var $jscomp$loop$0 = {x:undefined};",
"while (true) {",
"  $jscomp$loop$0.x = null;",
"  var f = function($jscomp$loop$0) {",
"    return function() {",
"      ($jscomp$loop$0.x)();",
"    };",
"  }($jscomp$loop$0);",
"  $jscomp$loop$0 = {x:$jscomp$loop$0.x};",
"}"));
test(LINE_JOINER.join(
"while (true) {",
"  let x = null;",
"  function f() {",
"    x();",
"  }",
"}"),
"var $jscomp$loop$0 = {x:undefined};",
"while (true) {",
"  $jscomp$loop$0.x = null;",
"  var f = function($jscomp$loop$0) {",
"    return function f() {",
"      ($jscomp$loop$0.x)();",
"    };",
"  }($jscomp$loop$0);",
"  $jscomp$loop$0 = {x:$jscomp$loop$0.x};",
"}"));
test(LINE_JOINER.join(
"while (true) {",
"  let x = null;",
"  (function() {",
"    x();",
"  })();",
"}"),
"var $jscomp$loop$0 = {x:undefined};",
"while (true) {",
"  $jscomp$loop$0.x = null;",
"  (function($jscomp$loop$0) {",
"    return function () {",
"      ($jscomp$loop$0.x)();",
"    };",
"  })($jscomp$loop$0)();",
"  $jscomp$loop$0 = {x:$jscomp$loop$0.x};",
"}"));
testWarning("/** @type {number} */ let x = 5; x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("let /** number */ x = 5; x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("let /** @type {number} */ x = 5; x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("/** @type {number} */ const x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("const /** number */ x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("const /** @type {number} */ x = 'str';", TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("const /** @type {string} */ x = 3, /** @type {number} */ y = 3;",
TypeValidator.TYPE_MISMATCH_WARNING);
testWarning("const /** @type {string} */ x = 'str', /** @type {string} */ y = 3;",
TypeValidator.TYPE_MISMATCH_WARNING);
test(
"  x = 5;",
null);
test(
null);
"  var $jscomp$loop$0 = {lx: undefined, ly: undefined, lz: undefined};",
enableAstValidation(true);
enableAstValidation(true);
assertEarlyReferenceError("function f(x=a) {}");
compareJsDoc = false;
List<SourceFile> inputs = new ArrayList<>();
for (int i = 0; i < original.length; i++) {
inputs.add(SourceFile.fromCode("input" + i, original[i]));
enableAstValidation(true);
"f(/** @type {!Bar<!Bar<number>>} */ (new Bar));"),
NewTypeInference.INVALID_ARGUMENT_TYPE);
"var /** Gen<Foo> */ a = new Gen(new Bar);"),
NewTypeInference.MISTYPED_ASSIGN_RHS);
test("var a = Number()", "var a = 0");
test("var a = Number(1)", "var a = 1");
test("var a = Number(x)", "var a = +x");
test("var a = Number({})", "var a = +({})");
testSame("var a = Number(1, 2);");
public void testSimpleFunctionCall3() {
enableAstValidation(true);
testClosureTypesMultipleWarnings(
ImmutableList.of(
"Bad type annotation. Unknown type booool",
"actual parameter 1 of g does not match formal parameter\n" +
"found   : (booool|null|string)\n" +
"required: number"));
super.enableAstValidation(true);
compareJsDoc = false;
testSame("asdf;", "var asdf;", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);
testSame("yz();", "function yz() {}",
this.compareJsDoc = true;
this.compareJsDoc = false;
testSame("asdf.foo;", "var asdf;",
testSame("asdf.foo;", "var asdf;",
test("asdf.foo;", "var asdf;", "var asdf;", null, null);
import com.google.common.collect.ImmutableMap;
private static final List<String> EMPTY = ImmutableList.of();
final String contents = "/*"
List<DependencyInfo> result = parser.parseFile(SRC_PATH, contents);
ImmutableList<DependencyInfo> expected = ImmutableList.<DependencyInfo>of(
assertThat(result).isEqualTo(expected);
public void testTooManyArgs3() {
parser.parseFile(SRC_PATH, "goog.addDependency('a', [], [], {}, []);");
assertThat(errorManager.getErrorCount()).isEqualTo(1);
assertThat(errorManager.getWarningCount()).isEqualTo(0);
public void testBadLoadFlagsSyntax() {
parser.parseFile(SRC_PATH, "goog.addDependency('a', [], [], {module: 'goog'});");
assertThat(errorManager.getErrorCount()).isEqualTo(1);
assertThat(errorManager.getWarningCount()).isEqualTo(0);
ImmutableList<DependencyInfo> expected = ImmutableList.<DependencyInfo>of(
assertThat(result).isEqualTo(expected);
public void testLoadFlags() {
List<DependencyInfo> result = parser.parseFile(SRC_PATH, ""
+ "goog.addDependency('yes1', [], [], {'module': 'goog'});\n"
+ "goog.addDependency('yes2', [], [], {\"lang\": \"es6\"});\n"
+ "goog.addDependency('yes3', [], [], {});\n");
ImmutableList<DependencyInfo> expected = ImmutableList.<DependencyInfo>of(
new SimpleDependencyInfo("yes1", SRC_PATH, EMPTY, EMPTY, ImmutableMap.of("module", "goog")),
new SimpleDependencyInfo("yes2", SRC_PATH, EMPTY, EMPTY, ImmutableMap.of("lang", "es6")),
new SimpleDependencyInfo("yes3", SRC_PATH, EMPTY, EMPTY, false));
assertThat(result).isEqualTo(expected);
ImmutableList<DependencyInfo> expected = ImmutableList.<DependencyInfo>of(
assertThat(result).isEqualTo(expected);
ImmutableList<DependencyInfo> expected = ImmutableList.<DependencyInfo>of(
assertThat(result).isEqualTo(expected);
import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Token;
Node associatedNode = new Node(Token.SCRIPT);
associatedNode.setInputId(new InputId(file.getName()));
associatedNode.setStaticSourceFile(file);
private JsDocTokenStream stream(String source) {
params.getFirstChild().getNext().getJSType());
assertTrue(params.getFirstChild().getNext().isOptionalArg());
registry.getNativeType(JSTypeNative.ALL_TYPE),public static class NamePosition extends SourcePosition<Node> {}
private SourcePosition<Node> nameNode;
public SourcePosition<Node> getNameNode() {
void setNameNode(SourcePosition<Node> p) {
&& Objects.equals(jsDoc1.getMarkers(), jsDoc2.getMarkers())
SourcePosition<Node> nodePos =
new JSDocInfo.NamePosition();
public void setUp() {
compareJsDoc = false;
public int getNumRepetitions() {
return 1;allJsInputs.add(pattern);
if (File.separator.equals("\\")) {
pattern = pattern.replace('\\', '/');
List<String> patternParts = Splitter.on('/').splitToList(pattern);
if (i == 0) {
break;
prefix = Joiner.on(File.separator).join(patternParts.subList(0, i));
pattern = Joiner.on(File.separator).join(patternParts.subList(i, patternParts.size()));
final PathMatcher matcher = fs.getPathMatcher("glob:" + (prefix.equals(".")
? pattern
: prefix + File.separator + pattern));
if (matcher.matches(p.normalize())) {
String pathString = p.toString();import java.nio.file.Files;
public void testGlobJs1() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "utest2.js"));
String glob = new File(jsFile1.value).getParent() + File.separator + "**.js";
compileFiles(
"var a;var b;", new FlagEntry<>(JsSourceType.JS, glob));
public void testGlobJs2() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "utest2.js"));
String glob = new File(jsFile1.value).getParent() + File.separator + "*test*.js";
compileFiles(
"var a;var b;", new FlagEntry<>(JsSourceType.JS, glob));
public void testGlobJs3() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "test2.js"));
String glob1 = new File(jsFile1.value).getParent() + File.separator + "**.js";
String glob2 = "!" + new File(jsFile1.value).getParent() + File.separator + "**test2.js";
compileFiles(
"var a;", new FlagEntry<>(JsSourceType.JS, glob1),
new FlagEntry<>(JsSourceType.JS, glob2));
public void testGlobJs4() throws IOException, FlagUsageException {
FlagEntry<JsSourceType> jsFile1 = createJsFile("test1", "var a;");
FlagEntry<JsSourceType> jsFile2 = createJsFile("test2", "var b;");
new File(jsFile2.value).renameTo(new File(
new File(jsFile1.value).getParentFile() + File.separator + "test2.js"));
String glob1 = "!" + new File(jsFile1.value).getParent() + File.separator + "**test2.js";
String glob2 = new File(jsFile1.value).getParent() + File.separator + "**.js";
compileFiles(
"var a;", new FlagEntry<>(JsSourceType.JS, glob1),
new FlagEntry<>(JsSourceType.JS, glob2));if (options.enables(DiagnosticGroups.LINT_CHECKS)) {
checks.add(lintChecks);
.add(new CheckPrototypeProperties(compiler))
.add(new CheckUnusedPrivateProperties(compiler))
CheckForInOverArray.FOR_IN_OVER_ARRAY,
CheckNullableReturn.NULLABLE_RETURN,
CheckNullableReturn.NULLABLE_RETURN_WITH_NAME,
CheckForInOverArray.FOR_IN_OVER_ARRAY,
ImplicitNullabilityCheck.IMPLICITLY_NULLABLE_JSDOC,if (lhs.equals(STRING) || rhs.equals(STRING)) {public ProcessCommonJSModulesTest() {
compareJsDoc = false;
+ "module$test = function () {};");
"module$test=foo$$module$test");
"module$test=foo$$module$test");
"module$test=foo$$module$test");
"function foo() {}"
+ "module.exports = {"
+ "  prop: 'value',"
+ "  foo"
+ "}",
"goog.provide('module$test');"
+ "function foo$$module$test() {}"
+ "module$test = { prop: 'value', foo }");
"module.exports = {\n"
+ "  prop: 'value',\n"
+ "  foo() {\n"
+ "    console.log('bar');\n"
+ "  }\n"
+ "};",
"goog.provide('module$test');"
+ "module$test = { prop: 'value', foo() { console.log('bar'); }}" );
String fileoverview = "/** @fileoverview\n * @suppress {missingProvide|missingRequire}\n */";
SourceFile.fromCode(fileName, fileoverview + expected));
testModules(this, input, expected);JSType prop2type = prop2.getType();
if (prop2.isOptional() || prop2type.isUnknown()) {
if (prop1 != null && !prop1.getType().isSubtypeOf(prop2type)) {
!prop1.getType().isSubtypeOf(prop2type)) {
"f({c: 123});"));
"g({bar:123});"));
" * @param {{metadata:METADATA}} spec",
" * @template METADATA",
"function viewId(spec) {}",
"viewId({});"));return getFixForDebuggerStatement(error);
private static SuggestedFix getFixForDebuggerStatement(JSError error) {private String legacyOutputCharset;
private String getLegacyOutputCharset() throws FlagUsageException {
throw new FlagUsageException(config.charset +
" is not a valid charset name.");
return config.charset;
return "US-ASCII";
if (replaceMessagesWithChromeI18n &&
messageBundle != null &&
!(messageBundle instanceof EmptyMessageBundle)) {
throw new RuntimeException("When replacing messages with " +
"chrome.i18n.getMessage, a message bundle should not be specified.");
String outputCharset;
public void setOutputCharset(String charsetName) {
return outputCharset == null ? null : Charset.forName(outputCharset);
private String outputEncoding = "UTF-8";
public void setOutputEncoding(String outputEncoding) {
assertThat(lastCompiler.getOptions().outputCharset).isEqualTo("US-ASCII");
assertThat(lastCompiler.getOptions().outputCharset).isEqualTo("UTF-8");return insertBefore(nodeToInsertBefore, generateCode(compiler, n));
new CodeReplacement(startPosition, 0, content));
return insertBefore(nodeToInsertBefore, googRequireNode, m.getMetadata().getCompiler());"  return iterator;",
"Found two declarations for property {0} on type {1}.\n");
DeclaredFunctionType declFunType = computeFnDeclaredType(
jsdoc, internalName, fn, ownerType, currentScope);
fnScope.setDeclaredType(declFunType);
warnings.add(JSError.make(getProp, REDECLARED_PROPERTY,
pname, classType.toString()));
JSType propDeclType = getDeclaredTypeOfNode(jsdoc, currentScope);
warnings.add(JSError.make(declNode, REDECLARED_PROPERTY,
pname, ns.toString()));
Node initializer = NodeUtil.getRValueOfLValue(declNode);
warnings.add(JSError.make(propCreationNode, REDECLARED_PROPERTY,
pname, classType.toString()));
return NodeUtil.isExprAssign(n)
&& isPrototypeProperty(n.getFirstChild().getFirstChild());
rhs.isName() && rhsPair.type.isUnknown()) {
TypeEnv env = envPutType(rhsPair.env, lhs.getString(), JSType.TOP_SCALAR);
env = envPutType(rhsPair.env, rhs.getString(), JSType.TOP_SCALAR);
return new EnvTypePair(env, JSType.BOOLEAN);
builder.addOptFormal(JSType.nullAcceptingJoin(
f1.getFormalType(i), f2.getFormalType(i)));
builder.addRestFormals(
JSType.nullAcceptingJoin(f1.restFormals, f2.restFormals));
"  return iterator;",
"  return iterator;",
"    return iterator;",
"    return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",
"  return iterator;",if (nominalType != null || other.nominalType != null) {protected static void lint(SourceFile externs, String filename) throws IOException {
lint(externs, Paths.get(filename));
private static void lint(SourceFile externs, Path path) throws IOException {import java.util.HashSet;
if (getReferenceName().equals(that.getReferenceName())) {
return true;
if (this.isStructuralInterface()
&& that.isStructuralInterface()) {
return checkStructuralInterfaceEquivalenceHelper(
that, eqMethod, eqCache);
return false;
boolean checkStructuralInterfaceEquivalenceHelper(
final JSType that, EquivalenceMethod eqMethod, EqCache eqCache) {
Preconditions.checkState(eqCache.isStructuralTyping());
Preconditions.checkState(this.isStructuralInterface());
Preconditions.checkState(that.isRecordType() || that.isFunctionType());
MatchStatus result = eqCache.checkCache(this, that);
if (result != null) {
return result.subtypeValue();
if (this.hasAnyTemplateTypes() || that.hasAnyTemplateTypes()) {
return false;
Map<String, JSType> thisPropList = getPropertyTypeMap(this);
Map<String, JSType> thatPropList = that.isRecordType()
? that.toMaybeRecordType().getOwnPropertyTypeMap()
: getPropertyTypeMap(that.toMaybeFunctionType());
if (thisPropList.size() != thatPropList.size()) {
eqCache.updateCache(this, that, MatchStatus.NOT_MATCH);
return false;
for (String propName : thisPropList.keySet()) {
JSType typeInInterface = thisPropList.get(propName);
JSType typeInFunction = thatPropList.get(propName);
if (typeInFunction == null
|| !typeInFunction.checkEquivalenceHelper(
typeInInterface, eqMethod, eqCache)) {
eqCache.updateCache(this, that, MatchStatus.NOT_MATCH);
return false;
eqCache.updateCache(this, that, MatchStatus.MATCH);
return true;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
return toMaybeRecordType().checkRecordEquivalenceHelper(
if (isNominalType() && that.isNominalType()) {
if (getConcreteNominalTypeName(this.toObjectType())
.equals(getConcreteNominalTypeName(that.toObjectType()))) {
return true;
FunctionType thatConstructor = that.toObjectType().getConstructor();
FunctionType thisConstructor = this.toObjectType().getConstructor();
return thisConstructor.checkStructuralInterfaceEquivalenceHelper(
thatConstructor, eqMethod, eqCache);
return checkObjectRecordEquivalenceHelper(that, eqMethod, eqCache);
private boolean checkObjectRecordEquivalenceHelper(final JSType that,
EquivalenceMethod eqMethod, EqCache eqCache) {
Preconditions.checkState((isInstanceType() && that.isRecordType())
|| (isRecordType() && that.isInstanceType()));
FunctionType constructor = isInstanceType() ?
toObjectType().getConstructor()
: that.toObjectType().getConstructor();
RecordType recordType = isRecordType() ? toMaybeRecordType()
: that.toMaybeRecordType();
return constructor.checkStructuralInterfaceEquivalenceHelper(
recordType, eqMethod, eqCache);
protected static boolean implicitMatch(JSType rightType, JSType leftType,
if (rightType.isUnionType() || leftType.isUnionType()) {
return false;
if (!rightType.isObject() || !leftType.isObject()) {
if (leftType.isTemplatizedType()) {
if (leftType.isStructuralInterface() && rightType.isFunctionType()) {
return checkConstructorImplicitMatch(rightType.toMaybeFunctionType(),
leftType.toMaybeFunctionType(), implicitImplCache);
if (leftType.isStructuralInterface() && rightType.isRecordType()) {
return checkObjectImplicitMatch(rightType.toMaybeObjectType(),
leftType.toMaybeFunctionType(), implicitImplCache);
FunctionType leftConstructor = leftType.toMaybeObjectType().getConstructor();
FunctionType rightConstructor = rightType.toMaybeObjectType().getConstructor();
if (leftConstructor == null || !leftConstructor.isStructuralInterface()) {
if (rightConstructor != null) {
return checkConstructorImplicitMatch(rightConstructor, leftConstructor,
implicitImplCache);
rightType.toMaybeObjectType(), leftConstructor, implicitImplCache);
ObjectType rightType, FunctionType leftType,
Preconditions.checkArgument(leftType.isStructuralInterface());
Map<String, JSType> leftPropList = getPropertyTypeMap(leftType);
Map<String, JSType> rightPropList = getPropertyTypeMap(rightType);
for (String propName : leftPropList.keySet()) {
JSType leftPropType = leftPropList.get(propName);
JSType rightPropType = rightPropList.get(propName);
if (rightPropType == null) {
return false;
if (!rightPropType.isSubtype(leftPropType, implicitImplCache)) {
return false;
return true;
protected static boolean checkConstructorImplicitMatch(FunctionType rightType,
FunctionType leftType,
ImplCache implicitImplCache) {
Preconditions.checkArgument(leftType.isStructuralInterface());
if (rightType.explicitlyImplOrExtInterface(leftType)) {
return true;
MatchStatus result = implicitImplCache.checkCache(rightType, leftType);
if (leftType.hasAnyTemplateTypes()) {
implicitImplCache.updateCache(leftType, rightType, MatchStatus.NOT_MATCH);
Map<String, JSType> interfacePropList = getPropertyTypeMap(leftType);
Map<String, JSType> functionPropList = getPropertyTypeMap(rightType);
for (String propName : interfacePropList.keySet()) {
JSType typeInInterface = interfacePropList.get(propName);
JSType typeInFunction = functionPropList.get(propName);
if (typeInFunction == null
|| !typeInFunction.isSubtype(typeInInterface, implicitImplCache)) {
implicitImplCache.updateCache(leftType, rightType, MatchStatus.NOT_MATCH);
return false;
implicitImplCache.updateCache(leftType, rightType, MatchStatus.MATCH);
protected static Map<String, JSType> getPropertyTypeMap(ObjectType type) {
if (type == null) { return ImmutableMap.of(); }
return type.getPropertyTypeMap();
void updateCache(JSType leftType,
JSType rightType, MatchStatus isMatch) {
this.matchCache.put(leftType, rightType, isMatch);
MatchStatus checkCache(JSType rightType, JSType leftType) {
if (this.matchCache.contains(leftType, rightType)) {
return this.matchCache.get(leftType, rightType);
this.updateCache(leftType, rightType, MatchStatus.PROCESSING);
import java.util.HashMap;
import java.util.Set;
boolean checkRecordEquivalenceHelper(RecordType otherRecord,
EquivalenceMethod eqMethod, EqCache eqCache) {
MatchStatus result = eqCache.checkCache(this, otherRecord);
if (result != null) {
return result.subtypeValue();
Set<String> keySet = getOwnPropertyNames();
Set<String> otherKeySet = otherRecord.getOwnPropertyNames();
if (!otherKeySet.equals(keySet)) {
return false;
for (String key : keySet) {
if (!otherRecord.getPropertyType(key).checkEquivalenceHelper(
getPropertyType(key), eqMethod, eqCache)) {
eqCache.updateCache(this, otherRecord, MatchStatus.NOT_MATCH);
return false;
eqCache.updateCache(this, otherRecord, MatchStatus.MATCH);
return true;
public Map<String, JSType> getOwnPropertyTypeMap() {
Map<String, JSType> propTypeMap = new HashMap<>();
for (String name : this.getOwnPropertyNames()) {
propTypeMap.put(name, this.getPropertyType(name));
return propTypeMap;import com.google.gson.Gson;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.InputStreamReader;
private final Gson gson;
private final List<JsonFileSpec> filesToStreamOut = new ArrayList<>();
this.gson = new Gson();
options.sourceMapOutputPath = "%outname%";
public List<JsonFileSpec> parseJsonFilesFromInputStream() throws IOException {
List<JsonFileSpec> jsonFiles = new ArrayList<>();
JsonReader reader = new JsonReader(new InputStreamReader(System.in, inputCharset));
reader.beginArray();
while (reader.hasNext()) {
JsonFileSpec jsonFile = gson.fromJson(reader, JsonFileSpec.class);
jsonFiles.add(jsonFile);
reader.endArray();
reader.close();
return jsonFiles;
protected List<SourceFile> createInputs(List<String> files,
List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
return createInputs(files, new ArrayList<String>() /* zips */, jsonFiles, false);
return createInputs(files, zips, null, allowStdIn);
protected List<SourceFile> createInputs(List<String> files,
List<String> zips, List<JsonFileSpec> jsonFiles, boolean allowStdIn)
throws FlagUsageException, IOException {
if (jsonFiles != null) {
for (JsonFileSpec jsonFile : jsonFiles) {
inputs.add(SourceFile.fromCode(jsonFile.getPath(), jsonFile.getSrc()));
private List<SourceFile> createSourceInputs(List<String> files, List<String> zips,
List<JsonFileSpec> jsonFiles)
return inputsSupplierForTesting != null ? inputsSupplierForTesting.get()
: null;
if (files.isEmpty() && zips.isEmpty() && jsonFiles == null) {
if (jsonFiles != null) {
return createInputs(files, jsonFiles);
return createInputs(files, zips, true);
List<String> specs, List<SourceFile> inputs)
Preconditions.checkState(inputs != null);
final int totalNumJsFiles = inputs.size();
List<SourceFile> moduleFiles =
inputs.subList(numJsFilesLeft - numJsFiles, numJsFilesLeft);
for (SourceFile input : moduleFiles) {
if (pathPrefix.length() > 0) {
? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(
pathPrefix).getParent();
List<JsonFileSpec> jsonFiles = null;
if (config.useJsonStreams) {
jsonFiles = parseJsonFilesFromInputStream();
ImmutableMap.Builder<String, SourceMapInput> inputSourceMaps
= new ImmutableMap.Builder<>();
boolean foundJsonInputSourceMap = false;
for (JsonFileSpec jsonFile : jsonFiles) {
if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
String sourceMapPath = jsonFile.getPath() + ".map";
SourceFile sourceMap = SourceFile.fromCode(sourceMapPath,
jsonFile.getSourceMap());
inputSourceMaps.put(sourceMapPath, new SourceMapInput(sourceMap));
foundJsonInputSourceMap = true;
if (foundJsonInputSourceMap) {
inputSourceMaps.putAll(options.inputSourceMaps);
options.inputSourceMaps = inputSourceMaps.build();
List<SourceFile> inputs = createSourceInputs(jsFiles, config.jsZip, jsonFiles);
modules = createJsModules(moduleSpecs, inputs);
outputSingleBinary(options);
if (!config.useJsonStreams) {
outputSourceMap(options, config.jsOutputFile);
if (config.useJsonStreams) {
outputJsonStream();
void outputSingleBinary(B options) throws IOException {
if (config.useJsonStreams) {
this.filesToStreamOut.add(createJsonFile(options, marker, escaper));
Appendable jsOutput = createDefaultOutput();
writeOutput(
jsOutput, compiler, compiler.toSource(), config.outputWrapper,
marker, escaper);
closeAppendable(jsOutput);
JsonFileSpec createJsonFile(B options, String outputMarker,
Function<String, String> escaper) throws IOException {
Appendable jsOutput = new StringBuilder();
outputMarker, escaper);
JsonFileSpec jsonOutput = new JsonFileSpec(jsOutput.toString(),
Strings.isNullOrEmpty(config.jsOutputFile) ?
"compiled.js" : config.jsOutputFile);
if (!Strings.isNullOrEmpty(options.sourceMapOutputPath)) {
StringBuilder sourcemap = new StringBuilder();
compiler.getSourceMap().appendTo(sourcemap, jsonOutput.getPath());
jsonOutput.setSourceMap(sourcemap.toString());
return jsonOutput;
void outputJsonStream() throws IOException {
JsonWriter jsonWriter = new JsonWriter(
new BufferedWriter(new OutputStreamWriter(defaultJsOutput, "UTF-8")));
jsonWriter.beginArray();
for (JsonFileSpec jsonFile : this.filesToStreamOut) {
jsonWriter.beginObject();
jsonWriter.name("src").value(jsonFile.getSrc());
jsonWriter.name("path").value(jsonFile.getPath());
if (!Strings.isNullOrEmpty(jsonFile.getSourceMap())) {
jsonWriter.name("source_map").value(jsonFile.getSourceMap());
jsonWriter.endObject();
jsonWriter.endArray();
jsonWriter.close();
Writer mapFileOut = null;
if (!(shouldGenerateMapPerModule(options) || config.useJsonStreams)) {
mapFileOut = fileNameToOutputWriter2(
expandSourceMapPath(options, null));
if (config.useJsonStreams) {
this.filesToStreamOut.add(createJsonFileFromModule(m));
if (shouldGenerateMapPerModule(options)) {
mapFileOut = fileNameToOutputWriter2(expandSourceMapPath(options, m));
try (Writer writer = fileNameToLegacyOutputWriter(
getModuleOutputFileName(m))) {
if (options.sourceMapOutputPath != null) {
compiler.getSourceMap().reset();
writeModuleOutput(writer, m);
if (options.sourceMapOutputPath != null) {
compiler.getSourceMap().appendTo(mapFileOut, m.getName());
if (shouldGenerateMapPerModule(options) && mapFileOut != null) {
mapFileOut.close();
mapFileOut = null;
if (mapFileOut != null) {
mapFileOut.close();
private JsonFileSpec createJsonFileFromModule(JSModule module) throws
FlagUsageException, IOException{
compiler.getSourceMap().reset();
StringBuilder output = new StringBuilder();
writeModuleOutput(output, module);
JsonFileSpec jsonFile = new JsonFileSpec(output.toString(),
getModuleOutputFileName(module));
StringBuilder moduleSourceMap = new StringBuilder();
compiler.getSourceMap().appendTo(moduleSourceMap,
getModuleOutputFileName(module));
jsonFile.setSourceMap(moduleSourceMap.toString());
return jsonFile;
private boolean useJsonStreams = false;
CommandLineConfig setUseJsonStreams(boolean useJsonStreams) {
this.useJsonStreams = useJsonStreams;
return this;
private class JsonFileSpec {
private final String src;
private final String path;
private String source_map;
public JsonFileSpec(String src, String path) {
this(src, path, null);
public JsonFileSpec(String src, String path, String source_map) {
this.src = src;
this.path = path;
this.source_map = source_map;
public String getSrc() {
return this.src;
public String getPath() {
return this.path;
public String getSourceMap() { return this.source_map; }
public void setSourceMap(String map) {
this.source_map = map;
final class CheckJSDoc extends AbstractPostOrderCallback implements CompilerPass {
hidden = true,
handler = BooleanOptionHandler.class,
usage = "Specifies that standard input and output streams will be "
+ "a JSON array of sources. Each source will be an object of the "
+ "form {path: filename, src: file_contents, srcmap: srcmap_contents }. "
+ "Intended for use by stream-based build systems such as gulpjs.")
private boolean jsonStreams = false;
.setNewTypeInference(flags.useNewTypeInference)
.setUseJsonStreams(flags.jsonStreams);
private final PassFactory checkJsDoc = new PassFactory("checkJsDoc", true) {
protected CompilerPass create(AbstractCompiler compiler) {
private final PassFactory es6RewriteDestructuring =
new PassFactory("Es6RewriteDestructuring", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
private final PassFactory es6RewriteArrowFunction =
new PassFactory("Es6RewriteArrowFunction", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
WRONG_PARAMETER_COUNT//,
WINDOW, getVarTypeFromAnnotation(nameNode, this.currentScope), false, true);
if (this.currentScope.isNamespace(name)
|| NodeUtil.isTypedefDecl(nameNode)
|| NodeUtil.isEnumDecl(nameNode)) {
if (!this.currentScope.isDefinedLocally(name, false)) {
return;
parentScope.addSimpleType(qnameNode, result.slotType);
void addSimpleType(Node qnameNode, JSType declType) {
Preconditions.checkState(qnameNode.isName());
String name = qnameNode.getString();
if (qnameNode.isFromExterns()) {
externs.put(name, declType);
locals.put(name, declType);
Preconditions.checkArgument(!isDefinedLocally(name, false));
Preconditions.checkArgument(!isNamespace(qnameNode));
"'use strict' is unnecessary in goog.module files.");
"maybeStr - 5;");if (pathPrefix.length() > 0) {
? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(
pathPrefix).getParent();if (!Ordering.natural().isOrdered(requiredNamespaces)) {
t.report(n, REQUIRES_NOT_SORTED);
if (!Ordering.natural().isOrdered(providedNamespaces)) {
t.report(n, PROVIDES_NOT_SORTED);
String req = compiler.getCodingConvention().extractClassNameIfRequire(n, parent);
if (req != null) {
requiredNamespaces.add(req);
String prov = compiler.getCodingConvention().extractClassNameIfProvide(n, parent);
if (prov != null) {
if (n.getFirstChild().matchesQualifiedName("goog.module")) {
moduleNamespaces.add(prov);
providedNamespaces.add(prov);
import com.google.javascript.jscomp.CompilerTestCase;
public final class CheckRequiresAndProvidesSortedTest extends CompilerTestCase {
"goog.require('namespace.Example');", "goog.require('namespace.example');"));
"goog.provide('namespace.Example');", "goog.provide('namespace.example');"));
testWarning("goog.module('xyz');\ngoog.module('abc');", MULTIPLE_MODULES_IN_FILE);
import static com.google.javascript.refactoring.testing.SuggestedFixes.assertChanges;
import static com.google.javascript.refactoring.testing.SuggestedFixes.assertReplacement;
import com.google.javascript.jscomp.JSError;
String before = "function f() { ";
String after = "debugger; }";
Compiler compiler = getCompiler(before + after);
JSError[] errors = compiler.getErrors();
assertThat(errors).hasLength(1);
SuggestedFix fix = ErrorToFixMapper.getFixForJsError(errors[0], compiler);
CodeReplacement replacement = new CodeReplacement(before.length(), "debugger;".length(), "");
assertReplacement(fix, replacement);
Compiler compiler = getCompiler(code);
JSError[] errors = compiler.getErrors();
assertThat(errors).hasLength(1);
SuggestedFix fix = ErrorToFixMapper.getFixForJsError(errors[0], compiler);
assertChanges(fix, "", code, expectedCode);
private Compiler getCompiler(String jsInput) {
Compiler compiler = new Compiler();
CompilerOptions options = getCompilerOptions();
ImmutableList.of(SourceFile.fromCode("test", jsInput)),
return compiler;
private CompilerOptions getCompilerOptions() {
CompilerOptions options = RefactoringDriver.getCompilerOptions();
options.setWarningLevel(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT, ERROR);
options.setWarningLevel(DiagnosticGroups.UNNECESSARY_CASTS, ERROR);
return options;private void testDep(
String js, String reason, DiagnosticType error, DiagnosticType errorWithMessage) {
testError(String.format(js, ""), error);
test(String.format(js, reason), null, errorWithMessage, null, reason);
testDep("/** @deprecated %s */ function f() {} function g() { f(); }", "Some Reason",
DEPRECATED_NAME, DEPRECATED_NAME_REASON);
testDep("/** @deprecated %s */ var f = 4; function g() { alert(f); }", "Another reason",
DEPRECATED_NAME, DEPRECATED_NAME_REASON);
testDep(
"/** @deprecated %s */ var f = function() {}; function g() { f(); }",
"I like g...", DEPRECATED_NAME, DEPRECATED_NAME_REASON);
testDep("/** @deprecated %s */ function f() {} f();", "Some global scope", DEPRECATED_NAME,
DEPRECATED_NAME_REASON);
testDep(
"/** @deprecated %s */ function f() {}"
+ "/** @constructor */  var Foo = function() {}; "
+ "Foo.prototype.bar = function() { f(); }",
"FooBar", DEPRECATED_NAME, DEPRECATED_NAME_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar = 3;"
+ "Foo.prototype.baz = function() { alert((new Foo()).bar); };",
"A property is bad", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar = 3;"
+ "Foo.prototype.baz = function() { alert(this.bar); };",
"Zee prop, it is deprecated!", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
"/** @constructor \n* @deprecated %s */ function Foo() {} "
+ "function f() { new Foo(); }",
"Use the class 'Bar'", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON);
testDep(
"/** @constructor \n * @deprecated %s */ function Foo() {} "
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "function f() { new SubFoo(); }",
"Superclass to the rescue!", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON);
testDep(
"/** @constructor \n * @deprecated %s */ function Foo() {} "
+ "var namespace = {}; "
+ "/** @constructor \n * @extends {Foo} */ "
+ "namespace.SubFoo = function() {}; "
+ "function f() { new namespace.SubFoo(); }",
"Its only weakness is Kryptoclass", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar = 3;"
+ "Foo.prototype.baz = function() { alert(Foo.prototype.bar); };",
"It is now in production, use that model...", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar = function() {};"
+ "Foo.prototype.baz = function() { this.bar(); };",
"There is a madness to this method", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar; "
+ "Foo.prototype.baz = function() { this.bar(); };",
"Stop the ringing!", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
"/** @deprecated %s */ function f() {} "
+ "/** @constructor */ "
+ "var Foo = function() {}; "
+ "Foo.bar = function() { f(); }",
"crazy!", DEPRECATED_NAME, DEPRECATED_NAME_REASON);
testDep(
"var f = {}; /** @deprecated %s */ f.foo = 3; function g() { return f.foo; }",
"It is literally not used anymore", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "Foo.prototype.bar = function() {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @deprecated %s */ SubFoo.prototype.bar = function() {};"
+ "function f() { (new SubFoo()).bar(); };",
"I have a parent class!", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.bar = function() {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "SubFoo.prototype.bar = function() {};"
+ "function f() { (new SubFoo()).bar(); };",
"I have a child class!", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s \n* @protected */"
+ "Foo.prototype.bar = function() {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @protected */SubFoo.prototype.bar = function() {};"
+ "function f() { (new SubFoo()).bar(); };",
"I have another child class...", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
"/** @deprecated %s */ Function.prototype.bind = function() {};"
+ "(function() {}).bind();",
"I'm bound to this method...", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
"/** @constructor \n * @deprecated %s */ var Foo = function() {};"
+ "new Foo();",
"I'm a very worldly object!", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON);
testDep(
+ " /** @deprecated %s */ this.bar = 3;"
+ "  this.baz = this.bar;"
+ "}",
"GRR", DEPRECATED_PROP, DEPRECATED_PROP_REASON);
testDep(
+ "/** @deprecated %s */ Foo.prototype.length;"
(String) null, DEPRECATED_PROP, DEPRECATED_PROP_REASON);
assertEquals(
"Unexpected error(s): " + LINE_JOINER.join(compiler.getErrors()),
0,
compiler.getErrorCount());
String errors = "";
for (JSError actualError : compiler.getErrors()) {
errors += actualError.description + "\n";
assertEquals("There should be one error. " + errors, 1, compiler.getErrorCount());
assertEquals(errors, error, actualError.getType());
"JSC_MSG_TREE_MALFORMED. Message parse tree malformed. "
+ "with placeholders. at testcode line 2 : 12", true);private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;
Set<Node> renameNodes = new HashSet<>();
final Map<Node, JSType> rootTypes = new HashMap<>();
renameNodes.add(node);
rootTypes.put(node, type);
invalidationMap.put(t, error);
if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) {
return;
Map<JSType, String> propNames = buildPropNames(prop.getTypes(), prop.name);
for (Node node : prop.renameNodes) {
JSType rootType = prop.rootTypes.get(node);
String newName = propNames.get(rootType);
private Map<JSType, String> buildPropNames(UnionFind<JSType> types, String name) {
for (Set<JSType> set : types.allEquivalenceClasses()) {
if (typeName == null || type.toString().compareTo(typeName) < 0) {
typeName = type.toString();
newName = name;
newName = NONWORD_PATTERN.matcher(typeName).replaceAll("_") + '$'
+ name;
for (JSType type : set) {
names.put(type, newName);return new GetAccessorTree(getTreeLocation(start), propertyName, isStatic, body);
getTreeLocation(start), property, isStatic, access, body);
getTreeLocation(start), propertyName, isStatic, parameter, body);
getTreeLocation(start), property, isStatic, access, parameter, body);
SourceRange location, Token propertyName, boolean isStatic, BlockTree body) {NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
NodeTraversal.traverseRootsEs6(compiler, new CollectUndeclaredNames(), externs, root);
NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
NodeTraversal.traverseRootsEs6(compiler, new Es6RenameReferences(renameMap), externs, root);
NodeTraversal.traverseRootsEs6(compiler, transformer, externs, root);
NodeTraversal.traverseRootsEs6(
NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
NodeTraversal.traverseRootsEs6(compiler, new GatherSignatures(), externs, root);
NodeTraversal.traverseRootsEs6(compiler, getActingCallback(), externs, root);
public static void traverseRootsEs6(
AbstractCompiler compiler, Callback cb, Node externs, Node root) {
NodeTraversal t = new NodeTraversal(compiler, cb, new Es6SyntacticScopeCreator(compiler));
t.traverseRoots(externs, root);
NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
NodeTraversal.traverseRootsEs6(compiler, this, externs, root);
Node node = newNode(type, transform(exprNode.operand));
node.putBooleanProp(Node.INCRDECR_PROP, true);
NodeTraversal.traverseRootsEs6(compiler, renamer, externs, root);
NodeTraversal.traverseRootsEs6(compiler,private final Multimap<String, Node> staticMethods = ArrayListMultimap.create();
private final Multimap<String, Node> staticProperties = ArrayListMultimap.create();
if (multiplyDefinedClasses.contains(superclassNameNode.getQualifiedName())) {
for (Node staticMethod : staticMethods.get(superclassNameNode.getQualifiedName())) {
copyStaticMethod(staticMethod, superclassNameNode, subclassNameNode, parent);
for (Node staticProperty : staticProperties.get(superclassNameNode.getQualifiedName())) {
Preconditions.checkState(staticProperty.isGetProp(), staticProperty);
String memberName = staticProperty.getLastChild().getString();
Node getprop = IR.getprop(subclassNameNode.cloneTree(), IR.string(memberName));
JSDocInfoBuilder info = JSDocInfoBuilder.maybeCopyFrom(staticProperty.getJSDocInfo());
JSTypeExpression unknown = new JSTypeExpression(new Node(Token.QMARK), "<synthetic>");
info.recordType(unknown); // In case there wasn't a type specified on the base class.
info.addSuppression("visibility");
getprop.setJSDocInfo(info.build());
Node declaration = IR.exprResult(getprop);
declaration.useSourceInfoIfMissingFromForTree(n);
parent.getParent().addChildAfter(declaration, parent);
staticProperties.put(subclassNameNode.getQualifiedName(), staticProperty);
compiler.reportCodeChange();
private void copyStaticMethod(
Node staticMember, Node superclassNameNode, Node subclassNameNode, Node insertionPoint) {
for (Node subclassMember : staticMethods.get(subclassNameNode.getQualifiedName())) {
staticMethods.put(subclassNameNode.getQualifiedName(), assign);
staticProperties.put(className, n);
if (classNames.contains(n.getLastChild().getQualifiedName())) {
staticMethods.putAll(maybeAlias, staticMethods.get(n.getLastChild().getQualifiedName()));
staticMethods.put(maybeClassName, n);
staticMethods.putAll(maybeAlias, staticMethods.get(maybeOriginalName));
test(
"Subclass.staticMethod = function() { return 5; };"),
"",
"/** @return {string} */",
"Example.staticMethod = function() { return ''; }",
"",
"",
"// This should be a type error, but currently we don't catch it.",
"Subclass.staticMethod = function() { return 5; };"));case Token.IN:
return JSType.TOP_DICT;
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));if (nt == null) {
return !isFunction() && !isObject();
private boolean isObject() {options.setNewTypeInference(config.useNewTypeInference);
if (ctorType != null && ctorType.isUniqueConstructor()) {
name = "--language_in",
hidden = true,
usage =
"Sets what language spec that input sources conform. "
+ "Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT, "
+ "ECMASCRIPT6, ECMASCRIPT6_STRICT, ECMASCRIPT6_TYPED (experimental)"
)
&& !options.getNewTypeInference()) {
if (this.options.getNewTypeInference()) {
private boolean useNewTypeInference;
defineReplacements.put(defineName, value);
defineReplacements.put(defineName, value);
defineReplacements.put(defineName, value);
tweakReplacements.put(tweakId, value);
tweakReplacements.put(tweakId, value);
tweakReplacements.put(tweakId, value);
return this.useNewTypeInference;
this.useNewTypeInference = enable;
if (enable) {
this.checkTypes = true;
setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.OFF);
if (options.getNewTypeInference()) {
if (options.getLanguageIn() == LanguageMode.ECMASCRIPT6_TYPED
&& options.getLanguageOut() != LanguageMode.ECMASCRIPT6_TYPED) {
checks.add(convertEs6TypedToEs6);
if (options.getNewTypeInference()) {
if (options.checkTypes || options.inferTypes) {
if (options.checkTypes) {
CheckJSDocStyle.EXTERNS_FILES_SHOULD_BE_ANNOTATED,
public final class Es6RewriteGenerators
extends NodeTraversal.AbstractPostOrderCallback implements HotSwapCompilerPass {
private final AbstractCompiler compiler;
private final List<LoopContext> currentLoopContext;
private final List<ExceptionContext> currentExceptionContext;
private static int generatorCaseCount;
private Supplier<String> generatorCounter;
private Node enclosingBlock;
private Node hoistRoot;
private Node originalGeneratorBody;
private Node currentStatement;
Preconditions.checkNotNull(compiler);
if (enclosing != null
&& enclosing.isGeneratorFunction()
default:
break;
Node ifThrows =
IR.ifNode(
IR.shne(IR.name(GENERATOR_THROW_ARG), IR.name("undefined")),
IR.block(IR.throwNode(IR.name(GENERATOR_THROW_ARG))));
Node assignIterResult =
IR.assign(
IR.name(GENERATOR_YIELD_ALL_ENTRY),
IR.call(
IR.getprop(IR.name(GENERATOR_YIELD_ALL_NAME), IR.string("next")),
IR.name(GENERATOR_NEXT_ARG)));
Node loop = IR.whileNode(loopCondition, IR.block(yieldStatement));
Node yieldStatement =
IR.exprResult(n.hasChildren() ? IR.yield(n.removeFirstChild()) : IR.yield());
Node genBlock = compiler
.parseSyntheticCode(Joiner.on('\n').join(
"function generatorBody() {",
"  var " + GENERATOR_STATE + " = " + generatorCaseCount + ";",
"  function $jscomp$generator$impl(" + GENERATOR_NEXT_ARG + ", ",
"      " + GENERATOR_THROW_ARG + ") {",
"    while (1) switch (" + GENERATOR_STATE + ") {",
"      case " + generatorCaseCount + ":",
"      default:",
"        return {value: undefined, done: true};",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg) { return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg) { return $jscomp$generator$impl(undefined, arg); },",
"  };",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"))
.getFirstChild()
.getLastChild()
.detachFromParent();
hoistRoot
.getParent()
.addChildAfter(IR.var(IR.name(GENERATOR_ARGUMENTS), IR.name("arguments")), hoistRoot);
hoistRoot
.getParent()
.addChildAfter(IR.var(IR.name(GENERATOR_THIS), IR.thisNode()), hoistRoot);
Node newTry =
IR.tryCatch(IR.block(), currentExceptionContext.get(0).catchBlock.cloneTree());
visitBlock();
return false;
+ Token.name(currentStatement.getType()));
Node newCatchBody =
IR.block(IR.exprResult(assignError), createStateUpdate(catchStartState), createSafeBreak());
NodeTraversal.traverseEs6(
compiler, tryBody, new ControlExitsCheck(finallyName, finallyStartState));
NodeTraversal.traverseEs6(
compiler, catchBody, new ControlExitsCheck(finallyName, finallyStartState));
finallyBody.addChildToBack(
IR.exprResult(IR.assign(IR.name(GENERATOR_STATE), finallyName.cloneTree())));
tryBody.addChildToBack(
IR.exprResult(IR.assign(finallyName.cloneTree(), IR.number(finallyEndState))));
catchBody.addChildToBack(
IR.exprResult(IR.assign(finallyName.cloneTree(), IR.number(finallyEndState))));
enclosingBlock.addChildToBack(IR.tryCatch(IR.block(), newCatch));
continueCase = getLoopContext(currentStatement.removeFirstChild().getString()).continueCase;
enclosingBlock.addChildToBack(createStateUpdate(continueCase));
compiler.report(
JSError.make(
currentStatement,
Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Breaking to a label that is not a loop"));
enclosingBlock.addChildToBack(createStateUpdate(breakCase));
Node invertedConditional =
IR.ifNode(IR.not(condition), IR.block(createStateUpdate(ifEndState), createSafeBreak()));
currCase
.getLastChild()
.addChildToFront(IR.exprResult(IR.assign(didEnter.cloneTree(), IR.trueNode())));
compiler.report(
JSError.make(
currentStatement,
Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Default case as intermediate case"));
equivBlock =
IR.ifNode(
IR.or(
didEnter.cloneTree(),
IR.sheq(switchVal.cloneTree(), currCase.removeFirstChild())),
currCase.removeFirstChild());
for (Node child = currentStatement.removeFirstChild();
child != null;
body.addChildToFront(
IR.ifNode(
IR.not(IR.in(variable.cloneTree(), iterableName.cloneTree())),
IR.block(IR.continueNode())));
body.addChildToFront(
IR.var(variable.cloneTree(), IR.getelem(arrayName.cloneTree(), varName.cloneTree())));
Node newForIn =
IR.forIn(
variable.cloneTree(),
iterableName,
IR.block(
IR.exprResult(
IR.call(IR.getprop(arrayName.cloneTree(), IR.string("push")), variable))));
Node newFor =
IR.forNode(
IR.assign(varName.cloneTree(), IR.number(0)),
IR.lt(varName.cloneTree(), IR.getprop(arrayName, IR.string("length"))),
IR.inc(varName, true),
body);
enclosingBlock.addChildToBack(IR.exprResult(IR.assign(name, name.removeFirstChild())));
enclosingBlock.addChildToBack(IR.returnNode(createIteratorResult(value, false)));
enclosingBlock.addChildToBack(
IR.returnNode(
createIteratorResult(
currentStatement.hasChildren()
? currentStatement.removeFirstChild()
: IR.name("undefined"),
true)));
return IR.exprResult(IR.assign(IR.name(GENERATOR_STATE), IR.number(generatorCaseCount)));
return IR.exprResult(IR.assign(IR.name(GENERATOR_STATE), IR.number(state)));
Node setReturnState = IR.exprResult(IR.assign(finallyName.cloneTree(), IR.number(jumpPoint)));
for (LoopContext context : currentLoopContext) {
if (label.equals(context.label)) {
return context;
private final class DecomposeYields extends NodeTraversal.AbstractPreOrderCallback {
DecomposeYields(AbstractCompiler compiler) {
decomposer =
new ExpressionDecomposer(
compiler,
compiler.getUniqueNameIdSupplier(),
consts,
Scope.createGlobalScope(new Node(Token.SCRIPT)));
compiler.report(
JSError.make(
n,
Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Case statements that contain yields"));
default:
break;
compiler.report(
JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT, "Undecomposable expression"));
if (enclosingFunc == null || !enclosingFunc.isGeneratorFunction() || NodeUtil.isForIn(n)) {
Node guard = null;
Node incr = null;
default:
break;
container.addChildToFront(
IR.block(IR.exprResult(IR.assign(guardName.cloneTree(), guard.cloneTree()))));
private static final class ControlExitsCheck implements NodeTraversal.Callback {
int continueCatchers;
int breakCatchers;
int throwCatchers;
List<String> labels = new ArrayList<>();
boolean exited;
boolean addJumps;
ControlExitsCheck(Node finallyName, int finallyStartState) {
ControlExitsCheck() {
if (parent != null
&& parent.isTry()
&& parent.getFirstChild() == n
&& ((breakCatchers == 0 && !n.hasChildren())
|| (n.hasChildren() && !labels.contains(n.getFirstChild().getString())))) {
if (continueCatchers == 0
|| (n.hasChildren() && !labels.contains(n.getFirstChild().getString()))) {
default:
break;
if (parent != null
&& parent.isTry()
&& parent.getFirstChild() == n
default:
break;
private static final class LoopContext {
LoopContext(int breakCase, int continueCase, String label) {
private static final class ExceptionContext {
ExceptionContext(int catchStartCase, Node catchBlock) {
JSType t = currentScope.getDeclaredFunctionType().getThisType();
NominalType thisType = t == null ? null : t.getNominalTypeIfSingletonObj();
Node qnameNode = declNode.isGetProp()
? declNode : NodeUtil.getFunctionNameNode(declNode);
if (funType == null
|| funType.isUniqueConstructor()
|| funType.isInterfaceDefinition()) {
return allButRecvType.withReceiverType(recvType);
options.setLanguageIn(LanguageMode.ECMASCRIPT6_STRICT);
options.setLanguageIn(LanguageMode.ECMASCRIPT5);
return getDeclaredFunctionType().getThisType();
if (fnType.isUniqueConstructor() || fnType.isInterfaceDefinition()) {
if (fnType.isUniqueConstructor() || fnType.isInterfaceDefinition()) {
|| funType.isInterfaceDefinition()) {
if (!ctorType.isUnknown()
&& (!ctorType.isSubtypeOf(commonTypes.topFunction())
|| (!ctorFunType.isQmarkFunction()
&& !ctorFunType.isSomeConstructorOrInterface()))) {
if (ctorFunType == null
|| !ctorFunType.isUniqueConstructor()
|| (!specializedType.isTrueOrTruthy()
&& !specializedType.isFalseOrFalsy())) {
&& funType.isSomeConstructorOrInterface()
&& (!funType.isSomeConstructorOrInterface()
|| funType.isInterfaceDefinition())) {
warnings.add(JSError.make(expr, NOT_A_CONSTRUCTOR, funType.toString()));
if (boundFunType.isSomeConstructorOrInterface()) {
if (reqThisType == null || boundFunType.isSomeConstructorOrInterface()) {
if (ft != null && ft.isUniqueConstructor()) {
|| expr.isNew() && !funType.isSomeConstructorOrInterface()) {
count = 0;
public static final DiagnosticType EXTERNS_FILES_SHOULD_BE_ANNOTATED =
DiagnosticType.warning("JSC_EXTERNS_FILES_SHOULD_BE_ANNOTATED",
"Externs files should be annotated with @externs in the @fileoverview block.");
NodeTraversal.traverseEs6(compiler, externs, new ExternsCallback());
private static class ExternsCallback implements NodeTraversal.Callback {
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
return parent == null || n.isScript();
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isScript()) {
JSDocInfo info = n.getJSDocInfo();
if (info == null || !info.isExterns()) {
t.report(n, EXTERNS_FILES_SHOULD_BE_ANNOTATED);
private final JSType nominalType;
private final JSType receiverType;
JSType nominalType,
JSType receiverType,
for (JSType formal : this.requiredFormals) {
for (JSType formal : this.optionalFormals) {
builder.addRestFormals(this.restFormals);
builder.addRetType(this.returnType == null ? JSType.UNKNOWN : this.returnType);
builder.addNominalType(this.nominalType);
builder.addReceiverType(this.receiverType);
builder.addTypeParameters(this.typeParameters);
JSType nominalType,
JSType receiverType,
public JSType getThisType() {
if (this.nominalType != null) {
return this.nominalType;
return this.receiverType;
public JSType getNominalType() {
return this.nominalType;
public JSType getReceiverType() {
return this.receiverType;
if (this.typeParameters.contains(tvar)) {
if (this.receiverType != null) {
NominalType recvType = this.receiverType.getNominalTypeIfSingletonObj();
if (recvType != null && recvType.isUninstantiatedGenericType()) {
RawNominalType rawType = recvType.getRawNominalType();
if (rawType.getTypeParameters().contains(tvar)) {
return true;
public DeclaredFunctionType withReceiverType(JSType newReceiverType) {
newReceiverType, this.typeParameters);
NominalType nt = superType.nominalType == null
? null : superType.nominalType.getNominalTypeIfSingletonObj();
NominalType rt = this.receiverType == null
? null : this.receiverType.getNominalTypeIfSingletonObj();
superType.restFormals, superType.returnType,
nt == null ? null : nt.getInstanceAsJSType(),
rt == null ? null : rt.getInstanceAsJSType(),
for (JSType formal : this.requiredFormals) {
for (JSType formal : this.optionalFormals) {
if (this.restFormals != null) {
builder.addRestFormals(this.restFormals);
builder.addRetType(
this.returnType != null ? this.returnType : superType.returnType);
builder.addNominalType(this.nominalType);
builder.addReceiverType(this.receiverType);
if (!this.typeParameters.isEmpty()) {
builder.addTypeParameters(this.typeParameters);
static boolean hasScalar(ImmutableSet<EnumType> enums) {
for (EnumType e : enums) {
if (e.declaredType.hasScalar()) {
return true;
return false;
private final JSType nominalType;
private final JSType receiverType;
JSType nominalType,
JSType receiverType,
JSType nominalType,
JSType receiverType,
private static NominalType getNominalTypeIfSingletonObj(JSType t) {
return t == null ? null : t.getNominalTypeIfSingletonObj();
public boolean isSomeConstructorOrInterface() {
return this.nominalType != null;
public boolean isUniqueConstructor() {
NominalType nt = getNominalTypeIfSingletonObj(this.nominalType);
return nt != null && nt.isClass();
NominalType nt = getNominalTypeIfSingletonObj(this.nominalType);
return nt != null && nt.isInterface();
Preconditions.checkState(isUniqueConstructor());
NominalType nt = getNominalTypeIfSingletonObj(this.nominalType);
NominalType superClass = nt.getInstantiatedSuperclass();
return this.nominalType;
return getNominalTypeIfSingletonObj(this.nominalType)
.instantiateGenerics(JSType.MAP_TO_UNKNOWN).getInstanceAsJSType();
return this.receiverType != null ? this.receiverType : this.nominalType;
NominalType nt = getNominalTypeIfSingletonObj(this.nominalType);
return Preconditions.checkNotNull(nt).getConstructorObject(this);
builder.addReqFormal(fromReceiverToFirstFormal());
for (JSType type : this.requiredFormals) {
for (JSType type : this.optionalFormals) {
builder.addRestFormals(this.restFormals);
builder.addRetType(this.returnType);
builder.addTypeParameters(this.typeParameters);
builder.addReqFormal(fromReceiverToFirstFormal());
builder.addRetType(this.returnType);
private JSType fromReceiverToFirstFormal() {
if (this.receiverType == null) {
NominalType nt = this.receiverType.getNominalTypeIfSingletonObj();
if (nt == null) {
return this.receiverType;
if (nt.isGeneric()) {
return nt.instantiateGenerics(JSType.MAP_TO_UNKNOWN).getInstanceAsJSType();
return nt.getInstanceAsJSType();
for (JSType type : this.requiredFormals) {
for (JSType type : this.optionalFormals) {
builder.addRestFormals(this.restFormals);
builder.addRetType(this.returnType);
builder.addNominalType(this.nominalType);
builder.addReceiverType(this.receiverType);
if (t2 == null) {
JSType tmp = JSType.meet(t1, t2);
return tmp.isBottom() ? null : tmp;
if (this.nominalType == null && other.nominalType != null
|| this.nominalType != null && other.nominalType == null
|| this.nominalType != null && other.nominalType != null
&& !this.nominalType.isSubtypeOf(other.nominalType)) {
if (this.receiverType != null && other.receiverType == null
|| this.receiverType != null && other.receiverType != null
&& !this.receiverType.isSubtypeOf(other.receiverType)) {
private static JSType joinNominalTypes(JSType nt1, JSType nt2) {
if (nt1 == null || nt2 == null) {
return null;
NominalType n1 = getNominalTypeIfSingletonObj(nt1);
NominalType n2 = getNominalTypeIfSingletonObj(nt2);
if (n1 != null && n2 != null) {
NominalType tmp = NominalType.pickSuperclass(n1, n2);
return tmp == null ? null : tmp.getInstanceAsJSType();
return JSType.join(nt1, nt2);
private static JSType meetNominalTypes(JSType nt1, JSType nt2) {
if (nt1 == null) {
return nt2;
if (nt2 == null) {
return nt1;
NominalType n1 = getNominalTypeIfSingletonObj(nt1);
NominalType n2 = getNominalTypeIfSingletonObj(nt2);
if (n1 != null && n2 != null) {
NominalType tmp = NominalType.pickSubclass(n1, n2);
return tmp == null ? null : tmp.getInstanceAsJSType();
return JSType.meet(nt1, nt2);
return f2 == QMARK_FUNCTION ? QMARK_FUNCTION : f1;
return f2;
if (reqFormal == null) {
if (optFormal == null) {
if (newRestFormals == null) {
builder.addNominalType(joinNominalTypes(f1.nominalType, f2.nominalType));
builder.addReceiverType(joinNominalTypes(f1.receiverType, f2.receiverType));
builder.addNominalType(meetNominalTypes(this.nominalType, other.nominalType));
builder.addReceiverType(meetNominalTypes(this.receiverType, other.receiverType));
builder.addNominalType(meetNominalTypes(f1.nominalType, f2.nominalType));
builder.addReceiverType(meetNominalTypes(f1.receiverType, f2.receiverType));
private static JSType substGenericsInNomType(JSType nt, Map<String, JSType> typeMap) {
if (nt == null) {
return null;
NominalType tmp = nt.getNominalTypeIfSingletonObj();
if (tmp == null) {
return nt.substituteGenerics(typeMap);
if (!tmp.isGeneric()) {
return tmp.getInstanceAsJSType();
if (typeMap.isEmpty()) {
return nt;
return JSType.fromObjectType(ObjectType.fromNominalType(
tmp.instantiateGenerics(typeMap)));
for (String typeParam : this.typeParameters) {
for (JSType reqFormal : this.requiredFormals) {
for (JSType optFormal : this.optionalFormals) {
if (this.restFormals != null) {
builder.addRetType(this.returnType.substituteGenerics(reducedMap));
builder.addNominalType(substGenericsInNomType(this.nominalType, typeMap));
builder.addReceiverType(substGenericsInNomType(this.receiverType, typeMap));
for (String var : this.outerVarPreconditions.keySet()) {
builder.addOuterVarPrecondition(var, this.outerVarPreconditions.get(var));
private FunctionType substituteParametricGenerics(Map<String, JSType> typeMap) {
for (JSType reqFormal : this.requiredFormals) {
for (JSType optFormal : this.optionalFormals) {
if (this.restFormals != null) {
builder.addRetType(this.returnType.substituteGenerics(typeMap));
builder.addNominalType(substGenericsInNomType(this.nominalType, typeMap));
if (this.receiverType != null) {
NominalType recvType = getNominalTypeIfSingletonObj(this.receiverType);
if (recvType != null && recvType.isUninstantiatedGenericType()) {
builder.addReceiverType(this.receiverType);
builder.addReceiverType(substGenericsInNomType(this.receiverType, typeMap));
private JSType nominalType;
private JSType receiverType;
public FunctionTypeBuilder addNominalType(JSType t) {
Preconditions.checkState(this.nominalType == null);
this.nominalType = t;
public FunctionTypeBuilder addReceiverType(JSType t) {
this.receiverType = t;
if (this.requiredFormals.isEmpty()
&& this.optionalFormals.isEmpty()
&& this.restFormals != null && this.restFormals.isUnknown()
&& this.returnType != null && this.returnType.isUnknown()
&& this.nominalType == null
&& this.receiverType == null
&& this.typeParameters.isEmpty()
&& this.outerVars.isEmpty()) {
return FunctionType.QMARK_FUNCTION;
boolean hasScalar() {
return (getMask() & TOP_SCALAR_MASK) != 0 || EnumType.hasScalar(getEnums());
&& (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0,
"Requested invalid type to remove: %s", other);
return ft != null && ft.isUniqueConstructor();
public static final DiagnosticType NEW_EXPECTS_OBJECT_OR_TYPEVAR =
DiagnosticType.warning(
"JSC_NTI_NEW_EXPECTS_OBJECT_OR_TYPEVAR",
"The \"new:\" annotation only accepts object types and type variables; "
+ "found {0}.");
builder.addReceiverType(
getThisOrNewType(child.getFirstChild(), registry, typeParameters));
Node newTypeNode = child.getFirstChild();
JSType t = getThisOrNewType(newTypeNode, registry, typeParameters);
if (!t.isSubtypeOf(JSType.TOP_OBJECT)
&& (!t.hasTypeVariable() || t.hasScalar())) {
warnings.add(JSError.make(
newTypeNode, NEW_EXPECTS_OBJECT_OR_TYPEVAR, t.toString()));
builder.addNominalType(t);
private JSType getThisOrNewType(Node n,
return getTypeFromComment(n, registry, typeParameters).removeType(JSType.NULL);
builder.addReceiverType(ownerType.getInstanceAsJSType());
if (ownerType != null && funType.getThisType() == null) {
declType = declType.withReceiverType(ownerType.getInstanceAsJSType());
if (jsdoc.hasThisType()) {
builder.addReceiverType(
getThisOrNewType(thisRoot.getFirstChild(), registry, typeParameters));
builder.addNominalType(constructorType.getInstanceAsJSType());
builder.addNominalType(constructorType.getInstanceAsJSType());
JSType getConstructorObject(FunctionType ctorFn) {
return this.rawType.getConstructorObject(ctorFn);
if (c2 == null) {
boolean isInterfaceInstance() {
&& !(this.isInterfaceInstance() && other.objectKind.isUnrestricted())) {
FunctionType newFn = fn == null ? null : fn.substituteGenerics(concreteTypes);
newFn,
newFn != null && newFn.isQmarkFunction() || isLoose,
newlines.add(charNo);
return new GetAccessorTree(getTreeLocation(start), propertyName, isStatic, body);
getTreeLocation(start), property, isStatic, access, body);
getTreeLocation(start), propertyName, isStatic, parameter, body);
getTreeLocation(start), property, isStatic, access, parameter, body);
SourceRange location, Token propertyName, boolean isStatic, BlockTree body) {
mapper.addExtension("x_google_int", 2);
mapper.addExtension("x_company_baz", 2);
public void testVariableDeclaredBeforePassVaraiableReferenceCheck() {
test(createCompilerOptions(),
"enum A { B, C }\n"
+ "function b(a:A = A.B) {}\n"
+ "b();", "");
public void testBothTypeCheckersRun() {
CompilerOptions options = createCompilerOptions();
options.setNewTypeInference(true);
test(
options,
"/** @return {number} */\n"
+ "function f() {\n"
+ "  return 'asdf';\n"
+ "}",
NewTypeInference.RETURN_NONDECLARED_TYPE);
ImmutableMap.of("foo", 1), lastCompiler.getPassConfig().getIntermediateState().cssNames);
+ "Function.prototype.call = function (var_args) {};\n"
+ "/** @constructor */\n"
+ "function Arguments() {}"));
public void testUnusualThisReference() {
"}"),
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {}",
"/**",
" * @template T",
" * @this {T}",
" * @return {T}",
" */",
"function f() { return this; }",
"var /** !Foo */ x = f.call(new Foo);"));
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @param {function(new:T)} x",
" */",
"function f(x, y) {",
"  if (y instanceof x) {}",
"}"));
"/** @constructor @extends {Foo} */ function Bar(){};",
"f(new Bar, /** @this{Foo} */function () {});"),
NewTypeInference.NOT_UNIQUE_INSTANTIATION);
"g(f);"),
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {}",
"/** @constructor @extends {Foo} */",
"function Bar() {",
"  /** @type {string} */ this.p = 'asdf';",
"}",
"/**",
" * @this {Foo}",
" * @param {number} x",
" */",
"function f(x) { this.p = x; }",
"/** @param {function(number)} x */",
"f.call(new Bar, 123);"));
public void testWarnAboutBadNewType() {
typeCheck(Joiner.on('\n').join(
"/** @type {function(new:number)} */",
"function f() {}"),
JSTypeCreatorFromJSDoc.NEW_EXPECTS_OBJECT_OR_TYPEVAR);
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @param {function(new:T)} x",
" */",
"function f(x) {}"));
public void testThisVoid() {
typeCheck(Joiner.on('\n').join(
"/**",
" * @param {function(this:void)} x",
" */",
"function f(x) {}",
"/** @constructor */",
"function Foo() {}",
"Foo.prototype.method = function() {};",
"f(Foo.prototype.method);",
"function g() {}",
"f(g);"),
NewTypeInference.INVALID_ARGUMENT_TYPE);
public void testThisOrNewWithUnions() {
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @param {function(new:(T|number))} x",
" */",
"function f(x) {}"),
JSTypeCreatorFromJSDoc.NEW_EXPECTS_OBJECT_OR_TYPEVAR);
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @this {T|Object}",
" */",
"function f() {}"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {",
"  this.p = 123;",
"}",
"/** @interface */",
"function Bar() {}",
"Bar.prototype.p;",
"/** @this {Foo|Bar} */",
"function f() {",
"  return this.p - 1;",
"}"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {",
"  /** @type {number} */",
"  this.p = 123;",
"}",
"/** @interface */",
"function Bar() {}",
"/** @type {number} */",
"Bar.prototype.p;",
"/** @this {Foo|Bar} */",
"function f() {",
"  var /** string */ n = this.p;",
"}"),
NewTypeInference.MISTYPED_ASSIGN_RHS);
public void testThisOverridesPrototype() {
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {",
"  /** @type {number} */",
"  this.prop = 123;",
"}",
"/** @type {function(this:{prop:number})} */",
"Foo.prototype.method = function() {};",
"Foo.prototype.method.call({prop:234});"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {",
"  /** @type {number} */",
"  this.prop = 123;",
"}",
"/** @this {{prop:number}} */",
"Foo.prototype.method = function() {};",
"Foo.prototype.method.call({prop:234});"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Obj() {}",
"/** @this {?} */",
"Obj.prototype.toString = function() { return ''; };",
"Obj.prototype.toString.call(123);"),
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Obj() {}",
"/** @this {?} */",
"Obj.prototype.toString1 = function() { return ''; };",
"Obj.prototype.toString1.call(123);"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Arr() {}",
"/** @this {{length: number}|string} // same as {length: number} */",
"Arr.prototype.join = function() {};",
"Arr.prototype.join.call('asdf');"));
typeCheck(Joiner.on('\n').join(
"/** @this {!Array|{length:number}} */",
"Array.prototype.method = function() {};",
"function f() {",
"  Array.prototype.method.call(arguments);",
"}"));
typeCheck(Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {}",
"/** @constructor */",
"function Bar() {}",
"/**",
" * @template T",
" * @this {T}",
" * @param {T} x",
" */",
"Foo.prototype.f = function(x) {};",
"(new Foo).f(new Foo);"));
public void testCreatingSeveralQmarkFunInstances() {
typeCheck(Joiner.on('\n').join(
"/** @type {!Function} */",
"function qmarkFunDeclared() {}",
"/** @type {function(new:Object)} */",
"var x = qmarkFunDeclared;"));
public void testNotAConstructor() {
typeCheck(Joiner.on('\n').join(
"/** @interface */",
"function Foo() {}",
"(new Foo);"),
NewTypeInference.NOT_A_CONSTRUCTOR);
nameGenerator = new NameGenerator(new HashSet<String>(), "", null);
nameGenerator = new NameGenerator(new HashSet<String>(), "", null);
nameGenerator = new NameGenerator(new HashSet<String>(), "", null);
import static com.google.javascript.jscomp.lint.CheckJSDocStyle.EXTERNS_FILES_SHOULD_BE_ANNOTATED;
public CheckJSDocStyleTest() {
super("/** @fileoverview\n * @externs\n */");
public void testExternsAnnotation() {
testSame(
"function Example() {}",
"",
EXTERNS_FILES_SHOULD_BE_ANNOTATED);
testSame(
"/** @fileoverview Some super cool externs.\n * @externs\n */ function Example() {}",
"",
null);
testSame(
LINE_JOINER.join(
"/** @fileoverview Some super cool externs.\n * @externs\n */",
"/** @constructor */ function Example() {}",
"/** @param {number} x */ function example2(x) {}"),
"",
null);
test(
new String[] {
"/** @fileoverview Some externs.\n * @externs\n */ /** @const */ var example;",
"/** @fileoverview Some more.\n * @externs\n */ /** @const */ var example2;",
new String[] {},
null);if (ctorType != null && ctorType.isConstructor()) {
NominalType thisType = currentScope.getDeclaredFunctionType().getThisType();
if (funType == null || funType.isConstructor() || funType.isInterfaceDefinition()) {
return getDeclaredFunctionType().getThisType().getInstanceAsJSType();
if (fnType.isConstructor() || fnType.isInterfaceDefinition()) {
if (fnType.isConstructor() || fnType.isInterfaceDefinition()) {
if (!ctorType.isUnknown() &&
(!ctorType.isSubtypeOf(commonTypes.topFunction()) ||
!ctorFunType.isQmarkFunction() && !ctorFunType.isConstructor())) {
if (ctorFunType == null || !ctorFunType.isConstructor() ||
(!specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy())) {
warnings.add(JSError.make(
expr, NOT_A_CONSTRUCTOR, funType.toString()));
if (boundFunType.isConstructor()) {
if (reqThisType == null || boundFunType.isConstructor()) {
if (ft != null && ft.isConstructor()) {
expr.isNew() && !funType.isConstructor()) {
private final NominalType nominalType;
private final NominalType receiverType;
NominalType nominalType,
NominalType receiverType,
for (JSType formal : requiredFormals) {
for (JSType formal : optionalFormals) {
builder.addRestFormals(restFormals);
builder.addRetType(returnType == null ? JSType.UNKNOWN : returnType);
builder.addNominalType(nominalType);
builder.addReceiverType(receiverType);
builder.addTypeParameters(typeParameters);
NominalType nominalType,
NominalType receiverType,
public NominalType getThisType() {
if (nominalType != null) {
return nominalType;
return receiverType;
public NominalType getNominalType() {
return nominalType;
public NominalType getReceiverType() {
return receiverType;
if (typeParameters.contains(tvar)) {
if (receiverType != null && receiverType.isUninstantiatedGenericType()) {
RawNominalType rawType = receiverType.getRawNominalType();
if (rawType.getTypeParameters().contains(tvar)) {
return true;
newReceiver,
superType.restFormals, superType.returnType, superType.nominalType,
this.receiverType, // only keep this from the current type
final NominalType nominalType;
private final NominalType receiverType;
NominalType nominalType,
NominalType receiverType,
NominalType nominalType,
NominalType receiverType,
public boolean isConstructor() {
return nominalType != null && !nominalType.isInterface();
return nominalType != null && nominalType.isInterface();
Preconditions.checkState(isConstructor());
NominalType superClass = nominalType.getInstantiatedSuperclass();
return nominalType.getInstanceAsJSType();
ImmutableMap.Builder<String, JSType> builder = ImmutableMap.builder();
for (String typeVar : getTypeParameters()) {
builder.put(typeVar, JSType.UNKNOWN);
return instantiateGenerics(builder.build())
.nominalType.getInstanceAsJSType();
if (receiverType != null) {
return receiverType.getInstanceAsJSType();
if (nominalType != null) {
return nominalType.getInstanceAsJSType();
return null;
Preconditions.checkState(nominalType != null);
return NominalType.getConstructorObject(this);
builder.addReqFormal(receiverCallApply(receiverType));
for (JSType type : requiredFormals) {
for (JSType type : optionalFormals) {
builder.addRestFormals(restFormals);
builder.addRetType(returnType);
builder.addTypeParameters(typeParameters);
builder.addReqFormal(receiverCallApply(receiverType));
builder.addRetType(returnType);
private static JSType receiverCallApply(NominalType receiverType) {
if (receiverType == null) {
if (receiverType.isGeneric()) {
return receiverType.instantiateGenerics(JSType.MAP_TO_UNKNOWN).getInstanceAsJSType();
return receiverType.getInstanceAsJSType();
for (JSType type : requiredFormals) {
for (JSType type : optionalFormals) {
builder.addRestFormals(restFormals);
builder.addRetType(returnType);
builder.addNominalType(nominalType);
builder.addReceiverType(receiverType);
Preconditions.checkArgument(t1 != null || t2 != null);
return JSType.meet(t1, t2);
if (nominalType == null && other.nominalType != null
|| nominalType != null && other.nominalType == null
|| nominalType != null && other.nominalType != null
&& !nominalType.isSubtypeOf(other.nominalType)) {
if (receiverType != null && other.receiverType != null
&& !receiverType.isSubtypeOf(other.receiverType)) {
return QMARK_FUNCTION;
if (reqFormal.isBottom()) {
if (optFormal.isBottom()) {
if (newRestFormals.isBottom()) {
builder.addNominalType(
NominalType.pickSuperclass(f1.nominalType, f2.nominalType));
builder.addReceiverType(
NominalType.pickSuperclass(f1.receiverType, f2.receiverType));
builder.addNominalType(NominalType.pickSubclass(this.nominalType, other.nominalType));
builder.addReceiverType(NominalType.pickSubclass(this.receiverType, other.receiverType));
builder.addNominalType(
NominalType.pickSubclass(f1.nominalType, f2.nominalType));
builder.addReceiverType(
NominalType.pickSubclass(f1.receiverType, f2.receiverType));
for (String typeParam : typeParameters) {
for (JSType reqFormal : requiredFormals) {
for (JSType optFormal : optionalFormals) {
if (restFormals != null) {
builder.addRetType(returnType.substituteGenerics(reducedMap));
if (nominalType != null) {
builder.addNominalType(nominalType.instantiateGenerics(typeMap));
if (receiverType != null) {
builder.addReceiverType(receiverType.instantiateGenerics(typeMap));
for (String var : outerVarPreconditions.keySet()) {
builder.addOuterVarPrecondition(var, outerVarPreconditions.get(var));
for (JSType reqFormal : requiredFormals) {
for (JSType optFormal : optionalFormals) {
if (restFormals != null) {
builder.addRetType(returnType.substituteGenerics(typeMap));
if (nominalType != null) {
builder.addNominalType(nominalType.instantiateGenerics(typeMap));
if (receiverType != null) {
if (receiverType.isUninstantiatedGenericType()) {
builder.addReceiverType(receiverType);
builder.addReceiverType(receiverType.instantiateGenerics(typeMap));
private NominalType nominalType;
private NominalType receiverType;
public FunctionTypeBuilder addNominalType(NominalType cl) {
Preconditions.checkState(nominalType == null);
nominalType = cl;
public FunctionTypeBuilder addReceiverType(NominalType cl) {
Preconditions.checkState(receiverType == null);
receiverType = cl;
&& (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0);
return ft != null && ft.isConstructor();
NominalType builtinObject = registry.getCommonTypes().getObjectType();
NominalType nt = getNominalType(child.getFirstChild(), registry, typeParameters);
builder.addReceiverType(nt == null ? builtinObject : nt);
NominalType nt = getNominalType(child.getFirstChild(), registry, typeParameters);
builder.addNominalType(nt == null ? builtinObject : nt);
private NominalType getNominalType(Node n,
return getTypeFromComment(n, registry, typeParameters)
.removeType(JSType.NULL).getNominalTypeIfSingletonObj();
builder.addReceiverType(ownerType.getAsNominalType());
Node thisNode = thisRoot.getFirstChild();
JSType thisType = getMaybeTypeFromComment(thisNode, registry, typeParameters);
if (thisType != null) {
thisType = thisType.removeType(JSType.NULL);
NominalType nt = thisType == null ? null : thisType.getNominalTypeIfSingletonObj();
NominalType builtinObject = registry.getCommonTypes().getObjectType();
builder.addReceiverType(nt == null ? builtinObject : nt);
builder.addNominalType(constructorType.getAsNominalType());
builder.addNominalType(constructorType.getAsNominalType());
static JSType getConstructorObject(FunctionType ctorFn) {
return ctorFn.nominalType.rawType.getConstructorObject(ctorFn);
boolean isInterface() {
&& !(this.isInterface() && other.objectKind.isUnrestricted())) {
fn == null ? null : fn.substituteGenerics(concreteTypes),
isLoose,
"}"));
"/** @constructor @extends {Foo} */ function Bar(){};",
"f(new Bar, /** @this{Foo} */function () {});"));
"g(f);"));return "type: " + root.toString();
JSType thisElement = thisTypeParams.getTemplateType(key);
JSType thatElement = thatTypeParams.getTemplateType(key);
iObjectIndexTemplateKey = new TemplateType(this, I_OBJECT_INDEX_TEMPLATE);
iObjectElementTemplateKey = new TemplateType(this, I_OBJECT_ELEMENT_TEMPLATE);
setReferencedType(referencedType);return orderOfAddition.get(b).intValue() -
orderOfAddition.get(a).intValue();return (mask & STRUCT_MASK) != 0;
return (mask & DICT_MASK) != 0;
return mask == (mask & other.mask);
if (this == TOP_OBJECT) {boolean needsEs6DartRuntime = false;
public Annotation getAnnotation() {
return annotation;
&& !info.containsFunctionDeclaration()) {
if (isFunctionDecl(n)) {
reportMisplaced(n, "template",
"The template variable is unused."
+ " Please remove the @template annotation.");
reportMisplaced(n, "template",
"@template is only allowed in class, constructor, interface, function "
+ "or method declarations");
private boolean isFunctionDecl(Node n) {
return n.isFunction()
|| (n.isVar() && n.getFirstChild().getFirstChild() != null
&& n.getFirstChild().getFirstChild().isFunction())
|| n.isAssign() && n.getFirstChild().isQualifiedName() && n.getLastChild().isFunction();
hidden = true,
handler = BooleanOptionHandler.class,
usage = "Rewrite Dart Dev Compiler output to be compiler-friendly.")
private boolean dartPass = false;
options.setDartPass(flags.dartPass);
boolean dartPass;
dartPass = false;
public void setDartPass(boolean dartPass) {
this.dartPass = dartPass;
if (options.dartPass) {
if (!options.getLanguageOut().isEs5OrHigher()) {
throw new InvalidOptionsException("Dart requires --language_out=ES5 or higher.");
options.setAmbiguateProperties(false);
options.setDisambiguateProperties(false);
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
public final class DartSuperAccessorsPass implements NodeTraversal.Callback,
HotSwapCompilerPass {
static final String CALL_SUPER_GET = "$jscomp.superGet";
static final String CALL_SUPER_SET = "$jscomp.superSet";
private final AbstractCompiler compiler;
private final boolean renameProperties;
public DartSuperAccessorsPass(AbstractCompiler compiler) {
this.compiler = compiler;
CompilerOptions options = compiler.getOptions();
this.renameProperties = options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED;
Preconditions.checkState(options.getLanguageOut().isEs5OrHigher(),
"Dart super accessors pass requires ES5+ output");
Preconditions.checkState(!options.ambiguateProperties && !options.disambiguateProperties,
"Dart super accessors pass is not compatible with property (dis)ambiguation yet");
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
if (isSuperGet(n)) {
visitSuperGet(n);
return false;
if (!n.isAssign()) {
n = normalizeAssignmentOp(n);
visitSuperSet(n);
return false;
return true;
private static boolean isCalled(Node n) {
Node parent = n.getParent();
return parent.isCall() && (n == parent.getFirstChild());
private static Node normalizeAssignmentOp(Node n) {
Node lhs = n.getFirstChild();
Node rhs = n.getLastChild();
Node newRhs = new Node(NodeUtil.getOpFromAssignmentOp(n),
lhs.cloneTree(), rhs.cloneTree()).srcrefTree(n);
return replace(n, IR.assign(lhs.cloneTree(), newRhs).srcrefTree(n));
public void visit(NodeTraversal t, Node n, Node parent) {}
private boolean isSuperGet(Node n) {
return (n.isGetProp() || n.isGetElem())
&& !isCalled(n)
&& n.getFirstChild().isSuper()
&& isInsideInstanceMember(n);
private boolean isSuperSet(Node n) {
return NodeUtil.isAssignmentOp(n) && isSuperGet(n.getFirstChild());
private static boolean isInsideInstanceMember(Node n) {
while (n != null) {
if (n.isMemberFunctionDef()
|| n.isGetterDef()
|| n.isSetterDef()
|| n.isComputedProp()) {
return !n.isStaticMember();
if (n.isClass()) {
return false;
n = n.getParent();
return false;
private void visitSuperGet(Node superGet) {
Node name = superGet.getLastChild().cloneTree();
Node callSuperGet = IR.call(
NodeUtil.newQName(compiler, CALL_SUPER_GET),
IR.thisNode(),
superGet.isGetProp() ? renameProperty(name) : name);
replace(superGet, callSuperGet.srcrefTree(superGet));
reportEs6Change();
private void visitSuperSet(Node superSet) {
Preconditions.checkArgument(superSet.isAssign());
NodeTraversal.traverse(compiler, superSet.getLastChild(), this);
Node rhs = superSet.getLastChild();
Node superGet = superSet.getFirstChild();
Node name = superGet.getLastChild().cloneTree();
Node callSuperSet = IR.call(
NodeUtil.newQName(compiler, CALL_SUPER_SET),
IR.thisNode(),
superGet.isGetProp() ? renameProperty(name) : name,
rhs.cloneTree());
replace(superSet, callSuperSet.srcrefTree(superSet));
reportEs6Change();
private void reportEs6Change() {
compiler.needsEs6Runtime = true;
compiler.needsEs6DartRuntime = true;
compiler.reportCodeChange();
private static Node replace(Node original, Node replacement) {
original.getParent().replaceChild(original, replacement);
return replacement;
private Node renameProperty(Node propertyName) {
Preconditions.checkArgument(propertyName.isString());
if (!renameProperties) {
return propertyName;
Node call = IR.call(IR.name(NodeUtil.JSC_PROPERTY_NAME_FN), propertyName);
call.srcrefTree(propertyName);
call.putBooleanProp(Node.FREE_CALL, true);
call.putBooleanProp(Node.IS_CONSTANT_NAME, true);
return call;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, externs, this);
NodeTraversal.traverse(compiler, root, this);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverse(compiler, scriptRoot, this);
if (options.dartPass && !options.getLanguageOut().isEs6OrHigher()) {
checks.add(dartSuperAccessorsPass);
int dartSuperAccessorsIndex = checks.indexOf(dartSuperAccessorsPass);
int es6ConvertSuperIndex = checks.indexOf(es6ConvertSuper);
"The Polymer pass must run before suspiciousCode processing.");
if (dartSuperAccessorsIndex != -1 && es6ConvertSuperIndex != -1) {
Preconditions.checkState(dartSuperAccessorsIndex < es6ConvertSuperIndex,
"The Dart super accessors pass must run before ES6->ES3 super lowering.");
private final HotSwapPassFactory dartSuperAccessorsPass =
new HotSwapPassFactory("dartSuperAccessorsPass", true) {
protected HotSwapCompilerPass create(AbstractCompiler compiler) {
return new DartSuperAccessorsPass(compiler);
import com.google.javascript.rhino.JSDocInfoBuilder;
import com.google.javascript.rhino.JSTypeExpression;
JSDocInfoBuilder jsdoc = new JSDocInfoBuilder(false);
jsdoc.recordType(
new JSTypeExpression(
new Node(Token.BANG, IR.string("Arguments")), "<Es6RewriteArrowFunction>"));
argumentsVar.setJSDocInfo(jsdoc.build());
return commonTypes.getArrayInstance();
if (compiler.needsEs6DartRuntime) {
compiler.ensureLibraryInjected("es6_dart_runtime", false);
if (!JSType.haveCommonSubtype(fromType, toType) && !fromType.hasTypeVariable()) {
warnings.add(JSError.make(expr, INVALID_CAST, fromType.toString(), toType.toString()));
return getMask() == TYPEVAR_MASK;
public boolean hasTypeVariable() {
return (getMask() & TYPEVAR_MASK) != 0;
private Node transformNodeWithInlineJsDoc(ParseTree node) {
JSDocInfo info = handleInlineJsDoc(node);
private JSDocInfo handleInlineJsDoc(ParseTree node) {
return handleInlineJsDoc(node.location);
com.google.javascript.jscomp.parsing.parser.Token token) {
return handleInlineJsDoc(token.location);
private JSDocInfo handleInlineJsDoc(SourceRange location) {
if (comment != null && !comment.value.contains("@")) {
Node paramNode = transformNodeWithInlineJsDoc(param);
JSDocInfo info = handleInlineJsDoc(identifierToken);
node.addChildToBack(transformNodeWithInlineJsDoc(child));
Node node = transformNodeWithInlineJsDoc(decl.lvalue);
Node exportSpec = newNode(Token.EXPORT_SPEC,
processName(tree.importedName));
exportSpec.addChildToBack(processName(tree.destinationName));
Node importSpec = newNode(Token.IMPORT_SPEC,
processName(tree.importedName));
while (peekId()) {
IdentifierToken importedName = eatId();
while (peekId()) {
IdentifierToken importedName = eatId();
destinationName = eatId();
TokenType type = peekType();
if (type == TokenType.IDENTIFIER || Keywords.isKeyword(type)) {
if (peekId() || Keywords.isKeyword(peekType())) {
if (printType && typei != null) {
String typeString = typei.toString();
if (typeString != null) {
sb.append(" : ");
sb.append(typeString);
case NEW:
case CALL:
case STRING_KEY:
case REGEXP:
case ARRAYLIT:
case OBJECTLIT:
case TEMPLATELIT:
case TRY:
case PARAM_LIST:
case IF:
case SWITCH:
case FOR:
case BREAK:
case CONTINUE:
case VAR:
case BLOCK:
case SCRIPT:
case CONST:
case DEBUGGER:
case ANNOTATION:
case PIPE:
case STAR:
case EOC:
case QMARK:
case ELLIPSIS:
case BANG:
case EQUALS:
case LB:
case LC:
case COLON:
case YIELD:
case NAME:
case LABEL_NAME:
case NUMBER:
case STRING:
case NULL:
case THIS:
case FALSE:
case TRUE:
case EMPTY:
case REST:
case IMPORT_STAR:
case MEMBER_VARIABLE_DEF:
return 0;
case NOT:
case BITNOT:
case POS:
case NEG:
case DELPROP:
case TYPEOF:
case THROW:
case TEMPLATELIT_SUB:
case MEMBER_FUNCTION_DEF:
case INC:
case DEC:
case DEFAULT_CASE:
case EXPR_RESULT:
case GETTER_DEF:
case SETTER_DEF:
case CAST:
case SPREAD:
case VOID:
case NAMED_TYPE:
case TYPE_ALIAS:
case INDEX_SIGNATURE:
case CALL_SIGNATURE:
return 1;
case ENUM:
case NAMESPACE:
case CLASS:
case HOOK:
case FUNCTION:
case FOR_OF:
Map<String, JSType> propTypeMap = new HashMap<>();
if (referencedObjType != null
&& !referencedObjType.isUnknownType()
&& propertyContinuations != null) {
for (PropertyContinuation c : propertyContinuations) {
c.commit(this);
Map<String, JSType> propTypeMap = new HashMap<>();
boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) {
return referencedObjType == null
|| referencedObjType.defineProperty(propertyName, type, inferred, propertyNode);
Map<String, JSType> propTypeMap = new HashMap<>();
enableTypeCheck();
enableTypeCheck();
super.enableTypeCheck();
enableTypeCheck();
public void testInlineJSDoc() {
testSame("function f(/** string */ x) {}");
testSame("function f(/** @type {string} */ x) {}");
testSame("var /** string */ x = 'x';");
testSame("var /** @type {string} */ x = 'x';");
testSame("var /** string */ x, /** number */ y;");
testSame("var /** @type {string} */ x, /** @type {number} */ y;");
public void testObjectLiterals() {
testSame("var o = { /** @type {?} */ x: y };");
testWarning("var o = { x: /** @type {?} */ y };", MISPLACED_ANNOTATION);
public void testBadTemplate1() {
public void testBadTemplate2() {
public void testBadTemplate3() {
testBadTemplate("/** @template T */ function f() {}");
testBadTemplate("/** @template T */ var f = function() {};");
testBadTemplate("/** @template T */ Foo.prototype.f = function() {};");
enableTypeCheck();
enableTypeCheck();
this.enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
reportMissingOverrideCheckLevel = level;
public void enableTypeCheck() {
TypeCheck check = createTypeCheck(compiler, reportMissingOverrideCheckLevel);
TypeCheck check = createTypeCheck(compiler, reportMissingOverrideCheckLevel);
package com.google.javascript.jscomp;
import com.google.common.collect.ImmutableList;
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
public final class DartSuperAccessorsPassTest extends CompilerTestCase {
private static final ImmutableList<String> MEMBER_SIGNATURES = ImmutableList.of(
"constructor()",
"method()", "*generator()", "get prop()", "set prop(v)",
"[method]()", "*[generator]()", "get [prop]()", "set [prop](v)");
private PropertyRenamingPolicy propertyRenaming;
public void setUp() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
runTypeCheckAfterProcessing = true;
propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;
protected CompilerOptions getOptions() {
CompilerOptions options = super.getOptions();
options.setLanguageOut(LanguageMode.ECMASCRIPT5);
options.setDartPass(true);
options.setAmbiguateProperties(false);
options.setDisambiguateProperties(false);
options.setPropertyRenaming(propertyRenaming);
return options;
protected final PassFactory makePassFactory(
String name, final CompilerPass pass) {
return new PassFactory(name, true/* one-time pass */) {
protected CompilerPass create(AbstractCompiler compiler) {
return pass;
public CompilerPass getProcessor(final Compiler compiler) {
PhaseOptimizer optimizer = new PhaseOptimizer(compiler, null, null);
optimizer.addOneTimePass(
makePassFactory("dartSuperAccessors", new DartSuperAccessorsPass(compiler)));
return optimizer;
protected int getNumRepetitions() {
return 1;
public void testSuperGetElem() {
checkConversionWithinMembers(
"return super['prop']",
"return $jscomp.superGet(this, 'prop')");
public void testSuperGetProp_renameOff() {
propertyRenaming = PropertyRenamingPolicy.OFF;
checkConversionWithinMembers(
"return super.prop",
"return $jscomp.superGet(this, 'prop')");
public void testSuperGetProp_renameAll() {
propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;
checkConversionWithinMembers(
"return super.prop",
"return $jscomp.superGet(this, JSCompiler_renameProperty('prop'))");
public void testSuperSetElem() {
checkConversionWithinMembers(
"super['prop'] = x",
"$jscomp.superSet(this, 'prop', x)");
public void testSuperSetProp_renameOff() {
propertyRenaming = PropertyRenamingPolicy.OFF;
checkConversionWithinMembers(
"super.prop = x",
"$jscomp.superSet(this, 'prop', x)");
public void testSuperSetProp_renameAll() {
propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;
checkConversionWithinMembers(
"super.prop = x",
"$jscomp.superSet(this, JSCompiler_renameProperty('prop'), x)");
public void testSuperSetAssignmentOps() {
propertyRenaming = PropertyRenamingPolicy.OFF;
checkConversionWithinMembers(
"super.a |= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') | b)");
checkConversionWithinMembers(
"super.a ^= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') ^ b)");
checkConversionWithinMembers(
"super.a &= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') & b)");
checkConversionWithinMembers(
"super.a <<= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') << b)");
checkConversionWithinMembers(
"super.a >>= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') >> b)");
checkConversionWithinMembers(
"super.a >>>= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') >>> b)");
checkConversionWithinMembers(
"super.a += b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') + b)");
checkConversionWithinMembers(
"super.a -= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') - b)");
checkConversionWithinMembers(
"super.a *= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') * b)");
checkConversionWithinMembers(
"super.a /= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') / b)");
checkConversionWithinMembers(
"super.a %= b",
"$jscomp.superSet(this, 'a', $jscomp.superGet(this, 'a') % b)");
public void testSuperSetRecursion() {
checkConversionWithinMembers(
"super['x'] = super['y']",
"$jscomp.superSet(this, 'x', $jscomp.superGet(this, 'y'))");
checkConversionWithinMembers(
"super['x'] = super['y'] = 10",
"$jscomp.superSet(this, 'x', $jscomp.superSet(this, 'y', 10))");
checkConversionWithinMembers(
"super['x'] += super['y']",
"$jscomp.superSet(this, 'x', $jscomp.superGet(this, 'x') + $jscomp.superGet(this, 'y'))");
public void testExpressionsWithoutSuperAccessors() {
String body = LINE_JOINER.join(
"foo.bar;",
"foo.bar();",
"this.bar;",
"this.bar();",
"super();",
"super.bar();");
for (String sig : MEMBER_SIGNATURES) {
testSame(wrap(sig, body));
public void testSuperAccessorsOutsideInstanceMembers() {
String body = LINE_JOINER.join(
"super.x;",
"super.x = y;");
testSame(body);
for (String sig : MEMBER_SIGNATURES) {
testSame(wrap("static " + sig, body));
private void checkConversionWithinMembers(String js, String expected) {
for (String sig : MEMBER_SIGNATURES) {
test(wrap(sig, js), wrap(sig, expected));
private String wrap(String memberSignature, String body) {
return LINE_JOINER.join(
"class X extends Y {",
"  " + memberSignature + " {",
"    " + body,
"  }",
"}");
enableTypeCheck();
enableTypeCheck();
super.enableTypeCheck();
public void testArguments() {
test(
LINE_JOINER.join(
"function f() {",
"  var x = () => arguments;",
"}"),
LINE_JOINER.join(
"function f() {",
"  /** @type {!Arguments} */",
"  const $jscomp$arguments = arguments;",
"  var x = function() { return $jscomp$arguments; };",
"}"));
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
super.enableTypeCheck();
enableTypeCheck();
typeCheck("/** @const */ var x = [];");
typeCheck(Joiner.on('\n').join(
"/** @const */",
"var x = [];",
"function f() {",
"  x[0] = 'asdf';",
"}",
"function g() {",
"  return x[0] - 5;",
"}"));
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @param {T} x",
" */",
"function f(x) {",
"  /** @type{!Object} */ (x);",
"}"));
typeCheck(Joiner.on('\n').join(
"/**",
" * @template T",
" * @param {T|string} x",
" */",
"function f(x) {",
"  /** @type{!Object} */ (x);",
"}"));
public void testConstEmptyArrayNoWarning() {
typeCheck("const x = [];");
enableTypeCheck();
LINE_JOINER.join("goog.require('module$other');", "use(module$other.default);"));
LINE_JOINER.join("goog.require('module$other');", "use(module$other.default);"));
"export {name} from 'other';",
"module$testcode.name = module$other.name;"));
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
super.enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
import static com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT;
enableTypeCheck();
"/** @constructor */ function Foo() {}"
+ "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @param {number} x */ SubFoo.prototype.bar = "
+ "    function(x) { return 3; }",
"inconsistent return type\n" + "found   : number\n" + "required: undefined");
"/** @param {string} x */ function f(x) {}"
+ "/** @constructor */ function Foo() {}"
+ "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @return {void} */ SubFoo.prototype.bar = "
+ "    function(x) { f(x); }",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : number\n"
+ "required: string");
"/** @param {string} x */ function f(x) {}"
+ "/** @constructor */ function Foo() {}"
+ "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @return {void} */ SubFoo.prototype.bar = "
+ "    function(x) { f(x); }; (new SubFoo()).bar();",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : (number|undefined)\n"
+ "required: string");
"/** @param {string} x */ function f(x) {}"
+ "/** @constructor */ function Foo() {}"
+ "/** @param {...number} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @return {void} */ SubFoo.prototype.bar = "
+ "    function(x) { f(x); }; (new SubFoo()).bar();",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : (number|undefined)\n"
+ "required: string");
"/** @param {string} x */ function f(x) {}"
+ "/** @constructor */ function Foo() {}"
+ "/** @param {...number} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @param {number=} x \n * @param {...number} y  */ "
+ "SubFoo.prototype.bar = "
+ "    function(x, y) { f(x); }; (new SubFoo()).bar();",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : (number|undefined)\n"
+ "required: string");
"/** @param {string} x */ function f(x) {}"
+ "/** @constructor */ function Foo() {}"
+ "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
+ "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+ "/** @override @param {number=} x \n * @param {number=} y */ "
+ "SubFoo.prototype.bar = "
+ "    function(x, y) { f(y); };",
"actual parameter 1 of f does not match formal parameter\n"
+ "found   : (number|undefined)\n"
+ "required: string");
"/** @constructor */ function Foo() {}"
+ "Foo.prototype = {"
+ "  /** @return {Bar} */ x: function() { new Bar(); },"
+ "  /** @return {Foo} */ y: function() { new Bar(); }"
+ "};"
+ "/**\n"
+ " * @constructor\n"
+ " * @extends {Foo}\n"
+ " */\n"
+ "function Bar() {"
+ "  this.xy = 3;"
+ "}"
+ "/** @return {Bar} */ function f() { return new Bar(); }"
+ "/** @return {Foo} */ function g() { return new Bar(); }"
+ "Bar.prototype = {"
+ "  /** @override @return {Bar} */ x: function() { new Bar(); },"
+ "  /** @override @return {Foo} */ y: function() { new Bar(); }"
+ "};"
+ "Bar.prototype.__proto__ = Foo.prototype;");
"var goog = {};"
+ "/** @constructor */goog.Super = function() {};"
+ "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};"
+ "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+ "/** @override @param {string} x */ goog.Sub.prototype.foo = function(x) {};",
"mismatch of the foo property type and the type of the property it "
+ "overrides from superclass goog.Super\n"
+ "original: function (this:goog.Super, number): undefined\n"
+ "override: function (this:goog.Sub, string): undefined");
testTypes(
"/** @interface */ function T() {};\n"
+ "/** @type {number} */T.prototype.x;\n"
+ "/** @constructor \n"
+ " *  @implements {T} \n"
+ " */\n"
+ "function C() {}\n"
+ "/** @override */\n"
+ "C.prototype.x = 'foo';",
"mismatch of the x property type and the type of the property it "
+ "overrides from interface T\n"
+ "original: number\n"
+ "override: string");
"function defineClass(x, y) { return function() {}; } "
+ "/** @constructor */"
+ "var Foo = function() {};"
+ "/** @return {*} */ Foo.prototype.bar = function() { return 3; };"
+ "/**\n"
+ " * @constructor\n"
+ " * @extends {Foo}\n"
+ " */\n"
+ "var SubFoo = defineClass(Foo, "
+ "    /** @lends {SubFoo.prototype} */ ({\n"
+ "      /** @override @return {number} */ bar: function() { return 3; }}));"
+ "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
"inconsistent return type\n" + "found   : number\n" + "required: string");
"/** @record */",
"/** @record */",
"/** @record */",
"/** @record */",
"/** @record */",
"/** @interface */",
"/** @record */",
"/** @interface */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @interface */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @record */",
"/** @constructor */",
"/** @interface */",
"/** @constructor */",
"/** @interface */",
"/** @constructor */",
"/** @constructor */",
"/** @constructor */",
"/** @constructor */",
"/** @constructor */",
"/** @constructor */",
"/** @constructor */",
testTypes(
"/** @record */",
"/** @record */",
"/** @constructor */",
"variable fun redefined, original definition at [testcode]:14");
testTypes(
"/** @type {{x:number}} */ ns.x;"));
testTypes(
+ "at [testcode]:2 with type {x: number}");
testTypes(
+ "original definition at [testcode]:2 with type {x: number}");
testTypes(
"/** @record */ function rec3(){}",
"/** @record */ function rec4(){}",
"/** @type {!rec4} */ ns.x;"));
testTypes(
"/** @record */ function rec3(){}",
"/** @record */ function rec4(){}",
+ "[testcode]:5 with type rec3");
testTypes(
"/** @record */ function rec3(){}",
"/** @record */ function rec4(){}",
+ "[testcode]:5 with type rec3");
testTypes(
"  td1 = td2;"));
testTypes(
"/** @record */ function rec(){}",
"/** @type {!rec} */ ns.y;"));
testTypes(
"/** @record */ function rec(){}",
+ "definition at [testcode]:5 with type rec");
testTypes(
"/** @record */ function rec(){}",
+ "[testcode]:8 with type {prop: number}");
testTypes(
"/** @record */ function rec(){}",
"/** @type {{prop:I}} */ ns.x;"));
testTypes(
"/** @record */ function rec(){}",
"/** @type {{prop:I<number>}} */ ns.x;"));
testTypes(
"/** @record */ function rec(){}",
+ "original definition at [testcode]:7 with type rec");
testTypes(
+ "original definition at [testcode]:5 with type (null|rec<string>)");
return new TypeCheck(compiler, new SemanticReverseAbstractInterpreter(registry), registry);
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
enableTypeCheck();
parse("function f(/** @type {string} */ x) {}");
parse(
" */ x) {}");private ParseTree parseArrowFunction(Expression expressionIn) {
SourcePosition start = getTreeStartLocation();
GenericTypeListTree generics = maybeParseGenericTypes();
FormalParameterListTree formalParameterList;
if (peekId()) {
ParseTree param = parseIdentifierExpression();
formalParameterList = new FormalParameterListTree(getTreeLocation(start),
ImmutableList.of(param));
formalParameterList = parseFormalParameterList(ParamContext.IMPLEMENTATION);
private boolean peekArrowFunction() {
if (peekId() && peekType(1) == TokenType.ARROW) {
return true;
return peekArrowFunctionWithParenthesizedParameterList(ParamContext.IMPLEMENTATION);
private boolean peekArrowFunctionWithParenthesizedParameterList(ParamContext context) {
if (peekArrowFunctionWithParenthesizedParameterList(ParamContext.TYPE_EXPRESSION)) {
return parseParenExpression();
private ParseTree parseParenExpression() {
if (peek(TokenType.COMMA)) {
while (peek(TokenType.COMMA)) {
if (peekArrowFunction()) {
return parseArrowFunction(expressionIn);
public void testFunctionParamDeclaration_arrow() {
public void testFunctionReturn_arrow() {
test("var x = <K, V>(p) => 3;", "var x = /** @template K, V */ (p) => 3");
parseError("f = (...xs, x) => xs", "A rest parameter must be last in a parameter list.");
public void testFunctionParamDeclaration_arrow() {
public void testFunctionReturn_arrow() {
parse("(number): () => number => number;");
parse("var x = <K, V>(p) => 3;");continue;TypeCheck.CONFLICTING_EXTENDED_TYPE,
TypeCheck.ENUM_NOT_CONSTANT,
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
TypeCheck.MULTIPLE_VAR_DEF,
TypeCheck.UNKNOWN_OVERRIDE,
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,
TypeCheck.CONSTRUCTOR_NOT_CALLABLE,
TypeCheck.ILLEGAL_OBJLIT_KEY,
TypeCheck.IN_USED_WITH_STRUCT,
TypeCheck.NOT_CALLABLE,
TypeValidator.UNKNOWN_TYPEOF_VALUE);
"JSC_DUPLICATE_JSDOC",
"JSC_REDECLARED_PROPERTY",
"JSC_INVALID_PROP_OVERRIDE",
"JSC_CTOR_IN_DIFFERENT_SCOPE",
"JSC_UNRECOGNIZED_TYPE_NAME",
"JSC_STRUCTDICT_WITHOUT_CTOR",
"JSC_EXPECTED_CONSTRUCTOR",
"JSC_EXPECTED_INTERFACE",
"JSC_INEXISTENT_PARAM",
"JSC_CONST_WITHOUT_INITIALIZER",
"JSC_COULD_NOT_INFER_CONST_TYPE",
"JSC_MISPLACED_CONST_ANNOTATION",
"JSC_CANNOT_OVERRIDE_FINAL_METHOD",
"JSC_CANNOT_INIT_TYPEDEF",
"JSC_ANONYMOUS_NOMINAL_TYPE",
"JSC_MALFORMED_ENUM",
"JSC_DUPLICATE_PROP_IN_ENUM",
"JSC_UNDECLARED_NAMESPACE",
"JSC_LENDS_ON_BAD_TYPE",
"JSC_FUNCTION_CONSTRUCTOR_NOT_DEFINED",
"JSC_INVALID_INTERFACE_PROP_INITIALIZER",
"JSC_SETTER_WITH_RETURN",
"JSC_WRONG_PARAMETER_COUNT",
"JSC_CANNOT_ADD_PROPERTIES_TO_TYPEDEF",
WRONG_PARAMETER_COUNT,
TypeCheck.CONFLICTING_EXTENDED_TYPE,
TypeCheck.ENUM_NOT_CONSTANT,
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
TypeCheck.MULTIPLE_VAR_DEF,
TypeCheck.UNKNOWN_OVERRIDE,
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED //,
Node defSite = rawType.getDefSite();
defSite, TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
NodeUtil.getNearestFunctionName(defSite), pname, "", ""));
warnings.add(JSError.make(propDefsite, TypeCheck.UNKNOWN_OVERRIDE,
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,
warnings.add(
JSError.make(prop, TypeCheck.ENUM_NOT_CONSTANT, pname));
warnings.add(JSError.make(initializer, TypeCheck.INTERFACE_METHOD_NOT_EMPTY));
warnings.add(JSError.make(varNode, TypeCheck.MULTIPLE_VAR_DEF));
"JSC_MISTYPED_ASSIGN_RHS",
"The right side in the assignment is not a subtype of the left side.\n" +
"left side  : {0}\n" +
"right side : {1}\n");
"JSC_INVALID_OPERAND_TYPE",
"JSC_RETURN_NONDECLARED_TYPE",
"JSC_INVALID_INFERRED_RETURN_TYPE",
"JSC_INVALID_ARGUMENT_TYPE",
"JSC_CROSS_SCOPE_GOTCHA",
"JSC_POSSIBLY_INEXISTENT_PROPERTY",
"JSC_NULLABLE_DEREFERENCE",
"JSC_PROPERTY_ACCESS_ON_NONOBJECT",
"JSC_NOT_UNIQUE_INSTANTIATION",
"JSC_FAILED_TO_UNIFY",
"JSC_NON_NUMERIC_ARRAY_INDEX",
"JSC_INVALID_OBJLIT_PROPERTY_TYPE",
"JSC_FORIN_EXPECTS_OBJECT",
"JSC_FORIN_EXPECTS_STRING_KEY",
"JSC_CONST_REASSIGNED",
"JSC_CONST_PROPERTY_REASSIGNED",
"JSC_NOT_A_CONSTRUCTOR",
"JSC_ASSERT_FALSE",
"JSC_UNKNOWN_ASSERTION_TYPE",
"JSC_INVALID_THIS_TYPE_IN_BIND",
"JSC_CANNOT_BIND_CTOR",
"JSC_GOOG_BIND_EXPECTS_FUNCTION",
"JSC_BOTTOM_PROP",
DiagnosticType.warning("JSC_INVALID_CAST",
CheckGlobalThis.GLOBAL_THIS,
CheckMissingReturn.MISSING_RETURN_STATEMENT,
TypeCheck.CONSTRUCTOR_NOT_CALLABLE,
TypeCheck.ILLEGAL_OBJLIT_KEY,
TypeCheck.ILLEGAL_PROPERTY_CREATION,
TypeCheck.IN_USED_WITH_STRUCT,
TypeCheck.INEXISTENT_PROPERTY,
TypeCheck.NOT_CALLABLE,
TypeCheck.WRONG_ARGUMENT_COUNT,
TypeValidator.ILLEGAL_PROPERTY_ACCESS,
TypeValidator.UNKNOWN_TYPEOF_VALUE);
warnings.add(JSError.make(obj, TypeCheck.IN_USED_WITH_STRUCT));
warnings.add(JSError.make(fnRoot,
CheckMissingReturn.MISSING_RETURN_STATEMENT,
declRetType.toString()));
expr, TypeCheck.NOT_CALLABLE, calleeType.toString()));
warnings.add(JSError.make(
expr, TypeCheck.CONSTRUCTOR_NOT_CALLABLE, funType.toString()));
expr, TypeCheck.WRONG_ARGUMENT_COUNT,
call, TypeCheck.WRONG_ARGUMENT_COUNT,
call, TypeCheck.WRONG_ARGUMENT_COUNT,
warnings.add(JSError.make(rhs, TypeCheck.IN_USED_WITH_STRUCT));
warnings.add(JSError.make(
typeString, TypeValidator.UNKNOWN_TYPEOF_VALUE, typeName));
warnings.add(JSError.make(prop, TypeCheck.ILLEGAL_OBJLIT_KEY, "struct"));
warnings.add(JSError.make(prop, TypeCheck.ILLEGAL_OBJLIT_KEY, "dict"));
warnings.add(JSError.make(call, TypeCheck.WRONG_ARGUMENT_COUNT,
TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'[]'", "struct"));
TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict"));
warnings.add(JSError.make(getProp, TypeCheck.ILLEGAL_PROPERTY_CREATION));
? POSSIBLY_INEXISTENT_PROPERTY : TypeCheck.INEXISTENT_PROPERTY;
warnings.add(JSError.make(thisExpr, CheckGlobalThis.GLOBAL_THIS));
"ILLEGAL_OBJLIT_KEY",
"JSC_INVALID_GENERICS_INSTANTIATION",
"JSC_BAD_JSDOC_ANNOTATION",
"JSC_EXTENDS_NON_OBJECT",
"JSC_EXTENDS_NOT_ON_CTOR_OR_INTERF",
"JSC_INHERITANCE_CYCLE",
"JSC_DICT_IMPLEMENTS_INTERF",
"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR",
"JSC_CONFLICTING_SHAPE_TYPE",
"JSC_CONFLICTING_EXTENDED_TYPE",
"JSC_CONFLICTING_IMPLEMENTED_TYPE",
"JSC_UNION_IS_UNINHABITABLE",
typeCheck("this.x = 5;", CheckGlobalThis.GLOBAL_THIS);
typeCheck("function f() { this.p = 1; }", CheckGlobalThis.GLOBAL_THIS);
typeCheck("function f() { return this.p; }", CheckGlobalThis.GLOBAL_THIS);
typeCheck("function f() { this['p']; }", CheckGlobalThis.GLOBAL_THIS);
typeCheck("(function() { this.p; })();", CheckGlobalThis.GLOBAL_THIS);
TypeCheck.INEXISTENT_PROPERTY);
typeCheck("/** @type {number} */ var x, y;", TypeCheck.MULTIPLE_VAR_DEF);
CheckMissingReturn.MISSING_RETURN_STATEMENT);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck("function f() {}; f(5);", TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck("function f(x) { x-5; }; f();", TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.NOT_CALLABLE);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.NOT_CALLABLE);
typeCheck("var x = {}; x.foo.bar = 1;", TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
typeCheck("({}).p < 'asdf';", TypeCheck.INEXISTENT_PROPERTY);
typeCheck("var x = {}; var y = x.a;", TypeCheck.INEXISTENT_PROPERTY);
typeCheck("var x = {}; x.y - 3; x.y = 5;", TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeValidator.UNKNOWN_TYPEOF_VALUE);
TypeValidator.UNKNOWN_TYPEOF_VALUE);
TypeCheck.NOT_CALLABLE);
TypeCheck.INEXISTENT_PROPERTY);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.WRONG_ARGUMENT_COUNT);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.WRONG_ARGUMENT_COUNT);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.NOT_CALLABLE,
TypeCheck.NOT_CALLABLE);
"function f(opt_num, x) {}", RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
"function f(var_args, x) {}", RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INTERFACE_METHOD_NOT_EMPTY);
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
TypeCheck.CONFLICTING_EXTENDED_TYPE);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.UNKNOWN_OVERRIDE);
TypeCheck.UNKNOWN_OVERRIDE);
CheckMissingReturn.MISSING_RETURN_STATEMENT);
TypeCheck.UNKNOWN_OVERRIDE);
CheckGlobalThis.GLOBAL_THIS);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.NOT_CALLABLE,
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
typeCheck("(/** @struct */ { 'prop' : 1 });", TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
typeCheck("(/** @dict */ { prop : 1 });", TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeValidator.ILLEGAL_PROPERTY_ACCESS);
"(/** @dict */ {}).toString();", TypeValidator.ILLEGAL_PROPERTY_ACCESS);
typeCheck("('prop' in /** @struct */ {});", TypeCheck.IN_USED_WITH_STRUCT);
"for (var x in /** @struct */ {});", TypeCheck.IN_USED_WITH_STRUCT);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
TypeCheck.ILLEGAL_PROPERTY_CREATION,
TypeCheck.ILLEGAL_PROPERTY_CREATION);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.ILLEGAL_PROPERTY_CREATION,
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
"var x = /** @dict */ { get a() {} };", TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeCheck.NOT_CALLABLE);
TypeCheck.NOT_CALLABLE);
TypeCheck.ILLEGAL_PROPERTY_CREATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
"var x = /** @dict */ { set a(b) {} };", TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeCheck.ILLEGAL_OBJLIT_KEY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.NOT_CALLABLE);
TypeCheck.NOT_CALLABLE);
typeCheck(Joiner.on('\n').join(
"/** @const */ var ns = {};",
"/** @type {Object} */",
"ns.obj = { prop: 123 };",
"/**",
" * @suppress {duplicate}",
" * @type {Object}",
" */",
"ns.obj = null;"));
typeCheck(Joiner.on('\n').join(
"function f() {",
"  /** @const */",
"  var ns = {};",
"  /** @type {number} */",
"  ns.prop = 1;",
"  /**",
"   * @type {number}",
"   * @suppress {duplicate}",
"   */",
"  ns.prop = 2;",
"}"));
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.ENUM_NOT_CONSTANT);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION,
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(CLOSURE_BASE + "goog.isNull();", TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT,
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.WRONG_ARGUMENT_COUNT);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY,
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.INEXISTENT_PROPERTY);
typeCheck("taggedTemp`${this.a}TaggedTemp`", CheckGlobalThis.GLOBAL_THIS);
TypeCheck.INEXISTENT_PROPERTY);
TypeCheck.NOT_A_CONSTRUCTOR);
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
TypeCheck.CONFLICTING_EXTENDED_TYPE);
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
Predicate<Token> followPred = new Predicate<Token>() {
public boolean apply(Token t) {
return EnumSet.of(TokenType.IN, TokenType.EQUAL).contains(t.type)
|| (t.type == TokenType.IDENTIFIER
&& t.asIdentifier().value.equals(PredefinedName.OF));
ParseTree initializer = peekPattern(PatternKind.ANY, followPred)
? parsePattern(PatternKind.ANY)
: parseExpressionNoIn();
ParseTree left = peekParenPatternAssignment()
? parseParenPattern()
: parseConditional(expressionIn);
private boolean peekParenPatternAssignment() {
return peekParenPattern(PatternKind.ANY, assignmentFollowSet);
private boolean peekParenPatternStart() {
int index = 0;
while (peek(index, TokenType.OPEN_PAREN)) {
index++;
return peekPatternStart(index);
return peekPatternStart(0);
private boolean peekPatternStart(int index) {
return peek(index, TokenType.OPEN_SQUARE) || peek(index, TokenType.OPEN_CURLY);
private ParseTree parseParenPattern() {
return parseParenPattern(PatternKind.ANY);
private ParseTree parseParenPattern(PatternKind kind) {
if (peek(TokenType.OPEN_PAREN)) {
SourcePosition start = getTreeStartLocation();
eat(TokenType.OPEN_PAREN);
ParseTree result = parseParenPattern(kind);
eat(TokenType.CLOSE_PAREN);
return new ParenExpressionTree(this.getTreeLocation(start), result);
return parsePattern(kind);
private boolean peekPattern(PatternKind kind) {
return peekPattern(kind, Predicates.<Token>alwaysTrue());
private boolean peekPattern(PatternKind kind, Predicate<Token> follow) {
if (!peekPatternStart()) {
return false;
Parser p = createLookaheadParser();
try {
p.parsePattern(kind);
return follow.apply(p.peekToken());
return false;
private boolean peekParenPattern(PatternKind kind, EnumSet<TokenType> follow) {
if (!peekParenPatternStart()) {
return false;
Parser p = createLookaheadParser();
try {
p.parseParenPattern(kind);
return follow.contains(p.peekType());
return false;
private static final EnumSet<TokenType> assignmentFollowSet =
EnumSet.of(TokenType.EQUAL);
if (peekParenPatternStart()) {
lvalue = parseParenPattern(kind);
if (peekPattern(kind)) {
"var x; ({a: x}) = foo();",
"({[a]: b}) = foo();",
assertEarlyReference("({a: b}) = {}; var a, b;");
+ "({fg, bg}) = pal[val - 1];", "fg", "bg");
parse("({x, y}) = foo();");
parse("({x: x, y: y}) = foo();");
parse("({x: {y, z}}) = foo();");
parse("({k1: {k2 : x} = bar(), k3: y}) = foo();");
parse("({}) = foo();");
parse("({x = 1}) = foo();");
parse("({x: {y = 1}}) = foo();");
parse("({x: y = 1}) = foo();");
parse("({x: v1 = 5, y: v2 = 'str'}) = foo();");
parse("({k1: {k2 : x} = bar(), k3: y}) = foo();");
parse("({x}) = y;");
parse("(({x})) = y;");
parse("((({x}))) = y;");
parse("([x]) = y;");
parseError("for ({x: 5} in foo()) {}", "Invalid LHS for a for-in loop");
parseError("for ({x: 'str'} in foo()) {}", "Invalid LHS for a for-in loop");NodeTraversal.traverseEs6(compiler, externsRoot, new BuildGlobalNamespace());
NodeTraversal.traverseEs6(compiler, root, new BuildGlobalNamespace());
scope = scope.getClosestHoistScope();paramList.replaceChild(param, IR.name(tempVarName));boolean isNotDefinedAsProperty = n.isFunction() && n.getParent().isName();
if (isNotDefinedAsProperty && n.getParent().getParent().isVar()) {
return t.inGlobalHoistScope();
return t.getScopeDepth() <= 1;
return false;
if (!cfgRoots.isEmpty()) {
Preconditions.checkState(cfgRoots.pop() == scopeRoot);
cfgRoots.clear();
if (cfgRoots.isEmpty()) {
Scope currScope = scopes.peek();
while (currScope.isBlockScope()) {
currScope = currScope.getParent();
return currScope.getRootNode();
return cfgRoots.peek();
if (curNode.isFunction() && getCfgRoot() == curNode) {
if (cfgRoots.isEmpty()) {  // Scopes have been created, won't scan scopes.
return getClosestHoistScope().isGlobal();
Node temp = cfgRoots.pop();
boolean result = cfgRoots.isEmpty() || !cfgRoots.peek().isFunction();
cfgRoots.push(temp);
return result;
return !getCfgRoot().isFunction();
if (n.getParent() == null
|| n.getFirstChild() != null && n.getFirstChild().isScript()) {Node parent = n.getParent();
if (parent == null || parent.isCatch()) {
Node child = n.getFirstChild();
return child != null && !child.isScript();
NodeTraversal.traverseEs6(compiler, externs, new NameRefInExternsCheck());
assertThat(c3.getVisitedScopes()).hasSize(4);if (n.getParent() == null || n.getParent().isCatch()
|| n.getFirstChild() != null && n.getFirstChild().isScript()) {
return true;
NodeTraversal traversal = new NodeTraversal(
compiler, new NameRefInExternsCheck(), scopeCreator);
traversal.traverse(externs);
assertThat(c3.getVisitedScopes()).hasSize(5);Node parent = n.getParent();
if (parent == null || parent.isCatch()) {
Node child = n.getFirstChild();
return child != null && !child.isScript();
NodeTraversal.traverseEs6(compiler, externs, new NameRefInExternsCheck());
assertThat(c3.getVisitedScopes()).hasSize(4);if (t.getScope().getClosestHoistScope().isGlobal()
|| isInThrowExpression(n)) {
if (t.getClosestHoistScope().isGlobal()) {
boolean lookingAtScopeRoot = t.getScopeRoot() == n && t.getScopeDepth() == 1;
return t.getClosestHoistScope().isGlobal() || lookingAtScopeRoot;
return t.inGlobalScope() || lookingAtScopeRoot;
return t.inGlobalScope();
Node containingFunction = getContainingFunction(t);
return inlineLocalFunctions
|| nodeTraversal.getScope().getClosestHoistScope().isGlobal();
if ((t.inGlobalScope() && inlineGlobalFunctions)
|| (!t.inGlobalScope() && inlineLocalFunctions)) {
private static Node getContainingFunction(NodeTraversal t) {
Scope hoistScope = t.getScope().getClosestHoistScope();
return hoistScope.isGlobal() ? null : t.getScopeRoot().getParent();
Node root = t.getScopeRoot();
if (!t.getClosestHoistScope().isGlobal()) {
if (t.getClosestHoistScope().isGlobal()) {
if (parent.isCall() && t.inGlobalScope()) {
if (t.inGlobalScope()) {
boolean inFunction() {
return getCfgRoot().isFunction();
if (!t.inFunction() && !NodeUtil.isClassExpression(n)) {
if (!t.inFunction() &&
if (!n.getParent().isExprResult() || t.inFunction()) {
if (!t.inFunction() && info != null && info.hasTypedefType()) {
if (!t.inFunction()) {
if (t.getClosestHoistScope().isGlobal()) {
if (!t.getClosestHoistScope().isGlobal()) {
if (!t.getClosestHoistScope().isGlobal()
if (t.getScope().isGlobal()) {
Scope scope = t.getScope();
Node scopeRoot = scope.getRootNode();
Node enclosingFunctionBody = NodeUtil.getEnclosingFunction(scopeRoot).getLastChild();
&& !scope.isFunctionBlockScope()) {
for (Var v : scope.getVarIterable()) {
if (!parent.isCatch() && !parent.isLet() && !parent.isConst()) {
if (scopeRoot.getFirstChild().isCatch()) {
for (Var v : scope.getClosestHoistScope().getVarIterable()) {
if (NodeUtil.getEnclosingFunction(t.getScope().getRootNode()) != null) {
if (isGoogScopeFunctionBody(t.getClosestHoistScope().getRootNode())) {
test("if (window) { f(); function f() {} }", "");SourcePosition start = getTreeStartLocation();if (name != null && isInlinableGlobalAlias(name)) {
private static boolean isInlinableGlobalAlias(Name name) {
if (name.inExterns || name.globalSets != 1 || name.localSets != 0
|| !name.canCollapse()) {
return false;
for (Ref ref : name.getRefs()) {
switch (ref.type) {
case SET_FROM_GLOBAL:
continue;
case SET_FROM_LOCAL:
throw new IllegalStateException();
case ALIASING_GET:
case DIRECT_GET:
continue;
case PROTOTYPE_GET:
case CALL_GET:
case DELETE_PROP:
return false;
default:
throw new IllegalStateException();
return true;
if (rewriteClosureCode && i == 0) {
new ClosureRewriteClass(compiler).process(null, mainRoot);
new ClosureRewriteModule(compiler).process(null, mainRoot);
new ScopedAliases(compiler, null, CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER)
.process(null, mainRoot);
hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();final String envPrefix = options.getEnvironment().toString().toLowerCase()
+ "/";
ImmutableList.Builder<ZipEntry> builder = ImmutableList.builder();
builder.add(entry);
ImmutableList<ZipEntry> zipEntries = builder.build();
boolean flatExternStructure = true;
String browserEnv = CompilerOptions.Environment.BROWSER.toString().toLowerCase();
for (ZipEntry entry : zipEntries) {
if (entry.getName().contains(browserEnv)) {
break;
Map<String, SourceFile> externsMap = new HashMap<>();
for (ZipEntry entry : zipEntries) {
if (entry.getName().indexOf('/') < 0
|| flatExternStructure
|| (entry.getName().indexOf(envPrefix) == 0
&& entry.getName().length() > envPrefix.length())) {
externsMap.put(entry.getName(),
"externs.zip//" + entry.getName(),
externsMap.containsKey(key),
externs.add(externsMap.remove(key));
if (!key.contains(envPrefix)) {
externsMap.containsKey(key),
"Externs zip must contain %s when environment is %s.", key, options.getEnvironment());
externs.add(externsMap.remove(key));
externs.addAll(externsMap.values());checks.add(inlineTypeAliases);
private final PassFactory inlineTypeAliases =
new PassFactory("inlineTypeAliases", true) {
CompilerPass create(AbstractCompiler compiler) {
return new InlineAliases(compiler);
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.LinkedHashMap;
import java.util.Map;
final class InlineAliases extends AbstractPostOrderCallback implements CompilerPass {
private final AbstractCompiler compiler;
private final Map<String, String> aliases = new LinkedHashMap<>();
InlineAliases(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverseEs6(compiler, root, this);
private void visitAliasDefinition(Node lhs, JSDocInfo info) {
if (info != null && info.hasConstAnnotation() && lhs.isQualifiedName()) {
Node rhs = NodeUtil.getRValueOfLValue(lhs);
if (rhs != null && rhs.isQualifiedName()) {
aliases.put(lhs.getQualifiedName(), rhs.getQualifiedName());
public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.VAR:
if (n.getChildCount() == 1 && t.inGlobalScope()) {
visitAliasDefinition(n.getFirstChild(), n.getFirstChild().getJSDocInfo());
break;
case Token.ASSIGN:
if (parent != null && parent.isExprResult() && t.inGlobalScope()) {
visitAliasDefinition(n.getFirstChild(), n.getJSDocInfo());
break;
case Token.NAME:
case Token.GETPROP:
if (n.isQualifiedName() && aliases.containsKey(n.getQualifiedName())) {
String leftmostName = NodeUtil.getRootOfQualifiedName(n).getString();
Var v = t.getScope().getVar(leftmostName);
if (v != null && v.isLocal()) {
return;
Preconditions.checkState(!NodeUtil.isVarOrSimpleAssignLhs(n, parent));
parent.replaceChild(n, NodeUtil.newQName(compiler,
aliases.get(n.getQualifiedName())).copyInformationFromForTree(n));
compiler.reportCodeChange();
break;
maybeRewriteJsdoc(n.getJSDocInfo());
private void maybeRewriteJsdoc(JSDocInfo info) {
if (info == null) {
return;
for (Node typeNode : info.getTypeNodes()) {
NodeUtil.visitPreOrder(typeNode, fixJsdocTypeNodes, Predicates.<Node>alwaysTrue());
private final NodeUtil.Visitor fixJsdocTypeNodes = new NodeUtil.Visitor() {
public void visit(Node aliasReference) {
if (!aliasReference.isString()) {
return;
String fullTypeName = aliasReference.getString();
int dotIndex = 0;
do {
dotIndex = fullTypeName.indexOf('.', dotIndex + 1);
String aliasName = dotIndex == -1 ? fullTypeName : fullTypeName.substring(0, dotIndex);
if (aliases.containsKey(aliasName)) {
String replacement = aliases.get(aliasName) + fullTypeName.substring(aliasName.length());
aliasReference.setString(replacement);
return;
if (closurePassEnabled && i == 0) {
recentChange.reset();
new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, false)
.process(null, mainRoot);
hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();
package com.google.javascript.jscomp;
import com.google.common.collect.ImmutableList;
public class InlineAliasesTest extends Es6CompilerTestCase {
protected CompilerPass getProcessor(Compiler compiler) {
return new InlineAliases(compiler);
void testGoogModules(ImmutableList<SourceFile> inputs, ImmutableList<SourceFile> expecteds) {
enableClosurePass();
enableRewriteClosureCode();
test(inputs, expecteds);
public void testRewriteGoogModuleAliases1() {
testGoogModules(
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"goog.module('base');",
"",
"/** @constructor */ var Base = function() {}",
"exports = Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"goog.module('leaf');",
"",
"var Base = goog.require('base');",
"exports = /** @constructor @extends {Base} */ function Foo() {}"))),
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"var /** @const */ base = $jscomp.scope.Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"var /** @const */ leaf =",
"  /** @constructor @extends {$jscomp.scope.Base} */ function Foo(){}"))));
public void testRewriteGoogModuleAliases2() {
testGoogModules(
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"goog.module('ns.base');",
"",
"/** @constructor */ var Base = function() {}",
"exports = Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"goog.module('leaf');",
"",
"var Base = goog.require('ns.base');",
"exports = /** @constructor @extends {Base} */ function Foo() {}"))),
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"var /** @const */ ns={}; ",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"var /** @const */ leaf =",
"  /** @constructor @extends {$jscomp.scope.Base} */function Foo(){}"))));
public void testRewriteGoogModuleAliases3() {
testGoogModules(
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"goog.module('ns.base');",
"",
"/** @constructor */ var Base = function() {};",
"/** @constructor */ Base.Foo = function(){};",
"exports = Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"goog.module('leaf');",
"",
"var Base = goog.require('ns.base');",
"exports = /** @constructor @extends {Base.Foo} */ function Foo() {}"))),
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"var /** @const */ ns={}; ",
"/** @constructor */ $jscomp.scope.Base = function(){}",
"/** @constructor */ $jscomp.scope.Base.Foo = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"var /**@const*/ leaf =",
"  /**@constructor @extends {$jscomp.scope.Base.Foo}*/function Foo(){}"))));
public void testRewriteGoogModuleAliases4() {
testGoogModules(
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"goog.module('ns.base');",
"",
"/** @constructor */ var Base = function() {}",
"exports = Base;")),
SourceFile.fromCode("B", LINE_JOINER.join(
"goog.module('leaf');",
"",
"var Base = goog.require('ns.base');",
"exports = new Base;"))),
ImmutableList.of(
SourceFile.fromCode("A", LINE_JOINER.join(
"/** @const */ var $jscomp={}; /** @const */ $jscomp.scope={};",
"var /** @const */ ns={}; ",
"/** @constructor */ $jscomp.scope.Base = function(){};",
"/** @const */ ns.base = $jscomp.scope.Base;")),
SourceFile.fromCode("B",
"var /** @const */ leaf = new $jscomp.scope.Base;")));
public void testSimpleAliasInJSDoc() {
test("var /** @const */ alias = ns.Foo; /** @type {alias} */ var x;",
"var /** @const */ alias = ns.Foo; /** @type {ns.Foo} */ var x;");
test("/** @const */ mod.alias = ns.Foo; /** @type {mod.alias} */ var x;",
"/** @const */ mod.alias = ns.Foo; /** @type {ns.Foo} */ var x;");
test("/** @const */ mod.alias = ns.Foo; /** @type {mod.alias.Subfoo} */ var x;",
"/** @const */ mod.alias = ns.Foo; /** @type {ns.Foo.Subfoo} */ var x;");
public void testSimpleAliasInCode() {
test("var /** @const */ alias = ns.Foo; var x = new alias;",
"var /** @const */ alias = ns.Foo; var x = new ns.Foo;");
test("/** @const */ mod.alias = ns.Foo; var x = new mod.alias;",
"/** @const */ mod.alias = ns.Foo; var x = new ns.Foo;");
test("/** @const */ mod.alias = ns.Foo; var x = new mod.alias.Subfoo;",
"/** @const */ mod.alias = ns.Foo; var x = new ns.Foo.Subfoo;");
public void testTransitiveAliases() {
test(
LINE_JOINER.join(
"var /** @const */ alias = ns.Foo;",
"var /** @const */ alias2 = alias.Bar;",
"var x = new alias2"),
LINE_JOINER.join(
"var /** @const */ alias = ns.Foo;",
"var /** @const */ alias2 = ns.Foo.Bar;",
"var x = new ns.Foo.Bar;"));
public void testDefinesAreNotInlined() {
testSame("var /** @define {boolean} */ alias = ns.Foo; var x = new alias;");
public void testShadowedAliasesNotRenamed() {
testSame(
LINE_JOINER.join(
"var /** @const */ alias = ns.Foo;",
"function f(alias) {",
"  var x = alias",
"}"));
testSame(
LINE_JOINER.join(
"var /** @const */ alias = ns.Foo;",
"function f() {",
"  var /** @const */ alias = 5;",
"  var x = alias",
"}"));
testSame(
LINE_JOINER.join(
"/** @const */",
"var x = y;",
"function f() {",
"  var x = 123;",
"  function g() {",
"    return x;",
"  }",
"}"));if (rewriteClosureCode && i == 0) {
new ClosureRewriteClass(compiler).process(null, mainRoot);
new ClosureRewriteModule(compiler).process(null, mainRoot);
new ScopedAliases(compiler, null, CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER)
.process(null, mainRoot);
hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();class ConstParamCheck extends AbstractPostOrderCallback
implements CompilerPass {
private static boolean isStringLiteralValue(Node node) {
public void testNotConstantArgument() {
testError(CLOSURE_DEFS
+ "var foo = 'foo';"
+ "goog.string.Const.from(foo);",
ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, meetType);
lhsPair = analyzeExprFwd(lhs, rhsPair.env, JSType.UNKNOWN, lhsType);
rhs, lhsPair.env, JSType.UNKNOWN, JSType.NULL_OR_UNDEF);
lhs, inEnv, JSType.UNKNOWN, JSType.NULL_OR_UNDEF);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, rhsType);
lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, lhsType);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, rhsType);
lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, lhsType);
typeCheck(Joiner.on('\n').join(
"function f(/** (null | { prop: (null|number) }) */ x) {",
"  if (x.prop !== null) {",
"    return x.prop - 1;",
"  }",
"}"),
NewTypeInference.NULLABLE_DEREFERENCE);String[] sources = (String[]) consumer.getOriginalSources().toArray();
assertThat(sources).hasLength(1);
assertThat(sources[0]).isEqualTo("testcode");
String[] sources = (String[]) consumer.getOriginalSources().toArray();
assertThat(sources).hasLength(1);
assertThat(sources[0]).isEqualTo("testcode");NodeUtil.getFunctionName(defSite), pname, "", ""));
String functionName = NodeUtil.getFunctionName(fn);
warnings.add(JSError.make(
fn, INEXISTENT_PARAM, formalInJsdoc, functionName));
import com.google.javascript.rhino.StaticSourceFile;
private static String getFileWhereWarningOccurred(JSError warning) {
StaticSourceFile f = warning.node.getStaticSourceFile();
return f == null ? "" : f.getName();
if (getFileWhereWarningOccurred(warning).startsWith(" [synthetic")
Node value = IR.function(dummyName, paramList, body);
Node value = IR.function(dummyName, paramList, body);
protected final void parseAndTypeCheck(String externs, String js) {
+ Arrays.toString(warnings) + "\n"if (lvalue.isQualifiedName()) {
name = namespace.getSlot(lvalue.getQualifiedName());
if (name != null && isInlinableGlobalAlias(name)) {
List<AstChange> newNodes = new ArrayList<>();
List<Ref> refs = new ArrayList<>(name.getRefs());
for (Ref ref : refs) {
switch (ref.type) {
case SET_FROM_GLOBAL:
continue;
case DIRECT_GET:
case ALIASING_GET:
Node newNode = alias.node.cloneTree();
Node node = ref.node;
node.getParent().replaceChild(node, newNode);
newNodes.add(new AstChange(ref.module, ref.scope, newNode));
name.removeRef(ref);
break;
default:
throw new IllegalStateException();
rewriteAliasProps(name, alias.node, 0, newNodes);
aliasParent.replaceChild(alias.node, IR.nullNode());
compiler.reportCodeChange();
namespace.scanNewNodes(newNodes);
return true;
Name name, Node value, int depth, List<AstChange> newNodes) {
if (name.props != null) {
Preconditions.checkState(!
value.matchesQualifiedName(name.getFullName()));
for (Name prop : name.props) {
rewriteAliasProps(prop, value, depth + 1, newNodes);
List<Ref> refs = new ArrayList<>(prop.getRefs());
for (Ref ref : refs) {
Node target = ref.node;
for (int i = 0; i <= depth; i++) {
if (target.isGetProp()) {
target = target.getFirstChild();
Node gparent = target.getParent().getParent();
if (gparent.isAssign()) {
target = gparent.getFirstChild();
Preconditions.checkState(NodeUtil.isObjectLitKey(gparent));
target = gparent;
throw new IllegalStateException("unexpected: " + target);
Preconditions.checkState(target.isGetProp() || target.isName());
target.getParent().replaceChild(target, value.cloneTree());
prop.removeRef(ref);
newNodes.add(new AstChange(ref.module, ref.scope, ref.node));
List<AstChange> newNodes = new ArrayList<>();
if (n.props != null) {
for (Name p : n.props) {
collapseDeclarationOfNameAndDescendants(
p, appendPropForAlias(alias, p.getBaseName()));
if (!p.inExterns && canCollapseChildNames &&
p.getDeclaration() != null &&
p.canCollapse() &&
p.getDeclaration().node != null &&
p.getDeclaration().node.getParent() != null &&
p.getDeclaration().node.getParent().isAssign()) {
updateSimpleDeclaration(
appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());
if (n.props != null) {
for (Name p : n.props) {
if (p.needsToBeStubbed()) {
String propAlias = appendPropForAlias(alias, p.getBaseName());
Node nameNode = IR.name(propAlias);
Node newVar = IR.var(nameNode)
.copyInformationFromForTree(addAfter);
parent.addChildAfter(newVar, addAfter);
addAfter = newVar;
numStubs++;
compiler.reportCodeChange();
if (p.getRefs().get(0).node.getLastChild().getBooleanProp(
Node.IS_CONSTANT_NAME)) {
nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
void scanNewNodes(List<AstChange> newNodes) {
public void testCrashInCommaOperator() {
public void testDontCrashAtComma() {
test(
"var ns = {};\n"
+ "ns.Foo = {};\n"
+ "var Baz = {};\n"
+ "Baz.Foo = ns.Foo;\n"
+ "(Baz.Foo.bar = 10, 123);",
"var Baz$Foo=null;\n"
+ "(ns$Foo$bar = 10, 123);");private static final Joiner lineJoiner = Joiner.on("\n");
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
private static final String EXTERNS_WITH_IOBJECT_DECLS = lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(if (name.isConstructor() && aliasParent.isName()) {
return inlineAliasIfPossible(name, alias, namespace);
if (aliasParent.isAssign() && NodeUtil.isExecutedExactlyOnce(aliasParent)) {
if (aliasParent.getFirstChild().isQualifiedName()) {
name = namespace.getSlot(aliasParent.getFirstChild().getQualifiedName());
"var $jscomp$scope$Foo$staticprop = {A:1};\n" +
"var y = $jscomp$scope$Foo$staticprop.A;");JSDocInfo info = NodeUtil.getBestJSDocInfo(n);
info = NodeUtil.getBestJSDocInfo(origVar.nameNode);String pname = NodeUtil.getPrototypePropertyName(getProp);
mayAddPropToPrototype(rawType, pname, getProp, initializer);
String typeName =
NodeUtil.getRootOfQualifiedName(fn.getParent().getFirstChild())
.getString();
JSType t = methodScope.getDeclaredTypeOf(typeName);
return t != null && t.isInterfaceDefinition();static final String WAITING_FOR_INPUT_WARNING =
"The compiler is waiting for input via stdin.";
this.err.println(WAITING_FOR_INPUT_WARNING);
source.append("//@ sourceMappingURL=" + sourceMapOutputFile.getName());removePropertyDocs(cls);
private void removePropertyDocs(final ClassDefinition cls) {
for (MemberDefinition prop : cls.props) {RawNominalType rawType = getRawTypeFromJSType(
simpleInferExprType(getProp.getFirstChild()));
if (rawType == null) {
private RawNominalType getRawTypeFromJSType(JSType t) {
if (t == null) {
return null;
NominalType nt = t.getNominalTypeIfSingletonObj();
return nt == null ? null : nt.getRawNominalType();
public NominalType getNominalType() {
return nominalType;this.wrappedAsNominal =
new NominalType(ImmutableMap.<String, JSType>of(), this);
ObjectType objInstance = "Function".equals(name)
? ObjectType.fromFunction(
FunctionType.TOP_FUNCTION, this.wrappedAsNominal)
: ObjectType.fromNominalType(this.wrappedAsNominal);
this.wrappedAsNullableJSType = JSType.join(JSType.NULL,
this.wrappedAsJSType);if (receiverType != null && other.receiverType == null
|| receiverType != null && other.receiverType != null
&& !receiverType.isSubtypeOf(other.receiverType)) {NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL,
static final DiagnosticType CALL_FUNCTION_WITH_BOTTOM_FORMAL =
DiagnosticType.warning(
"JSC_CALL_FUNCTION_WITH_BOTTOM_FORMAL",
"The #{0} formal parameter of this function has an invalid type, " +
"which prevents the function from being called.\n" +
"Please change the type.");
CALL_FUNCTION_WITH_BOTTOM_FORMAL,
if (!calleeType.isSubtypeOf(commonTypes.topFunction())) {
if (formalType.isBottom()) {
warnings.add(JSError.make(call, CALL_FUNCTION_WITH_BOTTOM_FORMAL,
Integer.toString(i)));
formalType = JSType.UNKNOWN;
Preconditions.checkNotNull(requiredFormals,
JSType reqFormal = nullAcceptingMeet(
f1.getFormalType(i), f2.getFormalType(i));
JSType optFormal = nullAcceptingMeet(
f1.getFormalType(i), f2.getFormalType(i));
builder.addRestFormals(
nullAcceptingMeet(f1.restFormals, f2.restFormals));
optionalFormals.add(JSType.BOTTOM);
union = JSType.join(union, nextType);
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL);
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL);
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL);int templateMask = BOTTOM_MASK;
int otherScalarBits = other.getMask() & ~NON_SCALAR_MASK;
templateMask |= otherScalarBits & ~thisScalarBits;
if (rawType.name.equals("Array")
return areTypeParametersSubtypes(other);
private boolean areTypeParametersSubtypes(NominalType other) {
if (typeMap.isEmpty()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
typeVar, typeMap.keySet());
other, typeVar, typeMap.get(typeVar), this);
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return hasUnified && isInvariantWith(typeMultimap, other);
NewTypeInference.FAILED_TO_UNIFY);
"var /** Gen<Foo> */ a = new Gen(new Bar);"));"  /** @type {Object.<string, !HTMLElement>} */",
"  /** @type {Object.<string, !HTMLElement>} */",
"  /** @type {Object.<string, !HTMLElement>} */",String rootName = Splitter.on('.').split(typeNode.getString()).iterator().next();
usagesMap.put(typeNode.getString(), n);static final FunctionType QMARK_FUNCTION = FunctionType.normalized(null,
private static final FunctionType BOTTOM_FUNCTION = FunctionType.normalized(
Preconditions.checkState(!isLoose());
return FunctionType.looseJoin(f1, f2);
FunctionType result = FunctionType.meet(this, other);
return FunctionType.looseJoin(f1, f2);localPropDef.methodType.withTypeInfoFromSuper(superMethodType);
DeclaredFunctionType superType) {
+ "/** @param {string} opt_str */\n"NodeUtil.newQName(compiler, qualifiedPath + behaviorFunction.name.getString()),propMethodTypesToProcess.put(pname, inheritedPropDef.methodType);
Preconditions.checkArgument(
declNode.isFunction() || declNode.isGetProp());
builder.addReqFormal(
formal != null ? formal : superType.getFormalType(i));
builder.addOptFormal(
formal != null ? formal : superType.getFormalType(i));
builder.addTypeParameters(typeParameters);Map<String, Property> props1, Map<String, Property> props2) {
for (Map.Entry<String, Property> propsEntry : props1.entrySet()) {
String pname = propsEntry.getKey();
if (!props2.containsKey(pname)) {
newProps = newProps.with(pname, propsEntry.getValue().withOptional());
for (Map.Entry<String, Property> propsEntry : props2.entrySet()) {
String pname = propsEntry.getKey();
Property prop2 = propsEntry.getValue();
if (props1.containsKey(pname)) {
newProps = newProps.with(
pname, Property.join(props1.get(pname), prop2));
newProps = newProps.with(pname, prop2.withOptional());
Preconditions.checkState(
areRelatedClasses(obj1.nominalType, obj2.nominalType));
props = joinProps(obj1.props, obj2.props);
NominalType nominal =
NominalType.pickSuperclass(obj1.nominalType, obj2.nominalType);
if (nominalType2 == null && nominalType1 != null &&
!obj1.isSubtypeOf(obj2) ||
nominalType1 == null && nominalType2 != null &&
!obj2.isSubtypeOf(obj1)) {
addedObj2 = true;
return new Property(defSite, inferredType, declaredType, Attribute.OPTIONAL);
return new Property(defSite, inferredType, declaredType, Attribute.REQUIRED);assertEquals("/**@return {number|string} */", JSDocInfoPrinter.print(info));
JsDocInfoParser.parseTypeString("!Array.<number|string>"), ""));
"/**@type {!Array.<number|string>} */", JSDocInfoPrinter.print(info));SetMultimap<String, CodeReplacement> replacements) {
return new SuggestedFix(originalMatchedNode, replacements.build());if (parent.isStringKey() && info == parent.getJSDocInfo()) {
for (Node node : info.getTypeNodes()) {
fixTypeNode(node);return this.symbolTable;
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.jscomp.newtypes.FunctionType;
import com.google.javascript.jscomp.newtypes.JSType;
import com.google.javascript.jscomp.newtypes.JSTypes;
import com.google.javascript.jscomp.newtypes.NominalType;
import com.google.javascript.jscomp.newtypes.ObjectType;
import com.google.javascript.jscomp.newtypes.QualifiedName;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.TypeI;
import com.google.javascript.rhino.jstype.FunctionBuilder;
import com.google.javascript.rhino.jstype.FunctionParamBuilder;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.UnionTypeBuilder;
import java.util.HashMap;
import java.util.Map;
public final class ConvertNewTypesToOld extends AbstractPostOrderCallback implements CompilerPass {
private final AbstractCompiler compiler;
private final JSTypeRegistry registry;
private final JSTypes commonTypes;
private final com.google.javascript.rhino.jstype.JSType OLD_UNKNOWN_FUNCTION_TYPE;
private final com.google.javascript.rhino.jstype.JSType OLD_UNKNOWN_TYPE;
private Node currentNode;
private final Map<JSType, com.google.javascript.rhino.jstype.JSType> cachedTypes =
new HashMap<>();
private final Map<NominalType, com.google.javascript.rhino.jstype.FunctionType> cachedNomTypes =
new HashMap<>();
ConvertNewTypesToOld(AbstractCompiler compiler) {
this.compiler = compiler;
this.registry = compiler.getTypeRegistry();
this.commonTypes = compiler.getSymbolTable().getTypesUtilObject();
this.OLD_UNKNOWN_FUNCTION_TYPE = registry.getNativeType(JSTypeNative.U2U_FUNCTION_TYPE);
this.OLD_UNKNOWN_TYPE = registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);
com.google.javascript.rhino.jstype.JSType oldNativeType;
oldNativeType = registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
JSType.BOOLEAN.setOldType(oldNativeType);
cachedTypes.put(JSType.BOOLEAN, oldNativeType);
JSType.TRUE_TYPE.setOldType(oldNativeType);
cachedTypes.put(JSType.TRUE_TYPE, oldNativeType);
JSType.FALSE_TYPE.setOldType(oldNativeType);
cachedTypes.put(JSType.FALSE_TYPE, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NO_TYPE);
JSType.BOTTOM.setOldType(oldNativeType);
cachedTypes.put(JSType.BOTTOM, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NULL_TYPE);
JSType.NULL.setOldType(oldNativeType);
cachedTypes.put(JSType.NULL, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NUMBER_TYPE);
JSType.NUMBER.setOldType(oldNativeType);
cachedTypes.put(JSType.NUMBER, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.STRING_TYPE);
JSType.STRING.setOldType(oldNativeType);
cachedTypes.put(JSType.STRING, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.ALL_TYPE);
JSType.TOP.setOldType(oldNativeType);
cachedTypes.put(JSType.TOP, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.VOID_TYPE);
JSType.UNDEFINED.setOldType(oldNativeType);
cachedTypes.put(JSType.UNDEFINED, oldNativeType);
JSType.UNKNOWN.setOldType(OLD_UNKNOWN_TYPE);
cachedTypes.put(JSType.UNKNOWN, OLD_UNKNOWN_TYPE);
commonTypes.topFunction().setOldType(OLD_UNKNOWN_FUNCTION_TYPE);
cachedTypes.put(commonTypes.topFunction(), OLD_UNKNOWN_FUNCTION_TYPE);
commonTypes.qmarkFunction().setOldType(OLD_UNKNOWN_FUNCTION_TYPE);
cachedTypes.put(commonTypes.qmarkFunction(), OLD_UNKNOWN_FUNCTION_TYPE);
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, externs, this);
NodeTraversal.traverse(compiler, root, this);
compiler.setSymbolTable(null);
public void visit(NodeTraversal t, Node n, Node parent) {
TypeI ti = n.getTypeI();
if (ti instanceof com.google.javascript.rhino.jstype.JSType) {
return;
JSType newType = (JSType) ti;
if (newType != null) {
this.currentNode = n;
n.setTypeI(convertNewTypeToOld(newType));
private com.google.javascript.rhino.jstype.JSType convertNewTypeToOld(JSType newType) {
if (newType == null) {
return null;
com.google.javascript.rhino.jstype.JSType oldType =
(com.google.javascript.rhino.jstype.JSType) newType.getOldType();
if (cachedTypes.containsKey(newType)) {
return cachedTypes.get(newType);
if (newType.isUnion()) {
oldType = convertUnionType(newType);
FunctionType ft = newType.getFunTypeIfSingletonObj();
if (ft != null) {
oldType = convertFunctionType(ft);
return OLD_UNKNOWN_TYPE;
ObjectType ot = newType.getObjectTypeIfSingletonObj();
Preconditions.checkNotNull(ot, "Null object type for JSType: %s", newType);
oldType = convertObjectType(ot);
newType.setOldType(oldType);
return oldType;
private com.google.javascript.rhino.jstype.JSType convertUnionType(JSType newType) {
UnionTypeBuilder builder = new UnionTypeBuilder(this.registry);
for (JSType alternate : newType.getAlternates()) {
builder.addAlternate(convertNewTypeToOld(alternate));
return builder.build();
private com.google.javascript.rhino.jstype.JSType convertObjectType(ObjectType ot) {
NominalType nt = ot.getNominalType();
if (nt == null) {
com.google.javascript.rhino.jstype.ObjectType oldObject =
this.registry.createAnonymousObjectType(NodeUtil.getBestJSDocInfo(currentNode));
for (String pname : ot.getAllOwnProps()) {
QualifiedName qname = new QualifiedName(pname);
JSType ptype = ot.getDeclaredProp(qname);
if (ptype == null) {
ptype = ot.getProp(qname);
Preconditions.checkNotNull(ptype);
oldObject.defineInferredProperty(pname, convertNewTypeToOld(ptype), null);
oldObject.defineDeclaredProperty(pname, convertNewTypeToOld(ptype), null);
Node defSite = ot.getPropDefsite(qname);
if (defSite != null) {
oldObject.setPropertyNode(pname, defSite);
oldObject.setPropertyJSDocInfo(pname, NodeUtil.getBestJSDocInfo(defSite));
return oldObject;
if (cachedNomTypes.containsKey(nt)) {
return cachedNomTypes.get(nt).getTypeOfThis();
return OLD_UNKNOWN_TYPE;
private com.google.javascript.rhino.jstype.JSType convertFunctionType(FunctionType ft) {
if (ft.isTopFunction() || ft.isQmarkFunction()) {
return OLD_UNKNOWN_FUNCTION_TYPE;
if (ft.isConstructor()) {
return convertConstructorFunction(ft);
FunctionBuilder funBuilder = new FunctionBuilder(this.registry);
funBuilder.withParamsNode(convertFunctionParams(ft));
funBuilder.withReturnType(convertNewTypeToOld(ft.getReturnType()));
funBuilder.withTypeOfThis(convertNewTypeToOld(ft.getThisType()));
com.google.javascript.rhino.jstype.FunctionType result = funBuilder.build();
result.setJSDocInfo(NodeUtil.getBestJSDocInfo(currentNode));
return result;
private Node convertFunctionParams(FunctionType ft) {
FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this.registry);
int minArity = ft.getMinArity();
com.google.javascript.rhino.jstype.JSType[] requiredFormals =
new com.google.javascript.rhino.jstype.JSType[minArity];
for (int i = 0; i < minArity; i++) {
requiredFormals[i] = convertNewTypeToOld(ft.getFormalType(i));
paramBuilder.addRequiredParams(requiredFormals);
int maxArity = ft.getMaxArityWithoutRestFormals();
if (maxArity > minArity) {
com.google.javascript.rhino.jstype.JSType[] optionalFormals =
new com.google.javascript.rhino.jstype.JSType[maxArity - minArity];
for (int i = minArity; i < maxArity; i++) {
optionalFormals[i - minArity] = convertNewTypeToOld(ft.getFormalType(i));
paramBuilder.addOptionalParams(optionalFormals);
if (ft.hasRestFormals()) {
paramBuilder.addVarArgs(convertNewTypeToOld(ft.getRestFormalsType()));
return paramBuilder.build();
private com.google.javascript.rhino.jstype.JSType convertConstructorFunction(FunctionType ft) {
NominalType nt = ft.getInstanceTypeOfCtor().getNominalTypeIfSingletonObj();
if (cachedNomTypes.containsKey(nt)) {
return cachedNomTypes.get(nt);
String ntName = nt.getName();
Node source = nt.getDefsite();
com.google.javascript.rhino.jstype.FunctionType oldCtor =
this.registry.createConstructorType(ntName, source,
convertFunctionParams(ft), convertNewTypeToOld(ft.getReturnType()), null);
convertClassProperties(nt, oldCtor);
oldCtor.setSource(source);
NominalType superNt = nt.getInstantiatedSuperclass();
if (superNt != null) {
com.google.javascript.rhino.jstype.ObjectType oldPrototype =
convertNewTypeToOld(superNt.getInstanceAsJSType()).toObjectType();
if (oldPrototype != null) {
oldCtor.setPrototypeBasedOn(oldPrototype);
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(source);
oldCtor.setJSDocInfo(jsdoc);
oldCtor.getInstanceType().setJSDocInfo(jsdoc);
cachedNomTypes.put(nt, oldCtor);
return oldCtor;
private void convertClassProperties(
NominalType nt, com.google.javascript.rhino.jstype.FunctionType oldCtor) {
com.google.javascript.rhino.jstype.ObjectType oldInstance = oldCtor.getInstanceType();
for (String pname : nt.getAllOwnProps()) {
JSType ptype = nt.getPropDeclaredType(pname);
if (ptype == null) {
oldInstance.defineInferredProperty(pname, OLD_UNKNOWN_TYPE, null);
oldInstance.defineDeclaredProperty(pname, convertNewTypeToOld(ptype), null);
Node defSite = nt.getPropDefsite(pname);
if (defSite != null) {
oldInstance.setPropertyNode(pname, defSite);
oldInstance.setPropertyJSDocInfo(pname, NodeUtil.getBestJSDocInfo(defSite));
private final PassFactory convertNewTypesToOld =
new PassFactory("ConvertNewTypesToOld", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
return new TypeConverter(compiler);
private class TypeConverter implements CompilerPass {
private final AbstractCompiler compiler;
TypeConverter(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
Preconditions.checkState(topScope == null);
(new ConvertNewTypesToOld(this.compiler)).process(externs, root);
regenerateGlobalTypedScopeAfterNTI(compiler, root);
private boolean needsAttachedType(Node n) {
Node parent = n.getParent();
return n.isGetProp()
|| n.isName()
|| n.isFunction()
|| n.isThis()
|| n.isNew();
if (!needsAttachedType(n)) {
return;
void regenerateGlobalTypedScopeAfterNTI(AbstractCompiler compiler, Node root) {
typedScopeCreator = new MemoizedScopeCreator(SyntacticScopeCreator.makeTyped(compiler));
topScope = TypedScope.createGlobalScope(root.getParent());
protected Object oldType = null;
public Object getOldType() {
return this.oldType;
public void setOldType(Object t) {
this.oldType = t;
return this.typei;
public void setUp() {
enableNewTypeInference();
disableNewTypeInference();
public void testPrivateAccessForProperties4a() {
testSame(new String[] {
"/** @constructor */ function Foo() {}" +
"/** @private */ Foo.prototype.bar_ = function() {};",
"Foo.prototype.baz = function() { (new Foo()).bar_(); };"
"/** @const */ var goog = {};" +
disableNewTypeInference();
"/** @const */ var goog = {};" +
"/** @const */ var foo = {};\n" +
"foo.bar = function() { return 'asdf'; };");
"/** @const */ var goog = {};" +
"/** @const */ var goog = {};" +
"/** @const */ var NS = {}; /** @constructor */ NS.Foo = function() {};" +
disableNewTypeInference();
disableNewTypeInference();
testError(
"/** @const */ var o = {};\n" +
testSame(
"/** @const */ var o = {};\n" +
"/** @const */ var o2 = {};\n" +
testError(
disableNewTypeInference();
disableNewTypeInference();
disableNewTypeInference();
testSame("/** @const */ var o = { /** @const */ x: 1 };" +
disableNewTypeInference();
disableNewTypeInference();
disableNewTypeInference();
" */ function B() { /** @const */ this.bar = 3; this.bar += 4; }");
private boolean newTypeInferenceEnabled = false;
this.typeCheckEnabled = true;
this.typeCheckLevel = level;
void enableNewTypeInference() {
Preconditions.checkState(typeCheckEnabled);
Preconditions.checkState(!runTypeCheckAfterProcessing);
this.newTypeInferenceEnabled = true;
void disableNewTypeInference() {
this.newTypeInferenceEnabled = false;
DiagnosticType error, DiagnosticType warning, String description) {
if (newTypeInferenceEnabled) {
Compiler compiler = createCompiler();
lastCompiler = compiler;
compiler.init(externsInputs, js, getOptions());
test(compiler, expected, error, warning, description, true);
test(compiler, expected, error, warning, description, false);
test(compiler, (List<SourceFile>) null, error, warning, description, false);
if (newTypeInferenceEnabled) {
List<SourceFile> inputs = Lists.newArrayList();
for (int i = 0; i < expected.length; i++) {
inputs.add(SourceFile.fromCode("expected" + i, expected[i]));
test(compiler, inputs, error, warning, description, true);
test(compiler, inputs, error, warning, description, false);
String description, boolean runNewTypeInference) {
if (runNewTypeInference) {
GlobalTypeInfo symbolTable = new GlobalTypeInfo(compiler);
compiler.setSymbolTable(symbolTable);
symbolTable.process(externsRoot, mainRoot);
(new NewTypeInference(compiler, rewriteClosureCode)).process(externsRoot, mainRoot);
(new ConvertNewTypesToOld(compiler)).process(externsRoot, mainRoot);
(new InferJSDocInfo(compiler)).process(externsRoot, mainRoot);
TypeCheck check = createTypeCheck(compiler, typeCheckLevel);
check.processForTesting(externsRoot, mainRoot);JSDocInfo fnDoc = NodeUtil.getFunctionJSDocInfo(fn);
JSDocInfo fnDoc = NodeUtil.getFunctionJSDocInfo(fn);
JSDocInfo fnDoc = NodeUtil.getFunctionJSDocInfo(root);
parent.isOr() ||
parent.isAnd() ||
(parent.isComma() && parent.getFirstChild() != n)) {
return getBestJSDocInfo(parent);
return parent.getJSDocInfo();
JSDocInfo jsDoc = NodeUtil.getFunctionJSDocInfo(node);
"var bar = /** @type {function(number=,number=)} */ (" +
"    function(x, y) { f(y); });",
public void testClosureParameterTypesWithJSDoc() {
testSame(
"/**\n" +
" * @param {function(!Object)} bar\n" +
" */\n" +
"function foo(bar) {}\n" +
"foo(/** @type {function(string)} */" +
"  (function(baz) { var f = baz; }))\n");
assertEquals("string", findNameType("f", lastLocalScope).toString());
public void testFunctionInHook() throws Exception {
testSame("/** @param {number} x */ var f = Math.random() ? " +
"function(x) {} : function(x) {};");
assertEquals("number", lastLocalScope.getVar("x").getType().toString());
public void testFunctionInAnd() throws Exception {
testSame("/** @param {number} x */ var f = Math.random() && " +
"function(x) {};");
assertEquals("number", lastLocalScope.getVar("x").getType().toString());
public void testFunctionInOr() throws Exception {
testSame("/** @param {number} x */ var f = Math.random() || " +
"function(x) {};");
assertEquals("number", lastLocalScope.getVar("x").getType().toString());
public void testFunctionInComma() throws Exception {
testSame("/** @param {number} x */ var f = (Math.random(), " +
"function(x) {});");
assertEquals("number", lastLocalScope.getVar("x").getType().toString());Node description = NodeUtil.getArgumentForCallOrNew(callNode, 0);
if (description == null || !description.isObjectLit()) {
Node elName = NodeUtil.getFirstPropMatchingKey(description, "is");
Node constructor = NodeUtil.getFirstPropMatchingKey(description, "constructor");
Node baseClass = NodeUtil.getFirstPropMatchingKey(description, "extends");
JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);
new MemberDefinition(info, null, constructor), nativeBaseElement,
objectLitToList(description));
private static List<MemberDefinition> objectLitToList(Node objlit) {
for (Node keyNode : objlit.children()) {
parent.addChildBefore(stmts, exprRoot);
String polymerElementType = this.getPolymerElementType(cls);
JSDocInfoBuilder constructorDoc = new JSDocInfoBuilder(true);
new Node(Token.BANG, IR.string(this.getPolymerElementType(cls))), VIRTUAL_FILE);
"  constructor: function() { alert('hi'); },",
"/** @constructor @extends {PolymerElement} */",
"var X = function() { alert('hi'); };",
"  constructor: function() { alert('hi'); },",RhinoErrorReporter.MISPLACED_FUNCTION_ANNOTATION);
"/** @desc description */Super.prototype.foo = function() {};" +
"/** @desc description */Sub.prototype.foo = function() {};");
"/** @desc description */Root.prototype.foo = function() {};" +
"/** @desc description */Sub.prototype.foo = function() {};");
"/** @desc description */Super.prototype.foo = function() {};" +
"/** @desc description */Super.prototype.foo = function() {};" +
"/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
"/** @desc description\n @return {U} */B.prototype.bar = function() {};" +
"/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
"/** @desc description\n @return {U} */B.prototype.bar = function() {};" +
"/** @desc description\n @return {T} */A.prototype.foo = function() {};" +
"/** @desc description\n @return {T} */A.prototype.bar = function() {};" +
"/** @desc description */Int.prototype.foo = function() {};" +
"/** @desc description */Int.prototype.foo = function() {};" +
"/** @desc description\n @return {T} */Int.prototype.foo = function() {};" +
"/** @desc description */Int.prototype.foo = function() {};" +
"/** @desc x does something */u.T.prototype.x = function() {};");
"/** @desc x does something */T.prototype.x = function() {};");
"/** @desc description */Int0.prototype.foo = function() {};" +
"/** @desc description */Int1.prototype.foo = function() {};" +
"/** @desc description @ return {string} x */" +
parse(
"};").getFirstChild();|| localNamespaces != null && localNamespaces.containsKey(name)
|| localTypedefs != null && localTypedefs.containsKey(name)
|| localEnums != null && localEnums.containsKey(name);
return localNamespaces.containsKey(name) ||
localClassDefs.containsKey(name) ||
localEnums.containsKey(name) ||
parent != null && parent.isNamespace(name);
return localNamespaces.containsKey(name);
return constVars.contains(name) ||
parent != null && parent.isConstVar(name);
return new LinkedHashSet<>(localFunDefs.keySet());
String name = qname.getLeftmostName();
RawNominalType rnt = localClassDefs.get(name);
if (rnt != null) {
return rnt;
return parent == null ? null : parent.getNominalType(qname);
int formalIndex = formals.indexOf(name);
if (formalIndex != -1) {
JSType formalType = declaredType.getFormalType(formalIndex);
if (formalType == null || formalType.isBottom()) {
return null;
return formalType;
JSType localType = locals.get(name);
if (localType != null) {
Preconditions.checkState(!localType.isBottom(), "%s was bottom", name);
return localType;
JSType externType = externs.get(name);
if (externType != null) {
Preconditions.checkState(!externType.isBottom());
return externType;
Scope s = localFunDefs.get(name);
if (s != null && s.getDeclaredType() != null) {
return getCommonTypes()
.fromFunctionType(s.getDeclaredType().toFunctionType());
if (localNamespaces != null) {
Namespace ns = localNamespaces.get(name);
if (ns != null) {
return ns.toJSType();
if (isDefinedLocally(name)) {
return null;
Scope s = localFunDefs.get(fnName);
if (s != null) {
return s;
return parent.getScopeHelper(fnName);
return null;
if (locals.containsKey(name)) {
if (isDefinedLocally(name)) {
return localTypedefs.get(name);
if (parent != null) {
return parent.getTypedef(name);
if (isDefinedLocally(name)) {
return localEnums.get(name);
if (parent != null) {
return parent.getEnum(name);
private Namespace getNamespace(String name) {
Namespace ns = localNamespaces.get(name);
if (ns != null) {
return ns;
ns = localClassDefs.get(name);
if (ns != null) {
return ns;
ns = localEnums.get(name);
if (ns != null) {
return ns;
return parent == null ? null : parent.getNamespace(name);
localNamespaces = null;
localClassDefs = null;
localTypedefs = null;
localEnums = null;JSType inferredType) {
functionScope.declare(symbol, node, bottomType, null);
&& !declaredType.isSubtype(inferredType)) {
!type.isPropertyTypeInferred(pname) &&
!propertyIsImplicitCast(type, pname)) {
validator.expectCanAssignToPropertyOf(
t, assign, getJSType(rvalue),
expectedType, object, pname);
checkPropertyInheritanceOnGetpropAssign(
t, assign, object, pname, info, expectedType);
scope.inferQualifiedSlot(left, qualifiedName,
leftType == null ? unknownType : leftType,
resultType);
valueType);
node, node.getQualifiedName(), getJSType(node), narrowed);
scope.inferQualifiedSlot(node, qualifiedName, origType, type);
JSType inferredType);
object, propertyQualifiedName, unknownType, unknownType);
public void testImplicitCast() throws Exception {
verify("y", CHECKED_UNKNOWN_TYPE);test("function fake(){};" +
"var ns = {};" +
"fake( /** @ngInject */ ns.func = function (a, b) {} )",
null, AngularPass.INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR);
test("/** @ngInject */( function (a, b) {} )",
null, AngularPass.INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR);
test("var ns = {}; ns.subns = {};" +
"ns.subns.fake = function(x, y){};" +
"/** @ngInject */ ns.subns.fake(1);",
null, AngularPass.INJECT_NON_FUNCTION_ERROR);
test("/** @ngInject */ var a = 10",
null, AngularPass.INJECT_NON_FUNCTION_ERROR);
test("/** @ngInject */ var x",
null, AngularPass.INJECT_NON_FUNCTION_ERROR);
test(String.format(js, ""), null, error);
test("/**\n" +
"* @fileoverview\n" +
"* @package\n" +
"*/\n" +
"/** @struct @constructor */\n" +
"Foo = function() {};\n" +
"/** @private */\n" +
"Foo.prototype.privateMethod_ = function() {};\n" +
"/** @struct @constructor @extends {Foo} */\n" +
"Bar = function() {};\n" +
"/** @override */\n" +
"Bar.prototype.privateMethod_ = function() {};\n",
null, BAD_PROPERTY_OVERRIDE_IN_FILE_WITH_FILEOVERVIEW_VISIBILITY);
"GRR",
"", // output
"GRR",
test("/** @constructor */ function A() {" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function A() {" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function cat(name) {}" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function cat(name) {}" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() { this.prop = 1;}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() { this.prop = 1;}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {}" +
null , CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {" +
null, CONST_PROPERTY_DELETED);
test("/** @constructor */ function Foo() { this.CONST = 100; };\n" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("/** @constructor */ function Foo() {};\n" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test("" +
null, CONST_PROPERTY_REASSIGNED_VALUE);
test(
null, EXTEND_FINAL_CLASS);
test(
null, EXTEND_FINAL_CLASS);
test(js, js, CheckMissingGetCssName.MISSING_GETCSSNAME);
test(js, js, CheckMissingReturn.MISSING_RETURN_STATEMENT);
public void test(String js, String expected, DiagnosticType warning) {
public void test(String js, DiagnosticType warning) {
test("function f(x) { if(x) return; }", ok);
test("function f(x) { if(x); }", "function f(x) { if(x); }", e);
test("if(x) x = y;", ok);
test("if(x) x == bar();", "if(x) JSCOMPILER_PRESERVE(x == bar());", e);
test("x = 3;", ok);
test("x == 3;", "JSCOMPILER_PRESERVE(x == 3);", e);
test("var x = 'test'", ok);
test("var x = 'test'\n'str'",
test("", ok);
test("foo();;;;bar();;;;", ok);
test("var a, b; a = 5, b = 6", ok);
test("var a, b; a = 5, b == 6",
test("var a, b; a = (5, 6)",
test("var a, b; a = (bar(), 6, 7)",
test("var a, b; a = (bar(), bar(), 7, 8)",
test("var a, b; a = (b = 7, 6)", ok);
test("function x(){}\nfunction f(a, b){}\nf(1,(x(), 2));", ok);
test("function x(){}\nfunction f(a, b){}\nf(1,(2, 3));",
test("for(var x = 0; x < 100; x++) { foo(x) }", ok);
test("for(; true; ) { bar() }", ok);
test("for(foo(); true; foo()) { bar() }", ok);
test("for(void 0; true; foo()) { bar() }",
test("for(foo(); true; void 0) { bar() }",
test("for(foo(); true; (1, bar())) { bar() }",
test("for(foo in bar) { foo() }", ok);
test("for (i = 0; el = el.previousSibling; i++) {}", ok);
test("for (i = 0; el = el.previousSibling; i++);", ok);
test("x;", "JSCOMPILER_PRESERVE(x);", e);
test("a.b.c.d;", "JSCOMPILER_PRESERVE(a.b.c.d);", e);
test("/** @type Number */ a.b.c.d;", ok);
test("if (true) { /** @type Number */ a.b.c.d; }", ok);
test("function A() { this.foo; }",
test("function A() { /** @type Number */ this.foo; }", ok);
test("function A() { /** This is a JsDoc comment */ this.foo; }", ok);
test("function A() { /* This is a normal comment */ this.foo; }",
test("(0, eval)('alert');", ok);
test("(0, foo)('alert');", "(JSCOMPILER_PRESERVE(0), foo)('alert');", e);
"}",
null);
test(js, expected, null);
public void test(String js, String expected, DiagnosticType error) {
test(js, expected, error, null);
test(js, js, diag);
test(externs, js, js, diag, null);
test(externsInputs, js, js, type, null, description);
public void testSame(String[] js, DiagnosticType error) {
test(js, js, error);
public void testSame(
String[] js, DiagnosticType error, DiagnosticType warning) {
test(js, js, error, warning);
new ScopedAliases(compiler, null,  CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER)
test(before, after, null);
test(js, null, ConstCheck.CONST_REASSIGNED_VALUE_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR);
test(CLOSURE_DEFS
null, ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR);
String ttOutput = ""
+ "function Foo(){}Foo.prototype.Foo_prototype$a=0;"
+ "function Bar(){}Bar.prototype.Bar_prototype$a=0;"
+ "var F=new Foo;F.Unique$1$a=0;";
String ttOutput = ""
+ "var Foo=function(){this.Foo_prototype$a=0};"
+ "function Bar(){}"
+ "Bar.prototype.Bar_prototype$a=0;"
+ "new Foo";
String ttOutput = ""
+ "function Foo(){}Foo.prototype.Foo_prototype$a=0;"
+ "function Bar(){}Bar.prototype.Bar_prototype$a=0;"
+ "var B = new Bar;B.Bar_prototype$a=0;"
+ "function Baz(){}Baz.prototype.Baz_prototype$a=function(){};";
String ttOutput = ""
+ "var Foo=function(){};\n"
+ "var Bar=function(){};\n"
+ "function fun(){}\n"
+ "Foo.prototype.Foo_prototype$a=fun();\n"
+ "fun().Unique$1$a;\n"
+ "Bar.prototype.Bar_prototype$a=0;";
String ttOutput = ""
+ "var En={A:'first',B:'second'};"
+ "var EA=En.A;"
+ "var EB=En.B;"
+ "function Foo(){};"
+ "Foo.prototype.Foo_prototype$A=0;"
+ "Foo.prototype.Foo_prototype$B=0";
String ttOutput = ""
+ "function Ind() { this.Unique$1$a = 0; }"
+ "function Foo() {}"
+ "Foo.prototype.a = 0;"
+ "function Bar() {}"
+ "Bar.prototype.a = 0;"
+ "var F = new Foo;"
+ "F.a = 1;"
+ "F = new Bar;"
+ "var Z = new Baz;"
+ "Z.a = 1;"
+ "var B = new Baz;"
+ "B.a = 1;"
+ "B = new Bar;";
test("function addSingletonGetter(foo) { foo.foobar = 'a'; };", null,
test("/** @constructor */ function F() {}" +
null,
externs, js, "",
test("function *f() { obj.bar(yield 5); }",
null, Es6ToEs3Converter.CANNOT_CONVERT);
test("function *f() {switch (i) {default: case 1: yield 1;}}",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("function *f() { l: if (true) { var x = 5; break l; x++; yield x; }; }",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("function *f(b, i) {switch (i) { case (b || (yield 1)): yield 2; }}",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("f(class extends D { f() { super.g() } })", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var C = new (class {})();", null,
test("var C = new (foo || (foo = class { }))();", null,
test("(condition ? obj1 : obj2).prop = class C { };", null,
test("class C extends foo() {}", null, Es6ToEs3Converter.DYNAMIC_EXTENDS_TYPE);
test("class C extends function(){} {}", null, Es6ToEs3Converter.DYNAMIC_EXTENDS_TYPE);
test("class A {}; class B {}; class C extends (foo ? A : B) {}",
null, Es6ToEs3Converter.DYNAMIC_EXTENDS_TYPE);
test("class C { constructor() { super(); } }",
null, Es6ConvertSuper.NO_SUPERTYPE);
test("class C { f() { super(); } }",
null, Es6ConvertSuper.NO_SUPERTYPE);
test("class C { static f() { super(); } }",
null, Es6ConvertSuper.NO_SUPERTYPE);
test("var i = super();",
null, Es6ConvertSuper.NO_SUPERTYPE);
test("class D {} class C extends D { f() {var i = super.c;} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { static f() {var i = super.c;} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { f() {var i; i = super[s];} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { f() {return super.s;} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { f() {m(super.s);} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test(Joiner.on('\n').join(
), null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test(Joiner.on('\n').join(
), null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { f() {var s = new super;} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("class D {} class C extends D { f(str) {var s = new super(str);} }", null,
Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("function f() { class C {} C = function() {};}",
null, Es6ToEs3Converter.CLASS_REASSIGNMENT);
test("function f() { var a = b = class {};}",
null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var ns = {}; function f() { var self = ns.Child = class {};}",
null, Es6ToEs3Converter.CANNOT_CONVERT);
test("class C { get value() {} }", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("class C { set value(v) {} }", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("class C { get [foo]() {}}", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("class C { set [foo](val) {}}", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var x = { get y() {} };", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var x = { set y(value) {} };", null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var o = { get [foo]() {}}", null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("var o = { set [foo](val) {}}", null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("var {5: b} = foo();",  Joiner.on('\n').join(
test("var {0.1: b} = foo();",  Joiner.on('\n').join(
test("var BAR;\n/** @export */var FOO = BAR = 5",
null, FindExportableNodes.NON_GLOBAL_ERROR);
test("var BAR;\n/** @export */var FOO = BAR = 5",
null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);
test("var BAR;var FOO = {};\n/** @export */FOO.test = BAR = 5",
null, FindExportableNodes.NON_GLOBAL_ERROR);
test("var BAR;var FOO = {};\n/** @export */FOO.test = BAR = 5",
null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);
test("(function() { /** @export */var FOO = 5 })()",
null, FindExportableNodes.NON_GLOBAL_ERROR);
test("(function() { /** @export */var FOO = 5 })()",
null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);
test("var x = {/** @export */ A:function() {}}",
null, FindExportableNodes.NON_GLOBAL_ERROR);
test("function a(){b}", "", RhinoErrorReporter.PARSE_ERROR);
test("function a(){b}", "", RhinoErrorReporter.PARSE_ERROR);
test("/** @nosideeffects */ function foo() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = /** @nosideeffects */ function() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("/** @nosideeffects */ var f = function() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = function() {};" +
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = function() {};" +
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
void fold(String js, String expected, DiagnosticType warning) {
test(js, expected, warning);
test("try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }",
"try { throw 1 } catch(e) { var e=2 }",
test("function a() {" +
"function a() {" +
"try { throw 1 } catch(e) { var e=2 }" +
"}",
test("var e = 0; try { throw 1 } catch(e) {" +
"/** @suppress {duplicate} */ var e=2 }",
"var e = 0; try { throw 1 } catch(e) { var e=2 }",
Normalize.CATCH_BLOCK_VAR_ERROR);
test("function a() {" +
"var e = 0; try { throw 1 } catch(e) {" +
"/** @suppress {duplicate} */ var e=2 }" +
"};",
"function a() {" +
"var e = 0; try { throw 1 } catch(e) { var e=2 }" +
"}",
Normalize.CATCH_BLOCK_VAR_ERROR);
testSame(new String[] {"new goog.testing.ObjectPropertyString()"},
testSame(
new String[] {
"new goog.testing.ObjectPropertyString(foo[a], 'bar')"
testSame(new String[] {"new goog.testing.ObjectPropertyString(foo, bar)"},
test("goog.provide('foo'); function foo(){}",
null, FUNCTION_NAMESPACE_ERROR);
test("goog.provide();", "", NULL_ARGUMENT_ERROR);
test("goog.provide(5);", "", INVALID_ARGUMENT_ERROR);
test("goog.provide([]);", "", INVALID_ARGUMENT_ERROR);
test("goog.provide({});", "", INVALID_ARGUMENT_ERROR);
test("goog.provide('foo', 'bar');", "", TOO_MANY_ARGUMENTS_ERROR);
test("goog.provide('foo'); goog.provide('foo');", "",
test("goog.provide('foo.bar'); goog.provide('foo'); goog.provide('foo');",
"", DUPLICATE_NAMESPACE_ERROR);
test("goog.require();", "", NULL_ARGUMENT_ERROR);
test("goog.require(5);", "", INVALID_ARGUMENT_ERROR);
test("goog.require([]);", "", INVALID_ARGUMENT_ERROR);
test("goog.require({});", "", INVALID_ARGUMENT_ERROR);
test("goog.require('foo'); goog.provide('foo');",
"var foo={};", LATE_PROVIDE_ERROR);
test("goog.require('foo.bar'); goog.provide('foo.bar');",
"var foo={}; foo.bar={};", LATE_PROVIDE_ERROR);
test("goog.provide('foo.bar'); goog.require('foo'); goog.provide('foo');",
"var foo={}; foo.bar={};", LATE_PROVIDE_ERROR);
test("goog.require('foo');",
"", MISSING_PROVIDE_ERROR);
test("goog.provide('foo'); goog.require('Foo');",
"var foo={};", MISSING_PROVIDE_ERROR);
test("goog.provide('foo'); goog.require('foo.bar');",
"var foo={};", MISSING_PROVIDE_ERROR);
test("goog.provide('foo'); var EXPERIMENT_FOO = true; " +
"if (EXPERIMENT_FOO) {goog.require('foo.bar');}",
"var foo={}; var EXPERIMENT_FOO = true; if (EXPERIMENT_FOO) {}",
MISSING_PROVIDE_ERROR);
test("goog.forwardDeclare();", "",
test("goog.forwardDeclare('A.B', 'C.D');", "",
test("var BAR = {foo:'bar'}; goog.setCssNameMapping(BAR);", "",
EXPECTED_OBJECTLIT_ERROR);
test("goog.setCssNameMapping([]);", "",
EXPECTED_OBJECTLIT_ERROR);
test("goog.setCssNameMapping(false);", "",
EXPECTED_OBJECTLIT_ERROR);
test("goog.setCssNameMapping(null);", "",
EXPECTED_OBJECTLIT_ERROR);
test("goog.setCssNameMapping(undefined);", "",
EXPECTED_OBJECTLIT_ERROR);
test("var BAR = 'bar'; goog.setCssNameMapping({foo:BAR});", "",
NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);
test("goog.setCssNameMapping({foo:6});", "",
test("goog.setCssNameMapping({foo:false});", "",
test("goog.setCssNameMapping({foo:null});", "",
test("goog.setCssNameMapping({foo:undefined});", "",
test("goog.setCssNameMapping({foo:'bar'}, 'UNKNOWN');", "",
test("goog.require('b.C'); goog.provide('a.A'); a.A = {};",
"var b={};b.B={};var a={};a.A={};",
test("goog.provide('class.a');", null, INVALID_PROVIDE_ERROR);
test("goog.provide('a.class');", null, INVALID_PROVIDE_ERROR);
test("goog.provide('class.a');", null, INVALID_PROVIDE_ERROR);
test("goog.provide('a.b'); var x = x || goog.require('a.b');",
null, INVALID_CLOSURE_CALL_ERROR);
test("goog.provide('a.b'); x = goog.require('a.b');",
null, INVALID_CLOSURE_CALL_ERROR);
test("goog.provide('a.b'); function f() { goog.require('a.b'); }",
null, INVALID_CLOSURE_CALL_ERROR);
test("goog.base(this, 'method');", null, GOOG_BASE_CLASS_ERROR);
test("function Foo() {}" +
"};", null, GOOG_BASE_CLASS_ERROR);
test(String.format(METHOD_FORMAT, "goog.base();"),
null, GOOG_BASE_CLASS_ERROR);
test(String.format(METHOD_FORMAT, "goog.base(this, 'bar');"),
null, GOOG_BASE_CLASS_ERROR);
test(String.format(METHOD_FORMAT, "goog.base('foo', 'method');"),
null, GOOG_BASE_CLASS_ERROR);
test(String.format(METHOD_FORMAT, "goog.base.call(null, this, 'method');"),
null, GOOG_BASE_CLASS_ERROR);
test("function Foo() { goog.base(this); }",
null, GOOG_BASE_CLASS_ERROR);
test("var Foo = function() { goog.base(this); }",
null, GOOG_BASE_CLASS_ERROR);
test("var goog = {}; goog.Foo = function() { goog.base(this); }",
null, GOOG_BASE_CLASS_ERROR);
test(
"Foo.base(this, 'method');", null, BASE_CLASS_ERROR);
test("function Foo() {}" + FOO_INHERITS +
"Foo.method = function() {" +
"  Foo.base(this, 'method');" +
"};", null, BASE_CLASS_ERROR);
test(String.format(FOO_INHERITS + METHOD_FORMAT, "Foo.base();"),
null, BASE_CLASS_ERROR);
test(String.format(FOO_INHERITS + METHOD_FORMAT, "Foo.base(this, 'bar');"),
null, BASE_CLASS_ERROR);
test(String.format(FOO_INHERITS + METHOD_FORMAT,
null, BASE_CLASS_ERROR);
test("function Foo() { Foo.base(this); };" + FOO_INHERITS,
null, BASE_CLASS_ERROR);
test("var Foo = function() { Foo.base(this); };" + FOO_INHERITS,
null, BASE_CLASS_ERROR);
test("var goog = {}; goog.Foo = function() { goog.Foo.base(this); };"
+ FOO_INHERITS,
null, BASE_CLASS_ERROR);
test("function Foo() { Foo.base(this); }" + FOO_INHERITS,
null, BASE_CLASS_ERROR);
test("function Foo() { Foo.base(this, 'method'); }" + FOO_INHERITS,
null, BASE_CLASS_ERROR);
test("function Foo() { Foo.base(this, 1, 2); }" + FOO_INHERITS,
null, BASE_CLASS_ERROR);
test(
null, BASE_CLASS_ERROR);
test("goog.require('goog');",
"", MISSING_PROVIDE_ERROR);
test("goog.define('name', 1);", "", MISSING_DEFINE_ANNOTATION);
test(jsdoc + "goog.define('name.2', 1);", "", INVALID_DEFINE_NAME_ERROR);
test(jsdoc + "goog.define();", "", NULL_ARGUMENT_ERROR);
test(jsdoc + "goog.define('value');", "", NULL_ARGUMENT_ERROR);
test(jsdoc + "goog.define(5);", "", INVALID_ARGUMENT_ERROR);
test("/** @define {Object} */ var DEF = {}",
null, ProcessDefines.INVALID_DEFINE_TYPE_ERROR);
test("/** @define {boolean} */ var DEF = new Boolean(true);", null,
test("/** @define {string} */ var DEF = 'x' + y;", null,
test("var BASE = false;\n" +
"/** @define {boolean} */ var DEF = !BASE;",
null,
ProcessDefines.INVALID_DEFINE_INIT_ERROR);
test("DEF=false;var b=false,/** @define {boolean} */DEF=true,c=false",
null, ProcessDefines.INVALID_DEFINE_INIT_ERROR);
test(
null, ProcessDefines.INVALID_DEFINE_INIT_ERROR);
test("/** @define {boolean} */ var DEF;",
null, ProcessDefines.INVALID_DEFINE_INIT_ERROR);
test("/** @define {boolean} */var DEF=true;externMethod();DEF=false",
null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR);
test("/** @define {boolean} */var DEF=true;var x = DEF;DEF=false",
null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR);
test("/** @define {boolean} */var DEF=true;var x;DEF=x=false",
null, ProcessDefines.INVALID_DEFINE_INIT_ERROR);
test(
null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR);
test("/** @define {boolean} */var DEF=true;function foo() {DEF=false};",
null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR);
test("function foo() {/** @define {boolean} */var DEF=true;};",
null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR);
test("/** @define {boolean} */var DEF=true;var x=0;while (x) {DEF=false;}",
null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR);
test("var x; /** @define {boolean} */var DEF=true; x=DEF; DEF=false;",
null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR);
test("goog.tweak.registerBoolean(3, 'Description')", null,
ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR);
test("goog.tweak.getBoolean('a' + 'b')", null,
ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR);
test("var CONST = 'foo'; goog.tweak.overrideDefaultValue(CONST, 3)", null,
test("goog.tweak.registerBoolean('Some ID', 'a')", null,
ProcessTweaks.INVALID_TWEAK_ID_ERROR);
test("goog.tweak.registerBoolean('TweakA', 'desc');" +
"goog.tweak.registerBoolean('TweakA', 'desc')", null,
test("goog.tweak.registerBoolean('TweakA', 'desc');" +
null, ProcessTweaks.TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR);
test("function foo() {goog.tweak.registerBoolean('TweakA', 'desc');};",
null, ProcessTweaks.NON_GLOBAL_TWEAK_INIT_ERROR);
test("/** @nosideeffects */ function foo() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = /** @nosideeffects */ function() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("/** @nosideeffects */ var f = function() {}",
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = function() {};" +
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
test("var f = function() {};" +
null, INVALID_NO_SIDE_EFFECT_ANNOTATION);
"Bar.prototype = {a: function(){}, c: 1,  b: 0}; bar.a();");
testRenameMap("", input, expected,  expectedMap);
testRenameMap(externs, input, expected,  expectedMap);
test("var x = goog.getCssName('header', 'active')",
null, UNEXPECTED_STRING_LITERAL_ERROR);
test("el.className = goog.getCssName('footer', window)",
null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("setClass(goog.getCssName('buttonbar', 'disabled'))",
null, UNEXPECTED_STRING_LITERAL_ERROR);
test("setClass(goog.getCssName(goog.getCssName('buttonbar'), 'active'))",
null, UNEXPECTED_STRING_LITERAL_ERROR);
test("goog.getCssName()", null,
ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR);
test("goog.getCssName('a', 'b', 'c')", null,
ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR);
test("goog.getCssName('a', 'b', 'c', 'd')", null,
ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR);
test("goog.getCssName('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i')", null,
test("goog.getCssName(window);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(555);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName([]);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName({});", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(null);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(undefined);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, window);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, 555);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, []);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, {});", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, null);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName(baseClass, undefined);", null,
ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR);
test("goog.getCssName('foo', 3);", null,
testSame(new String[] {"/** @idGenerator */ var id = function() {}; " +
"var x = 'foo';" +
"id(x);"},
null,
testSame(new String[] {"/** @idGenerator */ var id = function() {}; " +
"id('foo' + 'bar');"},
null,
testSame(new String[] {"/** @idGenerator */ var id = function() {}; " +
"function Foo() { id('foo'); }"},
testSame(new String[] {"/** @idGenerator */ var id = function() {}; " +
"if(x) id('foo');"},
testSame(new String[] {"/** @idGenerator \n @consistentIdGenerator \n*/" +
"var id = function() {}; "},
testSame(new String[] {"/** @stableIdGenerator \n @idGenerator \n*/" +
"var id = function() {}; "},
testSame(new String[] {"/** @stableIdGenerator \n " +
"@consistentIdGenerator \n*/" +
"var id = function() {}; "},
test("/** @desc A message with two placeholders, but one is missing. */\n" +
null, JsMessageVisitor.MESSAGE_TREE_MALFORMED);
test("var MSG_E = 'Hello';", "var MSG_E = 'Hello';",
test("var MSG_E = 'Hello';", "var MSG_E = 'Hello';",
test(
"var MSG_J = goog.getMsg('${$amt_earned}', {amt_earned: x});",
test(
"var MSG_K = goog.getMsg('Hi {$jane}', {jane: x});",
test("var MSG_B = function(chump) {return chump + 'x'};",
"var MSG_B = function(chump) {return chump + 'x'};",
test("var MSG_A = goog.getMsg('{$a}');",
"var MSG_A = goog.getMsg('{$a}');",
test("/** @desc d */\n" +
"var x = goog.getMsgWithFallback(MSG_A);", null,
test("var x = goog.getMsgWithFallback('abc', 'bcd');", null,
JsMessageVisitor.BAD_FALLBACK_SYNTAX);
test("/** @desc d */\n" +
"var x = goog.getMsgWithFallback(MSG_A, y);", null,
test("/** @desc d */\n" +
"var x = goog.getMsgWithFallback(y, MSG_A);", null,
private void testFailure(String code, DiagnosticType expectedError) {
test(code, null, expectedError);
private void testScopedFailure(String code, DiagnosticType expectedError) {
test("goog.scope(function() {" + code + "});", null, expectedError);
testScopedFailure("this.y = 10;", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);
testScopedFailure("var x = this;",
ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);
testScopedFailure("fn(this);", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);
testScopedFailure("var x = goog.dom; x = goog.events;",
ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED);
test("var x = {y: {}};" +
"});", null,
testScopedFailure("return;", ScopedAliases.GOOG_SCOPE_USES_RETURN);
testScopedFailure("var x = goog.dom; return;",
ScopedAliases.GOOG_SCOPE_USES_RETURN);
testScopedFailure("throw 'error';", ScopedAliases.GOOG_SCOPE_USES_THROW);
testFailure("var x = goog.scope(function() {});",
ScopedAliases.GOOG_SCOPE_MUST_BE_ALONE);
testFailure("var f = function() { goog.scope(function() {}); }",
testFailure("goog.scope()", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);
testFailure("goog.scope(10)", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);
testFailure("goog.scope(function() {}, 10)",
ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);
testFailure("goog.scope(function z() {})",
ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);
testFailure("goog.scope(function(a, b, c) {})",
ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);
testScopedFailure("try { } catch (e) {}",
ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
testScopedFailure("for (var k in { a: 1, b: 2 }) {}",
ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
testScopedFailure("var x = 3; x = 5;",
ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED);
test("{function g() {}}", null, StrictModeCheck.BAD_FUNCTION_DECLARATION);
test("var x;if (x) { function g(){} }", null,
StrictModeCheck.BAD_FUNCTION_DECLARATION);
test("{function g() {}}", null, StrictModeCheck.BAD_FUNCTION_DECLARATION);
test("goog.formatter=function(){};" +
null, StripCode.STRIP_TYPE_INHERIT_ERROR);
test("goog.formatter=function(){};" +
null, StripCode.STRIP_TYPE_INHERIT_ERROR);
test("goog.formatter=function(){};" +
null, StripCode.STRIP_TYPE_INHERIT_ERROR);
test("(foo.logger_ = 7) + 8",
"(foo.logger_ = 7) + 8",
test("(goog.debug.Logger.foo = 7) + 8",
"(goog.debug.Logger.foo = 7) + 8",
test("(GA_GoogleDebugger.foo = 7) + 8",
"(GA_GoogleDebugger.foo = 7) + 8",
test(js, null, TransformAMDToCJSModule.UNSUPPORTED_DEFINE_SIGNATURE_ERROR);
test(js, null,
TransformAMDToCJSModule.NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR);
" is not a subtype of " + type +".",  varType.isSubtype(type));
test("x = 0;", null, VarCheck.UNDEFINED_VAR_ERROR);
test("{ let x = 1; } var y = x;", null, VarCheck.UNDEFINED_VAR_ERROR);
test("var x = 1; var x = 2;", null,
VarCheck.VAR_MULTIPLY_DECLARED_ERROR);
test("try { var x = 1; x *=2; } catch (x) {}", null,
VarCheck.VAR_MULTIPLY_DECLARED_ERROR);
"asdf.foo;", "var asdf;", "",
test("var a = {b:5}; with (a){b;}", null, VarCheck.UNDEFINED_VAR_ERROR);
test(new JSModule[] { m1, m2 },
new String[] { code1, code2 }, error, warning);
test(js, null, VarCheck.VAR_MULTIPLY_DECLARED_ERROR);
test("/** @define {boolean} */ var DEF = false; var DEF = true;",
null, VAR_MULTIPLY_DECLARED_ERROR);
test("var f = function arguments() {}",
null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);
test("var f = function (arguments) {}",
null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);
test("function f() {try {} catch(arguments) {}}",
null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);
test("goog.require('namespace.Class1');\n", null,String[] sourceLines = getCode().split("\n");public Builder delete(Node n) {
return delete(googRequireNode);
String expectedCode = preamble + "\n\n" + postamble;(constructors == null || !constructors.contains(className));
&& !requires.contains(outermostClassName)));
if (var == null || var.isLocal() || var.isExtern()) {private String renamePrefixNamespace = null;
CommandLineConfig setRenamePrefixNamespace(String renamePrefixNamespace) {
this.renamePrefixNamespace = renamePrefixNamespace;
return this;
.setNewTypeInference(flags.useNewTypeInference)
.setRenamePrefixNamespace(flags.renamePrefixNamespace);options.renamePrefixNamespace = config.renamePrefixNamespace;if (getLastChar() != ' ' && op.charAt(0) != ',') {
append(" ");
append(op);
append(op);
CompilerOptions newCompilerOptions(boolean prettyprint, int lineThreshold) {
options.setPrettyPrint(prettyprint);
options.setLineLengthThreshold(lineThreshold);
CompilerOptions newCompilerOptions(boolean prettyprint, int lineThreshold, boolean lineBreak) {
CompilerOptions options = newCompilerOptions(prettyprint, lineThreshold);
options.setLineBreak(lineBreak);
return options;
String parsePrint(String js, boolean prettyprint, int lineThreshold) {
return parsePrint(js, newCompilerOptions(prettyprint, lineThreshold));
String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold) {
return parsePrint(js, newCompilerOptions(prettyprint, lineThreshold, lineBreak));
String parsePrint(String js, boolean prettyprint, boolean lineBreak,
boolean preferLineBreakAtEof, int lineThreshold) {
CompilerOptions options = newCompilerOptions(prettyprint, lineThreshold, lineBreak);
options.setPreferLineBreakAtEndOfFile(preferLineBreakAtEof);
return parsePrint(js, options);
String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold,
boolean outputTypes) {
return new CodePrinter.Builder(parse(js, true))
.setCompilerOptions(newCompilerOptions(prettyprint, lineThreshold, lineBreak))
.setOutputTypes(outputTypes)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.build();
String parsePrint(String js, boolean prettyprint, boolean lineBreak,
int lineThreshold, boolean outputTypes,
boolean tagAsStrict) {
return new CodePrinter.Builder(parse(js, true))
.setCompilerOptions(newCompilerOptions(prettyprint, lineThreshold, lineBreak))
.setOutputTypes(outputTypes)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.setTagAsStrict(tagAsStrict)
.build();
parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, false, true,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, false, false, false, 30));
parsePrint(js, false, false, true, 30));
parsePrint(js, true, false,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, true, false,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));
parsePrint(js, false, true, 10));
String result = parsePrint("var x", false, false, 0, false, true);private FunctionType applyInstantiation(
boolean keepTypeParams, Map<String, JSType> typeMap) {
builder.addReceiverType(receiverType.instantiateGenerics(typeMap));
if (keepTypeParams) {
builder.addTypeParameters(this.typeParameters);
return applyInstantiation(true, typeMap);
return applyInstantiation(false, typeMap);
return applyInstantiation(false, builder.build());
return new NominalType(builder.build(), this.rawType);if (getLastChar() != ' ' && op.charAt(0) != ',') {
append(" ");
append(op);
private abstract class CompilerOptionBuilder {
abstract void setOptions(CompilerOptions options);
CompilerOptions newCompilerOptions(CompilerOptionBuilder builder) {
builder.setOptions(options);
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
options.setPrettyPrint(false);
options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPrettyPrint(false);
options.setLineBreak(true);
options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
options.setPrettyPrint(false);
options.setLineBreak(false);
options.setLineLengthThreshold(30);
options.setPreferLineBreakAtEndOfFile(false);
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
options.setPrettyPrint(false);
options.setLineBreak(false);
options.setLineLengthThreshold(30);
options.setPreferLineBreakAtEndOfFile(true);
public void testPrettyPrinter_spaceBeforeSingleQuote() throws Exception {
assertPrettyPrint("var f = function() { return 'hello';};",
"var f = function() {\n" +
"  return 'hello';\n" +
"};\n",
new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPreferSingleQuotes(true);
public void testPrettyPrinter_spaceBeforeBangOperator() throws Exception {
assertPrettyPrint("var f = function() { return !b; };",
"var f = function() {\n" +
"  return !b;\n" +
"};\n");
assertPrettyPrint(js, expected, new CompilerOptionBuilder() {
private void assertPrettyPrint(String js, String expected,
final CompilerOptionBuilder optionBuilder) {
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPrettyPrint(true);
options.setLineBreak(false);
options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
optionBuilder.setOptions(options);
new CodePrinter.Builder(parse(js, true))
.setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPrettyPrint(true);
options.setLineBreak(false);
options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
.setOutputTypes(true)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.build());
parsePrint(js, newCompilerOptions(new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPrettyPrint(false);
options.setLineBreak(true);
options.setLineLengthThreshold(10);
String result = new CodePrinter.Builder(parse("var x", true))
.setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder() {
void setOptions(CompilerOptions options) {
options.setPrettyPrint(false);
options.setLineBreak(false);
options.setLineLengthThreshold(0);
.setOutputTypes(false)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.setTagAsStrict(true)
.build();"es6_collections.js",
Node callee = n.getFirstChild();
if (callee.matchesQualifiedName("goog.getMsg")) {
return JSType.STRING;
JSType calleeType = simpleInferExprType(callee);
if (calleeType == null) {
FunctionType funType = calleeType.getFunType();
if (union.getChildCount() == 1) {
Node firstChild = union.getFirstChild();
union.removeChild(firstChild);
return firstChild;
Set<String> names = new HashSet<>();
String name = fieldType.isStringKey() ? fieldType.getString()
: fieldType.getFirstChild().getString();
if (names.add(name)) {
fieldTypeList.addChildToBack(fieldType);
parser.addTypeWarning(
"msg.jsdoc.type.record.duplicate", name, stream.getLineno(), stream.getCharno());
builder.addProperty(fieldName, fieldType, fieldNameNode);
import com.google.common.collect.ImmutableSortedMap;
private final ImmutableSortedMap.Builder<String, RecordProperty> properties =
ImmutableSortedMap.naturalOrder();
return new RecordType(registry, properties.build(), isDeclared);
import static com.google.common.truth.Truth.assertThat;
assertThat(b).hasSize(Iterables.size(a));
checkNoWarnings("/** @param {(?)} x */ function f(x) {}");
public void testInferConstTypeFromGoogGetMsg() {
typeCheck(
"/** @const */\n"
+ "var s = goog.getMsg('asdf');\n"
+ "s - 1;\n",
NewTypeInference.INVALID_OPERAND_TYPE);
"Bad type annotation. Duplicate record field x");
"Bad type annotation. Duplicate record field number"});
public void testParseUnionType19() throws Exception {
JSDocInfo info = parse("@type {(?)} */");
assertTypeEquals(UNKNOWN_TYPE, info.getType());EnvTypePair pair = analyzeExprBwd(receiver, outEnv,
pickReqObjType(receiver.getParent()).withLoose()
.withProperty(qname, requiredType));
(!isPropertyTest(n) || objectType.isStruct())) {
private boolean isPropertyTest(Node getProp) {
Node parent = getProp.getParent();
switch (parent.getType()) {
case Token.CALL:
return parent.getFirstChild() != getProp &&
compiler.getCodingConvention().isPropertyTestFunction(parent);
case Token.IF:
case Token.WHILE:
case Token.DO:
case Token.FOR:
return NodeUtil.getConditionExpression(parent) == getProp;
case Token.INSTANCEOF:
case Token.TYPEOF:
return true;
case Token.AND:
case Token.HOOK:
return parent.getFirstChild() == getProp;
case Token.NOT:
return parent.getParent().isOr() &&
parent.getParent().getFirstChild() == parent;
case Token.CAST:
return isPropertyTest(parent);
return false;
return false;
"/** @constructor */\n" +
"function Foo() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {\n" +
"  var y = x;\n" +
"  goog.asserts.assertInstanceof(y, Foo);\n" +
"}");"Returned type does not match declared return type.\n " +
"Function called in context that expects incompatible type.\n " +
"Invalid type for parameter {0} of function {1}.\n " +
"Variable {0} typed inconsistently across scopes.\n " +
Integer.toString(i + 1), "",package com.google.javascript.jscomp;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.List;
import java.util.Map;
import java.util.Set;
class AliasKeywords implements CompilerPass {
private class FindAliasableNodes extends AbstractPostOrderCallback {
public void visit(NodeTraversal t, Node n, Node parent) {
final int type = n.getType();
if (isAliasableType(type)) {
visitAliasableNode(n, parent);
visitNameNode(n);
private void visitAliasableNode(Node n, Node parent) {
AliasSpecification aliasableNodes = aliasTypes.get(n.getType());
aliasableNodes.visit(n, parent);
private void visitNameNode(Node n) {
if (isAliasDefinition(n)) {
throw new IllegalStateException(
"Existing alias definition for " + Token.name(n.getType()));
private abstract static class AliasSpecification {
private final Map<Node, Node> nodes = Maps.newHashMap();
private boolean isAliased = false;
private String aliasName;
private int tokenId;
public AliasSpecification(String aliasName, int tokenId) {
this.aliasName = aliasName;
this.tokenId = tokenId;
public void visit(Node n, Node parent) {
nodes.put(n, parent);
boolean maybeInsertAliasDeclarationIntoParseTree(Node codeRoot) {
if (nodes.size() >= minOccurrencesRequiredToAlias()) {
insertAliasDeclaration(codeRoot);
isAliased = true;
return true;
return false;
public void doAlias(AbstractCompiler compiler) {
if (isAliased) {
for (Map.Entry<Node, Node> entry : nodes.entrySet()) {
Node n = entry.getKey();
Node parent = entry.getValue();
aliasNode(n, parent);
compiler.reportCodeChange();
public int getTokenId() {
return tokenId;
public String getAliasName() {
return aliasName;
protected abstract int minOccurrencesRequiredToAlias();
protected abstract void insertAliasDeclaration(Node codeRoot);
protected abstract void aliasNode(Node n, Node parent);
private class ThrowAliasSpecification extends AliasSpecification {
ThrowAliasSpecification(String aliasName) {
super(aliasName, Token.THROW);
protected void aliasNode(Node throwNode, Node parent) {
Node name = NodeUtil.newName(
compiler, getAliasName(), throwNode, getAliasName());
Node aliasCall = IR.call(name, throwNode.removeFirstChild());
aliasCall.putBooleanProp(Node.FREE_CALL, true);
Node exprResult = IR.exprResult(aliasCall);
parent.replaceChild(throwNode, exprResult);
protected void insertAliasDeclaration(Node codeRoot) {
codeRoot.addChildToFront(createAliasFunctionNode(getAliasName()));
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;
static int estimateMinOccurrencesRequriedToAlias() {
Node alias = createAliasFunctionNode("TT");
return InlineCostEstimator.getCost(alias) / 2 + 1;
private static Node createAliasFunctionNode(String aliasName) {
final String paramName = "jscomp_throw_param";
return IR.function(
IR.name(aliasName),
IR.paramList(IR.name(paramName)),
IR.block(
IR.throwNode(IR.name(paramName))));
private class KeywordAliasSpecification extends AliasSpecification {
KeywordAliasSpecification(String aliasName, int tokenId) {
super(aliasName, tokenId);
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
protected void aliasNode(Node n, Node parent) {
Node aliasNode = NodeUtil.newName(
compiler, getAliasName(), n, getAliasName());
parent.replaceChild(n, aliasNode);
protected void insertAliasDeclaration(Node codeRoot) {
Node varNode = new Node(Token.VAR);
Node value = new Node(getTokenId());
Node name = NodeUtil.newName(
compiler, getAliasName(), varNode, getAliasName());
name.addChildToBack(value);
varNode.addChildToBack(name);
codeRoot.addChildrenToFront(varNode);
private class VoidKeywordAliasSpecification extends AliasSpecification {
VoidKeywordAliasSpecification(String aliasName, int tokenId) {
super(aliasName, tokenId);
public void visit(Node n, Node parent) {
Node value = n.getFirstChild();
if (value.isNumber() && value.getDouble() == 0) {
super.visit(n, parent);
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
protected void aliasNode(Node n, Node parent) {
Node aliasNode = NodeUtil.newName(
compiler, getAliasName(), n, getAliasName());
parent.replaceChild(n, aliasNode);
protected void insertAliasDeclaration(Node codeRoot) {
Node varNode = new Node(Token.VAR);
Node value = IR.voidNode(IR.number(0));
Node name = NodeUtil.newName(
compiler, getAliasName(), varNode, getAliasName());
name.addChildToBack(value);
varNode.addChildToBack(name);
codeRoot.addChildrenToFront(varNode);
static final String ALIAS_NULL = "JSCompiler_alias_NULL";
static final String ALIAS_TRUE = "JSCompiler_alias_TRUE";
static final String ALIAS_FALSE = "JSCompiler_alias_FALSE";
static final String ALIAS_THROW = "JSCompiler_alias_THROW";
static final String ALIAS_VOID = "JSCompiler_alias_VOID";
static final int MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL = 6;
static final int MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW =
estimateMinOccurrencesRequriedToAlias();
private final AbstractCompiler compiler;
private final List<AliasSpecification> aliasSpecifications;
private final Map<Integer, AliasSpecification> aliasTypes;
private final Set<String> aliasNames;
AliasKeywords(AbstractCompiler compiler) {
this.compiler = compiler;
aliasSpecifications = createAliasSpecifications();
aliasTypes = Maps.newLinkedHashMap();
aliasNames = Sets.newLinkedHashSet();
for (AliasSpecification specification : aliasSpecifications) {
aliasTypes.put(specification.getTokenId(), specification);
aliasNames.add(specification.getAliasName());
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, new FindAliasableNodes());
if (needsAliases()) {
addAliasNodes(compiler.getNodeForCodeInsertion(null));
for (AliasSpecification spec : aliasSpecifications) {
spec.doAlias(compiler);
private boolean needsAliases() {
for (AliasSpecification spec : aliasSpecifications) {
if (!spec.nodes.isEmpty()) {
return true;
return false;
private void addAliasNodes(Node codeRoot) {
boolean codeChanged = false;
for (AliasSpecification spec : aliasSpecifications) {
if (spec.maybeInsertAliasDeclarationIntoParseTree(codeRoot)) {
codeChanged = true;
if (codeChanged) {
compiler.reportCodeChange();
private boolean isAliasDefinition(Node n) {
if (!n.isName()) {
return false;
if (!isAliasName(n.getString())) {
return false;
return n.getFirstChild() != null;
private boolean isAliasableType(int type) {
return aliasTypes.containsKey(type);
private boolean isAliasName(String name) {
return aliasNames.contains(name);
private List<AliasSpecification> createAliasSpecifications() {
List<AliasSpecification> l = Lists.newArrayList();
l.add(new KeywordAliasSpecification(ALIAS_FALSE, Token.FALSE));
l.add(new KeywordAliasSpecification(ALIAS_NULL, Token.NULL));
l.add(new KeywordAliasSpecification(ALIAS_TRUE, Token.TRUE));
l.add(new VoidKeywordAliasSpecification(ALIAS_VOID, Token.VOID));
l.add(new ThrowAliasSpecification(ALIAS_THROW));
return l;
if (options.aliasKeywords) {
passes.add(aliasKeywords);
final PassFactory aliasKeywords = new PassFactory("aliasKeywords", true) {
protected CompilerPass create(AbstractCompiler compiler) {
return new AliasKeywords(compiler);
public static final DiagnosticGroup CHECK_PROVIDES =
DiagnosticGroups.registerGroup("checkProvides",
CheckProvides.MISSING_PROVIDE_WARNING);
String variableName = variable.isName() ? variable.getQualifiedName()
: variable.getFirstChild().getQualifiedName(); // var or let
body.addChildToFront(IR.var(IR.name(variableName),
IR.getprop(iterResult.cloneTree(), IR.string("value"))));
warnings.add(JSError.make(assertedNode, NewTypeInference.ASSERT_FALSE));
pair.type = JSType.UNKNOWN;
pair.env = env;
HashMap<String, JSType> tmpTypeMap = new HashMap<>();
for (String typeParam : typeParameters) {
tmpTypeMap.put(typeParam, JSType.UNKNOWN);
unifTarget.substituteGenerics(tmpTypeMap);
static boolean isNameDeclaration(Node n) {
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.common.collect.Sets;
import com.google.gson.JsonObject;
import com.google.javascript.jscomp.CodePrinter;
import com.google.javascript.rhino.Node;
import java.util.EnumSet;
import java.util.Set;
abstract class AbstractFuzzer {
protected FuzzingContext context;
AbstractFuzzer(FuzzingContext context) {
this.context = context;
protected JsonObject getOwnConfig() {
Preconditions.checkNotNull(context.config);
return context.config.get(getConfigName()).getAsJsonObject();
protected abstract boolean isEnough(int budget);
protected abstract Node generate(int budget, Set<Type> types);
protected Node generate(int budget) {
return generate(budget, supportedTypes());
protected Node[] distribute(int budget, AbstractFuzzer[] fuzzers) {
Preconditions.checkArgument(fuzzers.length > 0);
int numNodes = fuzzers.length;
int[] subBudgets = new int[numNodes];
if (budget > 3 * numNodes) {
double[] rands = new double[numNodes];
double sum = 0;
for (int i = 0; i < numNodes; i++) {
rands[i] = context.random.nextDouble();
sum += rands[i];
for (int i = 0; i < numNodes; i++) {
double additionalBudget = budget / sum * rands[i];
subBudgets[i] += additionalBudget;
budget -= additionalBudget;
while (budget > 0) {
subBudgets[context.random.nextInt(numNodes)]++;
budget--;
Node[] nodes = new Node[numNodes];
for (int i = 0; i < numNodes; i++) {
nodes[i] = fuzz(fuzzers[i], subBudgets[i]);
return nodes;
protected Node fuzz(AbstractFuzzer fuzzer, int budget) {
return fuzzer.generate(budget);
protected abstract String getConfigName();
protected int generateLength(int budget) {
return context.random.nextInt(
(int) (budget * getOwnConfig().get("maxLength").getAsDouble()) + 1);
public static String getPrettyCode(Node root) {
CodePrinter.Builder builder = new CodePrinter.Builder(root);
builder.setPrettyPrint(true);
builder.setLineBreak(true);
return builder.build();
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(EnumSet.allOf(Type.class));
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class ArrayFuzzer extends AbstractFuzzer {
ArrayFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(Token.ARRAYLIT);
if (budget < 1) {
budget = 1;
int arraySize = generateLength(budget - 1);
if (arraySize > 0) {
AbstractFuzzer[] fuzzers = new AbstractFuzzer[arraySize];
Arrays.fill(fuzzers, new ExpressionFuzzer(context));
Node[] elements = distribute(budget - 1, fuzzers);
for (int i = 0; i < arraySize; i++) {
node.addChildToBack(elements[i]);
return node;
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "array";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.ARRAY);
package com.google.javascript.jscomp.fuzzing;
class AssignableExprFuzzer extends Dispatcher {
Type type;
AssignableExprFuzzer(FuzzingContext context) {
super(context);
AssignableExprFuzzer(FuzzingContext context, Type type) {
super(context);
this.type = type;
protected void initCandidates() {
ExistingIdentifierFuzzer idFuzzer = context.strict ?
new ExistingIdentifierFuzzer(context, type, true) :
new ExistingIdentifierFuzzer(context);
candidates = new AbstractFuzzer[] {
idFuzzer,
new GetPropFuzzer(context),
new GetElemFuzzer(context)
protected String getConfigName() {
return "assignableExpr";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.CaseFormat;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
public class BinaryExprFuzzer extends Dispatcher {
BinaryExprFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
Operator[] operators = Operator.values();
candidates = new BinaryExprGenerator[operators.length];
for (int i = 0; i < operators.length; i++) {
candidates[i] = new BinaryExprGenerator(context, operators[i]);
private static class BinaryExprGenerator extends AbstractFuzzer {
private Operator operator;
private AbstractFuzzer left, right;
private String configName;
BinaryExprGenerator(FuzzingContext context, Operator operator) {
super(context);
this.configName = CaseFormat.UPPER_UNDERSCORE.to(
CaseFormat.LOWER_CAMEL, operator.name());
this.operator = operator;
protected Node generate(int budget, Set<Type> types) {
Node[] operands = distribute(
budget - 1, new AbstractFuzzer[] {getLeft(),  getRight()});
return new Node(operator.nodeType, operands);
protected Node fuzz(AbstractFuzzer fuzzer, int budget) {
if (context.strict && fuzzer == getRight()) {
return fuzzer.generate(budget, operator.rightTypes);
return fuzzer.generate(budget);
private AbstractFuzzer getLeft() {
if (left == null) {
left = operator.hasSideEffect() ?
new AssignableExprFuzzer(context) :
new ExpressionFuzzer(context);
return left;
private AbstractFuzzer getRight() {
if (right == null) {
right = new ExpressionFuzzer(context);
return right;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getLeft().isEnough(budget - 2) &&
getRight().isEnough(budget - 2);
protected String getConfigName() {
return configName;
private enum Operator {
MUL(Token.MUL),
DIV(Token.DIV),
MOD(Token.MOD),
ADD(Token.ADD),
SUB(Token.SUB),
LSH(Token.LSH),
RSH(Token.RSH),
URSH(Token.URSH),
LT(Token.LT),
GT(Token.GT),
LE(Token.LE),
GE(Token.GE),
INSTANCEOF(Token.INSTANCEOF, Sets.newHashSet(Type.FUNCTION)),
IN(Token.IN, Sets.newHashSet(Type.OBJECT)),
EQ(Token.EQ),
NE(Token.NE),
SHEQ(Token.SHEQ),
SHNE(Token.SHNE),
BIT_AND(Token.BITAND),
BIT_XOR(Token.BITXOR),
BIT_OR(Token.BITOR),
AND(Token.AND),
OR(Token.OR),
ASSIGN(Token.ASSIGN),
ASSIGN_MUL(Token.ASSIGN_MUL),
ASSIGN_DIV(Token.ASSIGN_DIV),
ASSIGN_MOD(Token.ASSIGN_MOD),
ASSIGN_ADD(Token.ASSIGN_ADD),
ASSIGN_SUB(Token.ASSIGN_SUB),
ASSIGN_LSH(Token.ASSIGN_LSH),
ASSIGN_RSH(Token.ASSIGN_RSH),
ASSIGN_URSH(Token.ASSIGN_URSH),
ASSIGN_BIT_AND(Token.ASSIGN_BITAND),
ASSIGN_BIT_XOR(Token.ASSIGN_BITXOR),
ASSIGN_BIT_OR(Token.ASSIGN_BITOR);
int nodeType;
Set<Type> rightTypes;
Operator(int nodeType) {
this.nodeType = nodeType;
rightTypes = Sets.newHashSet(Type.values());
Operator(int nodeType, Set<Type> rightTypes) {
this.nodeType = nodeType;
this.rightTypes = rightTypes;
boolean hasSideEffect() {
return this.name().startsWith("ASSIGN");
protected String getConfigName() {
return "binaryExpr";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class BlockFuzzer extends AbstractFuzzer {
BlockFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 1;
protected Node generate(int budget, Set<Type> types) {
if (budget < 1) {
budget = 1;
int numStmts = generateLength(budget - 1);
if (numStmts == 0) {
return new Node(Token.BLOCK);
StatementFuzzer[] stmtFuzzers = new StatementFuzzer[numStmts];
Arrays.fill(
stmtFuzzers,
new StatementFuzzer(context));
Node[] statements = distribute(budget - 1, stmtFuzzers);
return new Node(Token.BLOCK, statements);
protected String getConfigName() {
return "block";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class BooleanFuzzer extends AbstractFuzzer {
BooleanFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
return context.random.nextInt(2) == 0 ?
new Node(Token.FALSE) : new Node(Token.TRUE);
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "boolean";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.BOOLEAN);
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
public class BreakFuzzer extends AbstractFuzzer {
BreakFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
Scope scope = context.scopeManager.localScope();
if (scope.loopNesting + scope.switchNesting > 0) {
return budget >= 1;
return false;
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(Token.BREAK);
Scope localScope = context.scopeManager.localScope();
double toLabel = getOwnConfig().get("toLabel").getAsDouble();
if (budget > 1 &&
localScope.loopLabels.size() + localScope.otherLabels.size() > 0 &&
context.random.nextDouble() < toLabel) {
node.addChildToBack(
Node.newString(Token.LABEL_NAME,
localScope.randomLabelForBreak(context.random)));
return node;
protected String getConfigName() {
return "break";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ContinueFuzzer extends AbstractFuzzer {
ContinueFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
Scope scope = context.scopeManager.localScope();
if (scope.loopNesting > 0) {
return budget >= 1;
return false;
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(Token.CONTINUE);
Scope localScope = context.scopeManager.localScope();
double toLabel = getOwnConfig().get("toLabel").getAsDouble();
if (budget > 1 && !localScope.loopLabels.isEmpty()
&& context.random.nextDouble() < toLabel) {
node.addChildToBack(
Node.newString(Token.LABEL_NAME,
localScope.randomLabelForContinue(context.random)));
return node;
protected String getConfigName() {
return "continue";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
public class DiscreteDistribution<T> {
private Random random;
private List<T> items;
private List<Double> weights;
public DiscreteDistribution(Random random,
ArrayList<T> items, ArrayList<Double> weights) {
this.random = random;
this.items = items;
this.weights = weights;
double sum = 0;
for (Double w : weights) {
Preconditions.checkArgument(w >= 0);
Preconditions.checkArgument(!Double.isInfinite(w));
Preconditions.checkArgument(!Double.isNaN(w));
sum += w;
for (int i = 0; i < weights.size(); i++) {
weights.set(i, weights.get(i) / sum);
public T nextItem() {
final double randomValue = random.nextDouble();
double sum = 0;
for (int i = 0; i < weights.size(); i++) {
sum += weights.get(i);
if (Double.compare(randomValue, sum) <= 0) {
return items.get(i);
return null;
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.javascript.rhino.Node;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Set;
abstract class Dispatcher extends AbstractFuzzer {
private Set<Type> supportedTypes;
Dispatcher(FuzzingContext context) {
super(context);
protected AbstractFuzzer[] candidates;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
Preconditions.checkNotNull(
getCandidates(),
"Candidate fuzzers need to be initialized before being used.");
for (AbstractFuzzer fuzzer : getCandidates()) {
if (fuzzer.isEnough(budget)) {
return true;
return false;
protected Node generate(int budget, Set<Type> types) {
AbstractFuzzer fuzzer = selectFuzzer(budget, types);
return fuzzer.generate(budget, types);
protected Set<Type> supportedTypes() {
if (supportedTypes == null) {
supportedTypes = EnumSet.noneOf(Type.class);
for (AbstractFuzzer fuzzer : getCandidates()) {
supportedTypes.addAll(fuzzer.supportedTypes());
return Sets.immutableEnumSet(supportedTypes);
protected AbstractFuzzer selectFuzzer(int budget, Set<Type> types) {
Preconditions.checkNotNull(
getCandidates(),
"Candidate fuzzers need to be initialized before being used.");
ArrayList<AbstractFuzzer> typeCorrectCandidates;
typeCorrectCandidates = Lists.newArrayList();
for (AbstractFuzzer fuzzer : getCandidates()) {
if (!Sets.intersection(fuzzer.supportedTypes(), types).
isEmpty()) {
typeCorrectCandidates.add(fuzzer);
JsonObject weightConfig = getOwnConfig().get("weights").getAsJsonObject();
ArrayList<AbstractFuzzer> validFuzzers = Lists.newArrayList();
ArrayList<Double> weights = Lists.newArrayList();
int stepSize = 2;
budget -= stepSize;
do {
budget += stepSize;
for (AbstractFuzzer fuzzer : typeCorrectCandidates) {
if (fuzzer.isEnough(budget)) {
validFuzzers.add(fuzzer);
try {
weights.add(weightConfig.get(fuzzer.getConfigName()).getAsDouble());
e.printStackTrace();
DiscreteDistribution<AbstractFuzzer> dd =
new DiscreteDistribution<>(context.random, validFuzzers, weights);
return dd.nextItem();
protected abstract void initCandidates();
private AbstractFuzzer[] getCandidates() {
if (candidates == null) {
initCandidates();
return candidates;
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class DoWhileFuzzer extends AbstractFuzzer {
DoWhileFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
Preconditions.checkArgument(budget >= 3);
AbstractFuzzer[] fuzzers = {
new BlockFuzzer(context),
new ExpressionFuzzer(context)
context.scopeManager.localScope().loopNesting++;
Node[] components = distribute(budget, fuzzers);
context.scopeManager.localScope().loopNesting--;
return new Node(Token.DO, components);
protected String getConfigName() {
return "doWhile";
package com.google.javascript.jscomp.fuzzing;
import static java.nio.charset.StandardCharsets.UTF_8;
import com.google.common.base.Function;
import com.google.common.collect.Collections2;
import com.google.common.collect.Lists;
import com.google.common.io.CharStreams;
import com.google.common.io.Files;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.CompilationLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JSModule;
import com.google.javascript.jscomp.Result;
import com.google.javascript.jscomp.SyntheticAst;
import com.google.javascript.jscomp.VariableRenamingPolicy;
import com.google.javascript.rhino.Node;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
public class Driver {
usage = "The number of runs of the fuzzer. "
+ "If this option is missing, the driver will run forever")
private int numberOfRuns = -1;
usage = "The max number of nodes in the generated ASTs. Default: 100")
private int maxASTSize;
usage = "Specifies the compilation level to use. " +
"Default: SIMPLE_OPTIMIZATIONS")
private CompilationLevel compilationLevel =
CompilationLevel.SIMPLE_OPTIMIZATIONS;
usage = "Specifies the seed for the fuzzer. "
+ "It will override --number_of_runs to 1. "
+ "If not given, System.currentTimeMillis() will be used")
private long seed = -1;
usage = "Specifies the logging level for the driver. "
+ "Default: INFO")
private LoggingLevel level = LoggingLevel.INFO;
required = true,
usage = "Specifies the configuration file")
private String configFileName;
usage = "Whether to execute the generated JavaScript")
private boolean execute = false;
usage = "Whether to stop fuzzing once an error is found")
private boolean stopOnError = false;
private Logger logger;
private JsonObject config;
public Result compile(Node script) throws IOException {
CompilerInput input = new CompilerInput(new SyntheticAst(script));
JSModule jsModule = new JSModule("fuzzedModule");
jsModule.add(input);
Compiler.setLoggingLevel(level.getLevel());
Compiler compiler = new Compiler();
compiler.setTimeout(30);
compiler.disableThreads();
return compiler.compileModules(
CommandLineRunner.getDefaultExterns(),
Arrays.asList(jsModule), getOptions());
private CompilerOptions getOptions() {
CompilerOptions options = new CompilerOptions();
compilationLevel.setOptionsForCompilationLevel(options);
options.variableRenaming = VariableRenamingPolicy.OFF;
return options;
private JsonObject getConfig() {
if (config == null) {
File file = new File(configFileName);
try {
config = new Gson().fromJson(Files.toString(
file, StandardCharsets.UTF_8), JsonObject.class);
e.printStackTrace();
return config;
private Logger getLogger() {
if (logger == null) {
logger = Logger.getLogger(Driver.class.getName());
logger.setLevel(level.getLevel());
for (Handler handler : logger.getHandlers()) {
handler.setLevel(Level.ALL);
return logger;
private Node fuzz(FuzzingContext context) {
ScriptFuzzer fuzzer = new ScriptFuzzer(context);
return fuzzer.generate(maxASTSize);
private boolean executeJS(String js1, String js2) {
ExecutorService executor = Executors.newCachedThreadPool();
NodeRunner node1 = new NodeRunner(js1);
NodeRunner node2 = new NodeRunner(js2);
String[] output1 = null, output2 = null;
try {
List<Future<String[]>>  futures = executor.invokeAll(
Lists.newArrayList(node1, node2), maxASTSize, TimeUnit.MILLISECONDS);
Future<String[]> future1 = futures.get(0);
if (!future1.isCancelled()) {
output1 = future1.get();
Future<String[]> future2 = futures.get(1);
if (!future2.isCancelled()) {
output2 = future2.get();
getLogger().log(Level.INFO, "Timeout in executing JavaScript", e);
getLogger().log(Level.SEVERE, "Error in executing JavaScript", e);
node1.process.destroy();
node2.process.destroy();
if (output1 == null && output2 == null) {
getLogger().info("Infinite loop!");
return true;
boolean hasError = false;
if (output1 != null && output1[1].length() > 0) {
getLogger().warning("First JavaScript has a runtime error: " +
output1[1]);
hasError = true;
if (output2 != null && output2[1].length() > 0) {
getLogger().warning("Second JavaScript has a runtime error: " +
output2[1]);
hasError = true;
return !(hasError && getLogger().getLevel().intValue() < Level.WARNING.intValue());
StringBuilder sb =
new StringBuilder("Different outputs!");
sb.append("\nOutput 1:");
if (output1 != null) {
sb.append(output1[0]).append(output1[1]);
sb.append("null");
sb.append("\nOutput 2:");
if (output2 != null) {
sb.append(output2[0]).append(output2[1]);
sb.append("null");
getLogger().severe(sb.toString());
return false;
private void run() {
if (seed != -1) {
numberOfRuns = 1;
long currentSeed;
for (int i = 0; numberOfRuns == -1 || i < numberOfRuns; i++) {
currentSeed = seed == -1 ? System.currentTimeMillis() : seed;
getLogger().info("Running fuzzer [" + i + " of " +
numberOfRuns + "]");
Random random = currentSeed == -1 ? new Random(currentSeed) :
new Random(currentSeed);
FuzzingContext context = new FuzzingContext(random, getConfig(), execute);
Node script = null;
try {
script = fuzz(context);
getLogger().log(Level.SEVERE, "Fuzzer error: ", e);
if (stopOnError) {
break;
continue;
String code1 = ScriptFuzzer.getPrettyCode(script);
StringBuilder debugInfo = new StringBuilder("Seed: ").append(currentSeed);
debugInfo.append("\nJavaScript: ").append(code1);
try {
Result result = compile(script);
if (result.success) {
if (result.warnings.length == 0) {
getLogger().info(debugInfo.toString());
getLogger().warning(debugInfo.toString());
getLogger().severe(debugInfo.toString());
if (stopOnError) {
break;
getLogger().log(Level.SEVERE, "Compiler Crashed!", e);
getLogger().severe(debugInfo.toString());
if (stopOnError) {
break;
String code2 = ScriptFuzzer.getPrettyCode(script);
debugInfo.append("\nCompiled Code: " + code2);
String setUpCode = getSetupCode(context.scopeManager);
if (execute) {
if (!executeJS(setUpCode + code1, setUpCode + code2)) {
getLogger().severe(debugInfo.toString());
if (stopOnError) {
break;
getLogger().info(debugInfo.toString());
private static String getSetupCode(ScopeManager scopeManager) {
Collection<String> vars = Collections2.transform(
Lists.newArrayList(scopeManager.localScope().symbols),
new Function<Symbol, String>() {
public String apply(Symbol s) {
return "'" + s.name + "'=" + s.name;
String setUpCode = "function toString(value) {\n" +
"    if (value instanceof Array) {\n" +
"        var string = \"[\";\n" +
"        for (var i in value) {\n" +
"            string += toString(value[i]) + \",\";\n" +
"        }\n" +
"        string += ']';\n" +
"        return string;\n" +
"    } else if (value instanceof Function) {\n" +
"        return value.length;\n" +
"    } else {\n" +
"        return value;\n" +
"    }\n" +
"}\n" +
"\n" +
"process.on('uncaughtException', function(e) {\n" +
"    console.log(\"Errors: \");\n" +
"    if (e instanceof Error) {\n" +
"        console.log(e.name);\n" +
"    } else {\n" +
"        console.log(typeof(e));\n" +
"    }\n" +
"});\n" +
"\n" +
"process.on(\"exit\", function(e) {\n" +
"    console.log(\"Variables:\");\n" +
"    var allvars = " + vars + ";\n" +
"    console.log(toString(allvars));\n" +
"});\n" +
"";
return setUpCode;
public static void main(String[] args) throws Exception {
Driver driver = new Driver();
CmdLineParser parser = new CmdLineParser(driver);
try {
parser.parseArgument(args);
System.err.println(e.getMessage());
parser.printUsage(System.err);
System.exit(1);
driver.run();
System.exit(0);
enum LoggingLevel {
OFF(Level.OFF),
SEVERE(Level.SEVERE),
WARNING(Level.WARNING),
INFO(Level.INFO),
CONFIG(Level.CONFIG),
FINE(Level.FINE),
FINER(Level.FINER),
FINEST(Level.FINEST),
ALL(Level.ALL);
private Level level;
private LoggingLevel(Level l) {
level = l;
public Level getLevel() {
return level;
static class NodeRunner implements Callable<String[]> {
private String js;
private Process process;
NodeRunner(String js) {
this.js = js;
public String[] call() throws IOException {
String[] command = {"node", "-e", js};
Runtime runtime = Runtime.getRuntime();
process = runtime.exec(command);
String[] results = new String[2];
results[0] = CharStreams.toString(new InputStreamReader(process.getInputStream(), UTF_8));
results[1] = CharStreams.toString(new InputStreamReader(process.getErrorStream(), UTF_8));
return results;
public static boolean isSame(String[] output1, String[] output2) {
if (output1 == null && output2 == null) {
return true;
return false;
return output1[0].equals(output2[0]);
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ExistingIdentifierFuzzer extends AbstractFuzzer {
Type type;
boolean excludeExterns;
ExistingIdentifierFuzzer(FuzzingContext context) {
super(context);
ExistingIdentifierFuzzer(FuzzingContext context,
Type type, boolean excludeExterns) {
super(context);
this.type = type;
this.excludeExterns = excludeExterns;
protected Node generate(int budget, Set<Type> types) {
Preconditions.checkState(
isEnough(1),
"No symbol defined.");
int flags = 0;
if (excludeExterns) {
flags = ScopeManager.EXCLUDE_EXTERNS;
return Node.newString(
Token.NAME, context.scopeManager.getRandomSymbol(type, flags).name);
protected boolean isEnough(int budget) {
return (context.scopeManager.getSize() > 0 || !excludeExterns)
&& budget >= 1;
protected String getConfigName() {
return "existingIdentifier";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ExprStmtFuzzer extends AbstractFuzzer {
ExprStmtFuzzer(FuzzingContext context) {
super(context);
private ExpressionFuzzer exprFuzzer;
protected boolean isEnough(int budget) {
return getExprFuzzer().isEnough(budget - 1);
protected Node generate(int budget, Set<Type> types) {
Node expr = getExprFuzzer().generate(budget - 1);
return new Node(Token.EXPR_RESULT, expr);
private ExpressionFuzzer getExprFuzzer() {
if (exprFuzzer == null) {
exprFuzzer =
new ExpressionFuzzer(context);
return exprFuzzer;
protected String getConfigName() {
return "exprStmt";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Token;
class ExpressionFuzzer extends Dispatcher {
ExpressionFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[] {
new SimpleFuzzer(Token.THIS, "this", Type.OBJECT),
new ExistingIdentifierFuzzer(context),
new LiteralFuzzer(context),
new FunctionCallFuzzer(context),
new UnaryExprFuzzer(context),
new BinaryExprFuzzer(context),
new TernaryExprFuzzer(context),
new FunctionFuzzer(context, true)
protected String getConfigName() {
return "expression";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ForFuzzer extends AbstractFuzzer {
ForFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 2;
protected Node generate(int budget, Set<Type> types) {
int totalHeaderBudget =
(int) ((budget - 1) * getOwnConfig().get("headBudget").getAsDouble());
int bodyBudget = budget - 1 - totalHeaderBudget;
ExpressionFuzzer exprFuzzer =
new ExpressionFuzzer(context);
AbstractFuzzer[] fuzzers = {
new ForInitializerFuzzer(context),
exprFuzzer, exprFuzzer};
Node[] headers = distribute(totalHeaderBudget, fuzzers);
Node node = new Node(Token.FOR, headers);
context.scopeManager.localScope().loopNesting++;
Node body = new BlockFuzzer(context).
generate(bodyBudget);
context.scopeManager.localScope().loopNesting--;
node.addChildToBack(body);
return node;
protected Node fuzz(AbstractFuzzer fuzzer, int budget) {
if (fuzzer.isEnough(budget)) {
return fuzzer.generate(budget);
return new Node(Token.EMPTY);
private static class ForInitializerFuzzer extends Dispatcher {
ForInitializerFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[] {
new VarFuzzer(context),
new ExpressionFuzzer(context)
protected String getConfigName() {
return "forInitializer";
protected String getConfigName() {
return "for";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ForInFuzzer extends AbstractFuzzer {
ForInFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 4;
protected Node generate(int budget, Set<Type> types) {
Scope localScope = context.scopeManager.localScope();
localScope.loopNesting++;
AbstractFuzzer[] fuzzers = {
new ForInItemFuzzer(context),
new ExpressionFuzzer(context),
new BlockFuzzer(context)
Node[] components = distribute(budget - 1, fuzzers);
localScope.loopNesting--;
return new Node(Token.FOR, components);
private static class ForInItemFuzzer extends Dispatcher {
ForInItemFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[] {
new AssignableExprFuzzer(context),
new VarFuzzer(context)
protected String getConfigName() {
return "forInItem";
protected String getConfigName() {
return "forIn";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class FunctionCallFuzzer extends Dispatcher {
FunctionCallFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
CallFuzzer constructorFuzzer =
new CallFuzzer(context, true);
CallFuzzer normalCallFuzzer =
new CallFuzzer(context, false);
candidates = new AbstractFuzzer[]{constructorFuzzer, normalCallFuzzer};
private class CallFuzzer extends AbstractFuzzer {
private int nodeType;
private CallableExprFuzzer callableExprFuzzer;
private String configName;
CallFuzzer(FuzzingContext context, boolean isConstructor) {
super(context);
if (isConstructor) {
nodeType = Token.NEW;
configName = "constructorCall";
nodeType = Token.CALL;
configName = "normalCall";
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getCallableExprFuzzer().isEnough(budget - 1);
protected Node generate(int budget, Set<Type> types) {
int maxParamBudget = budget - 2;
if (maxParamBudget < 0) {
maxParamBudget = 0;
double argLength = getOwnConfig().get("argLength").getAsDouble();
int numArgs = context.random.nextInt((int) (maxParamBudget * argLength) + 1);
AbstractFuzzer[] fuzzers = new AbstractFuzzer[numArgs + 1];
fuzzers[0] = getCallableExprFuzzer();
ExpressionFuzzer exprFuzzer =
new ExpressionFuzzer(context);
for (int i = 1; i <= numArgs; i++) {
fuzzers[i] = exprFuzzer;
Node[] components = distribute(maxParamBudget, fuzzers);
Node node = new Node(nodeType, components);
return node;
private CallableExprFuzzer getCallableExprFuzzer() {
if (callableExprFuzzer == null) {
callableExprFuzzer = new CallableExprFuzzer(context);
return callableExprFuzzer;
private class CallableExprFuzzer extends Dispatcher {
CallableExprFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
ExistingIdentifierFuzzer idFuzzer = context.strict ?
new ExistingIdentifierFuzzer(context, Type.FUNCTION, false) :
new ExistingIdentifierFuzzer(context);
candidates = new AbstractFuzzer[] {
idFuzzer,
new GetPropFuzzer(context),
new GetElemFuzzer(context),
new FunctionFuzzer(context, true)
protected String getConfigName() {
return "callableExpr";
protected String getConfigName() {
return configName;
protected String getConfigName() {
return "functionCall";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class FunctionFuzzer extends AbstractFuzzer {
private boolean isExpression;
private IdentifierFuzzer idFuzzer;
public FunctionFuzzer(FuzzingContext context,
boolean isExpression) {
super(context);
this.isExpression = isExpression;
protected boolean isEnough(int budget) {
if (isExpression) {
return budget >= 3;
return budget >= 4;
protected Node generate(int budget, Set<Type> types) {
int paramBodyBudget;
Node name;
ScopeManager scopeManager = context.scopeManager;
if (isExpression) {
Preconditions.checkArgument(budget >= 3);
scopeManager.addScope();
if (budget >= 4 && context.random.nextInt(2) == 0) {
name = getIdFuzzer().generate(1);
paramBodyBudget = budget - 3;
name = Node.newString(Token.NAME, "");
paramBodyBudget = budget - 2;
Preconditions.checkArgument(budget >= 4);
name = getIdFuzzer().generate(1);
paramBodyBudget = budget - 3;
scopeManager.addScope();
int numParams = context.random.nextInt(getOwnConfig().get("maxParams").getAsInt() + 1);
int bodyBudget = paramBodyBudget - numParams - 1;
Node params =
new ParamListFuzzer(context).
generate(numParams);
int numStmts =
generateLength(bodyBudget);
if (numStmts < 1) {
numStmts = 1;
AbstractFuzzer[] fuzzers = new AbstractFuzzer[numStmts];
Arrays.fill(
fuzzers,
new SourceElementFuzzer(context));
Node[] components = distribute(paramBodyBudget, fuzzers);
Node body = new Node(Token.BLOCK);
for (int i = 0; i < numStmts; i++) {
body.addChildToBack(components[i]);
scopeManager.removeScope();
return new Node(Token.FUNCTION,
name, params, body);
private IdentifierFuzzer getIdFuzzer() {
if (idFuzzer == null) {
idFuzzer = new IdentifierFuzzer(context);
return idFuzzer;
private class ParamListFuzzer extends AbstractFuzzer {
ParamListFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 1;
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(Token.PARAM_LIST);
for (int i = 0; i < budget - 1; i++) {
node.addChildToBack(getIdFuzzer().generate(1));
return node;
protected String getConfigName() {
return null;
protected String getConfigName() {
return "function";
package com.google.javascript.jscomp.fuzzing;
import com.google.gson.JsonObject;
import java.util.Random;
class FuzzingContext {
Random random;
ScopeManager scopeManager;
JsonObject config;
boolean strict;
StringNumberGenerator snGenerator;
FuzzingContext(Random random, JsonObject config, boolean strict) {
this.random = random;
this.scopeManager = new ScopeManager(random);
this.snGenerator = new StringNumberGenerator(random);
this.config = config;
this.strict = strict;
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class GetElemFuzzer extends AbstractFuzzer {
GetElemFuzzer(FuzzingContext context) {
super(context);
private ExpressionFuzzer exprFuzzer;
protected Node generate(int budget, Set<Type> types) {
AbstractFuzzer[] fuzzers = {getExprFuzzer(), getExprFuzzer()};
Node[] components = distribute(budget - 1, fuzzers);
return new Node(Token.GETELEM, components[0], components[1]);
private ExpressionFuzzer getExprFuzzer() {
if (exprFuzzer == null) {
exprFuzzer =
new ExpressionFuzzer(context);
return exprFuzzer;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getExprFuzzer().isEnough((budget - 1) / 2);
protected String getConfigName() {
return "getElem";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class GetPropFuzzer extends AbstractFuzzer {
GetPropFuzzer(FuzzingContext context) {
super(context);
private ExpressionFuzzer exprFuzzer;
protected Node generate(int budget, Set<Type> types) {
Node left = getExprFuzzer().generate(budget - 2);
Node right = Node.newString(context.snGenerator.getPropertyName());
return new Node(Token.GETPROP, left, right);
private ExpressionFuzzer getExprFuzzer() {
if (exprFuzzer == null) {
exprFuzzer =
new ExpressionFuzzer(context);
return exprFuzzer;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getExprFuzzer().isEnough(budget - 2);
protected String getConfigName() {
return "getProp";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class IdentifierFuzzer extends AbstractFuzzer {
IdentifierFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
String name = null;
ScopeManager scopeManager = context.scopeManager;
if (scopeManager.hasNonLocals() &&
context.random.nextDouble() <
getOwnConfig().get("shadow").getAsDouble()) {
Symbol symbol = scopeManager.getRandomSymbol(
ScopeManager.EXCLUDE_EXTERNS | ScopeManager.EXCLUDE_LOCALS);
if (symbol != null) {
name = symbol.name;
if (name == null){
name = "x_" + context.snGenerator.getNextNumber();
scopeManager.addSymbol(new Symbol(name));
return Node.newString(Token.NAME, name);
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "identifier";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class IfFuzzer extends AbstractFuzzer {
IfFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
int numComponents;
if (budget <= 3) {
numComponents = 2;
numComponents = context.random.nextDouble() <
getOwnConfig().get("hasElse").getAsDouble() ? 3 : 2;
AbstractFuzzer[] fuzzers = new AbstractFuzzer[numComponents];
BlockFuzzer blockFuzzer =
new BlockFuzzer(context);
Arrays.fill(fuzzers, blockFuzzer);
fuzzers[0] =
new ExpressionFuzzer(context);
Node[] components = distribute(budget - 1, fuzzers);
return new Node(Token.IF, components);
protected String getConfigName() {
return "if";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.ArrayList;
import java.util.Set;
public class LabelFuzzer extends AbstractFuzzer {
LabelFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
String labelName = "x_" + context.snGenerator.getNextNumber();
Node name = Node.newString(
Token.LABEL_NAME, labelName);
StatementFuzzer stmtFuzzer =
new StatementFuzzer(context);
AbstractFuzzer selectedFuzzer = stmtFuzzer.selectFuzzer(budget - 2, types);
Scope localScope = context.scopeManager.localScope();
ArrayList<String> currentLabels;
if (selectedFuzzer instanceof ForFuzzer ||
selectedFuzzer instanceof ForInFuzzer ||
selectedFuzzer instanceof WhileFuzzer ||
selectedFuzzer instanceof DoWhileFuzzer) {
currentLabels = localScope.loopLabels;
currentLabels = localScope.otherLabels;
currentLabels.add(labelName);
Node node =
new Node(Token.LABEL, name, selectedFuzzer.generate(budget - 2));
currentLabels.remove(labelName);
return node;
protected String getConfigName() {
return "label";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class LiteralFuzzer extends Dispatcher {
LiteralFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[]{
new SimpleFuzzer(Token.NULL, "null", Type.OBJECT),
new GlobalValueFuzzer("undefined", Type.UNDEFINED),
new GlobalValueFuzzer("Infinity", Type.NUMBER),
new GlobalValueFuzzer("NaN", Type.NUMBER),
new BooleanFuzzer(context),
new NumericFuzzer(context),
new StringFuzzer(context),
new ArrayFuzzer(context),
new RegularExprFuzzer(context),
new ObjectFuzzer(context),
protected String getConfigName() {
return "literal";
private static class GlobalValueFuzzer extends AbstractFuzzer {
private String value;
private Type type;
GlobalValueFuzzer(String value, Type type) {
super(null);
this.value = value;
this.type = type;
protected boolean isEnough(int budget) {
return budget >= 1;
protected Node generate(int budget, Set<Type> types) {
return Node.newString(Token.NAME, value);
protected String getConfigName() {
return value;
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(type);
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import java.util.Set;
class NumericFuzzer extends AbstractFuzzer {
NumericFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
return Node.newNumber(context.random.nextInt(getOwnConfig().get("max").getAsInt()));
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "numeric";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.NUMBER);
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class ObjectFuzzer extends AbstractFuzzer {
ObjectFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
Node objectLit = new Node(Token.OBJECTLIT);
int remainingBudget = budget - 1;
if (remainingBudget < 0) {
remainingBudget = 0;
int objectLength = generateLength(remainingBudget / 2);
if (objectLength == 0) {
return objectLit;
remainingBudget -= objectLength;
ExpressionFuzzer[] fuzzers = new ExpressionFuzzer[objectLength];
Arrays.fill(fuzzers,
new ExpressionFuzzer(context));
Node[] values = distribute(remainingBudget, fuzzers);
for (int i = 0; i < objectLength; i++) {
String name;
if (context.random.nextInt(2) == 0) {
name = context.snGenerator.getPropertyName();
name = String.valueOf(context.snGenerator.getRandomNumber());
Node key = Node.newString(Token.STRING_KEY, name);
key.addChildrenToFront(values[i]);
objectLit.addChildToBack(key);
return objectLit;
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "object";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.OBJECT);
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class RegularExprFuzzer extends AbstractFuzzer {
RegularExprFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
if (budget < 3) {
Node[] children = {Node.newString(context.snGenerator.getString())};
Node node = new Node(Token.REGEXP, children);
return node;
Node[] children =
Node node = new Node(Token.REGEXP, children);
return node;
protected boolean isEnough(int budget) {
return budget >= 2;
protected String getConfigName() {
return "regularExpr";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.OBJECT);
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class ReturnFuzzer extends AbstractFuzzer {
ReturnFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
if (context.scopeManager.isInFunction()) {
return budget >= 1;
return false;
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(Token.RETURN);
if (budget > 1 &&
context.random.nextDouble() < getOwnConfig().get("hasValue").getAsDouble()) {
node.addChildToBack(
new ExpressionFuzzer(context).
generate(budget - 1));
return node;
protected String getConfigName() {
return "return";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.Random;
class Scope {
ArrayList<Symbol> symbols = new ArrayList<>();
int loopNesting = 0;
int switchNesting = 0;
ArrayList<String> loopLabels = new ArrayList<>();
ArrayList<String> otherLabels = new ArrayList<>();
String randomLabelForContinue(Random random) {
Preconditions.checkState(!loopLabels.isEmpty());
return loopLabels.get(random.nextInt(loopLabels.size()));
String randomLabelForBreak(Random random) {
Preconditions.checkState(loopLabels.size() + otherLabels.size() > 0);
int rand = random.nextInt(loopLabels.size() + otherLabels.size());
if (rand < loopLabels.size()) {
return loopLabels.get(rand);
return otherLabels.get(rand - loopLabels.size());
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
class ScopeManager {
private ArrayDeque<Scope> scopeStack = new ArrayDeque<>();
private Random random;
private int numSym;
static final int EXCLUDE_LOCALS = 1;
static final int EXCLUDE_EXTERNS = 1 << 1;
public ScopeManager(Random random) {
this.random = random;
Scope externs = new Scope();
externs.symbols = Lists.newArrayList(
new Symbol("Array", Type.FUNCTION),
new Symbol("Boolean", Type.FUNCTION),
new Symbol("Function", Type.FUNCTION),
new Symbol("Object", Type.FUNCTION),
new Symbol("String", Type.FUNCTION),
new Symbol("Error", Type.FUNCTION),
new Symbol("JSON", Type.OBJECT),
new Symbol("Math", Type.OBJECT),
new Symbol("Number", Type.FUNCTION),
new Symbol("isFinite", Type.FUNCTION),
new Symbol("parseFloat", Type.FUNCTION),
new Symbol("parseInt", Type.FUNCTION),
new Symbol("decodeURI", Type.FUNCTION),
new Symbol("decodeURIComponent", Type.FUNCTION),
new Symbol("encodeURI", Type.FUNCTION),
new Symbol("encodeURIComponent", Type.FUNCTION),
new Symbol("isNaN", Type.FUNCTION));
scopeStack.push(externs);
scopeStack.push(new Scope());
numSym = 0;
public void addScope() {
Scope newScope = new Scope();
newScope.symbols = Lists.newArrayList(new Symbol("arguments", Type.ARRAY));
numSym++;
scopeStack.push(newScope);
public void removeScope() {
numSym -= localSymbols().size();
scopeStack.pop();
public void addSymbol(Symbol symbol) {
localSymbols().add(symbol);
numSym++;
public void removeSymbol(String symbolName) {
Symbol symbol = searchLocalFor(symbolName);
if (symbol != null && localSymbols().remove(symbol)) {
numSym--;
private Symbol searchLocalFor(String symbolName) {
Symbol symbol = null;
for (Symbol s : localSymbols()) {
if (s.name.equals(symbolName)) {
symbol = s;
break;
return symbol;
private ArrayList<Symbol> localSymbols() {
return scopeStack.peek().symbols;
public Scope localScope() {
return scopeStack.peek();
public int getSize() {
return numSym;
public boolean isInFunction() {
return scopeStack.size() > 2;
public boolean hasNonLocals() {
return numSym - localSymbols().size() > 0;
public Symbol getRandomSymbol(int flags) {
return getRandomSymbol(null, flags);
public Symbol getRandomSymbol(Type type, int flags) {
int minScopes = 1;
boolean excludeLocals = (flags & EXCLUDE_LOCALS) != 0;
if (excludeLocals) {
minScopes++;
boolean excludeExterns = (flags & EXCLUDE_EXTERNS) != 0;
if (excludeExterns) {
minScopes++;
Preconditions.checkArgument(scopeStack.size() >= minScopes);
List<Symbol> symbols = new ArrayList<>();
ArrayList<Scope> scopes = new ArrayList<>(scopeStack);
int start = excludeLocals ? 1 : 0;
int end = excludeExterns ? scopes.size() - 1 : scopes.size();
for (int i = start; i < end; i++) {
Scope scope = scopes.get(i);
for (Symbol s : scope.symbols) {
if (type == null || s.type == type) {
symbols.add(s);
int numCandidates = symbols.size();
if (numCandidates == 0) {
return null;
Symbol sym = symbols.get(random.nextInt(numCandidates));
if (excludeLocals && searchLocalFor(sym.name) != null) {
return null;
return sym;
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
public class ScriptFuzzer extends AbstractFuzzer {
ScriptFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 1;
public Node generate(int budget, Set<Type> types) {
int numElements = generateLength(budget - 1);
Node script;
if (numElements > 0) {
SourceElementFuzzer[] fuzzers = new SourceElementFuzzer[numElements];
Arrays.fill(
fuzzers,
new SourceElementFuzzer(context));
Node[] elements = distribute(budget - 1, fuzzers);
script = new Node(Token.SCRIPT, elements);
script = new Node(Token.SCRIPT);
InputId inputId = new InputId("fuzzedInput");
script.setInputId(inputId);
script.setSourceFileForTesting(inputId.getIdName());
return script;
protected String getConfigName() {
return "script";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import java.util.Set;
class SimpleFuzzer extends AbstractFuzzer {
private int nodeType;
private String configName;
private Type dataType;
SimpleFuzzer(int nodeType, String configName, Type dataType) {
super(null);
this.nodeType = nodeType;
this.configName = configName;
this.dataType = dataType;
protected Node generate(int budget, Set<Type> types) {
return new Node(nodeType);
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return configName;
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(dataType);
package com.google.javascript.jscomp.fuzzing;
public class SourceElementFuzzer extends Dispatcher {
SourceElementFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[] {
new StatementFuzzer(context),
new FunctionFuzzer(context, false)
protected String getConfigName() {
return "sourceElement";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Token;
class StatementFuzzer extends Dispatcher {
StatementFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
candidates = new AbstractFuzzer[] {
new BlockFuzzer(context),
new VarFuzzer(context),
new SimpleFuzzer(Token.EMPTY, "empty", Type.UNDEFINED),
new ExprStmtFuzzer(context),
new IfFuzzer(context),
new WhileFuzzer(context),
new DoWhileFuzzer(context),
new ForFuzzer(context),
new ForInFuzzer(context),
new ContinueFuzzer(context),
new BreakFuzzer(context),
new ReturnFuzzer(context),
new SwitchFuzzer(context),
new LabelFuzzer(context),
new ThrowFuzzer(context),
new TryFuzzer(context)
protected String getConfigName() {
return "statement";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import java.util.Set;
class StringFuzzer extends AbstractFuzzer {
StringFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget, Set<Type> types) {
return Node.newString(context.snGenerator.getString());
protected boolean isEnough(int budget) {
return budget >= 1;
protected String getConfigName() {
return "string";
protected Set<Type> supportedTypes() {
return Sets.immutableEnumSet(Type.STRING);
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.Joiner;
import java.util.Random;
public class StringNumberGenerator {
private static final int LARGEST_NUMBER = 1000;
private Random random;
private int counter = 0;
private static final String[] ADJECTIVES = {
"Amazing",
"Breezy",
"Cheerful",
"Dapper",
"Edgy",
"Feisty",
"Gutsy",
"Hardy",
"Intrepid",
"Jaunty",
"Karmic",
"Lucid",
"Maverick",
"Natty",
"Oneiric",
"Precise",
"Quantal",
"Raring",
"Saucy",
"Tranquil",
"Ubiquitous",
"Vigilant",
"Wild",
"Xenial",
"Yelping",
"Zealous"
private static final String[] ANIMALS = {
"Ape",
"Badger",
"Chipmunk",
"Drake",
"Eft",
"Fawn",
"Gibbon",
"Heron",
"Ibex",
"Jackalope",
"Koala",
"Lynx",
"Meerkat",
"Narwhal",
"Ocelot",
"Pangolin",
"Quetzal",
"Ringtail",
"Salamander",
"Turtle",
"Unicorn",
"Vixen",
"Wolf",
"Xerus",
"Yeti",
"Zebra"
public StringNumberGenerator(Random random) {
this.random = random;
public String getString() {
Joiner joiner = Joiner.on(' ');
return joiner.join(getCombination());
public String getPropertyName() {
Joiner joiner = Joiner.on("");
String[] combination = getCombination();
return joiner.join(combination[0].toLowerCase(), combination[1]);
public int getNextNumber() {
return counter++;
public int getRandomNumber() {
return random.nextInt(LARGEST_NUMBER);
private String[] getCombination() {
String[] result = new String[2];
result[0] = ADJECTIVES[random.nextInt(ADJECTIVES.length)];
result[1] = ANIMALS[random.nextInt(ANIMALS.length)];
return result;
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class SwitchFuzzer extends AbstractFuzzer {
SwitchFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 2;
protected Node generate(int budget, Set<Type> types) {
int numCases = budget > 2 ? context.random.nextInt(budget - 2) : 0;
AbstractFuzzer[] fuzzers = new AbstractFuzzer[numCases + 1];
CaseFuzzer caseFuzzer =
new CaseFuzzer(context, Token.CASE);
Arrays.fill(fuzzers, caseFuzzer);
fuzzers[0] =
new ExpressionFuzzer(context);
if (numCases > 0) {
int defaultClauseIndex = context.random.nextInt(numCases);
fuzzers[defaultClauseIndex + 1] =
new CaseFuzzer(context, Token.DEFAULT_CASE);
Scope localScope = context.scopeManager.localScope();
localScope.switchNesting++;
Node[] components = distribute(budget - 1, fuzzers);
localScope.switchNesting--;
return new Node(Token.SWITCH, components);
private static class CaseFuzzer extends AbstractFuzzer {
private int nodeType;
CaseFuzzer(FuzzingContext context, int nodeType) {
super(context);
this.nodeType = nodeType;
protected boolean isEnough(int budget) {
if (nodeType == Token.CASE) {
return budget >= 3;
return budget >= 2;
protected Node generate(int budget, Set<Type> types) {
Node clause = new Node(nodeType);
if (nodeType == Token.CASE) {
int valueBudget =
(int) (budget * getOwnConfig().get("valueBudget").getAsDouble());
if (valueBudget == 0) {
valueBudget = 1;
clause.addChildToBack(
new ExpressionFuzzer(context).
generate(valueBudget));
budget -= valueBudget;
Node block = new BlockFuzzer(context).
generate(budget + 1);
block.setIsSyntheticBlock(true);
clause.addChildrenToBack(block);
return clause;
protected String getConfigName() {
return "case";
protected String getConfigName() {
return "switch";
package com.google.javascript.jscomp.fuzzing;
class Symbol {
String name;
Type type;
Symbol(String name, Type type) {
this.name = name;
this.type = type;
Symbol(String name) {
this(name, null);
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class TernaryExprFuzzer extends AbstractFuzzer {
TernaryExprFuzzer(FuzzingContext context) {
super(context);
private ExpressionFuzzer exprFuzzer;
protected Node generate(int budget, Set<Type> types) {
AbstractFuzzer[] fuzzers = new AbstractFuzzer[3];
Arrays.fill(fuzzers, getExprFuzzer());
Node[] components = distribute(budget - 1, fuzzers);
return new Node(Token.HOOK, components);
private ExpressionFuzzer getExprFuzzer() {
if (exprFuzzer == null) {
exprFuzzer =
new ExpressionFuzzer(context);
return exprFuzzer;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getExprFuzzer().isEnough((budget - 1) / 3);
protected String getConfigName() {
return "ternaryExpr";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
public class ThrowFuzzer extends AbstractFuzzer {
ThrowFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 2;
protected Node generate(int budget, Set<Type> types) {
return new Node(
Token.THROW,
new ExpressionFuzzer(context).
generate(budget - 1));
protected String getConfigName() {
return "throw";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Arrays;
import java.util.Set;
class TryFuzzer extends AbstractFuzzer {
TryFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
AbstractFuzzer[] fuzzers = {
new BlockFuzzer(context),
new CatchFuzzer(context),
new FinallyFuzzer(context)
Node[] components = distribute(budget - 1, fuzzers);
if (components[2] == null) {
if (!components[1].hasChildren()) {
components[2] = new Node(Token.BLOCK);
components = Arrays.copyOf(components, 2);
return new Node(Token.TRY, components);
private static class CatchFuzzer extends AbstractFuzzer {
CatchFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
Node catchBlock = new Node(Token.BLOCK);
if (isEnough(budget)) {
Node param =
new IdentifierFuzzer(context).
generate(1);
catchBlock.addChildToBack(
new Node(Token.CATCH, param,
new BlockFuzzer(context).generate(budget - 1)));
context.scopeManager.removeSymbol(param.getQualifiedName());
return catchBlock;
protected String getConfigName() {
return null;
private static class FinallyFuzzer extends BlockFuzzer {
FinallyFuzzer(FuzzingContext context) {
super(context);
protected Node generate(int budget) {
if (isEnough(budget)) {
return super.generate(budget);
return null;
protected String getConfigName() {
return "try";
package com.google.javascript.jscomp.fuzzing;
enum Type {
FUNCTION,
NUMBER,
OBJECT,
ARRAY,
STRING,
BOOLEAN,
UNDEFINED
package com.google.javascript.jscomp.fuzzing;
import com.google.common.base.CaseFormat;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
class UnaryExprFuzzer extends Dispatcher {
UnaryExprFuzzer(FuzzingContext context) {
super(context);
protected void initCandidates() {
Operator[] operators = Operator.values();
candidates = new UnaryExprGenerator[operators.length];
for (int i = 0; i < operators.length; i++) {
candidates[i] = new UnaryExprGenerator(context, operators[i]);
private static class UnaryExprGenerator extends AbstractFuzzer {
Operator operator;
private AbstractFuzzer target;
UnaryExprGenerator(FuzzingContext context,
Operator operator) {
super(context);
this.operator = operator;
private AbstractFuzzer getTarget() {
if (target == null) {
if (operator.hasSideEffect) {
target = new AssignableExprFuzzer(context);
target = new ExpressionFuzzer(context);
return target;
protected Node generate(int budget, Set<Type> types) {
Node node = new Node(operator.nodeType, getTarget().generate(budget - 1));
if (operator == Operator.POST_INC || operator == Operator.POST_DEC) {
node.putBooleanProp(Node.INCRDECR_PROP, true);
return node;
protected boolean isEnough(int budget) {
if (budget < 1) {
return false;
return getTarget().isEnough(budget - 1);
protected String getConfigName() {
return CaseFormat.UPPER_UNDERSCORE.to(
CaseFormat.LOWER_CAMEL, operator.name());
protected Set<Type> supportedTypes() {
return operator.supportedTypes;
private enum Operator {
VOID(Token.VOID, false, Sets.newHashSet(Type.UNDEFINED)),
TYPEOF(Token.TYPEOF, false, Sets.newHashSet(Type.STRING)),
POS(Token.POS, false, Sets.newHashSet(Type.NUMBER)),
NEG(Token.NEG, false, Sets.newHashSet(Type.NUMBER)),
BIT_NOT(Token.BITNOT, false, Sets.newHashSet(Type.NUMBER)),
NOT(Token.NOT, false, Sets.newHashSet(Type.BOOLEAN)),
INC(Token.INC, true, Sets.newHashSet(Type.NUMBER)),
DEC(Token.DEC, true, Sets.newHashSet(Type.NUMBER)),
DEL_PROP(Token.DELPROP, true, Sets.newHashSet(Type.BOOLEAN)),
POST_INC(Token.INC, true, Sets.newHashSet(Type.NUMBER)),
POST_DEC(Token.DEC, true, Sets.newHashSet(Type.NUMBER));
int nodeType;
boolean hasSideEffect;
Set<Type> supportedTypes;
Operator(int nodeType, boolean hasSideEffect, Set<Type> supportedTypes) {
this.nodeType = nodeType;
this.hasSideEffect = hasSideEffect;
this.supportedTypes = supportedTypes;
protected String getConfigName() {
return "unaryExpr";
package com.google.javascript.jscomp.fuzzing;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Set;
public class VarFuzzer extends AbstractFuzzer {
VarFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 1;
protected Node generate(int budget, Set<Type> types) {
Node identifier =
new IdentifierFuzzer(context).generate(1);
Node node = new Node(Token.VAR, identifier);
ExpressionFuzzer exprFuzzer =
new ExpressionFuzzer(context);
if (exprFuzzer.isEnough(budget - 2)) {
Node assn = exprFuzzer.generate(budget - 2);
identifier.addChildToBack(assn);
return node;
protected String getConfigName() {
return "var";
package com.google.javascript.jscomp.fuzzing;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.EnumSet;
import java.util.Set;
class WhileFuzzer extends AbstractFuzzer {
WhileFuzzer(FuzzingContext context) {
super(context);
protected boolean isEnough(int budget) {
return budget >= 3;
protected Node generate(int budget, Set<Type> types) {
AbstractFuzzer[] fuzzers = {
new ExpressionFuzzer(context),
new BlockFuzzer(context)
Scope scope = context.scopeManager.localScope();
scope.loopNesting++;
Node[] components = distribute(budget - 1, fuzzers);
scope.loopNesting--;
return new Node(Token.WHILE, components);
protected String getConfigName() {
return "while";
protected Node fuzz(AbstractFuzzer fuzzer, int budget) {
if (fuzzer instanceof ExpressionFuzzer) {
Set<Type> types = Sets.immutableEnumSet(
Sets.difference(fuzzer.supportedTypes(), EnumSet.of(Type.UNDEFINED)));
return fuzzer.generate(budget, types);
return fuzzer.generate(budget);
import java.util.HashMap;
HashMap<String, JSType> tmpTypeMap = new HashMap<>();
for (String typeParam : f.typeParameters) {
tmpTypeMap.put(typeParam, JSType.UNKNOWN);
return f.instantiateGenerics(tmpTypeMap);
for (String typeParam : typeMap.keySet()) {
Preconditions.checkState(typeParameters.contains(typeParam));
for (Map.Entry<String, JSType> newTypeEntry : newTypeMap.entrySet()) {
String newKey = newTypeEntry.getKey();
if (rawType.typeParameters.contains(newKey)) {
builder.put(newKey, newTypeEntry.getValue());
private static final EnumSet<TokenType> arraySubPatternFollowSet =
EnumSet.of(TokenType.COMMA, TokenType.CLOSE_SQUARE, TokenType.EQUAL);
if (peekParenPattern(kind, arraySubPatternFollowSet)) {
return new SuggestedFix.Builder().delete(error.node).build();
return new SuggestedFix.Builder().rename(error.node, suggestedPropName).build();
return new SuggestedFix.Builder().removeCast(error.node, compiler).build();
public Builder addExterns(List<SourceFile> externs) {
public Builder addExternsFromFile(List<String> externs) {
this.externs.addAll(Lists.transform(externs, TO_SOURCE_FILE_FN));
public Builder addInputs(List<SourceFile> inputs) {
public Builder addInputsFromFile(List<String> inputs) {
this.inputs.addAll(Lists.transform(inputs, TO_SOURCE_FILE_FN));
private SuggestedFix(SetMultimap<String, CodeReplacement> replacements) {
return new SuggestedFix(replacements.build());
package com.google.javascript.jscomp;
public class AliasKeywordsTest extends CompilerTestCase {
private static final int ENOUGH_TO_ALIAS_LITERAL
= AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
private static final int TOO_FEW_TO_ALIAS_LITERAL
= ENOUGH_TO_ALIAS_LITERAL - 1;
private static final int ENOUGH_TO_ALIAS_THROW
= AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;
private static final int TOO_FEW_TO_ALIAS_THROW
= ENOUGH_TO_ALIAS_THROW - 1;
public void setUp() {
super.enableLineNumberCheck(false);
super.enableNormalize();
public CompilerPass getProcessor(Compiler compiler) {
return new AliasKeywords(compiler);
protected int getNumRepetitions() {
return 1;
private static String generateCode(
String keyword, int numReps, String prepend) {
StringBuilder sb = new StringBuilder(prepend);
for (int i = 0; i < numReps; i++) {
sb.append("if (");
sb.append(keyword);
sb.append(");");
return sb.toString();
private static String generateCode(String keyword, int numReps) {
return generateCode(keyword, numReps, "");
private static String generatePreProcessThrowCode(int repetitions,
String whatToThrow) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < repetitions; i++) {
sb.append("throw ");
sb.append(whatToThrow);
sb.append(";");
return sb.toString();
private static String generatePostProcessThrowCode(
int repetitions, String code, String whatToThrow) {
StringBuilder sb = new StringBuilder();
sb.append("function ");
sb.append(AliasKeywords.ALIAS_THROW);
sb.append("(jscomp_throw_param){throw jscomp_throw_param;}");
sb.append(code);
for (int i = 0; i < repetitions; i++) {
sb.append(AliasKeywords.ALIAS_THROW);
sb.append("(");
sb.append(whatToThrow);
sb.append(");");
return sb.toString();
public void testDontAlias() {
testSame(generateCode("true", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("false", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("null", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("void 0", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generatePreProcessThrowCode(TOO_FEW_TO_ALIAS_THROW, "1"));
testSame(generateCode("void 1", ENOUGH_TO_ALIAS_LITERAL));
testSame(generateCode("void x", ENOUGH_TO_ALIAS_LITERAL));
testSame(generateCode("void f()", ENOUGH_TO_ALIAS_LITERAL));
public void testAlias() {
test(generateCode("true", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_TRUE=true;"));
test(generateCode("false", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_FALSE=false;"));
test(generateCode("null", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_NULL=null;"));
test(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_VOID=void 0;"));
test(generatePreProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "1"),
generatePostProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "", "1"));
public void testAliasTrueFalseNull() {
StringBuilder actual = new StringBuilder();
actual.append(generateCode("true", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("false", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("null", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL));
StringBuilder expected = new StringBuilder();
expected.append(
"var JSCompiler_alias_VOID=void 0;" +
"var JSCompiler_alias_TRUE=true;" +
"var JSCompiler_alias_NULL=null;" +
"var JSCompiler_alias_FALSE=false;");
expected.append(
generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL));
test(actual.toString(), expected.toString());
public void testAliasThrowKeywordLiteral() {
int repetitions = Math.max(ENOUGH_TO_ALIAS_THROW, ENOUGH_TO_ALIAS_LITERAL);
String afterCode = generatePostProcessThrowCode(
repetitions, "var JSCompiler_alias_TRUE=true;",
AliasKeywords.ALIAS_TRUE);
test(generatePreProcessThrowCode(repetitions, "true"), afterCode);
public void testExistingAliasDefinitionFails() {
try {
testSame("var JSCompiler_alias_TRUE='foo';");
fail();
assertTrue(expected.getMessage().contains("Existing alias definition"));
public void testWithNoInputs() {
testSame(new String[] {});
"  var i = $jscomp$key$i.value;",
public void testAliasKeywords() {
CompilerOptions options = createCompilerOptions();
String code =
"function f() { return true + true + true + true + true + true; }";
String expected = "var JSCompiler_alias_TRUE = true;" +
"function f() { return JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE; }";
testSame(options, code);
options.aliasKeywords = true;
test(options, code, expected);
options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES,
options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES,
" *  @suppress{checkProvides} */\n" +
package com.google.javascript.jscomp.fuzzing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.spy;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import junit.framework.TestCase;
import java.util.Map.Entry;
import java.util.Random;
public class FuzzerTest extends TestCase{
private FuzzingContext context;
public void setUp() {
Random random = new Random(123);
JsonObject config = TestConfig.getConfig();
context = new FuzzingContext(random, config, true);
public void testGenerateArray() {
ArrayFuzzer fuzzer =
new ArrayFuzzer(context);
int budget = 10;
Node node = fuzzer.generate(budget);
String code = ArrayFuzzer.getPrettyCode(node);
assertTrue(code.startsWith("["));
assertTrue(code.endsWith("]"));
JsonObject config = fuzzer.getOwnConfig();
assertTrue(
"\nGenerated code: \n" + code,
code.split(",").length
< (int) (config.get("maxLength").getAsDouble()
public void testGenerateNull() {
SimpleFuzzer fuzzer = new SimpleFuzzer(Token.NULL, "null", Type.OBJECT);
Node node = fuzzer.generate(30);
assertEquals("null", SimpleFuzzer.getPrettyCode(node));
public void testGenerateBoolean() {
BooleanFuzzer fuzzer = new BooleanFuzzer(context);
Node node = fuzzer.generate(10);
String code = BooleanFuzzer.getPrettyCode(node).trim();
assertTrue(
"\nGenerated code: \n" + code,
code.equals("true") || code.equals("false"));
public void testGenerateNumeric() {
NumericFuzzer fuzzer = new NumericFuzzer(context);
Node node = fuzzer.generate(10);
String code = NumericFuzzer.getPrettyCode(node);
for (int i = 0; i < code.length(); i++) {
assertTrue("\nGenerated code: \n" + code, code.charAt(i) >= '0');
assertTrue("\nGenerated code: \n" + code, code.charAt(i) <= '9');
public void testGenerateString() {
StringFuzzer fuzzer = new StringFuzzer(context);
Node node = fuzzer.generate(10);
String code = StringFuzzer.getPrettyCode(node);
assertTrue("\nGenerated code: \n" + code, code.startsWith("\""));
assertTrue("\nGenerated code: \n" + code, code.endsWith("\""));
public void testGenerateRegex() {
RegularExprFuzzer fuzzer = new RegularExprFuzzer(context);
Node node = fuzzer.generate(10);
String code = RegularExprFuzzer.getPrettyCode(node);
assertTrue("\nGenerated code: \n" + code, code.startsWith("/"));
assertNotSame('/', code.charAt(1));
public void testGenerateObjectLiteral() {
ObjectFuzzer fuzzer = new ObjectFuzzer(context);
Node node = fuzzer.generate(10);
String code = ObjectFuzzer.getPrettyCode(node);
assertTrue("\nGenerated code: \n" + code, code.startsWith("{"));
assertTrue("\nGenerated code: \n" + code, code.endsWith("}"));
public void testGenerateLiteral() throws JsonParseException {
int budget = 0;
LiteralFuzzer literalFuzzer = new LiteralFuzzer(context);
LiteralFuzzer spyFuzzer = spy(literalFuzzer);
doThrow(new RuntimeException("Not enough budget for literal")).
when(spyFuzzer).generate(budget);
budget = 1;
leaveOneSubtype(literalFuzzer.getOwnConfig(), "null");
Node node = literalFuzzer.generate(budget);
String code = AbstractFuzzer.getPrettyCode(node);
assertEquals("null", code.trim());
public void testPostfixExpressions() throws JsonParseException {
String[] postfixes = {"++", "--"};
String[] types = {"postInc", "postDec"};
for (int i = 0; i < postfixes.length; i++) {
setUp();
UnaryExprFuzzer fuzzer = new UnaryExprFuzzer(context);
leaveOneSubtype(fuzzer.getOwnConfig(), types[i]);
Node node = fuzzer.generate(10);
String code = UnaryExprFuzzer.getPrettyCode(node);
assertTrue(code.endsWith(postfixes[i]));
public void testPrefixExpressions() throws JsonParseException {
String[] prefixes =
String[] types = {"void", "typeof", "pos", "neg", "bitNot", "not", "inc",
"dec", "delProp"};
for (int i = 0; i < prefixes.length; i++) {
setUp();
UnaryExprFuzzer fuzzer = new UnaryExprFuzzer(context);
leaveOneSubtype(fuzzer.getOwnConfig(), types[i]);
Node node = fuzzer.generate(10);
String code = UnaryExprFuzzer.getPrettyCode(node);
assertTrue(code.startsWith(prefixes[i]));
public void testNewExpression() throws JsonParseException {
FunctionCallFuzzer fuzzer =
new FunctionCallFuzzer(context);
leaveOneSubtype(fuzzer.getOwnConfig(), "constructorCall");
Node node = fuzzer.generate(10);
String code = FunctionCallFuzzer.getPrettyCode(node);
assertTrue(code.startsWith("new "));
public void testCallExpression() throws JsonParseException {
FunctionCallFuzzer fuzzer =
new FunctionCallFuzzer(context);
leaveOneSubtype(fuzzer.getOwnConfig(), "normalCall");
Node node = fuzzer.generate(10);
String code = FunctionCallFuzzer.getPrettyCode(node);
assertFalse(code.startsWith("new "));
public void testGenerateBinaryExpression() throws JsonParseException {
int budget = 50;
String[] operators = {"*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", ">",
"<=", ">=", "instanceof", "in", "==", "!=", "===", "!==", "&", "^",
"|", "&&", "||", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=",
">>>=", "&=", "^=", "|="};
String[] types = {"mul", "div", "mod", "add", "sub", "lsh", "rsh", "ursh",
"lt", "gt", "le", "ge", "instanceof", "in", "eq", "ne", "sheq", "shne",
"bitAnd", "bitXor", "bitOr", "and", "or", "assign", "assignMul",
"assignDiv", "assignMod", "assignAdd", "assignSub", "assignLsh",
"assignRsh", "assignUrsh", "assignBitAnd", "assignBitXor",
"assignBitOr"};
for (int i = 0; i < operators.length; i++) {
context =
new FuzzingContext(new Random(123), TestConfig.getConfig(), true);
BinaryExprFuzzer fuzzer =
new BinaryExprFuzzer(context);
leaveOneSubtype(fuzzer.getOwnConfig(), types[i]);
Node node = fuzzer.generate(budget);
String code = BinaryExprFuzzer.getPrettyCode(node).trim();
assertNotSame(-1, code.indexOf(" " + operators[i] + " "));
public void testTrinaryExpression() {
TernaryExprFuzzer fuzzer =
new TernaryExprFuzzer(context);
Node node = fuzzer.generate(4);
String code = TernaryExprFuzzer.getPrettyCode(node);
assertNotSame(-1, code.indexOf(" ? "));
assertTrue(code.indexOf(" : ") > code.indexOf(" ? "));
public void testVariableStatement() {
VarFuzzer fuzzer = new VarFuzzer(context);
Node node = fuzzer.generate(10);
String code = VarFuzzer.getPrettyCode(node);
assertTrue(code.startsWith("var "));
public void testEmptyStatement() {
SimpleFuzzer fuzzer = new SimpleFuzzer(Token.EMPTY, "empty", Type.UNDEFINED);
Node emptyStmt = fuzzer.generate(10);
assertEquals(Token.EMPTY, emptyStmt.getType());
public void testIfStatement() {
IfFuzzer fuzzer = new IfFuzzer(context);
Node ifStatement = fuzzer.generate(10);
String code = IfFuzzer.getPrettyCode(ifStatement);
assertTrue(code.startsWith("if ("));
public void testWhileStatement() {
WhileFuzzer fuzzer =
new WhileFuzzer(context);
Node whileStatement = fuzzer.generate(10);
String code = WhileFuzzer.getPrettyCode(whileStatement);
assertTrue(code.startsWith("while ("));
public void testDoWhileStatement() {
DoWhileFuzzer fuzzer =
new DoWhileFuzzer(context);
Node doStatement = fuzzer.generate(10);
String code = DoWhileFuzzer.getPrettyCode(doStatement);
assertTrue(code.startsWith("do {"));
assertTrue(code.trim().endsWith(");"));
public void testForStatement() {
ForFuzzer fuzzer = new ForFuzzer(context);
Node forStatement = fuzzer.generate(10);
String code = ForFuzzer.getPrettyCode(forStatement);
assertTrue(code.startsWith("for ("));
public void testForInStatement() {
ForInFuzzer fuzzer =
new ForInFuzzer(context);
Node forInStatement = fuzzer.generate(10);
String code = ForInFuzzer.getPrettyCode(forInStatement);
assertTrue("\nGenerated code: \n" + code, code.startsWith("for ("));
assertTrue("\nGenerated code: \n" + code, code.contains(" in "));
public void testSwitchStatement() {
SwitchFuzzer fuzzer =
new SwitchFuzzer(context);
Node switchStmt = fuzzer.generate(20);
String code = SwitchFuzzer.getPrettyCode(switchStmt);
assertTrue("\nGenerated code: \n" + code, code.startsWith("switch("));
public void testThrowStatement() {
ThrowFuzzer fuzzer =
new ThrowFuzzer(context);
Node throwStatement = fuzzer.generate(10);
String code = ThrowFuzzer.getPrettyCode(throwStatement);
assertTrue("\nGenerated code: \n" + code, code.startsWith("throw"));
public void testTryStatement() {
TryFuzzer fuzzer = new TryFuzzer(context);
Node tryStatement = fuzzer.generate(20);
String code = TryFuzzer.getPrettyCode(tryStatement);
assertTrue("\nGenerated code: \n" + code, code.startsWith("try {"));
public void testFunctionDeclaration() {
FunctionFuzzer fuzzer =
new FunctionFuzzer(context, false);
Node functionDecl = fuzzer.generate(20);
String code = FunctionFuzzer.getPrettyCode(functionDecl);
assertTrue("\nGenerated code: \n" + code, code.startsWith("function "));
public void testBreakStatement() throws JsonParseException {
BreakFuzzer fuzzer = new BreakFuzzer(context);
fuzzer.getOwnConfig().addProperty("toLabel", 1);
Scope scope = context.scopeManager.localScope();
scope.otherLabels.add("testLabel");
Node breakStmt = fuzzer.generate(10);
String code = BreakFuzzer.getPrettyCode(breakStmt);
assertEquals("break testLabel;", code.trim());
public void testContinueStatement() throws JsonParseException {
ContinueFuzzer fuzzer = new ContinueFuzzer(context);
fuzzer.getOwnConfig().addProperty("toLabel", 1);
Scope scope = context.scopeManager.localScope();
scope.loopLabels.add("testLabel");
Node continueStmt = fuzzer.generate(10);
String code = ContinueFuzzer.getPrettyCode(continueStmt);
assertEquals("continue testLabel;", code.trim());
public void testDeterministicProgramGenerating() {
ScriptFuzzer fuzzer = new ScriptFuzzer(context);
Node nodes = fuzzer.generate(100);
String code1 = ScriptFuzzer.getPrettyCode(nodes);
setUp();
context =
new FuzzingContext(new Random(123), TestConfig.getConfig(), true);
fuzzer = new ScriptFuzzer(context);
nodes = fuzzer.generate(100);
String code2 = ScriptFuzzer.getPrettyCode(nodes);
assertEquals(code1, code2);
private static void leaveOneSubtype(JsonObject typeConfig, String subtypeName)
throws JsonParseException {
JsonObject weightConfig = typeConfig.get("weights").getAsJsonObject();
for (Entry<String, JsonElement> entry : weightConfig.entrySet()) {
String name = entry.getKey();
if (name.equals(subtypeName)) {
weightConfig.addProperty(name, 1);
weightConfig.addProperty(name, 0);
package com.google.javascript.jscomp.fuzzing;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
class TestConfig {
static JsonObject getConfig() {
try {
String json =
"{\n" +
"  \"script\": {\n" +
"    \"maxLength\": 0.05\n" +
"  },\n" +
"  \"sourceElement\": {\n" +
"    \"weights\": {\n" +
"      \"statement\": 7,\n" +
"      \"function\": 3\n" +
"    }\n" +
"  },\n" +
"  \"function\": {\n" +
"    \"maxParams\": 5,\n" +
"    \"maxLength\": 0.1\n" +
"  },\n" +
"\n" +
"  \"statement\": {\n" +
"    \"weights\": {\n" +
"      \"block\": 1,\n" +
"      \"var\": 1,\n" +
"      \"empty\": 1,\n" +
"      \"exprStmt\": 1,\n" +
"      \"if\": 1,\n" +
"      \"while\": 1,\n" +
"      \"doWhile\": 1,\n" +
"      \"for\": 1,\n" +
"      \"forIn\": 1,\n" +
"      \"continue\": 1,\n" +
"      \"break\": 1,\n" +
"      \"return\": 1,\n" +
"      \"switch\": 1,\n" +
"      \"label\": 1,\n" +
"      \"throw\": 1,\n" +
"      \"try\": 1\n" +
"    }\n" +
"  },\n" +
"  \"block\": {\n" +
"    \"maxLength\": 0.1\n" +
"  },\n" +
"  \"if\": {\n" +
"    \"hasElse\": 0.5\n" +
"  },\n" +
"  \"for\": {\n" +
"    \"headBudget\": 0.3\n" +
"  },\n" +
"  \"forInitializer\": {\n" +
"    \"weights\": {\n" +
"      \"var\": 1,\n" +
"      \"expression\": 1\n" +
"    }\n" +
"  },\n" +
"  \"forInItem\": {\n" +
"    \"weights\": {\n" +
"      \"assignableExpr\": 1,\n" +
"      \"var\": 1\n" +
"    }\n" +
"  },\n" +
"  \"continue\": {\n" +
"    \"toLabel\": 0.5\n" +
"  },\n" +
"  \"break\": {\n" +
"    \"toLabel\": 0.5\n" +
"  },\n" +
"  \"return\": {\n" +
"    \"hasValue\": 0.5\n" +
"  },\n" +
"  \"case\": {\n" +
"    \"valueBudget\": 0.1\n" +
"  },\n" +
"  \"expression\": {\n" +
"    \"weights\": {\n" +
"        \"this\": 1,\n" +
"        \"existingIdentifier\": 1,\n" +
"        \"literal\": 1,\n" +
"        \"functionCall\": 1,\n" +
"        \"unaryExpr\": 1,\n" +
"        \"binaryExpr\": 1,\n" +
"        \"function\": 1,\n" +
"        \"ternaryExpr\": 1\n" +
"    }\n" +
"  },\n" +
"  \"literal\": {\n" +
"    \"weights\": {\n" +
"        \"null\": 1,\n" +
"        \"undefined\": 1,\n" +
"        \"Infinity\": 1,\n" +
"        \"NaN\": 1,\n" +
"        \"boolean\": 1,\n" +
"        \"numeric\": 1,\n" +
"        \"string\": 1,\n" +
"        \"array\": 1,\n" +
"        \"object\": 1,\n" +
"        \"regularExpr\": 1\n" +
"    }\n" +
"  },\n" +
"  \"numeric\": {\n" +
"    \"max\": 1000\n" +
"  },\n" +
"  \"identifier\": {\n" +
"    \"shadow\": 0.1\n" +
"  },\n" +
"  \"object\": {\n" +
"    \"maxLength\": 0.5\n" +
"  },\n" +
"  \"array\": {\n" +
"    \"maxLength\": 1\n" +
"  },\n" +
"  \"assignableExpr\": {\n" +
"    \"weights\": {\n" +
"        \"getProp\": 1,\n" +
"        \"getElem\": 1,\n" +
"        \"existingIdentifier\": 1\n" +
"    }\n" +
"  },\n" +
"  \"functionCall\": {\n" +
"    \"weights\": {\n" +
"        \"constructorCall\": 1,\n" +
"        \"normalCall\": 1\n" +
"    }\n" +
"  },\n" +
"  \"constructorCall\": {\n" +
"    \"argLength\": 1\n" +
"  },\n" +
"  \"normalCall\": {\n" +
"    \"argLength\": 1\n" +
"  },\n" +
"  \"callableExpr\": {\n" +
"    \"weights\": {\n" +
"        \"getProp\": 1,\n" +
"        \"getElem\": 1,\n" +
"        \"existingIdentifier\": 1,\n" +
"        \"function\": 1\n" +
"    }\n" +
"  },\n" +
"  \"unaryExpr\": {\n" +
"    \"weights\": {\n" +
"        \"void\": 1,\n" +
"        \"typeof\": 1,\n" +
"        \"pos\": 1,\n" +
"        \"neg\": 1,\n" +
"        \"bitNot\": 1,\n" +
"        \"not\": 1,\n" +
"        \"inc\": 1,\n" +
"        \"dec\": 1,\n" +
"        \"delProp\": 1,\n" +
"        \"postInc\": 1,\n" +
"        \"postDec\": 1\n" +
"    }\n" +
"  },\n" +
"  \"binaryExpr\": {\n" +
"    \"weights\": {\n" +
"        \"mul\": 1,\n" +
"        \"div\": 1,\n" +
"        \"mod\": 1,\n" +
"        \"add\": 1,\n" +
"        \"sub\": 1,\n" +
"        \"lsh\": 1,\n" +
"        \"rsh\": 1,\n" +
"        \"ursh\": 1,\n" +
"        \"lt\": 1,\n" +
"        \"gt\": 1,\n" +
"        \"le\": 1,\n" +
"        \"ge\": 1,\n" +
"        \"instanceof\": 1,\n" +
"        \"in\": 1,\n" +
"        \"eq\": 1,\n" +
"        \"ne\": 1,\n" +
"        \"sheq\": 1,\n" +
"        \"shne\": 1,\n" +
"        \"bitAnd\": 1,\n" +
"        \"bitXor\": 1,\n" +
"        \"bitOr\": 1,\n" +
"        \"and\": 1,\n" +
"        \"or\": 1,\n" +
"        \"assign\": 1,\n" +
"        \"assignMul\": 1,\n" +
"        \"assignDiv\": 1,\n" +
"        \"assignMod\": 1,\n" +
"        \"assignAdd\": 1,\n" +
"        \"assignSub\": 1,\n" +
"        \"assignLsh\": 1,\n" +
"        \"assignRsh\": 1,\n" +
"        \"assignUrsh\": 1,\n" +
"        \"assignBitAnd\": 1,\n" +
"        \"assignBitXor\": 1,\n" +
"        \"assignBitOr\": 1\n" +
"    }\n" +
"  },\n" +
"  \"program\": {\n" +
"    \"maxLength\": 0.1\n" +
"  }\n" +
"}";
return new Gson().fromJson(json, JsonObject.class);
e.printStackTrace();
return null;package com.google.javascript.jscomp;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.List;
import java.util.Map;
import java.util.Set;
class AliasKeywords implements CompilerPass {
private class FindAliasableNodes extends AbstractPostOrderCallback {
public void visit(NodeTraversal t, Node n, Node parent) {
final int type = n.getType();
if (isAliasableType(type)) {
visitAliasableNode(n, parent);
visitNameNode(n);
private void visitAliasableNode(Node n, Node parent) {
AliasSpecification aliasableNodes = aliasTypes.get(n.getType());
aliasableNodes.visit(n, parent);
private void visitNameNode(Node n) {
if (isAliasDefinition(n)) {
throw new IllegalStateException(
"Existing alias definition for " + Token.name(n.getType()));
private abstract static class AliasSpecification {
private final Map<Node, Node> nodes = Maps.newHashMap();
private boolean isAliased = false;
private String aliasName;
private int tokenId;
public AliasSpecification(String aliasName, int tokenId) {
this.aliasName = aliasName;
this.tokenId = tokenId;
public void visit(Node n, Node parent) {
nodes.put(n, parent);
boolean maybeInsertAliasDeclarationIntoParseTree(Node codeRoot) {
if (nodes.size() >= minOccurrencesRequiredToAlias()) {
insertAliasDeclaration(codeRoot);
isAliased = true;
return true;
return false;
public void doAlias(AbstractCompiler compiler) {
if (isAliased) {
for (Map.Entry<Node, Node> entry : nodes.entrySet()) {
Node n = entry.getKey();
Node parent = entry.getValue();
aliasNode(n, parent);
compiler.reportCodeChange();
public int getTokenId() {
return tokenId;
public String getAliasName() {
return aliasName;
protected abstract int minOccurrencesRequiredToAlias();
protected abstract void insertAliasDeclaration(Node codeRoot);
protected abstract void aliasNode(Node n, Node parent);
private class ThrowAliasSpecification extends AliasSpecification {
ThrowAliasSpecification(String aliasName) {
super(aliasName, Token.THROW);
protected void aliasNode(Node throwNode, Node parent) {
Node name = NodeUtil.newName(
compiler, getAliasName(), throwNode, getAliasName());
Node aliasCall = IR.call(name, throwNode.removeFirstChild());
aliasCall.putBooleanProp(Node.FREE_CALL, true);
Node exprResult = IR.exprResult(aliasCall);
parent.replaceChild(throwNode, exprResult);
protected void insertAliasDeclaration(Node codeRoot) {
codeRoot.addChildToFront(createAliasFunctionNode(getAliasName()));
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;
static int estimateMinOccurrencesRequriedToAlias() {
Node alias = createAliasFunctionNode("TT");
return InlineCostEstimator.getCost(alias) / 2 + 1;
private static Node createAliasFunctionNode(String aliasName) {
final String paramName = "jscomp_throw_param";
return IR.function(
IR.name(aliasName),
IR.paramList(IR.name(paramName)),
IR.block(
IR.throwNode(IR.name(paramName))));
private class KeywordAliasSpecification extends AliasSpecification {
KeywordAliasSpecification(String aliasName, int tokenId) {
super(aliasName, tokenId);
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
protected void aliasNode(Node n, Node parent) {
Node aliasNode = NodeUtil.newName(
compiler, getAliasName(), n, getAliasName());
parent.replaceChild(n, aliasNode);
protected void insertAliasDeclaration(Node codeRoot) {
Node varNode = new Node(Token.VAR);
Node value = new Node(getTokenId());
Node name = NodeUtil.newName(
compiler, getAliasName(), varNode, getAliasName());
name.addChildToBack(value);
varNode.addChildToBack(name);
codeRoot.addChildrenToFront(varNode);
private class VoidKeywordAliasSpecification extends AliasSpecification {
VoidKeywordAliasSpecification(String aliasName, int tokenId) {
super(aliasName, tokenId);
public void visit(Node n, Node parent) {
Node value = n.getFirstChild();
if (value.isNumber() && value.getDouble() == 0) {
super.visit(n, parent);
protected int minOccurrencesRequiredToAlias() {
return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
protected void aliasNode(Node n, Node parent) {
Node aliasNode = NodeUtil.newName(
compiler, getAliasName(), n, getAliasName());
parent.replaceChild(n, aliasNode);
protected void insertAliasDeclaration(Node codeRoot) {
Node varNode = new Node(Token.VAR);
Node value = IR.voidNode(IR.number(0));
Node name = NodeUtil.newName(
compiler, getAliasName(), varNode, getAliasName());
name.addChildToBack(value);
varNode.addChildToBack(name);
codeRoot.addChildrenToFront(varNode);
static final String ALIAS_NULL = "JSCompiler_alias_NULL";
static final String ALIAS_TRUE = "JSCompiler_alias_TRUE";
static final String ALIAS_FALSE = "JSCompiler_alias_FALSE";
static final String ALIAS_THROW = "JSCompiler_alias_THROW";
static final String ALIAS_VOID = "JSCompiler_alias_VOID";
static final int MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL = 6;
static final int MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW =
estimateMinOccurrencesRequriedToAlias();
private final AbstractCompiler compiler;
private final List<AliasSpecification> aliasSpecifications;
private final Map<Integer, AliasSpecification> aliasTypes;
private final Set<String> aliasNames;
AliasKeywords(AbstractCompiler compiler) {
this.compiler = compiler;
aliasSpecifications = createAliasSpecifications();
aliasTypes = Maps.newLinkedHashMap();
aliasNames = Sets.newLinkedHashSet();
for (AliasSpecification specification : aliasSpecifications) {
aliasTypes.put(specification.getTokenId(), specification);
aliasNames.add(specification.getAliasName());
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, new FindAliasableNodes());
if (needsAliases()) {
addAliasNodes(compiler.getNodeForCodeInsertion(null));
for (AliasSpecification spec : aliasSpecifications) {
spec.doAlias(compiler);
private boolean needsAliases() {
for (AliasSpecification spec : aliasSpecifications) {
if (!spec.nodes.isEmpty()) {
return true;
return false;
private void addAliasNodes(Node codeRoot) {
boolean codeChanged = false;
for (AliasSpecification spec : aliasSpecifications) {
if (spec.maybeInsertAliasDeclarationIntoParseTree(codeRoot)) {
codeChanged = true;
if (codeChanged) {
compiler.reportCodeChange();
private boolean isAliasDefinition(Node n) {
if (!n.isName()) {
return false;
if (!isAliasName(n.getString())) {
return false;
return n.getFirstChild() != null;
private boolean isAliasableType(int type) {
return aliasTypes.containsKey(type);
private boolean isAliasName(String name) {
return aliasNames.contains(name);
private List<AliasSpecification> createAliasSpecifications() {
List<AliasSpecification> l = Lists.newArrayList();
l.add(new KeywordAliasSpecification(ALIAS_FALSE, Token.FALSE));
l.add(new KeywordAliasSpecification(ALIAS_NULL, Token.NULL));
l.add(new KeywordAliasSpecification(ALIAS_TRUE, Token.TRUE));
l.add(new VoidKeywordAliasSpecification(ALIAS_VOID, Token.VOID));
l.add(new ThrowAliasSpecification(ALIAS_THROW));
return l;
if (options.aliasKeywords) {
passes.add(aliasKeywords);
final PassFactory aliasKeywords = new PassFactory("aliasKeywords", true) {
protected CompilerPass create(AbstractCompiler compiler) {
return new AliasKeywords(compiler);
package com.google.javascript.jscomp;
public class AliasKeywordsTest extends CompilerTestCase {
private static final int ENOUGH_TO_ALIAS_LITERAL
= AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;
private static final int TOO_FEW_TO_ALIAS_LITERAL
= ENOUGH_TO_ALIAS_LITERAL - 1;
private static final int ENOUGH_TO_ALIAS_THROW
= AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;
private static final int TOO_FEW_TO_ALIAS_THROW
= ENOUGH_TO_ALIAS_THROW - 1;
public void setUp() {
super.enableLineNumberCheck(false);
super.enableNormalize();
public CompilerPass getProcessor(Compiler compiler) {
return new AliasKeywords(compiler);
protected int getNumRepetitions() {
return 1;
private static String generateCode(
String keyword, int numReps, String prepend) {
StringBuilder sb = new StringBuilder(prepend);
for (int i = 0; i < numReps; i++) {
sb.append("if (");
sb.append(keyword);
sb.append(");");
return sb.toString();
private static String generateCode(String keyword, int numReps) {
return generateCode(keyword, numReps, "");
private static String generatePreProcessThrowCode(int repetitions,
String whatToThrow) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < repetitions; i++) {
sb.append("throw ");
sb.append(whatToThrow);
sb.append(";");
return sb.toString();
private static String generatePostProcessThrowCode(
int repetitions, String code, String whatToThrow) {
StringBuilder sb = new StringBuilder();
sb.append("function ");
sb.append(AliasKeywords.ALIAS_THROW);
sb.append("(jscomp_throw_param){throw jscomp_throw_param;}");
sb.append(code);
for (int i = 0; i < repetitions; i++) {
sb.append(AliasKeywords.ALIAS_THROW);
sb.append("(");
sb.append(whatToThrow);
sb.append(");");
return sb.toString();
public void testDontAlias() {
testSame(generateCode("true", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("false", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("null", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generateCode("void 0", TOO_FEW_TO_ALIAS_LITERAL));
testSame(generatePreProcessThrowCode(TOO_FEW_TO_ALIAS_THROW, "1"));
testSame(generateCode("void 1", ENOUGH_TO_ALIAS_LITERAL));
testSame(generateCode("void x", ENOUGH_TO_ALIAS_LITERAL));
testSame(generateCode("void f()", ENOUGH_TO_ALIAS_LITERAL));
public void testAlias() {
test(generateCode("true", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_TRUE=true;"));
test(generateCode("false", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_FALSE=false;"));
test(generateCode("null", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_NULL=null;"));
test(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL),
generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL,
"var JSCompiler_alias_VOID=void 0;"));
test(generatePreProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "1"),
generatePostProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "", "1"));
public void testAliasTrueFalseNull() {
StringBuilder actual = new StringBuilder();
actual.append(generateCode("true", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("false", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("null", ENOUGH_TO_ALIAS_LITERAL));
actual.append(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL));
StringBuilder expected = new StringBuilder();
expected.append(
"var JSCompiler_alias_VOID=void 0;" +
"var JSCompiler_alias_TRUE=true;" +
"var JSCompiler_alias_NULL=null;" +
"var JSCompiler_alias_FALSE=false;");
expected.append(
generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL));
expected.append(
generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL));
test(actual.toString(), expected.toString());
public void testAliasThrowKeywordLiteral() {
int repetitions = Math.max(ENOUGH_TO_ALIAS_THROW, ENOUGH_TO_ALIAS_LITERAL);
String afterCode = generatePostProcessThrowCode(
repetitions, "var JSCompiler_alias_TRUE=true;",
AliasKeywords.ALIAS_TRUE);
test(generatePreProcessThrowCode(repetitions, "true"), afterCode);
public void testExistingAliasDefinitionFails() {
try {
testSame("var JSCompiler_alias_TRUE='foo';");
fail();
assertTrue(expected.getMessage().contains("Existing alias definition"));
public void testWithNoInputs() {
testSame(new String[] {});
public void testAliasKeywords() {
CompilerOptions options = createCompilerOptions();
String code =
"function f() { return true + true + true + true + true + true; }";
String expected = "var JSCompiler_alias_TRUE = true;" +
"function f() { return JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " +
"    JSCompiler_alias_TRUE; }";
testSame(options, code);
options.aliasKeywords = true;
test(options, code, expected);return new SuggestedFix.Builder().delete(error.node).build();
return new SuggestedFix.Builder().rename(error.node, suggestedPropName).build();
return new SuggestedFix.Builder().removeCast(error.node, compiler).build();
public Builder addExterns(List<SourceFile> externs) {
public Builder addExternsFromFile(List<String> externs) {
this.externs.addAll(Lists.transform(externs, TO_SOURCE_FILE_FN));
public Builder addInputs(List<SourceFile> inputs) {
public Builder addInputsFromFile(List<String> inputs) {
this.inputs.addAll(Lists.transform(inputs, TO_SOURCE_FILE_FN));
private SuggestedFix(SetMultimap<String, CodeReplacement> replacements) {
return new SuggestedFix(replacements.build());"equirement\"\357\003\n\013Requirement\022\025\n\rerror_mess" +
"t_regexp\030\003 \003(\t\022\025\n\ronly_apply_to\030\004 \003(\t\022\034\n" +
"\024only_apply_to_regexp\030\005 \003(\t\022&\n\004type\030\006 \001(" +
"\0162\030.jscomp.Requirement.Type\022\r\n\005value\030\007 \003" +
"(\t\022\022\n\njava_class\030\010 \001(\t\022\017\n\007rule_id\030\t \001(\t\022" +
"\017\n\007extends\030\n \001(\t\"\355\001\n\004Type\022\n\n\006CUSTOM\020\001\022\025\n" +
"\021BANNED_DEPENDENCY\020\002\022\017\n\013BANNED_NAME\020\003\022\023\n",
"\017BANNED_PROPERTY\020\004\022\030\n\024BANNED_PROPERTY_RE" +
"AD\020\005\022\031\n\025BANNED_PROPERTY_WRITE\020\006\022\030\n\024RESTR" +
"ICTED_NAME_CALL\020\007\022\032\n\026RESTRICTED_METHOD_C" +
"ALL\020\010\022\027\n\023BANNED_CODE_PATTERN\020\t\022\030\n\024BANNED" +
"_PROPERTY_CALL\020\n*\n\010\300\204=\020\200\200\200\200\002B \n\034com.goog" +
"le.javascript.jscompP\001"
new java.lang.String[] { "ErrorMessage", "Whitelist", "WhitelistRegexp", "OnlyApplyTo", "OnlyApplyToRegexp", "Type", "Value", "JavaClass", "RuleId", "Extends", });
case 34: {
if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
onlyApplyTo_ = new com.google.protobuf.LazyStringArrayList();
mutable_bitField0_ |= 0x00000008;
onlyApplyTo_.add(input.readBytes());
break;
case 42: {
if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
onlyApplyToRegexp_ = new com.google.protobuf.LazyStringArrayList();
mutable_bitField0_ |= 0x00000010;
onlyApplyToRegexp_.add(input.readBytes());
break;
case 48: {
unknownFields.mergeVarintField(6, rawValue);
case 58: {
if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
mutable_bitField0_ |= 0x00000040;
case 66: {
case 74: {
bitField0_ |= 0x00000008;
ruleId_ = input.readBytes();
break;
case 82: {
bitField0_ |= 0x00000010;
extends_ = input.readBytes();
break;
if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
onlyApplyTo_ = new com.google.protobuf.UnmodifiableLazyStringList(onlyApplyTo_);
onlyApplyToRegexp_ = new com.google.protobuf.UnmodifiableLazyStringList(onlyApplyToRegexp_);
if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
public static final int ONLY_APPLY_TO_FIELD_NUMBER = 4;
private com.google.protobuf.LazyStringList onlyApplyTo_;
public java.util.List<java.lang.String>
getOnlyApplyToList() {
return onlyApplyTo_;
public int getOnlyApplyToCount() {
return onlyApplyTo_.size();
public java.lang.String getOnlyApplyTo(int index) {
return onlyApplyTo_.get(index);
public com.google.protobuf.ByteString
getOnlyApplyToBytes(int index) {
return onlyApplyTo_.getByteString(index);
public static final int ONLY_APPLY_TO_REGEXP_FIELD_NUMBER = 5;
private com.google.protobuf.LazyStringList onlyApplyToRegexp_;
public java.util.List<java.lang.String>
getOnlyApplyToRegexpList() {
return onlyApplyToRegexp_;
public int getOnlyApplyToRegexpCount() {
return onlyApplyToRegexp_.size();
public java.lang.String getOnlyApplyToRegexp(int index) {
return onlyApplyToRegexp_.get(index);
public com.google.protobuf.ByteString
getOnlyApplyToRegexpBytes(int index) {
return onlyApplyToRegexp_.getByteString(index);
public static final int TYPE_FIELD_NUMBER = 6;
public static final int VALUE_FIELD_NUMBER = 7;
public static final int JAVA_CLASS_FIELD_NUMBER = 8;
public static final int RULE_ID_FIELD_NUMBER = 9;
private java.lang.Object ruleId_;
public boolean hasRuleId() {
return ((bitField0_ & 0x00000008) == 0x00000008);
public java.lang.String getRuleId() {
java.lang.Object ref = ruleId_;
if (ref instanceof java.lang.String) {
return (java.lang.String) ref;
com.google.protobuf.ByteString bs = 
(com.google.protobuf.ByteString) ref;
java.lang.String s = bs.toStringUtf8();
if (bs.isValidUtf8()) {
ruleId_ = s;
return s;
public com.google.protobuf.ByteString
getRuleIdBytes() {
java.lang.Object ref = ruleId_;
if (ref instanceof java.lang.String) {
com.google.protobuf.ByteString b = 
com.google.protobuf.ByteString.copyFromUtf8(
(java.lang.String) ref);
ruleId_ = b;
return b;
return (com.google.protobuf.ByteString) ref;
public static final int EXTENDS_FIELD_NUMBER = 10;
private java.lang.Object extends_;
public boolean hasExtends() {
return ((bitField0_ & 0x00000010) == 0x00000010);
public java.lang.String getExtends() {
java.lang.Object ref = extends_;
if (ref instanceof java.lang.String) {
return (java.lang.String) ref;
com.google.protobuf.ByteString bs = 
(com.google.protobuf.ByteString) ref;
java.lang.String s = bs.toStringUtf8();
if (bs.isValidUtf8()) {
extends_ = s;
return s;
public com.google.protobuf.ByteString
getExtendsBytes() {
java.lang.Object ref = extends_;
if (ref instanceof java.lang.String) {
com.google.protobuf.ByteString b = 
com.google.protobuf.ByteString.copyFromUtf8(
(java.lang.String) ref);
extends_ = b;
return b;
return (com.google.protobuf.ByteString) ref;
onlyApplyTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
onlyApplyToRegexp_ = com.google.protobuf.LazyStringArrayList.EMPTY;
ruleId_ = "";
extends_ = "";
for (int i = 0; i < onlyApplyTo_.size(); i++) {
output.writeBytes(4, onlyApplyTo_.getByteString(i));
for (int i = 0; i < onlyApplyToRegexp_.size(); i++) {
output.writeBytes(5, onlyApplyToRegexp_.getByteString(i));
output.writeEnum(6, type_.getNumber());
output.writeBytes(7, value_.getByteString(i));
output.writeBytes(8, getJavaClassBytes());
if (((bitField0_ & 0x00000008) == 0x00000008)) {
output.writeBytes(9, getRuleIdBytes());
if (((bitField0_ & 0x00000010) == 0x00000010)) {
output.writeBytes(10, getExtendsBytes());
int dataSize = 0;
for (int i = 0; i < onlyApplyTo_.size(); i++) {
dataSize += com.google.protobuf.CodedOutputStream
.computeBytesSizeNoTag(onlyApplyTo_.getByteString(i));
size += dataSize;
size += 1 * getOnlyApplyToList().size();
int dataSize = 0;
for (int i = 0; i < onlyApplyToRegexp_.size(); i++) {
dataSize += com.google.protobuf.CodedOutputStream
.computeBytesSizeNoTag(onlyApplyToRegexp_.getByteString(i));
size += dataSize;
size += 1 * getOnlyApplyToRegexpList().size();
.computeEnumSize(6, type_.getNumber());
.computeBytesSize(8, getJavaClassBytes());
if (((bitField0_ & 0x00000008) == 0x00000008)) {
size += com.google.protobuf.CodedOutputStream
.computeBytesSize(9, getRuleIdBytes());
if (((bitField0_ & 0x00000010) == 0x00000010)) {
size += com.google.protobuf.CodedOutputStream
.computeBytesSize(10, getExtendsBytes());
onlyApplyTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
onlyApplyToRegexp_ = com.google.protobuf.LazyStringArrayList.EMPTY;
type_ = com.google.javascript.jscomp.Requirement.Type.CUSTOM;
value_ = com.google.protobuf.LazyStringArrayList.EMPTY;
bitField0_ = (bitField0_ & ~0x00000040);
javaClass_ = "";
bitField0_ = (bitField0_ & ~0x00000080);
ruleId_ = "";
bitField0_ = (bitField0_ & ~0x00000100);
extends_ = "";
bitField0_ = (bitField0_ & ~0x00000200);
if (((bitField0_ & 0x00000008) == 0x00000008)) {
onlyApplyTo_ = new com.google.protobuf.UnmodifiableLazyStringList(
onlyApplyTo_);
bitField0_ = (bitField0_ & ~0x00000008);
result.onlyApplyTo_ = onlyApplyTo_;
if (((bitField0_ & 0x00000010) == 0x00000010)) {
onlyApplyToRegexp_ = new com.google.protobuf.UnmodifiableLazyStringList(
onlyApplyToRegexp_);
bitField0_ = (bitField0_ & ~0x00000010);
result.onlyApplyToRegexp_ = onlyApplyToRegexp_;
if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
if (((bitField0_ & 0x00000040) == 0x00000040)) {
bitField0_ = (bitField0_ & ~0x00000040);
if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
to_bitField0_ |= 0x00000008;
result.ruleId_ = ruleId_;
if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
to_bitField0_ |= 0x00000010;
result.extends_ = extends_;
if (!other.onlyApplyTo_.isEmpty()) {
if (onlyApplyTo_.isEmpty()) {
onlyApplyTo_ = other.onlyApplyTo_;
bitField0_ = (bitField0_ & ~0x00000008);
ensureOnlyApplyToIsMutable();
onlyApplyTo_.addAll(other.onlyApplyTo_);
onChanged();
if (!other.onlyApplyToRegexp_.isEmpty()) {
if (onlyApplyToRegexp_.isEmpty()) {
onlyApplyToRegexp_ = other.onlyApplyToRegexp_;
bitField0_ = (bitField0_ & ~0x00000010);
ensureOnlyApplyToRegexpIsMutable();
onlyApplyToRegexp_.addAll(other.onlyApplyToRegexp_);
onChanged();
bitField0_ = (bitField0_ & ~0x00000040);
bitField0_ |= 0x00000080;
if (other.hasRuleId()) {
bitField0_ |= 0x00000100;
ruleId_ = other.ruleId_;
onChanged();
if (other.hasExtends()) {
bitField0_ |= 0x00000200;
extends_ = other.extends_;
onChanged();
private com.google.protobuf.LazyStringList onlyApplyTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
private void ensureOnlyApplyToIsMutable() {
if (!((bitField0_ & 0x00000008) == 0x00000008)) {
onlyApplyTo_ = new com.google.protobuf.LazyStringArrayList(onlyApplyTo_);
bitField0_ |= 0x00000008;
public java.util.List<java.lang.String>
getOnlyApplyToList() {
return java.util.Collections.unmodifiableList(onlyApplyTo_);
public int getOnlyApplyToCount() {
return onlyApplyTo_.size();
public java.lang.String getOnlyApplyTo(int index) {
return onlyApplyTo_.get(index);
public com.google.protobuf.ByteString
getOnlyApplyToBytes(int index) {
return onlyApplyTo_.getByteString(index);
public Builder setOnlyApplyTo(
int index, java.lang.String value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToIsMutable();
onlyApplyTo_.set(index, value);
onChanged();
return this;
public Builder addOnlyApplyTo(
java.lang.String value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToIsMutable();
onlyApplyTo_.add(value);
onChanged();
return this;
public Builder addAllOnlyApplyTo(
java.lang.Iterable<java.lang.String> values) {
ensureOnlyApplyToIsMutable();
super.addAll(values, onlyApplyTo_);
onChanged();
return this;
public Builder clearOnlyApplyTo() {
onlyApplyTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
bitField0_ = (bitField0_ & ~0x00000008);
onChanged();
return this;
public Builder addOnlyApplyToBytes(
com.google.protobuf.ByteString value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToIsMutable();
onlyApplyTo_.add(value);
onChanged();
return this;
private com.google.protobuf.LazyStringList onlyApplyToRegexp_ = com.google.protobuf.LazyStringArrayList.EMPTY;
private void ensureOnlyApplyToRegexpIsMutable() {
if (!((bitField0_ & 0x00000010) == 0x00000010)) {
onlyApplyToRegexp_ = new com.google.protobuf.LazyStringArrayList(onlyApplyToRegexp_);
bitField0_ |= 0x00000010;
public java.util.List<java.lang.String>
getOnlyApplyToRegexpList() {
return java.util.Collections.unmodifiableList(onlyApplyToRegexp_);
public int getOnlyApplyToRegexpCount() {
return onlyApplyToRegexp_.size();
public java.lang.String getOnlyApplyToRegexp(int index) {
return onlyApplyToRegexp_.get(index);
public com.google.protobuf.ByteString
getOnlyApplyToRegexpBytes(int index) {
return onlyApplyToRegexp_.getByteString(index);
public Builder setOnlyApplyToRegexp(
int index, java.lang.String value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToRegexpIsMutable();
onlyApplyToRegexp_.set(index, value);
onChanged();
return this;
public Builder addOnlyApplyToRegexp(
java.lang.String value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToRegexpIsMutable();
onlyApplyToRegexp_.add(value);
onChanged();
return this;
public Builder addAllOnlyApplyToRegexp(
java.lang.Iterable<java.lang.String> values) {
ensureOnlyApplyToRegexpIsMutable();
super.addAll(values, onlyApplyToRegexp_);
onChanged();
return this;
public Builder clearOnlyApplyToRegexp() {
onlyApplyToRegexp_ = com.google.protobuf.LazyStringArrayList.EMPTY;
bitField0_ = (bitField0_ & ~0x00000010);
onChanged();
return this;
public Builder addOnlyApplyToRegexpBytes(
com.google.protobuf.ByteString value) {
if (value == null) {
throw new NullPointerException();
ensureOnlyApplyToRegexpIsMutable();
onlyApplyToRegexp_.add(value);
onChanged();
return this;
return ((bitField0_ & 0x00000020) == 0x00000020);
bitField0_ |= 0x00000020;
bitField0_ = (bitField0_ & ~0x00000020);
if (!((bitField0_ & 0x00000040) == 0x00000040)) {
bitField0_ |= 0x00000040;
bitField0_ = (bitField0_ & ~0x00000040);
return ((bitField0_ & 0x00000080) == 0x00000080);
bitField0_ |= 0x00000080;
bitField0_ = (bitField0_ & ~0x00000080);
bitField0_ |= 0x00000080;
private java.lang.Object ruleId_ = "";
public boolean hasRuleId() {
return ((bitField0_ & 0x00000100) == 0x00000100);
public java.lang.String getRuleId() {
java.lang.Object ref = ruleId_;
if (!(ref instanceof java.lang.String)) {
java.lang.String s = ((com.google.protobuf.ByteString) ref)
.toStringUtf8();
ruleId_ = s;
return s;
return (java.lang.String) ref;
public com.google.protobuf.ByteString
getRuleIdBytes() {
java.lang.Object ref = ruleId_;
if (ref instanceof String) {
com.google.protobuf.ByteString b = 
com.google.protobuf.ByteString.copyFromUtf8(
(java.lang.String) ref);
ruleId_ = b;
return b;
return (com.google.protobuf.ByteString) ref;
public Builder setRuleId(
java.lang.String value) {
if (value == null) {
throw new NullPointerException();
bitField0_ |= 0x00000100;
ruleId_ = value;
onChanged();
return this;
public Builder clearRuleId() {
bitField0_ = (bitField0_ & ~0x00000100);
ruleId_ = getDefaultInstance().getRuleId();
onChanged();
return this;
public Builder setRuleIdBytes(
com.google.protobuf.ByteString value) {
if (value == null) {
throw new NullPointerException();
bitField0_ |= 0x00000100;
ruleId_ = value;
onChanged();
return this;
private java.lang.Object extends_ = "";
public boolean hasExtends() {
return ((bitField0_ & 0x00000200) == 0x00000200);
public java.lang.String getExtends() {
java.lang.Object ref = extends_;
if (!(ref instanceof java.lang.String)) {
java.lang.String s = ((com.google.protobuf.ByteString) ref)
.toStringUtf8();
extends_ = s;
return s;
return (java.lang.String) ref;
public com.google.protobuf.ByteString
getExtendsBytes() {
java.lang.Object ref = extends_;
if (ref instanceof String) {
com.google.protobuf.ByteString b = 
com.google.protobuf.ByteString.copyFromUtf8(
(java.lang.String) ref);
extends_ = b;
return b;
return (com.google.protobuf.ByteString) ref;
public Builder setExtends(
java.lang.String value) {
if (value == null) {
throw new NullPointerException();
bitField0_ |= 0x00000200;
extends_ = value;
onChanged();
return this;
public Builder clearExtends() {
bitField0_ = (bitField0_ & ~0x00000200);
extends_ = getDefaultInstance().getExtends();
onChanged();
return this;
public Builder setExtendsBytes(
com.google.protobuf.ByteString value) {
if (value == null) {
throw new NullPointerException();
bitField0_ |= 0x00000200;
extends_ = value;
onChanged();
return this;
java.util.List<java.lang.String>
getOnlyApplyToList();
int getOnlyApplyToCount();
java.lang.String getOnlyApplyTo(int index);
com.google.protobuf.ByteString
getOnlyApplyToBytes(int index);
java.util.List<java.lang.String>
getOnlyApplyToRegexpList();
int getOnlyApplyToRegexpCount();
java.lang.String getOnlyApplyToRegexp(int index);
com.google.protobuf.ByteString
getOnlyApplyToRegexpBytes(int index);
boolean hasRuleId();
java.lang.String getRuleId();
com.google.protobuf.ByteString
getRuleIdBytes();
boolean hasExtends();
java.lang.String getExtends();
com.google.protobuf.ByteString
getExtendsBytes();
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
JsonObject sourceMapRoot = new Gson().fromJson(contents, JsonObject.class);
int version = sourceMapRoot.get("version").getAsInt();
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
JsonObject sourceMapRoot = new Gson().fromJson(contents, JsonObject.class);
public void parse(JsonObject sourceMapRoot) throws SourceMapParseException {
public void parse(JsonObject sourceMapRoot, SourceMapSupplier sectionSupplier)
int version = sourceMapRoot.get("version").getAsInt();
&& sourceMapRoot.get("file").getAsString().isEmpty()) {
? sourceMapRoot.get("lineCount").getAsInt() : -1;
String lineMap = sourceMapRoot.get("mappings").getAsString();
sources = getJavaStringArray(sourceMapRoot.get("sources").getAsJsonArray());
names = getJavaStringArray(sourceMapRoot.get("names").getAsJsonArray());
sourceRoot = sourceMapRoot.get("sourceRoot").getAsString();
for (Map.Entry<String, JsonElement> entry : sourceMapRoot.entrySet()) {
if (entry.getKey().startsWith("x_")) {
extensions.put(entry.getKey(), entry.getValue());
JsonObject sourceMapRoot, SourceMapSupplier sectionSupplier)
int version = sourceMapRoot.get("version").getAsInt();
String file = sourceMapRoot.get("file").getAsString();
JsonArray sections = sourceMapRoot.get("sections").getAsJsonArray();
for (int i = 0, count = sections.size(); i < count; i++) {
JsonObject section = sections.get(i).getAsJsonObject();
JsonObject offset = section.get("offset").getAsJsonObject();
int line = offset.get("line").getAsInt();
int column =  offset.get("column").getAsInt();
String url = section.get("url").getAsString();
mapSectionContents = section.get("map").toString();
private String[] getJavaStringArray(JsonArray array) throws JsonParseException {
int len = array.size();
for (int i = 0; i < len; i++) {
result[i] = array.get(i).getAsString();
import com.google.gson.Gson;
+ "new : (%s,%s)",
value = new Gson().toJson(value);
import java.util.Collections;
result.addAll(Collections.nCopies(entry.reps, entry.id));
throw new FlagUsageException("Unknown language `" + config.languageIn
+ "' specified.");
options.renamePrefixNamespace = config.renamePrefixNamespace;
inputs.add(SourceFile.fromInputStream("stdin", System.in, inputCharset));
List<String> moduleNames = new ArrayList<>(specs.size());
Map<String, Integer> modulesFileCountMap = Maps.newLinkedHashMap();
int numJsFilesExpected = 0, minJsFilesRequired = 0;
boolean isFirstModule = true;
throw new FlagUsageException("Duplicate module name: " + name);
JSModule module = new JSModule(name);
int numJsFiles = -1;
try {
numJsFiles = Integer.parseInt(parts[1]);
numJsFiles = -1;
if (numJsFiles < 0) {
if (parts.length == 2 && "auto".equals(parts[1])) {
if (isFirstModule) {
numJsFilesExpected = -1;
throw new FlagUsageException("Invalid JS file count '" + parts[1]
+ "' for module: " + name + ". Only the first module may specify " +
"a size of 'auto' and it must have no dependencies.");
throw new FlagUsageException("Invalid JS file count '" + parts[1]
+ "' for module: " + name);
minJsFilesRequired += numJsFiles;
if (numJsFilesExpected >= 0) {
numJsFilesExpected += numJsFiles;
moduleNames.add(0, name);
modulesFileCountMap.put(name, numJsFiles);
final int totalNumJsFiles = jsFiles.size();
if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
if (minJsFilesRequired > totalNumJsFiles) {
numJsFilesExpected = minJsFilesRequired;
if (numJsFilesExpected > totalNumJsFiles) {
throw new FlagUsageException("Not enough JS files specified. Expected "
+ numJsFilesExpected + " but found " + totalNumJsFiles);
throw new FlagUsageException("Too many JS files specified. Expected "
+ numJsFilesExpected + " but found " + totalNumJsFiles);
int numJsFilesLeft = totalNumJsFiles, moduleIndex = 0;
for (String moduleName : moduleNames) {
int numJsFiles = modulesFileCountMap.get(moduleName);
JSModule module = modulesByName.get(moduleName);
if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
numJsFiles = numJsFilesLeft;
List<String> moduleJsFiles =
jsFiles.subList(numJsFilesLeft - numJsFiles, numJsFilesLeft);
for (SourceFile input : createInputs(moduleJsFiles, false)) {
module.add(input);
numJsFilesLeft -= numJsFiles;
moduleIndex++;
compiler.hoistExterns();
try (Writer eeOut = openExternExportsStream(options, config.jsOutputFile)) {
eeOut.append(result.externExport);
try (Writer writer = fileNameToLegacyOutputWriter(getModuleOutputFileName(m))) {
if (options.sourceMapOutputPath != null) {
compiler.getSourceMap().reset();
writeModuleOutput(writer, m);
if (options.sourceMapOutputPath != null) {
compiler.getSourceMap().appendTo(mapOut, m.getName());
return new BufferedWriter(new OutputStreamWriter(stream, UTF_8));
return new BufferedWriter(new OutputStreamWriter(stream, UTF_8));
try (Writer out = fileNameToOutputWriter2(outName)) {
compiler.getSourceMap().appendTo(out, associatedName);
try (final OutputStream file = filenameToOutputStream(functionInformationMapOutputPath)) {
CodedOutputStream outputStream = CodedOutputStream.newInstance(file);
compiler.getFunctionalInformationMap().writeTo(outputStream);
outputStream.flush();
try (Writer out = fileNameToOutputWriter2(expandCommandLinePath(output, module))) {
if (isManifest) {
printManifestTo(module.getInputs(), out);
printBundleTo(module.getInputs(), out);
try (Writer out = fileNameToOutputWriter2(expandCommandLinePath(output, null))) {
if (config.module.isEmpty()) {
if (isManifest) {
printManifestTo(compiler.getInputsInOrder(), out);
printBundleTo(compiler.getInputsInOrder(), out);
printModuleGraphManifestOrBundleTo(
compiler.getDegenerateModuleGraph(), out, isManifest);
try (Writer out = fileNameToOutputWriter2(config.outputModuleDependencies)) {
printModuleGraphJsonTo(out);
private String renamePrefixNamespace = null;
CommandLineConfig setRenamePrefixNamespace(String renamePrefixNamespace) {
this.renamePrefixNamespace = renamePrefixNamespace;
return this;
boolean needsEs6Runtime = false;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.PrototypeObjectType;
static Visibility getEffectiveNameVisibility(Node name, Var var,
ImmutableMap<StaticSourceFile, Visibility> fileVisibilityMap) {
JSType type = name.getJSType();
boolean createdFromGoogProvide = (type instanceof PrototypeObjectType
&& ((PrototypeObjectType) type).isAnonymous());
return (createdFromGoogProvide || defaultVisibilityForFile == null)
JSType type = getprop.getJSType();
boolean createdFromGoogProvide = (type instanceof PrototypeObjectType
&& ((PrototypeObjectType) type).isAnonymous());
return (raw != Visibility.INHERITED
|| fileOverviewVisibility == null
|| createdFromGoogProvide)
? raw
: fileOverviewVisibility;
import static java.nio.charset.StandardCharsets.UTF_8;
crc32.update(s.getBytes(UTF_8));
import java.util.ArrayList;
private Map<String, String> renamingMap = null;
r.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE));
static AmbiguateProperties makePassForTesting(
AbstractCompiler compiler, char[] reservedCharacters) {
AmbiguateProperties ap =
new AmbiguateProperties(compiler, reservedCharacters);
ap.renamingMap = Maps.newHashMap();
return ap;
Preconditions.checkNotNull(renamingMap);
ArrayList<PropertyGraphNode> nodes = new ArrayList<>(propertyMap.size());
for (Property prop : propertyMap.values()) {
if (prop.skipAmbiguating) {
reservedNames.add(prop.oldName);
++numRenamedPropertyNames;
nodes.add(new PropertyGraphNode(prop));
PropertyGraph graph = new PropertyGraph(nodes);
String[] colorMap = new String[numNewPropertyNames];
colorMap[i] = nameGen.generateNextName();
for (PropertyGraphNode node : graph.getNodes()) {
node.getValue().newName = colorMap[node.getAnnotation().hashCode()];
if (renamingMap != null) {
renamingMap.put(node.getValue().oldName, node.getValue().newName);
private final ArrayList<PropertyGraphNode> nodes;
PropertyGraph(ArrayList<PropertyGraphNode> nodes) {
this.nodes = nodes;
public List<PropertyGraphNode> getNodes() {
return nodes;
throw new RuntimeException("PropertyGraph#getNode is never called.");
for (PropertyGraphNode node : nodes) {
import com.google.common.base.Predicates;
Predicate<Node> shouldTraverse = Predicates.alwaysTrue();
if (n.getFirstChild().isName()) {
validateNodeType(Token.EMPTY, n.getFirstChild());
Node secondChild = n.getChildAtIndex(1);
switch (secondChild.getType()) {
case Token.IMPORT_SPECS:
validateImportSpecifiers(secondChild);
break;
case Token.IMPORT_STAR:
validateNonEmptyString(secondChild);
break;
default:
validateNodeType(Token.EMPTY, secondChild);
validateString(n.getChildAtIndex(2));
Preconditions.checkState(!alreadyRun);
DefinitionProvider definitionProvider = constructDefinitionProvider(externsRoot, jsRoot);
import com.google.javascript.rhino.jstype.JSTypeNative;
import java.util.ArrayDeque;
" must explicitly redeclare superclass visibility");
private final ArrayDeque<JSType> currentClassStack = new ArrayDeque<>();
private final JSType noTypeSentinel;
this.noTypeSentinel = compiler.getTypeRegistry()
.getNativeType(JSTypeNative.NO_TYPE);
JSType prevClass = getCurrentClass();
JSType currentClass = prevClass == null
? getClassOfMethod(n, parent)
: prevClass;
currentClassStack.addFirst(currentClass == null
? noTypeSentinel
: currentClass);
currentClassStack.pop();
name, var, defaultVisibilityForFiles), name);
return overridingInfo == null || !overridingInfo.isOverride()
? null
if (overriding != null) {
checkOverriddenPropertyVisibilityMismatch(
overriding, visibility, fileOverviewVisibility, t, getprop);
JSType cur = currentClassStack.peekFirst();
return cur == noTypeSentinel
? null
: cur;
JSType currentClass = getCurrentClass();
JSType currentClass = getCurrentClass();
import com.google.common.collect.ImmutableSet;
import com.google.protobuf.Descriptors;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
List<Requirement> requirements = mergeRequirements(compiler, configs);
for (Requirement requirement : requirements) {
Rule rule = initRule(compiler, requirement);
if (rule != null) {
builder.add(rule);
return builder.build();
private static final Set<String> EXTENDABLE_FIELDS = ImmutableSet.of(
"extends", "whitelist", "whitelist_regexp", "only_apply_to", "only_apply_to_regexp");
static List<Requirement> mergeRequirements(AbstractCompiler compiler,
List<ConformanceConfig> configs) {
List<Requirement.Builder> builders = new ArrayList<>();
Map<String, Requirement.Builder> extendable = new HashMap<>();
Requirement.Builder builder = requirement.toBuilder();
if (requirement.hasRuleId()) {
if (requirement.getRuleId().isEmpty()) {
reportInvalidRequirement(compiler, requirement, "empty rule_id");
continue;
if (extendable.containsKey(requirement.getRuleId())) {
reportInvalidRequirement(compiler, requirement,
"two requirements with the same rule_id: " + requirement.getRuleId());
continue;
extendable.put(requirement.getRuleId(), builder);
if (!requirement.hasExtends()) {
builders.add(builder);
for (ConformanceConfig config : configs) {
for (Requirement requirement : config.getRequirementList()) {
if (requirement.hasExtends()) {
Requirement.Builder existing = extendable.get(requirement.getExtends());
if (existing == null) {
reportInvalidRequirement(compiler, requirement,
"no requirement with rule_id: " + requirement.getExtends());
continue;
for (Descriptors.FieldDescriptor field : requirement.getAllFields().keySet()) {
if (!EXTENDABLE_FIELDS.contains(field.getName())) {
reportInvalidRequirement(compiler, requirement,
"extending rules allow only " + EXTENDABLE_FIELDS);
existing.addAllWhitelist(requirement.getWhitelistList());
existing.addAllWhitelistRegexp(requirement.getWhitelistRegexpList());
existing.addAllOnlyApplyTo(requirement.getOnlyApplyToList());
existing.addAllOnlyApplyToRegexp(requirement.getOnlyApplyToRegexpList());
List<Requirement> requirements = new ArrayList<>(builders.size());
for (Requirement.Builder builder : builders) {
Requirement requirement = builder.build();
checkRequirementList(compiler, requirement, "whitelist");
checkRequirementList(compiler, requirement, "whitelist_regexp");
checkRequirementList(compiler, requirement, "only_apply_to");
checkRequirementList(compiler, requirement, "only_apply_to_regexp");
requirements.add(requirement);
return requirements;
private static void checkRequirementList(AbstractCompiler compiler, Requirement requirement,
String field) {
Set<String> existing = new HashSet<>();
for (String value : getRequirementList(requirement, field)) {
if (!existing.add(value)) {
reportInvalidRequirement(compiler, requirement, "duplicate " + field + " value: " + value);
private static List<String> getRequirementList(Requirement requirement, String field) {
switch (field) {
case "whitelist":
return requirement.getWhitelistList();
case "whitelist_regexp":
return requirement.getWhitelistRegexpList();
case "only_apply_to":
return requirement.getOnlyApplyToList();
case "only_apply_to_regexp":
return requirement.getOnlyApplyToRegexpList();
default:
throw new AssertionError("Unrecognized field: " + field);
key = parentScopeType + "~" + key;
key = t.getScope().getParentScope().getTypeOfThis() + "~" + key;
key = base.getJSType() + "=" + key;
key = hObjT + "=" + key;
while (!dfsStack.isEmpty()) {
if (!isDisposalStack.isEmpty()) {
if (!isDisposalStack.isEmpty()) {
return type.isEmptyType() || type.isUnknownType()
|| !isPossiblySubtype(type, googDisposableInterfaceType);
return name.parent.type == Name.Type.FUNCTION && name.parent.isDeclaredType()
&& !functionPrototypeProps.contains(name.getBaseName());
public class CheckPathsBetweenNodes<N, E> {
public CheckPathsBetweenNodes(DiGraph<N, E> graph, DiGraphNode<N, E> a,
import com.google.common.base.Preconditions;
return className.substring(0,
className.indexOf(part) + part.length());
private final List<Node> newAndImplementsNodes = new ArrayList<>();
return parent == null || !parent.isScript() || !t.getInput().isExtern();
maybeAddImplements(t, n);
for (Node node : newAndImplementsNodes) {
String className;
if (node.isNew()) {
className = node.getFirstChild().getQualifiedName();
className = node.getString();
this.newAndImplementsNodes.clear();
Node root = NodeUtil.getRootOfQualifiedName(qNameNode);
if (!root.isName()) {
String name = root.getString();
newAndImplementsNodes.add(n);
JSDocInfo info = n.getJSDocInfo();
if (info.isConstructor() || info.isInterface()) {
private void maybeAddImplements(NodeTraversal t, Node n) {
JSDocInfo info = NodeUtil.getBestJSDocInfo(n);
if (info != null) {
for (JSTypeExpression expr : info.getImplementedInterfaces()) {
Node implementsNode = expr.getRoot();
Preconditions.checkState(implementsNode.getType() == Token.BANG);
Node child = implementsNode.getFirstChild();
Preconditions.checkState(child.isString());
String rootName = Splitter.on('.').split(child.getString()).iterator().next();
Scope.Var var = t.getScope().getVar(rootName);
if (var != null && var.isExtern()) {
return;
newAndImplementsNodes.add(child);
"If this if/for/while really shouldn''t have a body, use '{}'");
"Comparison against NaN is always false. Did you mean isNaN()?");
import com.google.javascript.jscomp.newtypes.DeclaredTypeRegistry;
import com.google.javascript.jscomp.newtypes.JSType;
import com.google.javascript.jscomp.newtypes.QualifiedName;
new AssertionFunctionSpec("goog.asserts.assert", JSType.TRUTHY),
JSType.NUMBER, JSTypeNative.NUMBER_TYPE),
JSType.STRING, JSTypeNative.STRING_TYPE),
JSType.TOP_OBJECT, JSTypeNative.OBJECT_TYPE),
new AssertFunctionByTypeName("goog.asserts.assertFunction", "Function"),
new AssertFunctionByTypeName("goog.asserts.assertArray", "Array"),
public Bind describeFunctionBind(
Node n, boolean callerChecksTypes, boolean iCheckTypes) {
return super.describeFunctionBind(n, callerChecksTypes, iCheckTypes);
super(functionName, JSType.TOP_OBJECT, JSTypeNative.OBJECT_TYPE);
public com.google.javascript.rhino.jstype.JSType
getAssertedOldType(Node call, JSTypeRegistry registry) {
com.google.javascript.rhino.jstype.JSType ownerType =
constructor.getJSType();
public JSType getAssertedNewType(Node call, DeclaredTypeRegistry scope) {
if (call.getChildCount() > 2) {
Node constructor = call.getFirstChild().getNext().getNext();
if (constructor != null && constructor.isQualifiedName()) {
QualifiedName qname = QualifiedName.fromNode(constructor);
JSType functionType = scope.getDeclaredTypeOf(qname.getLeftmostName());
if (functionType != null) {
if (!qname.isIdentifier()) {
functionType = functionType.getProp(qname.getAllButLeftmost());
com.google.javascript.jscomp.newtypes.FunctionType ctorType =
functionType.getFunTypeIfSingletonObj();
if (ctorType != null && ctorType.isConstructor()) {
return ctorType.getInstanceTypeOfCtor();
return JSType.UNKNOWN;
super(functionName, null);
public com.google.javascript.rhino.jstype.JSType
getAssertedOldType(Node call, JSTypeRegistry registry) {
public JSType getAssertedNewType(Node call, DeclaredTypeRegistry scope) {
JSType result = scope.getDeclaredTypeOf(typeName)
.getFunTypeIfSingletonObj().getInstanceTypeOfCtor();
return result;
if (classInfo.getBaseType() != null) {
mergedInfo.recordBaseType(classInfo.getBaseType());
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.JSDocInfoBuilder;
final List<Node> exports = new ArrayList<>();
if (inModule()) {
switch (n.getType()) {
case Token.BLOCK:
if (current.moduleScopeRoot == parent && parent.isFunction()) {
current.moduleScope = t.getScope();
break;
case Token.SCRIPT:
current.moduleScope = t.getScope();
break;
private static boolean isCallTo(Node n, String qname) {
&& n.getFirstChild().matchesQualifiedName(qname);
private static boolean isLoadModuleCall(Node n) {
return isCallTo(n, "goog.loadModule");
return isCallTo(n, "goog.module.get");
if (isCallTo(n.getFirstChild(),
"goog.module.declareLegacyNamespace")) {
n.detachFromParent();
if (isCallTo(n, "goog.module")) {
case Token.GETPROP:
if (isExportPropAssign(n)) {
Node rhs = parent.getLastChild();
maybeUpdateExportDeclToNode(t, parent, rhs);
break;
current.exports.add(n);
if (isAssignTarget(n)) {
maybeUpdateExportObjectDecl(t, n);
private void maybeUpdateExportObjectDecl(NodeTraversal t, Node n) {
Node parent = n.getParent();
Node rhs = parent.getLastChild();
maybeUpdateExportDeclToNode(t, parent, rhs);
if (rhs.isObjectLit()) {
for (Node c = rhs.getFirstChild(); c != null; c = c.getNext()) {
if (c.isStringKey()) {
Node value = c.getFirstChild();
maybeUpdateExportDeclToNode(t, c, value);
private void maybeUpdateExportDeclToNode(
NodeTraversal t, Node target, Node value) {
if (value.isName()) {
Scope currentScope = t.getScope();
Var v = t.getScope().getVar(value.getString());
if (v != null) {
Scope varScope = v.getScope();
if (varScope.getDepth() == currentScope.getDepth()) {
JSDocInfo info = v.getJSDocInfo();
if (info != null && info.hasTypedefType()) {
JSDocInfoBuilder builder = JSDocInfoBuilder.copyFrom(info);
target.setJSDocInfo(builder.build(target));
return;
JSDocInfo info = target.getJSDocInfo();
if (info == null) {
JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
builder.recordConstancy();
target.setJSDocInfo(builder.build(target));
JSDocInfoBuilder builder = JSDocInfoBuilder.copyFrom(info);
builder.recordConstancy();
target.setJSDocInfo(builder.build(target));
private static boolean isExportPropAssign(Node n) {
Preconditions.checkState(n.isGetProp());
Node target = n.getFirstChild();
return isAssignTarget(n) && target.isName()
&& target.getString().equals("exports");
private static boolean isAssignTarget(Node n) {
Node parent = n.getParent();
return parent.isAssign() && parent.getFirstChild() == n;
updateExports(current.exports);
private void updateExports(List<Node> exports) {
for (Node n : exports) {
Node replacement = NodeUtil.newQName(compiler, current.moduleNamespace);
replacement.srcrefTree(n);
n.getParent().replaceChild(n, replacement);
return LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE >= scope.getVarCount();
while (mantissa / 10 * ((long) Math.pow(10, exp + 1)) == value) {
addConstant(mantissa + "E" + exp);
Node second = first.getNext();
if (!second.isEmpty()) {
if (!second.isEmpty()) {
add(second);
if (!first.isEmpty() || !second.isEmpty()) {
add("from");
case Token.IMPORT_STAR:
add("*");
add("as");
add(n.getString());
break;
import com.google.javascript.jscomp.newtypes.DeclaredTypeRegistry;
import com.google.javascript.jscomp.newtypes.JSType;
JSTypeRegistry registry,
StaticScope<com.google.javascript.rhino.jstype.JSType> scope,
public Bind describeFunctionBind(
Node n, boolean callerChecksTypes, boolean iCheckTypes);
protected final JSType assertedNewType;
this(functionName, JSType.UNKNOWN, null);
public AssertionFunctionSpec(String functionName, JSType assertedNewType) {
this(functionName, assertedNewType, null);
JSType assertedNewType, JSTypeNative assertedType) {
this.assertedNewType = assertedNewType;
public com.google.javascript.rhino.jstype.JSType
getAssertedOldType(Node call, JSTypeRegistry registry) {
public com.google.javascript.jscomp.newtypes.JSType
getAssertedNewType(Node call, DeclaredTypeRegistry scope) {
return assertedNewType;
return describeFunctionBind(n, false, false);
public Bind describeFunctionBind(
Node n, boolean callerChecksTypes, boolean iCheckTypes) {
return nextConvention
.describeFunctionBind(n, callerChecksTypes, iCheckTypes);
int lastSlash = name.lastIndexOf('/');
return describeFunctionBind(n, false, false);
public Bind describeFunctionBind(
Node n, boolean callerChecksTypes, boolean iCheckTypes) {
if (iCheckTypes && maybeFnType != null) {
if (fnType != null || callerChecksTypes || maybeFn.isFunction()) {
CollapseProperties(AbstractCompiler compiler, boolean inlineAliases) {
namespace = new GlobalNamespace(compiler, root);
throw new IllegalStateException("unexpected: " + target);
import java.util.Collection;
public static final int UTF8_BOM_CODE = 65279;
+ "<num-js-files> may be set to 'auto' for the first module if it "
+ "has no dependencies. "
"based on available information. Inaccurate type annotations " +
+ "goog.require(), goog.provide(), and goog.exportSymbol(). "
+ "True by default.")
usage = "Specifies the name of an object that will be used to store all "
+ "non-extern globals")
private String renamePrefixNamespace = null;
hidden = true,
p.printUsage(new OutputStreamWriter(ps, UTF_8), null, OptionHandlerFilter.ALL);
List<String> allJsInputs = findJsFiles(patterns);
return allJsInputs;
boolean isFirstCharacter = true;
if (isFirstCharacter) {
isFirstCharacter = false;
if (c == UTF8_BOM_CODE) {
continue;
.setNewTypeInference(flags.useNewTypeInference)
.setRenamePrefixNamespace(flags.renamePrefixNamespace);
options.renamePrefixNamespace = flags.renamePrefixNamespace;
if ((int)textProto.charAt(0) == UTF8_BOM_CODE) {
textProto = textProto.substring(1);
entryStream,
UTF_8));
public static List<String> findJsFiles(Collection<String> patterns) throws IOException {
Set<String> allJsInputs = new LinkedHashSet<>();
for (String pattern : patterns) {
if (!pattern.contains("*") && !pattern.startsWith("!")) {
File matchedFile = new File(pattern);
if (matchedFile.isDirectory()) {
matchPaths(new File(matchedFile, "**.js").toString(), allJsInputs);
allJsInputs.add(pattern);
matchPaths(pattern, allJsInputs);
return new ArrayList<>(allJsInputs);
private static void matchPaths(String pattern, final Set<String> allJsInputs)
throws IOException {
FileSystem fs = FileSystems.getDefault();
final boolean remove = pattern.indexOf('!') == 0;
if (remove) pattern = pattern.substring(1);
if (File.separator.equals("\\")) {
pattern = pattern.replace('\\', '/');
List<String> patternParts = Splitter.on('/').splitToList(pattern);
String prefix = ".";
for (int i = 0; i < patternParts.size(); i++) {
if (patternParts.get(i).contains("*")) {
if (i == 0) {
break;
prefix = Joiner.on("/").join(patternParts.subList(0, i));
pattern = Joiner.on("/").join(patternParts.subList(i, patternParts.size()));
final PathMatcher matcher = fs.getPathMatcher("glob:" + pattern);
java.nio.file.Files.walkFileTree(
fs.getPath(prefix), new SimpleFileVisitor<Path>() {
Path p, BasicFileAttributes attrs) {
if (matcher.matches(p)) {
if (remove) {
allJsInputs.remove(p.toString());
allJsInputs.add(p.toString());
return FileVisitResult.CONTINUE;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.javascript.jscomp.JSModuleGraph.MissingModuleException;
import java.util.ArrayList;
List<WarningsGuard> guards = ImmutableList.of(
getDiagnosticGroups().getRegisteredGroups()),
options.getWarningsGuard());
initAST();
List<CompilerInput> inputs = new ArrayList<>(files.size());
List<CompilerInput> inputs = new ArrayList<>();
private void initAST() {
jsRoot = IR.block();
jsRoot.setIsSyntheticBlock(true);
externsRoot = IR.block();
externsRoot.setIsSyntheticBlock(true);
externAndJsRoot = IR.block(externsRoot, jsRoot);
externAndJsRoot.setIsSyntheticBlock(true);
return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);
return new SanityCheck(compiler);
if (errorManager == null) {
return new JSError[] {};
if (errorManager == null) {
return new JSError[] {};
symbolTable.fillSymbolVisibility(this, externsRoot, jsRoot);
new SemanticReverseAbstractInterpreter(getTypeRegistry());
interpreter = new ClosureReverseAbstractInterpreter(getTypeRegistry())
externsRoot.detachChildren();
jsRoot.detachChildren();
hoistExterns();
void hoistExterns() {
Map<String, JSModule> modulesByProvide = Maps.newLinkedHashMap();
JSModule m = new JSModule(cjs.inputToModuleName(input));
m.addAndOverrideModule(input);
for (String provide : input.getProvides()) {
modulesByProvide.put(provide, m);
modulesByInput.put(input, m);
List<JSModule> modules = new ArrayList<>(modulesByProvide.values());
JSModule dependency = modulesByProvide.get(require);
addCommonJSModulesToGraph(modules, modulesByInput);
void addCommonJSModulesToGraph(
List<JSModule> inputModules,
Map<CompilerInput, JSModule> modulesByInput)
throws CircularDependencyException, MissingProvideException, MissingModuleException {
List<CompilerInput> inputs = new ArrayList<>();
for (JSModule module : inputModules) {
inputs.addAll(module.getInputs());
modules = new ArrayList<>();
DependencyOptions depOptions = options.dependencyOptions;
for (CompilerInput input :
this.moduleGraph.manageDependencies(depOptions, inputs)) {
modules.add(modulesByInput.get(input));
SortedDependencies<JSModule> sorter =
new SortedDependencies<>(modules);
modules = sorter.getDependenciesOf(modules, true);
JSModule firstModule = Iterables.getFirst(modules, null);
for (int i = 1; i < modules.size(); i++) {
if (!modules.get(i).getDependencies().contains(firstModule)) {
modules.get(i).addDependency(firstModule);
this.moduleGraph = new JSModuleGraph(modules);
List<PassFactory> optimizations = getPassConfig().getOptimizations();
if (optimizations.isEmpty()) {
return;
phaseOptimizer.consume(optimizations);
private final List<CodeChangeHandler> codeChangeHandlers = new ArrayList<>();
initCompilerOptionsIfTesting();
if (!moduleInputs.isEmpty()) {
Preconditions.checkNotNull(compiler, "Expected setCompiler to be called first: %s", this);
Preconditions.checkNotNull(
compiler.getErrorManager(), "Expected compiler to call an error manager: %s", this);
int maxFunctionSizeAfterInlining;
static final int UNLIMITED_FUN_SIZE_AFTER_INLINING = -1;
maxFunctionSizeAfterInlining = UNLIMITED_FUN_SIZE_AFTER_INLINING;
public void setMaxFunctionSizeAfterInlining(int funAstSize) {
Preconditions.checkArgument(funAstSize > 0);
this.maxFunctionSizeAfterInlining = funAstSize;
public boolean isEs5OrHigher() {
Preconditions.checkState(this != NO_TRANSPILE);
return this != LanguageMode.ECMASCRIPT3;
if (options.getLanguageOut().isEs6OrHigher()) {
throw new InvalidOptionsException(
"ES6 is only supported for transpilation to a lower ECMAScript"
+ " version. Set --language_out to ES3, ES5, or ES5_strict.");
if (!options.inlineFunctions
&& options.maxFunctionSizeAfterInlining
!= CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING) {
throw new InvalidOptionsException(
"max_function_size_after_inlining has no effect if inlining is"
+ " disabled.");
import com.google.common.collect.Sets;
import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.JSDocInfo.Visibility;
import com.google.javascript.rhino.jstype.Property;
import com.google.javascript.rhino.jstype.ObjectType;
import java.util.Set;
import javax.annotation.Nullable;
final ImmutableList<String> onlyApplyTo;
message = requirement.getErrorMessage();
whitelist = ImmutableList.copyOf(requirement.getWhitelistList());
whitelistRegexp = buildPattern(
onlyApplyTo = ImmutableList.copyOf(requirement.getOnlyApplyToList());
onlyApplyToRegexp = buildPattern(
requirement.getOnlyApplyToRegexpList());
boolean hasWhitelist = !whitelist.isEmpty()
|| whitelistRegexp != null;
boolean hasOnlyApplyTo = !onlyApplyTo.isEmpty()
|| onlyApplyToRegexp != null;
if (hasWhitelist && hasOnlyApplyTo) {
throw new IllegalArgumentException(
"It is an error to specify both whitelist and only_apply_to");
private boolean shouldCheckConformance(Node n) {
if (srcfile == null) {
return true;
return pathIsInListOrRegexp(srcfile, onlyApplyTo, onlyApplyToRegexp);
return !pathIsInListOrRegexp(srcfile, whitelist, whitelistRegexp);
private static boolean pathIsInListOrRegexp(
String srcfile, ImmutableList<String> list, @Nullable Pattern regexp) {
for (int i = 0; i < list.size(); i++) {
String entry = list.get(i);
return regexp != null && regexp.matcher(srcfile).find();
if (confidence != ConformanceResult.CONFORMANCE
&& shouldCheckConformance(n)) {
public static final class BanExpose extends AbstractRule {
public BanExpose(AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
JSDocInfo info = n.getJSDocInfo();
if (info != null && info.isExpose()) {
return ConformanceResult.VIOLATION;
return ConformanceResult.CONFORMANCE;
public static final class BanThrowOfNonErrorTypes extends AbstractRule {
final JSType errorObjType;
public BanThrowOfNonErrorTypes(AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
errorObjType = compiler.getTypeRegistry().getType("Error");
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
if (errorObjType != null && n.isThrow()) {
JSType thrown = n.getFirstChild().getJSType();
if (thrown != null) {
if (!thrown.isUnknownType()
&& !thrown.isAllType()
&& !thrown.isEmptyType()
&& !thrown.isSubtype(errorObjType)) {
return ConformanceResult.VIOLATION;
return ConformanceResult.CONFORMANCE;
public static final class BanUnknownThis extends AbstractRule {
private final Set<Node> reports = Sets.newIdentityHashSet();
private final ImmutableList<AssertionFunctionSpec> assertions;
public BanUnknownThis(AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
assertions = ImmutableList.copyOf(
compiler.getCodingConvention().getAssertionFunctions());
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
if (n.isThis()) {
JSType type = n.getJSType();
if (type != null && type.isUnknownType() && !isWhiteListed(n)) {
Node root = t.getScopeRoot();
if (!reports.contains(root)) {
reports.add(root);
return ConformanceResult.VIOLATION;
return ConformanceResult.CONFORMANCE;
private boolean isWhiteListed(Node n) {
return n.getParent().isCast() || isAssertionCall(n.getParent());
private boolean isAssertionCall(Node n) {
if (n.isCall() && n.getFirstChild().isQualifiedName()) {
Node target = n.getFirstChild();
for (int i = 0; i < assertions.size(); i++) {
if (target.matchesQualifiedName(
assertions.get(i).getFunctionName())) {
return true;
return false;
public static final class BanGlobalVars extends AbstractRule {
public BanGlobalVars(AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
if (t.inGlobalScope()
&& isDeclaration(n)
&& !n.getBooleanProp(Node.IS_NAMESPACE)
&& !isWhitelisted(n)) {
return ConformanceResult.VIOLATION;
return ConformanceResult.CONFORMANCE;
private boolean isDeclaration(Node n) {
return NodeUtil.isNameDeclaration(n)
|| NodeUtil.isFunctionDeclaration(n)
|| NodeUtil.isClassDeclaration(n);
private boolean isWhitelisted(Node n) {
return n.isVar() && n.getFirstChild().getString().equals("$jscomp");
public static final class RequireFileoverviewVisibility extends AbstractRule {
public RequireFileoverviewVisibility(
AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
if (!n.isScript()) {
return ConformanceResult.CONFORMANCE;
JSDocInfo docInfo = n.getJSDocInfo();
if (docInfo == null || !docInfo.hasFileOverview()) {
return ConformanceResult.VIOLATION;
Visibility v = docInfo.getVisibility();
if (v == null || v == Visibility.INHERITED) {
return ConformanceResult.VIOLATION;
return ConformanceResult.CONFORMANCE;
public static final class NoImplicitlyPublicDecls extends AbstractRule {
public NoImplicitlyPublicDecls(
AbstractCompiler compiler, Requirement requirement)
throws InvalidRequirementSpec {
super(compiler, requirement);
protected ConformanceResult checkConformance(NodeTraversal t, Node n) {
if (!t.inGlobalScope()
|| !n.isExprResult()
|| !n.getFirstChild().isAssign()
|| n.getFirstChild().getLastChild() == null
|| n.getFirstChild().getLastChild().isObjectLit()
|| isWizDeclaration(n)) {
return ConformanceResult.CONFORMANCE;
JSDocInfo ownJsDoc = n.getFirstChild().getJSDocInfo();
if (ownJsDoc != null && ownJsDoc.isConstructor()) {
FunctionType functionType = n.getFirstChild()
.getJSType()
.toMaybeFunctionType();
if (functionType == null) {
return ConformanceResult.CONFORMANCE;
ObjectType instanceType = functionType.getInstanceType();
if (instanceType == null) {
return ConformanceResult.CONFORMANCE;
ConformanceResult result = checkCtorProperties(instanceType);
if (result != ConformanceResult.CONFORMANCE) {
return result;
return visibilityAtDeclarationOrFileoverview(ownJsDoc, getScriptNode(n));
private static boolean isWizDeclaration(Node n) {
Node lastChild = n.getFirstChild().getLastChild();
if (!lastChild.isCall()) {
return false;
Node getprop = lastChild.getFirstChild();
if (getprop == null || !getprop.isGetProp()) {
return false;
Node name = getprop.getFirstChild();
if (name == null || !name.isName()) {
return false;
return "wiz".equals(name.getString());
private static ConformanceResult checkCtorProperties(ObjectType type) {
for (String propertyName : type.getOwnPropertyNames()) {
Property prop = type.getOwnSlot(propertyName);
JSDocInfo docInfo = prop.getJSDocInfo();
Node scriptNode = getScriptNode(prop.getNode());
ConformanceResult result = visibilityAtDeclarationOrFileoverview(
docInfo, scriptNode);
if (result != ConformanceResult.CONFORMANCE) {
return result;
return ConformanceResult.CONFORMANCE;
for (Node up : start.getAncestors()) {
if (up.isScript()) {
return up;
return null;
private static ConformanceResult visibilityAtDeclarationOrFileoverview(
if (declaredJsDoc != null
&& (declaredJsDoc.getVisibility() != Visibility.INHERITED
|| declaredJsDoc.isOverride())) {
return ConformanceResult.CONFORMANCE;
&& scriptNode.getJSDocInfo() != null
&& scriptNode.getJSDocInfo().getVisibility() !=
Visibility.INHERITED) {
return ConformanceResult.CONFORMANCE;
return ConformanceResult.VIOLATION;
if (!initializedConstants.add(var)) {
if (!initializedConstants.add(var)) {
worklist.addAll(successors);
throw new IllegalStateException("Not reachable");
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
if (NodeUtil.isValidPropertyName(LanguageMode.ECMASCRIPT3, n.getString())) {
NodeUtil.isValidPropertyName(LanguageMode.ECMASCRIPT3, right.getString())) {
throw new IllegalStateException("Unknown statement");
if (!nodes.isEmpty() && windowInExterns) {
import com.google.javascript.jscomp.lint.CheckInterfaces;
import com.google.javascript.jscomp.lint.CheckPrototypeProperties;
checks.add(es6ConvertSuper);
if (options.checkRequires.isOn()
|| options.enables(DiagnosticGroups.MISSING_REQUIRE)) {
if (!options.getConformanceConfigs().isEmpty()) {
checks.add(checkConformance);
return new CheckRequiresForConstructors(compiler, CheckLevel.WARNING);
final HotSwapPassFactory es6ConvertSuper =
new HotSwapPassFactory("es6ConvertSuper", true) {
protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
return new Es6ConvertSuper(compiler);
new CheckEnums(compiler),
new CheckInterfaces(compiler),
new CheckPrototypeProperties(compiler)));
Preconditions.checkArgument(!callbacks.isEmpty());
return new CollapseProperties(compiler, !isInliningForbidden());
options.assumeClosuresOnlyCaptureReferences,
options.maxFunctionSizeAfterInlining);
return new GatherExternProperties(compiler);
implements OptimizeCalls.CallGraphCompilerPass, CompilerPass {
if (rValue == null
|| !rValue.isFunction()
|| NodeUtil.isVarArgsFunction(rValue)) {
if ((lValue == null)
|| !lValue.isGetProp()) {
if (!lValue.isQualifiedName()
&& !lValue.getFirstChild().isObjectLit()) {
return false;
import com.google.javascript.jscomp.lint.CheckInterfaces;
import com.google.javascript.jscomp.lint.CheckPrototypeProperties;
import com.google.javascript.jscomp.newtypes.JSTypeCreatorFromJSDoc;
static {
DiagnosticGroups.registerGroup("newCheckTypesWarningsOverload",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION,
NewTypeInference.NULLABLE_DEREFERENCE);
DiagnosticGroups.registerGroup("newCheckTypesClosureClean",
JSTypeCreatorFromJSDoc.CONFLICTING_EXTENDED_TYPE,
JSTypeCreatorFromJSDoc.CONFLICTING_IMPLEMENTED_TYPE,
JSTypeCreatorFromJSDoc.CONFLICTING_SHAPE_TYPE,
JSTypeCreatorFromJSDoc.DICT_IMPLEMENTS_INTERF,
JSTypeCreatorFromJSDoc.EXTENDS_NON_OBJECT,
JSTypeCreatorFromJSDoc.EXTENDS_NOT_ON_CTOR_OR_INTERF,
JSTypeCreatorFromJSDoc.IMPLEMENTS_WITHOUT_CONSTRUCTOR,
JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE,
GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE,
GlobalTypeInfo.CANNOT_INIT_TYPEDEF,
GlobalTypeInfo.CANNOT_OVERRIDE_FINAL_METHOD,
GlobalTypeInfo.CONST_WITHOUT_INITIALIZER,
GlobalTypeInfo.CTOR_IN_DIFFERENT_SCOPE,
GlobalTypeInfo.DUPLICATE_JSDOC,
GlobalTypeInfo.DUPLICATE_PROP_IN_ENUM,
GlobalTypeInfo.EXPECTED_CONSTRUCTOR,
GlobalTypeInfo.EXPECTED_INTERFACE,
GlobalTypeInfo.INEXISTENT_PARAM,
GlobalTypeInfo.LENDS_ON_BAD_TYPE,
GlobalTypeInfo.MALFORMED_ENUM,
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR,
GlobalTypeInfo.UNDECLARED_NAMESPACE,
TypeCheck.CONFLICTING_EXTENDED_TYPE,
TypeCheck.ENUM_NOT_CONSTANT,
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,
TypeCheck.MULTIPLE_VAR_DEF,
TypeCheck.UNKNOWN_OVERRIDE,
TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL,
NewTypeInference.CANNOT_BIND_CTOR,
NewTypeInference.CROSS_SCOPE_GOTCHA,
NewTypeInference.FORIN_EXPECTS_STRING_KEY,
NewTypeInference.INVALID_INFERRED_RETURN_TYPE,
NewTypeInference.UNKNOWN_ASSERTION_TYPE,
CheckGlobalThis.GLOBAL_THIS,
TypeCheck.CONSTRUCTOR_NOT_CALLABLE,
TypeCheck.ILLEGAL_OBJLIT_KEY,
TypeCheck.IN_USED_WITH_STRUCT,
TypeValidator.UNKNOWN_TYPEOF_VALUE);
RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION,
RhinoErrorReporter.MISPLACED_FUNCTION_ANNOTATION);
CheckEnums.DUPLICATE_ENUM_VALUE,
CheckInterfaces.INTERFACE_FUNCTION_NOT_EMPTY,
CheckInterfaces.INTERFACE_SHOULD_NOT_TAKE_ARGS,
CheckPrototypeProperties.ILLEGAL_PROTOTYPE_MEMBER);
public static final DiagnosticGroup CLOSURE_DEP_METHOD_USAGE_CHECKS =
DiagnosticGroups.registerGroup("closureDepMethodUsageChecks",
ProcessClosurePrimitives.INVALID_CLOSURE_CALL_ERROR);
static {
DiagnosticGroups.registerGroup("invalidProvide",
ProcessClosurePrimitives.INVALID_PROVIDE_ERROR);
import java.util.HashMap;
suggestion =
"Consider fixing errors for the following types:\n";
compiler.report(JSError.make(n, propertiesToErrorFor.get(name), Warnings.INVALIDATION,
name, (String.valueOf(type)), n.toString(), suggestion));
compiler.report(JSError.make(child, propertiesToErrorFor.get(name),
Warnings.INVALIDATION, name, (String.valueOf(type)), n.toString(), ""));
errors.add(t + " at " + error.sourceName + ":" + error.lineNumber);
newName = NONWORD_PATTERN.matcher(typeName).replaceAll("_") + '$'
+ name;
private final Map<FunctionType, Iterable<ObjectType>> implementedInterfaces;
implementedInterfaces = new HashMap<>();
if (objType == null) {
return;
FunctionType constructor;
if (objType.isFunctionType()) {
constructor = objType.toMaybeFunctionType();
constructor = objType.getOwnerFunction();
constructor = objType.getConstructor();
if (constructor == null) {
return;
Iterable<ObjectType> interfaces = implementedInterfaces.get(constructor);
if (interfaces == null) {
interfaces = constructor.getImplementedInterfaces();
implementedInterfaces.put(constructor, interfaces);
for (ObjectType itype : interfaces) {
JSType top = getTypeWithProperty(p.name, itype);
if (top != null) {
p.addType(itype, top, relatedType);
recordInterfaces(itype, relatedType, p);
if (p.skipRenaming) {
return;
edgeList[i] =
formatNodeName(keyParent) + ARROW + toNode + " [label=\"" + edge.getValue() + "\", "
+ "fontcolor=\"red\", "
+ "weight=0.01, color=\"red\"];\n";
import java.io.File;
static final String INDEX_FILE = "index.js";
static class LoadFailedException extends Exception {}
private final URI moduleRootURI;
this.moduleRootURI = new File(moduleRoot).toURI();
URI base = isRelativeIdentifier(name) ? createUri(referrer)
: createUri(moduleRoot);
return convertSourceUriToModuleAddress(base.resolve(createUri(name)));
private String resolveInFileSystem(String filename) {
File f = new File(filename);
if (f.exists() && f.isDirectory()) {
File index = new File(f, INDEX_FILE);
if (index.exists()) {
return moduleRootURI.relativize(index.toURI()).getPath();
return filename;
String filename = resolveInFileSystem(uri.normalize().toString());
package com.google.javascript.jscomp;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT;
import static com.google.javascript.jscomp.Es6ToEs3Converter.CANNOT_CONVERT_YET;
import static com.google.javascript.jscomp.Es6ToEs3Converter.getUniqueClassName;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
public class Es6ConvertSuper implements NodeTraversal.Callback, HotSwapCompilerPass {
static final DiagnosticType NO_SUPERTYPE = DiagnosticType.error(
"JSC_NO_SUPERTYPE",
"The super keyword may only appear in classes with an extends clause.");
private final AbstractCompiler compiler;
public Es6ConvertSuper(AbstractCompiler compiler) {
this.compiler = compiler;
private void checkClassSuperReferences(Node classNode) {
Node className = classNode.getFirstChild();
Node superClassName = className.getNext();
if (NodeUtil.referencesSuper(classNode) && superClassName.isEmpty()) {
compiler.report(JSError.make(classNode, NO_SUPERTYPE));
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
if (n.isClass()) {
boolean hasConstructor = false;
for (Node member = n.getLastChild().getFirstChild();
member != null;
member = member.getNext()) {
if (member.isGetterDef() || member.isSetterDef()
|| member.getBooleanProp(Node.COMPUTED_PROP_GETTER)
|| member.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
compiler.report(JSError.make(member, CANNOT_CONVERT,
"getters or setters in class definitions"));
return false;
if (member.isMemberDef() && member.getString().equals("constructor")) {
hasConstructor = true;
if (!hasConstructor) {
addSyntheticConstructor(n);
checkClassSuperReferences(n);
return true;
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isSuper()) {
visitSuper(n, parent);
private void addSyntheticConstructor(Node classNode) {
Node superClass = classNode.getFirstChild().getNext();
Node classMembers = classNode.getLastChild();
Node memberDef;
if (superClass.isEmpty()) {
memberDef = IR.memberDef("constructor",
IR.function(IR.name(""), IR.paramList(), IR.block()));
Node paramList = IR.paramList(IR.rest("args"));
Node body = IR.block(
IR.exprResult(IR.call(
IR.superNode(),
IR.spread(IR.name("args")))));
Node constructor = IR.function(
IR.name(""),
paramList,
body);
memberDef = IR.memberDef("constructor", constructor);
memberDef.useSourceInfoIfMissingFromForTree(classNode);
classMembers.addChildToFront(memberDef);
private void visitSuper(Node node, Node parent) {
Node enclosing = parent;
Node potentialCallee = node;
if (!parent.isCall()) {
enclosing = parent.getParent();
potentialCallee = parent;
if (!enclosing.isCall() || enclosing.getFirstChild() != potentialCallee) {
compiler.report(JSError.make(node, CANNOT_CONVERT_YET,
"Only calls to super or to a method of super are supported."));
return;
Node clazz = NodeUtil.getEnclosingClass(node);
if (clazz == null) {
compiler.report(JSError.make(node, NO_SUPERTYPE));
return;
if (NodeUtil.getClassNameNode(clazz) == null) {
return;
Node enclosingMemberDef = NodeUtil.getEnclosingClassMember(node);
if (enclosingMemberDef.isStaticMember()) {
Node superName = clazz.getFirstChild().getNext();
if (!superName.isQualifiedName()) {
return;
Node callTarget;
potentialCallee.detachFromParent();
if (potentialCallee == node) {
potentialCallee =
IR.getprop(superName.cloneTree(), IR.string(enclosingMemberDef.getString()));
enclosing.putBooleanProp(Node.FREE_CALL, false);
potentialCallee.replaceChild(node, superName.cloneTree());
callTarget = IR.getprop(potentialCallee, IR.string("call"));
enclosing.addChildToFront(callTarget);
enclosing.addChildAfter(IR.thisNode(), callTarget);
enclosing.useSourceInfoIfMissingFromForTree(enclosing);
compiler.reportCodeChange();
return;
String methodName;
Node callName = enclosing.removeFirstChild();
if (callName.isSuper()) {
methodName = enclosingMemberDef.getString();
methodName = callName.getLastChild().getString();
Node baseCall = baseCall(clazz, methodName, enclosing.removeChildren())
.useSourceInfoIfMissingFromForTree(enclosing);
enclosing.getParent().replaceChild(enclosing, baseCall);
compiler.reportCodeChange();
private Node baseCall(Node clazz, String methodName, Node arguments) {
boolean useUnique = NodeUtil.isStatement(clazz) && !NodeUtil.isInFunction(clazz);
String uniqueClassString = useUnique ? getUniqueClassName(NodeUtil.getClassName(clazz))
: NodeUtil.getClassName(clazz);
Node uniqueClassName = NodeUtil.newQName(compiler,
uniqueClassString);
Node base = IR.getprop(uniqueClassName, IR.string("base"));
Node call = IR.call(base, IR.thisNode(), IR.string(methodName));
if (arguments != null) {
call.addChildrenToBack(arguments);
return call;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverse(compiler, scriptRoot, this);
import java.util.HashSet;
import java.util.Set;
public class Es6RewriteGenerators extends NodeTraversal.AbstractPostOrderCallback
implements HotSwapCompilerPass {
NodeTraversal.traverse(compiler, root, new DecomposeYields(compiler));
NodeTraversal.traverse(compiler, scriptRoot, new DecomposeYields(compiler));
compiler.needsEs6Runtime = true;
initializer = IR.empty();
incr = IR.assign(IR.name(GENERATOR_DO_WHILE_INITIAL), IR.falseNode());
class DecomposeYields extends NodeTraversal.AbstractPreOrderCallback {
private final AbstractCompiler compiler;
private final ExpressionDecomposer decomposer;
public DecomposeYields(AbstractCompiler compiler) {
this.compiler = compiler;
Set<String> consts = new HashSet<>();
decomposer = new ExpressionDecomposer(
compiler, compiler.getUniqueNameIdSupplier(), consts,
Scope.createGlobalScope(new Node(Token.SCRIPT)));
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.YIELD:
visitYieldExpression(n);
break;
case Token.DO:
case Token.FOR:
case Token.WHILE:
visitLoop(n);
break;
case Token.CASE:
if (controlCanExit(n.getFirstChild())) {
compiler.report(JSError.make(currentStatement, Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Case statements that contain yields"));
return false;
break;
return true;
private void visitYieldExpression(Node n) {
if (n.getParent().isExprResult()) {
return;
if (decomposer.canExposeExpression(n)
!= ExpressionDecomposer.DecompositionType.UNDECOMPOSABLE) {
decomposer.exposeExpression(n);
compiler.reportCodeChange();
compiler.report(JSError.make(currentStatement, Es6ToEs3Converter.CANNOT_CONVERT,
"Undecomposable expression"));
private void visitLoop(Node n) {
Node enclosingFunc = NodeUtil.getEnclosingFunction(n);
if (enclosingFunc  == null || !enclosingFunc.isGeneratorFunction()
|| NodeUtil.isForIn(n)) {
return;
Node enclosingBlock = NodeUtil.getEnclosingType(n, Token.BLOCK);
Node guard = null, incr = null;
switch (n.getType()) {
case Token.FOR:
guard = n.getFirstChild().getNext();
incr = guard.getNext();
break;
case Token.WHILE:
guard = n.getFirstChild();
incr = IR.empty();
break;
case Token.DO:
guard = n.getLastChild();
if (!guard.isEmpty()) {
Node firstEntry = IR.name(GENERATOR_DO_WHILE_INITIAL);
enclosingBlock.addChildToFront(IR.var(firstEntry.cloneTree(), IR.trueNode()));
guard = IR.or(firstEntry, n.getLastChild().detachFromParent());
n.addChildToBack(guard);
incr = IR.empty();
break;
if (!controlCanExit(guard) && !controlCanExit(incr)) {
return;
Node guardName = IR.name(GENERATOR_LOOP_GUARD + generatorCounter.get());
if (!guard.isEmpty()) {
Node container = new Node(Token.BLOCK);
n.replaceChild(guard, container);
container.addChildToFront(IR.block(IR.exprResult(IR.assign(
guardName.cloneTree(), guard.cloneTree()))));
container.addChildToBack(guardName.cloneTree());
if (!incr.isEmpty()) {
n.addChildBefore(IR.block(IR.exprResult(incr.detachFromParent())), n.getLastChild());
enclosingBlock.addChildToFront(IR.var(guardName));
compiler.reportCodeChange();
if (functionHandledMap.containsEntry(function, name)) {
StringBuilder sb = new StringBuilder();
private final Set<String> classNames = new HashSet<>();
compiler.needsEs6Runtime = true;
Node enclosingFunction = NodeUtil.getEnclosingFunction(clazz);
boolean useUnique = NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
Preconditions.checkNotNull(constructor);
JSDocInfoBuilder newInfo = (classJSDoc != null)
? JSDocInfoBuilder.copyFrom(classJSDoc)
: new JSDocInfoBuilder(true);
compiler.needsEs6Runtime = true;
compiler.needsEs6Runtime = true;
static String getUniqueClassName(String qualifiedName) {
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
return call.getFirstChild() != null && JQUERY_EXPANDED_EACH_NAME.equals(qName);
NodeUtil.isValidPropertyName(LanguageMode.ECMASCRIPT3, prop.getString())) {
!NodeUtil.isValidPropertyName(LanguageMode.ECMASCRIPT3, prop.getString())) {
case Token.THROW:
case Token.FOR:
if (!NodeUtil.isForIn(parent) && child == parent.getFirstChild()) {
return parent;
throw new IllegalStateException("No other definitions can be inlined.");
return blockInlines <= 0 || costDeltaBlock <= 0;
Node root =
compiler.parseSyntheticCode(reducer.getClass() + ":helper", reducer.getHelperSource());
return value != null && value.isName() && value.getString().equals(paramNode.getString());
static final DiagnosticType INEXISTENT_PARAM = DiagnosticType.warning(
"JSC_INEXISTENT_PARAM",
Node errorRoot, Scope scope) {
if (!baseInterfaces.add(baseInterface)) {
reportWarning(SAME_INTERFACE_MULTIPLE_IMPLEMENTS, baseInterface.toString());
reportWarning(INEXISTENT_PARAM, inexistentName, formatFnName());
return !objectType.getImplicitPrototype().isResolved();
public GatherExternProperties(AbstractCompiler compiler) {
JSType type = n.getJSType();
if (type != null) {
typeVisitor.visitOnce(type);
if (n.isQualifiedName()) {
JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);
if (jsDoc != null && jsDoc.hasTypedefType()) {
JSType typedefType =
compiler.getTypeRegistry().getType(n.getQualifiedName());
if (typedefType != null) {
typeVisitor.visitOnce(typedefType);
if (seenTypes.add(type)) {
private static final String GLOBAL_THIS_NAMES[] = {
"window", "top", "goog$global", "goog.global" };
if (n.matchesQualifiedName(GLOBAL_THIS_NAMES[i])) {
return className != null;
stream.printf("%s: Added by %s%n", sym, passName);
stream.printf("%s: Removed by %s%n", sym, passName);
import com.google.javascript.jscomp.newtypes.JSTypes;
static final DiagnosticType STRUCTDICT_WITHOUT_CTOR = DiagnosticType.warning(
"JSC_STRUCTDICT_WITHOUT_CTOR",
"{0} used without @constructor.");
static final DiagnosticType EXPECTED_CONSTRUCTOR = DiagnosticType.warning(
"JSC_EXPECTED_CONSTRUCTOR",
"Expected constructor name but found {0}.");
static final DiagnosticType EXPECTED_INTERFACE = DiagnosticType.warning(
"JSC_EXPECTED_INTERFACE",
"Expected interface name but found {0}.");
"All constants must be typed. The compiler could not infer the type "
+ "of this constant. Please use an explicit type annotation.");
EXPECTED_CONSTRUCTOR,
EXPECTED_INTERFACE,
STRUCTDICT_WITHOUT_CTOR,
private JSTypes commonTypes;
this.commonTypes = JSTypes.make();
JSTypes getTypesUtilObject() {
return commonTypes;
globalScope =
new Scope(root, null, ImmutableList.<String>of(), commonTypes);
for (JSError warning : typeParser.getWarnings()) {
warnings.add(warning);
commonTypes.fromFunctionType(updatedMethodType.toFunctionType()));
maybeRecordAliasedNominalType(qnameNode);
maybeRecordAliasedNominalType(nameNode);
switch (expr.getType()) {
case Token.ASSIGN:
if (!expr.getFirstChild().isGetProp()) {
return;
expr = expr.getFirstChild();
case Token.GETPROP:
if (isPrototypeProperty(expr)
|| NodeUtil.referencesThis(expr)
|| !expr.isQualifiedName()) {
return;
processQualifiedDefinition(expr);
break;
case Token.CALL: {
List<String> decls = convention.identifyTypeDeclarationCall(expr);
if (decls == null || decls.isEmpty()) {
return;
currentScope.addUnknownTypeNames(decls);
break;
if (init != null && init.isQualifiedName()) {
EnumType et = currentScope.getEnum(init.getQualifiedName());
if (et != null) {
currentScope.addEnum(qnameNode, et);
return;
Scope fnScope = new Scope(fn, currentScope, formals, null);
if (!fn.isFromExterns()) {
scopes.add(fnScope);
maybeRecordBuiltinType(nameNode.getString(), rawNominalType);
warnings.add(JSError.make(fn, STRUCTDICT_WITHOUT_CTOR, "@struct"));
warnings.add(JSError.make(fn, STRUCTDICT_WITHOUT_CTOR, "@dict"));
private void maybeRecordBuiltinType(
String name, RawNominalType rawNominalType) {
switch (name) {
case "Function":
commonTypes.setFunctionType(rawNominalType);
break;
case "Object":
commonTypes.setObjectType(rawNominalType);
break;
case "Number":
commonTypes.setNumberInstance(rawNominalType.getInstanceAsJSType());
break;
case "String":
commonTypes.setStringInstance(rawNominalType.getInstanceAsJSType());
break;
case "Boolean":
commonTypes.setBooleanInstance(rawNominalType.getInstanceAsJSType());
break;
case "RegExp":
commonTypes.setRegexpInstance(rawNominalType.getInstanceAsJSType());
break;
case "Array":
commonTypes.setArrayType(rawNominalType);
break;
private void maybeRecordAliasedNominalType(Node nameNode) {
Preconditions.checkArgument(nameNode.isQualifiedName());
Node aliasedDef = nameNode.getParent();
Preconditions.checkState(aliasedDef.isVar() || aliasedDef.isAssign());
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(aliasedDef);
Node init = NodeUtil.getInitializer(nameNode);
RawNominalType rawType =
currentScope.getNominalType(QualifiedName.fromNode(init));
String initQname = init.getQualifiedName();
if (jsdoc.isConstructor()) {
if (rawType == null || rawType.isInterface()) {
warnings.add(JSError.make(init, EXPECTED_CONSTRUCTOR, initQname));
return;
if (rawType == null || !rawType.isInterface()) {
warnings.add(JSError.make(init, EXPECTED_INTERFACE, initQname));
return;
currentScope.addNominalType(nameNode, rawType);
currentScope.addLocal(
name, JSType.UNKNOWN, false, n.isFromExterns());
currentScope.addLocal(
name, JSType.UNKNOWN, false, n.isFromExterns());
boolean isConst = isConst(parent);
currentScope.addLocal(
name, declType, isConst, n.isFromExterns());
if (isAnnotatedAsConst(prop)) {
if (isAnnotatedAsConst(getProp) && currentScope.isPrototypeMethod()) {
if (isAnnotatedAsConst(getProp)) {
if (isNamedType(getProp)) {
return;
boolean isConst = isConst(getProp);
if (isConst) {
getProp.putBooleanProp(Node.CONSTANT_PROPERTY_DEF, true);
if (isNamedType(getProp)) {
EnumType et = currentScope.getEnum(recv.getQualifiedName());
if (et != null && et.enumLiteralHasKey(pname)) {
return;
boolean isConst = isConst(declNode);
if (declNode.isGetProp() && isConst) {
declNode.putBooleanProp(Node.CONSTANT_PROPERTY_DEF, true);
JSType t = initializer == null
? null : simpleInferExprType(initializer);
ns.addUndeclaredProperty(pname, t, false);
boolean isConst = isConst(getProp);
if (isConst) {
getProp.putBooleanProp(Node.CONSTANT_PROPERTY_DEF, true);
Preconditions.checkArgument(!currentScope.isNamespace(declNode));
return commonTypes.fromFunctionType(
return commonTypes.getRegexpType();
return commonTypes.getArrayInstance(arrayType);
Node recv = n.getFirstChild();
if (recv.isQualifiedName()) {
EnumType et = currentScope.getEnum(recv.getQualifiedName());
if (et != null
&& et.enumLiteralHasKey(n.getLastChild().getString())) {
return et.getEnumeratedType();
if (currentScope.isNamespace(recv)) {
return currentScope.lookupTypeByQname(QualifiedName.fromNode(n));
JSType recvType = simpleInferExprType(recv);
QualifiedName qname =
new QualifiedName(n.getLastChild().getString());
if (recvType != null && recvType.mayHaveProp(qname)) {
return recvType.getProp(qname);
return null;
case Token.NEW: {
.instantiateGenericsFromArgumentTypes(argTypes.build());
JSType retType =
n.isNew() ? funType.getThisType() : funType.getReturnType();
return retType;
RawNominalType ctorType =
declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
DeclaredFunctionType result = typeParser.getFunctionType(
fnDoc, functionName, declNode, ctorType, ownerType, parentScope);
ctorType.setCtorFunction(
result.toFunctionType(), commonTypes.getFunctionType());
if (initializer.getLastChild().hasChildren() && rawType.isInterface()) {
warnings.add(JSError.make(initializer.getLastChild(),
TypeCheck.INTERFACE_METHOD_NOT_EMPTY));
propDeclType =
commonTypes.fromFunctionType(methodType.toFunctionType());
propDeclType =
commonTypes.fromFunctionType(methodType.toFunctionType());
boolean isConst = isConst(defSite);
if (isConst) {
defSite.putBooleanProp(Node.CONSTANT_PROPERTY_DEF, true);
private boolean isNamedType(Node getProp) {
return currentScope.isNamespace(getProp)
|| NodeUtil.isTypedefDecl(getProp);
private JSType getTypeDeclarationFromJsdoc(JSDocInfo jsdoc, Scope s) {
return typeParser.getNodeTypeDeclaration(jsdoc, null, s);
private static boolean isAnnotatedAsConst(Node defSite) {
return NodeUtil.hasConstAnnotation(defSite)
&& !NodeUtil.getBestJSDocInfo(defSite).isConstructor();
private static Node fromDefsiteToName(Node defSite) {
if (defSite.isVar()) {
return defSite.getFirstChild();
if (defSite.isGetProp()) {
return defSite.getLastChild();
if (defSite.isStringKey()) {
return defSite;
throw new RuntimeException("Unknown defsite: "
+ Token.name(defSite.getType()));
private boolean isConst(Node defSite) {
return isAnnotatedAsConst(defSite)
|| NodeUtil.isConstantByConvention(
this.convention, fromDefsiteToName(defSite));
private final JSTypes commonTypes;
private final Map<String, JSType> externs;
private Set<String> unknownTypeNames = new HashSet<>();
private Scope(
Node root, Scope parent, List<String> formals, JSTypes commonTypes) {
this.externs = new HashMap<>();
this.externs = ImmutableMap.of();
this.commonTypes = commonTypes;
return isTopLevel() ? null : NodeUtil.getFunctionName(root);
private boolean isTopLevel() {
return parent == null;
private void addUnknownTypeNames(List<String> names) {
Preconditions.checkState(this.isTopLevel());
unknownTypeNames.addAll(names);
boolean isLocalExtern(String name) {
return externs.containsKey(name);
|| externs.containsKey(name)
return isFunction() && getDeclaredType().getThisType() != null;
private JSType lookupTypeByQname(QualifiedName qname) {
Preconditions.checkArgument(!qname.isIdentifier());
Namespace ns = getNamespace(qname.getLeftmostName());
if (ns == null) {
return null;
RawNominalType rawType = ns.getNominalType(qname.getAllButLeftmost());
if (rawType == null) {
return null;
return rawType.getInstanceAsJSType();
JSType type = lookupTypeByQname(QualifiedName.fromQname(name));
return type != null ? type : getUnresolvedTypeByName(name);
if (declaredType != null && declaredType.isTypeVariableInScope(name)) {
JSType t = getUnresolvedTypeByName(name);
if (t != null) {
return t;
JSType getUnresolvedTypeByName(String name) {
if (unknownTypeNames.contains(name)) {
return JSType.UNKNOWN;
return null;
public JSTypes getCommonTypes() {
if (isTopLevel()) {
return commonTypes;
return parent.getCommonTypes();
public JSType getDeclaredTypeOf(String name) {
return getDeclaredType().getThisType().getInstanceAsJSType();
Preconditions.checkState(!localType.isBottom(), "%s was bottom", name);
JSType externType = externs.get(name);
if (externType != null) {
Preconditions.checkState(!externType.isBottom());
return externType;
return getCommonTypes()
.fromFunctionType(s.getDeclaredType().toFunctionType());
return getCommonTypes()
.fromFunctionType(getDeclaredType().toFunctionType());
if (isDefinedLocally(name)) {
return null;
boolean isExternalFunction(String fnName) {
Scope s = Preconditions.checkNotNull(getScopeHelper(fnName));
return s.root.isFromExterns();
Set<String> getExterns() {
return ImmutableSet.copyOf(externs.keySet());
private void addLocal(String name, JSType declType,
boolean isConstant, boolean isFromExterns) {
if (isFromExterns) {
externs.put(name, declType);
locals.put(name, declType);
if (name == null) {
return null;
unknownTypeNames = null;
if (isTopLevel()) {
sb.append(root);
int lastSlash = name.lastIndexOf('/');
if (compiler.needsEs6Runtime) {
compiler.ensureLibraryInjected("es6_runtime", false);
static int getCost(Node root, int costThreshold) {
CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshold);
CompiledSizeEstimator(int costThreshold) {
this.maxCost = costThreshold;
import java.util.HashMap;
import java.util.LinkedHashMap;
class InlineFunctions implements CompilerPass {
private final Map<String, FunctionState> fns = new LinkedHashMap<>();
private final Map<Node, String> anonFns = new HashMap<>();
private final boolean enforceMaxSizeAfterInlining;
private final int maxSizeAfterInlining;
boolean assumeMinimumCapture,
int maxSizeAfterInlining) {
this.maxSizeAfterInlining = maxSizeAfterInlining;
this.enforceMaxSizeAfterInlining =
maxSizeAfterInlining != CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING;
compiler, safeNameIdSupplier, true, assumeStrictThis, assumeMinimumCapture);
trimCandidatesNotMeetingMinimumRequirements();
trimCandidatesUsingOnCost();
new CallVisitor(fns, anonFns, new Inline(injector)));
private static boolean isAlwaysInlinable(Node fn) {
Preconditions.checkArgument(fn.isFunction());
Node body = NodeUtil.getFunctionBody(fn);
int numOfStmsInBody = body.getChildCount();
return numOfStmsInBody == 0
|| numOfStmsInBody == 1 && body.getFirstChild().isReturn();
private boolean targetSizeAfterInlineExceedsLimit(
NodeTraversal t, FunctionState fs) {
Node containingFunction = getContainingFunction(t);
if (containingFunction == null) {
return false;
Node inlinedFun = fs.getFn().getFunctionNode();
if (isAlwaysInlinable(inlinedFun)) {
return false;
int inlinedFunSize = NodeUtil.countAstSizeUpToLimit(
NodeUtil.getFunctionBody(inlinedFun), maxSizeAfterInlining);
int targetFunSize = NodeUtil.countAstSizeUpToLimit(
containingFunction, maxSizeAfterInlining);
return inlinedFunSize + targetFunSize > maxSizeAfterInlining;
return;
Node fnNode = fn.getFunctionNode();
if (enforceMaxSizeAfterInlining
&& !isAlwaysInlinable(fnNode)
&& maxSizeAfterInlining
<= NodeUtil.countAstSizeUpToLimit(fnNode, maxSizeAfterInlining)) {
fs.setInline(false);
return;
if (fs.canInline()) {
fs.setFn(fn);
if (FunctionInjector.isDirectCallNodeReplacementPossible(
fn.getFunctionNode())) {
fs.inlineDirectly(true);
if (!isCandidateFunction(fn)) {
fs.setInline(false);
if (fs.canInline()) {
fs.setModule(module);
Set<String> namesToAlias =
FunctionArgumentInjector.findModifiedParameters(fnNode);
if (!namesToAlias.isEmpty()) {
fs.inlineDirectly(false);
fs.setNamesToAlias(namesToAlias);
Node block = NodeUtil.getFunctionBody(fnNode);
if (NodeUtil.referencesThis(block)) {
fs.setReferencesThis(true);
if (NodeUtil.containsFunction(block)) {
fs.setHasInnerFunctions(true);
if (!assumeMinimumCapture && hasLocalNames(fnNode)) {
if (fs.canInline() && !fs.canInlineDirectly()) {
if (!blockFunctionInliningEnabled) {
fs.setInline(false);
if (enforceMaxSizeAfterInlining
&& targetSizeAfterInlineExceedsLimit(t, fs)) {
return false;
private class Inline implements CallVisitorCallback {
Inline(FunctionInjector injector) {
private void trimCandidatesNotMeetingMinimumRequirements() {
private void trimCandidatesUsingOnCost() {
if (!inline) {
references = new LinkedHashMap<>();
if (inConstructor(t)) {
private boolean inConstructor(NodeTraversal t) {
return !isInvalidatingType(dest) && dest.isSubtype(src);
return NodeUtil.getStringValue(retVal) != null;
public final Node node;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
JsonArray toJson() {
JsonArray modules = new JsonArray();
JsonObject node = new JsonObject();
node.add("name", new JsonPrimitive(module.getName()));
JsonArray deps = new JsonArray();
node.add("dependencies", deps);
deps.add(new JsonPrimitive(m.getName()));
JsonArray transitiveDeps = new JsonArray();
node.add("transitive-dependencies", transitiveDeps);
transitiveDeps.add(new JsonPrimitive(m.getName()));
JsonArray inputs = new JsonArray();
node.add("inputs", inputs);
inputs.add(new JsonPrimitive(
input.getSourceFile().getOriginalPath()));
modules.add(node);
ImmutableList.Builder<CompilerInput> result = ImmutableList.builder();
return result.build();
import static java.nio.charset.StandardCharsets.UTF_8;
return hash64(value.getBytes(UTF_8), seed);
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
DiagnosticType.warning("JSC_MSG_NOT_INITIALIZED_USING_NEW_SYNTAX",
case Token.STRING_KEY:
if (node.isQuotedString() || node.getFirstChild() == null) {
return;
isVar = false;
messageKey = node.getString();
msgNode = node.getFirstChild();
break;
compiler.report(traversal.makeError(node,
if (style == JsMessage.Style.CLOSURE) {
return;
out.printf("\t%s jit time: %d ms%n", name, cBean.getTotalCompilationTime());
return name.replace(' ', '_').toLowerCase();
return n.isName() && n.getString().equals(ARGUMENT_ARRAY_ALIAS)
&& !jsScope.isDeclared(ARGUMENT_ARRAY_ALIAS, false);
public static String getOriginalName(String name) {
if (containsSeparator(name) && !getOriginalName(name).isEmpty()) {
String original = getOriginalName(name);
newName = original + ContextualRenamer.UNIQUE_ID_SEPARATOR + i++;
return TokenStream.isJSIdentifier(name) && !referencedNames.contains(name)
&& !name.equals(ARGUMENTS);
return "Definition@" + node;
import com.google.common.base.Predicates;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
private LinkedDirectedGraph<JsName, RefType> referenceGraph =
if ((parent.isName() || parent.isAssign()) && !isPrototypePropAssignment && referring != null
&& scopes.containsEntry(parent, referring)) {
referenceGraph.connectIfNotConnectedInDirection(from, depType, to);
private void recordReference(
DiGraphNode<JsName, RefType> from,
DiGraphNode<JsName, RefType> to,
RefType depType) {
if (from == to) {
return;
if (!referenceGraph.isConnectedInDirection(from, Predicates.equalTo(depType), to)) {
if (!node.prototypeNames.isEmpty()) {
if (!refersTo.isEmpty()) {
if (!referencedBy.isEmpty()) {
Set<AliasSet> sets = new HashSet<>(aliases.values());
for (AliasSet set : sets) {
DiGraphNode<JsName, RefType> first = null;
Set<DiGraphNode<JsName, RefType>> required = new HashSet<>();
for (String key : set.names) {
JsName name = getName(key, false);
if (name.hasWrittenDescendants || name.hasInstanceOfReference) {
DiGraphNode<JsName, RefType> node = getGraphNode(name);
required.add(node);
if (first == null) {
first = node;
if (!required.isEmpty()) {
for (DiGraphNode<JsName, RefType> node : required) {
recordReference(node, first, RefType.REGULAR);
recordReference(first, node, RefType.REGULAR);
for (String key : set.names) {
DiGraphNode<JsName, RefType> alias = getGraphNode(getName(key, false));
recordReference(alias, first, RefType.REGULAR);
private DiGraphNode<JsName, RefType> getGraphNode(JsName name) {
return referenceGraph.createDirectedGraphNode(name);
if (curName.contains(".")) {
DiGraphNode<JsName, RefType> nameNode = getGraphNode(name);
DiGraphNode<JsName, RefType> parentNode = getGraphNode(parentJsName);
recordReference(nameNode, parentNode, RefType.REGULAR);
recordReference(parentNode, nameNode, RefType.REGULAR);
propagateReference(window, function);
private void propagateReference(JsName ... names) {
Deque<DiGraphNode<JsName, RefType>> work = new ArrayDeque<>();
for (JsName name : names) {
work.push(referenceGraph.createDirectedGraphNode(name));
while (!work.isEmpty()) {
DiGraphNode<JsName, RefType> source = work.pop();
List<DiGraphEdge<JsName, RefType>> outEdges = source.getOutEdges();
int len = outEdges.size();
for (int i = 0; i < len; i++) {
DiGraphNode<JsName, RefType> item = outEdges.get(i).getDestination();
JsName destNode = item.getValue();
if (!destNode.referenced) {
destNode.referenced = true;
work.push(item);
boolean nodeIsClass = !name.prototypeNames.isEmpty();
boolean classMatch =
isClass == TriState.BOTH || (nodeIsClass && isClass == TriState.TRUE)
int occurrence;
this.occurrence = 0;
int result = other.occurrence - this.occurrence;
c.occurrence++;
result.addAll(referenceMap.get(site));
public Reference(Node site) {
Reference reference = new Reference(n);
Reference ref = new Reference(n);
Reference ref = new Reference(n);
if (!outEdges.isEmpty()) {
if (!inEdges.isEmpty()) {
builder.append(" (type: " + defType + ") ");
import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;
import com.google.javascript.jscomp.CodingConvention.Bind;
import com.google.javascript.jscomp.newtypes.JSTypes;
static final DiagnosticType NULLABLE_DEREFERENCE =
DiagnosticType.warning(
"JSC_NULLABLE_DEREFERENCE",
"Attempt to use nullable type {0}.");
static final DiagnosticType ASSERT_FALSE =
DiagnosticType.warning(
"JSC_ASSERT_FALSE",
"Assertion is always false. Please use a throw or fail() instead.");
static final DiagnosticType UNKNOWN_ASSERTION_TYPE =
DiagnosticType.warning(
"JSC_UNKNOWN_ASSERTION_TYPE",
"Assert with unknown asserted type.");
static final DiagnosticType INVALID_THIS_TYPE_IN_BIND =
DiagnosticType.warning(
"JSC_INVALID_THIS_TYPE_IN_BIND",
"The first argument to bind has type {0} which is not a subtype of"
+ " {1}.");
static final DiagnosticType CANNOT_BIND_CTOR =
DiagnosticType.warning(
"JSC_CANNOT_BIND_CTOR",
"We do not support using .bind on constructor functions.");
static final DiagnosticType GOOG_BIND_EXPECTS_FUNCTION =
DiagnosticType.warning(
"JSC_GOOG_BIND_EXPECTS_FUNCTION",
"The first argument to goog.bind/goog.partial must be a function.");
ASSERT_FALSE,
CANNOT_BIND_CTOR,
GOOG_BIND_EXPECTS_FUNCTION,
INVALID_THIS_TYPE_IN_BIND,
NULLABLE_DEREFERENCE,
UNKNOWN_ASSERTION_TYPE,
private final CodingConvention convention;
private Map<DiGraphEdge<Node, ControlFlowGraph.Branch>, TypeEnv> envs;
private Map<Scope, JSType> summaries;
private Map<Node, DeferredCheck> deferredChecks;
private ControlFlowGraph<Node> cfg;
private Scope currentScope;
private GlobalTypeInfo symbolTable;
private JSTypes commonTypes;
private static final String RETVAL_ID = "%return";
private static final String GETTER_PREFIX = "%getter_fun";
private static final String SETTER_PREFIX = "%setter_fun";
private final String ABSTRACT_METHOD_NAME;
private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;
this.convention = compiler.getCodingConvention();
this.ABSTRACT_METHOD_NAME = convention.getAbstractMethodName();
assertionFunctionsMap = new HashMap<>();
for (AssertionFunctionSpec assertionFunction :
convention.getAssertionFunctions()) {
assertionFunctionsMap.put(assertionFunction.getFunctionName(),
assertionFunction);
commonTypes = symbolTable.getTypesUtilObject();
message += "\nIn scope: " + currentScope;
if (commonTypes.getArrayInstance().isUnknown() // no externs
return t.isSubtypeOf(commonTypes.getArrayInstance());
b.append(obj);
System.out.println(b);
Set<String> nonLocals = new HashSet<>();
nonLocals.add(currentScope.getName());
nonLocals.addAll(currentScope.getOuterVars());
nonLocals.addAll(currentScope.getFormals());
nonLocals.add("this");
nonLocals.addAll(currentScope.getExterns());
for (String name : nonLocals) {
JSType declType = currentScope.getDeclaredTypeOf(name);
JSType initType = declType == null
? envGetType(entryEnv, name) : pickInitialType(declType);
entryEnv = envPutType(entryEnv, name, initType);
JSType summaryType = getSummaryOfLocalFunDef(fnName);
summaryType = fnType.createConstructorObject(commonTypes.getFunctionType());
varNames.addAll(currentScope.getExterns());
JSType summaryType = getSummaryOfLocalFunDef(fnName);
summaryType = fnType.createConstructorObject(commonTypes.getFunctionType());
private JSType getSummaryOfLocalFunDef(String name) {
JSType summaryType = summaries.get(currentScope.getScope(name));
if (summaryType == null) {
summaryType = currentScope.getDeclaredTypeOf(name);
return summaryType;
private JSType pickInitialType(JSType declType) {
return funType.createConstructorObject(commonTypes.getFunctionType());
!commonTypes.isStringScalarOrObj(lval.declType)) {
if (declRetType != null) {
builder.addRetType(actualRetType);
builder.addRetType(JSType.UNKNOWN);
JSType summary = commonTypes.fromFunctionType(builder.buildFunction());
case Token.POS: {
EnvTypePair pair = analyzeExprFwd(expr.getFirstChild(), inEnv);
pair.type = JSType.NUMBER;
return pair;
return new EnvTypePair(inEnv, commonTypes.getRegexpType());
currentScope.isLocalExtern(varName) ||
if (!commonTypes.isNumberScalarOrObj(pair.type)) {
ctorPair = analyzeExprFwd(ctor, objPair.env, commonTypes.topFunction());
(!ctorType.isSubtypeOf(commonTypes.topFunction()) ||
!ctorFunType.isQmarkFunction() && !ctorFunType.isConstructor())) {
JSType instanceType = ctorFunType.getInstanceTypeOfCtor();
JSType instanceSpecType = specializedType.isTruthy()
? objPair.type.specialize(instanceType)
: objPair.type.removeType(instanceType);
if (!instanceSpecType.isBottom()) {
objPair = analyzeExprFwd(obj, inEnv, JSType.UNKNOWN, instanceSpecType);
ctorPair = analyzeExprFwd(ctor, objPair.env, commonTypes.topFunction());
if (lhsType.isString() || rhsType.isString()) {
rhsPair.type = JSType.STRING;
return rhsPair;
if (!commonTypes.isNumStrScalarOrObj(lhsType)) {
if (!commonTypes.isNumStrScalarOrObj(rhsType)) {
if (!commonTypes.isNumberScalarOrObj(lhsPair.type)) {
if (!commonTypes.isNumberScalarOrObj(rhsPair.type)) {
if (rhs.matchesQualifiedName(ABSTRACT_METHOD_NAME)) {
return new EnvTypePair(inEnv, requiredType);
if (!commonTypes.isNumberScalarOrObj(lhsType)) {
if (!commonTypes.isNumberScalarOrObj(pair.type)) {
warnInvalidOperand(expr, expr.getType(), "matching scalar types", lhsType + ", " + rhsType);
if (isFunctionBind(callee, inEnv, true)) {
return analyzeFunctionBindFwd(expr, inEnv);
AssertionFunctionSpec assertionFunctionSpec =
assertionFunctionsMap.get(callee.getQualifiedName());
if (assertionFunctionSpec != null) {
return analyzeAssertionCall(expr, inEnv, assertionFunctionSpec);
analyzeExprFwd(callee, inEnv, commonTypes.topFunction());
calleePair = mayWarnAboutNullableReferenceAndTighten(
callee, calleePair.type, inEnv, commonTypes.topFunction());
if (!calleeType.isSubtypeOf(commonTypes.topFunction())) {
return analyzeCallNodeArgsFwdWhenError(expr, inEnv);
&& funType.getReturnType().isUnknown()) {
return analyzeCallNodeArgsFwdWhenError(expr, inEnv);
return analyzeCallNodeArgsFwdWhenError(expr, inEnv);
expr, TypeCheck.WRONG_ARGUMENT_COUNT,
getReadableCalleeName(callee),
return analyzeCallNodeArgsFwdWhenError(expr, inEnv);
Map<String, JSType> typeMap = calcTypeInstantiationFwd(
expr, expr.getChildAtIndex(1), funType, inEnv);
TypeEnv tmpEnv = analyzeCallNodeArgumentsFwd(
expr, expr.getChildAtIndex(1), funType, argTypes, inEnv);
if (currentScope.isKnownFunction(calleeName)
&& !currentScope.isExternalFunction(calleeName)) {
JSType retType =
expr.isNew() ? funType.getThisType() : funType.getReturnType();
private EnvTypePair analyzeFunctionBindFwd(Node call, TypeEnv inEnv) {
Preconditions.checkArgument(call.isCall());
Bind bindComponents = convention.describeFunctionBind(call, true, false);
Node boundFunNode = bindComponents.target;
EnvTypePair pair = analyzeExprFwd(boundFunNode, inEnv);
TypeEnv env = pair.env;
FunctionType boundFunType = pair.type.getFunTypeIfSingletonObj();
if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
warnings.add(JSError.make(boundFunNode, GOOG_BIND_EXPECTS_FUNCTION));
if (boundFunType == null
|| boundFunType.isTopFunction()
|| boundFunType.isQmarkFunction()
|| boundFunType.isLoose()) {
return analyzeCallNodeArgsFwdWhenError(call, env);
if (boundFunType.isConstructor()) {
warnings.add(JSError.make(call, CANNOT_BIND_CTOR));
return new EnvTypePair(env, JSType.UNKNOWN);
if (isGoogBind(call) && call.getChildCount() <= 2
|| !isGoogPartial(call) && call.getChildCount() == 1) {
warnings.add(JSError.make(
call, TypeCheck.WRONG_ARGUMENT_COUNT,
getReadableCalleeName(call.getFirstChild()),
"0", "1", ""));
int maxArity = boundFunType.hasRestFormals()
? Integer.MAX_VALUE : boundFunType.getMaxArity();
int numArgs = bindComponents.getBoundParameterCount();
if (numArgs > maxArity) {
warnings.add(JSError.make(
call, TypeCheck.WRONG_ARGUMENT_COUNT,
getReadableCalleeName(call.getFirstChild()),
Integer.toString(numArgs), "0",
" and at most " + maxArity));
return analyzeCallNodeArgsFwdWhenError(call, inEnv);
if (boundFunType.isGeneric()) {
Map<String, JSType> typeMap = calcTypeInstantiationFwd(
call, bindComponents.parameters, boundFunType, env);
boundFunType = boundFunType.instantiateGenerics(typeMap);
FunctionTypeBuilder builder = new FunctionTypeBuilder();
Node receiver = bindComponents.thisValue;
if (receiver != null) {// receiver is null for goog.partial
JSType reqThisType = boundFunType.getThisType();
if (reqThisType == null || boundFunType.isConstructor()) {
reqThisType = JSType.join(JSType.NULL, JSType.TOP_OBJECT);
pair = analyzeExprFwd(receiver, env, reqThisType);
env = pair.env;
if (!pair.type.isSubtypeOf(reqThisType)) {
warnings.add(JSError.make(call, INVALID_THIS_TYPE_IN_BIND,
pair.type.toString(), reqThisType.toString()));
env = analyzeCallNodeArgumentsFwd(call, bindComponents.parameters,
boundFunType, new ArrayList<JSType>(), env);
for (int j = numArgs; j < boundFunType.getMaxArity(); j++) {
JSType formalType = boundFunType.getFormalType(j);
if (boundFunType.isRequiredArg(j)) {
builder.addReqFormal(formalType);
builder.addOptFormal(formalType);
builder.addRestFormals(formalType);
break; // To avoid iterating to Integer.MAX_VALUE
return new EnvTypePair(env, commonTypes.fromFunctionType(
builder.addRetType(boundFunType.getReturnType()).buildFunction()));
private TypeEnv analyzeCallNodeArgumentsFwd(Node call, Node firstArg,
FunctionType funType, List<JSType> argTypesForDeferredCheck,
TypeEnv inEnv) {
TypeEnv env = inEnv;
Node arg = firstArg;
int i = 0;
while (arg != null) {
JSType formalType = funType.getFormalType(i);
if (formalType.isBottom()) {
warnings.add(JSError.make(call, CALL_FUNCTION_WITH_BOTTOM_FORMAL,
Integer.toString(i)));
formalType = JSType.UNKNOWN;
EnvTypePair pair = analyzeExprFwd(arg, env, formalType);
JSType argTypeForDeferredCheck = pair.type;
if (funType.isOptionalArg(i) && pair.type.equals(JSType.UNDEFINED)) {
argTypeForDeferredCheck = null; // No deferred check needed.
warnings.add(JSError.make(arg, INVALID_ARGUMENT_TYPE,
Integer.toString(i + 1), "",
formalType.toString(), pair.type.toString()));
argTypeForDeferredCheck = null; // No deferred check needed.
argTypesForDeferredCheck.add(argTypeForDeferredCheck);
env = pair.env;
arg = arg.getNext();
i++;
return env;
private EnvTypePair analyzeAssertionCall(
Node callNode, TypeEnv env, AssertionFunctionSpec assertionFunctionSpec) {
Node left = callNode.getFirstChild();
Node firstParam = left.getNext();
if (firstParam == null) {
return new EnvTypePair(env, JSType.UNKNOWN);
Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);
if (assertedNode == null) {
return new EnvTypePair(env, JSType.UNKNOWN);
JSType assertedType =
assertionFunctionSpec.getAssertedNewType(callNode, currentScope);
if (assertedType.isUnknown()) {
warnings.add(
JSError.make(callNode, NewTypeInference.UNKNOWN_ASSERTION_TYPE));
EnvTypePair pair =
analyzeExprFwd(assertedNode, env, JSType.UNKNOWN, assertedType);
if (pair.type.isBottom()) {
warnings.add(JSError.make(assertedNode, NewTypeInference.ASSERT_FALSE));
pair.type = JSType.UNKNOWN;
pair.env = env;
return pair;
pair = mayWarnAboutNullableReferenceAndTighten(
receiver, pair.type, pair.env, JSType.TOP_OBJECT);
JSType recvType = pair.type.autobox(commonTypes);
if (!commonTypes.isNumberScalarOrObj(pair.type)) {
return new EnvTypePair(env, commonTypes.getArrayInstance(elementType));
private EnvTypePair analyzeCallNodeArgsFwdWhenError(
private JSType getTypeFromString(Node typeString) {
return commonTypes.looseTopFunction();
Node callNode, Node firstArg, FunctionType funType, TypeEnv typeEnv) {
return calcTypeInstantiation(callNode, firstArg, funType, typeEnv, true);
return calcTypeInstantiation(
callNode, callNode.getChildAtIndex(1), funType, typeEnv, false);
private ImmutableMap<String, JSType> calcTypeInstantiation(Node callNode,
Node firstArg, FunctionType funType, TypeEnv typeEnv, boolean isFwd) {
Node arg = firstArg;
EnvTypePair pair =
isFwd ? analyzeExprFwd(arg, typeEnv) : analyzeExprBwd(arg, typeEnv);
JSType targetAfterInstantiation =
unifTarget.substituteGenerics(tmpTypeMap);
if (!unifTarget.equals(targetAfterInstantiation)
&& unifSource.isSubtypeOf(targetAfterInstantiation)) {
return analyzeCallNodeArgsFwdWhenError(call, inEnv);
JSType arrayType = commonTypes.getArrayInstance();
? commonTypes.looseTopFunction()
: beforeType.removeType(commonTypes.topFunction());
warnings.add(JSError.make(receiver, PROPERTY_ACCESS_ON_NONOBJECT,
pname, recvType.toString()));
!propAccess.getBooleanProp(Node.CONSTANT_PROPERTY_DEF)) {
JSType reqObjType = pickReqObjType(propAccessNode).withLoose();
JSType recvReqType, recvSpecType;
recvSpecType = reqObjType.withProperty(propQname, requiredType);
recvReqType = reqObjType.withProperty(propQname, requiredType);
recvSpecType = reqObjType.withProperty(propQname, specializedType);
pair = mayWarnAboutNullableReferenceAndTighten(
receiver, pair.type, pair.env, JSType.TOP_OBJECT);
JSType recvType = pair.type.autobox(commonTypes);
if (convention.isSuperClassReference(pname)) {
FunctionType ft = recvType.getFunTypeIfSingletonObj();
if (ft != null && ft.isConstructor()) {
JSType result = ft.getSuperPrototype();
pair.type = result != null ? result : JSType.UNDEFINED;
return pair;
if (recvType.isTop()) {
recvType = JSType.TOP_OBJECT;
JSType looseFunctionType = commonTypes.fromFunctionType(
builder.addRetType(looseRetType).addLoose().buildFunction());
callee, tmpEnv, commonTypes.topFunction(), looseFunctionType);
JSType looseFunctionType = commonTypes.fromFunctionType(
builder.addRetType(looseRetType).addLoose().buildFunction());
Preconditions.checkArgument(requiredType != null, "Required type null at: %s", expr);
case Token.POS: {
EnvTypePair pair = analyzeExprBwd(expr.getFirstChild(), outEnv);
pair.type = JSType.NUMBER;
return pair;
expr.getLastChild(), outEnv, commonTypes.topFunction()).env;
return new EnvTypePair(outEnv, commonTypes.getRegexpType());
Preconditions.checkArgument(expr.isNew() || expr.isCall());
analyzeExprBwd(callee, outEnv, commonTypes.topFunction()).type;
JSType retType =
expr.isNew() ? funType.getThisType() : funType.getReturnType();
return new EnvTypePair(tmpEnv, retType);
Preconditions.checkState(
isArrayType(arrayType), "Expected array but found %s", arrayType);
return new EnvTypePair(env, commonTypes.getArrayInstance(elementType));
if (currentScope.isKnownFunction(calleeName)
&& !currentScope.isLocalFunDef(calleeName)
&& !currentScope.isExternalFunction(calleeName)) {
pickReqObjType(receiver.getParent()).withLoose()
.withProperty(qname, requiredType));
return expr.getFirstChild().isQualifiedName()
&& convention.isPropertyTestFunction(expr);
private boolean isGoogBind(Node n) {
return n.isCall()
&& n.getFirstChild().isQualifiedName()
&& n.getFirstChild().matchesQualifiedName("goog.bind");
private boolean isGoogPartial(Node n) {
return n.isCall()
&& n.getFirstChild().isQualifiedName()
&& n.getFirstChild().matchesQualifiedName("goog.partial");
private boolean isFunctionBind(Node expr, TypeEnv env, boolean isFwd) {
if (!expr.isGetProp()) {
return false;
Node recv = expr.getFirstChild();
if (!recv.isFunction() && !recv.isQualifiedName()) {
return false;
if (isGoogBind(expr.getParent()) || isGoogPartial(expr.getParent())) {
return true;
if (!expr.getLastChild().getString().equals("bind")) {
JSType recvType = isFwd
? analyzeExprFwd(recv, env).type : analyzeExprBwd(recv, env).type;
return !recvType.isUnknown()
&& recvType.isSubtypeOf(commonTypes.topFunction());
case Token.GETPROP: {
Node obj = expr.getFirstChild();
QualifiedName pname =
new QualifiedName(expr.getLastChild().getString());
return analyzePropLValFwd(obj, pname, inEnv, type, insideQualifiedName);
Node obj = expr.getFirstChild();
Node prop = expr.getLastChild();
if (prop.isString()) {
QualifiedName pname = new QualifiedName(prop.getString());
return analyzePropLValFwd(
obj, pname, inEnv, type, insideQualifiedName);
LValueResultFwd lvalue =
analyzeLValueFwd(obj, inEnv, JSType.UNKNOWN, true);
if (isArrayType(lvalue.type)) {
return analyzeArrayElmLvalFwd(prop, lvalue);
EnvTypePair pair = analyzeExprFwd(expr, inEnv, type);
return new LValueResultFwd(pair.env, pair.type, null, null);
private LValueResultFwd analyzeArrayElmLvalFwd(
Node prop, LValueResultFwd lvalue) {
EnvTypePair pair = analyzeExprFwd(prop, lvalue.env, JSType.NUMBER);
if (!pair.type.equals(JSType.NUMBER)) {
return new LValueResultFwd(pair.env, JSType.UNKNOWN, null, null);
JSType inferred = getArrayElementType(lvalue.type);
JSType declared = null;
if (lvalue.declType != null) {
JSType receiverAdjustedDeclType =
lvalue.declType.removeType(JSType.NULL_OR_UNDEF);
if (isArrayType(receiverAdjustedDeclType)) {
declared = getArrayElementType(receiverAdjustedDeclType);
return new LValueResultFwd(pair.env, inferred, declared, null);
private EnvTypePair mayWarnAboutNullableReferenceAndTighten(
Node obj, JSType recvType, TypeEnv inEnv, JSType requiredType) {
if (!recvType.isUnknown()
&& (JSType.NULL.isSubtypeOf(recvType)
|| JSType.UNDEFINED.isSubtypeOf(recvType))) {
JSType minusNull = recvType.removeType(JSType.NULL_OR_UNDEF);
if (!minusNull.isBottom() && minusNull.isSubtypeOf(requiredType)) {
warnings.add(JSError.make(
obj, NULLABLE_DEREFERENCE, recvType.toString()));
TypeEnv outEnv = inEnv;
if (obj.isQualifiedName()) {
QualifiedName qname = QualifiedName.fromNode(obj);
outEnv = updateLvalueTypeInEnv(inEnv, obj, qname, minusNull);
return new EnvTypePair(outEnv, minusNull);
return new EnvTypePair(inEnv, recvType);
private LValueResultFwd analyzePropLValFwd(Node obj, QualifiedName pname,
TypeEnv inEnv, JSType type, boolean insideQualifiedName) {
Preconditions.checkArgument(pname.isIdentifier());
JSType reqObjType =
pickReqObjType(obj.getParent()).withLoose().withProperty(pname, type);
LValueResultFwd lvalue = analyzeLValueFwd(obj, inEnv, reqObjType, true);
EnvTypePair pair = mayWarnAboutNullableReferenceAndTighten(
obj, lvalue.type, lvalue.env, JSType.TOP_OBJECT);
TypeEnv lvalueEnv = pair.env;
JSType lvalueType = pair.type.autobox(commonTypes);
pnameAsString, lvalueType.toString()));
Node propAccessNode = obj.getParent();
if (propAccessNode.isGetProp() &&
propAccessNode.getParent().isAssign() &&
mayWarnAboutPropCreation(pname, propAccessNode, lvalueType)) {
mayWarnAboutConstProp(propAccessNode, lvalueType, pname)) {
if (!lvalueType.hasProp(pname)) {
if (lvalueType.isDict() && propAccessNode.isGetProp()) {
propAccessNode.getParent().getType() != Token.ASSIGN;
DiagnosticType dt = lvalueType.mayHaveProp(pname)
? POSSIBLY_INEXISTENT_PROPERTY : TypeCheck.INEXISTENT_PROPERTY;
warnings.add(
JSError.make(obj, dt, pnameAsString, lvalueType.toString()));
if (propAccessNode.isGetElem()) {
pickReqObjType(obj.getParent()).withLoose().withProperty(pname, type);
case Token.GETPROP:
return JSType.TOP_STRUCT;
default:
private static String getReadableCalleeName(Node expr) {
return expr.isQualifiedName() ? expr.getQualifiedName() : "";
private final boolean useBlockScope;
this.useBlockScope = scopeCreator.hasBlockScope();
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
import java.util.LinkedHashMap;
import java.util.List;
static final long MAX_POSITIVE_INTEGER_NUMBER = 1L << 53;
Preconditions.checkState(clazz.isClass());
return getNameNode(clazz);
return getNameNode(n);
static String getFunctionName(Node n) {
Node nameNode = getFunctionNameNode(n);
return nameNode == null ? null : nameNode.getQualifiedName();
private static Node getNameNode(Node n) {
return (funNameNode.isEmpty() || funNameNode.getString().isEmpty())
? null : funNameNode;
case Token.AND:
case Token.OR:
static boolean isAliasedNominalTypeDecl(Node n) {
if (n.isName()) {
n = n.getParent();
if (n.isVar() && n.getChildCount() == 1) {
Node name = n.getFirstChild();
Node init = name.getFirstChild();
JSDocInfo jsdoc = getBestJSDocInfo(n);
return jsdoc != null
&& (jsdoc.isConstructor() || jsdoc.isInterface())
&& init != null
&& init.isQualifiedName();
Node parent = n.getParent();
if (n.isGetProp() && n.isQualifiedName()
&& parent.isAssign() && parent.getParent().isExprResult()) {
JSDocInfo jsdoc = getBestJSDocInfo(n);
return jsdoc != null
&& (jsdoc.isConstructor() || jsdoc.isInterface())
&& parent.getLastChild().isQualifiedName();
return false;
if (jsdoc == null || !jsdoc.isConstant()
|| !jsdoc.getTypeNodes().isEmpty()) {
case Token.YIELD:
return !nameNode.isName() || !CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString());
case Token.YIELD:
case Token.YIELD:
static boolean isInFunction(Node n) {
return getEnclosingFunction(n) != null;
switch (n.getType()) {
case Token.BLOCK:
Node parent = n.getParent();
if (parent == null || parent.isCatch()) {
return false;
Node child = n.getFirstChild();
return child != null && !child.isScript();
case Token.FOR:
case Token.FOR_OF:
return true;
return false;
throw new IllegalStateException("Invalid attempt to remove node: " + node + " of " + parent);
public static boolean isValidQualifiedName(String name) {
return isValidQualifiedName(LanguageMode.ECMASCRIPT3, name);
public static boolean isValidQualifiedName(LanguageMode mode, String name) {
List<String> parts = Splitter.on('.').splitToList(name);
for (String part : parts) {
if (!isValidPropertyName(mode, part)) {
return isValidSimpleName(parts.get(0));
static boolean isValidPropertyName(String name) {
return isValidSimpleName(name);
static boolean isValidPropertyName(LanguageMode mode, String name) {
if (isValidSimpleName(name)) {
return true;
return mode.isEs5OrHigher() && TokenStream.isKeyword(name);
final Map<String, Node> vars = new LinkedHashMap<>();
public static boolean isPrototypePropertyDeclaration(Node n) {
public static interface Visitor {
public static void visitPreOrder(Node node,
CodingConvention convention, Node node) {
Node parent = node.getParent();
return NodeUtil.isConstantByConvention(convention, node);
return node.isQualifiedName()
&& NodeUtil.isConstantByConvention(convention, node.getLastChild());
return (expr == parent.getFirstChild()) || isExpressionResultUsed(parent);
return (n.isName() && n.getString().equals("NaN")) || (n.getType() == Token.DIV
&& n.getFirstChild().isNumber() && n.getFirstChild().getDouble() == 0
&& n.getLastChild().isNumber() && n.getLastChild().getDouble() == 0);
static int countAstSizeUpToLimit(Node n, final int limit) {
final int[] wrappedSize = {0};
visitPreOrder(
n,
new Visitor() {
public void visit(Node n) {
wrappedSize[0]++;
new Predicate<Node>() {
public boolean apply(Node n) {
return wrappedSize[0] < limit;
return wrappedSize[0];
NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n);
|| NodeUtil.isConstantByConvention(convention, n)) {
compiler.getCodingConvention(), n)) {
name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(
import java.util.ArrayDeque;
private final Deque<List<Node>> argumentsAccessStack = new ArrayDeque<>();
if (!passes.isEmpty()) {
return obj.isName();
return n.getParent().isAdd();
case Token.ASSIGN_SUB:
return reduceSubstractionAssignment(node);
Bind bind = getCodingConvention()
.describeFunctionBind(callTarget, false, false);
private Node reduceSubstractionAssignment(Node n) {
Node right = n.getLastChild();
if (right.isNumber()) {
if (right.getDouble() == 1) {
Node newNode = IR.dec(n.removeFirstChild(), false);
n.getParent().replaceChild(n, newNode);
reportCodeChange();
return newNode;
Node newNode = IR.inc(n.removeFirstChild(), false);
n.getParent().replaceChild(n, newNode);
reportCodeChange();
return newNode;
return n;
import static java.nio.charset.StandardCharsets.UTF_8;
OutputStreamWriter output = new OutputStreamWriter(pstr, UTF_8);
statEntries.addAll(summary.entrySet());
Collections.sort(statEntries, new Comparator<Entry<String, Stats>>() {
public int compare(Entry<String, Stats> e1, Entry<String, Stats> e2) {
return (int) (e1.getValue().runtime - e2.getValue().runtime);
output.write("\nTOTAL:"
+ "\nRuntime(ms): " + runtime + "\n#Runs: " + runs
+ "\n#Changing runs: " + changes + "\n#Loopable runs: " + loopRuns
+ "\n#Changing loopable runs: " + loopChanges + "\nEstimated Reduction(bytes): " + diff
+ "\nEstimated GzReduction(bytes): " + gzDiff + "\nEstimated Size(bytes): " + codeSize
+ "\nEstimated GzSize(bytes): " + gzCodeSize + "\n\n");
stream.write(str.getBytes(UTF_8));
long traceRuntime = tracer.stop();
tracker.recordPassStop(name, traceRuntime);
throw new IllegalStateException("normalizeNodeType constraints violated");
import com.google.javascript.rhino.JSTypeExpression;
static final DiagnosticType WEAK_NAMESPACE_TYPE = DiagnosticType.warning(
"JSC_WEAK_NAMESPACE_TYPE",
"Provided symbol declared with type Object. This is rarely useful. "
+ "For more information see "
+ "https://github.com/google/closure-compiler/wiki/A-word-about-the-type-Object");
"\"{0}\" is not a valid {1} qualified name");
static final DiagnosticType INVALID_CLOSURE_CALL_ERROR = DiagnosticType.error(
"JSC_INVALID_CLOSURE_CALL_ERROR",
"Closure dependency methods(goog.provide, goog.require, etc) must be called at file scope.");
if (validPrimitiveCall(t, n)) {
processDefineCall(t, n, parent);
if (validPrimitiveCall(t, n)) {
processRequireCall(t, n, parent);
if (validPrimitiveCall(t, n)) {
processProvideCall(t, n, parent);
if (validPrimitiveCall(t, n)) {
processForwardDeclare(t, n, parent);
if (validPrimitiveCall(t, n)) {
processAddDependency(n, parent);
private boolean validPrimitiveCall(NodeTraversal t, Node n) {
if (!n.getParent().isExprResult() || !t.inGlobalScope()) {
compiler.report(t.makeError(n, INVALID_CLOSURE_CALL_ERROR));
return false;
return true;
unrecognizedRequires.add(new UnrecognizedRequire(n, ns));
if (!NodeUtil.isValidQualifiedName(compiler.getLanguageMode(), arg.getString())) {
compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR,
arg.getString(), compiler.getLanguageMode().toString()));
if (!NodeUtil.isValidQualifiedName(compiler.getLanguageMode(), name)) {
compiler.report(t.makeError(args, INVALID_DEFINE_NAME_ERROR, name));
return false;
JSDocInfo info;
if (candidateDefinition.isExprResult()) {
info = candidateDefinition.getFirstChild().getJSDocInfo();
info = candidateDefinition.getJSDocInfo();
if (info != null) {
JSTypeExpression expr = info.getType();
if (expr != null) {
Node n = expr.getRoot();
if (n.getType() == Token.BANG) {
n = n.getFirstChild();
if (n.getType() == Token.STRING
&& !n.hasChildren()  // templated object types are ok.
&& n.getString().equals("Object")) {
compiler.report(
JSError.make(candidateDefinition, WEAK_NAMESPACE_TYPE));
UnrecognizedRequire(Node requireNode, String namespace) {
String inputToModuleName(CompilerInput input) {
return toModuleName(loader.getLoadAddress(input));
String moduleName = inputToModuleName(t.getInput());
int lastSlash = name.lastIndexOf('/');
import com.google.common.collect.ImmutableSet;
private static final String DEFAULT_EXPORT_NAME = "$jscompDefaultExport";
private Set<String> types = new LinkedHashSet<>();
new ModuleOriginalNamePair(moduleName, "default"));
namesToRequire.add("default");
Preconditions.checkState(child.getType() == Token.IMPORT_STAR,
"Expected an IMPORT_STAR node, but was: %s", child);
importMap.put(
child.getString(),
new ModuleOriginalNamePair(moduleName, ""));
if (alreadyRequired.add(moduleName)) {
Node require = IR.exprResult(
IR.call(NodeUtil.newQName(compiler, "goog.require"), IR.string(moduleName)));
Node var = IR.var(IR.name(DEFAULT_EXPORT_NAME), n.removeFirstChild());
n.getParent().replaceChild(n, var);
exportMap.put("default", DEFAULT_EXPORT_NAME);
Node moduleIdentifier = n.getLastChild();
Node importNode = new Node(Token.IMPORT, moduleIdentifier.cloneNode());
importNode.copyInformationFrom(n);
parent.addChildBefore(importNode, n);
visit(t, importNode, parent);
String loadAddress = loader.locate(moduleIdentifier.getString(), t.getInput());
String moduleName = toModuleName(loadAddress);
for (Node exportSpec : n.getFirstChild().children()) {
String nameFromOtherModule = exportSpec.getFirstChild().getString();
String exportedName = exportSpec.getLastChild().getString();
exportMap.put(exportedName, moduleName + "." + nameFromOtherModule);
parent.removeChild(n);
types.add(name);
if (!exportMap.isEmpty()) {
Node objectlit = IR.objectlit();
Node varNode = IR.var(IR.name(moduleName), objectlit)
.useSourceInfoIfMissingFromForTree(script);
script.addChildToBack(varNode);
String withSuffix = entry.getValue();
Node assign = IR.assign(
NodeUtil.newQName(compiler, withSuffix));
Node exprResult = IR.exprResult(assign)
if (types.contains(exportedName)) {
JSDocInfoBuilder builder = new JSDocInfoBuilder(true);
builder.recordConstancy();
JSDocInfo info = builder.build(assign);
assign.setJSDocInfo(info);
NodeTraversal.traverse(compiler, script, new RenameGlobalVars(moduleName));
if (!exportMap.isEmpty()) {
Node googProvide = IR.exprResult(
IR.string(moduleName)));
script.addChildToFront(googProvide.copyInformationFromForTree(script));
t.getInput().addProvide(moduleName);
for (String name : exportMap.keySet()) {
String qualifiedName = moduleName + "." + name;
Node newGoogProvide = IR.exprResult(
IR.call(NodeUtil.newQName(compiler, "goog.provide"),
IR.string(qualifiedName)));
newGoogProvide.copyInformationFromForTree(script);
if (name.equals("default")) {
JSDocInfoBuilder jsDocInfo = script.getJSDocInfo() == null
? new JSDocInfoBuilder(false)
: JSDocInfoBuilder.copyFrom(script.getJSDocInfo());
jsDocInfo.recordSuppressions(ImmutableSet.of("invalidProvide"));
script.setJSDocInfo(jsDocInfo.build(script));
script.addChildAfter(newGoogProvide, googProvide);
if (reportDependencies) {
t.getInput().addProvide(qualifiedName);
if (pair.originalName.isEmpty()) {
n.getParent().replaceChild(
n, IR.name(pair.module).useSourceInfoIfMissingFromForTree(n));
n.getParent().replaceChild(n,
IR.getprop(IR.name(pair.module), IR.string(pair.originalName))
.useSourceInfoIfMissingFromForTree(n));
int lastSlash = name.lastIndexOf('/');
new TweakFunctionCall(tweakFunc, n));
TweakFunctionCall(TweakFunction tweakFunc, Node callNode) {
this(tweakFunc, callNode, null);
TweakFunctionCall(TweakFunction tweakFunc, Node callNode, Node valueNode) {
registerCall = new TweakFunctionCall(tweakFunc, callNode,
functionCalls.add(new TweakFunctionCall(tweakFunc, callNode,
functionCalls.add(new TweakFunctionCall(tweakFunc, callNode));
import java.util.ArrayList;
import java.util.HashSet;
sb.append(functionNames.getFunctionName(function) + " " + functionInfo + " Calls: "
+ depFunctionNames + "\n");
if (functionInfo.functionThrows()) {
if (functionInfo.taintsThis()) {
if (functionInfo.taintsReturn()) {
!sideEffectInfo.blacklisted().contains(v) &&
sideEffectInfo.taintedLocals().contains(v)) {
if (!localVar || sideEffectInfo.blacklisted().contains(v)) {
if (sideEffectInfo.taintedLocals().contains(v)) {
sideEffectInfo.taintedLocals = Collections.emptySet();
sideEffectInfo.blacklisted = Collections.emptySet();
private List<Node> callsInFunctionBody = null;
private Set<Var> blacklisted = null;
private Set<Var> taintedLocals = null;
private int bitmask = 0;
private static final int EXTERN_MASK = 1 << 0;
private static final int PURE_FUNCTION_MASK = 1 << 1;
private static final int FUNCTION_THROWS_MASK = 1 << 2;
private static final int TAINTS_GLOBAL_STATE_MASK = 1 << 3;
private static final int TAINTS_THIS_MASK = 1 << 4;
private static final int TAINTS_ARGUMENTS_MASK = 1 << 5;
private static final int TAINTS_UNKNOWN_MASK = 1 << 6;
private static final int TAINTS_RETURN_MASK = 1 << 7;
private void setMask(int mask, boolean value) {
if (value) {
bitmask |= mask;
bitmask &= ~mask;
private boolean getMask(int mask) {
return (bitmask & mask) != 0;
private boolean extern() {
return getMask(EXTERN_MASK);
private boolean pureFunction() {
return getMask(PURE_FUNCTION_MASK);
private boolean taintsGlobalState() {
return getMask(TAINTS_GLOBAL_STATE_MASK);
private boolean taintsThis() {
return getMask(TAINTS_THIS_MASK);
private boolean taintsUnknown() {
return getMask(TAINTS_UNKNOWN_MASK);
private boolean taintsReturn() {
return getMask(TAINTS_RETURN_MASK);
boolean functionThrows() {
return getMask(FUNCTION_THROWS_MASK);
this.setMask(EXTERN_MASK, extern);
public Set<Var> taintedLocals() {
if (taintedLocals == null) {
return Collections.emptySet();
return taintedLocals;
if (taintedLocals == null) {
taintedLocals = new HashSet<>();
blacklisted = Collections.emptySet();
taintedLocals = Collections.emptySet();
public Set<Var> blacklisted() {
if (blacklisted == null) {
return Collections.emptySet();
return blacklisted;
if (blacklisted == null) {
blacklisted = new HashSet<>();
return !getMask(
FUNCTION_THROWS_MASK
| TAINTS_GLOBAL_STATE_MASK
| TAINTS_THIS_MASK
| TAINTS_ARGUMENTS_MASK
| TAINTS_UNKNOWN_MASK);
return !pureFunction();
this.setMask(PURE_FUNCTION_MASK, true);
setMask(TAINTS_GLOBAL_STATE_MASK, true);
setMask(TAINTS_THIS_MASK, true);
setMask(TAINTS_ARGUMENTS_MASK, true);
setMask(FUNCTION_THROWS_MASK, true);
setMask(TAINTS_UNKNOWN_MASK, true);
setMask(TAINTS_RETURN_MASK, true);
return getMask(TAINTS_GLOBAL_STATE_MASK | TAINTS_UNKNOWN_MASK);
return getMask(
TAINTS_GLOBAL_STATE_MASK
| TAINTS_ARGUMENTS_MASK
| TAINTS_UNKNOWN_MASK);
return taintsThis();
throw new IllegalStateException("Invariant failed.  " + this);
if (callsInFunctionBody == null) {
callsInFunctionBody = new ArrayList<>();
if (callsInFunctionBody == null) {
return Collections.emptyList();
if (extern()) {
if (pureFunction()) {
if (taintsThis()) {
if (taintsGlobalState()) {
if (functionThrows()) {
if (taintsUnknown()) {
return "Side effects: " + status;
return size > 0 && references.get(0).isInitializingDeclaration();
return isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock();
class RemoveUnusedPrototypeProperties implements CompilerPass {
for (NameInfo nameInfo : analyzer.getAllNameInfo()) {
declaration.remove(compiler);
return !codingConvention.isExported(var.getName());
import java.util.ArrayDeque;
final Deque<LabelNamespace> namespaceStack = new ArrayDeque<>();
.getOriginalName(name);
import com.google.common.collect.Ordering;
List<String> placeholderNames = Ordering.natural().sortedCopy(message.placeholders());
import java.util.ArrayList;
final List<Integer> parameters;
Config(String name, List<Integer> replacementParameters) {
this.parameters = replacementParameters;
public boolean isReplaceAll() {
return parameters.size() == 1 && parameters.contains(REPLACE_ALL_VALUE);
public boolean didReplacement = false;
return result.didReplacement;
if (!config.isReplaceAll()) {
for (int parameter : config.parameters) {
Node arg = n.getChildAtIndex(parameter);
if (arg != null) {
replaceExpression(t, arg, n);
recordReplacement(key);
private void recordReplacement(String key) {
result.didReplacement = true;
List<Integer> replacementParameters = new ArrayList<>();
replacementParameters.add(Config.REPLACE_ALL_VALUE);
Preconditions.checkState(!replacementParameters.contains(
Config.REPLACE_ALL_VALUE));
replacementParameters.add(paramCount);
Preconditions.checkState(!replacementParameters.isEmpty());
return new Config(name, replacementParameters);
if (!commas.isEmpty()) {
static final DiagnosticType MISPLACED_FUNCTION_ANNOTATION =
DiagnosticType.warning("JSC_MISPLACED_FUNCTION_ANNOTATION",
"Misplaced function annotation.");
.put(Pattern.compile("^This JSDoc is not attached to a function node.*"),
MISPLACED_FUNCTION_ANNOTATION)
new Normalize(compiler, false).process(externs, root);
alternates.addAll(type.toMaybeUnionType().getAlternates());
SanityCheck(AbstractCompiler compiler) {
(new GatherExternProperties(compiler)).process(externs, null);
static final DiagnosticType GOOG_SCOPE_MUST_BE_ALONE = DiagnosticType.error(
"JSC_GOOG_SCOPE_MUST_BE_ALONE",
static final DiagnosticType GOOG_SCOPE_MUST_BE_IN_GLOBAL_SCOPE = DiagnosticType.error(
"JSC_GOOG_SCOPE_MUST_BE_IN_GLOBAL_SCOPE",
"The call to goog.scope must be in the global scope.");
if (!traversal.getAliasUsages().isEmpty() || !traversal.getAliasDefinitionsInOrder().isEmpty()
|| !traversal.getScopeCalls().isEmpty()) {
private class Traversal extends NodeTraversal.AbstractPostOrderCallback
implements NodeTraversal.ScopedCallback {
report(t, n, GOOG_SCOPE_MUST_BE_ALONE);
if (t.getScope().isLocal()) {
report(t, n, GOOG_SCOPE_MUST_BE_IN_GLOBAL_SCOPE);
if (t.getScopeDepth() == 2
&& isCallToScopeMethod(t.getScope().getRootNode().getParent())) {
if (!scopeUpRefMap.containsEntry(curScope.getRootNode(), assignment.oldName)) {
return !environmentModSet.intersectsLocation(sourceRefSet)
&& !environmentModSet.intersectsLocation(sourceModSet);
return codingConvention.isExported(partialName);
return fn.getFirstChild().getString().isEmpty()
&& (NodeUtil.isExprAssign(gramps) || parent.isName());
import java.nio.charset.StandardCharsets;
public static SourceFile fromInputStream(String fileName, InputStream s,
Charset charset) throws IOException {
return builder().withCharset(charset).buildFromInputStream(fileName, s);
return Files.newReader(file, StandardCharsets.UTF_8);
if (!getters.add(key.getString())) {
if (!setters.add(key.getString())) {
import com.google.common.collect.ImmutableMap;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.JSDocInfo.Visibility;
import com.google.javascript.rhino.jstype.StaticSourceFile;
List<Symbol> sortedSymbols = getNaturalSymbolOrdering().sortedCopy(symbols.values());
Collections.sort(types, getNaturalSymbolOrdering().reverse());
return type.isEnumType()
&& sym.getName().equals(type.toMaybeEnumType().getElementsType().getReferenceName());
void fillSymbolVisibility(
AbstractCompiler compiler, Node externs, Node root) {
CollectFileOverviewVisibility collectPass =
new CollectFileOverviewVisibility(compiler);
collectPass.process(externs, root);
ImmutableMap<StaticSourceFile, Visibility> visibilityMap =
collectPass.getFileOverviewVisibilityMap();
NodeTraversal.traverseRoots(
compiler, Lists.newArrayList(externs, root),
new VisibilityCollector(visibilityMap, compiler.getCodingConvention()));
set.addAll(instanceType.getOwnPropertyNames());
return this.visibility;
void setVisibility(Visibility v) {
this.visibility = v;
private class VisibilityCollector
extends NodeTraversal.AbstractPostOrderCallback {
private final ImmutableMap<StaticSourceFile, Visibility> fileVisibilityMap;
private final CodingConvention codingConvention;
private VisibilityCollector(
ImmutableMap<StaticSourceFile, Visibility> fileVisibilityMap,
CodingConvention codingConvention) {
this.fileVisibilityMap = fileVisibilityMap;
this.codingConvention = codingConvention;
if (n.isName()) {
visitName(t, n, parent);
visitProperty(t, n, parent);
private void visitName(NodeTraversal t, Node n, Node parent) {
Symbol symbol = symbols.get(n, n.getString());
if (symbol == null) {
return;
if (symbol.getVisibility() != null) {
return;
Var var = t.getScope().getVar(n.getString());
if (var == null) {
return;
Visibility v = AccessControlUtils.getEffectiveNameVisibility(
n ,var, fileVisibilityMap);
if (v == null) {
return;
symbol.setVisibility(v);
private void visitProperty(NodeTraversal t, Node getprop, Node parent) {
String propertyName = getprop.getLastChild().getString();
Symbol symbol = symbols.get(getprop, propertyName);
if (symbol == null) {
return;
if (symbol.getVisibility() != null) {
return;
JSType jsType = getprop.getFirstChild().getJSType();
if (jsType == null) {
return;
boolean isOverride = parent.getJSDocInfo() != null
&& parent.isAssign()
&& parent.getFirstChild() == getprop;
if (isOverride) {
symbol.setVisibility(Visibility.INHERITED);
ObjectType referenceType = ObjectType.cast(jsType.dereference());
Visibility v = AccessControlUtils.getEffectivePropertyVisibility(
getprop,
referenceType,
fileVisibilityMap,
codingConvention);
if (v == null) {
return;
symbol.setVisibility(v);
import java.util.Collections;
Collections.fill(localVarMatches, null);
sb.append(tracer);
static final DiagnosticType INTERFACE_METHOD_NOT_EMPTY =
"JSC_INTERFACE_METHOD_NOT_EMPTY",
INTERFACE_METHOD_NOT_EMPTY,
private void checkPropertyInheritanceOnPrototypeLitKey(
NodeTraversal t, Node key, String propertyName, ObjectType type) {
FunctionType ctorType = type.getOwnerFunction();
if (ctorType == null || (!ctorType.isConstructor() && !ctorType.isInterface())) {
return;
JSType propertyType = type.getPropertyType(propertyName);
checkDeclaredPropertyInheritance(
t, key, ctorType, propertyName,
key.getJSDocInfo(), propertyType);
checkPropertyInheritanceOnPrototypeLitKey(t, key, property, type);
&& interfaceHasProperty
&& !"__proto__".equals(propertyName)) {
&& declaredLocally
&& !"__proto__".equals(propertyName)) {
t.makeError(object, INTERFACE_METHOD_NOT_EMPTY,
report(t, n.getLastChild(), INEXISTENT_PROPERTY_WITH_SUGGESTION,
propName,
report(t, n.getLastChild(), reportType, propName,
JSType assertedType = assertionFunctionSpec.getAssertedOldType(
compiler.getCodingConvention().describeFunctionBind(n, false, true);
Node target = bind.target;
FunctionType callTargetFn = getJSType(target)
if (bind.thisValue != null && target.isFunction()) {
JSType thisType = getJSType(bind.thisValue);
if (thisType.toObjectType() != null && !thisType.isUnknownType()
&& callTargetFn.getTypeOfThis().isUnknownType()) {
callTargetFn = new FunctionBuilder(registry)
.copyFromOtherFunction(callTargetFn)
.withTypeOfThis(thisType.toObjectType())
.build();
target.setJSType(callTargetFn);
if (seenTypes.add(paramType)) {
ObjectType argObjectType = argType.restrictByNotNullOrUndefined().toObjectType();
if (argObjectType != null && !argObjectType.isUnknownType()
if (paramRecordType.hasOwnProperty(name) && argObjectType.hasProperty(name)) {
maybeResolveTemplatedType(paramRecordType.getPropertyType(name),
argObjectType.getPropertyType(name), resolvedTypes, seenTypes);
Map<String, JSType> typeVars = new HashMap<>();
result = new HashMap<>();
Preconditions.checkArgument(n.isFunction(), "Expected a function node, found %s", n);
Preconditions.checkArgument(n.isFunction(), "Expected a function node, found %s", n);
Preconditions.checkArgument(n.isCall(), "Expected a call node, found %s", n);
Preconditions.checkArgument(n.isCall(), "Expected a call node, found %s", n);
Preconditions.checkArgument(n.isCall(), "Expected a call node, found %s", n);
Preconditions.checkArgument(n.isCall(), "Expected a call node, found %s", n);
ImmutableList.Builder<Node> builder = new ImmutableList.Builder<>();
Preconditions.checkArgument(
n.isComputedProp(), "Expected a computed property node, found %s", n);
Preconditions.checkArgument(
n.isComputedProp(), "Expected a computed property node, found %s", n);
if (params[i].isEmpty()) {
return nameResolver.typeVars.containsKey(getCallArgument(ttlAst, 0).getString());
ImmutableMap.Builder<String, JSType> props = new ImmutableMap.Builder<>();
ImmutableList.Builder<RecordType> recTypesBuilder = new ImmutableList.Builder<>();
Map<String, JSType> props = new HashMap<>();
return createRecordType(ImmutableMap.copyOf(props));
Map<String, JSType> newProps = new HashMap<>();
return createRecordType(ImmutableMap.copyOf(newProps));
String msg = getCallArgument(ttlAst, 0).getString() + type;
return objectType + "." + propName;
Joiner.on(",").appendTo(sb, funType.getTemplateTypeMap().getTemplateKeys());
new FunctionTypeBuilder(name, compiler, errorRoot,
logger.fine("Removing " + n);
private static final Splitter LINE_SPLITTER = Splitter.on('\n');
result.addAll(CharStreams.readLines(reader));
List<String> lines = LINE_SPLITTER.splitToList(error.description);
try (PrintStream stream = new PrintStream(out)) {
appendWhitelist(stream);
out.append("#" + Joiner.on("\n# ").join(Splitter.on('\n').split(headerNote)) + "\n");
import com.google.javascript.jscomp.SourceMap.LocationMapping;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Iterator;
private String sourceMapLocationMapping;
if (!Strings.isNullOrEmpty(sourceMapLocationMapping)) {
String tokens[] = sourceMapLocationMapping.split("\\|", -1);
LocationMapping lm = new LocationMapping(tokens[0], tokens[1]);
options.sourceMapLocationMappings = Arrays.asList(lm);
private List<SourceFile> findJavaScriptFiles(ResourceCollection rc) {
Iterator<Resource> iter = rc.iterator();
while (iter.hasNext()) {
FileResource fr = (FileResource) iter.next().as(FileResource.class);
File file = Paths.get("")
.toAbsolutePath()
.relativize(fr.getFile().toPath())
.toFile();
files.add(SourceFile.fromFile(file, Charset.forName(encoding)));
public void setSourceMapLocationMapping(String mapping) {
this.sourceMapLocationMapping = mapping;
import com.google.common.io.Files;
import java.io.File;
import java.nio.charset.StandardCharsets;
return parseFileReader(filePath, Files.newReader(new File(filePath), StandardCharsets.UTF_8));
c = (char) (c >>> 4);
c = (char) (c >>> 4);
c = (char) (c >>> 4);
c = (char) (c >>> 4);
import com.google.gson.JsonObject;
protected JsonObject getOwnConfig() {
return context.config.get(getConfigName()).getAsJsonObject();
(int) (budget * getOwnConfig().get("maxLength").getAsDouble()) + 1);
double toLabel = getOwnConfig().get("toLabel").getAsDouble();
double toLabel = getOwnConfig().get("toLabel").getAsDouble();
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
JsonObject weightConfig = getOwnConfig().get("weights").getAsJsonObject();
weights.add(weightConfig.get(fuzzer.getConfigName()).getAsDouble());
import static java.nio.charset.StandardCharsets.UTF_8;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
private JsonObject config;
private JsonObject getConfig() {
config = new Gson().fromJson(Files.toString(
file, StandardCharsets.UTF_8), JsonObject.class);
results[0] = CharStreams.toString(new InputStreamReader(process.getInputStream(), UTF_8));
results[1] = CharStreams.toString(new InputStreamReader(process.getErrorStream(), UTF_8));
(int) ((budget - 1) * getOwnConfig().get("headBudget").getAsDouble());
double argLength = getOwnConfig().get("argLength").getAsDouble();
int numParams = context.random.nextInt(getOwnConfig().get("maxParams").getAsInt() + 1);
import com.google.gson.JsonObject;
JsonObject config;
FuzzingContext(Random random, JsonObject config, boolean strict) {
getOwnConfig().get("shadow").getAsDouble()) {
getOwnConfig().get("hasElse").getAsDouble() ? 3 : 2;
return Node.newNumber(context.random.nextInt(getOwnConfig().get("max").getAsInt()));
context.random.nextDouble() < getOwnConfig().get("hasValue").getAsDouble()) {
(int) (budget * getOwnConfig().get("valueBudget").getAsDouble());
import java.util.LinkedList;
nodeAnnotationStack = new LinkedList<>();
edgeAnnotationStack = new LinkedList<>();
private List<GraphNode<N, E>> nodes = new ArrayList<>();
import java.util.ArrayList;
List<GraphNode<N, E>> worklist = new ArrayList<>(graph.getNodes());
import java.util.ArrayList;
import java.util.HashMap;
protected final Map<N, LinkedDirectedGraphNode<N, E>> nodes = new HashMap<>();
useEdgeAnnotations
? new AnnotatedLinkedDirectedGraphEdge<>(src, edgeValue, dest)
: new LinkedDirectedGraphEdge<>(src, edgeValue, dest);
public void connect(
DiGraphNode<N, E> src,
E edgeValue,
DiGraphNode<N, E> dest) {
LinkedDirectedGraphEdge<N, E> edge =
useEdgeAnnotations
? new AnnotatedLinkedDirectedGraphEdge<>(src, edgeValue, dest)
: new LinkedDirectedGraphEdge<>(src, edgeValue, dest);
src.getOutEdges().add(edge);
dest.getInEdges().add(edge);
public void connectIfNotConnectedInDirection(N srcValue, E edgeValue, N destValue) {
LinkedDirectedGraphNode<N, E> src = createDirectedGraphNode(srcValue);
LinkedDirectedGraphNode<N, E> dest = createDirectedGraphNode(destValue);
if (!this.isConnectedInDirection(src, Predicates.equalTo(edgeValue), dest)) {
this.connect(src, edgeValue, dest);
public LinkedDirectedGraphNode<N, E> createDirectedGraphNode(N nodeValue) {
node = useNodeAnnotations
? new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue)
: new LinkedDirectedGraphNode<N, E>(nodeValue);
List<DiGraphEdge<N, E>> edges = new ArrayList<>(totalSize);
List<DiGraphEdge<N, E>> edges = new ArrayList<>();
public boolean isConnectedInDirection(
DiGraphNode<N, E> dNode1,
Predicate<E> edgeMatcher,
DiGraphNode<N, E>  dNode2) {
List<DiGraphEdge<N, E>> outEdges = dNode1.getOutEdges();
int len = outEdges.size();
for (int i = 0; i < len; i++) {
DiGraphEdge<N, E> outEdge = outEdges.get(i);
if (outEdge.getDestination() == dNode2
&& edgeMatcher.apply(outEdge.getValue())) {
return true;
return false;
if (outEdge.getDestination() == dNode2
&& edgeMatcher.apply(outEdge.getValue())) {
Preconditions.checkNotNull(dNode);
List<DiGraphNode<N, E>> nodeList =
new ArrayList<>(dNode.getInEdges().size());
Preconditions.checkNotNull(dNode);
List<DiGraphNode<N, E>> nodeList =
new ArrayList<>(dNode.getOutEdges().size());
List<GraphvizEdge> edgeList = new ArrayList<>();
List<GraphvizNode> nodeList = new ArrayList<>(nodes.size());
List<GraphNode<N, E>> result = new ArrayList<>(
node.getInEdges().size() + node.getOutEdges().size());
for (DiGraphEdge<N, E> inEdge : node.getInEdges()) {
result.add(inEdge.getSource());
for (DiGraphEdge<N, E> outEdge : node.getOutEdges()) {
result.add(outEdge.getDestination());
List<DiGraphEdge<N, E>> result = new ArrayList<>();
public static class LinkedDirectedGraphNode<N, E> implements DiGraphNode<N, E>,
List<DiGraphEdge<N, E>> inEdgeList = new ArrayList<>();
List<DiGraphEdge<N, E>> outEdgeList = new ArrayList<>();
import java.util.ArrayList;
return ((LinkedUndirectedGraphNode<N, E>) uNode).neighborList();
List<UndiGraphEdge<N, E>> edges = new ArrayList<>();
List<GraphvizEdge> edgeList = new ArrayList<>();
List<GraphvizNode> nodeList = new ArrayList<>(nodes.size());
List<GraphEdge<N, E>> result = new ArrayList<>();
private List<UndiGraphEdge<N, E>> neighborEdges = new ArrayList<>();
return neighborEdges;
return neighborEdges.iterator();
private List<GraphNode<N, E>> neighborList() {
List<GraphNode<N, E>> result = new ArrayList<>(neighborEdges.size());
for (UndiGraphEdge<N, E> edge : neighborEdges) {
if (edge.getNodeA() == this) {
result.add(edge.getNodeB());
result.add(edge.getNodeA());
return result;
if (!values.add(value)) {
package com.google.javascript.jscomp.lint;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.DiagnosticType;
import com.google.javascript.jscomp.HotSwapCompilerPass;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.jscomp.NodeUtil;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
public final class CheckInterfaces extends AbstractPostOrderCallback
implements HotSwapCompilerPass {
public static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY =
DiagnosticType.warning(
"JSC_INTERFACE_FUNCTION_NOT_EMPTY",
"interface functions must have an empty body");
public static final DiagnosticType INTERFACE_SHOULD_NOT_TAKE_ARGS =
DiagnosticType.warning(
"JSC_INTERFACE_SHOULD_NOT_TAKE_ARGS",
"Interface functions should not take any arguments");
private final AbstractCompiler compiler;
public CheckInterfaces(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverse(compiler, scriptRoot, this);
private boolean isInterface(Node n) {
if (!n.isFunction()) {
return false;
JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);
return jsDoc != null && jsDoc.isInterface();
public void visit(NodeTraversal t, Node n, Node parent) {
if (!isInterface(n)) {
return;
Node args = n.getFirstChild().getNext();
if (args.hasChildren()) {
t.report(args.getFirstChild(), INTERFACE_SHOULD_NOT_TAKE_ARGS);
Node block = n.getLastChild();
if (block.hasChildren()) {
t.report(block.getFirstChild(), INTERFACE_FUNCTION_NOT_EMPTY);
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.javascript.jscomp.CheckPathsBetweenNodes;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
import com.google.javascript.rhino.Token;
private static final Predicate<Node> NULLABLE_RETURN_PREDICATE =
new Predicate<Node>() {
public boolean apply(Node input) {
if (input == null || !input.isReturn()) {
return false;
Node returnValue = input.getFirstChild();
return returnValue != null && isNullable(returnValue);
public static boolean hasReturnDeclaredNullable(Node n) {
return n.isBlock() && n.hasChildren() && isReturnTypeNullable(n.getParent())
&& !hasSingleThrow(n);
if (hasReturnDeclaredNullable(n)
private static boolean hasSingleThrow(Node blockNode) {
if (blockNode.getChildCount() == 1
&& blockNode.getFirstChild().getType() == Token.THROW) {
return true;
return false;
public static boolean canReturnNull(ControlFlowGraph<Node> graph) {
CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test = new CheckPathsBetweenNodes<>(graph,
graph.getEntry(), graph.getImplicitReturn(), NULLABLE_RETURN_PREDICATE,
Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue());
return test.somePathsSatisfyPredicate();
package com.google.javascript.jscomp.lint;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.DiagnosticType;
import com.google.javascript.jscomp.HotSwapCompilerPass;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.NodeUtil;
import com.google.javascript.rhino.Node;
public class CheckPrototypeProperties implements HotSwapCompilerPass, NodeTraversal.Callback {
public static final DiagnosticType ILLEGAL_PROTOTYPE_MEMBER =
DiagnosticType.disabled(
"JSC_ILLEGAL_PROTOTYPE_MEMBER",
"Prototype property {0} should be a primitive, not an Array or Object.");
final AbstractCompiler compiler;
public CheckPrototypeProperties(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverse(compiler, originalRoot, this);
public void visit(NodeTraversal t, Node n, Node parent) {
if (NodeUtil.isPrototypePropertyDeclaration(n)) {
Node assign = n.getFirstChild();
Node rhs = assign.getLastChild();
if (rhs.isArrayLit() || rhs.isObjectLit()) {
String propName = assign.getFirstChild().getLastChild().getString();
compiler.report(t.makeError(assign, ILLEGAL_PROTOTYPE_MEMBER, propName));
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
return true;
import com.google.javascript.jscomp.newtypes.NominalType.RawNominalType;
private final ImmutableList<String> typeParameters;
public boolean isTypeVariableInScope(String tvar) {
if (typeParameters != null && typeParameters.contains(tvar)) {
return true;
if (receiverType != null && receiverType.isUninstantiatedGenericType()) {
RawNominalType rawType = receiverType.getRawNominalType();
if (rawType.getTypeParameters().contains(tvar)) {
return true;
return false;
builder.addTypeParameters(typeParameters);
JSType lookupTypeByName(String name);
Typedef getTypedef(String name);
EnumType getEnum(String name);
JSType getDeclaredTypeOf(String name);
JSTypes getCommonTypes();
public boolean enumLiteralHasKey(String name) {
return props.contains(name);
import java.util.HashMap;
checkValid();
private FunctionType(boolean isLoose) {
this.requiredFormals = null;
this.optionalFormals = null;
this.restFormals = null;
this.returnType = null;
this.nominalType = null;
this.receiverType = null;
this.outerVarPreconditions = null;
this.typeParameters = null;
this.isLoose = isLoose;
Preconditions.checkNotNull(requiredFormals,
"null required formals for function: %s", this);
Preconditions.checkNotNull(formal);
Preconditions.checkNotNull(requiredFormals,
"null optional formals for function: %s", this);
Preconditions.checkNotNull(formal);
Preconditions.checkNotNull(returnType);
if (isLoose()) {
return this;
static final FunctionType TOP_FUNCTION = new FunctionType(false);
private static final FunctionType LOOSE_TOP_FUNCTION = new FunctionType(true);
null, JSType.UNKNOWN, JSType.UNKNOWN, null, null, null, null, true);
private static final FunctionType BOTTOM_FUNCTION = FunctionType.normalized(
null, null, null, JSType.BOTTOM, null, null, null, null, false);
public JSType getSuperPrototype() {
Preconditions.checkState(isConstructor());
NominalType superClass = nominalType.getInstantiatedSuperclass();
return superClass == null ? null : superClass.getPrototype();
static boolean isInhabitable(FunctionType f) {
return f != BOTTOM_FUNCTION;
public boolean hasRestFormals() {
return restFormals != null;
return returnType;
public boolean isRequiredArg(int i) {
return i < requiredFormals.size();
public boolean isOptionalArg(int i) {
return i >= requiredFormals.size()
&& i < requiredFormals.size() + optionalFormals.size();
public JSType getInstanceTypeOfCtor() {
if (!isGeneric()) {
return nominalType.getInstanceAsJSType();
ImmutableMap.Builder<String, JSType> builder = ImmutableMap.builder();
for (String typeVar : getTypeParameters()) {
builder.put(typeVar, JSType.UNKNOWN);
return instantiateGenerics(builder.build())
.nominalType.getInstanceAsJSType();
public JSType getThisType() {
if (receiverType != null) {
return receiverType.getInstanceAsJSType();
if (nominalType != null) {
return nominalType.getInstanceAsJSType();
return null;
public JSType createConstructorObject(NominalType fnNominal) {
return NominalType.createConstructorObject(this, fnNominal);
if (isQmarkFunction()) {
return FunctionTypeBuilder.qmarkFunctionBuilder().buildDeclaration();
Preconditions.checkState(!isLoose());
Preconditions.checkState(!isLoose() && !other.isLoose());
if (this.equals(other)) {
return true;
return instantiateGenericsWithUnknown(this).isSubtypeOf(other);
if (other == null
|| other.isQmarkFunction()
|| !this.isLoose() && other.isLoose()) {
FunctionType result = FunctionType.meet(this, other);
if (this.isLoose() && !result.isLoose()) {
result = result.withLoose();
return result;
if (f1.isGeneric() && f1.isSubtypeOf(f2)) {
return f1;
return f2;
if (f1.isGeneric()) {
f1 = instantiateGenericsWithUnknown(f1);
if (f2.isGeneric()) {
f2 = instantiateGenericsWithUnknown(f2);
JSType retType = JSType.meet(f1.returnType, f2.returnType);
if (retType.isBottom()) {
return BOTTOM_FUNCTION;
builder.addRetType(retType);
int minRequiredArity =
Math.min(this.requiredFormals.size(), f2.requiredFormals.size());
for (int i = 0; i < minRequiredArity; i++) {
if (this.receiverType != null && other.receiverType != null
&& !this.receiverType.unifyWith(
other.receiverType, typeParameters, typeMultimap)) {
private static FunctionType instantiateGenericsWithUnknown(FunctionType f) {
if (!f.isGeneric()) {
return f;
HashMap<String, JSType> tmpTypeMap = new HashMap<>();
for (String typeParam : f.typeParameters) {
tmpTypeMap.put(typeParam, JSType.UNKNOWN);
return f.instantiateGenerics(tmpTypeMap);
if (isLoose()) {
for (Map.Entry<String, JSType> concreteTypeEntry
: concreteTypes.entrySet()) {
public FunctionType instantiateGenericsFromArgumentTypes(
if (argTypes.size() < getMinArity() || argTypes.size() > getMaxArity()) {
return null;
if (isLoose()) {
Preconditions.checkState(restFormals == null);
Preconditions.checkState(returnType == null);
Preconditions.checkState(nominalType == null);
Preconditions.checkState(this.typeParameters == null);
Preconditions.checkState(receiverType == null);
abstract ImmutableSet<ObjectType> getObjs();
static JSType fromFunctionType(FunctionType fn, NominalType fnNominal) {
ImmutableSet.of(ObjectType.fromFunction(fn, fnNominal)), null, null);
public boolean isString() {
return STRING_MASK == getMask();
return lhs.isBottom() || rhs.isBottom()
|| lhs.isUnknown() || rhs.isUnknown()
public JSType autobox(JSTypes commonTypes) {
if (isTop() || isUnknown()) {
return this;
int mask = getMask();
if ((mask & (NUMBER_MASK | STRING_MASK | BOOLEAN_MASK)) == BOTTOM_MASK) {
return this;
switch (mask) {
case NUMBER_MASK:
return commonTypes.getNumberInstance();
case BOOLEAN_MASK:
case TRUE_MASK:
case FALSE_MASK:
return commonTypes.getBooleanInstance();
case STRING_MASK:
return commonTypes.getStringInstance();
ImmutableSet.Builder<ObjectType> builder = ImmutableSet.builder();
if (getObjs() != null) {
builder.addAll(getObjs());
if ((mask & NUMBER_MASK) != 0) {
builder.add(commonTypes.getNumberInstanceObjType());
if ((mask & STRING_MASK) != 0) {
builder.add(commonTypes.getStringInstanceObjType());
if ((mask & BOOLEAN_MASK) != 0) { // may have truthy or falsy
builder.add(commonTypes.getBooleanInstanceObjType());
return makeType(
mask & ~(NUMBER_MASK | STRING_MASK | BOOLEAN_MASK),
builder.build(), getTypeVar(), getEnums());
int templateMask = BOTTOM_MASK;
int otherScalarBits = other.getMask() & ~NON_SCALAR_MASK;
if (other.isTop() || other.isUnknown() || this == other) {
Preconditions.checkState(getObjs() != null || getEnums() != null,
"Can't getProp of type %s", this);
if (isUnknown() || isBottom() || getObjs() == null) {
import com.google.javascript.jscomp.DiagnosticType;
import com.google.javascript.jscomp.JSError;
public static final DiagnosticType INVALID_GENERICS_INSTANTIATION =
DiagnosticType.warning(
"JSC_INVALID_GENERICS_INSTANTIATION",
"Invalid generics instantiation for {0}.\n"
+ "Expected {1} type argument(s), but found {2}.");
public static final DiagnosticType BAD_JSDOC_ANNOTATION =
DiagnosticType.warning(
"JSC_BAD_JSDOC_ANNOTATION",
"Bad JSDoc annotation. {0}");
public static final DiagnosticType EXTENDS_NON_OBJECT =
DiagnosticType.warning(
"JSC_EXTENDS_NON_OBJECT",
"{0} extends non-object type {1}.\n");
public static final DiagnosticType EXTENDS_NOT_ON_CTOR_OR_INTERF =
DiagnosticType.warning(
"JSC_EXTENDS_NOT_ON_CTOR_OR_INTERF",
"@extends used without @constructor or @interface for {0}.\n");
public static final DiagnosticType INHERITANCE_CYCLE =
DiagnosticType.warning(
"JSC_INHERITANCE_CYCLE",
"Cycle detected in inheritance chain of type {0}");
public static final DiagnosticType DICT_IMPLEMENTS_INTERF =
DiagnosticType.warning(
"JSC_DICT_IMPLEMENTS_INTERF",
"Class {0} is a dict. Dicts can't implement interfaces.");
public static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR =
DiagnosticType.warning(
"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR",
"@implements used without @constructor or @interface for {0}");
public static final DiagnosticType CONFLICTING_SHAPE_TYPE =
DiagnosticType.warning(
"JSC_CONFLICTING_SHAPE_TYPE",
"{1} cannot extend this type; {0}s can only extend {0}s");
public static final DiagnosticType CONFLICTING_EXTENDED_TYPE =
DiagnosticType.warning(
"JSC_CONFLICTING_EXTENDED_TYPE",
"{1} cannot extend this type; {0}s can only extend {0}s");
public static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE =
DiagnosticType.warning(
"JSC_CONFLICTING_IMPLEMENTED_TYPE",
"{0} cannot implement this type; "
+ "an interface can only extend, but not implement interfaces");
private Set<JSError> warnings = new HashSet<>();
private static DeclaredFunctionType qmarkFunctionDeclared =
FunctionTypeBuilder.qmarkFunctionBuilder().buildDeclaration();
private JSType qmarkFunctionOrNull = null;
private JSType getQmarkFunctionOrNull(JSTypes commonTypes) {
if (qmarkFunctionOrNull == null) {
qmarkFunctionOrNull =
JSType.join(commonTypes.qmarkFunction(), JSType.NULL);
return qmarkFunctionOrNull;
return getNodeTypeDeclaration(jsdoc, registry, ownerType == null
? ImmutableList.<String>of() : ownerType.getTypeParameters());
DeclaredTypeRegistry registry, ImmutableList<String> typeParameters) {
jsdoc.getType(), registry, typeParameters);
public Set<JSError> getWarnings() {
private JSType getTypeFromJSTypeExpression(JSTypeExpression expr,
return getTypeFromNode(expr.getRoot(), registry, typeParameters == null
? ImmutableList.<String>of() : typeParameters);
private JSType getTypeFromNode(Node n, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) {
return getTypeFromNodeHelper(n, registry, typeParameters);
private JSType getMaybeTypeFromNode(Node n, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) {
try {
return getTypeFromNodeHelper(n, registry, typeParameters);
return null;
private JSType getTypeFromNodeHelper(Node n, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) throws UnknownTypeException {
Preconditions.checkNotNull(typeParameters);
return getRecordTypeHelper(n, registry, typeParameters);
return getNamedTypeHelper(n, registry, typeParameters);
JSType nextType = getTypeFromNodeHelper(child, registry, typeParameters);
if (nextType.isUnknown()) {
warn("This union type is equivalent to '?'.", n);
return JSType.UNKNOWN;
union = JSType.join(union, nextType);
JSType nullableType = getTypeFromNodeHelper(
n.getFirstChild(), registry, typeParameters);
if (nullableType.isTypeVariable()) {
warn("Cannot use ! to restrict type variable type.\n"
+ "Prefer to make type argument non-nullable and add "
+ "null explicitly where needed (e.g. through ?T or T|null)", n);
return nullableType.removeType(JSType.NULL);
return JSType.join(JSType.NULL,
getTypeFromNodeHelper(child, registry, typeParameters));
return getFunTypeHelper(n, null, registry, typeParameters);
private JSType getRecordTypeHelper(Node n, DeclaredTypeRegistry registry,
getTypeFromNodeHelper(
fieldTypeNode.getLastChild(), registry, typeParameters);
private JSType getNamedTypeHelper(Node n, DeclaredTypeRegistry registry,
return getQmarkFunctionOrNull(registry.getCommonTypes());
if (outerTypeParameters.contains(typeName)) {
if (namedType.isUnknown()) {
return namedType;
namedType, n, registry, outerTypeParameters);
td.getTypeExprForErrorReporting().getRoot());
tdType = getTypeFromJSTypeExpression(texp, registry, null);
e.getTypeExprForErrorReporting().getRoot());
enumeratedType = getTypeFromJSTypeExpression(texp, registry, null);
warn("An enum type cannot include type variables.", texp.getRoot());
texp.getRoot());
warn("An enum type cannot be a union type.", texp.getRoot());
DeclaredTypeRegistry registry, ImmutableList<String> outerTypeParameters)
typeList.add(
getTypeFromNodeHelper(child, registry, outerTypeParameters));
warnings.add(JSError.make(
n, INVALID_GENERICS_INSTANTIATION,
nominalTypeName, String.valueOf(typeParamsSize),
String.valueOf(typeArgsSize)));
DeclaredTypeRegistry registry, ImmutableList<String> typeParameters)
FunctionTypeBuilder builder = new FunctionTypeBuilder();
if (ownerType != null) {
builder.addReceiverType(ownerType.getAsNominalType());
fillInFunTypeBuilder(
jsdocNode, ownerType, registry, typeParameters, builder);
return registry.getCommonTypes().fromFunctionType(builder.buildFunction());
private void fillInFunTypeBuilder(
ImmutableList<String> typeParameters, FunctionTypeBuilder builder)
if (ownerType == null) {
builder.addReceiverType(
getNominalType(child.getFirstChild(), registry, typeParameters));
builder.addNominalType(
getNominalType(child.getFirstChild(), registry, typeParameters));
builder.addOptFormal(getTypeFromNodeHelper(
arg.getFirstChild(), registry, typeParameters));
getTypeFromNodeHelper(restNode, registry, typeParameters));
getTypeFromNodeHelper(arg, registry, typeParameters));
builder.addRetType(getTypeFromNodeHelper(child, registry, typeParameters));
private NominalType getNominalType(Node n,
return getTypeFromNode(n, registry, typeParameters)
.getNominalTypeIfUnique();
private ImmutableSet<NominalType> getImplementedInterfaces(
JSDocInfo jsdoc, DeclaredTypeRegistry registry,
return getInterfacesHelper(jsdoc, registry, typeParameters, true);
private ImmutableSet<NominalType> getExtendedInterfaces(
JSDocInfo jsdoc, DeclaredTypeRegistry registry,
return getInterfacesHelper(jsdoc, registry, typeParameters, false);
JSDocInfo jsdoc, DeclaredTypeRegistry registry,
Node expRoot = texp.getRoot();
JSType interfaceType =
getMaybeTypeFromNode(expRoot, registry, typeParameters);
if (interfaceType != null) {
NominalType nt = interfaceType.getNominalTypeIfUnique();
public DeclaredFunctionType getFunctionType(
JSDocInfo jsdoc, String functionName, Node declNode,
RawNominalType constructorType, RawNominalType ownerType,
FunctionTypeBuilder builder = new FunctionTypeBuilder();
if (ownerType != null) {
builder.addReceiverType(ownerType.getAsNominalType());
Node jsdocNode = jsdoc.getType().getRoot();
jsdoc, declNode, ownerType, registry, builder);
try {
fillInFunTypeBuilder(jsdocNode, ownerType, registry,
ImmutableList.<String>of(), builder);
return builder.buildDeclaration();
return qmarkFunctionDeclared;
if (isQmarkFunction(jsdocNode)) {
return qmarkFunctionDeclared;
return getFunTypeFromTypicalFunctionJsdoc(null, functionName,
declNode, constructorType, ownerType, registry, builder, true);
return getFunTypeFromTypicalFunctionJsdoc(jsdoc, functionName,
declNode, constructorType, ownerType, registry, builder, false);
return qmarkFunctionDeclared;
private DeclaredFunctionType getFunTypeFromAtTypeJsdoc(
DeclaredTypeRegistry registry, FunctionTypeBuilder builder) {
Node childJsdoc = jsdoc.getType().getRoot().getFirstChild();
ImmutableList<String> typeParameters = ownerType == null
? ImmutableList.<String>of() : ownerType.getTypeParameters();
if (ownerType == null) {
builder.addReceiverType(getNominalType(
childJsdoc.getFirstChild(), registry, typeParameters));
getNominalType(childJsdoc.getFirstChild(), registry, typeParameters));
paramType.getFirstChild(), registry, typeParameters));
getTypeFromNode(paramType, registry, typeParameters));
paramType.getFirstChild(), registry, typeParameters));
builder.addRetType(getTypeFromNode(childJsdoc, registry, typeParameters));
return builder.buildDeclaration();
private DeclaredFunctionType getFunTypeFromTypicalFunctionJsdoc(
JSDocInfo jsdoc, String functionName, Node funNode,
RawNominalType constructorType, RawNominalType ownerType,
DeclaredTypeRegistry registry, FunctionTypeBuilder builder,
ImmutableList<String> typeParameters = ImmutableList.of();
if (ownerType != null) {
ImmutableList.Builder<String> paramsBuilder =
new ImmutableList.Builder<>();
paramsBuilder.addAll(typeParameters);
paramsBuilder.addAll(ownerType.getTypeParameters());
typeParameters = paramsBuilder.build();
fillInFormalParameterTypes(
jsdoc, funNode, typeParameters, registry, builder, ignoreJsdoc);
fillInReturnType(
jsdoc, funNode, parent, typeParameters, registry, builder, ignoreJsdoc);
if (jsdoc == null) {
return builder.buildDeclaration();
NominalType parentClass = getMaybeParentClass(
jsdoc, functionName, funNode, typeParameters, registry);
ImmutableSet<NominalType> implementedIntfs = getImplementedInterfaces(
jsdoc, registry, typeParameters);
if (constructorType == null
&& (jsdoc.isConstructor() || jsdoc.isInterface())) {
return builder.buildDeclaration();
handleConstructorAnnotation(functionName, funNode, constructorType,
parentClass, implementedIntfs, registry, builder);
handleInterfaceAnnotation(jsdoc, functionName, funNode, constructorType,
implementedIntfs, typeParameters, registry, builder);
warnings.add(JSError.make(
funNode, IMPLEMENTS_WITHOUT_CONSTRUCTOR, functionName));
if (jsdoc.hasThisType() && ownerType == null) {
Node thisNode = jsdoc.getThisType().getRoot();
JSType thisType =
getMaybeTypeFromNode(thisNode, registry, typeParameters);
NominalType thisTypeAsNominal = thisType == null
? null : thisType.getNominalTypeIfUnique();
builder.addReceiverType(thisTypeAsNominal);
return builder.buildDeclaration();
private void fillInFormalParameterTypes(
JSDocInfo jsdoc, Node funNode,
ImmutableList<String> typeParameters,
DeclaredTypeRegistry registry, FunctionTypeBuilder builder,
boolean ignoreJsdoc /* for when the jsdoc is malformed */) {
boolean ignoreFunNode  = !funNode.isFunction();
Node params = ignoreFunNode ? null : funNode.getFirstChild().getNext();
param.getJSDocInfo(), registry, typeParameters);
boolean isRequired = true;
boolean isRestFormals = false;
JSTypeExpression texp =
jsdoc == null ? null : jsdoc.getParameterType(pname);
Node jsdocNode = texp == null ? null : texp.getRoot();
fnParamType = getTypeFromNode(jsdocNode, registry, typeParameters);
private void fillInReturnType(
JSDocInfo jsdoc, Node funNode, Node parent,
ImmutableList<String> typeParameters,
DeclaredTypeRegistry registry, FunctionTypeBuilder builder,
boolean ignoreJsdoc /* for when the jsdoc is malformed */) {
JSDocInfo inlineRetJsdoc =
ignoreJsdoc ? null : funNode.getFirstChild().getJSDocInfo();
builder.addRetType(
getNodeTypeDeclaration(inlineRetJsdoc, registry, typeParameters));
builder.addRetType(
getTypeFromJSTypeExpression(retTypeExp, registry, typeParameters));
private NominalType getMaybeParentClass(
JSDocInfo jsdoc, String functionName, Node funNode,
ImmutableList<String> typeParameters, DeclaredTypeRegistry registry) {
if (!jsdoc.hasBaseType()) {
return null;
if (!jsdoc.isConstructor()) {
warnings.add(JSError.make(
funNode, EXTENDS_NOT_ON_CTOR_OR_INTERF, functionName));
return null;
Node docNode = jsdoc.getBaseType().getRoot();
JSType extendedType =
getMaybeTypeFromNode(docNode, registry, typeParameters);
if (extendedType == null) {
return null;
NominalType parentClass = extendedType.getNominalTypeIfUnique();
if (parentClass != null && parentClass.isClass()) {
return parentClass;
if (parentClass == null) {
warnings.add(JSError.make(funNode, EXTENDS_NON_OBJECT,
functionName, extendedType.toString()));
Preconditions.checkState(parentClass.isInterface());
warnings.add(JSError.make(funNode, CONFLICTING_EXTENDED_TYPE,
"constructor", functionName));
return null;
private void handleConstructorAnnotation(
String functionName, Node funNode, RawNominalType constructorType,
NominalType parentClass, ImmutableSet<NominalType> implementedIntfs,
DeclaredTypeRegistry registry, FunctionTypeBuilder builder) {
String className = constructorType.toString();
NominalType builtinObject = registry.getCommonTypes().getObjectType();
if (parentClass == null && !functionName.equals("Object")) {
parentClass = builtinObject;
if (parentClass != null) {
if (!constructorType.addSuperClass(parentClass)) {
warnings.add(JSError.make(funNode, INHERITANCE_CYCLE, className));
if (constructorType.isStruct() && !parentClass.isStruct()) {
warnings.add(JSError.make(
funNode, CONFLICTING_SHAPE_TYPE, "struct", className));
warnings.add(JSError.make(
funNode, CONFLICTING_SHAPE_TYPE, "dict", className));
if (constructorType.isDict() && !implementedIntfs.isEmpty()) {
warnings.add(JSError.make(funNode, DICT_IMPLEMENTS_INTERF, className));
boolean noCycles = constructorType.addInterfaces(implementedIntfs);
Preconditions.checkState(noCycles);
builder.addNominalType(constructorType.getAsNominalType());
private void handleInterfaceAnnotation(
JSDocInfo jsdoc, String functionName, Node funNode,
RawNominalType constructorType,
ImmutableSet<NominalType> implementedIntfs,
ImmutableList<String> typeParameters,
DeclaredTypeRegistry registry, FunctionTypeBuilder builder) {
if (!implementedIntfs.isEmpty()) {
warnings.add(JSError.make(
funNode, CONFLICTING_IMPLEMENTED_TYPE, functionName));
boolean noCycles = constructorType.addInterfaces(
getExtendedInterfaces(jsdoc, registry, typeParameters));
if (!noCycles) {
warnings.add(JSError.make(
funNode, INHERITANCE_CYCLE, constructorType.toString()));
builder.addNominalType(constructorType.getAsNominalType());
Node jsdocNode = texp == null ? null : texp.getRoot();
warnings.add(JSError.make(faultyNode, BAD_JSDOC_ANNOTATION, msg));
package com.google.javascript.jscomp.newtypes;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.javascript.jscomp.newtypes.NominalType.RawNominalType;
public class JSTypes {
private JSType numberInstance;
private JSType booleanInstance;
private JSType stringInstance;
private ObjectType numberInstanceObjtype;
private ObjectType booleanInstanceObjtype;
private ObjectType stringInstanceObjtype;
private JSType numberOrNumber;
private JSType stringOrString;
private JSType anyNumOrStr;
private JSType regexpType;
private RawNominalType arrayType;
private RawNominalType builtinObject;
private RawNominalType builtinFunction;
private JSTypes() {}
public static JSTypes make() {
return new JSTypes();
public JSType fromFunctionType(FunctionType fn) {
return JSType.fromFunctionType(fn, getFunctionType());
public NominalType getFunctionType() {
if (builtinFunction == null) {
return null;
return builtinFunction.getAsNominalType();
public JSType looseTopFunction() {
return topFunction().withLoose();
public JSType topFunction() {
return fromFunctionType(FunctionType.TOP_FUNCTION);
JSType qmarkFunction() {
return fromFunctionType(FunctionType.QMARK_FUNCTION);
public JSType getArrayInstance() {
return getArrayInstance(JSType.UNKNOWN);
public NominalType getObjectType() {
if (builtinObject == null) {
return null;
return builtinObject.getAsNominalType();
public JSType getArrayInstance(JSType t) {
if (arrayType == null) {
return JSType.UNKNOWN;
ImmutableList<String> typeParams = arrayType.getTypeParameters();
JSType result = arrayType.getInstanceAsJSType();
if (typeParams.size() == 1) {
String typeParam = Iterables.getOnlyElement(typeParams);
result = result.substituteGenerics(ImmutableMap.of(typeParam, t));
return result;
public JSType getRegexpType() {
return regexpType != null ? regexpType : JSType.UNKNOWN;
JSType getNumberInstance() {
return numberInstance != null ? numberInstance : JSType.NUMBER;
JSType getBooleanInstance() {
return booleanInstance != null ? booleanInstance : JSType.BOOLEAN;
JSType getStringInstance() {
return stringInstance != null ? stringInstance : JSType.STRING;
ObjectType getNumberInstanceObjType() {
return numberInstanceObjtype != null
? numberInstanceObjtype : ObjectType.TOP_OBJECT;
ObjectType getBooleanInstanceObjType() {
return booleanInstanceObjtype != null
? booleanInstanceObjtype : ObjectType.TOP_OBJECT;
ObjectType getStringInstanceObjType() {
return stringInstanceObjtype != null
? stringInstanceObjtype : ObjectType.TOP_OBJECT;
public void setFunctionType(RawNominalType builtinFunction) {
this.builtinFunction = builtinFunction;
public void setObjectType(RawNominalType builtinObject) {
this.builtinObject = builtinObject;
public void setArrayType(RawNominalType arrayType) {
this.arrayType = arrayType;
public void setRegexpInstance(JSType regexpType) {
this.regexpType = regexpType;
public void setNumberInstance(JSType t) {
Preconditions.checkState(numberInstance == null);
Preconditions.checkNotNull(t);
numberInstance = t;
numberOrNumber = JSType.join(JSType.NUMBER, numberInstance);
numberInstanceObjtype = Iterables.getOnlyElement(t.getObjs());
if (stringInstance != null) {
anyNumOrStr = JSType.join(numberOrNumber, stringOrString);
public void setBooleanInstance(JSType t) {
Preconditions.checkState(booleanInstance == null);
Preconditions.checkNotNull(t);
booleanInstance = t;
booleanInstanceObjtype = Iterables.getOnlyElement(t.getObjs());
public void setStringInstance(JSType t) {
Preconditions.checkState(stringInstance == null);
Preconditions.checkNotNull(t);
stringInstance = t;
stringOrString = JSType.join(JSType.STRING, stringInstance);
stringInstanceObjtype = Iterables.getOnlyElement(t.getObjs());
if (numberInstance != null) {
anyNumOrStr = JSType.join(numberOrNumber, stringOrString);
public boolean isNumberScalarOrObj(JSType t) {
if (numberOrNumber == null) {
return t.isSubtypeOf(JSType.NUMBER);
return t.isSubtypeOf(numberOrNumber);
public boolean isStringScalarOrObj(JSType t) {
if (numberOrNumber == null) {
return t.isSubtypeOf(JSType.STRING);
return t.isSubtypeOf(stringOrString);
public boolean isNumStrScalarOrObj(JSType t) {
if (anyNumOrStr == null) {
return t.isSubtypeOf(JSType.NUM_OR_STR);
return t.isSubtypeOf(anyNumOrStr);
import com.google.common.collect.Iterables;
public JSType getInstanceAsJSType() {
return (rawType.isGeneric() && !typeMap.isEmpty())
? JSType.fromObjectType(ObjectType.fromNominalType(this))
: rawType.getInstanceAsJSType();
boolean isClassy() {
return !isFunction() && !isObject();
boolean isFunction() {
return "Function".equals(rawType.name);
private boolean isObject() {
return "Object".equals(rawType.name);
public boolean isUninstantiatedGenericType() {
return rawType.isGeneric() && typeMap.isEmpty();
public JSType getPrototype() {
Preconditions.checkState(rawType.isFinalized);
return rawType.getCtorPropDeclaredType("prototype")
.substituteGenerics(typeMap);
if (rawType.name.equals("Array")
&& NUMERIC_PATTERN.matcher(pname).matches()) {
if (typeMap.isEmpty()) {
return Property.make(JSType.UNKNOWN, null);
Preconditions.checkState(typeMap.size() == 1);
JSType elmType = Iterables.getOnlyElement(typeMap.values());
return Property.make(elmType, null);
static JSType createConstructorObject(
FunctionType ctorFn, NominalType builtinFunction) {
return ctorFn.nominalType.rawType
.createConstructorObject(ctorFn, builtinFunction);
return areTypeParametersSubtypes(other);
return areTypeParametersSubtypes(other);
private boolean areTypeParametersSubtypes(NominalType other) {
Preconditions.checkState(rawType.equals(other.rawType));
if (typeMap.isEmpty()) {
return other.instantiationIsUnknownOrIdentity();
if (other.typeMap.isEmpty()) {
return instantiationIsUnknownOrIdentity();
for (String typeVar : rawType.getTypeParameters()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, typeMap.keySet());
Preconditions.checkState(other.typeMap.containsKey(typeVar),
"Other (%s) doesn't contain mapping (%s->%s) from this (%s)",
other, typeVar, typeMap.get(typeVar), this);
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
return true;
private boolean instantiationIsUnknownOrIdentity() {
if (this.typeMap.isEmpty()) {
return true;
for (String typeVar : this.rawType.getTypeParameters()) {
Preconditions.checkState(this.typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, this.typeMap.keySet());
JSType t = this.typeMap.get(typeVar);
if (!t.isUnknown() && !t.equals(JSType.fromTypeVar(typeVar))) {
return false;
return true;
if (other.typeMap.isEmpty()) {
return true;
private NominalType builtinFunction;
ObjectType objInstance = "Function".equals(name)
? ObjectType.fromFunction(
FunctionType.TOP_FUNCTION, this.wrappedAsNominal)
: ObjectType.fromNominalType(this.wrappedAsNominal);
this.wrappedAsJSType = JSType.fromObjectType(objInstance);
public void setCtorFunction(
FunctionType ctorFn, NominalType builtinFunction) {
this.builtinFunction = builtinFunction;
private JSType createConstructorObject(
FunctionType ctorFn, NominalType builtinFunction) {
return withNamedTypes(ObjectType.makeObjectType(
builtinFunction, otherProps, ctorFn,
ctorFn.isLoose(), ObjectKind.UNRESTRICTED));
builder.append("<");
Preconditions.checkState(this.isFinalized);
return createConstructorObject(ctorFn, builtinFunction);
Preconditions.checkArgument(FunctionType.isInhabitable(fn));
Preconditions.checkArgument(fn == null || nominalType != null,
"Cannot create function %s without nominal type", fn);
if (nominalType != null) {
Preconditions.checkArgument(!nominalType.isClassy() || !isLoose,
"Cannot create loose objectType with nominal type %s", nominalType);
Preconditions.checkArgument(fn == null || nominalType.isFunction(),
"Cannot create objectType of nominal type %s with function (%s)",
nominalType, fn);
static ObjectType fromFunction(FunctionType fn, NominalType fnNominal) {
fnNominal, null, fn, fn.isLoose(), ObjectKind.UNRESTRICTED);
static ObjectType fromNominalType(NominalType cl) {
if (isLoose()
|| this.nominalType != null && this.nominalType.isClassy()) {
return this.fn == null || obj2.isLoose();
if (resultNominalType != null && resultNominalType.isClassy()) {
meetPropsHelper(true, resultNominalType, this.props, other.props);
resultNominalType,
if (!FunctionType.isInhabitable(fn)) {
return BOTTOM_OBJECT;
NominalType nominal =
NominalType.pickSuperclass(obj1.nominalType, obj2.nominalType);
if (nominal == null || !nominal.isFunction()) {
fn = null;
nominal,
if (fn != null) {
if (other.fn == null ||
!fn.unifyWith(other.fn, typeParameters, typeMultimap)) {
return false;
import com.google.common.base.Joiner;
return Joiner.on(".").join(parts);
List<String> names = Splitter.on(',')
.trimResults()
.splitToList(templateNames);
List<String> names = Splitter.on(',')
.trimResults()
.splitToList(templateInfo.string);
if (token != JsDocToken.LEFT_CURLY) {
parser.addParserWarning("msg.jsdoc.suppress",
stream.getLineno(), stream.getCharno());
boolean squareBrackets = match(JsDocToken.LEFT_SQUARE);
if (squareBrackets) {
next();
if (squareBrackets) {
if (match(JsDocToken.RIGHT_SQUARE)) {
next();
return reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
String s = new String(stringBuffer, 0, stringBufferTop);
return s.intern();
static final String MISPLACED_FUNCTION_ANNOTATION =
"This JSDoc is not attached to a function node. Are you missing parentheses?";
static final String STRING_CONTINUATION_ERROR =
static final String STRING_CONTINUATION_WARNING =
"String continuations are not recommended. See"
+ " https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Multiline_string_literals";
validateJsDoc(n);
private void validateJsDoc(Node n) {
validateTypeAnnotations(n);
validateFunctionJsDoc(n);
private void validateFunctionJsDoc(Node n) {
JSDocInfo info = n.getJSDocInfo();
if (info == null) {
return;
if (info.containsFunctionDeclaration() && !info.hasType()) {
switch (n.getType()) {
case Token.FUNCTION:
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_DEF:
case Token.STRING_KEY:
return;
case Token.GETELEM:
case Token.GETPROP:
if (n.getFirstChild().isQualifiedName()) {
return;
break;
case Token.ASSIGN: {
return;
errorReporter.warning(MISPLACED_FUNCTION_ANNOTATION,
sourceName,
n.getLineno(), n.getCharno());
int type = transformUnaryTokenType(exprNode.operator.type);
setSourceInfo(decls, tree);
Node exportSpec = newNode(Token.EXPORT_SPEC,
exportSpec.addChildToBack(processName(tree.destinationName));
return exportSpec;
Node firstChild = transformOrEmpty(tree.defaultBindingIdentifier, tree);
Node secondChild = (tree.nameSpaceImportIdentifier != null)
? newStringNode(Token.IMPORT_STAR, tree.nameSpaceImportIdentifier.value)
: transformListOrEmpty(Token.IMPORT_SPECS, tree.importSpecifierList);
Node thirdChild = processString(tree.moduleSpecifier);
return newNode(Token.IMPORT, firstChild, secondChild, thirdChild);
if (isEs5OrBetterMode()) {
errorReporter.error(STRING_CONTINUATION_ERROR,
sourceName,
lineno(token.location.start), charno(token.location.start));
double v = 0;
return v;
double v = 0;
return v;
double v = 0;
return v;
double v = 0;
return v;
private static int transformUnaryTokenType(TokenType token) {
getTreeLocation(start), null, null, null, moduleSpecifier);
IdentifierToken nameSpaceImportIdentifier = null;
boolean parseExplicitNames = true;
parseExplicitNames = false;
if (parseExplicitNames) {
if (peek(TokenType.STAR)) {
eat(TokenType.STAR);
eatPredefinedString(PredefinedName.AS);
nameSpaceImportIdentifier = eatId();
defaultBindingIdentifier, identifierSet, nameSpaceImportIdentifier, moduleSpecifier);
if (peekImplicitSemiColon()) {
reportError("No newline allowed before '=>'");
if (peekPatternStart()) {
if (peekImplicitSemiColon()) {
reportError("semicolon/newline not allowed after 'throw'");
if (peekPatternStart()) {
nextToken();
return new MissingPrimaryExpressionTree(getTreeLocation(start));
return peekParenPattern(PatternKind.ANY, assignmentFollowSet);
private static final EnumSet<TokenType> assignmentFollowSet =
EnumSet.of(TokenType.EQUAL);
public final IdentifierToken defaultBindingIdentifier;
public final IdentifierToken nameSpaceImportIdentifier;
IdentifierToken defaultBindingIdentifier,
IdentifierToken nameSpaceImportIdentifier,
this.defaultBindingIdentifier = defaultBindingIdentifier;
this.nameSpaceImportIdentifier = nameSpaceImportIdentifier;
public MissingPrimaryExpressionTree(SourceRange location) {
protected void reportMessage(
SourcePosition location, String kind, String format, Object... arguments) {
throw new ParseException();
import java.util.Arrays;
Arrays.fill(paddingChars, paddingChar);
Arrays.fill(zeros, '0');
Arrays.fill(zeros, '0');
public ChainableReverseAbstractInterpreter(JSTypeRegistry typeRegistry) {
public ClosureReverseAbstractInterpreter(final JSTypeRegistry typeRegistry) {
super(typeRegistry);
public SemanticReverseAbstractInterpreter(JSTypeRegistry typeRegistry) {
super(typeRegistry);
DISABLE_PROPERTY_RENAMING("disable_property_renaming"),
if (lastIndex <= code.length()) {
package com.google.javascript.refactoring;
import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.JSError;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public final class ErrorToFixMapper {
private ErrorToFixMapper() {} // All static
private static final Pattern DID_YOU_MEAN = Pattern.compile(".*Did you mean (.*)\\?");
private static final Pattern MISSING_REQUIRE =
Pattern.compile("'([^']+)' used but not goog\\.require'd");
public static SuggestedFix getFixForJsError(JSError error, AbstractCompiler compiler) {
switch (error.getType().key) {
case "JSC_DEBUGGER_STATEMENT_PRESENT":
return getFixForDebuggerStatement(error);
case "JSC_INEXISTENT_PROPERTY":
return getFixForInexistentProperty(error);
case "JSC_MISSING_REQUIRE_WARNING":
return getFixForMissingRequire(error, compiler);
case "JSC_UNNECESSARY_CAST":
return getFixForUnnecessaryCast(error, compiler);
default:
return null;
private static SuggestedFix getFixForDebuggerStatement(JSError error) {
return new SuggestedFix.Builder().delete(error.node).build();
private static SuggestedFix getFixForInexistentProperty(JSError error) {
Matcher m = DID_YOU_MEAN.matcher(error.description);
if (m.matches()) {
String suggestedPropName = m.group(1);
return new SuggestedFix.Builder().rename(error.node, suggestedPropName).build();
return null;
private static SuggestedFix getFixForMissingRequire(JSError error, AbstractCompiler compiler) {
Matcher regexMatcher = MISSING_REQUIRE.matcher(error.description);
Preconditions.checkState(regexMatcher.matches(),
"Unexpected error description: %s", error.description);
String namespaceToRequire = regexMatcher.group(1);
NodeMetadata metadata = new NodeMetadata(compiler);
Match match = new Match(error.node, metadata);
return new SuggestedFix.Builder()
.addGoogRequire(match, namespaceToRequire)
.build();
private static SuggestedFix getFixForUnnecessaryCast(JSError error, AbstractCompiler compiler) {
return new SuggestedFix.Builder().removeCast(error.node, compiler).build();
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import com.google.javascript.jscomp.ErrorManager;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.spi.BooleanOptionHandler;
import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
hidden = true,
handler = BooleanOptionHandler.class,
usage = "Show instructions for how to use RefasterJS")
private boolean displayHelp = false;
name = "--inputs",
usage = "List of input files for the refactoring. You may also use glob patterns to "
+ "match files. For example, use --js='**.js' --js='!**_test.js' "
+ "to recursively include all js files that do not end in _test.js")
private boolean verbose = false;
private List<String> arguments = new ArrayList<>();
if (args.length < 1 || displayHelp) {
CmdLineParser p = new CmdLineParser(this);
p.printUsage(System.out);
return;
Preconditions.checkArgument(
!Strings.isNullOrEmpty(refasterJsTemplate), "--refasterjs_template must be provided");
List<String> fileInputs = getInputs();
Preconditions.checkArgument(
!fileInputs.isEmpty(), "At least one input must be provided in the --inputs flag.");
for (String input : fileInputs) {
Preconditions.checkArgument(
new File(input).exists(), "Input file %s does not exist.", input);
if (!verbose) {
Logger errorManagerLogger = Logger.getLogger("com.google.javascript.jscomp");
errorManagerLogger.setLevel(Level.OFF);
.addInputsFromFile(fileInputs)
System.out.println("Compiling JavaScript code and searching for suggested fixes.");
if (!verbose) {
ErrorManager errorManager = driver.getCompiler().getErrorManager();
System.out.println("Compiler results: " + errorManager.getErrorCount()
+ " errors and " + errorManager.getWarningCount() + " warnings.");
System.out.println("Found " + fixes.size() + " suggested fixes.");
if (!fixes.isEmpty()) {
System.out.println("SuggestedFixes: " + fixes);
Set<String> affectedFiles = new TreeSet<>();
for (SuggestedFix fix : fixes) {
affectedFiles.addAll(fix.getReplacements().keySet());
System.out.println("Modifying affected files: " + affectedFiles);
private List<String> getInputs() throws IOException {
Set<String> patterns = new HashSet<>();
Splitter commaSplitter = Splitter.on(',');
for (String input : inputs) {
patterns.addAll(commaSplitter.splitToList(input));
patterns.addAll(arguments);
return CommandLineRunner.findJsFiles(patterns);
this.templateJs =
Thread.currentThread().getContextClassLoader().getResource(refasterjsTemplate) != null
"The template JS must be loaded before the scanner is used. "
+ "Make sure that the template file is not empty.");
Preconditions.checkNotNull(nodeToInsertBefore.getSourceFileName(),
"No source file name for node: %s", nodeToInsertBefore);
Preconditions.checkState(n.getParent().isGetProp());
nodeToRename = n;
"Rename is not implemented for this node type: " + n);
Node parent = original.getParent();
if (original.getParent().isExprResult()) {
original = original.getParent();
String newCode = generateCode(compiler, newNode);
if (newCode.endsWith("\n")) {
newCode = newCode.substring(0, newCode.length() - 1);
boolean needsSemicolon = parent.isExprResult() || parent.isBlock() || parent.isScript();
if (newCode.endsWith(";") && !needsSemicolon) {
newCode = newCode.substring(0, newCode.length() - 1);
new CodeReplacement(original.getSourceOffset(), original.getLength(), newCode));
package com.google.javascript.refactoring.testing;
import static org.junit.Assert.assertEquals;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.SetMultimap;
import com.google.javascript.refactoring.CodeReplacement;
import com.google.javascript.refactoring.SuggestedFix;
import java.util.Set;
public final class SuggestedFixes {
private SuggestedFixes() {}
public static void assertReplacement(SuggestedFix fix, CodeReplacement expectedReplacement) {
assertReplacements(fix, ImmutableSet.of(expectedReplacement));
private static void assertReplacements(
SuggestedFix fix, Set<CodeReplacement> expectedReplacements) {
SetMultimap<String, CodeReplacement> replacementMap = fix.getReplacements();
assertEquals(1, replacementMap.size());
Set<CodeReplacement> replacements = replacementMap.get("test");
assertEquals(expectedReplacements.size(), replacements.size());
assertEquals(expectedReplacements, replacements);
Preconditions.checkState(param.isName() || param.isRest());
Preconditions.checkState(param.isName() || param.isRest());
Preconditions.checkState(param.isName() || param.isRest());
public static Node rest(String name) {
return Node.newString(Token.REST, name);
public static Node spread(Node expr) {
Preconditions.checkState(mayBeExpression(expr));
return new Node(Token.SPREAD, expr);
public static Node superNode() {
return new Node(Token.SUPER);
public static Node memberDef(String name, Node function) {
Preconditions.checkState(function.isFunction());
Node member = Node.newString(Token.MEMBER_DEF, name);
member.addChildToBack(function);
return member;
case Token.SPREAD:
case Token.TEMPLATELIT:
case Token.THIS:
private static final int MASK_UNUSED_1      = 0x00010000; //
other.info = this.info;  // this should be cloned as it isn't immutable
boolean hasFunctionType = hasType() && getType().getRoot().isFunction();
return hasFunctionType
|| getFlag(MASK_CONSTRUCTOR)
|| (getFlag(MASK_NOSIDEEFFECTS) && (!hasType() || hasFunctionType));
documentation.throwsDescriptions = new LinkedHashMap<>();
documentation.parameters = new LinkedHashMap<>();
info.parameters = new LinkedHashMap<>();
info.templateTypeNames = new ArrayList<>();
info.typeTransformations = new LinkedHashMap<>();
EXPORT_ALL_FROM    = 63,    // Set if an export is a "*"
ANALYZED_DURING_GTI  = 75,  // In GlobalTypeInfo, we mark some AST nodes
CONSTANT_PROPERTY_DEF = 76; // Used to communicate information between
case CONSTANT_PROPERTY_DEF: return "constant_property_def";
getType() == Token.CALL || getType() == Token.NEW,
"setIsNoSideEffectsCall only supports CALL and NEW nodes, got %s",
Token.name(getType()));
warnings = new ArrayList<>();
errors = new ArrayList<>();
IMPORT_STAR    = 168, // "* as name", called NameSpaceImport in the spec.
EXPORT         = 169,
EXPORT_SPECS   = 170,
EXPORT_SPEC    = 171,
MODULE         = 172,
REST           = 173, // "..." in formal parameters, or an array pattern.
SPREAD         = 174, // "..." in a call expression, or an array literal.
COMPUTED_PROP  = 175,
TEMPLATELIT     = 176, // template literal
TEMPLATELIT_SUB = 177, // template literal substitution
DEFAULT_VALUE   = 178, // Formal parameter or destructuring element
case IMPORT_STAR:     return "IMPORT_STAR";
case IMPORT_STAR:     return 0;
return thisParam == null || thisParam.isOptionalArg() || thisParam.isVarArgs()
|| thatParam != null;
(getReferenceName() + "<" + primitiveType + ">");
private final Set<String> elements = new HashSet<>();
FunctionType superCtor =
isConstructor() ? getSuperClassConstructor() : null;
ImmutableList.Builder<ObjectType> builder = ImmutableList.builder();
builder.addAll(implementedInterfaces);
while (superCtor != null) {
builder.addAll(superCtor.implementedInterfaces);
superCtor = superCtor.getSuperClassConstructor();
return builder.build();
builder.append("...").append(
paramType.toStringHelper(forAnnotations));
return (jsType instanceof JSType) && isEquivalentTo((JSType) jsType);
private final Set<String> namespaces = new HashSet<>();
private final Set<String> nonNullableTypeNames = new HashSet<>();
private final Set<String> forwardDeclaredTypes = new HashSet<>();
namesToTypes = new HashMap<>();
Preconditions.checkState(type.isTemplateType(), "expected:%s", type);
PrototypeObjectType type = new PrototypeObjectType(
this, null, null, true /* anonymousType */);
return createNullableType(
throw new IllegalStateException("Unexpected node in type expression: " + n);
int pos = name.indexOf('(');
props.addAll(properties.keySet());
public class PrototypeObjectType extends ObjectType {
private final boolean anonymousType;
this(
registry,
className,
implicitPrototype,
false /* nativeType */,
null /* templateTypeMap */,
false /* anonymousType */);
PrototypeObjectType(JSTypeRegistry registry, String className,
ObjectType implicitPrototype, boolean anonymousType) {
this(
registry,
className,
implicitPrototype,
false /* nativeType */,
null /* templateTypeMap */,
anonymousType);
this(
registry,
className,
implicitPrototype,
nativeType,
templateTypeMap,
false /* anonymousType */);
PrototypeObjectType(JSTypeRegistry registry, String className,
ObjectType implicitPrototype, boolean nativeType,
TemplateTypeMap templateTypeMap, boolean anonymousType) {
this.anonymousType = anonymousType;
public boolean isAnonymous() {
return anonymousType;
this.visitedTypes = new ArrayDeque<>();
typeString += "<" + Joiner.on(",").join(templateTypes) + ">";
SortedSet<JSType> sorted = new TreeSet<>(ALPHA);
return alternates.get(0);
import static org.junit.Assert.assertEquals;
import org.junit.Assert;
assertEquals(
(b == null), (a == null));
+ " * @return {!Array.<?>}\n"
+ " * @template T\n"
import org.junit.Assert;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import junit.framework.TestCase;
public void testMap() throws Exception{
String sourceMap = ""
+ "{"
+ "  \"version\": 3,"
+ "  \"file\": \"testcode.js\","
+ "  \"sections\": ["
+ "    {"
+ "      \"map\": {"
+ "         \"version\": 3,"
+ "         \"mappings\": \"AAAAA,QAASA,UAAS,EAAG;\","
+ "         \"sources\": [\"testcode.js\"],"
+ "         \"names\": [\"foo\"]"
+ "      },"
+ "      \"offset\": {"
+ "        \"line\": 1,"
+ "        \"column\": 1"
+ "      }"
+ "    }"
+ "  ]"
+ "}";
SourceMapConsumerV3 consumer = new SourceMapConsumerV3();
consumer.parse(sourceMap);
assertEquals(2, ((JsonElement) exts.get("x_org_int")).getAsInt());
assertEquals(0, ((JsonArray) exts.get("x_org_array")).size());
import static org.junit.Assert.assertFalse;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
mapper.addExtension("x_google_foo", new JsonObject());
mapper.addExtension("x_google_test", parseJsonObject("{\"number\" : 1}"));
mapper.addExtension("x_google_array", new JsonArray());
JsonObject sourceMap = parseJsonObject(out.toString());
assertEquals(1, sourceMap.get("x_google_test").getAsJsonObject().get("number").getAsInt());
assertEquals(0, sourceMap.get("x_google_array").getAsJsonArray().size());
assertEquals(2, sourceMap.get("x_google_int").getAsInt());
assertEquals("Some text", sourceMap.get("x_google_str").getAsString());
return (Integer) currentValue
+ ((JsonPrimitive) newValue).getAsInt();
assertFalse(((JsonPrimitive) mapper.getExtension("x_company_bar")).getAsBoolean());
JsonObject mapping = parseJsonObject(out.toString());
assertEquals(3, mapping.get("version").getAsInt());
mapping = parseJsonObject(out.toString());
mapping = parseJsonObject(out.toString());
assertEquals("http://url/path", mapping.get("sourceRoot").getAsString());
private JsonObject parseJsonObject(String json) {
return new Gson().fromJson(json, JsonObject.class);
public void testGlobalAssignment() {
lastPass = AmbiguateProperties.makePassForTesting(
compiler, new char[]{'$'});
public void testSplitNamedFunction() {
public void testSplitNamedFunctionWithArgs() {
public void disable_testSplitAnonFunction() {
public void disable_testSplitMupltiFunctions() {
enableClosurePass();
public void testNoPrivateAccessForNamespaces() {
test(new String[]{
"var foo = {};\n" +
"/** @private */ foo.bar_ = function() {};",
"foo.bar_();"
public void testProtectedAccessForProperties10() {
testSame(ImmutableList.of(
SourceFile.fromCode("foo.js",
"/** @constructor */ var Foo = function() {};" +
"/** @protected */ Foo.prototype.bar = function() {};"),
SourceFile.fromCode("sub_foo.js",
"/** @constructor @extends {Foo} */" +
"var SubFoo = function() {};" +
"(function() {" +
"SubFoo.prototype.baz = function() { this.bar(); }" +
"})();")));
public void testNoPackagePrivateAccessForNamespaces() {
test(ImmutableList.of(
SourceFile.fromCode(
"foo/bar.js",
"var foo = {};\n" +
"/** @package */ foo.bar = function() {};"),
SourceFile.fromCode(
"baz/quux.js",
"foo.bar();")),
null, BAD_PACKAGE_PROPERTY_ACCESS);
public void testNamespacedFunctionDoesNotNeedVisibilityRedeclInFileWithFileOverviewVisibility() {
testSame(
"/**\n" +
" * @fileoverview\n" +
" * @package\n" +
" */\n" +
"/** @return {string} */\n" +
"foo.bar = function() {};");
public void testFileoverviewVisibilityDoesNotApplyToGoogProvidedNamespace1() {
compareJsDoc = false;
test(ImmutableList.of(
SourceFile.fromCode(
"foo.js",
"goog.provide('foo');"),
SourceFile.fromCode(
"foo/bar.js",
"/**\n" +
"  * @fileoverview\n" +
"  * @package\n" +
"  */\n" +
"goog.provide('foo.bar');"),
SourceFile.fromCode(
"bar.js",
"goog.require('foo')")),
ImmutableList.of(
SourceFile.fromCode("foo.js", "var foo={};"),
SourceFile.fromCode("foo/bar.js", "foo.bar={};"),
SourceFile.fromCode("bar.js", "")),
null, null);
compareJsDoc = true;
public void testFileoverviewVisibilityDoesNotApplyToGoogProvidedNamespace2() {
compareJsDoc = false;
test(ImmutableList.of(
SourceFile.fromCode(
"foo/bar.js",
"/**\n" +
"  * @fileoverview\n" +
"  * @package\n" +
"  */\n" +
"goog.provide('foo.bar');"),
SourceFile.fromCode(
"foo.js",
"goog.provide('foo');"),
SourceFile.fromCode(
"bar.js",
"goog.require('foo');\n" +
"var x = foo;")),
ImmutableList.of(
SourceFile.fromCode("foo/bar.js", "var foo={};foo.bar={};"),
SourceFile.fromCode("foo.js", ""),
SourceFile.fromCode("bar.js", "var x=foo")),
null, null);
compareJsDoc = true;
public void testFileoverviewVisibilityDoesNotApplyToGoogProvidedNamespace3() {
compareJsDoc = false;
test(ImmutableList.of(
SourceFile.fromCode(
"foo/bar.js",
"/**\n" +
" * @fileoverview\n" +
" * @package\n" +
" */\n" +
"goog.provide('one.two');\n" +
"one.two.three = function(){};"),
SourceFile.fromCode(
"baz.js",
"goog.require('one.two');\n" +
"var x = one.two;")),
ImmutableList.of(
SourceFile.fromCode(
"foo/bar.js",
"var one={};one.two={};one.two.three=function(){};"),
SourceFile.fromCode(
"baz.js",
"var x=one.two")),
null, null);
compareJsDoc = true;
public void testFileoverviewVisibilityDoesNotApplyToGoogProvidedNamespace4() {
test(ImmutableList.of(
SourceFile.fromCode(
"foo/bar.js",
"/**\n" +
" * @fileoverview\n" +
" * @package\n" +
" */\n" +
"goog.provide('one.two');\n" +
"one.two.three = function(){};"),
SourceFile.fromCode(
"baz.js",
"goog.require('one.two');\n" +
"var x = one.two.three();")),
null, BAD_PACKAGE_PROPERTY_ACCESS);
import java.util.List;
"/** @type {Arguments} */ var arguments;\n" +
"/** @constructor \n" +
" * @param {*=} opt_message\n" +
" * @param {*=} opt_file\n" +
" * @param {*=} opt_line\n" +
" * @return {!Error} \n" +
"*/" +
"var Error;" +
"var alert;" +
"";
enableClosurePass();
enableClosurePassForExpected();
options.setCodingConvention(getCodingConvention());
public void testFileOnOnlyApplyToIsChecked() {
configuration =
"requirement: {\n" +
"  type: BANNED_NAME\n" +
"  value: 'eval'\n" +
"  error_message: 'eval is not allowed'\n" +
"  only_apply_to: 'foo.js'\n " +
"}";
ImmutableList<SourceFile> input = ImmutableList.of(
SourceFile.fromCode("foo.js", "eval()"));
test(input, input, null, CheckConformance.CONFORMANCE_VIOLATION,
"Violation: eval is not allowed");
public void testFileNotOnOnlyApplyToIsNotChecked() {
configuration =
"requirement: {\n" +
"  type: BANNED_NAME\n" +
"  value: 'eval'\n" +
"  error_message: 'eval is not allowed'\n" +
"  only_apply_to: 'foo.js'\n " +
"}";
testSame(ImmutableList.of(SourceFile.fromCode("bar.js", "eval()")));
public void testFileOnOnlyApplyToRegexpIsChecked() {
configuration =
"requirement: {\n" +
"  type: BANNED_NAME\n" +
"  value: 'eval'\n" +
"  error_message: 'eval is not allowed'\n" +
"  only_apply_to_regexp: 'test.js$'\n " +
"}";
ImmutableList<SourceFile> input = ImmutableList.of(
SourceFile.fromCode("foo_test.js", "eval()"));
test(input, input, null, CheckConformance.CONFORMANCE_VIOLATION,
"Violation: eval is not allowed");
public void testFileNotOnOnlyApplyToRegexpIsNotChecked() {
configuration =
"requirement: {\n" +
"  type: BANNED_NAME\n" +
"  value: 'eval'\n" +
"  error_message: 'eval is not allowed'\n" +
"  only_apply_to_regexp: 'test.js$'\n " +
"}";
testSame(ImmutableList.of(SourceFile.fromCode("bar.js", "eval()")));
public void testSpecifyingWhitelistAndOnlyApplyToIsRuntimeError() {
configuration =
"requirement: {\n" +
"  type: BANNED_NAME\n" +
"  value: 'eval'\n" +
"  error_message: 'eval is not allowed'\n" +
"  whitelist: 'blah'\n" +
"  only_apply_to_regexp: 'test.js$'\n " +
"}";
try {
testSame(ImmutableList.of(SourceFile.fromCode("bar.js", "eval()")));
fail("expected IllegalArgumentException");
assertTrue(e instanceof IllegalArgumentException);
public void testCustomBanExpose() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanExpose'\n" +
"  error_message: 'BanExpose Message'\n" +
"}";
testSame(
EXTERNS,
"/** @expose */ var x;",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanExpose Message");
public void testCustomRestrictThrow1() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanThrowOfNonErrorTypes'\n" +
"  error_message: 'BanThrowOfNonErrorTypes Message'\n" +
"}";
testSame(
EXTERNS,
"throw 'blah';",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanThrowOfNonErrorTypes Message");
public void testCustomRestrictThrow2() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanThrowOfNonErrorTypes'\n" +
"  error_message: 'BanThrowOfNonErrorTypes Message'\n" +
"}";
testSame("throw new Error('test');");
public void testCustomBanUnknownThis1() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanUnknownThis'\n" +
"  error_message: 'BanUnknownThis Message'\n" +
"}";
testSame(
EXTERNS,
"function f() {alert(this);}",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanUnknownThis Message");
public void testCustomBanUnknownThis2() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanUnknownThis'\n" +
"  error_message: 'BanUnknownThis Message'\n" +
"}";
testSame(
"/** @constructor */ function C() {alert(this);}");
public void testCustomBanUnknownThis3() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanUnknownThis'\n" +
"  error_message: 'BanUnknownThis Message'\n" +
"}";
testSame(
"function f() {alert(/** @type {Error} */(this));}");
public void testCustomBanUnknownThis4() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanUnknownThis'\n" +
"  error_message: 'BanUnknownThis Message'\n" +
"}";
testSame(
"function f() {goog.asserts.assertInstanceof(this, Error);}");
public void testCustomBanGlobalVars1() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanGlobalVars'\n" +
"  error_message: 'BanGlobalVars Message'\n" +
"}";
testSame(
EXTERNS,
"var x;",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanGlobalVars Message");
testSame(
EXTERNS,
"function fn() {}",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanGlobalVars Message");
testSame(
"goog.provide('x');");
testSame(
EXTERNS,
"goog.provide('x'); var x;",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: BanGlobalVars Message");
public void testRequireFileoverviewVisibility() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$" +
"RequireFileoverviewVisibility'\n" +
"  error_message: 'RequireFileoverviewVisibility Message'\n" +
"}";
testSame(
EXTERNS,
"var foo = function() {};",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: RequireFileoverviewVisibility Message");
testSame(
EXTERNS,
"/**\n" +
"  * @fileoverview\n" +
"  */\n" +
"var foo = function() {};",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: RequireFileoverviewVisibility Message");
testSame(
EXTERNS,
"/**\n" +
"  * @package\n" +
"  */\n" +
"var foo = function() {};",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: RequireFileoverviewVisibility Message");
testSame(
"/**\n" +
"  * @fileoverview\n" +
"  * @package\n" +
"  */\n" +
"var foo = function() {};");
public void testNoImplicitlyPublicDecls() {
configuration =
"requirement: {\n" +
"  type: CUSTOM\n" +
"  java_class: 'com.google.javascript.jscomp.ConformanceRules$" +
"NoImplicitlyPublicDecls'\n" +
"  error_message: 'NoImplicitlyPublicDecls Message'\n" +
"}";
testSame(
EXTERNS,
"goog.provide('foo.bar');\n" +
"/** @constructor */foo.bar.Baz = function(){};",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: NoImplicitlyPublicDecls Message");
testSame(
"/** @package\n@fileoverview */\n" +
"goog.provide('foo.bar');\n" +
"/** @constructor */foo.bar.Baz = function(){};");
testSame(
"goog.provide('foo.bar');\n" +
"/** @package @constructor */foo.bar.Baz = function(){};");
testSame(
EXTERNS,
"goog.provide('foo.bar');\n" +
"/** @public @constructor */foo.bar.Baz = function(){};\n" +
"/** @type {number} */foo.bar.Baz.prototype.quux = 42;",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: NoImplicitlyPublicDecls Message");
testSame(
"/** @fileoverview\n@package*/\n" +
"goog.provide('foo.bar');\n" +
"/** @public @constructor */foo.bar.Baz = function(){};\n" +
"/** @type {number} */foo.bar.Baz.prototype.quux = 42;");
testSame(
"goog.provide('foo.bar');\n" +
"/** @public @constructor */foo.bar.Baz = function(){};\n" +
"/** @package {number} */foo.bar.Baz.prototype.quux = 42;");
testSame(
EXTERNS,
"goog.provide('foo');\n" +
"/** @public @constructor */\n" +
"foo.Bar = function() {\n" +
"  /** @type {number} */ this.baz = 52;\n" +
"};",
CheckConformance.CONFORMANCE_VIOLATION,
"Violation: NoImplicitlyPublicDecls Message");
testSame(
"goog.provide('foo');\n" +
"/** @public @constructor */\n" +
"foo.Bar = function() {\n" +
"  /** @package {number} */ this.baz = 52;\n" +
"};");
testSame(
"/** @fileoverview\n@package */\n" +
"goog.provide('foo');\n" +
"/** @constructor */\n" +
"foo.Bar = function() {\n" +
"  /** @type {number} */ this.baz = 52;\n" +
"};");
testSame("goog.provide('foo.bar');");
testSame(
"goog.provide('foo');\n" +
"/** @public @constructor */" +
"foo.Bar = function() {};\n" +
"/** @public */foo.Bar.prototype.baz = function() {};\n" +
"/** @public @constructor @extends {foo.Bar} */\n" +
"foo.Quux = function() {};\n" +
"/** @override */foo.Quux.prototype.baz = function() {};");
testSame("var foo");
testSame("var foo = 42;");
testSame("goog.provide('foo');\n" +
"/** @constructor @public */foo.Bar = function() {};\n" +
"foo.Bar.prototype = {\n" +
"  baz: function(){}\n" +
"};");
public void testMergeRequirements() {
Compiler compiler = createCompiler();
ConformanceConfig.Builder builder = ConformanceConfig.newBuilder();
builder.addRequirementBuilder().setRuleId("a").addWhitelist("x").addWhitelistRegexp("m");
builder.addRequirementBuilder().setExtends("a").addWhitelist("y").addWhitelistRegexp("n");
List<Requirement> requirements =
CheckConformance.mergeRequirements(compiler, ImmutableList.of(builder.build()));
assertEquals(1, requirements.size());
Requirement requirement = requirements.get(0);
assertEquals(2, requirement.getWhitelistCount());
assertEquals(2, requirement.getWhitelistRegexpCount());
public void testMergeRequirements_findsDuplicates() {
Compiler compiler = createCompiler();
ErrorManager errorManager = new BlackHoleErrorManager(compiler);
ConformanceConfig.Builder builder = ConformanceConfig.newBuilder();
builder.addRequirementBuilder().addWhitelist("x").addWhitelist("x");
CheckConformance.mergeRequirements(compiler, ImmutableList.of(builder.build()));
assertEquals(1, errorManager.getErrorCount());
import com.google.common.base.Joiner;
public void testFailWithImplements() {
String[] js = new String[] {
"var goog = {};"
+ "goog.provide('example.Foo'); /** @interface */ example.Foo = function() {};",
"/** @constructor @implements {example.Foo} */ var Ctor = function() {};"
String warning = "'example.Foo' used but not goog.require'd";
test(js, js, null, MISSING_REQUIRE_WARNING, warning);
public void testPassWithImplements() {
String js = "goog.require('example.Foo');"
+ "/** @constructor @implements {example.Foo} */"
+ "var Ctor = function() {};";
testSame(js);
String localVar = Joiner.on('\n').join(
"/** @constructor */ function tempCtor() {}",
"function baz() {",
"  /** @constructor */ function tempCtor() {}",
"  var foo = new tempCtor();",
"}");
new ClosureReverseAbstractInterpreter(registry);
public void testBundle3() {
test(
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('ns.a');" +
"goog.module.declareLegacyNamespace();" +
"var b = goog.require('ns.b');" +
"return exports;});",
"'use strict';" +
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
public void testBundle4() {
test(
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('ns.a');" +
"var b = goog.require('goog.asserts');" +
"return exports;});",
"'use strict';" +
"goog.provide('ns.a');" +
"goog.require('goog.asserts');" +
"goog.scope(function(){" +
"  var b = goog.asserts;" +
"});");
public void testBundle5() {
test(
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('xid');" +
"" +
"goog.module.declareLegacyNamespace();" +
"" +
"var asserts = goog.require('goog.asserts');" +
"" +
"exports = function(id) {" +
"  return xid.internal_(id);" +
"};" +
"var xid = exports;" +
"return exports;});",
"goog.provide('xid');" +
"goog.require('goog.asserts');" +
"goog.scope(function(){" +
"var asserts=goog.asserts;" +
"/** @const */ xid=function(id){return xid_module.internal_(id)};" +
"var xid_module=xid})");
"  /** @const */ ns.a = {};" +
"  /** @const */ ns.a.x = 1;" +
public void testExport3() {
test(
"goog.module('xid');" +
"var xid = function() {};" +
"exports = xid;",
"goog.provide('xid');" +
"goog.scope(function(){" +
"  var xid_module = function() {};" +
"  /** @const */ xid = xid_module;" +
"});");
public void testExport4() {
test(
"goog.module('ns.a');" +
"exports = { something: 1 };",
"goog.provide('ns.a');" +
"goog.scope(function(){" +
"  /** @const */ ns.a = { /** @const */ something: 1 };" +
"});");
public void testExport5() {
test(
"goog.module('ns.a');"
+ "/** @typedef {string} */ var x;"
+ "exports.x = x;",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  /** @typedef {string} */ var x;"
+ "  /** @typedef {string} */ ns.a.x = x;"
+ "});");
public void testExport6() {
test(
"goog.module('ns.a');"
+ "/** @typedef {string} */ var x;"
+ "exports = { something: x };",
"goog.provide('ns.a');"
+ "goog.scope(function(){"
+ "  /** @typedef {string} */ var x;"
+ "  /** @const */ ns.a = { /** @typedef {string} */ something: x };"
+ "});");
"/** @typedef {Array<number>} */ goog.java.Long;\n"
+ " * @param {(Array<number>|null)} a\n"
public void testDoLoopIECompatibility() {
public void testFunctionSafariCompatibility() {
assertPrintNumber("0x7fffffffffffffff", 0x7fffffffffffffffL);
public void testBiggerThanMaxLongNumericLiterals() {
assertPrint("9223372036854775808", "0x7fffffffffffffff");
assertPrint("0x8000000000000000", "0x7fffffffffffffff");
languageMode = LanguageMode.ECMASCRIPT6;
assertPrint(
"0b1000000000000000000000000000000000000000000000000000000000000000",
"0x7fffffffffffffff");
assertPrint("0o1000000000000000000000", "0x7fffffffffffffff");
assertPrintSame("import\"foo\"");
assertPrintSame("import x,*as f from\"foo\"");
assertPrintSame("import*as f from\"foo\"");
return new CollapseProperties(compiler, true);
assertTrue(
new String(errReader.toByteArray(), UTF_8)
.contains("Bad value for --source_map_location_mapping"));
"digraph AST {\n"
+ "  node [color=lightblue2, style=filled];\n"
+ "  node0 [label=\"BLOCK\"];\n"
+ "  node1 [label=\"SCRIPT\"];\n"
+ "  node0 -> node1 [weight=1];\n"
+ "  node1 -> RETURN [label=\"UNCOND\", "
+ "fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
+ "  node0 -> RETURN [label=\"SYN_BLOCK\", "
+ "fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
+ "  node0 -> node1 [label=\"UNCOND\", "
+ "fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
+ "}\n\n",
new String(outReader.toByteArray(), UTF_8));
public void testProcessCJSWithClosureRequires() {
args.add("--process_common_js_modules");
args.add("--common_js_entry_module=app.js");
args.add("--manage_closure_dependencies");
setFilename(0, "base.js");
setFilename(1, "array.js");
setFilename(2, "Baz.js");
setFilename(3, "app.js");
test(new String[] {
"/** @provideGoog */\n" +
"/** @const */ var goog = goog || {};\n" +
"var COMPILED = false;\n" +
"goog.provide = function (arg) {};\n" +
"goog.require = function (arg) {};\n",
"goog.provide('goog.array');\n",
"goog.require('goog.array');\n" +
"function Baz() {}\n" +
"Baz.prototype = {\n" +
"  baz: function() {\n" +
"    return goog.array.last(['asdf','asd','baz']);\n" +
"  },\n" +
"  bar: function () {\n" +
"    return 4 + 4;\n" +
"  }\n" +
"}\n" +
"module.exports = Baz;",
"var Baz = require('./Baz');\n" +
"var baz = new Baz();\n" +
"console.log(baz.baz());\n" +
"console.log(baz.bar());\n"
new String[] {
"var goog=goog||{},COMPILED=!1;" +
"goog.provide=function(a){};goog.require=function(a){};",
"goog.array={};",
"function Baz$$module$Baz(){}" +
"Baz$$module$Baz.prototype={" +
"  baz:function(){return goog.array.last(['asdf','asd','baz'])}," +
"  bar:function(){return 8}" +
"};" +
"var module$Baz=Baz$$module$Baz;",
"var module$app={}," +
"    Baz$$module$app=module$Baz," +
"    baz$$module$app=new Baz$$module$app;" +
"console.log(baz$$module$app.baz());" +
"console.log(baz$$module$app.bar())"
fail(new String(errReader.toByteArray(), UTF_8));
String name = filenames.get(i);
Preconditions.checkState(name != null && !name.isEmpty());
return name;
import com.google.common.base.Joiner;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Token;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Map;
assertEquals(3, graph.getModuleCount());
assertEquals("[module$tonic]", result.get(0).getName());
assertEquals("[module$gin]", result.get(1).getName());
assertEquals("tonic.js", result.get(2).getName());
assertEquals("gin.js", result.get(3).getName());
assertEquals("mix.js", result.get(4).getName());
private static final List<SourceFile> EMPTY_EXTERNS = ImmutableList.of(
SourceFile.fromCode("externs", ""));
public void testInputDelimiters() throws Exception {
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
options.printInputDelimiter = true;
String fileOverview = "/** @fileoverview Foo */";
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("i1", ""),
SourceFile.fromCode("i2", fileOverview));
Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
assertTrue(result.success);
String outputSource = compiler.toSource();
System.err.println("Output:\n[" + outputSource + "]");
assertEquals("// Input 0\n// Input 1\n", outputSource);
public void testBug2176967Default() {
final String badJsDoc = "/** @XYZ */\n var x";
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
compiler.compile(SourceFile.fromCode("extern.js", ""),
SourceFile.fromCode("test.js", badJsDoc), options);
assertEquals(1, compiler.getWarningCount());
assertEquals(0, compiler.getErrorCount());
public void testBug2176967Off() {
final String badJsDoc = "/** @XYZ */\n var x";
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
options.setWarningLevel(
DiagnosticGroups.NON_STANDARD_JSDOC, CheckLevel.OFF);
compiler.compile(SourceFile.fromCode("extern.js", ""),
SourceFile.fromCode("test.js", badJsDoc), options);
assertEquals(0, compiler.getWarningCount());
assertEquals(0, compiler.getErrorCount());
public void testCoverage() {
final String original =
"var name = 1;\n" +
"function f() {\n" +
" var name2 = 2;\n" +
"}\n" +
"window['f'] = f;\n";
final String expected =
"var JSCompiler_lcov_fileNames=JSCompiler_lcov_fileNames||[];" +
"var JSCompiler_lcov_instrumentedLines=" +
"JSCompiler_lcov_instrumentedLines||[];" +
"var JSCompiler_lcov_executedLines=JSCompiler_lcov_executedLines||[];" +
"var JSCompiler_lcov_data_test_js=[];" +
"JSCompiler_lcov_executedLines.push(JSCompiler_lcov_data_test_js);" +
"JSCompiler_lcov_instrumentedLines.push(\"04\");" +
"JSCompiler_lcov_fileNames.push(\"test.js\");" +
"var name=1;" +
"function f(){" +
"JSCompiler_lcov_data_test_js[2]=true;" +
"var name2=2" +
"}" +
"window[\"f\"]=f;";
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
options.setInstrumentForCoverage(true);
compiler.compile(
SourceFile.fromCode("extern.js", "var window;"),
SourceFile.fromCode("test.js", original), options);
assertEquals(0, compiler.getWarningCount());
assertEquals(0, compiler.getErrorCount());
String outputSource = compiler.toSource();
assertEquals(expected, outputSource);
public void testBug2176967Error() {
final String badJsDoc = "/** @XYZ */\n var x";
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
options.setWarningLevel(
DiagnosticGroups.NON_STANDARD_JSDOC, CheckLevel.ERROR);
compiler.compile(SourceFile.fromCode("extern.js", ""),
SourceFile.fromCode("test.js", badJsDoc), options);
assertEquals(0, compiler.getWarningCount());
assertEquals(1, compiler.getErrorCount());
public void testNormalInputs() {
CompilerOptions options = new CompilerOptions();
Compiler compiler = new Compiler();
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("in1", ""),
SourceFile.fromCode("in2", ""));
compiler.compile(EMPTY_EXTERNS, inputs, options);
assertTrue(compiler.getInput(new InputId("externs")).isExtern());
assertFalse(compiler.getInput(new InputId("in1")).isExtern());
assertFalse(compiler.getInput(new InputId("in2")).isExtern());
public void testRebuildInputsFromModule() {
List<JSModule> modules = ImmutableList.of(
new JSModule("m1"), new JSModule("m2"));
modules.get(0).add(SourceFile.fromCode("in1", ""));
modules.get(1).add(SourceFile.fromCode("in2", ""));
Compiler compiler = new Compiler();
compiler.initModules(
ImmutableList.<SourceFile>of(), modules, new CompilerOptions());
modules.get(1).add(SourceFile.fromCode("in3", ""));
assertNull(compiler.getInput(new InputId("in3")));
compiler.rebuildInputsFromModules();
assertNotNull(compiler.getInput(new InputId("in3")));
public void testMalformedFunctionInExterns() throws Exception {
new Compiler().compile(
ImmutableList.of(SourceFile.fromCode("externs", "function f {}")),
ImmutableList.of(SourceFile.fromCode("foo", "")),
new CompilerOptions());
public void testGetSourceInfoInExterns() throws Exception {
Compiler compiler = new Compiler();
compiler.compile(
ImmutableList.of(SourceFile.fromCode("externs", "function f() {}\n")),
ImmutableList.of(SourceFile.fromCode("foo", "function g() {}\n")),
new CompilerOptions());
assertEquals("function f() {}", compiler.getSourceLine("externs", 1));
assertEquals("function g() {}", compiler.getSourceLine("foo", 1));
assertEquals(null, compiler.getSourceLine("bar", 1));
public void testFileoverviewTwice() throws Exception {
List<SourceFile> input = ImmutableList.of(
SourceFile.fromCode("foo",
"/** @fileoverview */ var x; /** @fileoverview */ var y;"));
assertTrue(
(new Compiler()).compile(
EMPTY_EXTERNS, input, new CompilerOptions()).success);
public void testLicenseDirectiveOutput() throws Exception {
test("/** @license Your favorite license goes here */ var x;",
"/*\n Your favorite license goes here */\n",
null);
public void testLicenseAndOverviewDirectiveWarning() throws Exception {
List<SourceFile> input = ImmutableList.of(
SourceFile.fromCode("foo",
("/** @license Your favorite license goes here */\n" +
"/** \n" +
"  * @fileoverview This is my favorite file! */\n" +
"var x;")));
assertTrue(
(new Compiler()).compile(
EMPTY_EXTERNS, input, new CompilerOptions()).success);
public void testOverviewAndLicenseDirectiveOutput() throws Exception {
test("/** @fileoverview This is my favorite file! */\n" +
"/** @license Your favorite license goes here */\n" +
"var x;",
"/*\n Your favorite license goes here */\n",
null);
public void testLicenseOverviewLicense() throws Exception {
test("/** @license Another license */\n" +
"/** @fileoverview This is my favorite file! */\n" +
"/** @license Your favorite license goes here */\n" +
"var x;",
"/*\n Your favorite license goes here  Another license */\n",
null);
public void testCombinedLicenseOverviewDirectiveOutput() throws Exception {
test("/** @license Your favorite license goes here\n" +
" * @fileoverview This is my favorite file! */\n" +
"var x;",
"/*\n Your favorite license goes here\n" +
" @fileoverview This is my favorite file! */\n",
null);
public void testCombinedLicenseAuthorDirectiveOutput() throws Exception {
test("/** @license Your favorite license goes here\n" +
" * @author Robert */\n" +
"var x;",
"/*\n Your favorite license goes here\n @author Robert */\n",
null);
public void testMultipleLicenseDirectiveOutput() throws Exception {
test("/** @license Your favorite license goes here */\n" +
"/** @license Another license */\n" +
"var x;",
"/*\n Another license  Your favorite license goes here */\n" ,
null);
public void testTwoLicenseInSameComment() throws Exception {
test("/** @license Your favorite license goes here \n" +
"  * @license Another license */\n" +
"var x;",
"/*\n Your favorite license goes here \n" +
" @license Another license */\n" ,
null);
public void testLicenseInTree() throws Exception {
test("var a = function() {\n +" +
"/** @license Your favorite license goes here */\n" +
" 1;};\n",
"/*\n Your favorite license goes here */\n" ,
null);
public void testDefineNoOverriding() throws Exception {
Map<String, Node> emptyMap = Maps.newHashMap();
List<String> defines = Lists.newArrayList();
assertDefineOverrides(emptyMap, defines);
public void testDefineOverriding1() throws Exception {
List<String> defines =
Lists.newArrayList(
"COMPILED",
"DEF_TRUE=true",
"DEF_FALSE=false",
"DEF_NUMBER=5.5",
"DEF_STRING='bye'");
Map<String, Node> expected = ImmutableMap.of(
"COMPILED", new Node(Token.TRUE),
"DEF_TRUE", new Node(Token.TRUE),
"DEF_FALSE", new Node(Token.FALSE),
"DEF_NUMBER", Node.newNumber(5.5),
"DEF_STRING", Node.newString("bye"));
assertDefineOverrides(expected, defines);
public void testDefineOverriding2() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING='='");
Map<String, Node> expected = ImmutableMap.of(
"DEF_STRING", Node.newString("="));
assertDefineOverrides(expected, defines);
public void testDefineOverriding3() throws Exception {
List<String> defines = Lists.newArrayList("a.DEBUG");
Map<String, Node> expected = ImmutableMap.of(
"a.DEBUG", new Node(Token.TRUE));
assertDefineOverrides(expected, defines);
public void testBadDefineOverriding1() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING=");
assertCreateDefinesThrowsException(defines);
public void testBadDefineOverriding2() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING='xyz");
assertCreateDefinesThrowsException(defines);
public void testBadDefineOverriding3() throws Exception {
List<String> defines = Lists.newArrayList("=true");
assertCreateDefinesThrowsException(defines);
public void testBadDefineOverriding4() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING==");
assertCreateDefinesThrowsException(defines);
public void testBadDefineOverriding5() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING='");
assertCreateDefinesThrowsException(defines);
public void testBadDefineOverriding6() throws Exception {
List<String> defines = Lists.newArrayList("DEF_STRING='''");
assertCreateDefinesThrowsException(defines);
static void assertCreateDefinesThrowsException(List<String> defines) {
try {
CompilerOptions options = new CompilerOptions();
AbstractCommandLineRunner.createDefineOrTweakReplacements(defines,
options, false);
return;
fail();
static void assertDefineOverrides(Map<String, Node> expected,
List<String> defines) {
CompilerOptions options = new CompilerOptions();
AbstractCommandLineRunner.createDefineOrTweakReplacements(defines, options,
false);
Map<String, Node> actual = options.getDefineReplacements();
assertEquals(expected.size(), actual.size());
for (Map.Entry<String, Node> entry : expected.entrySet()) {
assertTrue(entry.getKey(), actual.containsKey(entry.getKey()));
Node actualNode = actual.get(entry.getKey());
assertTrue(entry.toString(),
entry.getValue().isEquivalentTo(actualNode));
static Result test(String js, String expected, DiagnosticType error) {
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("testcode", js));
Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
if (error == null) {
assertTrue(Joiner.on(",").join(result.errors), result.success);
String outputSource = compiler.toSource();
assertEquals(expected, outputSource);
assertEquals(1, result.errors.length);
assertEquals(error, result.errors[0].getType());
return result;
public void testConsecutiveSemicolons() {
Compiler compiler = new Compiler();
String js = "if(a);";
Node n = compiler.parseTestCode(js);
Compiler.CodeBuilder cb = new Compiler.CodeBuilder();
compiler.toSource(cb, 0, n);
assertEquals(js, cb.toString());
public void testWarningsFiltering() {
assertTrue(hasOutput(
null,
"foo/bar.js",
CheckLevel.WARNING));
assertTrue(hasOutput(
null,
"foo/bar.js",
CheckLevel.ERROR));
assertFalse(hasOutput(
"baz",
"foo/bar.js",
CheckLevel.WARNING));
assertTrue(hasOutput(
"foo",
"foo/bar.js",
CheckLevel.WARNING));
assertTrue(hasOutput(
"baz",
"foo/bar.js",
CheckLevel.ERROR));
assertTrue(hasOutput(
"foo",
"foo/bar.js",
CheckLevel.ERROR));
public void testExportSymbolReservesNamesForRenameVars() {
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
options.closurePass = true;
options.variableRenaming = VariableRenamingPolicy.ALL;
String js = "var goog, x; goog.exportSymbol('a', x);";
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("testcode", js));
Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
assertTrue(result.success);
assertEquals("var b;var c;b.exportSymbol(\"a\",c);", compiler.toSource());
public void testGenerateExportsReservesNames() {
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
options.closurePass = true;
options.variableRenaming = VariableRenamingPolicy.ALL;
options.generateExports = true;
String js = "var goog; /** @export */ var a={};";
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("testcode", js));
Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
assertTrue(result.success);
assertEquals("var b;var c={};b.exportSymbol(\"a\",c);",
compiler.toSource());
private static final DiagnosticType TEST_ERROR =
DiagnosticType.error("TEST_ERROR", "Test error");
private static class TestErrorManager implements ErrorManager {
private boolean output = false;
output = true;
private boolean hasOutput(
String showWarningsOnlyFor,
String path,
CheckLevel level) {
TestErrorManager errorManager = new TestErrorManager();
Compiler compiler = new Compiler(errorManager);
CompilerOptions options = createNewFlagBasedOptions();
if (showWarningsOnlyFor != null) {
options.addWarningsGuard(
new ShowByPathWarningsGuard(showWarningsOnlyFor));
compiler.init(ImmutableList.<SourceFile>of(),
ImmutableList.<SourceFile>of(), options);
compiler.report(JSError.make(path, 1, 1, level, TEST_ERROR));
return errorManager.output;
public void testIdeModeSkipsOptimizations() {
Compiler compiler = new Compiler();
CompilerOptions options = createNewFlagBasedOptions();
options.ideMode = true;
Multimap<CustomPassExecutionTime, CompilerPass> customPasses =
HashMultimap.create();
final boolean[] before = new boolean[1];
final boolean[] after = new boolean[1];
customPasses.put(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS,
new CompilerPass() {
before[0] = true;
customPasses.put(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP,
new CompilerPass() {
after[0] = true;
options.customPasses = customPasses;
String js = "var x = 1;";
List<SourceFile> inputs = ImmutableList.of(
SourceFile.fromCode("testcode", js));
compiler.compile(EMPTY_EXTERNS, inputs, options);
assertTrue(before[0]);  // should run these custom passes
assertFalse(after[0]);  // but not these
public void testAdditionalReplacementsForClosure() {
CompilerOptions options = createNewFlagBasedOptions();
options.locale = "it_IT";
options.closurePass = true;
Map<String, Node> replacements =
DefaultPassConfig.getAdditionalReplacements(options);
assertEquals(2, replacements.size());
assertEquals("it_IT", replacements.get("goog.LOCALE").getString());
public void testInputSerialization() throws Exception {
Compiler compiler = new Compiler();
compiler.initCompilerOptionsIfTesting();
CompilerInput input = new CompilerInput(SourceFile.fromCode(
"tmp", "function foo() {}"));
Node ast = input.getAstRoot(compiler);
CompilerInput newInput = (CompilerInput) deserialize(serialize(input));
assertTrue(ast.isEquivalentTo(newInput.getAstRoot(compiler)));
public void testTargetSpecificCompiles() throws Exception {
String testExterns = ""
+ "var window;"
+ "/** @param {string} str */"
+ "function alert(str) {}";
String testCode = ""
+ "/** @define {number} */"
+ "var mydef = 0;"
+ "if (mydef == 1) {"
+ "  alert('1');"
+ "} else if (mydef == 2) {"
+ "  alert('2');"
+ "} else if (mydef == 3) {"
+ "  alert('3');"
+ "} else { "
+ "  alert('4');"
+ "}";
CompilerOptions options = createNewFlagBasedOptions();
Compiler compiler = new Compiler();
compiler.init(
ImmutableList.of(SourceFile.fromCode("ext.js", testExterns)),
ImmutableList.of(SourceFile.fromCode("in1.js", testCode)),
options);
compiler.parse();
compiler.check();
byte[] savedState = serialize(compiler.getState());
for (int num = 1; num <= 3; ++num) {
compiler.setState((Compiler.IntermediateState) deserialize(savedState));
options.setDefineToNumberLiteral("mydef", num);
compiler.processDefines();
compiler.optimize();
assertEquals("alert(\"" + num + "\");", compiler.toSource());
public void testGetEmptyResult() {
Result result = new Compiler().getResult();
assertEquals(0, result.errors.length);
private static CompilerOptions createNewFlagBasedOptions() {
CompilerOptions opt = new CompilerOptions();
CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(opt);
return opt;
private static byte[] serialize(Object obj) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream out = new ObjectOutputStream(baos);
out.writeObject(obj);
out.close();
return baos.toByteArray();
private static Object deserialize(byte[] bytes)
throws IOException, ClassNotFoundException {
ObjectInputStream in =
new ObjectInputStream(new ByteArrayInputStream(bytes));
Object obj = in.readObject();
in.close();
return obj;
private boolean closurePassEnabledForExpected = false;
void enableClosurePassForExpected() {
closurePassEnabledForExpected = true;
new SemanticReverseAbstractInterpreter(compiler.getTypeRegistry());
(new GatherExternProperties(compiler))
if (closurePassEnabled && closurePassEnabledForExpected && !compiler.hasErrors()) {
new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, false)
.process(null, mainRoot);
static class BlackHoleErrorManager extends BasicErrorManager {
BlackHoleErrorManager(Compiler compiler) {
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
setAcceptedLanguage(LanguageMode.ECMASCRIPT3);
public void testRewriteImplementedMethod5() throws Exception {
String source = newlineJoin(
"(function() {this.foo()}).prototype.foo = function() {extern();};");
testSame(source);
package com.google.javascript.jscomp;
import static java.nio.charset.StandardCharsets.UTF_8;
import com.google.common.collect.ImmutableList;
import com.google.javascript.rhino.InputId;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
public class ES6ModuleLoaderFileSystemTest {
private ES6ModuleLoader loader;
private Compiler compiler;
private String rootPath;
public TemporaryFolder tempFolder = new TemporaryFolder();
private void writeFile(File f, String s) throws IOException {
Files.write(f.toPath(), s.getBytes(UTF_8));
public void setup() {
final File indexA, indexB, appFile;
try {
final File tempDirA = tempFolder.newFolder("A");
indexA = new File(tempDirA, "index.js");
writeFile(indexA, "alert('A');");
final File tempDirB = tempFolder.newFolder("B");
indexB = new File(tempDirB, "index.js");
writeFile(indexB, "alert('B');");
appFile = tempFolder.newFile("app.js");
writeFile(appFile, "alert('app');");
throw new RuntimeException(e);
SourceFile in1 = SourceFile.fromFile(indexA);
SourceFile in2 = SourceFile.fromFile(indexB);
SourceFile in3 = SourceFile.fromFile(appFile);
compiler = new Compiler();
compiler.init(
ImmutableList.<SourceFile>of(),
ImmutableList.of(in1, in2, in3),
new CompilerOptions());
rootPath = tempFolder.getRoot().getPath().replace(File.separatorChar, '/') + "/";
loader = ES6ModuleLoader.createNaiveLoader(compiler, rootPath);
private CompilerInput getInput(String s) {
return compiler.getInput(new InputId((rootPath + s).replace('/', File.separatorChar)));
public void testFileSystem() {
CompilerInput inputA = getInput("A/index.js");
CompilerInput inputB = getInput("B/index.js");
CompilerInput inputApp = getInput("app.js");
Assert.assertEquals("A/index.js", loader.getLoadAddress(inputA));
Assert.assertEquals("A/index.js", loader.locate("../A", inputB));
Assert.assertEquals("A/index.js", loader.locate("./A", inputApp));
Assert.assertEquals("A/index.js", loader.locate("A", inputApp));
rewriteGeneratorBodyWithVars(
"var i = 0; for (var j = 0; j < 10; j++) { i += j; throw 5; } yield i;",
"var j; var i;",
Joiner.on('\n').join(
"      case 0:",
"        i = 0;",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        i += j;",
"        $jscomp$generator$state = -1;",
"        throw 5;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = 4;",
"        return {value: i, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
public void testUndecomposableExpression() {
test("function *f() { obj.bar(yield 5); }",
null, Es6ToEs3Converter.CANNOT_CONVERT);
public void testGeneratorCannotConvertYet() {
test("function *f(b, i) {switch (i) { case (b || (yield 1)): yield 2; }}",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
public void testGeneratorShortCircuit() {
rewriteGeneratorBody("0 || (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 3;",
"        return{value:1, done:false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
rewriteGeneratorBody("0 && (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        return{value:1, done:false};",
"      case 2:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 3:",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
rewriteGeneratorBody("0 ? 1 : (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        1;",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 3;",
"        return{value:1, done:false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
"",
"/**",
" * @param {...*} var_args",
" * @return {*}",
" */",
"Function.prototype.call = function(var_args) {};",
"",
optimizer.addOneTimePass(passConfig.es6ConvertSuper);
"var C = function(args) {",
"  args=[].slice.call(arguments, 0);",
"  C.base.apply(C, [].concat([this, 'constructor'], args));",
"};",
"var C = function(args) {",
"  args=[].slice.call(arguments, 0);",
"  C.base.apply(C, [].concat([this, 'constructor'], args));",
"};",
public void testInvalidExtends() {
test("class A {}; class B {}; class C extends (foo ? A : B) {}",
null, Es6ToEs3Converter.DYNAMIC_EXTENDS_TYPE);
"var C = function(args) {",
"  args = [].slice.call(arguments, 0);",
"  C.base.apply(C, [].concat([this, 'constructor'], args));",
"};",
"  constructor() { }",
"var C = function() { }",
"  constructor() {}",
"var C = function() {};",
null, Es6ConvertSuper.NO_SUPERTYPE);
null, Es6ConvertSuper.NO_SUPERTYPE);
null, Es6ConvertSuper.NO_SUPERTYPE);
null, Es6ConvertSuper.NO_SUPERTYPE);
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor() {}",
"  f() {super();}",
"}"), Joiner.on('\n').join(
"var C = function() {}",
"C.prototype.f = function() {C.base(this, 'f');}"));
"  var D = function(args) {",
"    args = [].slice.call(arguments, 0);",
"    D.base.apply(D, [].concat([this, 'constructor'], args));",
"  };",
public void testSuperSpread() {
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor(args) {",
"    super(...args)",
"  }",
"}"), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function(){};",
"/** @constructor @struct @extends {D} */",
"var C=function(args) {",
"  C.base.apply(C, [].concat([this, 'constructor'], args))",
"};",
"$jscomp.copyProperties(C,D);",
"$jscomp.inherits(C,D);"));
"var S = function(args) {",
"  args = [].slice.call(arguments, 0);",
"  S.base.apply(S, [].concat([this,'constructor'],args));",
"};",
"var S = function(args) {",
"  args = [].slice.call(arguments, 0);",
"  S.base.apply(S, [].concat([this,'constructor'],args));",
"};",
"S.prototype.f=function() { S.base(this, 'f') }"));
"class C extends D { constructor() {} }",
"var C = function() {};",
"class C extends D {",
"  constructor() {}",
"  f() {}",
"}",
"var C = function() { };",
"class C extends D {",
"  constructor() {}",
"  static f() {}",
"  g() {}",
"}"
"var C = function() { };",
public void testGithub752() {
test("function f() { var a = b = class {};}",
null, Es6ToEs3Converter.CANNOT_CONVERT);
test("var ns = {}; function f() { var self = ns.Child = class {};}",
null, Es6ToEs3Converter.CANNOT_CONVERT);
"var Sub=function(args) {",
"  args = [].slice.call(arguments,0);",
"  Sub.base.apply(Sub, [].concat([this, 'constructor'], args))",
"};",
import java.util.Arrays;
helperCanExposeExpression(
DecompositionType.MOVABLE, "for(foo();;);", "foo");
helperCanExposeExpression(
DecompositionType.MOVABLE,
"function f(){ throw foo();}", "foo");
public void testExposeExpression12() {
helperExposeExpression(
"throw bar() && foo();",
"foo",
"var temp$$0; if (temp$$0 = bar()) temp$$0 = foo(); throw temp$$0;");
public void testExposeYieldExpression1() {
helperMoveExpression(
"function *f() { return { a: yield 1, c: foo(yield 2, yield 3) }; }",
"yield",
"function *f() {" +
"  var result$$0 = yield 1;" +
"  return { a: result$$0, c: foo(yield 2, yield 3) };" +
"}");
helperMoveExpression(
"function *f() {" +
"  return { a: 0, c: foo(yield 2, yield 3) };" +
"}",
"yield",
"function *f() {" +
"  var result$$0 = yield 2;" +
"  return { a: 0, c: foo(result$$0, yield 3) };" +
"}");
helperMoveExpression(
"function *f() {" +
"  return { a: 0, c: foo(1, yield 3) };" +
"}",
"yield",
"function *f() {" +
"  var result$$0 = yield 3;" +
"  return { a: 0, c: foo(1, result$$0) };" +
"}");
public void testExposeYieldExpression2() {
helperMoveExpression(
"function *f() { return (yield 1) || (yield 2); }",
"yield",
"function *f() {" +
"  var result$$0 = yield 1;" +
"  return result$$0 || (yield 2);" +
"}");
helperExposeExpression(
"function *f(x) {" +
"  return x || (yield 2);" +
"}",
"yield",
"function *f(x) {" +
"  var temp$$0;" +
"  if (temp$$0=x); else temp$$0 = yield 2;" +
"  return temp$$0" +
"}");
assertEquals(DecompositionType.DECOMPOSABLE, result);
private Compiler getCompiler() {
options.setLanguage(LanguageMode.ECMASCRIPT6_STRICT);
if (n.isCall() || n.isYield()) {
if (name == null
|| n.isYield() && "yield".equals(name)
|| (n.isCall() && n.getFirstChild().isName()
&& n.getFirstChild().getString().equals(name))) {
assertEquals(Arrays.toString(compiler.getErrors()),
0, compiler.getErrorCount());
+ "expected: function (new:Function, ...*): ?");
return new GatherExternProperties(compiler);
public void testExportOnGoogGlobalFound1() {
assertExported("goog.global['a']", "a");
public void testExportOnGoogGlobalFound2() {
assertExported("goog.global.a", "a");
public void testExportOnGoogGlobalFound3() {
assertExported("goog$global['a']", "a");
public void testExportOnGoogGlobalFound4() {
assertExported("goog$global.a", "a");
int maxSizeAfterInlining = CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING;
assumeMinimumCapture,
maxSizeAfterInlining);
public void testComplexInlineInExpressionss1() {
public void testComplexInlineInExpressionss2() {
public void testComplexInlineInExpressionss3() {
public void testComplexInlineInExpressionss4() {
public void testComplexInlineInExpressionss5() {
"var element$$inline_0=" +
"var stylesString$$inline_1=a;" +
"element$$inline_0.cssText=" +
"stylesString$$inline_1;" +
"var propToSet$$inline_2=" +
"element$$inline_0[" +
"propToSet$$inline_2]=" +
"stylesString$$inline_1" +
true, // assumeMinimumCapture
CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING);
public void testMaxFunSizeAfterInlining() {
this.maxSizeAfterInlining = 1;
test(// Always inline single-statement functions
"function g() { return 123; }\n" +
"function f() { g(); }",
"function f() { 123; }");
this.maxSizeAfterInlining = 10;
test(// Always inline at the top level
"function g() { 123; return 123; }\n" +
"g();",
"{ 123; 123; }");
this.maxSizeAfterInlining = 1;
testSame(// g is too big to be inlined
"function g() { 123; return 123; }\n" +
"g();");
this.maxSizeAfterInlining = 20;
test(
"function g() { 123; return 123; }\n" +
"function f() {\n" +
"  g();\n" +
"}",
"");
this.maxSizeAfterInlining = 25;
test(
"function f1() { 1; return 1; }\n" +
"function f2() { 2; return 2; }\n" +
"function f3() { 3; return 3; }\n" +
"function f4() { 4; return 4; }\n" +
"function g() {\n" +
"  f1(); f2(); f3(); f4();\n" +
"}\n" +
"g(); g(); g();",
"function g() { {1; 1;} {2; 2;} {3; 3;} {4; 4;} }\n" +
"g(); g(); g();");
this.maxSizeAfterInlining =
CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING;
import static com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING;
import com.google.common.base.Joiner;
public void testBug18078936() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
"var goog = {};" +
"goog.inherits = function(a,b) {};" +
"goog.defineClass = function(a,b) {};" +
"/** @template T */\n" +
"var ClassA = goog.defineClass(null, {\n" +
"  constructor: function() {},\n" +
"" +
"  /** @param {T} x */\n" +
"  fn: function(x) {}\n" +
"});\n" +
"" +
"/** @extends {ClassA.<string>} */\n" +
"var ClassB = goog.defineClass(ClassA, {\n" +
"  constructor: function() {},\n" +
"" +
"  /** @override */\n" +
"  fn: function(x) {}\n" +
"});\n" +
"" +
"(new ClassB).fn(3);\n" +
"",
TypeValidator.TYPE_MISMATCH_WARNING);
public void testQMarkTIsNullable() {
CompilerOptions options = createCompilerOptions();
options.checkTypes = true;
String code = Joiner.on('\n').join(
"/** @constructor @template T */",
"function F() {}",
"",
"/** @return {?T} */",
"F.prototype.foo = function() {",
"  return null;",
"}",
"",
"/** @type {F<string>} */",
"var f = new F;",
"/** @type {string} */",
"var s = f.foo(); // Type error: f.foo() has type {?string}.");
test(options, code, TYPE_MISMATCH_WARNING);
public void testTIsNotNullable() {
CompilerOptions options = createCompilerOptions();
options.checkTypes = true;
String code = Joiner.on('\n').join(
"/** @constructor @template T */",
"function F() {}",
"",
"/** @param {T} t */",
"F.prototype.foo = function(t) {",
"}",
"",
"/** @type {F<string>} */",
"var f = new F;",
"/** @type {?string} */",
"var s = null;",
"f.foo(s); // Type error: f.foo() takes a {string}, not a {?string}");
test(options, code, TYPE_MISMATCH_WARNING);
public void testSuppressBadGoogRequire() throws Exception {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
options.checkTypes = true;
test(
options,
"/** @suppress {closureDepMethodUsageChecks} */\n" +
"function f() { goog.require('foo'); }\n" +
"f();",
"function f() { goog.require('foo'); }\n" +
"f();");
public void testMaxFunSizeAfterInliningUsage() {
CompilerOptions options = new CompilerOptions();
options.inlineFunctions = false;
options.setMaxFunctionSizeAfterInlining(1);
try {
test(options, "", "");
fail("Expected CompilerOptionsPreprocessor.InvalidOptionsException");
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
public void testToJson() throws JsonParseException {
JsonArray modules = graph.toJson();
assertEquals(6, modules.size());
for (int i = 0; i < modules.size(); i++) {
JsonObject m = modules.get(i).getAsJsonObject();
assertNotNull(m.get("name"));
assertNotNull(m.get("dependencies"));
assertNotNull(m.get("transitive-dependencies"));
assertNotNull(m.get("inputs"));
JsonObject m = modules.get(3).getAsJsonObject();
assertEquals("D", m.get("name").getAsString());
assertEquals("[\"B\"]", m.get("dependencies").getAsJsonArray().toString());
m.get("transitive-dependencies").getAsJsonArray().size());
assertEquals("[]", m.get("inputs").getAsJsonArray().toString());
private JsMessage.Style mode;
protected void setUp() throws Exception {
super.setUp();
mode = JsMessage.Style.LEGACY;
return new JsMessageExtractor(null, mode)
private JsMessage.Style mode;
mode = JsMessage.Style.LEGACY;
public void testJsMessageOnObjLit() {
extractMessagesSafely("" +
"pint.sub = {" +
"/** @desc a */ MSG_MENU_MARK_AS_UNREAD: goog.getMsg('a')}");
assertEquals(0, compiler.getWarningCount());
assertEquals(1, messages.size());
JsMessage msg = messages.get(0);
assertEquals("MSG_MENU_MARK_AS_UNREAD", msg.getKey());
assertEquals("a", msg.getDesc());
assertEquals(0, compiler.getWarningCount());
mode = RELAX;
mode = CLOSURE;
assertEquals(0, messages.size());
assertEquals(1, compiler.getWarnings().length);
JSError warning = compiler.getWarnings()[0];
warning.getType());
mode = CLOSURE;
super(compiler, true, mode, null);
return new SanityCheck(compiler);
true, true, true, true, true,
CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING);
import com.google.javascript.jscomp.newtypes.JSTypeCreatorFromJSDoc;
static final String DEFAULT_EXTERNS =
CompilerTypeTestCase.DEFAULT_EXTERNS + "/** @return {string} */\n"
+ "String.prototype.toString = function() { return '' };\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @param {*=} arg\n"
+ " * @return {number}\n"
+ " */\n"
+ "function Number(arg) {}\n"
+ "/** @return {string} */\n"
+ "Number.prototype.toString = function() { return '' };\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @param {*=} arg\n"
+ " * @return {boolean}\n"
+ " */\n"
+ "function Boolean(arg) {}\n"
+ "/** @return {string} */\n"
+ "Boolean.prototype.toString = function() { return '' };";
compiler.init(Lists.newArrayList(SourceFile.fromCode("[externs]", externs)),
Lists.newArrayList(SourceFile.fromCode("[testcode]", js)), options);
assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()),
assertEquals(
"parsing warning: " + Joiner.on(", ").join(compiler.getWarnings()), 0,
compiler.getWarningCount());
assertEquals(
"Expected no warning, but found: " + Arrays.toString(warnings) + "\n",
return typeCheck(DEFAULT_EXTERNS, js, warningKinds);
if (compiler.getErrors().length > 0) {
fail("Expected no errors, but found: "
+ Arrays.toString(compiler.getErrors()));
"Expected warning of type:\n"
+ "================================================================\n"
+ warningKinds
+ "================================================================\n"
+ "but found:\n"
+ "----------------------------------------------------------------\n"
+ Arrays.toString(warnings) + "\n"
+ "----------------------------------------------------------------\n";
assertEquals(
errorMessage + "Warning count", warningKinds.size(), warnings.length);
assertTrue(
"Wrong warning type\n" + errorMessage,
NewTypeInference typeInf = parseAndTypeCheck(DEFAULT_EXTERNS, js);
NewTypeInference typeInf = parseAndTypeCheck(DEFAULT_EXTERNS, js);
NewTypeInference typeInf = parseAndTypeCheck(DEFAULT_EXTERNS, js);
public void testVarDefinitionsInExterns() {
checkNoWarnings(
DEFAULT_EXTERNS + "var undecl = {};", "if (undecl) { undecl.x = 7 };");
checkNoWarnings(
DEFAULT_EXTERNS + "var undecl = {};",
"function f() { if (undecl) { undecl.x = 7 }; }");
checkNoWarnings(DEFAULT_EXTERNS + "var undecl;", "undecl(5);");
checkNoWarnings(
DEFAULT_EXTERNS + "/** @type {number} */ var num;", "num - 5;");
checkNoWarnings(
DEFAULT_EXTERNS + "var maybeStr; /** @type {string} */ var maybeStr;",
"maybeStr - 5;");
typeCheck(DEFAULT_EXTERNS + "/** @type {string} */ var str;", "str - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings(
DEFAULT_EXTERNS + "function f() {/** @type {string} */ var invisible;}",
"invisible - 5;");
typeCheck(
DEFAULT_EXTERNS + "/** @type {number} */ var num;",
"/** @type {undefined} */ var x = num;",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
DEFAULT_EXTERNS + "var untypedNum;",
"function f(x) {\n"
+ " x < untypedNum;\n"
+ " untypedNum - 5;\n"
+ "}\n"
+ "f('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
public void testThisInAtTypeFunction() {
"/** @constructor */ function Foo(){};\n"
+ "/** @type {number} */ Foo.prototype.n;\n"
+ "/** @type {function(this:Foo)} */ function f() { this.n = 'str' };",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "var /** function(this:Foo) */ x = function() {};");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {function(this:Foo)} x */\n"
+ "function f(x) {}\n"
+ "f(/** @type {function(this:Foo)} */ (function() {}));");
"/** @constructor */\n"
+ "function Foo() { /** @type {number} */ this.prop = 1; }\n"
+ "/** @type {function(this:Foo)} */\n"
+ "function f() { this.prop = 'asdf'; }",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "/** @param {function(this:Foo)} x */\n"
+ "function f(x) {}\n"
+ "f(/** @type {function(this:Bar)} */ (function() {}));",
"/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "function f(/** function(this:Low) */ low,\n"
+ "           /** function(this:High) */ high) {\n"
+ "  var fun = (1 < 2) ? low : high;\n"
+ "  var /** function(this:High) */ f2 = fun;\n"
+ "  var /** function(this:Low) */ f3 = fun;\n"
+ "}",
"/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "function f(/** function(function(this:Low)) */ low,\n"
+ "           /** function(function(this:High)) */ high) {\n"
+ "  var fun = (1 < 2) ? low : high;\n"
+ "  var /** function(function(this:High)) */ f2 = fun;\n"
+ "  var /** function(function(this:Low)) */ f3 = fun;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {function(this:Foo<T>)} fun\n"
+ " */\n"
+ "function f(fun) { return fun; }\n"
+ "var /** function(this:Foo<string>) */ x =\n"
+ "    f(/** @type {function(this:Foo<number>)} */ (function() {}));",
NewTypeInference.MISTYPED_ASSIGN_RHS);
public void testThisInFunctionJsdoc() {
typeCheck(
"/** @constructor */ function Foo() {};\n"
+ "/** @type {number} */ Foo.prototype.n;\n"
+ "/** @this {Foo} */\n"
+ "function f() { this.n = 'str'; }",
"/** @this {gibberish} */ function foo() {}",
GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME);
typeCheck(
"/** @constructor */\n"
+ "function Foo() { /** @type {number} */ this.prop = 1; }\n"
+ "/** @this {Foo} */\n"
+ "function f() { this.prop = 'asdf'; }",
checkNoWarnings("/** @type{function(this: Object)} */\n"
+ "function f() {}\n"
+ "f();");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function() {};\n"
+ "var f = (new Foo).method;\n"
+ "f();");
"/** @constructor */ function Foo() {}\n"
+ "function h(/** function(new:Foo,...[number]):number */ f) {\n"
+ "  (new f()) - 5;\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {function(new:Foo<T>)} fun\n"
+ " */\n"
+ "function f(fun) { return fun; }\n"
+ "/** @type {function(new:Foo<number>)} */\n"
+ "function f2() {}\n"
+ "var /** function(new:Foo<string>) */ x = f(f2);",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(x) {\n"
+ "  x();\n"
+ "  var /** !Foo */ y = new x();\n"
+ "  var /** function(new:Foo, number) */ z = x;\n"
+ "}");
checkNoWarnings("/** @constructor */ function Error() {};\n"
+ "Error.prototype.sourceURL;\n"
+ "/** @constructor @extends {Error} */ function SyntaxError() {}");
"/** @constructor */ function Foo() {};\n"
+ "/** @param {string} x */ Foo.prototype.method = function(x) {};\n"
+ "/** @constructor @extends {Foo} */ function Bar() {};\n"
+ "(new Bar).method(4)",
checkNoWarnings("/** @constructor */ function Super() {};\n"
+ "/** @type {string} */ Super.prototype.str;\n"
+ "/** @constructor @extends {Super} */ function Sub() {};\n"
+ "Sub.prototype.str;");
checkNoWarnings("function f() { return 9; }\n"
+ "var x = f();\n"
+ "x - 7;");
typeCheck(
"var /** ?number */ n = true;", NewTypeInference.MISTYPED_ASSIGN_RHS);
"var x = 5;\n"
+ "for (;true;) {\n"
+ "  x = 'str';\n"
+ "}\n"
+ "var /** (string|number) */ y = x;\n"
+ "(function(/** string */ s){})(x);",
"var x = 5;"
+ "while (true) {"
+ "  x = 'str';"
+ "}\n"
+ "(function(/** string */ s){})(x);\n"
+ "var /** (string|number) */ y = x;",
"while (true) {"
+ "  var x = 'str';"
+ "}\n"
+ "var /** (string|undefined) */ y = x;\n"
+ "(function(/** string */ s){})(x);",
"for (var x = 5; x < 10; x++) {}\n"
+ "(function(/** string */ s){})(x);\n"
+ "var /** number */ y = x;",
checkNoWarnings("var x, y = 5;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else {\n"
+ "  x = 'str';\n"
+ "}\n"
+ "if (x === 5) {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
checkNoWarnings("var x, y = 5;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x !== null) {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
checkNoWarnings("var x, y;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x === null) {\n"
+ "  y = 5;"
+ "} else {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
checkNoWarnings("var numOrNull = true ? null : 1\n"
+ "if (null === numOrNull) { var /** null */ n = numOrNull; }");
checkNoWarnings("var x, y = 5;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else if (true) {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x !== null && x !== undefined) {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
checkNoWarnings("var x, y;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else if (true) {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x === null || x === void 0) {\n"
+ "  y = 5;\n"
+ "} else {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
typeCheck(
"var x, y = 5;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else if (true) {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x === null || x === undefined) {\n"
+ "  y = x;\n"
+ "}\n"
+ "var /** (number|null|undefined) **/ z = y;\n"
+ "(function(/** (number|null) */ x){})(y);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"var x, y;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else if (true) {\n"
+ "  x = null;\n"
+ "}\n"
+ "if (x !== null && x !== undefined) {\n"
+ "  y = 5;\n"
+ "} else {\n"
+ "  y = x;\n"
+ "}\n"
+ "var /** (number|null|undefined) **/ z = y;\n"
+ "(function(/** (number|null) */ x){})(y);",
checkNoWarnings("var x, y = 5;\n"
+ "if (true) {\n"
+ "  x = 5;\n"
+ "} else {\n"
+ "  x = 'str';\n"
+ "}\n"
+ "if (x === 7 || x === 8) {\n"
+ "  y = x;\n"
+ "}\n"
+ "y - 5");
typeCheck(
"/** @constructor */ function C(){}\n"
+ "var obj = new C;\n"
+ "if (obj || false) { 123, obj.asdf; }",
checkNoWarnings("function f(/** (number|string) */ x) {\n"
+ "  (typeof x === 'number') && (x - 5);\n"
+ "}");
checkNoWarnings("function f(/** (number|string|null) */ x) {\n"
+ "  (x && (typeof x === 'number')) && (x - 5);\n"
+ "}");
"function f(/** (number|string|null) */ x) {\n"
+ "  (x && (typeof x === 'string')) && (x - 5);\n"
+ "}",
"function f(/** (number|string|null) */ x) {\n"
+ "  typeof x === 'string' && x;\n"
+ "  x < 'asdf';\n"
+ "}",
checkNoWarnings("var x = true ? null : 'str';\n"
+ "while (x !== null) {}\n"
+ "var /** null */ y = x;");
checkNoWarnings("var x = true ? null : 'str';\n"
+ "for (;x !== null;) {}\n"
+ "var /** null */ y = x;");
checkNoWarnings("for (var x = true ? null : 'str'; x === null;) {}\n"
+ "var /** string */ y = x;");
checkNoWarnings("var x;\n"
+ "for (x = true ? null : 'str'; x === null;) {}\n"
+ "var /** string */ y = x;");
checkNoWarnings("var x = true ? null : 'str';\n"
+ "do {} while (x === null);\n"
+ "var /** string */ y = x;");
typeCheck(
"/** @type {number} */ var /** number */ x;",
typeCheck(
"var /** number */ x = 5, /** string */ y = 6;",
typeCheck(
"var /** number */ x = 'str', /** string */ y = 'str2';",
typeCheck(
"/** @type {string} */ var s = 123;",
typeCheck(
"/** @type {string} */ var s; s = 123;",
typeCheck(
"var y = 123; var x = 'str'; var z = x - y;",
typeCheck(
"var y = 123; var x; var z = x - y;",
checkNoWarnings("+true;"); // This is considered an explicit coercion
inferFirstFormalType(
"function f(y) { var x; x = y; x - 5; }", JSType.NUMBER);
inferFirstFormalType(
"function f(x) { x + 5; }", JSType.join(JSType.NUMBER, JSType.STRING));
typeCheck(
"var x = 'str'; var y = 1; x < y;",
"function f(x) {\n"
+ "  var y = 1;\n"
+ "  x < y;\n"
+ "  return x;\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  var y = x, z = 7;\n"
+ "  y < z;\n"
+ "}");
"/** @return {number} */\n"
+ "function f() { return 1; }",
"/** @param {number} n */\n"
+ "function f(n) { return n; }",
checkNoWarnings("/** @param {number} n */\n"
+ "function f(n) { n < 5; }");
"/** @param {string} n */\n"
+ "function f(n) { n < 5; }",
"/** @return {string} */\n"
+ "function f() { return 1; }",
"/** @return {string} */\n"
+ "function f() { return; }",
"/** @return {string} */\n"
+ "function f(s) { return s; }",
"/** @return {number} */\n"
+ "function f() {}",
"/** @return {(undefined|number)} */\n"
+ "function f() { if (true) { return 'str'; } }",
"/** @param {function(number)} fun */\n"
+ "function f(fun) {}\n"
+ "f(function (/** string */ s) {});",
"/** @constructor */ function Foo() {}\n"
+ "/** @param {number} x */ Foo.prototype.method = function(x) {};\n"
+ "(new Foo).method('asdf');",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.method = /** @param {number} x */ function(x) {};\n"
+ "(new Foo).method('asdf');",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.method = function(/** number */ x) {};\n"
+ "(new Foo).method('asdf');",
typeCheck(
"/** @type {function(number)} */ function f(x) {}; f('asdf');",
typeCheck(
"/** @type {number} */ function f() {}",
"/** @type {function():number} */\n"
+ "function /** number */ f() { return 1; }",
checkNoWarnings("function f(/** function(number) */ fnum, floose, cond) {\n"
+ "  var y;\n"
+ "  if (cond) {\n"
+ "    y = fnum;\n"
+ "  } else {\n"
+ "    floose();\n"
+ "    y = floose;\n"
+ "  }\n"
+ "  return y;\n"
+ "}");
typeCheck(
"/** @param {function(): *} x */ function g(x) {}\n"
+ "/** @param {function(number): string} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/**\n"
+ " * @interface\n"
+ " */\n"
+ "function A() {};\n"
+ "/** @return {number} */\n"
+ "A.prototype.foo = function() {};");
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "function f(/** function(new:Foo) */ x) {}\n"
+ "f(Bar);",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** function(new:Foo) */ x) {}\n"
+ "f(function() {});",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "function f(/** function(new:Foo) */ x) {}\n"
+ "f(Bar);");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @param {function(new:Foo, (number|string))} x \n"
+ " * @param {function(new:Foo, number)} y \n"
+ " */\n"
+ "function f(x, y) {\n"
+ "  var z = 1 < 2 ? x : y;\n"
+ "  return new z(123);\n"
+ "}");
typeCheck(
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "/**\n"
+ " * @param {function(new:Foo)} x \n"
+ " * @param {function(new:Bar)} y \n"
+ " */\n"
+ "function f(x, y) {\n"
+ "  var z = 1 < 2 ? x : y;\n"
+ "  return new z();\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** function(new:Foo) */ x, /** function() */ y) {\n"
+ "  var z = 1 < 2 ? x : y;\n"
+ "  return new z();\n"
+ "}",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** function(new:Foo) */ x, /** function() */ y) {\n"
+ "  var z = 1 < 2 ? x : y;\n"
+ "  return z();\n"
+ "}");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @param {function(new:Foo, (number|string))} x \n"
+ " * @param {function(new:Foo, number)} y \n"
+ " */\n"
+ "function f(x, y) { if (x === y) { return x; } }");
"function f(/** {a, b} */ x) {}\n"
+ "f({c: 123});",
"function f(x) {\n"
+ "  var y = x; y - 5; y < 'str';\n"
+ "}",
typeCheck("function f(x) { x-5; }; f();", TypeCheck.WRONG_ARGUMENT_COUNT);
"/** @return {number} */ function f() { return 1; }\n"
+ "var /** string */ s = f();",
typeCheck(
"function f(/** number */ x) {}; f(true);",
"function f(/** boolean */ x) {}\n"
+ "function g() { f(123); }",
"function f(/** void */ x) {}\n"
+ "function g() { f(123); }",
"function f(/** boolean */ x) {}\n"
+ "function g(x) {\n"
+ "  var /** string */ s = x;\n"
+ "  f(x < 7);\n"
+ "}",
"function f(/** number */ x) {}\n"
+ "function g(x, y) {\n"
+ "  y < x;\n"
+ "  f(x);\n"
+ "  var /** string */ s = y;\n"
+ "}",
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "function takesObj(/** Object */ x) {}\n"
+ "takesObj(new Foo);");
checkNoWarnings("function takesObj(/** Object */ x) {}\n"
+ "takesObj(null);");
"/** @constructor */ function Foo() {}\n"
+ "function /** Object */ returnsObj() { return {}; }\n"
+ "function takesFoo(/** Foo */ x) {}\n"
+ "takesFoo(returnsObj());",
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "function fun(cond, /** !Foo */ f, /** !Bar */ g) {\n"
+ "  (cond ? f : g)();\n"
+ "}",
"function f() { return 'str'; }\n"
+ "function g() { f() - 5; }",
"function f(x) { x - 5; }\n"
+ "f(5 < 6);",
"function f(x, y) { x - y; }\n"
+ "f(5);",
"function f() { return 'str'; }\n"
+ "function g() { var x = f(); x - 7; }",
"function f(/** number */ x, y) { return x-y; }\n"
+ "f(5, 'str');",
"/** @return {number} */ function f(x) { return x; }\n"
+ "f('str');",
"function f(/** number */ x) { return x; }\n"
+ "function g(x) {\n"
+ "  var /** string */ s = f(x);\n"
+ "};",
"function f() { new Foo('asdf'); }\n"
+ "/** @constructor */ function Foo(x) { x - 5; }",
checkNoWarnings("/** @constructor */\n"
+ "function Arr() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {...T} var_args\n"
+ " */\n"
+ "Arr.prototype.push = function(var_args) {};\n"
+ "function f(x) {}\n"
+ "var renameByParts = function(parts) {\n"
+ "  var mapped = new Arr();\n"
+ "  mapped.push(f(parts));\n"
+ "};");
"/** @return {string} */ function foo(){ return 'str'; }\n"
+ "function g() { foo() - 123; }",
"function f() {"
+ " function x() {};\n"
+ " function g() { x(1); }"
+ " g();"
+ "}",
checkNoWarnings("function f() { return 123; }\n"
+ "var outer = 123;\n"
+ "function g(/** function(number) */ f) {\n"
+ "  f(123) < 'str';\n"
+ "  return outer;\n"
+ "}");
"(function() {\n"
+ "  function f() {}; f(5);\n"
+ "})();",
TypeCheck.WRONG_ARGUMENT_COUNT);
"(function() {\n"
+ "  function f() { return 'str'; }\n"
+ "  function g() { f() - 5; }\n"
+ "})();",
"var /** number */ x;\n"
+ "function f() { x = 'str'; }",
"var x;\n"
+ "function f() { x - 5; x < 'str'; }",
"function f() {\n"
+ "  x < 'str';\n"
+ "}"
+ "var x = 5;\n"
+ "f()",
typeCheck( // CROSS_SCOPE_GOTCHA is only for undeclared variables
"/** @type {string} */ var s;\n"
+ "function f() {\n"
+ "  s = 123;\n"
+ "}\n"
+ "f();",
checkNoWarnings("function g(x) {\n"
+ "  function f() { x < 'str'; z < 'str'; x = 5; }\n"
+ "  var z = x;\n"
+ "  f();\n"
+ "  x - 5;\n"
+ "  z < 'str';\n"
+ "}");
checkNoWarnings("function f(/** function() */ x, cond) {\n"
+ "  var y = cond ? x() : 5;\n"
+ "  y < 'str';\n"
+ "}");
checkNoWarnings("/** @param {function() : ?} x */ function f(x, cond) {\n"
+ "  var y = cond ? x() : 5;\n"
+ "  y < 'str';\n"
+ "}");
checkNoWarnings("function f(/** function() */ x) {\n"
+ "  x() < 'str';\n"
+ "}");
typeCheck(
"function g() { return {}; }\n"
+ "function f() {\n"
+ "  var /** ? */ x = g();\n"
+ "  return x.y;\n"
+ "}",
NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
checkNoWarnings("function g() { return {}; }\n"
+ "function f() {\n"
+ "  var /** ? */ x = g()\n"
+ "  x.y = 5;\n"
+ "}");
checkNoWarnings("function g(x) { return x; }\n"
+ "function f(z) {\n"
+ "  var /** ? */ x = g(z);\n"
+ "  x.y2 = 123;\n"
+ // specializing to a loose object here
"  return x.y1 - 5;\n"
+ "}");
"function f(/** function():number */ x) {\n"
+ "  var /** string */ s = x();\n"
+ "}",
"function f(/** function(number) */ x) {\n"
+ "  x(true);\n"
+ "}",
"function g(x, y, /** function(number) */ f) {\n"
+ "  y < x;\n"
+ "  f(x);\n"
+ "  var /** string */ s = y;\n"
+ "}",
"function f(x) {\n"
+ "  var y = x(); y - 5; y < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @param {function():?} x */ function f(x) {\n"
+ "  var y = x(); y - 5; y < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @param {function(number): string} x */ function g(x) {}\n"
+ "/** @param {function(number): string} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}");
checkNoWarnings("/** @param {function(number): *} x */ function g(x) {}\n"
+ "/** @param {function(*): string} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}");
"/** @param {function(*): string} x */ function g(x) {}\n"
+ "/** @param {function(number): string} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @param {function(number): string} x */ function g(x) {}\n"
+ "/** @param {function(number): *} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(/** function(string) : number */ x) {\n"
+ "  if (x('str') === 5) {\n"
+ "    x(5);\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(/** function(string) : string */ x) {\n"
+ "  if (x('str') === 5) {\n"
+ "    x(5);\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(/** function(string) */ x, y) {\n"
+ "  y(1);\n"
+ "  if (x === y) {\n"
+ "    x(5);\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(x) {\n"
+ "  if (x === null) {\n"
+ "    return 5;\n"
+ "  } else {\n"
+ "    return x - 43;\n"
+ "  }\n"
+ "}\n"
+ "f('str');",
checkNoWarnings("/** @const */ var goog = {};\n"
+ "/** @type {!Function} */ goog.abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @return {!Foo} */ Foo.prototype.clone = goog.abstractMethod;\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "/** @return {!Bar} */ Bar.prototype.clone = goog.abstractMethod;");
typeCheck(
"/** @const */ var goog = {};\n"
+ "/** @type {!Function} */ goog.abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @return {!Foo} */ Foo.prototype.clone = goog.abstractMethod;\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "/** @return {!Bar} */ Bar.prototype.clone = goog.abstractMethod;\n"
+ "var /** null */ n = (new Bar).clone();",
NewTypeInference.MISTYPED_ASSIGN_RHS);
public void testDifficultObjectSpecialization() {
checkNoWarnings("/** @constructor */\n"
+ "function X() { this.p = 1; }\n"
+ "/** @constructor */\n"
+ "function Y() { this.p = 2; }\n"
+ "/** @param {(!X|!Y)} a */\n"
+ "function fn(a) {\n"
+ "  a.p;\n"
+ "  /** @type {!X} */ (a);\n"
+ "}");
typeCheck(
"/** @interface */\n"
+ "function High1() {}\n"
+ "/** @interface */\n"
+ "function High2() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {High1}\n"
+ " * @implements {High2}\n"
+ " */\n"
+ "function Low() {}\n"
+ "function f(x) {\n"
+ "  var /** !High1 */ v1 = x;\n"
+ "  var /** !High2 */ v2 = x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @interface */\n"
+ "function High1() {}\n"
+ "/** @interface */\n"
+ "function High2() {}\n"
+ "/** @interface */\n"
+ "function High3() {}\n"
+ "/**\n"
+ " * @interface\n"
+ " * @extends {High1}\n"
+ " * @extends {High2}\n"
+ " */\n"
+ "function Mid() {}\n"
+ "/**\n"
+ " * @interface\n"
+ " * @extends {Mid}\n"
+ " * @extends {High3}\n"
+ " */\n"
+ "function Low() {}\n"
+ "function f(x) {\n"
+ "  var /** !High1 */ v1 = x;\n"
+ "  var /** (!High2|!High3) */ v2 = x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
public void testLooseConstructors() {
checkNoWarnings("function f(ctor) {\n"
+ "  new ctor(1);\n"
+ "}");
"function f(ctor) {\n"
+ "  new ctor(1);\n"
+ "}\n"
+ "/** @constructor */ function Foo(/** string */ y) {}\n"
+ "f(Foo);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
public void testLooseFunctions() {
checkNoWarnings("function f(x) {\n"
+ "  x(1);\n"
+ "}");
"function f(x) {\n"
+ "  x(1);\n"
+ "}\n"
+ "function g(/** string */ y) {}\n"
+ "f(g);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(x) {\n"
+ "  x(1);\n"
+ "}\n"
+ "function g(/** number */ y) {}\n"
+ "f(g);");
checkNoWarnings("function f(x) {\n"
+ "  x(1);\n"
+ "}\n"
+ "function g(/** (number|string) */ y) {}\n"
+ "f(g);");
typeCheck(
"function f(x) {\n"
+ "  5 - x(1);\n"
+ "}\n"
+ "/** @return {string} */\n"
+ "function g(/** number */ y) { return ''; }\n"
+ "f(g);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(x) {\n"
+ "  5 - x(1);\n"
+ "}\n"
+ "/** @return {(number|string)} */\n"
+ "function g(/** number */ y) { return 5; }\n"
+ "f(g);");
checkNoWarnings("function f(x, y) {\n"
+ "  x(5);\n"
+ "  y(5);\n"
+ "  return x(y);\n"
+ "}");
typeCheck(
"function f(x) {\n"
+ "  x();\n"
+ "  return x;\n"
+ "}\n"
+ "function g() {}\n"
+ "function h() { f(g) - 5; }",
"function f(x, cond) {\n"
+ "  x();\n"
+ "  return cond ? 5 : x;\n"
+ "}\n"
+ "function g() {}\n"
+ "function h() { f(g, true) - 5; }",
checkNoWarnings("function f(x) {\n"
+ "  x(5);\n"
+ "  return x;\n"
+ "}\n"
+ "function g(x) {}\n"
+ "function h() {\n"
+ "  var /** function((number|string)) */ fun = f(g);\n"
+ "}");
typeCheck(
"function g(/** string */ x) {}\n"
+ "function f(x, y) {\n"
+ "  y - 5;\n"
+ "  x(y);\n"
+ "  y + y;\n"
+ "}"
+ "f(g, 5)",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @return {string} */\n"
+ "function g(/** number */ x) { return 'str'; }\n"
+ "/** @return {number} */\n"
+ "function f(x) {\n"
+ "  var y = 5;\n"
+ "  var z = x(y);\n"
+ "  return z;\n"
+ "}"
+ "f(g)",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/** @return {number} */\n"
+ "function g(/** number */ y) { return 6; }\n"
+ "function f(x, cond) {\n"
+ "  if (cond) {\n"
+ "    5 - x(1);\n"
+ "  } else {\n"
+ "    x('str') < 'str';\n"
+ "  }\n"
+ "}\n"
+ "f(g, true)\n");
checkNoWarnings("function f(g, cond) {\n"
+ "  if (cond) {\n"
+ "    g(5, cond);\n"
+ "  }\n"
+ "}");
"function f(/** number */ x, /** string */ y, z) {\n"
+ "  var w = z;\n"
+ "  x < z;\n"
+ "  w < y;\n"
+ "}",
"/** @param {number} x */ function f(x) {\n"
+ "  x(7);\n"
+ "}",
TypeCheck.NOT_CALLABLE);
"function f() { return 'str'; }\n"
+ "var x = f();\n"
+ "x - 7;",
"function f() { return 'str'; }\n"
+ "f() - 5;",
"(function() {\n"
+ "  function f() { return 'str'; }\n"
+ "  f() - 5;\n"
+ "})();",
"(function() {\n"
+ "  function f() { return 'str'; }\n"
+ "  f() - 5;\n"
+ "})();",
checkNoWarnings("function f(x) { return x; }\n"
+ "5 - f(1);");
"function f() {\n"
+ "  var x = g();\n"
+ "  var /** string */ s = x;\n"
+ "  x - 5;\n"
+ "};\n"
+ "function g() { return 'str'};",
typeCheck("(null).foo;", NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
"var /** undefined */ n;\n"
+ "n.foo;",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
typeCheck("var x = {}; x.foo.bar = 1;", TypeCheck.INEXISTENT_PROPERTY);
"var /** undefined */ n;\n"
+ "n.foo = 5;",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
checkNoWarnings("/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (x.prop) {\n"
+ "    var /** { prop: ? } */ y = x;\n"
+ "  }\n"
+ "}");
typeCheck(
"/** @param {undefined} x */\n"
+ "function f(x) {\n"
+ "  if (x.prop) {}\n"
+ "}",
"function f(/** !Object */ x) { if (x[123]) { return 1; } }");
typeCheck(
"function f(/** undefined */ x) { if (x[123]) { return 1; } }",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
typeCheck(
"function f(/** (number|null) */ n) {\n"
+ "  n.foo;\n"
+ "}",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
"function f(/** (number|null|undefined) */ n) {\n"
+ "  n.foo;\n"
+ "}",
"function f(/** (!Object|number|null|undefined) */ n) {\n"
+ "  n.foo;\n"
+ "}",
typeCheck(
"/** @constructor */ function Foo(){}\n"
+ "Foo.prototype.prop;\n"
+ "function f(/** (!Foo|undefined) */ n) {\n"
+ "  n.prop;\n"
+ "}",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"/** @constructor */ function Foo(){}\n"
+ "/** @type {string} */ Foo.prototype.prop1;\n"
+ "function g(/** Foo */ f) {\n"
+ "  f.prop1.prop2 = 'str';\n"
+ "};",
NewTypeInference.NULLABLE_DEREFERENCE);
"/** @param {{ a: number }} obj */\n"
+ "function f(obj) {\n"
+ "  123, obj.b;\n"
+ "  obj.b = 'str';\n"
+ "}",
typeCheck("var x = {}; var y = x.a;", TypeCheck.INEXISTENT_PROPERTY);
typeCheck("var x = {}; x.y - 3; x.y = 5;", TypeCheck.INEXISTENT_PROPERTY);
public void testNullableDereference() {
typeCheck(
"function f(/** ?{ p : number } */ o) { return o.p; }",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"/** @constructor */ function Foo() { /** @const */ this.p = 5; }\n"
+ "function g(/** ?Foo */ f) { return f.p; }",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.p = function(){};\n"
+ "function g(/** ?Foo */ f) { f.p(); }",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"var f = 5 ? function() {} : null; f();",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"var f = 5 ? function(/** number */ n) {} : null; f('str');",
ImmutableList.of(
NewTypeInference.NULLABLE_DEREFERENCE,
NewTypeInference.INVALID_ARGUMENT_TYPE));
checkNoWarnings(CLOSURE_BASE + "function f(/** ?{ p : number } */ o) {\n"
+ "  goog.asserts.assert(o);\n"
+ "  return o.p;\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** ?{ p : number } */ o) {\n"
+ "  goog.asserts.assertObject(o);\n"
+ "  return o.p;\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** ?Array<string> */ a) {\n"
+ "  goog.asserts.assertArray(a);\n"
+ "  return a.length;\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.p = function(){};\n"
+ "function g(/** ?Foo */ f) {\n"
+ "  goog.asserts.assertInstanceof(f, Foo);\n"
+ "  f.p();\n"
+ "}");
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "function g(/** !Bar */ o) {\n"
+ "  goog.asserts.assertInstanceof(o, Foo);\n"
+ "}",
NewTypeInference.ASSERT_FALSE);
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "function g(/** !Foo */ o) {\n"
+ "  goog.asserts.assertInstanceof(o, 42);\n"
+ "}",
NewTypeInference.UNKNOWN_ASSERTION_TYPE);
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "function Bar() {}\n"
+ "function g(/** !Foo */ o) {\n"
+ "  goog.asserts.assertInstanceof(o, Bar);\n"
+ "}",
NewTypeInference.UNKNOWN_ASSERTION_TYPE);
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "/** @interface */ function Bar() {}\n"
+ "function g(/** !Foo */ o) {\n"
+ "  goog.asserts.assertInstanceof(o, Bar);\n"
+ "}",
NewTypeInference.UNKNOWN_ASSERTION_TYPE);
public void testAsserts() {
typeCheck(
CLOSURE_BASE
+ "function f(/** ({ p : string }|null|undefined) */ o) {\n"
+ "  goog.asserts.assert(o);\n"
+ "  o.p - 5;\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "function f(/** (Array.<string>|Foo) */ o) {\n"
+ "  goog.asserts.assert(o instanceof Array);\n"
+ "  var /** string */ s = o.length;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
CLOSURE_BASE + "/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.p = function(/** number */ x){};\n"
+ "function f(/** (function(new:Foo)) */ ctor,\n"
+ "           /** ?Foo */ o) {\n"
+ "  goog.asserts.assertInstanceof(o, ctor);\n"
+ "  o.p('str');\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(/** number */ n) {\n"
+ "  n = 'typo';\n"
+ "  n - 5;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {{ n: number }} x */ function f(x) {\n"
+ "  x.n = 'typo';\n"
+ "  x.n - 5;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("/** @param {{ n: number }} x */ function f(x) {\n"
+ "  if (x.p) {\n"
+ "    return x.p;\n"
+ "  }\n"
+ "}");
typeCheck(
"/** @param {{ p : string }} x */ function reqHasPropP(x){}\n"
+ "/** @param {{ n: number }} x */ function f(x, cond) {\n"
+ "  if (cond) {\n"
+ "    x.p = 'str';\n"
+ "  }\n"
+ "  reqHasPropP(x);\n"
+ "}",
"/** @param {{ n: number }} x */ function f(x, cond) {\n"
+ "  if (cond) { x.p = 'str'; }\n"
+ "  if (x.p) {\n"
+ "    x.p - 5;\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"function f(/** { n : number } */ x) {\n"
+ "  x.s = 'str';\n"
+ "  return x.inexistentProp;\n"
+ "}",
checkNoWarnings("/** @param {{ p: number }} x */ function f(x) {\n"
+ "  return x.p - 3;\n"
+ "}");
"/** @param {{ p: string }} x */ function f(x) {\n"
+ "  return x.p - 3;\n"
+ "}",
"/** @param {{ 'p': string }} x */ function f(x) {\n"
+ "  return x.p - 3;\n"
+ "}",
"/** @param {{ p: number }} x */ function f(x) {\n"
+ "  return x.q;\n"
+ "}",
"/** @param {{ p: string }} obj */ function f(obj, x, y) {\n"
+ "  x < y;\n"
+ "  x - 5;\n"
+ "  obj.p < y;\n"
+ "}",
checkNoWarnings("/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.p = 3;\n"
+ "}");
"/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.p = 'str';\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.q = 'str';\n"
+ "}");
checkNoWarnings("/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.q = 'str';\n"
+ "}\n"
+ "/** @param {{ p: number }} x */ function g(x) {\n"
+ "  f(x);\n"
+ "}");
typeCheck(
"/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.q = 'str';\n"
+ "  return x.q;\n"
+ "}\n"
+ "/** @param {{ p: number }} x */ function g(x) {\n"
+ "  f(x) - 5;\n"
+ "}",
NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
checkNoWarnings("/** @param {{ p: number }} x */ function f(x) {\n"
+ "  x.q = 'str';\n"
+ "  x.q = 7;\n"
+ "}");
"function f(/** { prop: number} */ obj) {\n"
+ "  obj.prop = 'asdf';\n"
+ "}",
"function f(/** { prop: number} */ obj, cond) {\n"
+ "  if (cond) { obj.prop = 123; } else { obj.prop = 234; }\n"
+ "  obj.prop = 'asdf';\n"
+ "}",
"function f(/** {p: number} */ x, /** {p: (number|null)} */ y) {\n"
+ "  var z;\n"
+ "  if (true) { z = x; } else { z = y; }\n"
+ "}");
"var /** { a: number } */ obj1 = { a: 321};\n"
+ "var /** { a: number, b: number } */ obj2 = obj1;",
checkNoWarnings("/** @param {{ p: number }} obj */\n"
+ "function f(obj) {\n"
+ "  obj = { p: 123 };\n"
+ "}");
"/** @param {{ p: number, p2: string }} obj */\n"
+ "function f(obj) {\n"
+ "  obj = { p: 123 };\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {{ p: number }} obj */\n"
+ "function f(obj) {\n"
+ "  obj = { p: 'str' };\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"var obj;\n"
+ "obj = { p: 123 };\n"
+ "obj.p < 'str';",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @param {{ p: number }} obj */\n"
+ "function f(obj, x) {\n"
+ "  obj = { p: x };\n"
+ "  x < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @param {{ p: number }} obj */\n"
+ "function f(obj, x) {\n"
+ "  obj = { p: 123, q: x };\n"
+ "  obj.q - 5;\n"
+ "  x < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @param {{ p: number }} obj */\n"
+ "function f(obj) {\n"
+ "  obj.q = 123;\n"
+ "}\n"
+ "/** @param {{ p: number, q: string }} obj */\n"
+ "function g(obj) { f(obj); }");
checkNoWarnings("/** @param {{ p: number }} obj */\n"
+ "function f(obj) {}\n"
+ "var obj = {p: 5};\n"
+ "if (true) {\n"
+ "  obj.q = 123;\n"
+ "}\n"
+ "f(obj);");
typeCheck(
"var /** ? */ x = 'str'; x - 123;",
"function f(obj) {\n"
+ "  var /** number */ x = obj.p;\n"
+ "  obj.p < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"function f(obj) {\n"
+ "  var /** @type {{ p: number }} */ x = obj;\n"
+ "  obj.p < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("function f(obj) {\n"
+ "  obj.x = 1;\n"
+ "  return obj.x;\n"
+ "}\n"
+ "f({x: 'str'});");
"function f(obj) {\n"
+ "  obj.x - 1;\n"
+ "}\n"
+ "f({x: 'str'});",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(obj, cond) {\n"
+ "  if (cond) {\n"
+ "    obj.x = 'str';\n"
+ "  }\n"
+ "  obj.x - 5;\n"
+ "}");
"function f(obj) {\n"
+ "  obj.x - 1;\n"
+ "  return obj;\n"
+ "}\n"
+ "var /** string */ s = (f({x: 5})).x;",
checkNoWarnings("function f(obj) {\n"
+ "  obj.a.b = 123;\n"
+ "}");
"function f(obj) {\n"
+ "  obj.a.b = 123;\n"
+ "  obj.a.b < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"function f(obj, cond) {\n"
+ "  (cond ? obj : obj).x - 1;\n"
+ "  return obj.x;\n"
+ "}\n"
+ "f({x: 'str'}, true);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(obj) {\n"
+ "  obj.a.b - 123;\n"
+ "}\n"
+ "f({a: {b: 'str'}})",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(obj) {\n"
+ "  obj.a.b = 123;\n"
+ "}\n"
+ "f({a: {b: 'str'}})");
"function f(obj) {\n"
+ "  var o;\n"
+ "  (o = obj).x - 1;\n"
+ "  return o.x;\n"
+ "}\n"
+ "f({x: 'str'});",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(obj) {\n"
+ "  ({x: obj.foo}).x - 1;\n"
+ "}\n"
+ "f({foo: 'str'});",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(x) {\n"
+ "  ({p: x++}).p = 'str';\n"
+ "}\n"
+ "f('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(x) {\n"
+ "  ({p: 'str'}).p = x++;\n"
+ "}\n"
+ "f('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f(x, y, z) {\n"
+ "  ({p: (y = x++), q: 'str'}).p = z = y;\n"
+ "  z < 'str';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "function f(obj) { obj.prop - 5; }\n"
+ "var /** !Foo */ x = new Foo;\n"
+ "f(x);\n"
+ "var /** !Bar */ y = x;",
"/** @constructor */ function Foo() {}\n"
+ "function f(obj) { obj.prop - 5; }\n"
+ "f(new Foo);",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.prop = 'str'; }\n"
+ "function f(obj) { obj.prop - 5; }\n"
+ "f(new Foo);",
"/** @constructor */ function Foo() { /** @type {number} */ this.prop = 1; }\n"
+ "function g(obj) { var /** string */ s = obj.prop; return obj; }\n"
+ "var /** !Foo */ x = g({ prop: '' });",
checkNoWarnings("function f(obj) { obj.a.num - 5; }\n"
+ "function g(obj) {\n"
+ "  obj.a.str < 'str';\n"
+ "  f(obj);\n"
+ "}");
checkNoWarnings("function f(/** Array<?> */ x) {}\n"
+ "function g(obj) {\n"
+ "  obj.x = 123;\n"
+ "  f(obj);\n"
+ "}");
"/** @param {({x:number}|{y:number})} obj */\n"
+ "function f(obj) {}\n"
+ "f({x: 5, y: 'asdf'});",
"function f() { return {}; }\n"
+ "/** @constructor */\n"
+ "f().Foo = function() {};",
"var x = {};\n"
+ "function f() { return x; }\n"
+ "/** @constructor */\n"
+ "f().Foo = function() {};\n"
+ "new (f().Foo)();",
"function Foo() {}; new Foo();", NewTypeInference.NOT_A_CONSTRUCTOR);
checkNoWarnings("/** @constructor */ function Foo() {};\n"
+ "function reqFoo(/** Foo */ f) {};\n"
+ "reqFoo(new Foo());");
"/** @constructor */ function Foo() {};\n"
+ "/** @constructor */ function Bar() {};\n"
+ "function reqFoo(/** Foo */ f) {};\n"
+ "reqFoo(new Bar());",
"/** @constructor */ function Foo() {};\n"
+ "function reqFoo(/** Foo */ f) {};\n"
+ "function g() {\n"
+ "  /** @constructor */ function Foo() {};\n"
+ "  reqFoo(new Foo());\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {number} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "/** @param {!Foo} x */\n"
+ "function f(x) { x.method('asdf'); }",
"function f(x) {\n"
+ "  var y = x;\n"
+ "  y < (123, 'asdf');\n"
+ "}\n"
+ "f(123);",
"function f(x) {\n"
+ "  var y = x;\n"
+ "  y < (typeof 123);\n"
+ "}\n"
+ "f(123);",
"function f(x) {\n"
+ "  if (typeof x === 'string') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  if (typeof x != 'function') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
"function f(x) {\n"
+ "  if (typeof x == 'string') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  if ('string' === typeof x) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  if (typeof x === 'number') {\n"
+ "    x < 'asdf';\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  if (typeof x === 'boolean') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  if (typeof x === 'undefined') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
checkNoWarnings("/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (typeof x === 'function') {\n"
+ "    x();\n"
+ "  }\n"
+ "}");
"function f(x) {\n"
+ "  if (typeof x === 'object') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  if (!(typeof x == 'number')) {\n"
+ "    x.prop;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(x) {\n"
+ "  if (!(typeof x == 'undefined')) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (!(typeof x == 'undefined')) {\n"
+ "    var /** undefined */ y = x;\n"
+ "  }\n"
+ "}",
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (typeof x !== 'undefined') {\n"
+ "    var /** undefined */ y = x;\n"
+ "  }\n"
+ "}",
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (typeof x == 'undefined') {} else {\n"
+ "    var /** undefined */ y = x;\n"
+ "  }\n"
+ "}",
checkNoWarnings("function f(/** (number|undefined) */ x) {\n"
+ "  if (typeof x !== 'undefined') {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f() {"
+ "  return (typeof 123 == 'number' ||"
+ "    typeof 123 == 'string' ||"
+ "    typeof 123 == 'boolean' ||"
+ "    typeof 123 == 'undefined' ||"
+ "    typeof 123 == 'function' ||"
+ "    typeof 123 == 'object' ||"
+ "    typeof 123 == 'unknown');"
+ "}");
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @param {(number|null|Foo)} x */\n"
+ "function f(x) {\n"
+ "  if (!(typeof x === 'object')) {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings("/** @param {(number|function(number):number)} x */\n"
+ "function f(x) {\n"
+ "  if (!(typeof x === 'function')) {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
"function f(x) {\n"
+ "  var y = x, z = 0;\n"
+ "  y < (z -= 123);\n"
+ "}\n"
+ "f('asdf');",
"function f(x) {\n"
+ "  var y = x, z = { prop: 0 };\n"
+ "  y < (z.prop -= 123);\n"
+ "}\n"
+ "f('asdf');",
"function f(x) {\n"
+ "  var z = { prop: 0 };\n"
+ "  x < z.prop;\n"
+ "  z.prop -= 123;\n"
+ "}\n"
+ "f('asdf');",
typeCheck("var x; x *= 123;", NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};\n"
+ "(new Foo()).n - 5;");
"/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};\n"
+ "(new Foo()).n = 'str';",
"/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n;\n"
+ "};\n"
+ "(new Foo()).n = 'str';",
"function f() { (new Foo()).n = 'str'; }\n"
+ "/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};",
"function f() { var x = new Foo(); x.n = 'str'; }\n"
+ "/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};",
checkNoWarnings("function f() { var x = new Foo(); return x.n - 5; }\n"
+ "/** @constructor */ function Foo() {\n"
+ "  this.n = 5;\n"
+ "};");
"function f() { var x = new Foo(); x.s = 'str'; x.s < x.n; }\n"
+ "/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};",
"/** @constructor */ function Foo() {\n"
+ "  /** @type {number} */ this.n = 5;\n"
+ "};\n"
+ "function reqFoo(/** Foo */ x) {};\n"
+ "reqFoo({ n : 20 });",
"function f() { var x = new Foo(); x.n - 5; x.n < 'str'; }\n"
+ "/** @constructor */ function Foo() {\n"
+ "  this.n = 5;\n"
+ "};",
NewTypeInference.INVALID_OPERAND_TYPE);
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {number} */ this.x = 'abc';\n"
+ "  /** @type {string} */ this.x = 'def';\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {number} */ this.x = 5;\n"
+ "  /** @type {number} */ this.x = 7;\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  this.x = 5;\n"
+ "  /** @type {number} */ this.x = 7;\n"
+ "}\n"
+ "function g() { (new Foo()).x < 'str'; }",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {number} */ this.x = 7;\n"
+ "  this.x = 5;\n"
+ "}\n"
+ "function g() { (new Foo()).x < 'str'; }",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {number} */ this.x = 7;\n"
+ "  this.x < 'str';\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {?} */ this.x = 1;\n"
+ "  /** @type {?} */ this.x = 1;\n"
+ "}",
GlobalTypeInfo.REDECLARED_PROPERTY);
"/** @constructor */ function Foo() {}\n"
+ "/** @type {string} */ Foo.prototype.x = 'str';\n"
+ "function g() { (new Foo()).x - 5; }",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.x = 'str';\n"
+ "function g() { var f = new Foo(); f.x - 5; f.x < 'str'; }",
"/** @constructor */ function Foo() {}\n"
+ "/** @type {function(string)} s */\n"
+ "Foo.prototype.bar = function(s) {};\n"
+ "function g() { (new Foo()).bar(5); }",
"/** @constructor */ function Foo() {};\n"
+ "Foo.prototype.bar = function(s) {\n"
+ "  /** @type {string} */ this.x = 'str';\n"
+ "};\n"
+ "(new Foo()).x - 5;",
"/** @constructor */ function Foo() {}\n"
+ "(function() { Foo.prototype.prop = 123; })();",
"/** @constructor */ function F() {}"
+ "F.prototype.bar = function() {};"
+ "F.prototype.bar = function() {};",
"/** @constructor */ function F() {}"
+ "/** @return {void} */ F.prototype.bar = function() {};"
+ "F.prototype.bar = function() {};",
checkNoWarnings("/** @constructor */ function C(){}\n"
+ "C.prototype.foo = {};\n"
+ "C.prototype.method = function() { this.foo.bar = 123; }");
checkNoWarnings("function f() {}\n"
+ "function g() { f.prototype.prop = 123; }");
checkNoWarnings("/** @param {!Function} f */"
+ "function foo(f) { f.prototype.bar = function(x) {}; }");
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function() {};\n"
+ "/** @type {number} */\n"
+ "Foo.prototype.method.pnum = 123;\n"
+ "var /** number */ n = Foo.prototype['method.pnum'];",
"/** @constructor */ function Foo() { this.x = 'str1'; };\n"
+ "/** @type {string} */ Foo.prototype.x = 'str2';\n"
+ "(new Foo).x - 5;",
"/** @constructor */ function Foo() {}\n"
+ "/** @type {string} */ Foo.prototype.x = 'str1';\n"
+ "Foo.prototype.x = 'str2';\n"
+ "(new Foo).x - 5;",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.x = 'str2';\n"
+ "/** @type {string} */ Foo.prototype.x = 'str1';\n"
+ "(new Foo).x - 5;",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.x = 'str1'; };\n"
+ "Foo.prototype.x = 'str2';\n"
+ "(new Foo).x - 5;",
"/** @constructor */ function Foo() { this.x = 5; };\n"
+ "/** @type {string} */ Foo.prototype.x = 'str';",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.x = 'str1'; };\n"
+ "Foo.prototype.x = 5;",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.x = 'str'; };\n"
+ "/** @type {number} */ Foo.prototype.x = 'str';",
"/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.prototype.x = 1;\n"
+ "/** @type {number} */ Foo.prototype.x = 2;",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.x = 'str';\n"
+ "var fp = Foo.prototype;\n"
+ "fp.x - 5;",
"/** @constructor */ function Foo() {}\n"
+ "function takesFoos(/** Foo */ afoo) {}\n"
+ "function f(/** (number|Foo) */ x) {\n"
+ "  takesFoos(x);\n"
+ "  if (x instanceof Foo) { takesFoos(x); }\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"({} instanceof function(){});", NewTypeInference.INVALID_OPERAND_TYPE);
"/** @constructor */ function Foo() {}\n"
+ "(123 instanceof Foo);",
"/** @constructor */ function Foo() {}\n"
+ "function takesFoos(/** Foo */ afoo) {}\n"
+ "function f(/** boolean */ cond, /** (number|Foo) */ x) {\n"
+ "  if (x instanceof (cond || Foo)) { takesFoos(x); }\n"
+ "}",
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "function f(/** (number|!Foo) */ x) {\n"
+ "  if (x instanceof Foo) {} else { x - 5; }\n"
+ "}");
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "function f(/** (number|!Foo) */ x) {\n"
+ "  if (!(x instanceof Foo)) { x - 5; }\n"
+ "}");
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "function takesFoos(/** Foo */ afoo) {}\n"
+ "function f(/** Foo */ x) {\n"
+ "  if (x instanceof Bar) {} else { takesFoos(x); }\n"
+ "}");
"/** @constructor */ function Foo() {}\n"
+ "function takesFoos(/** Foo */ afoo) {}\n"
+ "/** @param {*} x */ function f(x) {\n"
+ "  takesFoos(x);\n"
+ "  if (x instanceof Foo) { takesFoos(x); }\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @constructor */ function Foo() {}\n"
+ "var x = new Foo();\n"
+ "x.bar = 'asdf';\n"
+ "if (x instanceof Foo) { x.bar - 5; }",
"/** @constructor */ function Foo() { this.prop = 123; }\n"
+ "function f(x) { x = 123; if (x instanceof Foo) { x.prop; } }",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "/** @param {(number|!Bar)} x */\n"
+ "function f(x) {\n"
+ "  if (!(x instanceof Foo)) {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @enum {!Foo} */\n"
+ "var E = { ONE: new Foo };\n"
+ "/** @param {(number|E)} x */\n"
+ "function f(x) {\n"
+ "  if (!(x instanceof Foo)) {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
public void testFunctionsExtendFunction() {
checkNoWarnings("function f(x) {\n"
+ "  if (x instanceof Function) { x(); }\n"
+ "}");
checkNoWarnings("function f(x) {\n"
+ "  if (x instanceof Function) { x(1); x('str') }\n"
+ "}");
checkNoWarnings("function f(/** (null|function()) */ x) {\n"
+ "  if (x instanceof Function) { x(); }\n"
+ "}");
typeCheck(
"function f(/** (null|function()) */ x) {\n"
+ "  if (x instanceof Function) {} else { x(); }\n"
+ "}",
TypeCheck.NOT_CALLABLE);
checkNoWarnings("(function(){}).call(null);");
checkNoWarnings("function greet(name) {}\n"
+ "greet.call(null, 'bob');\n"
+ "greet.apply(null, ['bob']);");
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "Foo.prototype.greet = function(name){};\n"
+ "Foo.prototype.greet.call(new Foo, 'bob');");
typeCheck(
"Function.prototype.method = function(/** string */ x){};\n"
+ "(function(){}).method(5);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(value) {\n"
+ "  if (value instanceof Function) {} else if (value instanceof Object) {\n"
+ "    return value.displayName || value.name || '';\n"
+ "  }\n"
+ "};");
public void testObjectsAreNotClassy() {
typeCheck(
"function g(obj) {\n"
+ "  if (!(obj instanceof Object)) { throw -1; }\n"
+ "  return obj.x - 5;\n"
+ "}\n"
+ "g(new Object);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"function f() {}\n"
+ "f.x = 'asdf';\n"
+ "f.x - 5;",
"/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.n = 1\n"
+ "/** @type {number} */ Foo.n = 1",
checkNoWarnings("function g() { Foo.bar - 5; }\n"
+ "/** @constructor */ function Foo() {}\n"
+ "Foo.bar = 42;");
"function g() { Foo.bar - 5; }\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @type {string} */ Foo.bar = 'str';",
"function g() { return (new Foo).bar; }\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @type {string} */ Foo.bar = 'str';",
"/** @constructor */ function Foo() {}\n"
+ "/** @type {string} */ Foo.prop = 'asdf';\n"
+ "var x = Foo;\n"
+ "x.prop - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
"function g() { Foo.prototype.baz = (new Foo).bar + Foo.bar; }\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.prototype.bar = 5\n"
+ "/** @type {string} */ Foo.bar = 'str';",
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.n = 1;\n"
+ "Foo.n = 1;");
"/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.n;\n"
+ "Foo.n = '';",
checkNoWarnings("function f(/** ? */ x) {\n"
+ "  if (!(typeof x == 'number')) {\n"
+ "    x < 'asdf';\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(/** { prop: ? } */ x) {\n"
+ "  var /** (number|string) */ y = x.prop;\n"
+ "  x.prop < 5;\n"
+ "}");
"function f(/** (number|string) */ x, /** (number|string) */ y) {\n"
+ "  var z;\n"
+ "  if (1 < 2) {\n"
+ "    z = x;\n"
+ "  } else {\n"
+ "    z = y;\n"
+ "  }\n"
+ "  z - 5;\n"
+ "}",
"function f(/** { n: number } */ obj) {\n"
+ "  var o2 = obj;\n"
+ "  o2.n = 'asdf';\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("function f(f1, /** function(string=) */ f2, cond) {\n"
+ "  var y;\n"
+ "  if (cond) {\n"
+ "    f1();"
+ "    y = f1;\n"
+ "  } else {\n"
+ "    y = f2;\n"
+ "  }\n"
+ "  return y;\n"
+ "}");
typeCheck(
"/** @param {function(number=)} fnum */\n"
+ "function f(fnum) {\n"
+ "  fnum(); fnum('asdf');\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @param {function(... [number])} fnum */\n"
+ "function f(fnum) {\n"
+ "  fnum(); fnum(1, 2, 3, 'asdf');\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @param {function(number=, number)} g */\n"
+ "function f(g) {}",
"/** @param {number=} x */\n"
+ "function f(x) {}\n"
+ "f(); f('asdf');",
"/** @param {number=} x */\n"
+ "function f(x) {}\n"
+ "f(1, 2);",
typeCheck(
"/** @type {function()} */ function f(x) {}",
typeCheck(
"/** @type {function(number)} */ function f() {}",
typeCheck(
"/** @type {function(number)} */ function f(/** number */ x) {}",
"/**\n"
+ " * @param {number=} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "function f(x, y) {}",
"/** @type {function(number=)} */ function f(x) {}\n"
+ "f(); f('asdf');",
typeCheck(
"/** @type {function(number=, number)} */ function f(x, y) {}",
"/** @type {function(): number} */\n"
+ "function /** number */ f() { return 1; }",
"/** @type {function(... [number])} */ function f() {}"
+ "f(); f(1, 2, 3); f(1, 2, 'asdf');",
"/** @param {...number} var_args */ function f(var_args) {}\n"
+ "f(); f(1, 2, 3); f(1, 2, 'asdf');",
typeCheck(
"/** @type {function(... [number])} */ function f(x) {}",
"/**\n"
+ " * @param {...number} var_args\n"
+ " * @param {number=} x\n"
+ " */\n"
+ "function f(var_args, x) {}",
"/** @type {function(number=, ...[number])} */\n"
+ "function f(x) {}\n"
+ "f('asdf');",
typeCheck(
"function f(/** function(number=) */ fnum,"
+ "  /** function(string=) */ fstr, cond) {\n"
+ "  var y;\n"
+ "  if (cond) {\n"
+ "    y = fnum;\n"
+ "  } else {\n"
+ "    y = fstr;\n"
+ "  }\n"
+ "  y();\n"
+ "  y(123);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function f(/** function(... [number]) */ fnum,"
+ "  /** function(... [string]) */ fstr, cond) {\n"
+ "  var y;\n"
+ "  if (cond) {\n"
+ "    y = fnum;\n"
+ "  } else {\n"
+ "    y = fstr;\n"
+ "  }\n"
+ "  y();\n"
+ "  y(123);\n"
+ "}",
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL);
typeCheck(
"function f(\n"
+ "  /** function() */ f1, /** function(string=) */ f2, cond) {\n"
+ "  var y;\n"
+ "  if (cond) {\n"
+ "    y = f1;\n"
+ "  } else {\n"
+ "    y = f2;\n"
+ "  }\n"
+ "  y(123);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @param {function(string): *} x */ function g(x) {}\n"
+ "/** @param {function(... [number]): string} x */ function f(x) {\n"
+ "  g(x);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @param {number=} x\n"
+ " * @param {number=} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f(undefined, 123);\n"
+ "f('str')",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(/** function(...) */ fun) {}\n"
+ "f(function() {});");
checkNoWarnings("function f(/** function(... [number]) */ x) {}\n"
+ "f(function() {});");
checkNoWarnings("function f(/** function() */ x) {}\n"
+ "f(/** @type {function(... [number])} */ (function(nums) {}));");
"function f(/** function(string=) */ x) {}\n"
+ "f(/** @type {function(... [number])} */ (function(nums) {}));",
"function f(/** function(... [number]) */ x) {}\n"
+ "f(/** @type {function(string=)} */ (function(x) {}));",
checkNoWarnings("/** @param {number} opt_num */ function f(opt_num) {}\n"
+ "f();");
"function f(opt_num, x) {}", RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
"function f(var_args, x) {}", RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
"function f(x) {\n"
+ "  if (x !== undefined) {\n"
+ "    return x-5;\n"
+ "  } else {\n"
+ "    return 0;\n"
+ "  }\n"
+ "}\n"
+ "f() - 1;\n"
+ "f('str');",
"/** @return {function(number=)} */\n"
+ "function f() {\n"
+ "  return function(x) {};\n"
+ "}\n"
+ "f()();\n"
+ "f()('str');",
checkNoWarnings("/** @constructor */\n"
+ "function Parent() {}\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {}\n"
+ "Child.prototype = new Parent();");
typeCheck(
"/** @constructor */\n"
+ "function Parent() {\n"
+ "  /** @type {string} */ this.prop = 'asdf';\n"
+ "}\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {}\n"
+ "Child.prototype = new Parent();\n"
+ "(new Child()).prop - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @constructor */\n"
+ "function Parent() {\n"
+ "  /** @type {string} */ this.prop = 'asdf';\n"
+ "}\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {}\n"
+ "Child.prototype = new Parent();\n"
+ "(new Child()).prop = 5;",
"/** @constructor */\n"
+ "function Parent() {}\n"
+ "/** @type {string} */ Parent.prototype.prop = 'asdf';\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {}\n"
+ "Child.prototype = new Parent();\n"
+ "(new Child()).prop - 5;",
"/** @constructor */\n"
+ "function Parent() {}\n"
+ "/** @type {string} */ Parent.prototype.prop = 'asdf';\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {\n"
+ "  /** @type {number} */ this.prop = 5;\n"
+ "}\n"
+ "Child.prototype = new Parent();",
"/** @constructor */\n"
+ "function Parent() {}\n"
+ "/** @type {string} */ Parent.prototype.prop = 'asdf';\n"
+ "/** @constructor @extends{Parent} */\n"
+ "function Child() {}\n"
+ "Child.prototype = new Parent();\n"
+ "/** @type {number} */ Child.prototype.prop = 5;",
"/** @constructor */\n"
+ "function Parent() {}\n"
+ "/** @extends {Parent} */ function Child() {}",
JSTypeCreatorFromJSDoc.EXTENDS_NOT_ON_CTOR_OR_INTERF);
JSTypeCreatorFromJSDoc.EXTENDS_NON_OBJECT);
"/**\n"
+ " * @constructor\n"
+ " * @implements {string}\n"
+ " */\n"
+ "function Foo() {}",
"/**\n"
+ " * @interface\n"
+ " * @extends {number}\n"
+ " */\n"
+ "function Foo() {}",
"/** @interface */ function Foo() {}\n"
+ "/** @implements {Foo} */ function bar() {}",
JSTypeCreatorFromJSDoc.IMPLEMENTS_WITHOUT_CONSTRUCTOR);
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function(x) { x - 1; };\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "Bar.prototype.method = function(x, y) { x - y; };\n"
+ "Bar.prototype.method2 = function(x, y) {};\n"
+ "Bar.prototype.method = Bar.prototype.method2;",
checkNoWarnings("/** @constructor */ function Parent() {}\n"
+ "/** @constructor @extends{Parent} */ function Child() {}\n"
+ "(function(/** Parent */ x) {})(new Child);");
"/** @constructor */ function Parent() {}\n"
+ "/** @constructor @extends{Parent} */ function Child() {}\n"
+ "(function(/** Child */ x) {})(new Parent);",
"/** @constructor */ function Parent() {}\n"
+ "/** @constructor @extends{Parent} */ function Child() {}\n"
+ "/** @constructor */\n"
+ "function Foo() { /** @type {Parent} */ this.x = new Child(); }\n"
+ "/** @type {Child} */ Foo.prototype.y = new Parent();",
checkNoWarnings("/** @interface */\n"
+ "function High() {}\n"
+ "/** @constructor @implements {High} */\n"
+ "function Low() {}\n"
+ "var /** !High */ x = new Low");
checkNoWarnings("/** @interface */\n"
+ "function High() {}\n"
+ "/** @interface @extends {High}*/\n"
+ "function Low() {}\n"
+ "function f(/** !High */ h, /** !Low */ l) { h = l; }");
checkNoWarnings("/** @interface */\n"
+ "function High() {}\n"
+ "/** @interface @extends {High}*/\n"
+ "function Low() {}\n"
+ "/** @constructor @implements {Low} */\n"
+ "function Foo() {}\n"
+ "var /** !High */ x = new Foo;");
checkNoWarnings("/** @interface */\n"
+ "function Foo() {}\n"
+ "/** @interface */\n"
+ "function High() {}\n"
+ "/** @interface @extends {High} */\n"
+ "function Med() {}\n"
+ "/**\n"
+ " * @interface\n"
+ " * @extends {Med}\n"
+ " * @extends {Foo}\n"
+ " */\n"
+ "function Low() {}\n"
+ "function f(/** !High */ x, /** !Low */ y) { x = y }");
typeCheck(
"/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "function f(/** !Foo<number> */ x, /** !Foo<string> */ y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {Foo<number>}\n"
+ " */\n"
+ "function Bar() {}\n"
+ "function f(/** !Foo<string> */ x, /** Bar */ y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @implements {Foo<T>}\n"
+ " */\n"
+ "function Bar() {}\n"
+ "function f(/** !Foo<string> */ x, /** !Bar<number> */ y) { x = y; }",
checkNoWarnings("/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @implements {Foo<T>}\n"
+ " */\n"
+ "function Bar() {}\n"
+ "function f(/** !Foo<string> */ x, /** !Bar<string> */ y) {\n"
+ "  x = y;\n"
+ "}");
typeCheck(
"/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @implements {Foo<T>}\n"
+ " */\n"
+ "function Bar() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {!Foo<T>} x\n"
+ " * @param {!Bar<number>} y\n"
+ " */\n"
+ "function f(x, y) { x = y; }",
DEFAULT_EXTERNS
+ "/** @return {string} */ Object.prototype.toString = function() {};";
checkNoWarnings(
objectExterns,
"/** @constructor */ function Foo() {}\n"
+ "/** @override */ Foo.prototype.toString = function(){ return ''; };");
typeCheck(
objectExterns,
"/** @constructor */ function Foo() {}\n"
+ "/** @override */ Foo.prototype.toString = function(){ return 5; };",
"/** @constructor @extends {Parent} */ function Child() {}\n"
+ "/** @type {string} */ Child.prototype.y = 'str';\n"
+ "/** @constructor */ function Grandparent() {}\n"
+ "/** @type {number} */ Grandparent.prototype.y = 9;\n"
+ "/** @constructor @extends {Grandparent} */ function Parent() {}",
"/** @interface */ function Parent() {}\n"
+ "/** @type {number} */ Parent.prototype.y = 9;\n"
+ "/** @constructor @implements {Parent} */ function Child() {}\n"
+ "/** @param {string} x */ Child.prototype.y = function(x) {};",
"/** @interface */ function Parent() {}\n"
+ "/** @param {string} x */ Parent.prototype.y = function(x) {};\n"
+ "/** @constructor @implements {Parent} */ function Child() {}\n"
+ "/** @type {number} */ Child.prototype.y = 9;",
"/** @constructor */ function Parent() {}\n"
+ "/** @type {number} */ Parent.prototype.y = 9;\n"
+ "/** @constructor @extends {Parent} */ function Child() {}\n"
+ "/** @param {string} x */ Child.prototype.y = function(x) {};",
"/** @constructor */ function Parent() {}\n"
+ "/** @param {string} x */ Parent.prototype.y = function(x) {};\n"
+ "/** @constructor @extends {Parent} */ function Child() {}\n"
+ "/** @type {number} */ Child.prototype.y = 9;",
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @param {(Foo|Bar)} x */ function reqFooBar(x) {}\n"
+ "function f(cond) {\n"
+ "  reqFooBar(cond ? new Foo : new Bar);\n"
+ "}");
typeCheck(
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @param {Foo} x */ function reqFoo(x) {}\n"
+ "function f(cond) {\n"
+ "  reqFoo(cond ? new Foo : new Bar);\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @param {(Foo|Bar)} x */ function g(x) {\n"
+ "  if (x instanceof Foo) {\n"
+ "    var /** Foo */ y = x;\n"
+ "  } else {\n"
+ "    var /** Bar */ z = x;\n"
+ "  }\n"
+ "  var /** Foo */ w = x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.s = 'str'; }\n"
+ "/** @param {(!Foo|{n:number, s:string})} x */ function g(x) {\n"
+ "  if (x instanceof Foo) {\n"
+ "  } else {\n"
+ "    x.s - 5;\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.prototype.n = 5;\n"
+ "/** @param {{n : number}} x */ function reqRecord(x) {}\n"
+ "function f() {\n"
+ "  reqRecord(new Foo);\n"
+ "}");
"/** @constructor */ function Foo() {}\n"
+ "/** @type {number} */ Foo.prototype.n = 5;\n"
+ "/** @param {{n : string}} x */ function reqRecord(x) {}\n"
+ "function f() {\n"
+ "  reqRecord(new Foo);\n"
+ "}",
"/** @constructor */ function Foo() {}\n"
+ "/** @param {{n : number}|!Foo} x */\n"
+ "function f(x) {\n"
+ "  x.n - 5;\n"
+ "}",
"/** @constructor */ function Foo() {}\n"
+ "/** @param {{n : number}|!Foo} x */\n"
+ "function f(x) {\n"
+ "  x.abc - 5;\n"
+ "}",
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @param {!Bar|!Foo} x */\n"
+ "function f(x) {\n"
+ "  x.abc = 'str';\n"
+ "  if (x instanceof Foo) {\n"
+ "    x.abc - 5;\n"
+ "  }\n"
+ "}",
checkNoWarnings("/** @param {function():string | function():number} x\n"
+ "  * @return {string|number} */\n"
+ "function f(x) {\n"
+ "  return x();\n"
+ "}");
typeCheck(
"/** @param {function(string)|function(number)} x\n"
+ "  * @param {string|number} y */\n"
+ "function f(x, y) {\n"
+ "  x(y);\n"
+ "}",
"/** @returns {gibberish} */\n"
+ "function f(x) { return x; };",
checkNoWarnings("/** @constructor @extends {Bar}*/ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}");
checkNoWarnings("/** @param {Foo} x */ function f(x) {}\n"
+ "/** @constructor */ function Foo() {}");
"f(new Bar)\n"
+ "/** @param {Foo} x */ function f(x) {}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}",
checkNoWarnings("/** @constructor @param {Foo} x */ function Bar(x) {}\n"
+ "/** @constructor @param {Bar} x */ function Foo(x) {}\n"
+ "new Bar(new Foo(null));");
"/** @constructor @param {Foo} x */ function Bar(x) {}\n"
+ "/** @constructor @param {Bar} x */ function Foo(x) {}\n"
+ "new Bar(new Foo(undefined));",
"/** @constructor @extends {Bar} */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}",
JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE);
"/** @interface @extends {Bar} */ function Foo() {}\n"
+ "/** @interface @extends {Foo} */ function Bar() {}",
JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE);
JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE);
public void testInterfaceNonEmptyFunction() throws Exception {
"/** @interface */ function T() {};\n"
+ "T.prototype.x = function() { return 'foo'; }",
TypeCheck.INTERFACE_METHOD_NOT_EMPTY);
"/** @interface */ function I() {}\n"
+ "/** @type {number} */ I.prototype.y = 'asdf';",
"/** @interface */ function I() {}\n"
+ "/** @type {string} */ I.prototype.prop;\n"
+ "/** @constructor @implements{I} */ function C() {}",
"/** @interface */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x) {};\n"
+ "/** @constructor @implements{I} */ function C() {}",
"/** @interface */ function IParent() {}\n"
+ "/** @type {number} */ IParent.prototype.prop;\n"
+ "/** @interface @extends{IParent} */ function IChild() {}\n"
+ "/** @constructor @implements{IChild} */\n"
+ "function C() { this.prop = 5; }\n"
+ "(new C).prop < 'adsf';",
"/** @interface */ function IParent() {}\n"
+ "/** @type {number} */ IParent.prototype.prop;\n"
+ "/** @interface @extends{IParent} */ function IChild() {}\n"
+ "/** @constructor @implements{IChild} */\n"
+ "function C() { this.prop = 'str'; }",
checkNoWarnings("/** @constructor */\n"
+ "function Parent() { /** @type {number} */ this.prop = 123; }\n"
+ "/** @constructor @extends {Parent} */ function Child() {}\n"
+ "(new Child).prop = 321;");
"/** @constructor */\n"
+ "function Parent() { /** @type {number} */ this.prop = 123; }\n"
+ "/** @constructor @extends {Parent} */ function Child() {}\n"
+ "(new Child).prop = 'str';",
"/** @interface */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x, y) {};\n"
+ "/** @constructor @implements{I} */ function C() {}\n"
+ "/** @param {string} y */\n"
+ "C.prototype.method = function(x, y) {};\n"
+ "(new C).method(5, 6);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @interface */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x, y) {};\n"
+ "/** @constructor @implements{I} */ function C() {}\n"
+ "/** @param {string} y */\n"
+ "C.prototype.method = function(x, y) {};\n"
+ "(new C).method('asdf', 'fgr');",
"/** @interface */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x) {};\n"
+ "/** @constructor @implements{I} */ function C() {}\n"
+ "C.prototype.method = function(x) {};\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @interface */ function I1() {}\n"
+ "/** @param {number} x */ I1.prototype.method = function(x, y) {};\n"
+ "/** @interface */ function I2() {}\n"
+ "/** @param {string} y */ I2.prototype.method = function(x, y) {};\n"
+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"
+ "C.prototype.method = function(x, y) {};\n"
+ "(new C).method('asdf', 'fgr');",
"/** @interface */ function I1() {}\n"
+ "/** @param {number} x */ I1.prototype.method = function(x, y) {};\n"
+ "/** @interface */ function I2() {}\n"
+ "/** @param {string} y */ I2.prototype.method = function(x, y) {};\n"
+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"
+ "C.prototype.method = function(x, y) {};\n"
+ "(new C).method(1, 2);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/** @interface */ function I1() {}\n"
+ "/** @param {number} x */ I1.prototype.method = function(x) {};\n"
+ "/** @interface */ function I2() {}\n"
+ "/** @param {string} x */ I2.prototype.method = function(x) {};\n"
+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"
+
"/** @interface */ function I1() {}\n"
+ "/** @param {number} x */ I1.prototype.method = function(x) {};\n"
+ "/** @interface */ function I2() {}\n"
+ "/** @param {string} x */ I2.prototype.method = function(x) {};\n"
+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"
+
"C.prototype.method = function(x) {};\n"
+ "(new C).method(true);",
"/** @interface */ function I() {}\n"
+ "/** @param {number} x */ I.prototype.method = function(x) {};\n"
+ "/** @constructor */ function S() {}\n"
+ "/** @param {string} x */ S.prototype.method = function(x) {};\n"
+ "/** @constructor @implements{I} @extends{S} */ function C(){}\n"
+
"C.prototype.method = function(x) {};\n"
+ "(new C).method(true);",
checkNoWarnings("/** @interface */\n"
+ "function I1() {}\n"
+ "I1.prototype.method = function(x) {};\n"
+ "/** @interface */\n"
+ "function I2() {}\n"
+ "I2.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @interface\n"
+ " * @extends {I1}\n"
+ " * @extends {I2}\n"
+ " */\n"
+ "function I3() {}\n"
+ "/** @constructor @implements {I3} */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function(x) {};");
"/** @interface */\n"
+ "function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x) {};\n"
+ "/** @param {!I} x */\n"
+ "function foo(x) { x.method('asdf'); }",
"/** @interface */\n"
+ "function IParent() {}\n"
+ "/** @param {number} x */\n"
+ "IParent.prototype.method = function(x) {};\n"
+ "/** @interface @extends {IParent} */\n"
+ "function IChild() {}\n"
+ "/** @param {!IChild} x */\n"
+ "function foo(x) { x.method('asdf'); }",
public void testExtendedInterfacePropertiesCompatibility() {
typeCheck(
"/** @interface */function Int0() {};"
+ "/** @interface */function Int1() {};"
+ "/** @type {number} */"
+ "Int0.prototype.foo;"
+ "/** @type {string} */"
+ "Int1.prototype.foo;"
+ "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+ "function Int2() {};",
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);
"/** @interface */\n"
+ "function Parent1() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {number}\n"
+ " */\n"
+ "Parent1.prototype.method = function(x) {};\n"
+ "/** @interface */\n"
+ "function Parent2() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {string}\n"
+ " */\n"
+ "Parent2.prototype.method = function(x) {};\n"
+ "/** @interface @extends {Parent1} @extends {Parent2} */\n"
+ "function Child() {}",
TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE);
typeCheck(
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @interface */\n"
+ "function Parent1() {}\n"
+ "/** @type {!Foo} */\n"
+ "Parent1.prototype.obj;\n"
+ "/** @interface */\n"
+ "function Parent2() {}\n"
+ "/** @type {!Bar} */\n"
+ "Parent2.prototype.obj;\n"
+ "/** @interface @extends {Parent1} @extends {Parent2} */\n"
+ "function Child() {}",
"/** @interface */function Int0() {};"
+ "/** @type {function()} */"
+ "Int0.prototype.foo;"
+ "/** @interface @extends {Int0} */function Int1() {};"
+ "/** @constructor \n @implements {Int1} */"
+ "function Ctor() {};",
"/** @constructor */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x) {};\n"
+ "/** @constructor @extends{I} */ function C() {}\n"
+ "C.prototype.method = function(x) {};\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @constructor */ function I() {}\n"
+ "/** @param {number} x */\n"
+ "I.prototype.method = function(x, y) {};\n"
+ "/** @constructor @extends{I} */ function C() {}\n"
+ "/** @param {string} y */\n"
+ "C.prototype.method = function(x, y) {};\n"
+ "(new C).method('asdf', 'fgr');",
"/** @constructor @extends {Bar} */\n"
+ "function Foo() {}\n"
+ "/** @interface */\n"
+ "function Bar() {}",
"/** @constructor @implements {Bar} */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @interface @implements {Foo} */\n"
+ "function Bar() {}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @interface @extends {Foo} */\n"
+ "function Bar() {}",
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() { /** @type {string} */ this.prop = 'asdf'; }\n"
+ "function f(/** (!Foo|!Bar) */ obj) {\n"
+ "  if (!(obj instanceof Foo)) {\n"
+ "    obj.prop - 5;\n"
+ "  }\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("function f(cond) {\n"
+ "  var x = cond ? null : 123;\n"
+ "  if (!(x === null)) { x - 5; }\n"
+ "}");
"/** @constructor */ function Foo(){ this.prop = 123; }\n"
+ "function f(/** Foo */ obj) {\n"
+ "  if (!obj) { obj.prop; }\n"
+ "}",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {Foo} x */\n"
+ "function f(x) {}\n"
+ "f(new Foo);");
"/** @constructor */ function Foo(){ this.prop = 123; }\n"
+ "function f(/** Foo */ obj) { obj.prop; }",
NewTypeInference.NULLABLE_DEREFERENCE);
"/** @interface */\n"
+ "function I() {}\n"
+ "I.prototype.method = function() {};\n"
+ "/** @param {I} x */\n"
+ "function foo(x) { x.method(); }",
NewTypeInference.NULLABLE_DEREFERENCE);
"/** @constructor */\n"
+ "function C(){ /** @type {number} */ this.prop = 1; }\n"
+ "(new C)['prop'] < 'asdf';",
"function f(x, y) {\n"
+ "  x < y;\n"
+ "  ({})[y - 5];\n"
+ "}\n"
+ "f('asdf', 123);",
checkNoWarnings("function f(x, y) {\n"
+ "  x < y;\n"
+ "  ({})[y - 5];\n"
+ "  x = 'asdf';\n"
+ "}\n"
+ "f('asdf', 123);");
typeCheck(
"function f(x, y) {\n"
+ "  ({})[y - 5];\n"
+ "  x < y;\n"
+ "}\n"
+ "f('asdf', 123);",
"function f(x) {\n"
+ "  x['prop'] = 'str';\n"
+ "  return x['prop'] - 5;\n"
+ "}\n"
+ "f({});",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("function f(/** ? */ o) { return o[0].prop; }");
checkNoWarnings("function f(x) {\n"
+ "  x['prop'] = 7;\n"
+ "  var p = 'prop';\n"
+ "  x[p] = 'str';\n"
+ "  return x['prop'] - 5;\n"
+ "}\n"
+ "f({});");
"/** @const */ var ns = {};\n"
+ "/** @constructor */ ns.C = function() {};\n"
+ "ns.C();",
"/** @const */ var ns = {};\n"
+ "/** @param {number} x */ ns.f = function(x) {};\n"
+ "ns.f('asdf');",
"/** @const */ var ns = {};\n"
+ "/** @constructor */ ns.C = function(){}\n"
+ "ns.C.prototype.method = function(/** string */ x){};\n"
+ "(new ns.C).method(5);",
"/** @const */ var ns = {};\n"
+ "/** @const */ ns.ns2 = {};\n"
+ "/** @constructor */ ns.ns2.C = function() {};\n"
+ "ns.ns2.C();",
"/** @const */ var ns = {};\n"
+ "/** @const */ ns.ns2 = {};\n"
+ "/** @constructor */ ns.ns2.C = function() {};\n"
+ "ns.ns2.C.prototype.method = function(/** string */ x){};\n"
+ "(new ns.ns2.C).method(11);",
"/** @constructor */ function C1(){}\n"
+ "/** @constructor */ C1.C2 = function(){}\n"
+ "C1.C2.prototype.method = function(/** string */ x){};\n"
+ "(new C1.C2).method(1);",
"/** @constructor */ function C1(){};\n"
+ "/** @constructor */ C1.prototype.C2 = function(){};\n"
+ "(new C1).C2();",
"/** @const */ var ns = {};\n"
+ "/** @type {number} */ ns.N = 5;\n"
+ "ns.N();",
"/** @const */ var ns = {};\n"
+ "/** @type {number} */ ns.foo = 123;\n"
+ "/** @type {string} */ ns.foo = '';",
"/** @const */ var ns = {};\n"
+ "/** @type {number} */ ns.foo;\n"
+ "/** @type {string} */ ns.foo;",
"/** @const */ var ns = {};\n"
+ "/** @type {number} */ ns.foo;\n"
+ "/** @type {number} */ ns.foo;",
checkNoWarnings("var ns = {};\n"
+ "/** @type {number} */ ns.foo = 123;\n"
+ "/** @type {string} */ ns.foo = '';");
"/** @const */ var ns = {};\n"
+ "ns.x = 5;\n"
+ "/** @type {string} */\n"
+ "ns.x = 'str';",
"/** @const */ var ns = {};\n"
+ "ns.prop = 1;\n"
+ "function f() { var /** string */ s = ns.prop; }",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.subns = {};\n"
+ "/** @type {string} */\n"
+ "ns.subns.n = 'str';\n"
+ "function f() { ns.subns.n - 5; }",
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = null;\n"
+ "function setObj() {\n"
+ "  ns.obj = {};\n"
+ "}");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = null;\n"
+ "function setObj() {\n"
+ "  ns.obj = {};\n"
+ "  ns.obj.str = 'str';\n"
+ "}");
typeCheck(
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = null;\n"
+ "ns.obj = {};\n"
+ "ns.obj.x = 'str';\n"
+ "ns.obj.x - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = null;\n"
+ "ns.obj = { x : 1, y : 5};\n"
+ "ns.obj.x = 'str';");
typeCheck(
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = null;\n"
+ "ns.obj = { x : 1, y : 5};\n"
+ "ns.obj.x = 'str';\n"
+ "ns.obj.x - 5;",
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @constructor */\n"
+ "ns.Foo = function() {\n"
+ "  ns.Foo.obj.value = ns.Foo.VALUE;\n"
+ "};\n"
+ "ns.Foo.obj = {};\n"
+ "ns.Foo.VALUE = 128;");
checkNoWarnings("/** @const */ var ns = ns || {}\n"
+ "/** @const */ var ns = ns || {}");
checkNoWarnings("/** @const */ var ns = ns || {}\n"
+ "ns.subns = ns.subns || {}\n"
+ "ns.subns = ns.subns || {}");
"/** @const */ var ns = {};\n"
+ "/** @constructor */ ns.subns.Foo = function(){};",
"/** @const */ var ns = {};\n"
+ "ns.subns.subsubns = {};",
"/** @const */ var ns = {};\n"
+ "/** @enum {number} */ ns.subns.NUM = { N : 1 };",
"/** @const */ var ns = {};\n"
+ "/** @typedef {number} */ ns.subns.NUM;",
"/** @constructor */ function Foo(){}\n"
+ "Foo.subns.subsubns = {};",
"/** @constructor */ function Foo(){}\n"
+ "/** @constructor */ Foo.subns.Bar = function(){};",
checkNoWarnings("function f(cond, x, y) {\n"
+ "  if (cond) {\n"
+ "    x < y;\n"
+ "    throw 123;\n"
+ "  } else {\n"
+ "    x < 2;\n"
+ "  }\n"
+ "}");
typeCheck("throw (1 - 'asdf');", NewTypeInference.INVALID_OPERAND_TYPE);
"/** @const */ var ns = {};\n"
+ "/** @constructor */ ns.C = function() {};\n"
+ "/** @param {!ns.C} x */ function f(x) {\n"
+ "  123, x.prop;\n"
+ "}",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings("/** @const */ var ns = { x : 5 };\n"
+ "ns.x++; ++ns.x; ns.x--; --ns.x;");
checkNoWarnings("function f(x, y, z) { return x || y && z;}");
"function f(/** number */ x, /** string */ y) {\n"
+ "  var /** number */ n = x || y;\n"
+ "}",
"function f(/** number */ x, /** string */ y) {\n"
+ "  var /** number */ n = y || x;\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  if (null == x) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(x) {\n"
+ "  if (x == null) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}");
typeCheck(
"function f(x) {\n"
+ "  if (null == x) {\n"
+ "    var /** null */ y = x;\n"
+ "    var /** undefined */ z = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (5 == x) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (x == 5) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (null == x) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (x == null) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("function f(x) {\n"
+ "  if (null != x) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(x) {\n"
+ "  if (x != null) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}");
typeCheck(
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (5 != x) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (x != 5) {\n"
+ "  } else {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (null != x) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @param {*} x */\n"
+ "function f(x) {\n"
+ "  if (x != null) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"function f(x) {\n"
+ "  for (; x - 5 > 0; ) {}\n"
+ "  x = undefined;\n"
+ "}\n"
+ "f(true);",
"function f(x) {\n"
+ "  while (x - 5 > 0) {}\n"
+ "  x = undefined;\n"
+ "}\n"
+ "f(true);",
"function f(x) {\n"
+ "  if (x - 5 > 0) {}\n"
+ "  x = undefined;\n"
+ "}\n"
+ "f(true);",
"function f(x) {\n"
+ "  do {} while (x - 5 > 0);\n"
+ "  x = undefined;\n"
+ "}\n"
+ "f(true);",
checkNoWarnings("/** @constructor */ function Foo() { this.prop = 123; }\n"
+ "function f(x) { if (x instanceof Foo) { var y = x.prop; } }");
checkNoWarnings("/** @constructor */ function Foo() { this.prop = 123; }\n"
+ "/** @constructor */ function Bar() { this.prop = 123; }\n"
+ "function f(cond, x) {\n"
+ "  x = cond ? new Foo : new Bar;\n"
+ "  var y = x.prop;\n"
+ "}");
"function f(x, y) {\n"
+ "  x < y;\n"
+ "  var /** number */ z = 5;\n"
+ "  z += y;\n"
+ "}\n"
+ "f('asdf', 5);",
checkNoWarnings("function f(x, y) {\n"
+ "  x < y;\n"
+ "  var z = 5;\n"
+ "  z += y;\n"
+ "}\n"
+ "f('asdf', 5);");
typeCheck("var b = true; b += 5;", NewTypeInference.INVALID_OPERAND_TYPE);
public void testTypeCoercions() {
typeCheck(
"function f(/** * */ x) {\n"
+ "  var /** string */ s = !x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"function f(/** * */ x) {\n"
+ "  var /** string */ s = +x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings(
"function f(/** * */ x) {\n"
+ "  var /** string */ s = '' + x;\n"
+ "}");
typeCheck(
"function f(/** * */ x) {\n"
+ "  var /** number */ s = '' + x;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"switch (1) {\n"
+ "  case 1:\n"
+ "    1 - 'asdf';\n"
+ "}",
"switch (1) {\n"
+ "  default:\n"
+ "    1 - 'asdf';\n"
+ "}",
"switch (1 - 'asdf') {\n"
+ "  case 1:\n"
+ "    break;\n"
+ "}",
"switch (1) {\n"
+ "  case (1 - 'asdf'):\n"
+ "    break;\n"
+ "}",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** Foo */ x) {\n"
+ "  switch (x) {\n"
+ "    case null:\n"
+ "      break;\n"
+ "    default:\n"
+ "      var /** !Foo */ y = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(x) {\n"
+ "  switch (x) {\n"
+ "    case 123:\n"
+ "      x - 5;\n"
+ "  }\n"
+ "}");
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** Foo */ x) {\n"
+ "  switch (x) {\n"
+ "    case null:\n"
+ "    default:\n"
+ "      var /** !Foo */ y = x;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  switch (x) {\n"
+ "    case null:\n"
+ "      x - 5;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  switch (x) {\n"
+ "    case null:\n"
+ "      var /** undefined */ y = x;\n"
+ "  }\n"
+ "}",
"function f(x) {\n"
+ "  switch (x) {\n"
+ "    case 1: x - 5;\n"
+ "    case 'asdf': x < 123; x < 'asdf'; break;\n"
+ "  }\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  switch (x) {\n"
+ "    case 1: x - 5;\n"
+ "    case 'asdf': break;\n"
+ "  }\n"
+ "}");
"function g(/** number */ x) { return 5; }\n"
+ "function f() {\n"
+ "  switch (3) { case g('asdf'): return 123; }\n"
+ "}",
checkNoWarnings("function f(/** number */ x, /** string */ y) {\n"
+ "  switch (y) { case x: ; }\n"
+ "}");
checkNoWarnings("function f(/** string */ y) {\n"
+ "  for (var x in { a: 1, b: 2 }) { y = x; }\n"
+ "  x = 234;\n"
+ "  return 123;\n"
+ "}");
typeCheck(
"function f(y) {\n"
+ "  var z = x + 234;\n"
+ "  for (var x in { a: 1, b: 2 }) {}\n"
+ "  return 123;\n"
+ "}",
"function f(/** number */ y) {\n"
+ "  for (var x in { a: 1, b: 2 }) { y = x; }\n"
+ "}",
typeCheck("for (var x in 123) ;", NewTypeInference.FORIN_EXPECTS_OBJECT);
"function f(/** undefined */ y) {\n"
+ "  var x;\n"
+ "  for (x in { a: 1, b: 2 }) { y = x; }\n"
+ "}",
checkNoWarnings("function f(/** { a: number } */ obj) {\n"
+ "  if ('p' in obj) {\n"
+ "    return obj.p;\n"
+ "  }\n"
+ "}\n"
+ "f({ a: 123 });");
typeCheck(
"function f(/** { a: number } */ obj) {\n"
+ "  if (!('p' in obj)) {\n"
+ "    return obj.p;\n"
+ "  }\n"
+ "}",
"function f(x, y) {\n"
+ "  x < y;\n"
+ "  [y - 5];\n"
+ "}\n"
+ "f('asdf', 123);",
"var a = [1,2,3]; a['str'];", NewTypeInference.NON_NUMERIC_ARRAY_INDEX);
"function f(/** !Array<number> */ arr, i) {\n"
+ "  arr[i];\n"
+ "}\n"
+ "f([1, 2, 3], 'str');",
checkNoWarnings("function f() { return {}; }\n"
+ "f().x = 123;");
checkNoWarnings("function f() { return {}; }\n"
+ "f().ns = {};");
"/** @constructor */\n"
+ "function Foo() { /** @type {number} */ this.a = 123; }\n"
+ "/** @return {!Foo} */\n"
+ "function retFoo() { return new Foo(); }\n"
+ "function f(cond) {\n"
+ "  (retFoo()).a = 'asdf';\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(new Foo).x += 123;",
"/** @constructor */\n"
+ "function Foo() { /** @type {number} */ this.a = 123; }\n"
+ "function f(cond, /** !Foo */ foo1) {\n"
+ "  var /** { a: number } */ x = { a: 321 };\n"
+ "  (cond ? foo1 : x).a = 'asdf';\n"
+ "}",
"function f(/** undefined */ n, pname) { n[pname] = 3; }",
public void testQuestionableUnionJsDoc() {
typeCheck(
"/** @type {string|?} */ var x;",
JSTypeCreatorFromJSDoc.BAD_JSDOC_ANNOTATION);
checkNoWarnings(""
+ "/**\n"
+ " * @return {T|S}\n"
+ " * @template T, S\n"
+ " */\n"
+ "function f(){};");
checkNoWarnings("/** @template T\n @param {T} x\n @return {T} */\n"
+ "function f(x) { return x; };");
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @param {T} x\n"
+ " * @extends {Bar<T>} // error, Bar is not templatized \n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {Foo<number, string>} x */\n"
+ "function f(x) {}",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
checkNoWarnings("/** @type {Array<number>} */ var x;");
checkNoWarnings("/** @type {Object<number>} */ var x;");
typeCheck(
"/** @template T\n@param {!T} x */ function f(x) {}",
JSTypeCreatorFromJSDoc.BAD_JSDOC_ANNOTATION);
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "id('str') - 5;",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f(123, 'asdf');",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {(T|null)} x\n"
+ " * @return {(T|number)}\n"
+ " */\n"
+ "function f(x) { return x === null ? 123 : x; }\n"
+ "/** @return {(null|undefined)} */ function g() { return null; }\n"
+ "var /** (number|undefined) */ y = f(g());");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {(T|number)} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "/** @return {*} */ function g() { return 1; }\n"
+ "f(g());",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "/** @return {*} */ function g() { return 1; }\n"
+ "id(g()) - 5;",
"/**\n"
+ " * @template T, U\n"
+ " * @param {T} x\n"
+ " * @param {U} y\n"
+ " * @return {U}\n"
+ " */\n"
+ "function f(x, y) { return y; }\n"
+ "f(10, 'asdf') - 5;",
"function g(x) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f(x, 5);\n"
+ "}\n"
+ "g('asdf');",
checkNoWarnings("function g(/** ? */ x) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {(T|number)} x\n"
+ "   */\n"
+ "  function f(x) {}\n"
+ "  f(x)\n"
+ "}");
checkNoWarnings("function g(x) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @return {T}\n"
+ "   */\n"
+ "  function f(x) { return x; }\n"
+ "  f(x) - 5;\n"
+ "  x = 'asdf';\n"
+ "}\n"
+ "g('asdf');");
"/**\n"
+ " * @template T\n"
+ " * @param {(T|number)} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "f(123);",
"/**\n"
+ " * @template T\n"
+ " * @param {(T|null)} x\n"
+ " * @param {(T|number)} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f(null, 'str');",
"/** @constructor */ function Foo(){};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {(T|Foo)} x\n"
+ " * @param {(T|number)} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f(new Foo(), 'str');",
"/**\n"
+ " * @template T\n"
+ " * @param {function(T):T} f\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function apply(f, x) { return f(x); }\n"
+ "/** @type {string} */"
+ "var out;"
+ "var result = apply(function(x){ out = x; return x; }, 0);",
NewTypeInference.NOT_UNIQUE_INSTANTIATION,
NewTypeInference.MISTYPED_ASSIGN_RHS));
"/** @template T */\n"
+ "function f(/** T */ x, /** T */ y) {}\n"
+ "f(1, 'str');",
"/** @template T */\n"
+ "function /** T */ f(/** T */ x) { return x; }\n"
+ "f('str') - 5;",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  /** @constructor */\n"
+ "  function Foo() {\n"
+ "    /** @type {T} */\n"
+ "    this.prop = x;\n"
+ "  }\n"
+ "  return (new Foo()).prop;\n"
+ "}\n"
+ "f('asdf') - 5;",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {*} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "f(123);");
checkNoWarnings("/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @template U\n"
+ " * @param {function(U)} x\n"
+ " */\n"
+ "Foo.prototype.f = function(x) { this.f(x); };");
"/** @constructor */ function Foo(){};\n"
+ "/** @constructor */ function Bar(){};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "var /** Bar */ x = id(new Foo);",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "id({}) - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "var /** (number|string) */ x = id('str');");
typeCheck(
"function f(/** * */ a, /** string */ b) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f(a, b);\n"
+ "}",
checkNoWarnings("function f(/** string */ b) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f({p:5, r:'str'}, {p:20, r:b});\n"
+ "}");
typeCheck(
"function f(/** string */ b) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f({r:'str'}, {p:20, r:b});\n"
+ "}",
"function g(x) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  var /** boolean */ y = true;\n"
+ "  f(x, y);\n"
+ "}\n"
+ "g('str');",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f(123, 'asdf');",
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {Foo<T>} x\n"
+ " */\n"
+ "function takesFoo(x) {}\n"
+ "takesFoo(undefined);",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " */\n"
+ "function g(x) { f(x); }");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  if (x === undefined) {\n"
+ "    throw new Error('');\n"
+ "  }\n"
+ "  return x;\n"
+ "}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function g(x) { return f(x); }\n"
+ "g(123) - 5;");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  if (x === undefined) {\n"
+ "    throw new Error('');\n"
+ "  }\n"
+ "  return x;\n"
+ "}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T|undefined} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function g(x) { return f(x); }\n"
+ "g(123) < 'asdf';",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("function f(b) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f({p:5, r:'str'}, {p:20, r:b});\n"
+ "}");
checkNoWarnings("function f(b) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f({p:20, r:b}, {p:5, r:'str'});\n"
+ "}");
typeCheck(
"function g(x) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  f({prop: x}, {prop: 5});\n"
+ "}\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function g(x, cond) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  var y = cond ? {prop: 'str'} : {prop: 5};\n"
+ "  f({prop: x}, y);\n"
+ "}\n"
+ "g({}, true);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function g(x, cond) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {T} x\n"
+ "   * @param {T} y\n"
+ "   */\n"
+ "  function f(x, y) {}\n"
+ "  /** @type {{prop : (string | number)}} */\n"
+ "  var y = cond ? {prop: 'str'} : {prop: 5};\n"
+ "  f({prop: x}, y);\n"
+ "}\n"
+ "g({}, true);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {{a: number, b: T}} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x.b; }\n"
+ "f({a: 1, b: 'asdf'}) - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x.b; }\n"
+ "f({b: 'asdf'}) - 5;",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @type {function(number)} */\n"
+ "function g(x) {}\n"
+ "/** @type {function(?)} */\n"
+ "function h(x) {}\n"
+ "f(g, h);");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @type {function(number)} */\n"
+ "function g(x) {}\n"
+ "/** @type {function(string)} */\n"
+ "function h(x) {}\n"
+ "f(g, h);",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @type {function(number)} */\n"
+ "function g(x) {}\n"
+ "/** @type {function(?, string)} */\n"
+ "function h(x, y) {}\n"
+ "f(g, h);",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @type {function(number=, ...[string])} */\n"
+ "function g(x) {}\n"
+ "/** @type {function(number=, ...[?])} */\n"
+ "function h(x) {}\n"
+ "f(g, h);");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @type {function(number):number} */\n"
+ "function g(x) { return 1; }\n"
+ "/** @type {function(?):string} */\n"
+ "function h(x) { return ''; }\n"
+ "f(g, h);",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @type {function(new:Foo)} */\n"
+ "function g() {}\n"
+ "/** @type {function(new:Foo)} */\n"
+ "function h() {}\n"
+ "f(g, h);");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "/** @type {function(this:Foo)} */\n"
+ "function g() {}\n"
+ "/** @type {function(this:Bar)} */\n"
+ "function h() {}\n"
+ "f(g, h);",
"/**\n"
+ " * @template U\n"
+ " * @param {U} y\n"
+ " */\n"
+ "function g(y) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {{a: U, b: T}} x\n"
+ "   * @return {T}\n"
+ "   */\n"
+ "  function f(x) { return x.b; }\n"
+ "  f({a: y, b: 'asdf'}) - 5;\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/**\n"
+ " * @template U\n"
+ " * @param {U} y\n"
+ " */\n"
+ "function g(y) {\n"
+ "  /**\n"
+ "   * @template T\n"
+ "   * @param {{b: T}} x\n"
+ "   * @return {T}\n"
+ "   */\n"
+ "  function f(x) { return x.b; }\n"
+ "  f({b: y}) - 5;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {function(T):T} fun\n"
+ " */\n"
+ "function f(x, fun) {}\n"
+ "function g(x) { return x - 5; }\n"
+ "f('asdf', g);",
"/**\n"
+ " * @template T\n"
+ " * @param {function(T):number} fun\n"
+ " */\n"
+ "function f(fun) {}\n"
+ "function g(x) { return 'asdf'; }\n"
+ "f(g);",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {function(T=)} fun\n"
+ " */\n"
+ "function f(fun) {}\n"
+ "/** @param{string=} x */ function g(x) {}\n"
+ "f(g);");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {function(... [T])} fun\n"
+ " */\n"
+ "function f(fun) {}\n"
+ "/** @param {...number} var_args */ function g(var_args) {}\n"
+ "f(g);");
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function id(x) { return x; }\n"
+ "function g() {\n"
+ "  id('asdf') - 5;\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "function g() {\n"
+ "  f('asdf', 'asdf');\n"
+ "}",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "function g() {\n"
+ "  f(123, 'asdf');\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  x - 5;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {{ a: T }} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  x.a - 5;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {function(T):T} fun\n"
+ " */\n"
+ "function f(x, fun) {\n"
+ "  fun(x) - 5;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  return 5;\n"
+ "}",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  var /** ? */ y = x;\n"
+ "}");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {(T|number)}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  var y;\n"
+ "  if (1 < 2) {\n"
+ "    y = x;\n"
+ "  } else {\n"
+ "    y = 123;\n"
+ "  }\n"
+ "  return y;\n"
+ "}");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {(T|number)}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  var y;\n"
+ "  if (1 < 2) {\n"
+ "    y = x;\n"
+ "  } else {\n"
+ "    y = 123;\n"
+ "  }\n"
+ "  return y;\n"
+ "}\n"
+ "f(123) - 5;");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {(T|number)}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  var y;\n"
+ "  if (1 < 2) {\n"
+ "    y = x;\n"
+ "  } else {\n"
+ "    y = 123;\n"
+ "  }\n"
+ "  return y;\n"
+ "}\n"
+ "var /** (number|boolean) */ z = f('asdf');",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  var /** T */ y = x;\n"
+ "  y - 5;\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/**\n"
+ " * @template T, U\n"
+ " * @param {T} x\n"
+ " * @param {U} y\n"
+ " */\n"
+ "function f(x, y) {\n"
+ "  x = y;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {T} y */\n"
+ "Foo.prototype.bar = function(y) {}\n"
+ "new Foo('str').bar(5)",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @type {function(T)} y */\n"
+ "Foo.prototype.bar = function(y) {};\n"
+ "new Foo('str').bar(5)",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) { /** @type {T} */ this.x = x; }\n"
+ "/** @return {T} */\n"
+ "Foo.prototype.bar = function() { return this.x; };\n"
+ "new Foo('str').bar() - 5",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) { /** @type {T} */ this.x = x; }\n"
+ "/** @type {function() : T} */\n"
+ "Foo.prototype.bar = function() { return this.x; };\n"
+ "new Foo('str').bar() - 5",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @type {function(this:Foo<T>, T)} */\n"
+ "Foo.prototype.bar = function(x) { this.x = x; };\n"
+ "new Foo('str').bar(5)",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {!Foo<number>} x */\n"
+ "function f(x) {}\n"
+ "f(new Foo(7));");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {Foo<number>} x */\n"
+ "function f(x) {}\n"
+ "f(new Foo('str'));",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {T} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "/** @param {!Foo<number>} x */\n"
+ "function f(x) { x.method('asdf'); }",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @param {T} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "var /** @type {Foo<string>} */ foo = null;\n"
+ "foo.method('asdf');",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
public void testLooserCheckingForInferredProperties() {
checkNoWarnings("/** @constructor */\n"
+ "function Foo(x) { this.prop = x; }\n"
+ "function f(/** !Foo */ obj) {\n"
+ "  obj.prop = true ? 1 : 'asdf';\n"
+ "  obj.prop - 5;\n"
+ "}");
checkNoWarnings("/** @constructor */\n"
+ "function Foo(x) { this.prop = x; }\n"
+ "function f(/** !Foo */ obj) {\n"
+ "  if (!(typeof obj.prop == 'number')) {\n"
+ "    obj.prop < 'asdf';\n"
+ "  }\n"
+ "}");
typeCheck(
"/** @constructor */\n"
+ "function Foo(x) { this.prop = x; }\n"
+ "function f(/** !Foo */ obj) {\n"
+ "  obj.prop = true ? 1 : 'asdf';\n"
+ "  obj.prop - 5;\n"
+ "  obj.prop < 'asdf';\n"
+ "}",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"function /** string */ f(/** ?number */ x) {\n"
+ "  var o = { prop: 'str' };\n"
+ "  if (x) {\n"
+ "    o.prop = x;\n"
+ "  }\n"
+ "  return o.prop;\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/** @constructor @implements {I<number>} */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.bar = function(x) {};\n"
+ "(new Foo).bar('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/** @constructor @implements {I<number>} */\n"
+ "function Foo() {}\n"
+ "/** @override */\n"
+ "Foo.prototype.bar = function(x) {};\n"
+ "new Foo().bar('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/**\n"
+ " * @template U\n"
+ " * @constructor\n"
+ " * @implements {I<U>}\n"
+ " * @param {U} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "Foo.prototype.bar = function(x) {};{}\n"
+ "new Foo(5).bar('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/** @constructor @implements {I<number>} */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.bar = function(x) {};\n"
+ "/** @param {I<string>} x */ function f(x) {};\n"
+ "f(new Foo());",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/** @constructor @implements {I<number>} */\n"
+ "function Foo() {}\n"
+ "/** @param {string} x */\n"
+ "Foo.prototype.bar = function(x) {};",
"/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/** @param {T} x */\n"
+ "I.prototype.bar = function(x) {};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor @implements {I<number>}\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {T} x */\n"
+ "Foo.prototype.bar = function(x) {};",
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @param {T} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @extends {Foo<T>}\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Bar(x) {}\n"
+ "/** @param {number} x */\n"
+ "Bar.prototype.method = function(x) {};",
GlobalTypeInfo.INVALID_PROP_OVERRIDE);
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " */\n"
+ "function High() {}\n"
+ "/** @param {Low<T>} x */\n"
+ "High.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @extends {High<T>}\n"
+ " */\n"
+ "function Low() {}");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " */\n"
+ "function High() {}\n"
+ "/** @param {Low<number>} x */\n"
+ "High.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @extends {High<T>}\n"
+ " */\n"
+ "function Low() {}");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " */\n"
+ "function High() {}\n"
+ "/** @param {Low<T>} x */ // error, low is not templatized\n"
+ "High.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @extends {High<number>}\n"
+ " */\n"
+ "function Low() {}",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @implements {I<T>}\n"
+ " * @extends {Bar}\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {I<number>}\n"
+ " */\n"
+ "function Bar(x) {}");
checkNoWarnings("/**\n"
+ " * @interface\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @constructor @implements {Foo<number>} */\n"
+ "function A() {}\n"
+ "var /** Foo<number> */ x = new A();");
public void testGenericsSubtyping() {
typeCheck(
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {number} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){};",
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {?} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){};",
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {*} x\n"
+ " * @param {*} y\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {?} x\n"
+ " * @param {?} y\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {?} x\n"
+ " * @return {?}\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {*} x\n"
+ " * @return {?}\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };");
typeCheck(
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {*} x\n"
+ " * @return {*}\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };",
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {number} x\n"
+ " * @return {number}\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };",
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {?} x\n"
+ " * @return {*}\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };",
typeCheck(
"/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {function(T, T) : boolean} x\n"
+ " */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @param {function(number, number) : boolean} x\n"
+ " */\n"
+ "Child.prototype.method = function(x){ return x; };",
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "/** @param {function(number, number)} x */\n"
+ "function g(x) {}\n"
+ "g(f);");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "/** @param {function()} x */\n"
+ "function g(x) {}\n"
+ "g(f);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/** @interface */\n"
+ "function Parent() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "Parent.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {Parent}\n"
+ " */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template U\n"
+ " * @param {U} x\n"
+ " */\n"
+ "Child.prototype.method = function(x) {};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/** @param {string} x */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "Child.prototype.method = function(x){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/** @param {*} x */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "Child.prototype.method = function(x){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/** @param {?} x */\n"
+ "Parent.prototype.method = function(x){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "Child.prototype.method = function(x){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @param {string} x\n"
+ " * @param {number} y\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){};");
checkNoWarnings("/** @interface */ function Parent() {}\n"
+ "/**\n"
+ " * @template A, B\n"
+ " * @param {A} x\n"
+ " * @param {B} y\n"
+ " * @return {A}\n"
+ " */\n"
+ "Parent.prototype.method = function(x, y){};\n"
+ "/** @constructor @implements {Parent} */\n"
+ "function Child() {}\n"
+ "/**\n"
+ " * @template A, B\n"
+ " * @param {A} x\n"
+ " * @param {B} y\n"
+ " * @return {B}\n"
+ " */\n"
+ "Child.prototype.method = function(x, y){ return y; };");
public void testGenericsVariance() {
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Array<Foo> */ a = [new Bar];");
typeCheck(
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Array<Bar> */ a = [new Foo];",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings(
"/** @constructor @param {T} x @template T */ function Gen(x){}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Gen<Foo> */ a = new Gen(new Bar);");
typeCheck(
"/** @constructor @param {T} x @template T */ function Gen(x){}\n"
+ "/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Gen<Bar> */ a = new Gen(new Foo);",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @const */ var x = [];", GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE);
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "/** @const */ var x = [new Foo, new Bar];",
checkNoWarnings("var arr = [];\n"
+ "var /** Array<string> */ as = arr;");
"var arr = [1, 2, 3];\n"
+ "var /** Array<string> */ as = arr;",
"/** @constructor */ function Foo() {}\n"
+ "var /** Array<string> */ a = [new Foo, new Foo];",
checkNoWarnings("/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Array<Foo> */ a = [new Foo, new Bar];");
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "var /** Array<Bar> */ a = [new Foo, new Bar];",
"/** @const */ var x = [1, 2, 3];\n"
+ "function g() { var /** Array<string> */ a = x; }",
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor @extends {Foo} */ function Bar() {}\n"
+ "/** @const */ var x = [new Foo, new Foo];\n"
+ "function g() { var /** Array<Bar> */ a = x; }",
public void testSpecializedInstanceofCantGoToBottom() {
checkNoWarnings("/** @const */ var ns = {};\n"
+ "ns.f = function() {};\n"
+ "if (ns.f instanceof Function) {}");
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "/** @const */ var ns = {};\n"
+ "ns.f = new Foo;\n"
+ "if (ns.f instanceof Foo) {}");
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "/** @constructor */ function Bar(){}\n"
+ "/** @const */ var ns = {};\n"
+ "ns.f = new Foo;\n"
+ "if (ns.f instanceof Bar) {}");
"/** @type {Array<string>} */\n"
+ "var arr = ['str'];\n"
+ "arr[0]++;",
"var arr = ['str'];\n"
+ "arr[0]++;",
"function foo (/** Array<string> */ a) {}\n"
+ "/** @type {Array<number>} */\n"
+ "var b = [1];\n"
+ "foo(b);",
"function foo (/** Array<string> */ a) {}\n"
+ "foo([1]);",
"/** @type {!Array<number>} */\n"
+ "var arr = [1, 2, 3];\n"
+ "arr[0] = 'str';",
checkNoWarnings("/** @type {!Array<number>} */\n"
+ "var arr = [1, 2, 3];\n"
+ "arr['0'] = 'str';");
"/** @type {Array<number>} */\n"
+ "var arr = [1, 2, 3];\n"
+ "arr[0] = 'str';",
"function f(/** Array<number> */ arr) {\n"
+ "  arr[0] = 'str';\n"
+ "}",
NewTypeInference.NULLABLE_DEREFERENCE);
typeCheck(
"/** @const */\n"
+ "var arr = [1, 2, 3];\n"
+ "arr[0] = 'str';",
checkNoWarnings("var arr = [1, 2, 3];\n"
+ "arr[0] = 'str';");
checkNoWarnings("/** @constructor */ function Super(){}\n"
+ "/** @constructor @extends {Super} */ function Sub(){}\n"
+ "/** @type {!Array<Super>} */ var arr = [new Sub];\n"
+ "arr[0] = new Super;");
"/** @type {Array<number>} */ var arr = [];\n"
+ "arr[0] = 'str';",
"/** @type {Array<number>} */ var arr = [];\n"
+ "(function (/** Array<string> */ x){})(arr);",
"function /** string */ f(/** !Array<number> */ arr) {\n"
+ "  return arr[0];\n"
+ "}",
checkNoWarnings("var arr = [];\n"
+ "arr[0] = 5;\n"
+ "var /** Array<string> */ as = arr;");
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x; }\n"
+ "/** @const */ var x = f(5);\n"
+ "function g() { var /** null */ n = x; }",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @constructor\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @const */ var foo_str = new Foo('str');\n"
+ "function g() { var /** !Foo<number> */ foo_num = foo_str; }",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x; }\n"
+ "/** @const */ var x = f(f ? 'str' : 5);",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x, y) { return true ? y : x; }\n"
+ "/** @const */ var x = f(5, 'str');"
+ "function g() { var /** null */ n = x; }",
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x; }\n"
+ "/** @const */\n"
+ "var y = f(1, 2);",
ImmutableList.of(
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,
TypeCheck.WRONG_ARGUMENT_COUNT));
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(x) { return x; }\n"
+ "/** @const */\n"
+ "var y = f();",
ImmutableList.of(
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,
TypeCheck.WRONG_ARGUMENT_COUNT));
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {Bar<T>} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Bar(x) {}\n"
+ "/** @param {Foo<T>} x */\n"
+ "Bar.prototype.method = function(x) {};\n"
+ "(new Foo(123)).method(new Bar('asdf'));",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @constructor\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/** @param {Foo<Foo<T>>} x */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "(new Foo(123)).method(new Foo(new Foo('asdf')));",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface\n @template T */function A() {};"
+ "/** @return {T} */A.prototype.foo = function() {};"
+ "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
+ "/** @constructor\n @implements {B<string>} */function C() {};"
+ "/** @return {string}\n @override */\n"
+ "C.prototype.foo = function() { return 123; };",
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @template U\n"
+ " * @param {U} x\n"
+ " * @return {U}\n"
+ " */\n"
+ "Foo.prototype.method = function(x) { return x; };\n"
+ "(new Foo(123)).method('asdf') - 5;",
"/**\n"
+ " * @constructor\n"
+ " * @template T, U\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {!Foo<T>} x\n"
+ " */\n"
+ "function fn(x) {}\n"
+ "fn(new Foo('asdf'));",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template S, T\n"
+ " * @param {S} x\n"
+ " */\n"
+ "function Foo(x) {\n"
+ "  /** @type {S} */ this.prop = x;\n"
+ "}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {!Foo<T>} x\n"
+ " * @return {T}\n"
+ " */\n"
+ "function fn(x) { return x.prop; }\n"
+ "fn(new Foo('asdf')) - 5;",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION,
typeCheck("(/** @type {number} */ ('asdf'));", TypeValidator.INVALID_CAST);
checkNoWarnings("function f(/** (number|string) */ x) {\n"
+ "  var y = /** @type {number} */ (x);\n"
+ "}");
"/** @interface */\n"
+ "function Intf() {}\n"
+ "/** @param {(number|string)} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {Intf}\n"
+ " */\n"
+ "function C() {}\n"
+ "/** @override */\n"
+ "C.prototype.method = function (x) { x - 1; };\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @interface */\n"
+ "function Intf() {}\n"
+ "/** @param {(number|string)} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @implements {Intf}\n"
+ " */\n"
+ "function C() {}\n"
+ "/** @inheritDoc */\n"
+ "C.prototype.method = function (x) { x - 1; };\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @override */\n"
+ "Foo.prototype.method = function() {};",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @inheritDoc */\n"
+ "Foo.prototype.method = function() {};",
public void testOverrideNoInitializer() {
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @param {number} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/** @interface @extends {Intf} */\n"
+ "function Subintf() {}\n"
+ "/** @override */\n"
+ "Subintf.prototype.method;\n"
+ "function f(/** !Subintf */ x) { x.method('asdf'); }",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @param {number} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/** @interface @extends {Intf} */\n"
+ "function Subintf() {}\n"
+ "Subintf.prototype.method;\n"
+ "function f(/** !Subintf */ x) { x.method('asdf'); }",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @param {number} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/** @constructor  @implements {Intf} */\n"
+ "function C() {}\n"
+ "/** @override */\n"
+ "C.prototype.method = (function(){ return function(x){}; })();\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @param {number} x */\n"
+ "Intf.prototype.method = function(x) {};\n"
+ "/** @constructor  @implements {Intf} */\n"
+ "function C() {}\n"
+ "C.prototype.method = (function(){ return function(x){}; })();\n"
+ "(new C).method('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @type {string} */\n"
+ "Intf.prototype.s = 'str';\n"
+ "/** @constructor @implements {Intf} */\n"
+ "function C() {}\n"
+ "/** @override */\n"
+ "C.prototype.s = 'str2';\n"
+ "(new C).s - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @type {string} */\n"
+ "Intf.prototype.s = 'str';\n"
+ "/** @constructor @implements {Intf} */\n"
+ "function C() {}\n"
+ "/** @type {number} @override */\n"
+ "C.prototype.s = 72;",
GlobalTypeInfo.INVALID_PROP_OVERRIDE);
typeCheck(
"/** @interface */ function Intf() {}\n"
+ "/** @type {string} */\n"
+ "Intf.prototype.s = 'str';\n"
+ "/** @constructor @implements {Intf} */\n"
+ "function C() {}\n"
+ "/** @override */\n"
+ "C.prototype.s = 72;",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("/** @type {Function} */ function topFun() {}\n"
+ "topFun(1);");
checkNoWarnings("function f(/** Function */ fun) {}\n"
+ "f(function g(x) { return x - 5; });");
checkNoWarnings("function f(/** !Function */ fun) { [] instanceof fun; }");
checkNoWarnings("function g() { throw 1; }\n"
+ "function f() {\n"
+ "  try {\n"
+ "    if (g()) {}\n"
+ "  } catch (e) {}\n"
+ "};");
public void testGenericInterfaceDoesntCrash() {
checkNoWarnings("/** @const */ var ns = {};\n"
+ "/** @interface @template T */\n"
+ "ns.Interface = function(){}");
public void testGetpropOnTopDoesntCrash() {
"/** @constructor */ function Foo() {};\n"
+ "/** @type {*} */ Foo.prototype.stuff;\n"
+ "function f(/** !Foo */ foo, x) {\n"
+ "  (foo.stuff.prop = x) || false;\n"
+ "};",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
typeCheck(
"/** @constructor */ function Foo() {};\n"
+ "/** @type {*} */ Foo.prototype.stuff;\n"
+ "function f(/** Foo */ foo) {\n"
+ "  foo.stuff.prop || false;\n"
+ "};",
NewTypeInference.NULLABLE_DEREFERENCE);
checkNoWarnings("/** @interface @template Z */\n"
+ "function Foo(){}\n"
+ "Foo.prototype.getCount = function /** number */ (){};\n"
+ "/**\n"
+ " * @constructor @implements {Foo<T>}\n"
+ " * @template T\n"
+ " */\n"
+ "function Bar(){}\n"
+ "Bar.prototype.getCount = function /** number */ (){};");
checkNoWarnings("function f() {\n"
+ "   throw 'Error';\n"
+ "   return 5;\n"
+ "}");
typeCheck(
"/** @interface */ function Foo() {}\n"
+ "function reqFoo(/** Foo */ foo) {};\n"
+ "/** @param {Function} fun */\n"
+ "function f(fun) {\n"
+ "    reqFoo(fun);\n"
+ "}",
typeCheck(
"/** @constructor */ function Foo(){}\n"
+ "function f(x) {\n"
+ "  if (typeof x == 'function') {\n"
+ "    var /** !Foo */ y = x;\n"
+ "  }\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"function g() {}\n"
+ "function f() {\n"
+ "  g();\n"
+ "  return g.prop;\n"
+ "}",
checkNoWarnings("function f(foo, i, j) {\n"
+ "  foo.array[i][j] = 5;\n"
+ "}");
"/** @interface */ function I(){}\n"
+ "/** @type {function(NonExistentClass)} */\n"
+ "I.prototype.method;",
"var obj = null;\n"
+ "if (obj) obj.prop += 7;",
public void testUnannotatedFunctionSummaryDoesntCrash() {
checkNoWarnings(
DEFAULT_EXTERNS + "/** @interface */\n"
+ "var IThenable = function() {};\n"
+ "IThenable.prototype.then = function(onFulfilled) {};\n"
+ "/** @constructor @implements {IThenable} */\n"
+ "var Promise = function() {};\n"
+ "/**\n"
+ " * @param {function():RESULT} onFulfilled\n"
+ " * @template RESULT\n"
+ " */\n"
+ "Promise.prototype.then = function(onFulfilled) {};",
"var /** !Promise */ p;\n"
+ "function f(unused) {\n"
+ "  function g(){ return 5; }\n"
+ "  p.then(g);\n"
+ "}");
typeCheck(
DEFAULT_EXTERNS + "/** @interface */\n"
+ "var IThenable = function() {};\n"
+ "IThenable.prototype.then = function(onFulfilled) {};\n"
+ "/** @constructor @implements {IThenable} */\n"
+ "var Promise = function() {};\n"
+ "/**\n"
+ " * @param {function():RESULT} onFulfilled\n"
+ " * @return {RESULT}\n"
+ " * @template RESULT\n"
+ " */\n"
+ "Promise.prototype.then = function(onFulfilled) {};",
"var /** !Promise */ p;\n"
+ "function f(unused) {\n"
+ "  function g(){ return 5; }\n"
+ "  var /** null */ n = p.then(g);\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "function reqFoo(/** Foo */ x) {}\n"
+ "function f(x) {\n"
+ "   x = null;\n"
+ "   reqFoo(x);\n"
+ "}");
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "function f() {\n"
+ "  if (true) {\n"
+ "    function g() { new Foo; }\n"
+ "    g();\n"
+ "  }\n"
+ "}");
"/** @constructor */ function Function(){}\n"
+ "/** @constructor */ function Array(){}",
"function f(/** !Array */ arr) {\n"
+ "  var newarr = [];\n"
+ "  newarr[0] = arr[0];\n"
+ "  newarr[0].prop1 = newarr[0].prop2;\n"
+ "};");
checkNoWarnings("/** @constructor @template T */ function Foo(){}\n"
+ "function f(/** !Foo<?> */ f) {\n"
+ "  if (f instanceof Foo) return true;\n"
+ "};");
typeCheck(
"/** @const */ var ns = ns || {};\n"
+ "ns.fun = function(name) {};\n"
+ "ns.fun = ns.fun || {};\n"
+ "ns.fun.get = function(/** string */ name) {};",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @const */ var ns = ns || {};\n"
+ "ns.fun = function(name) {};\n"
+ "ns.fun.get = function(/** string */ name) {};\n"
+ "ns.fun = ns.fun || {};",
NewTypeInference.MISTYPED_ASSIGN_RHS);
"/** @enum {Array<number>} */\n"
+ "var FooEnum = {\n"
+ "  BAR: [5]\n"
+ "};\n"
+ "/** @param {FooEnum} x */\n"
+ "function f(x) {\n"
+ "    var y = x[0];\n"
+ "};",
typeCheck(
"var ns = {};\n"
+ "function f() {\n"
+ "  /** @enum {number} */ var EnumType = ns;\n"
+ "}",
GlobalTypeInfo.MALFORMED_ENUM);
"/** @constructor */ function Foo() {\n"
+ " /** @type {!Object} */ this.obj = {arr : []}\n"
+ "}\n"
+ "Foo.prototype.bar = function() {\n"
+ " this.obj.arr.length = 0;\n"
+ "}",
"/** @constructor */ function Foo() {\n"
+ " /** @type {!Object} */ this.obj = {}\n"
+ "}\n"
+ "Foo.prototype.bar = function() {\n"
+ " this.obj.prop1.prop2 = 0;\n"
+ "}",
"/** @constructor */ function Foo(){}\n"
+ "Foo.prototype.method = function(){};\n"
+ "var f = function() {\n"
+ "   Foo.prototype.method = function(){};\n"
+ "}",
checkNoWarnings("function f(x) {}\n"
+ "function g(value) {\n"
+ "  if (typeof value == 'function') {\n"
+ "    f(value);\n"
+ "  }\n"
+ "}");
checkNoWarnings("/** @constructor */ function Obj(){}\n"
+ "/** @constructor */ var Foo = function() {\n"
+ "    /** @private {Obj} */ this.obj;\n"
+ "};\n"
+ "Foo.prototype.update = function() {\n"
+ "    if (!this.obj) {}\n"
+ "};");
typeCheck(
"/** @constructor */ function Obj(){}\n"
+ "/** @constructor */ var Foo = function() {\n"
+ "    /** @private {Obj} */ this.obj;\n"
+ "};\n"
+ "Foo.prototype.update = function() {\n"
+ "    if (!this.obj.size) {}\n"
+ "};",
NewTypeInference.NULLABLE_DEREFERENCE);
checkNoWarnings("/** @constructor */\n"
+ "var Foo = function() {};\n"
+ "/** @param {function(!Foo)} fooFun */\n"
+ "var reqFooFun = function(fooFun) {};\n"
+ "/** @type {function(!Foo)} */\n"
+ "var declaredFooFun;\n"
+ "function f(opt_fooFun) {\n"
+ "  reqFooFun(opt_fooFun);\n"
+ "  var fooFun = opt_fooFun || declaredFooFun;\n"
+ "  reqFooFun(fooFun);\n"
+ "};");
checkNoWarnings("var /** @type {function(number)} */ f;\n"
+ "f = (function(x) {\n"
+ "  x(1, 2);\n"
+ "  return x;\n"
+ "})(function(x, y) {});");
checkNoWarnings("/** @constructor */ function Foo(){ this.prop = 5; }\n"
+ "/** @constructor */ function Bar(){}\n"
+ "/** @param {function(!Foo)} func */\n"
+ "Bar.prototype.forEach = function(func) {\n"
+ "  this.forEach(function(looseObj) { looseObj.prop; });\n"
+ "};");
checkNoWarnings("function f(/** number */ n) {\n"
+ "  if (typeof n == 'string') {\n"
+ "    return { 'First': n, 'Second': 5 };\n"
+ "  }\n"
+ "};");
"/** @constructor */ function Foo(){}\n"
+ "/** @constructor */ Foo = function(){};",
checkNoWarnings("/** @const */ var ns = {};\n"
+ "/** @public */ ns.prop;");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {!Array<T>} arr\n"
+ " * @return {T}\n"
+ " */\n"
+ "function f(arr) { return arr[0]; }\n"
+ "f([1,2,3]);");
checkNoWarnings(CLOSURE_BASE + "function f(/** !Function */ func) {};\n"
+ "function g(obj) {\n"
+ "    if (goog.isFunction(obj)) {\n"
+ "      f(obj);\n"
+ "    }\n"
+ "};");
checkNoWarnings("function f(/** !Function */ func) {};\n"
+ "function g(obj) {\n"
+ "    if (typeof obj === 'function') {\n"
+ "      f(obj);\n"
+ "    }\n"
+ "};");
checkNoWarnings("/** @param {function(T)} fn @param {T} x @template T */\n"
+ "function reqGenFun(fn, x) {};\n"
+ "function g(obj, str) {\n"
+ "  var member = obj[str];\n"
+ "  if (typeof member === 'function') {\n"
+ "    reqGenFun(member, str);\n"
+ "  }\n"
+ "};");
public void testGetpropOnPossiblyInexistentPropertyDoesntCrash() {
typeCheck(
"/** @constructor */ function Foo(){};\n"
+ "function f() {\n"
+ "  var obj = 3 ? new Foo : { prop : { subprop : 'str'}};\n"
+ "  obj.prop.subprop = 'str';\n"
+ "};",
NewTypeInference.POSSIBLY_INEXISTENT_PROPERTY);
checkNoWarnings("/** @constructor */ var X = function() {};\n"
+ "var f = function(ctor) {\n"
+ "  /** @type {function(new: X)} */\n"
+ "  function InstantiableCtor() {};\n"
+ "  InstantiableCtor.prototype = ctor.prototype;\n"
+ "}");
checkNoWarnings("/** @type {!Function} */ function abstractMethod(){}\n"
+ "/** @interface */ function I() {}\n"
+ "/** @param {string} opt_str */\n"
+ "I.prototype.done = abstractMethod;\n"
+ "/** @implements {I} @constructor */ function Foo() {}\n"
+ "/** @override */ Foo.prototype.done = function(opt_str) {}\n"
+ "/** @param {I} stats */ function f(stats) {}\n"
+ "function g() {\n"
+ "  var x = new Foo();\n"
+ "  f(x);\n"
+ "  x.done();\n"
+ "}");
public void testThisReferenceUsedGenerically() {
checkNoWarnings("/** @constructor @template T */\n"
+ "var Foo = function(t) {\n"
+ "  /** @type {Foo<T>} */\n"
+ "  this.parent_ = null;\n"
+ "}\n"
+ "Foo.prototype.method = function() {\n"
+ "  var p = this;\n"
+ "  while (p != null) p = p.parent_;\n"
+ "}");
checkNoWarnings("/** @constructor @template T */\n"
+ "var Foo = function(t) {\n"
+ "  /** @type {Foo<T>} */\n"
+ "  var p = this;\n"
+ "}");
checkNoWarnings("/** @constructor @template VALUE */\n"
+ "var Grandparent = function() {};\n"
+ "/** @constructor @extends {Grandparent<number>} */\n"
+ "var Parent = function(){};\n"
+ "/** @constructor @extends {Parent} */ function Child(){}");
typeCheck(
"/** @constructor @template VALUE */\n"
+ "var Grandparent = function() {};\n"
+ "/** @constructor @extends {Grandparent} */\n"
+ "var Parent = function(){};\n"
+ "/** @constructor @extends {Parent} */ function Child(){}",
JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
checkNoWarnings("/** @interface */ function Foo(){}\n"
+ "/** @type {function(number)} */ Foo.prototype.bar;\n"
+ "/** @constructor @implements {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(x){}");
checkNoWarnings("/** @type {!Function} */\n"
+ "var g = function() { throw 0; };\n"
+ "/** @constructor */ function Foo(){}\n"
+ "/** @type {function(number)} */ Foo.prototype.bar = g;\n"
+ "/** @constructor @extends {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(x){}");
checkNoWarnings("/** @param {string} s */\n"
+ "var reqString = function(s) {};\n"
+ "/** @constructor */ function Foo(){}\n"
+ "/** @type {function(string)} */ Foo.prototype.bar = reqString;\n"
+ "/** @constructor @extends {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(x){}");
typeCheck(
"/** @param {string} s */\n"
+ "var reqString = function(s) {};\n"
+ "/** @constructor */ function Foo(){}\n"
+ "/** @type {function(number)} */ Foo.prototype.bar = reqString;\n"
+ "/** @constructor @extends {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(x){}",
checkNoWarnings("/** @constructor */ function Foo(){}\n"
+ "/** @type {Function} */ Foo.prototype.bar = null;\n"
+ "/** @constructor @extends {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(){}");
"/** @constructor */ function Foo(){}\n"
+ "/** @type {!Function} */ Foo.prototype.bar = null;\n"
+ "/** @constructor @extends {Foo} */ function Bar(){}\n"
+ "Bar.prototype.bar = function(){}",
checkNoWarnings("/** @interface */ function I(){}\n"
+ "/** @return {void} */\n"
+ "I.prototype.method;");
"/** @interface */\n"
+ "var Bar = function() {};\n"
+ "/** @type {Function} */\n"
+ "Bar.prototype.method;\n"
+ "/** @interface */\n"
+ "var Baz = function() {};\n"
+ "Baz.prototype.method = function() {};\n"
+ "/** @constructor */\n"
+ "var Foo = function() {};\n"
+ "/** @type {!Bar|!Baz} */\n"
+ "Foo.prototype.obj;\n"
+ "Foo.prototype.set = function() {\n"
+ "    this.obj.method = 5;\n"
+ "};",
"function f(/** { prop: number } */ obj, x) {\n"
+ " x < obj.prop;\n"
+ " obj.prop < 'str';\n"
+ " obj.prop = 123;\n"
+ " x = 123;\n"
+ "}\n"
+ "f({ prop: 123}, 123)",
checkNoWarnings("function f(/** { foo : { bar : string } } */ x) {\n"
+ "  x['foo.bar'] = 5;\n"
+ "}");
"var x = { '.' : 'str' };\n"
+ "x['.'] - 5",
"var lit = { /** @type {string} */ prop: 'str' };\n"
+ "lit.prop = 123;",
"var lit = { /** @type {(number|string)} */ prop: 'str' };\n"
+ "var /** string */ s = lit.prop;");
TypeCheck.NOT_CALLABLE, NewTypeInference.INVALID_OPERAND_TYPE));
"/** @return {number} */\n"
+ "var f = function rec() { return rec; };",
"/** @constructor @struct */ function Foo() { this.prop = 123; }\n"
+ "(new Foo).prop;");
"/** @constructor @struct */ function Foo() { this.prop = 123; }\n"
+ "(new Foo)['prop'];",
"/** @interface */ function Foo() {}\n"
+ "/** @type {number} */ Foo.prototype.prop;\n"
+ "function f(/** !Foo */ x) { x['prop']; }",
"/** @constructor @struct */ function Foo() {\n"
+ "  this.prop = 123;\n"
+ "  this['prop'] - 123;\n"
+ "}",
"/** @constructor @struct */ function Foo() { this.prop = 123; }\n"
+ "(new Foo)['prop'] = 123;",
"/** @constructor @struct */ function Foo() { this.prop = 123; }\n"
+ "function f(pname) { (new Foo)[pname] = 123; }",
"/** @constructor @struct */ function Foo() { this.prop = {}; }\n"
+ "(new Foo)['prop'].newprop = 123;",
"/** @constructor @struct */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "function f(cond) {\n"
+ "  var x;\n"
+ "  if (cond) {\n"
+ "    x = new Foo;\n"
+ "  }\n"
+ "  else {\n"
+ "    x = new Bar;\n"
+ "  }\n"
+ "  x['prop'] = 123;\n"
+ "}",
typeCheck("(/** @struct */ { 'prop' : 1 });", TypeCheck.ILLEGAL_OBJLIT_KEY);
"function f(cond) {\n"
+ "  var x;\n"
+ "  if (cond) {\n"
+ "    x = /** @struct */ { a: 1 };\n"
+ "  }\n"
+ "  else {\n"
+ "    x = /** @struct */ { a: 2 };\n"
+ "  }\n"
+ "  x['a'] = 123;\n"
+ "}",
"function f(cond) {\n"
+ "  var x;\n"
+ "  if (cond) {\n"
+ "    x = /** @struct */ { a: 1 };\n"
+ "  }\n"
+ "  else {\n"
+ "    x = {};\n"
+ "  }\n"
+ "  x['random' + 'propname'] = 123;\n"
+ "}",
"/** @constructor @dict */ function Foo() { this['prop'] = 123; }\n"
+ "(new Foo)['prop'];");
"/** @constructor @dict */ function Foo() { this['prop'] = 123; }\n"
+ "(new Foo).prop;",
"/** @constructor @dict */ function Foo() {\n"
+ "  this['prop'] = 123;\n"
+ "  this.prop - 123;\n"
+ "}",
"/** @constructor @dict */ function Foo() { this['prop'] = 123; }\n"
+ "(new Foo).prop = 123;",
"/** @constructor @dict */ function Foo() { this['prop'] = {}; }\n"
+ "(new Foo).prop.newprop = 123;",
"/** @constructor @dict */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "function f(cond) {\n"
+ "  var x;\n"
+ "  if (cond) {\n"
+ "    x = new Foo;\n"
+ "  }\n"
+ "  else {\n"
+ "    x = new Bar;\n"
+ "  }\n"
+ "  x.prop = 123;\n"
+ "}",
typeCheck("(/** @dict */ { prop : 1 });", TypeCheck.ILLEGAL_OBJLIT_KEY);
"(/** @dict */ {}).toString();", TypeValidator.ILLEGAL_PROPERTY_ACCESS);
typeCheck("('prop' in /** @struct */ {});", TypeCheck.IN_USED_WITH_STRUCT);
"for (var x in /** @struct */ {});", TypeCheck.IN_USED_WITH_STRUCT);
checkNoWarnings("var lit = { a: 1 }; lit.a - 2; lit['a'] + 5;");
"/** @constructor @struct */ function Foo() {}\n"
+ "/** @constructor @dict */ function Bar() {}\n"
+ "function f(/** Foo */ x) {}\n"
+ "f(/** @dict */ {});",
"function f(/** { a : number } */ x) {}\n"
+ "f(/** @dict */ { 'a' : 5 });",
"function f(obj) {\n"
+ "  return obj.prop;\n"
+ "}\n"
+ "f(/** @dict */ { 'prop': 123 });",
"function f(obj) {\n"
+ "  return obj['prop'];\n"
+ "}\n"
+ "f(/** @struct */ { prop: 123 });",
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "function f(obj) { obj['prop']; return obj; }\n"
+ "var /** !Foo */ x = f({ prop: 123 });");
checkNoWarnings("function f(obj) {\n"
+ "  if (obj['p1']) {\n"
+ "    obj.p2.p3 = 123;\n"
+ "  }\n"
+ "}");
checkNoWarnings("function f(obj) {\n"
+ "  return obj['a'] + obj.b;\n"
+ "}\n"
+ "f({ a: 123, 'b': 234 });");
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "/** @constructor @struct @extends {Foo} */\n"
+ "function Bar() {}");
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "/** @constructor @unrestricted @extends {Foo} */\n"
+ "function Bar() {}");
checkNoWarnings("/** @constructor @dict */\n"
+ "function Foo() {}\n"
+ "/** @constructor @dict @extends {Foo} */\n"
+ "function Bar() {}");
typeCheck(
"/** @constructor @unrestricted */\n"
+ "function Foo() {}\n"
+ "/** @constructor @struct @extends {Foo} */\n"
+ "function Bar() {}",
"/** @constructor @unrestricted */\n"
+ "function Foo() {}\n"
+ "/** @constructor @dict @extends {Foo} */\n"
+ "function Bar() {}",
"/** @interface */\n"
+ "function Foo() {}\n"
+ "/** @constructor @dict @implements {Foo} */\n"
+ "function Bar() {}",
JSTypeCreatorFromJSDoc.DICT_IMPLEMENTS_INTERF);
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() { this.prop = 1; }\n"
+ "(new Foo).prop = 2;");
"/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function() { this.prop = 1; };\n"
+ "(new Foo).prop = 2;",
"/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "(new Foo).prop += 2;",
"/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function() { this.prop = 1; };\n"
+ "(new Foo).prop++;",
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "/** @constructor @struct @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "Bar.prototype.prop = 123;");
typeCheck(
"/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "/** @constructor @struct @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "Bar.prototype.prop = 123;\n"
+ "(new Foo).prop = 234;",
"/**\n"
+ " * @constructor\n"
+ " * @struct\n"
+ " */\n"
+ "function Foo() {\n"
+ "  var t = this;\n"
+ "  t.x = 123;\n"
+ "}",
checkNoWarnings("/**\n"
+ " * @constructor\n"
+ " * @struct\n"
+ " */\n"
+ "function Foo() {}\n"
+ "Foo.someprop = 123;");
checkNoWarnings("/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.bar = 123;\n"
+ "(new Foo).bar = 123;");
checkNoWarnings("function f(obj) { obj.prop = 123; }\n"
+ "f(/** @struct */ {});");
"/** @constructor @struct */\n"
+ "function Foo() {}\n"
+ "function f(obj) { obj.prop - 5; return obj; }\n"
+ "var s = (1 < 2) ? new Foo : f({ prop: 123 });\n"
+ "s.newprop = 123;",
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
"var x = {\n"
+ "  /**\n"
+ "   * @return {T|number} b\n"
+ "   * @template T\n"
+ "   */\n"
+ "  get a() {}\n"
+ "};",
"var x = /** @dict */ { get a() {} };", TypeCheck.ILLEGAL_OBJLIT_KEY);
"var x = { get a() { return 1; } };\n"
+ "x.a < 'str';",
"var x = { get a() { return 1; } };\n"
+ "x.a();",
"var x = { get 'a'() { return 1; } };\n"
+ "x['a']();",
checkNoWarnings( // assigning to a getter doesn't remove it
"var x = { get a() { return 1; } };\n"
+ "x.a = 'str';\n"
+ "x.a - 1;");
"var x = {\n"
+ "  /**\n"
+ "   * @param {T|number} b\n"
+ "   * @template T\n"
+ "   */\n"
+ "  set a(b) {}\n"
+ "};",
"var x = /** @dict */ { set a(b) {} };", TypeCheck.ILLEGAL_OBJLIT_KEY);
"var x = { /** @param {string} b */ set a(b) {} };\n"
+ "x.a = 123;",
"var x = { set a(b) { b - 5; } };\n"
+ "x.a = 'str';",
"var x = { set 'a'(b) { b - 5; } };\n"
+ "x['a'] = 'str';",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @const */\n"
+ "Foo.prop;",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop;\n"
+ "}",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @const */\n"
+ "Foo.prototype.prop;",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.prop;",
"/** @constructor */ function Foo() {}\n"
+ "Foo.prototype.method = function() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {\n"
+ "  /**\n"
+ "   * @constructor\n"
+ "   * @final\n"
+ "   */\n"
+ "  this.Bar = function() {};\n"
+ "}");
"/** @const */ var x = 1; x = 2;", NewTypeInference.CONST_REASSIGNED);
"/** @const */ var x = 1; x += 2;", NewTypeInference.CONST_REASSIGNED);
"/** @const */ var x = 1; x -= 2;", NewTypeInference.CONST_REASSIGNED);
"/** @const */ var x = 1; x++;", NewTypeInference.CONST_REASSIGNED);
"/** @const */ var x = 1;\n"
+ "function f() { x = 2; }",
typeCheck("/** @const {number} */ var x;", "x = 2;",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}\n"
+ "var obj = new Foo;\n"
+ "obj.prop = 2;",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const {number} */\n"
+ "  this.prop = 1;\n"
+ "}\n"
+ "var obj = new Foo;\n"
+ "obj.prop = 2;",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}\n"
+ "var obj = new Foo;\n"
+ "obj.prop += 2;",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}\n"
+ "var obj = new Foo;\n"
+ "obj.prop++;",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.prop = 1;\n"
+ "ns.prop = 2;",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.prop = 1;\n"
+ "function f() { ns.prop = 2; }",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const {number} */\n"
+ "ns.prop = 1;\n"
+ "ns.prop = 2;",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.prop = 1;\n"
+ "ns.prop++;",
"/** @constructor */ function Foo() {}\n"
+ "/** @const */ Foo.prop = 1;\n"
+ "Foo.prop = 2;",
"/** @constructor */ function Foo() {}\n"
+ "/** @const {number} */ Foo.prop = 1;\n"
+ "Foo.prop++;",
"/** @constructor */ function Foo() {}\n"
+ "/** @const */ Foo.prototype.prop = 1;\n"
+ "Foo.prototype.prop = 2;",
"/** @constructor */ function Foo() {}\n"
+ "/** @const */ Foo.prototype.prop = 1;\n"
+ "var protoAlias = Foo.prototype;\n"
+ "protoAlias.prop = 2;",
"/** @constructor */\n"
+ "function Foo() { /** @const */ this.X = 4; }\n"
+ "/** @constructor */\n"
+ "function Bar() { /** @const */ this.X = 5; }\n"
+ "var fb = true ? new Foo : new Bar;\n"
+ "fb.X++;",
NewTypeInference.CONST_REASSIGNED);
public void testConstantByConvention() {
typeCheck(
"var ABC = 123;\n"
+ "ABC = 321;",
NewTypeInference.CONST_REASSIGNED);
typeCheck(
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  this.ABC = 123;\n"
+ "}\n"
+ "(new Foo).ABC = 321;",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @final */\n"
+ "Foo.prototype.method = function(x) {};\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "Bar.prototype.method = function(x) {};",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @final */\n"
+ "Foo.prototype.num = 123;\n"
+ "/** @constructor @extends {Foo} */\n"
+ "function Bar() {}\n"
+ "Bar.prototype.num = 2;");
"/** @const */\n"
+ "var s = 'str';\n"
+ "function f() { s - 5; }",
"function f(/** string */ x) {\n"
+ "  /** @const */\n"
+ "  var s = x;\n"
+ "  function g() { s - 5; }\n"
+ "}",
checkNoWarnings("/** @const */\n"
+ "var r = /find/;");
"/** @constructor */ function RegExp(){}\n"
+ "/** @const */\n"
+ "var r = /find/;\n"
+ "function g() { r - 5; }",
checkNoWarnings("/** @const */\n"
+ "var a = [5];");
"/** @const */\n"
+ "var a = [5];\n"
+ "function g() { a - 5; }",
"var x;\n"
+ "/** @const */ var o = x = {};\n"
+ "function g() { return o.prop; }",
"/** @const */ var o = (0,{});\n"
+ "function g() { return o.prop; }",
"/** @const */ var s = true ? null : null;\n"
+ "function g() { s - 5; }",
"/** @const */ var s = true ? void 0 : undefined;\n"
+ "function g() { s - 5; }",
"/** @const */ var b = true ? (1<2) : ('' in {});\n"
+ "function g() { b - 5; }",
"/** @const */ var n = 0 || 6;\n"
+ "function g() { n < 'str'; }",
"/** @const */ var s = 'str' + 5;\n"
+ "function g() { s - 5; }",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */\n"
+ "  this.prop = 'str';\n"
+ "}\n"
+ "(new Foo).prop - 5;",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @const */\n"
+ "Foo.prop = 'str';\n"
+ "function g() { Foo.prop - 5; }",
"function f(/** string */ s) {\n"
+ "  /** @constructor */\n"
+ "  function Foo() {}\n"
+ "  /** @const */\n"
+ "  Foo.prototype.prop = s;\n"
+ "  function g() {\n"
+ "    (new Foo).prop - 5;\n"
+ "  }\n"
+ "}",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.prop = 'str';\n"
+ "function f() {\n"
+ "  ns.prop - 5;\n"
+ "}",
"function f(x, y) {\n"
+ "  /** @const */\n"
+ "  var n = x - y;\n"
+ "  function g() { n < 'str'; }\n"
+ "}",
"function f(x) {\n"
+ "  /** @const */\n"
+ "  var notx = !x;\n"
+ "  function g() { notx - 5; }\n"
+ "}",
"/** @const */\n"
+ "var lit = { a: 'a', b: 'b' };\n"
+ "function g() { lit.a - 5; }",
"/** @const */\n"
+ "var n = ('str', 123);\n"
+ "function f() { n < 'str'; }",
"/** @const */\n"
+ "var s = x;\n"
+ "var /** string */ x;\n",
"function f(x) {\n"
+ "  /** @const */\n"
+ "  var c = x;\n"
+ "}",
checkNoWarnings("function f(x) {\n"
+ "  /** @const */\n"
+ "  var c = { a: 1, b: x };\n"
+ "}");
"/**\n"
+ " * @constructor\n"
+ " * @param {{ a: string }} x\n"
+ " */\n"
+ "function Foo(x) {\n"
+ "  /** @const */\n"
+ "  this.prop = x.a;\n"
+ "}\n"
+ "(new Foo({ a: ''})).prop - 5;",
"/** @return {string} */\n"
+ "function f() { return ''; }\n"
+ "/** @const */\n"
+ "var s = f();\n"
+ "function g() { s - 5; }",
"/** @const */\n"
+ "var s = f();\n"
+ "/** @return {string} */\n"
+ "function f() { return ''; }",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "/** @const */\n"
+ "var foo = new Foo;\n"
+ "function g() {\n"
+ "  var /** Bar */ bar = foo;\n"
+ "}",
"/** @const */\n"
+ "var n1 = 1;\n"
+ "/** @const */\n"
+ "var n2 = n1;\n"
+ "function g() { n2 < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @constructor */ function Bar() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @final\n"
+ " */\n"
+ "var Foo = Bar;");
checkNoWarnings("/** @constructor */ function Bar() {}\n"
+ "/** @const */\n"
+ "var ns = {};\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @final\n"
+ " */\n"
+ "ns.Foo = Bar;");
checkNoWarnings("/**\n"
+ " * @constructor\n"
+ " * @final\n"
+ " */\n"
+ "var Foo = function() {};\n"
+ "Foo = /** @type {?} */ (function() {});");
checkNoWarnings("/**\n"
+ " * @fileoverview\n"
+ " * @suppress {newCheckTypes}\n"
+ " */\n"
+ "123();");
"123();\n"
+ "/** @suppress {newCheckTypes} */\n"
+ "function f() { 123(); }",
"123();\n"
+ "/** @suppress {newCheckTypes} */\n"
+ "function f() { 1 - 'str'; }",
checkNoWarnings("/** @const */ var ns = {};\n"
+ "/** @type {Object} */\n"
+ "ns.obj = { prop: 123 };\n"
+ "/**\n"
+ " * @suppress {duplicate}\n"
+ " * @type {Object}\n"
+ " */\n"
+ "ns.obj = null;");
checkNoWarnings("function f() {\n"
+ "  /** @const */\n"
+ "  var ns = {};\n"
+ "  /** @type {number} */\n"
+ "  ns.prop = 1;\n"
+ "  /**\n"
+ "   * @type {number}\n"
+ "   * @suppress {duplicate}\n"
+ "   */\n"
+ "  ns.prop = 2;\n"
+ "}");
"/** @typedef {number} */\n"
+ "var num = 1;",
"/** @typedef {NonExistentType} */\n"
+ "var t;\n"
+ "function f(/** t */ x) { x - 1; }",
"/** @typedef {number} */\n"
+ "var dup;\n"
+ "/** @typedef {string} */\n"
+ "var dup;\n"
+ "var /** dup */ n = 'str';",
checkNoWarnings("/** @typedef {number} */\n"
+ "var num;\n"
+ "/** @type {num} */\n"
+ "var n = 1;");
"/** @typedef {number} */\n"
+ "var num;\n"
+ "/** @type {num} */\n"
+ "var n = 'str';",
"/** @type {num} */\n"
+ "var n = 'str';\n"
+ "/** @typedef {number} */\n"
+ "var num;",
"/** @typedef {number} */\n"
+ "var num;\n"
+ "function f() {\n"
+ "  /** @type {num} */\n"
+ "  var n = 'str';\n"
+ "}",
"/** @type {num2} */\n"
+ "var n = 'str';\n"
+ "/** @typedef {num} */\n"
+ "var num2;\n"
+ "/** @typedef {number} */\n"
+ "var num;",
"/** @typedef {rec2} */\n"
+ "var rec1;\n"
+ "/** @typedef {rec1} */\n"
+ "var rec2;",
"/** @typedef {{ prop: rec2 }} */\n"
+ "var rec1;\n"
+ "/** @typedef {{ prop: rec1 }} */\n"
+ "var rec2;",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @typedef {Foo} */\n"
+ "var Bar;\n"
+ "var /** Bar */ x = null;");
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @typedef {Foo} */\n"
+ "var Bar;\n"
+ "var /** !Bar */ x = null;",
"/** @typedef {number} */\n"
+ "var N;\n"
+ "function f() {\n"
+ "  /** @constructor */\n"
+ "  function N() {}\n"
+ "  function g(/** N */ obj) { obj - 5; }\n"
+ "}",
"(/** @lends {number} */ { a: 1 });", GlobalTypeInfo.LENDS_ON_BAD_TYPE);
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo.badname} */ { a: 1 });",
"/** @interface */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo} */ { a: 1 });",
"/** @interface */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo.prototype} */ { a: 1 });",
"/** @const */ var ns = {};\n"
+ "(/** @lends {ns} */ { /** @type {number} */ prop : 1 });\n"
+ "function f() { ns.prop = 'str'; }",
"(/** @lends {ns} */ { /** @type {number} */ prop : 1 });\n"
+ "/** @const */ var ns = {};\n"
+ "function f() { ns.prop = 'str'; }",
"/** @const */ var ns = {};\n"
+ "(/** @lends {ns} */ { prop : 1 });\n"
+ "function f() { var /** string */ s = ns.prop; }",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.subns = {};\n"
+ "(/** @lends {ns.subns} */ { prop: 1 });\n"
+ "var /** string */ s = ns.subns.prop;",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo} */ { prop: 1 });\n"
+ "var /** string */ s = Foo.prop;",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo} */ { prop: 1 });\n"
+ "function f() { var /** string */ s = Foo.prop; }",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @constructor */\n"
+ "ns.Foo = function() {};\n"
+ "(/** @lends {ns.Foo} */ { prop: 1 });\n"
+ "function f() { var /** string */ s = ns.Foo.prop; }",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo.prototype} */ { /** @type {number} */ a: 1 });\n"
+ "var /** string */ s = Foo.prototype.a;",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "(/** @lends {Foo.prototype} */ { /** @type {number} */ a: 1 });\n"
+ "var /** string */ s = (new Foo).a;",
"/** @constructor */\n"
+ "function Foo() { /** @type {number} */ this.prop = 1; }\n"
+ "(/** @lends {Foo.prototype} */\n"
+ " { /** @return {number} */ m: function() { return this.prop; } });\n"
+ "var /** string */ s = (new Foo).m();",
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f(/** E */ x) { x < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @enum */\n"
+ // No type annotation defaults to number
"var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f(/** E */ x) { x < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings("/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f(/** E */ x) {}\n"
+ "function g(/** number */ x) {}\n"
+ "f(E.TWO);\n"
+ "g(E.TWO);");
typeCheck(
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f(/** E */ x) {}\n"
+ "f(1);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f() { E.THREE - 5; }",
checkNoWarnings("/** @enum {!Foo} */\n"
+ "var E = { ONE: new Foo };\n"
+ "/** @constructor */\n"
+ "function Foo() {}");
"/** @typedef {number} */\n"
+ "var num;\n"
+ "/** @enum {num} */\n"
+ "var E = { ONE: 1 };\n"
+ "function f(/** E */ x) { x < 'str'; }",
"/** @enum {!Object} */ var E = {FOO: { prop: 1 }};\n"
+ "E.FOO.prop - 5;",
"/** @enum {{prop: number}} */ var E = {FOO: { prop: 1 }};\n"
+ "E.FOO.prop - 5;");
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}\n"
+ "/** @enum {!Foo} */\n"
+ "var E = { ONE: new Foo() };\n"
+ "function f(/** E */ x) { x.prop < 'str'; }",
"/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @const */ this.prop = 1;\n"
+ "}\n"
+ "/** @enum {!Foo} */\n"
+ "var E = { ONE: new Foo() };\n"
+ "function f(/** E */ x) { x.prop = 2; }",
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @enum {!Foo} */\n"
+ "var E = { A: new Foo };\n"
+ "function f(/** E */ x) { x instanceof Foo; }");
"/** @enum {number} */\n"
+ "var E;",
"/** @enum {number} */\n"
+ "var E = {};",
"/** @enum {number} */\n"
+ "var E = 1;",
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: true\n"
+ "};",
"/** @enum {number} */\n"
+ "var E = { a: 1 };",
"/** @enum {number} */\n"
+ "var E = { A: 1, A: 2 };",
checkNoWarnings("/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "E.THREE = 3;");
typeCheck(
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "E.ONE = E.TWO;",
"/** @enum {number} */\n"
+ "var E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: 2\n"
+ "};\n"
+ "function f(/** E */) { E.ONE = E.TWO; }",
"/** @enum {Type2} */\n"
+ "var Type1 = {\n"
+ "  ONE: null\n"
+ "};\n"
+ "/** @enum {Type1} */\n"
+ "var Type2 = {\n"
+ "  ONE: null\n"
+ "};",
"/** @enum {Type2} */\n"
+ "var Type1 = {\n"
+ "  ONE: null\n"
+ "};\n"
+ "/** @typedef {Type1} */\n"
+ "var Type2;",
"/** @enum {InexistentType} */\n"
+ "var E = { ONE : null };",
"/** @enum {*} */\n"
+ "var E = { ONE: 1, STR: '' };",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  /** @enum {function(T):number} */\n"
+ "  var E = { ONE: x };\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  /** @enum {T} */\n"
+ "  var E1 = { ONE: 1 };\n"
+ "  /** @enum {function(E1):E1} */\n"
+ "  var E2 = { ONE: function(x) { return x; } };\n"
+ "}",
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function f(x) {\n"
+ "  /** @typedef {T} */ var AliasT;\n"
+ "  /** @enum {T} */\n"
+ "  var E1 = { ONE: 1 };\n"
+ "  /** @enum {function(E1):T} */\n"
+ "  var E2 = { ONE: function(x) { return x; } };\n"
+ "}",
"/** @enum {number|string} */\n"
+ "var E = { ONE: 1, STR: '' };",
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @enum {Foo} */\n"
+ "var E = { ONE: new Foo, TWO: null };",
"/** @typedef {number|string} */\n"
+ "var NOS;\n"
+ "/** @enum {NOS} */\n"
+ "var E = { ONE: 1, STR: '' };",
checkNoWarnings("/** @enum */ var E1 = { A: 1};\n"
+ "/** @enum */ var E2 = { A: 2};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {(T|E1)} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "f(/** @type {(string|E1)} */ ('str'));");
typeCheck(
"/** @enum */ var E1 = { A: 1};\n"
+ "/** @enum */ var E2 = { A: 2};\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {(T|E1)} x\n"
+ " */\n"
+ "function f(x) {}\n"
+ "f(/** @type {(string|E2)} */ ('str'));",
"/** @enum {number} */\n"
+ "var E = { ONE: 1 };\n"
+ "function f(cond) {\n"
+ "  var x = cond ? E.ONE : 5;\n"
+ "  x - 2;\n"
+ "  var /** E */ y = x;\n"
+ "}",
"/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "/** @enum {!Low} */\n"
+ "var E = { A: new Low };\n"
+ "function f(cond) {\n"
+ "  var x = cond ? E.A : new High;\n"
+ "  var /** High */ y = x;\n"
+ "  var /** E */ z = x;\n"
+ "}",
checkNoWarnings("/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "/** @enum {!High} */\n"
+ "var E = { A: new High };\n"
+ "function f(cond) {\n"
+ "  var x = cond ? E.A : new Low;\n"
+ "  if (!(x instanceof Low)) { var /** E */ y = x; }\n"
+ "}");
"/** @enum {?} */\n"
+ "var E = { A: 123 };\n"
+ "function f(x) {\n"
+ "  var /** string */ s = x;\n"
+ "  var /** E */ y = x;\n"
+ "  s = x;\n"
+ "}\n"
+ "f('str');",
"/** @enum {number} */\n"
+ "var E1 = { ONE: 1 };\n"
+ "/** @enum {number} */\n"
+ "var E2 = { TWO: 1 };\n"
+ "/** @enum {number} */\n"
+ "var E3 = { THREE: 1 };\n"
+ "function f(x) {\n"
+ "  var /** (E1|E2) */ y = x;\n"
+ "  var /** (E1|E3) */ z = x;\n"
+ "  var /** E1 */ w = x;\n"
+ "}\n"
+ "f(E2.TWO);",
"/** @enum {number} */\n"
+ "var E = { ONE: 1 };\n"
+ "function f(x) {\n"
+ "  var /** E */ y = x;\n"
+ "  var /** number */ z = x;\n"
+ "}\n"
+ "f(123);",
"/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "/** @enum {!Low} */\n"
+ "var E = { A: new Low };\n"
+ "function f(x) {\n"
+ "  var /** !High */ y = x;\n"
+ "  var /** E */ z = x;\n"
+ "}\n"
+ "f(new High);",
"/** @interface */\n"
+ "function High1() {}\n"
+ "/** @interface */\n"
+ "function High2() {}\n"
+ "/** @constructor @implements {High1} @implements {High2} */\n"
+ "function Low() {}\n"
+ "/** @enum {!Low} */\n"
+ "var E = { A: new Low };\n"
+ "function f(x) {\n"
+ "  var /** (!High1 | !High2) */ y = x;\n"
+ "  var /** E */ z = x;\n"
+ "}\n"
+ "f(/** @type {!High1} */ (new Low));",
"/** @constructor */\n"
+ "function High() {}\n"
+ "/** @constructor @extends {High} */\n"
+ "function Low() {}\n"
+ "/** @enum {!High} */\n"
+ "var E = { A: new High };\n"
+ "/** @param {function(E)|function(!Low)} x */\n"
+ "function f(x) { x(123); }",
public void testEnumAliasing() {
checkNoWarnings("/** @enum {number} */\n"
+ "var e1 = { A: 1 };\n"
+ "/** @enum {number} */\n"
+ "var e2 = e1;");
typeCheck(
"var x;\n"
+ "/** @enum {number} */\n"
+ "var e1 = { A: 1 };\n"
+ "/** @enum {number} */\n"
+ "var e2 = x;",
GlobalTypeInfo.MALFORMED_ENUM);
checkNoWarnings("/** @const */\n"
+ "var ns1 = {};\n"
+ "/** @enum {number} */\n"
+ "ns1.e1 = { A: 1 };\n"
+ "/** @const */\n"
+ "var ns2 = {};\n"
+ "/** @enum {number} */\n"
+ "ns2.e2 = ns1.e1;");
checkNoWarnings("/** @enum {number} */\n"
+ "var e1 = { A: 1 };\n"
+ "/** @enum {number} */\n"
+ "var e2 = e1;\n"
+ "function f(/** e2 */ x) {}\n"
+ "f(e1.A);");
checkNoWarnings("/** @enum {number} */\n"
+ "var e1 = { A: 1 };\n"
+ "/** @enum {number} */\n"
+ "var e2 = e1;\n"
+ "function f(/** e2 */ x) {}\n"
+ "f(e2.A);");
typeCheck(
"/** @enum {number} */\n"
+ "var e1 = { A: 1 };\n"
+ "/** @enum {number} */\n"
+ "var e2 = e1;\n"
+ "function f(/** e2 */ x) {}\n"
+ "f('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/** @const */\n"
+ "var ns1 = {};\n"
+ "/** @enum {number} */\n"
+ "ns1.e1 = { A: 1 };\n"
+ "/** @const */\n"
+ "var ns2 = {};\n"
+ "/** @enum {number} */\n"
+ "ns2.e2 = ns1.e1;\n"
+ "function f(/** ns2.e2 */ x) {}\n"
+ "f(ns1.e1.A);");
checkNoWarnings("/** @const */\n"
+ "var ns1 = {};\n"
+ "/** @enum {number} */\n"
+ "ns1.e1 = { A: 1 };\n"
+ "/** @const */\n"
+ "var ns2 = {};\n"
+ "/** @enum {number} */\n"
+ "ns2.e2 = ns1.e1;\n"
+ "function f(/** ns1.e1 */ x) {}\n"
+ "f(ns2.e2.A);");
checkNoWarnings("/** @const */\n"
+ "var ns1 = {};\n"
+ "/** @enum {number} */\n"
+ "ns1.e1 = { A: 1 };\n"
+ "function g() {\n"
+ "  /** @const */\n"
+ "  var ns2 = {};\n"
+ "  /** @enum {number} */\n"
+ "  ns2.e2 = ns1.e1;\n"
+ "  function f(/** ns1.e1 */ x) {}\n"
+ "  f(ns2.e2.A);\n"
+ "}");
typeCheck("(4 - 'str') ? 5 : 6;", NewTypeInference.INVALID_OPERAND_TYPE);
"/** @constructor */\n"
+ "function Foo() { /** @type {number|string} */ this.x = 5 };\n"
+ "var o = true ? {x:5} : {y:'str'};\n"
+ "if (o instanceof Foo) {\n"
+ "  var /** {x:number} */ o2 = o;\n"
+ "}\n"
+ "(function(/** {x:number} */ o3){})(o);",
typeCheck(CLOSURE_BASE + "goog.isNull();", TypeCheck.WRONG_ARGUMENT_COUNT);
CLOSURE_BASE + "goog.isNull(1, 2, 5 - 'str');",
checkNoWarnings(CLOSURE_BASE
+ "function f(x) { var /** boolean */ b = goog.isNull(x); }");
CLOSURE_BASE
+ "function f(x) { if (goog.isNull(x)) { var /** undefined */ y = x; } }",
CLOSURE_BASE + "/** @param {number=} x */\n"
+ "function f(x) {\n"
+ "  if (goog.isDef(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "  x - 5;\n"
+ "}",
CLOSURE_BASE + "/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {Foo=} x */\n"
+ "function f(x) {\n"
+ "  var /** !Foo */ y;\n"
+ "  if (goog.isDefAndNotNull(x)) {\n"
+ "    y = x;\n"
+ "  }\n"
+ "  y = x;\n"
+ "}",
CLOSURE_BASE + "function f(/** (Array<number>|number) */ x) {\n"
+ "  var /** Array<number> */ a;\n"
+ "  if (goog.isArray(x)) {\n"
+ "    a = x;\n"
+ "  }\n"
+ "  a = x;\n"
+ "}",
CLOSURE_BASE + "/** @param {null|function(number)} x */ \n"
+ "function f(x) {\n"
+ "  if (goog.isFunction(x)) {\n"
+ "    x('str');\n"
+ "  }\n"
+ "}",
CLOSURE_BASE + "function f(x) {\n"
+ "  if (goog.isObject(x)) {\n"
+ "    var /** null */ y = x;\n"
+ "  }\n"
+ "}",
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (goog.isString(x)) {\n"
+ "    x < 'str';\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (goog.isNumber(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|boolean) */ x) {\n"
+ "  if (goog.isBoolean(x)) {\n"
+ "    var /** boolean */ b = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "/**\n"
+ " * @param {number|string} x\n"
+ " * @return {string}\n"
+ " */\n"
+ "function f(x) {\n"
+ "  return goog.isString(x) && (1 < 2) ? x : 'a';\n"
+ "}");
CLOSURE_BASE + "/** @constructor */\n"
+ "function Foo() {}\n"
+ "function f(/** Foo */ x) {\n"
+ "  var /** !Foo */ y;\n"
+ "  if (!goog.isNull(x)) {\n"
+ "    y = x;\n"
+ "  }\n"
+ "  y = x;\n"
+ "}",
checkNoWarnings(CLOSURE_BASE + "/** @param {number=} x */\n"
+ "function f(x) {\n"
+ "  if (!goog.isDef(x)) {\n"
+ "    var /** undefined */ u = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {Foo=} x */\n"
+ "function f(x) {\n"
+ "  if (!goog.isDefAndNotNull(x)) {\n"
+ "    var /** (null|undefined) */ y = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (!goog.isString(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (!goog.isNumber(x)) {\n"
+ "    x < 'str';\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|boolean) */ x) {\n"
+ "  if (!goog.isBoolean(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE
+ "function f(/** (number|!Array<number>) */ x) {\n"
+ "  if (!goog.isArray(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(x) {\n"
+ "  if (goog.isArray(x)) {\n"
+ "    return x[0] - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE
+ "function f(/** (number|function(number)) */ x) {\n"
+ "  if (!goog.isFunction(x)) {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @param {?Foo} x */\n"
+ "function f(x) {\n"
+ "  if (!goog.isObject(x)) {\n"
+ "    var /** null */ y = x;\n"
+ "  }\n"
+ "}");
public void testGoogTypeof() {
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (goog.typeOf(x) === 'number') {\n"
+ "    var /** number */ n = x;\n"
+ "  } else {\n"
+ "    var /** string */ s = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if ('number' === goog.typeOf(x)) {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "function f(/** (number|string) */ x) {\n"
+ "  if (goog.typeOf(x) == 'number') {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
checkNoWarnings(CLOSURE_BASE + "/** @param {number=} x */\n"
+ "function f(x) {\n"
+ "  if (goog.typeOf(x) === 'undefined') {\n"
+ "    var /** undefined */ u = x;\n"
+ "  } else {\n"
+ "    var /** number */ n = x;\n"
+ "  }\n"
+ "}");
typeCheck(
CLOSURE_BASE + "/** @param {string} x */\n"
+ "function f(x, other) {\n"
+ "  if (goog.typeOf(x) === other) {\n"
+ "    var /** null */ n = x;\n"
+ "  } else {\n"
+ "    x - 5;\n"
+ "  }\n"
+ "}",
ImmutableList.of(
NewTypeInference.MISTYPED_ASSIGN_RHS,
NewTypeInference.INVALID_OPERAND_TYPE));
public void testSuperClassCtorProperty() throws Exception {
String CLOSURE_DEFS =
"/** @const */ var goog = {};\n"
+ "goog.inherits = function(child, parent){};\n";
checkNoWarnings(CLOSURE_DEFS + "/** @constructor */function base() {}\n"
+ "/** @return {number} */ "
+ "  base.prototype.foo = function() { return 1; };\n"
+ "/** @extends {base}\n * @constructor */function derived() {}\n"
+ "goog.inherits(derived, base);\n"
+ "var /** number */ n = derived.superClass_.foo()");
typeCheck(
CLOSURE_DEFS + "/** @constructor */ function OldType() {}"
+ "/** @param {?function(new:OldType)} f */ function g(f) {"
+ "  /**\n"
+ "    * @constructor\n"
+ "    * @extends {OldType}\n"
+ "    */\n"
+ "  function NewType() {};"
+ "  goog.inherits(NewType, f);"
+ "  NewType.prototype.method = function() {"
+ "    NewType.superClass_.foo.call(this);"
+ "  };"
+ "}",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings(CLOSURE_DEFS + "/** @constructor */ function Foo() {}\n"
+ "goog.inherits(Foo, Object);\n"
+ "var /** !Object */ b = Foo.superClass_;");
typeCheck(
CLOSURE_DEFS + "/** @constructor */ function base() {}\n"
+ "/** @constructor @extends {base} */ function derived() {}\n"
+ "goog.inherits(derived, base);\n"
+ "var /** null */ b = derived.superClass_",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
CLOSURE_DEFS + "var /** !Object */ b = Object.superClass_",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
CLOSURE_DEFS + "var o = {x: 'str'}; var q = o.superClass_;",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings(CLOSURE_DEFS
+ "var o = {superClass_: 'str'}; var /** string */ s = o.superClass_;");
"/** @const */\n"
+ "var ns = {};\n"
+ "(function() {\n"
+ "  /** @constructor */\n"
+ "  ns.Foo = function() {};\n"
+ "})();\n"
+ "ns.Foo();",
"/** @const */\n"
+ "var ns = {};\n"
+ "(function() {\n"
+ "  /** @type {string} */\n"
+ "  ns.str = 'str';\n"
+ "})();\n"
+ "ns.str - 5;",
"/** @const */\n"
+ "var ns = {};\n"
+ "(function() {\n"
+ "  /** @constructor */\n"
+ "  ns.Foo = function() {};\n"
+ "})();\n"
+ "function f(/** ns.Foo */ x) {}\n"
+ "f(1);",
"/** @const */\n"
+ "var ns = {};\n"
+ "(function() {\n"
+ "  /** @constructor */\n"
+ "  ns.Foo = function() {};\n"
+ "})();\n"
+ "var /** ns.Foo */ x = 123;",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @constructor */\n"
+ "ns.Foo = function() {};\n"
+ "ns.Foo();",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @typedef {number} */\n"
+ "ns.num;\n"
+ "var /** ns.num */ y = 'str';",
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @enum {number} */\n"
+ "ns.Foo = { A: 1 };\n"
+ "var /** ns.Foo */ y = 'str';",
"/** @enum {number} */\n"
+ "var E = { A: 1 };\n"
+ "/** @typedef {number} */\n"
+ "E.num;\n"
+ "var /** E.num */ x = 'str';",
"/** @const */ var ns = {};\n"
+ "/** @enum {number} */\n"
+ "ns.E = {\n"
+ "  ONE: 1,\n"
+ "  TWO: true\n"
+ "};",
"/** @enum */\n"
+ "var E = { A: 1 };\n"
+ "/** @enum */\n"
+ "E.E2 = { B: true };\n"
+ "var /** E */ x = E.A;",
checkNoWarnings("/** @enum */\n"
+ "var E = { A: 1 };\n"
+ "/** @constructor */\n"
+ "E.Foo = function(x) {};\n"
+ "var /** E */ x = E.A;");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @enum {number} */\n"
+ "ns.E = { A: 1 };\n"
+ "/** @constructor */\n"
+ "ns.E.Foo = function(x) {};");
typeCheck(
"/** @const */\n"
+ "var ns = {};\n"
+ "/** @enum {number} */\n"
+ "ns.E = { A: 1 };\n"
+ "/** @constructor */\n"
+ "ns.E.Foo = function(x) {};\n"
+ "function f() { ns.E.Foo(); }",
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
checkNoWarnings("/** @constructor */ function String(){}\n"
+ "/** @this {String|string} */\n"
+ "String.prototype.substr = function(start) {};\n"
+ "/** @const */ var ns = {};\n"
+ "/** @const */ var s = 'str';\n"
+ "ns.r = s.substr(2);");
checkNoWarnings("/** @type {!Function} */\n"
+ "var abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @constructor @extends {Foo} */ function Bar(){};\n"
+ "/** @param {number} index */\n"
+ "Foo.prototype.m = abstractMethod;\n"
+ "/** @override */\n"
+ "Bar.prototype.m = function(index) {};");
typeCheck(
"/** @type {!Function} */\n"
+ "var abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @constructor @extends {Foo} */ function Bar(){};\n"
+ "/** @param {number} index */\n"
+ "Foo.prototype.m = abstractMethod;\n"
+ "/** @override */\n"
+ "Bar.prototype.m = function(index) {};\n"
+ "(new Bar).m('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @type {!Function} */\n"
+ "var abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @constructor @extends {Foo} */ function Bar(){};\n"
+ "/**\n"
+ " * @param {number} b\n"
+ " * @param {string} a\n"
+ " */\n"
+ "Foo.prototype.m = abstractMethod;\n"
+ "/** @override */\n"
+ "Bar.prototype.m = function(a, b) {};\n"
+ "(new Bar).m('str', 5);",
"/** @type {!Function} */\n"
+ "var abstractMethod = function(){};\n"
+ "/** @constructor */ function Foo(){};\n"
+ "/** @constructor @extends {Foo} */ function Bar(){};\n"
+ "/** @type {function(number, string)} */\n"
+ "Foo.prototype.m = abstractMethod;\n"
+ "/** @override */\n"
+ "Bar.prototype.m = function(a, b) {};\n"
+ "(new Bar).m('str', 5);",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.prop = 'asdf'; }\n"
+ "/** @param {function(!Foo)} fun */\n"
+ "function f(fun) {}\n"
+ "f(function(x) { x.prop = 123; });",
"/** @constructor */\n"
+ "function Foo() { /** @type {string} */ this.prop = 'asdf'; }\n"
+ "function f(/** function(this:Foo) */ x) {}\n"
+ "f(function() { this.prop = 123; });",
"/** @param {function(string)} fun */\n"
+ "function f(fun) {}\n"
+ "f(function(str) { str - 5; });",
"/** @param {function(number, number=)} fun */\n"
+ "function f(fun) {}\n"
+ "f(function(num, maybeNum) { num - maybeNum; });",
"/** @param {function(string, ... [string])} fun */\n"
+ "function f(fun) {}\n"
+ "f(function(str, maybeStrs) { str - 5; });",
"/** @const */ var ns = {};\n"
+ "/** @param {function(string)} fun */\n"
+ "ns.f = function(fun) {}\n"
+ "ns.f(function(str) { str - 5; });",
"/** @const */ var ns = {};\n"
+ "/** @type {function(function(string))} */\n"
+ "ns.f = function(fun) {}\n"
+ "ns.f(function(str) { str - 5; });",
"/** @constructor */ function Foo() {}\n"
+ "/** @param {function(string)} fun */\n"
+ "Foo.f = function(fun) {}\n"
+ "Foo.f(function(str) { str - 5; });",
"(/** @param {function(string)} fun */ function(fun) {})(\n"
+ "  function(str) { str - 5; });",
"/** @const */ var ns = {};\n"
+ "/** @param {function(function(function(string)))} outerFun */\n"
+ "ns.f = function(outerFun) {};\n"
+ "ns.f(function(innerFun) {\n"
+ "  innerFun(function(str) { str - 5; });\n"
+ "});",
"var x = 'str';\n"
+ "/** @const */ var o = { /** @const {string} */ PROP: x };\n"
+ "function g() { o.PROP - 5; }",
checkNoWarnings("/** @const */ var ns = {};\n"
+ "/** @const */ ns.o = { /** @const */ PROP: 5 };");
checkNoWarnings("/** @const */ var ns = {};\n"
+ "var x = 5;\n"
+ "/** @const */ ns.o = { /** @const {number} */ PROP: x };");
"/** @const */ var ns = {};\n"
+ "var x = 'str';\n"
+ "/** @const */ ns.o = { /** @const {string} */ PROP: x };\n"
+ "function g() { ns.o.PROP - 5; }",
"function f(/** { x : string } */ obj) {\n"
+ "  obj.ns = { /** @const */ PROP: 5 };\n"
+ "}",
GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
public void testAllTestsShouldHaveDupPropWarnings() {
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.Foo = {};\n"
+ "ns.Foo = { a: 123 };");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.Foo = {};\n"
+ "/** @const */\n"
+ "ns.Foo = { a: 123 };");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.Foo = {};\n"
+ "/**\n"
+ " * @const\n"
+
" * @suppress {duplicate}\n"
+ " */\n"
+ "ns.Foo = { a: 123 };");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @const */\n"
+ "ns.Foo = {};\n"
+ "/** @type {number} */\n"
+ "ns.Foo = 123;");
checkNoWarnings("/** @enum {number} */\n"
+ "var en = { A: 5 };\n"
+ "/** @const */\n"
+ "en.Foo = {};\n"
+ "/** @type {number} */\n"
+ "en.Foo = 123;");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @const */\n"
+ "Foo.ns = {};\n"
+ "/** @const */\n"
+ "Foo.ns = {};");
public void testNominalTypeAliasing() {
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "var Bar = Foo;\n"
+ "var /** !Bar */ x = new Foo();");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @constructor */\n"
+ "ns.Foo = function() {};\n"
+ "/** @constructor */\n"
+ "ns.Bar = ns.Foo;\n"
+ "function g() {\n"
+ "  var /** !ns.Bar */ x = new ns.Foo();\n"
+ "  var /** !ns.Bar */ y = new ns.Bar();\n"
+ "}");
typeCheck(
"/** @type {number} */\n"
+ "var n = 123;\n"
+ "/** @constructor */\n"
+ "var Foo = n;",
GlobalTypeInfo.EXPECTED_CONSTRUCTOR);
typeCheck(
"/** @type {number} */\n"
+ "var n = 123;\n"
+ "/** @interface */\n"
+ "var Foo = n;",
GlobalTypeInfo.EXPECTED_INTERFACE);
typeCheck(
"/** @interface */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "var Bar = Foo;",
GlobalTypeInfo.EXPECTED_CONSTRUCTOR);
typeCheck(
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @interface */\n"
+ "var Bar = Foo;",
GlobalTypeInfo.EXPECTED_INTERFACE);
typeCheck(
"var Bar;",
"/**\n"
+ " * @constructor\n"
+ " * @final\n"
+ " */\n"
+ "var Foo = Bar;\n"
+ "var /** !Foo */ x;",
ImmutableList.of(
GlobalTypeInfo.EXPECTED_CONSTRUCTOR,
GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME));
public void testTypeVariablesVisibleInPrototypeMethods() {
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.method = function() {\n"
+ "  /** @type {T} */\n"
+ "  this.prop = 123;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @param {T} x */"
+ "Foo.prototype.method = function(x) {\n"
+ "  x = 123;\n"
+ "}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @param {T} x */"
+ "Foo.prototype.method = function(x) {\n"
+ "  this.prop = x;\n"
+ "}");
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Foo() {}\n"
+ "/** @param {T} x */"
+ "Foo.prototype.method = function(x) {\n"
+ "  /** @const */\n"
+ "  this.prop = x;\n"
+ "}",
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " */\n"
+ "function Parent() {}\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @extends {Parent<string>}\n"
+ " */\n"
+ "function Child() {}\n"
+ "Child.prototype.method = function() {\n"
+ "  /** @type {T} */\n"
+ "  this.prop = 123;\n"
+ "}",
GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME);
public void testInferConstTypeFromEnumProps() {
checkNoWarnings("/** @enum */\n"
+ "var e = { A: 1 };\n"
+ "/** @const */\n"
+ "var numarr = [ e.A ];");
typeCheck(
"/** @enum */\n"
+ "var e = { A: 1 };\n"
+ "/** @type {number} */\n"
+ "e.prop = 123;\n"
+ "/** @const */\n"
+ "var x = e.prop;",
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE);
public void testForwardDeclarations() {
final String DEFINITIONS =
"/** @const */ var goog = {};\n"
+ "goog.addDependency = function(file, provides, requires){};\n"
+ "goog.forwardDeclare = function(name){};";
checkNoWarnings(DEFINITIONS + "goog.addDependency('', ['Foo'], []);\n"
+ "goog.forwardDeclare('Bar');\n"
+ "function f(/** !Foo */ x) {}\n"
+ "function g(/** !Bar */ y) {}");
checkNoWarnings(DEFINITIONS + "/** @const */ var ns = {};\n"
+ "goog.addDependency('', ['ns.Foo'], []);\n"
+ "goog.forwardDeclare('ns.Bar');\n"
+ "function f(/** !ns.Foo */ x) {}\n"
+ "function g(/** !ns.Bar */ y) {}");
checkNoWarnings(DEFINITIONS + "goog.forwardDeclare('Foo');\n"
+ "function f(/** !Foo */ x) {}\n"
+ "/** @constructor */ function Bar(){}\n"
+ "f(new Bar);");
checkNoWarnings(DEFINITIONS + "/** @const */ var ns = {};\n"
+ "goog.forwardDeclare('ns.Foo');\n"
+ "function f(/** !ns.Foo */ x) {}\n"
+ "/** @constructor */ function Bar(){}\n"
+ "f(new Bar);");
public void testDontLookupInParentScopeForNamesWithoutDeclaredType() {
checkNoWarnings("/** @type {number} */\n"
+ "var x;\n"
+ "function f() {\n"
+ "  var x = true;\n"
+ "}");
public void testSpecializationInPropertyAccesses() {
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {?number} */ ns.n = 123;\n"
+ "if (ns.n === null) {\n"
+ "} else {\n"
+ "  ns.n - 5;\n"
+ "}");
checkNoWarnings("/** @const */\n"
+ "var ns = {};\n"
+ "/** @type {?number} */ ns.n = 123;\n"
+ "if (ns.n !== null) {\n"
+ "  ns.n - 5;\n"
+ "}");
checkNoWarnings("var obj = { n: (1 < 2 ? null : 123) };\n"
+ "if (obj.n !== null) {\n"
+ "  obj.n - 123;\n"
+ "}");
typeCheck(
"var obj = { n: (1 < 2 ? null : 123) };\n"
+ "if (obj.n !== null) {\n"
+ "  obj.n - 123;\n"
+ "}\n"
+ "obj.n - 123;",
NewTypeInference.INVALID_OPERAND_TYPE);
public void testAutoconvertBoxedNumberToNumber() {
typeCheck(
"var /** !Number */ n = 123;", NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"var /** number */ n = new Number(123);",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("function f(/** !Number */ x, y) {\n"
+ "  return x - y;\n"
+ "}");
checkNoWarnings("function f(x, /** !Number */ y) {\n"
+ "  return x - y;\n"
+ "}");
checkNoWarnings("function f(/** !Number */ x) {\n"
+ "  return x + 'asdf';\n"
+ "}");
checkNoWarnings("function f(/** !Number */ x) {\n"
+ "  return -x;\n"
+ "}");
checkNoWarnings("function f(/** !Number */ x) {\n"
+ "  x -= 123;\n"
+ "}");
checkNoWarnings("function f(/** !Number */ x, y) {\n"
+ "  y -= x;\n"
+ "}");
checkNoWarnings("function f(/** !Number */ x, /** !Array<string>*/ arr) {\n"
+ "  return arr[x];\n"
+ "}");
public void testAutoconvertBoxedStringToString() {
typeCheck(
"var /** !String */ s = '';", NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"var /** string */ s = new String('');",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("function f() {\n"
+ "  var /** !String */ x;\n"
+ "  for (x in { p1: 123, p2: 234 }) ;\n"
+ "}");
checkNoWarnings("function f(/** !String */ x) {\n"
+ "  return x + 1;\n"
+ "}");
public void testAutoconvertBoxedBooleanToBoolean() {
typeCheck(
"var /** !Boolean */ b = true;", NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"var /** boolean */ b = new Boolean(true);",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings("function f(/** !Boolean */ x) {\n"
+ "  if (x) { return 123; };\n"
+ "}");
public void testAutoconvertScalarsToBoxedScalars() {
checkNoWarnings("var /** number */ n = 123;\n"
+ "n.toString();");
checkNoWarnings("var /** boolean */ b = true;\n"
+ "b.toString();");
checkNoWarnings("var /** string */ s = '';\n"
+ "s.toString();");
typeCheck(
"var /** number */ n = 123;\n"
+ "n.prop = 0;\n"
+ "n.prop - 5;",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings("var /** number */ n = 123;\n"
+ "n['to' + 'String'];");
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {\n"
+ "  /** @type {number} */\n"
+ "  this.prop = 123;\n"
+ "}\n"
+ "(new Foo).prop.newprop = 5;");
typeCheck(
"/** @enum */\n"
+ "var E = { A: 1 };\n"
+ "function f(/** E */ x) {\n"
+ "  return x.toString();\n"
+ "}",
NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT);
checkNoWarnings("/** @constructor */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.toString = function() {};\n"
+ "function f(/** (number|!Foo) */ x) {\n"
+ "  return x.toString();\n"
+ "}");
public void testConstructorsCalledWithoutNew() {
checkNoWarnings("var n = new Number();\n"
+ "n.prop = 0;\n"
+ "n.prop - 5;");
typeCheck(
"var n = Number();\n"
+ "n.prop = 0;\n"
+ "n.prop - 5;",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings(
"/** @constructor @return {number} */ function Foo(){ return 5; }\n"
+ "var /** !Foo */ f = new Foo;\n"
+ "var /** number */ n = Foo();");
typeCheck(
"/** @constructor */ function Foo(){ return 5; }\n"
+ "var /** !Foo */ f = new Foo;\n"
+ "var n = Foo();",
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
typeCheck(
"/** @constructor @return {?} */ function Foo(){}\n"
+ "var /** !Foo */ f = new Foo;\n"
+ "var n = Foo();",
TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
public void testFunctionBind() {
typeCheck( // Don't handle specially
"var obj = { bind: function() { return 'asdf'; } };\n"
+ "obj.bind() - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"function f(x) { return x; }\n"
+ "f.bind(null, 1, 2);",
TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck(
"function f(x) { return x; }\n"
+ "f.bind();",
TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck(
"function f(x) { return x - 1; }\n"
+ "var g = f.bind(null);\n"
+ "g();",
TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck(
"function f() {}\n"
+ "f.bind(1);",
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
typeCheck(
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "/** @constructor */\n"
+ "function Bar() {}\n"
+ "/** @this {!Foo} */\n"
+ "function f() {}\n"
+ "f.bind(new Bar);",
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
typeCheck(
"function f(/** number */ x, /** number */ y) { return x - y; }\n"
+ "var g = f.bind(null, 123);\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function f(x, y) { return x - y; }\n"
+ "var g = f.bind(null, 123);\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function f(/** number */ x) { return x - 1; }\n"
+ "var g = f.bind(null, 'asdf');\n"
+ "g() - 3;",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @param {number=} x */\n"
+ "function f(x) {}\n"
+ "var g = f.bind(null);\n"
+ "g();\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @param {...number} var_args */\n"
+ "function f(var_args) {}\n"
+ "var g = f.bind(null);\n"
+ "g();\n"
+ "g(123, 'asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("/** @param {number=} x */\n"
+ "function f(x) {}\n"
+ "f.bind(null, undefined);");
checkNoWarnings("/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f.bind(null, 1, 2);");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "var g = f.bind(null, 1);\n"
+ "g(2);\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings( // T was instantiated to ? in the f.bind call.
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "var g = f.bind(null);\n"
+ "g(2, 'asdf');");
typeCheck(
"/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f.bind(null, 1, 'asdf');",
NewTypeInference.NOT_UNIQUE_INSTANTIATION);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ " function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @this {Foo<T>}\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "function f(x, y) {}\n"
+ "f.bind(new Foo('asdf'), 1, 2);",
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
typeCheck(
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ " function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " * @param {T} y\n"
+ " */\n"
+ "Foo.prototype.f = function(x, y) {};\n"
+ "Foo.prototype.f.bind(new Foo('asdf'), 1, 2);",
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
typeCheck(
"/** @constructor */\n"
+ "function Foo() {}\n"
+ "Foo.bind(new Foo);",
NewTypeInference.CANNOT_BIND_CTOR);
checkNoWarnings( // We can't detect that f takes a string
"/**\n"
+ " * @constructor\n"
+ " * @template T\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function Foo(x) {}\n"
+ "/**\n"
+ " * @template T\n"
+ " * @this {Foo<T>}\n"
+ " * @param {T} x\n"
+ " */\n"
+ "function poly(x) {}\n"
+ "function f(x) {\n"
+ "  poly.bind(new Foo('asdf'), x);\n"
+ "}\n"
+ "f(123);");
public void testClosureStyleFunctionBind() {
typeCheck(
"goog.bind(123, null);", NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
typeCheck(
"function f(x) { return x; }\n"
+ "goog.bind(f, null, 1, 2);",
TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck(
"function f(x) { return x; }\n"
+ "goog.bind(f);",
TypeCheck.WRONG_ARGUMENT_COUNT);
typeCheck(
"function f() {}\n"
+ "goog.bind(f, 1);",
NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
typeCheck(
"function f(/** number */ x, /** number */ y) { return x - y; }\n"
+ "var g = goog.bind(f, null, 123);\n"
+ "g('asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function f(/** number */ x) { return x - 1; }\n"
+ "var g = goog.partial(f, 'asdf');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"function f(/** number */ x) { return x - 1; }\n"
+ "var g = goog.partial(f, 'asdf');\n"
+ "g() - 3;",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings("function f(x) {\n"
+ "  if (typeof x == 'function') {\n"
+ "    goog.bind(x, {}, 1, 2);\n"
+ "  }\n"
+ "}");
assertTrue(isValidPropertyName("a"));
assertTrue(isValidPropertyName("a3"));
assertFalse(isValidPropertyName("3a"));
assertFalse(isValidPropertyName("a."));
assertFalse(isValidPropertyName(".a"));
assertFalse(isValidPropertyName("a.b"));
assertFalse(isValidPropertyName("true"));
assertFalse(isValidPropertyName("a.true"));
assertFalse(isValidPropertyName("a..b"));
assertTrue(isValidQualifiedName("a"));
assertTrue(isValidQualifiedName("a3"));
assertFalse(isValidQualifiedName("3a"));
assertFalse(isValidQualifiedName("a."));
assertFalse(isValidQualifiedName(".a"));
assertTrue(isValidQualifiedName("a.b"));
assertFalse(isValidQualifiedName("true"));
assertFalse(isValidQualifiedName("a.true"));
assertFalse(isValidQualifiedName("a..b"));
static boolean isValidPropertyName(String s) {
return NodeUtil.isValidPropertyName(LanguageMode.ECMASCRIPT3, s);
static boolean isValidQualifiedName(String s) {
return NodeUtil.isValidQualifiedName(LanguageMode.ECMASCRIPT3, s);
new CollapseProperties(compiler, true).process(externs, root);
public void testFoldSubtractionAssignment() {
fold("x -= 1", "--x");
fold("x -= -1", "++x");
import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CLOSURE_CALL_ERROR;
import static com.google.javascript.jscomp.ProcessClosurePrimitives.WEAK_NAMESPACE_TYPE;
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
public void testProvideErrorCases2() {
test("goog.provide('foo'); /** @type {Object} */ var foo = {};",
"var foo={};", null, WEAK_NAMESPACE_TYPE);
test("goog.provide('foo'); /** @type {!Object} */ var foo = {};",
"var foo={};", null, WEAK_NAMESPACE_TYPE);
test("goog.provide('foo.bar'); /** @type {Object} */ foo.bar = {};",
"var foo={};foo.bar={};", null, WEAK_NAMESPACE_TYPE);
test("goog.provide('foo.bar'); /** @type {!Object} */ foo.bar = {};",
"var foo={};foo.bar={};", null, WEAK_NAMESPACE_TYPE);
test("goog.provide('foo'); /** @type {Object.<string>} */ var foo = {};",
"var foo={};");
public void testProvideValidObjectType() {
test("goog.provide('foo'); /** @type {Object.<string>} */ var foo = {};",
"var foo={};");
setAcceptedLanguage(LanguageMode.ECMASCRIPT5);
test("goog.provide('a.class');", "var a = {}; a.class = {};");
test("goog.provide('class.a');", null, INVALID_PROVIDE_ERROR);
setAcceptedLanguage(LanguageMode.ECMASCRIPT3);
test("goog.provide('class.a');", null, INVALID_PROVIDE_ERROR);
public void testInvalidRequire() {
test("goog.provide('a.b'); goog.require('a.b');", "var a = {}; a.b = {};");
test("goog.provide('a.b'); var x = x || goog.require('a.b');",
null, INVALID_CLOSURE_CALL_ERROR);
test("goog.provide('a.b'); x = goog.require('a.b');",
null, INVALID_CLOSURE_CALL_ERROR);
test("goog.provide('a.b'); function f() { goog.require('a.b'); }",
null, INVALID_CLOSURE_CALL_ERROR);
public void testValidGoogMethod() {
testSame("function f() { goog.isDef('a.b'); }");
testSame("function f() { goog.inherits(a, b); }");
testSame("function f() { goog.exportSymbol(a, b); }");
test("function f() { goog.setCssNameMapping({}); }", "function f() {}");
testSame("x || goog.isDef('a.b');");
testSame("x || goog.inherits(a, b);");
testSame("x || goog.exportSymbol(a, b);");
testSame("x || void 0");
public void testIndex() {
setFilename("foo/index.js");
test(
"var name = require('../name'); exports.bar = 1;",
"goog.provide('module$foo$index');" +
"var module$foo$index = {};" +
"goog.require('module$name');" +
"var name$$module$foo$index = module$name;" +
"module$foo$index.bar = 1;");
test("import name from 'test'; use(name);", Joiner.on('\n').join(
"goog.require('module$test.default');",
"goog.require('module$test');",
"use(module$test.default);"
test("import x, {f as foo, b as bar} from 'test'; use(x);", Joiner.on('\n').join(
"goog.require('module$test.default');",
"goog.require('module$test');",
"use(module$test.default);"
public void testImportStar() {
test("import * as name from 'test'; use(name.foo);",
"goog.require('module$test'); use(module$test.foo)");
test(
"var f = 1; var b = 2; export {f as foo, b as bar};",
Joiner.on('\n').join(
"goog.provide('module$testcode');",
"goog.provide('module$testcode.bar');",
"goog.provide('module$testcode.foo');",
"var f$$module$testcode = 1;",
"var b$$module$testcode = 2;",
"var module$testcode = {};",
"module$testcode.foo = f$$module$testcode;",
"module$testcode.bar = b$$module$testcode;"));
"import {name as n} from 'other';",
"use(n);",
"goog.require('module$other.name');",
"goog.require('module$other');",
"use(module$other.name);",
"module$testcode.name = module$other.name;"
public void testExportFrom() {
test("export {name} from 'other';", Joiner.on('\n').join(
"goog.provide('module$testcode');",
"goog.provide('module$testcode.name');",
"goog.require('module$other');",
"var module$testcode={};",
"module$testcode.name = module$other.name;"));
test("export {a, b as c, d} from 'other';", Joiner.on('\n').join(
"goog.provide('module$testcode');",
"goog.provide('module$testcode.d');",
"goog.provide('module$testcode.c');",
"goog.provide('module$testcode.a');",
"goog.require('module$other');",
"var module$testcode={};",
"module$testcode.a = module$other.a;",
"module$testcode.c = module$other.b;",
"module$testcode.d = module$other.d;"));
"/** @const */ module$testcode.Child = Child$$module$testcode;"
"/** @const */ module$testcode.Child = Child$$module$testcode;"
"/** @const */ module$testcode.Child = Child$$module$testcode;"
public void testCallSiteInteraction_constructors() {
private Style style;
style = Style.LEGACY;
style = Style.LEGACY;
style = Style.LEGACY;
"goog.log.info(,?)",
"goog.log.multiString(,?,?,)"
"goog.log.info = function(logger, msg, opt_ex) {};\n" +
"goog.log.multiString = function(logger, replace1, replace2, keep) {};\n"
new CollapseProperties(compiler, true).process(externs, js);
public void testLoggerWithSomeParametersNotReplaced() {
testDebugStrings(
"var x = {};" +
"x.logger_ = goog.log.getLogger('foo');" +
"goog.log.multiString(x.logger_, 'Some message', 'Some message2', " +
"'Do not replace');",
"var x$logger_ = goog.log.getLogger('a');" +
"goog.log.multiString(x$logger_, 'b', 'c', 'Do not replace');",
new String[] {
"a", "foo",
"b", "Some message",
"c", "Some message2"});
(new SanityCheck(compiler)).process(externs, root);
ScopedAliases.GOOG_SCOPE_MUST_BE_ALONE);
testFailure("var f = function() { goog.scope(function() {}); }",
ScopedAliases.GOOG_SCOPE_MUST_BE_IN_GLOBAL_SCOPE);
interpreter = new SemanticReverseAbstractInterpreter(registry);
public void testJSDocNameVisibility() {
getGlobalVar(table, "foo").getVisibility());
getGlobalVar(table, "bar").getVisibility());
getGlobalVar(table, "baz").getVisibility());
getGlobalVar(table, "quux").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "xyzzy").getVisibility());
assertNull(getGlobalVar(table, "xyzzy").getJSDocInfo());
public void testJSDocNameVisibilityWithFileOverviewVisibility() {
SymbolTable table = createSymbolTable(
"/** @fileoverview\n @package */\n" +
"/** @public */ var foo;\n" +
"/** @protected */ var bar;\n" +
"/** @package */ var baz;\n" +
"/** @private */ var quux;\n" +
"var xyzzy;");
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "foo").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "bar").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "baz").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "quux").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "xyzzy").getVisibility());
assertNull(getGlobalVar(table, "xyzzy").getJSDocInfo());
public void testJSDocPropertyVisibility() {
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "Foo.prototype.bar").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "Foo.prototype.baz").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.quux").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "Foo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "Foo.prototype.plugh").getVisibility());
assertNull(getGlobalVar(table, "Foo.prototype.plugh").getJSDocInfo());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.bar").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.baz").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.quux").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.plugh").getVisibility());
public void testJSDocPropertyVisibilityWithFileOverviewVisibility() {
SymbolTable table = createSymbolTable(
"/** @fileoverview\n @package */\n" +
"/** @constructor */ var Foo = function() {};\n" +
"/** @public */ Foo.prototype.bar;\n" +
"/** @protected */ Foo.prototype.baz;\n" +
"/** @package */ Foo.prototype.quux;\n" +
"/** @private */ Foo.prototype.xyzzy;\n" +
"Foo.prototype.plugh;\n" +
"/** @constructor @extends {Foo} */ var SubFoo = function() {};\n" +
"/** @override @public */ SubFoo.prototype.bar = function() {};\n" +
"/** @override @protected */ SubFoo.prototype.baz = function() {};\n" +
"/** @override @package */ SubFoo.prototype.quux = function() {};\n" +
"/** @override @private */ SubFoo.prototype.xyzzy = function() {};\n" +
"/** @override */ SubFoo.prototype.plugh = function() {};");
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "Foo.prototype.bar").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "Foo.prototype.baz").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.quux").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "Foo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.plugh").getVisibility());
assertNull(getGlobalVar(table, "Foo.prototype.plugh").getJSDocInfo());
getGlobalVar(table, "SubFoo.prototype.bar").getVisibility());
getGlobalVar(table, "SubFoo.prototype.baz").getVisibility());
getGlobalVar(table, "SubFoo.prototype.quux").getVisibility());
getGlobalVar(table, "SubFoo.prototype.xyzzy").getVisibility());
getGlobalVar(table, "SubFoo.prototype.plugh").getVisibility());
testTypes("/** @type Array<String> */var foo;");
"required: Enum<string>",
testTypes("/** @param {!Array<number>} a\n" +
testTypes("/** @param {!Array<!Array<number>>} a\n" +
"found   : Array<number>\n" +
testTypes("/** @param {!Array<number>} a\n" +
testTypes("/** @param {!Array<number>} a\n" +
testTypes("/** @param {!Array<*>} a\n" +
testTypes("/** @param {!Array<*>} a\n" +
testTypes("/** @param {?Array<number>} a\n" +
testTypes("/** @param {!Object<number>} a\n" +
testTypes("/** @param {!Object<string,number>} a\n" +
testTypes("/** @param {!Object<number,string>} a\n" +
"/** @param {!Object<E,string>} a\n" +
"required: E<string>");
"  /** @type {Object<number, string>} */ this.numbers = {};" +
"function (...?): undefined");
"function (?, ?, ?, ...?): undefined");
"function (this:Date, ?, ?, ?, ...?): undefined");
"/** @type {Object<E, string>} */ var obj = {};" +
"found   : E<string>\n" +
"/** @type {Object<number>} */ var obj = {};" +
"/** @type {Object<E, Array>} */ var obj = {};" +
"/** @type {Object<E, number>} */ var obj = {};" +
testTypes("/** @type {Array<string>} */ var a = [];" +
testTypes("/** @type {Array<undefined>} */ var a = [];" +
testTypes("/** @type {Array<undefined>} */ var a = [];" +
"found   : a<number>\n" +
"required: E<number>");
"found   : E<number>\n" +
"found   : E<(Object|null)>\n" +
"required: A<number>");
"required: a.b<number>");
"found   : MyEnum<number>\n" +
"found   : YourEnum<number>\n" +
"found   : MyEnum<string>\n" +
"found   : YourEnum<string>\n" +
"required: goog.MyEnum<number>");
"function (new:derived, ...?): ?");
" * @extends {C<string>} */\n" +
" * @implements {D<T>} */\n" +
"var e = /** @type {E<string>} */ (new E());\n" +
public void testGoodExtends20() throws Exception {
testTypes(""
+ "/** @interface */\n"
+ "var MyInterface = function() {};\n"
+ "MyInterface.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @extends {MyInterface}\n * @interface */\n"
+ "var MyOtherInterface = function() {};\n"
+ "MyOtherInterface.prototype = {\n"
+ "  /** @return {number} \n @override */\n"
+ "  method: function() {}\n"
+ "}");
public void testGoodExtends21() throws Exception {
testTypes(""
+ "/** @constructor */\n"
+ "var MyType = function() {};\n"
+ "MyType.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @constructor \n"
+ " *  @extends {MyType}\n"
+ " */\n"
+ "var MyOtherType = function() {};\n"
+ "MyOtherType.prototype = {\n"
+ "  /** @return {number}\n"
+ "   * @override */\n"
+ "  method: function() {}\n"
+ "}");
public void testBadExtends5() throws Exception {
testTypes(""
+ "/** @interface */\n"
+ "var MyInterface = function() {};\n"
+ "MyInterface.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @extends {MyInterface}\n * @interface */\n"
+ "var MyOtherInterface = function() {};\n"
+ "MyOtherInterface.prototype = {\n"
+ "  /** @return {string} \n @override */\n"
+ "  method: function() {}\n"
+ "}",
""
+ "mismatch of the method property type and the type of the property "
+ "it overrides from superclass MyInterface\n"
+ "original: function (this:MyInterface): number\n"
+ "override: function (this:MyOtherInterface): string");
public void testBadExtends6() throws Exception {
testTypes(""
+ "/** @constructor */\n"
+ "var MyType = function() {};\n"
+ "MyType.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @constructor \n"
+ " *  @extends {MyType}\n"
+ " */\n"
+ "var MyOtherType = function() {};\n"
+ "MyOtherType.prototype = {\n"
+ "  /** @return {string}\n"
+ "   * @override */\n"
+ "  method: function() { return ''; }\n"
+ "}",
""
+ "mismatch of the method property type and the type of the property "
+ "it overrides from superclass MyType\n"
+ "original: function (this:MyType): number\n"
+ "override: function (this:MyOtherType): string");
public void testGoodImplements8() throws Exception {
testTypes(""
+ "/** @interface */\n"
+ "MyInterface = function() {};\n"
+ "MyInterface.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @implements {MyInterface}\n * @constructor */\n"
+ "MyClass = function() {};\n"
+ "MyClass.prototype = {\n"
+ "  /** @return {number} \n @override */\n"
+ "  method: function() { return 0; }\n"
+ "}");
public void testBadImplements7() throws Exception {
testTypes(""
+ "/** @interface */\n"
+ "MyInterface = function() {};\n"
+ "MyInterface.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @implements {MyInterface}\n * @constructor */\n"
+ "MyClass = function() {};\n"
+ "MyClass.prototype = {\n"
+ "  /** @return {string} \n @override */\n"
+ "  method: function() { return ''; }\n"
+ "}",
""
+ "mismatch of the method property type and the type of the property "
+ "it overrides from interface MyInterface\n"
+ "original: function (): number\n"
+ "override: function (): string");
public void testBadImplements8() throws Exception {
testTypes(""
+ "/** @interface */\n"
+ "MyInterface = function() {};\n"
+ "MyInterface.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() {}\n"
+ "}\n"
+ "/** @implements {MyInterface}\n * @constructor */\n"
+ "MyClass = function() {};\n"
+ "MyClass.prototype = {\n"
+ "  /** @return {number} */\n"
+ "  method: function() { return 0; }\n"
+ "}",
""
+ "property method already defined on interface MyInterface; "
+ "use @override to override it");
public void testProtoDoesNotRequireOverrideFromInterface() throws Exception {
testTypes(DEFAULT_EXTERNS + "/** @type {Object} */ Object.prototype.__proto__;",
"/** @interface */\n"
+ "var MyInterface = function() {};\n"
+ "/** @constructor\n @implements {MyInterface} */\n"
+ "var MySuper = function() {};\n"
+ "/** @constructor\n @extends {MySuper} */\n"
+ "var MyClass = function() {};\n"
+ "MyClass.prototype = {\n"
+ "  __proto__: MySuper.prototype\n"
+ "}",
(String) null,
false);
" * @implements {Foo<?>}\n" +
" * @implements {Foo<string>}\n" +
" * @implements {Foo<number>}\n" +
"after it is constructed.",
"Property x never defined on Foo"
"after it is constructed.",
"Property x never defined on Foo"
"original: function (this:Foo, ...number): undefined\n" +
"original: function (...number): ?\n" +
" * @extends {Foo<string>}\n" +
"/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}" +
"/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}" +
"var list = /** @type {!Array<string>} */ ['hello', 'you'];\n" +
reportMissingOverrides = CheckLevel.OFF;
" * @param {Array<T>} x\n" +
"/** @typedef {Object<string, number>} */" +
"/** @typedef {Object<string, number>} */" +
"var foo = /** @type {Foo<string>} */ (new Foo());\n" +
public void testFunctionBind6() throws Exception {
testTypes(Joiner.on('\n').join(
"/** @constructor */",
"function MyType() {",
"  /** @type {number} */",
"  this.x = 0;",
"  var f = function() {",
"    this.x = 'str';",
"  }.bind(this);",
"}"), Joiner.on('\n').join(
"assignment to property x of MyType",
"found   : string",
"required: number"));
public void testFunctionBind7() throws Exception {
testTypes(Joiner.on('\n').join(
"/** @constructor */",
"function MyType() {",
"  /** @type {number} */",
"  this.x = 0;",
"}",
"var m = new MyType;",
"(function f() {this.x = 'str';}).bind(m);"),
Joiner.on('\n').join(
"assignment to property x of MyType",
"found   : string",
"required: number"));
public void testFunctionBind8() throws Exception {
testTypes(Joiner.on('\n').join(
"/** @constructor */",
"function MyType() {}",
"",
"/** @constructor */",
"function AnotherType() {}",
"AnotherType.prototype.foo = function() {};",
"",
"/** @type {?} */",
"var m = new MyType;",
"(function f() {this.foo();}).bind(m);"),
(DiagnosticType) null);
public void testFunctionBind9() throws Exception {
testTypes(Joiner.on('\n').join(
"/** @constructor */",
"function MyType() {}",
"",
"/** @constructor */",
"function AnotherType() {}",
"AnotherType.prototype.foo = function() {};",
"",
"var m = new MyType;",
"(function f() {this.foo();}).bind(m);"),
TypeCheck.INEXISTENT_PROPERTY);
"/** @type {!Array<!A>} */ var x = " +
"/** @type {!Array<?>} */( /** @type {!Array<!B>} */([]) );");
" * @param {!C<T>} c\n" +
"/** @type {!C<!A>} */\n" +
"/** @interface\n @template U\n @extends {A<U>} */function B() {};" +
"/** @constructor\n @implements {B<string>} */function C() {};" +
"/** @interface\n @template U\n @extends {A<U>} */function B() {};" +
"/** @constructor\n @template V\n @implements {B<V>}\n */function C() {};" +
"/** @constructor\n @implements {A<string>} */function B() {};" +
"/** @constructor\n @implements {Int<string>} */function Foo() {};" +
"/** @typedef {number|Array<goog.Bar>} */ goog.Bar;" +
reportMissingOverrides = CheckLevel.OFF;
new SemanticReverseAbstractInterpreter(registry),
" * @this {Array<T>|{length:number}}\n" +
" * @param {Array<T>} arr \n" +
"/** @param {Array<number>} arr */ function g(arr) {" +
"/** @type {!Array<string>} */\n" +
" * @param {Bar<T>} bar \n" +
"/** @param {Bar<number>} bar */ function g(bar) {" +
" * @param {Bar<T>} bar \n" +
"/** @param {Bar<number>} bar */ function g(bar) {" +
"/** @type {!Bar<?>} */ var x;" +
"/** @type {!Bar<number>} */ var y;" +
" * @extends {Foo<string>}\n" +
" * @extends {Foo<number>}\n" +
"/** @type {!Foo<string>} */ var a = new A();\n" +
"/** @type {!Foo<string>} */ var b = new B();",
"required: Foo<string>");
" * @implements {Foo<string>}\n" +
" * @implements {Foo<number>}\n" +
"/** @type {!Foo<string>} */ var a = new A();\n" +
"/** @type {!Foo<string>} */ var b = new B();",
"required: Foo<string>");
" * @extends {Foo<T>}\n" +
"var a2 = /** @type {!A<string>} */ (new A());\n" +
"var a3 = /** @type {!A<number>} */ (new A());\n" +
"/** @type {!Foo<string>} */ var f1 = a1;\n" +
"/** @type {!Foo<string>} */ var f2 = a2;\n" +
"/** @type {!Foo<string>} */ var f3 = a3;",
"found   : A<number>\n" +
"required: Foo<string>");
" * @implements {Foo<T>}\n" +
"var a2 = /** @type {!A<string>} */ (new A());\n" +
"var a3 = /** @type {!A<number>} */ (new A());\n" +
"/** @type {!Foo<string>} */ var f1 = a1;\n" +
"/** @type {!Foo<string>} */ var f2 = a2;\n" +
"/** @type {!Foo<string>} */ var f3 = a3;",
"found   : A<number>\n" +
"required: Foo<string>");
"/** @constructor @implements {A<Foo>} */\n" +
"/** @constructor @implements {A<Bar>} */\n" +
"/** @constructor @implements {A<Foo>} */\n" +
"/** @constructor @implements {B<Foo>} */\n" +
"/** @constructor @implements {B<Foo>} */\n" +
"/** @constructor @implements {A<Foo>} */\n" +
"/** @type {Generic<!Foo>} */ var x;\n" +
"/** @type {Generic<!Bar>} */ var y;\n" +
"found   : (Generic<Foo>|null)\n" +
"/** @type {Generic<!Foo>} */ var x;\n" +
"/** @type {Generic<!Bar>} */ var y;\n" +
"found   : (Generic<Foo>|null)\n" +
"function f(/** Generic<!Bar> */ x) {}\n" +
"/** @type {Generic<!Foo>} */ var x;\n" +
"function f(/** Generic<!Bar> */ x) {}\n" +
"/** @type {Generic<!Bar>} */ var x;\n" +
"function f(/** Generic<!Foo> */ x) {}\n" +
"/** @type {Generic<!Foo>} */ var x;\n" +
"function f(/** Generic<!Foo> */ x) {}\n" +
"/** @type {Generic<!Bar>} */ var x;\n" +
"/** @interface \n @extends {Int0<number>} \n @extends {Int1<string>} */" +
"super interfaces Int0<number> and Int1<string>");
"/** @type {!Array<string>} */" +
"/** @type {!Array<string>} */" +
" * @param {!Array<T>} arr\n" +
" * @return {!Array<T>}\n" +
"/** @type {!Array<string>} */" +
"/** @type {!Array<string>} */" +
" * @param {!Array<T>} arr\n" +
" * @return {!Array<T>}\n" +
"/** @type {!Array<string>} */" +
"/** @type {!Array<number>} */" +
"found   : Array<string>\n" +
"required: Array<number>");
" * @param {Array<T>} arr\n" +
" * @return {Array<T>}\n" +
"/** @type {Array<string>} */" +
"/** @type {Array<number>} */" +
"found   : (Array<string>|null)\n" +
"required: (Array<number>|null)");
"/** @type {Array<string>} */" +
"/** @type {!Array<number>} */" +
"found   : Array<string>\n" +
"required: Array<number>");
"/** @type {Array<string>} */" +
"/** @type {Array<string>} */ var arr;\n" +
"/** @type {Array<string>} */ var arr;\n" +
"/** @type {!Array<string>} */" +
"/** @type {!Array<number>} */" +
"found   : Array<number>\n" +
"required: Array<string>");
"/** @type {!Array<string>} */" +
"var arr1 = /** @type {!Array<number>} */([]);\n",
"found   : Array<number>\n" +
"required: Array<string>");
"/** @type {Array<string>} */" +
"var arr1 = /** @type {!Array<number>} */([]);\n",
"found   : Array<number>\n" +
"required: (Array<string>|null)");
"/** @type {Array<string>} */" +
"/** @type {Array<number>} */" +
"found   : (Array<string>|null)\n" +
"required: (Array<number>|null)");
" * @param {Object<T>} obj\n" +
"/** @return {!Array<string>} */ function g() { return []; }" +
" * @implements {I<number>}\n" +
" *  @implements {I<R>}\n" +
"/** @type {C<number>} var x = new C();" +
" *  @implements {I<R>}\n" +
" * @extends {Parent<string>}\n" +
"  /** @type {!X<boolean>}*/\n" +
"found   : X<boolean>\n" +
new ClosureReverseAbstractInterpreter(registry).append(
new SemanticReverseAbstractInterpreter(registry))
new SemanticReverseAbstractInterpreter(registry),
"var x = /** @type {!Array<number>} */ ([]);\n" +
assertEquals("F<Array<number>>", getType("result").toString());
" * @param {Array<T>} x\n" +
"var x = /** @type {!Array<number>} */ ([]);\n" +
assertEquals("F<(number|string),boolean>", getType("result").toString());
+ "/** @type {{foo:!Array<number>}} */"
+ "/** @type {!Array<number>} */"
public void testTransformationWithMultipleTypeVars() {
assertEquals("Foo<number>", f.getPropertyType("BAR").toString());
assertEquals("Foo<number>", bar.getType().toString());
assertEquals("Foo<number>",
assertEquals("Foo<number>", f.getPropertyType("BAR").toString());
assertEquals("goog.Foo<number>",
"/** @type {!Array<string>} */\n" +
assertEquals("Array<string>", resultType.toString());
" * @param {Array<T>} arr\n" +
" * @return {!Array<T>}\n" +
"/** @type {Array<string>} */\n" +
assertEquals("Array<string>", findNameTypeStr("result", globalScope));
" * @param {Array<T>|string|undefined} arr\n" +
" * @return {!Array<T>}\n" +
"/** @type {Array<string>} */\n" +
assertEquals("Array<string>", findNameTypeStr("result", globalScope));
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, !T, number, !Array<!T>):boolean} f\n" +
" * @return {!Array<T>}\n" +
"/** @type {Array<string>} */\n" +
assertEquals("Array<string>",
assertEquals("Array<string>",
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, !T, number, !Array<T>):boolean} f\n" +
" * @return {!Array<T>}\n" +
"/** @type {Array<string>} */\n" +
assertEquals("Array<string>",
assertEquals("Array<string>",
" * @param {Array<T>} arr\n" +
" * @param {function(this:S, T, number, Array<T>):boolean} f\n" +
" * @return {!Array<T>}\n" +
"/** @type {Array<string>} */\n" +
assertEquals("(Array<string>|null)",
assertEquals("Array<string>",
" * @typedef {Array<T>|NodeList|Arguments|{length: number}}\n" +
" * @this {Array<T>|{length:number}}\n" +
assertEquals("(Array<T>|{length: number})",
"/** @type {C<string>} */ var x = new C();\n" +
"/** @type {ns.C<string>} */ var x = new ns.C();\n" +
"/** @type {C<string>} */ var x = new C();\n" +
"/** @type {ns.C<string>} */ var x = new ns.C();\n" +
"/** @type {C<string>} */ var x = new C();\n" +
"/** @type {C<string>} */ var x = new C();\n" +
" * @extends {C<U>}" +
"/** @type {D<string, number>} */ var x = new D();\n" +
" * @extends {C<U>}" +
"/** @type {D<boolean, string>} */ var x = new D();\n" +
"/** @type {D<boolean>} */ var x = new D();\n" +
" * @extends {C<U>}" +
"/** @type {D<boolean, string>} */ var x = new D();\n" +
" * @extends {C<U>}" +
"/** @type {D<string, boolean>} */ var x = new D();\n" +
"/** @type {C<boolean>} */ var y = x;\n" +
public void testUselessUnconditionalBreak() {
VariableMap out = VariableMap.fromBytes(serialized.getBytes(UTF_8));
VariableMap vm = VariableMap.fromBytes("AAA:a\nBBB:b\n".getBytes(UTF_8));
new VariableMap(ImmutableMap.of("x\ny", "a")).toBytes(), "x\\ny:a\n".getBytes(UTF_8));
new VariableMap(ImmutableMap.of("x:y", "a")).toBytes(), "x\\:y:a\n".getBytes(UTF_8));
new VariableMap(ImmutableMap.of("x\ny", "a")).toBytes(), "x\\ny:a\n".getBytes(UTF_8));
new VariableMap(ImmutableMap.of("x\\y", "a")).toBytes(), "x\\\\y:a\n".getBytes(UTF_8));
assertEqual(new VariableMap(ImmutableMap.of("\n", "a")).toBytes(), "\\n:a\n".getBytes(UTF_8));
assertEqual(new VariableMap(ImmutableMap.of(":", "a")).toBytes(), "\\::a\n".getBytes(UTF_8));
assertEqual(new VariableMap(ImmutableMap.of("\n", "a")).toBytes(), "\\n:a\n".getBytes(UTF_8));
assertEqual(new VariableMap(ImmutableMap.of("\\", "a")).toBytes(), "\\\\:a\n".getBytes(UTF_8));
assertEqual(in.toBytes(), "AAA['\\:f']:a\n".getBytes(UTF_8));
VariableMap vm = VariableMap.fromBytes("AAA['\\:f']:a\n".getBytes(UTF_8));
public void testNonExistentProvideLoose() throws Exception {
public void testNonExistentProvideStrict() throws Exception {
import static org.junit.Assert.assertEquals;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import java.util.Map.Entry;
JsonObject config = TestConfig.getConfig();
JsonObject config = fuzzer.getOwnConfig();
code.split(",").length
< (int) (config.get("maxLength").getAsDouble()
public void testGenerateLiteral() throws JsonParseException {
public void testPostfixExpressions() throws JsonParseException {
public void testPrefixExpressions() throws JsonParseException {
public void testNewExpression() throws JsonParseException {
public void testCallExpression() throws JsonParseException {
public void testGenerateBinaryExpression() throws JsonParseException {
public void testBreakStatement() throws JsonParseException {
fuzzer.getOwnConfig().addProperty("toLabel", 1);
public void testContinueStatement() throws JsonParseException {
fuzzer.getOwnConfig().addProperty("toLabel", 1);
private static void leaveOneSubtype(JsonObject typeConfig, String subtypeName)
throws JsonParseException {
JsonObject weightConfig = typeConfig.get("weights").getAsJsonObject();
for (Entry<String, JsonElement> entry : weightConfig.entrySet()) {
String name = entry.getKey();
weightConfig.addProperty(name, 1);
weightConfig.addProperty(name, 0);
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
static JsonObject getConfig() {
String json =
"    }\n" +
"}";
return new Gson().fromJson(json, JsonObject.class);
import org.junit.Assert;
package com.google.javascript.jscomp.lint;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerPass;
import com.google.javascript.jscomp.CompilerTestCase;
import com.google.javascript.jscomp.DiagnosticType;
public class CheckEnumsTest extends CompilerTestCase {
public CompilerPass getProcessor(Compiler compiler) {
return new CheckEnums(compiler);
public void testCheckEnums() throws Exception {
testOk("/** @enum {number} */ ns.Enum = {A: 1, B: 2};");
testOk("/** @enum {string} */ ns.Enum = {A: 'foo', B: 'bar'};");
testSame("/** @enum {number} */ ns.Enum = {A: 1, B: 1};",
CheckEnums.DUPLICATE_ENUM_VALUE);
testSame("/** @enum {string} */ ns.Enum = {A: 'foo', B: 'foo'};",
CheckEnums.DUPLICATE_ENUM_VALUE);
testOk("/** @enum {number} */ var Enum = {A: 1, B: 2};");
testOk("/** @enum {string} */ var Enum = {A: 'foo', B: 'bar'};");
testSame("/** @enum {number} */ var Enum = {A: 1, B: 1};",
CheckEnums.DUPLICATE_ENUM_VALUE);
testSame("/** @enum {string} */ var Enum = {A: 'foo', B: 'foo'};",
CheckEnums.DUPLICATE_ENUM_VALUE);
private void testOk(String js) {
test(js, js, null, (DiagnosticType) null);
package com.google.javascript.jscomp.lint;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerPass;
import com.google.javascript.jscomp.CompilerTestCase;
public class CheckInterfacesTest extends CompilerTestCase {
public CompilerPass getProcessor(Compiler compiler) {
return new CheckInterfaces(compiler);
public void setUp() {
enableTypeCheck(CheckLevel.ERROR);
public void testInterfaceArgs() throws Exception {
testSame("/** @interface */ function A(x) {}",
CheckInterfaces.INTERFACE_SHOULD_NOT_TAKE_ARGS);
testSame("var ns = {};\n"
+ "/** @interface */\n"
+ "ns.SomeInterface = function(x) {};",
CheckInterfaces.INTERFACE_SHOULD_NOT_TAKE_ARGS);
public void testInterfaceNotEmpty() {
testSame("/** @interface */ function A() { this.foo; }",
CheckInterfaces.INTERFACE_FUNCTION_NOT_EMPTY);
testSame("var ns = {};\n"
+ "/** @interface */\n"
+ "ns.SomeInterface = function() { this.foo; };",
CheckInterfaces.INTERFACE_FUNCTION_NOT_EMPTY);
package com.google.javascript.jscomp.lint;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.CompilerPass;
import com.google.javascript.jscomp.CompilerTestCase;
import com.google.javascript.jscomp.DiagnosticGroups;
import java.io.IOException;
public class CheckNullableReturnTest extends CompilerTestCase {
private static String externs = "/** @constructor */ function SomeType() {}";
public void setUp() throws IOException {
enableTypeCheck(CheckLevel.ERROR);
protected CompilerPass getProcessor(Compiler compiler) {
return new CheckNullableReturn(compiler);
protected CompilerOptions getOptions(CompilerOptions options) {
super.getOptions(options);
options.setWarningLevel(DiagnosticGroups.LINT_CHECKS, CheckLevel.WARNING);
return options;
protected int getNumRepetitions() {
return 1;
public void testSimpleWarning() {
testError(""
+ "/** @return {SomeType} */\n"
+ "function f() {\n"
+ "  return new SomeType();\n"
+ "}");
public void testNullableReturn() {
testBodyOk("return null;");
testBodyOk("if (a) { return null; } return {};");
testBodyOk("switch(1) { case 12: return null; } return {};");
testBodyOk(
"/** @return {number} */ function f() { var x; }; return null;");
public void testNotNullableReturn()  {
testBodyOk("");
testBodyError("return {};");
testBodyOk("throw new Error('Not implemented');");
testBodyError(
"/** @return {number} */ function f() { return 1; }; return {};");
testBodyError("switch(1) { default: return {}; } return null;");
testBodyError("switch(g) { case 1: return {}; default: return {}; } return null;");
public void testFinallyStatements() {
testBodyOk("try { return null; } finally { }");
testBodyOk("try { } finally { return null; }");
testBodyOk("try { return {}; } finally { return null; }");
testBodyOk("try { return null; } finally { return {}; }");
testBodyError("try { } catch (e) { return null; } finally { return {}; }");
public void testKnownConditions() {
testBodyOk("if (true) return {}; return null;");
testBodyOk("if (true) return null; else return {};");
testBodyOk("if (false) return {}; return null;");
testBodyOk("if (false) return null; else return {};");
testBodyError("if (1) return {}");
testBodyOk("if (1) { return null; } else { return {}; }");
testBodyOk("if (0) return {}; return null;");
testBodyOk("if (0) { return null; } else { return {}; }");
testBodyError("if (3) return {}");
testBodyOk("if (3) return null; else return {};");
public void testKnownWhileLoop() {
testBodyError("while (1) return {}");
testBodyError("while (1) { if (x) { return {}; } else { return {}; }}");
testBodyError("while (0) {} return {}");
testBodyError("while(x) { return {}; }");
public void testTwoBranches() {
testError(""
+ "/** @return {SomeType} */\n"
+ "function f() {\n"
+ "  if (foo) {\n"
+ "    return new SomeType();\n"
+ "  } else {\n"
+ "    return new SomeType();\n"
+ "  }\n"
+ "}");
public void testTryCatch() {
testError(""
+ "/** @return {SomeType} */\n"
+ "function f() {\n"
+ "  try {\n"
+ "    return new SomeType();\n"
+ "  } catch (e) {\n"
+ "    return new SomeType();\n"
+ "  }\n"
+ "}");
testBodyOk(""
+ "try {\n"
+ "  if (a) throw '';\n"
+ "} catch (e) {\n"
+ "  return null;\n"
+ "}\n"
+ "return {}");
testBodyOk(""
+ "try {\n"
+ "  return bar();\n"
+ "} catch (e) {\n"
+ "} finally { }");
public void testNoExplicitReturn() {
testError(""
+ "/** @return {SomeType} */\n"
+ "function f() {\n"
+ "  if (foo) {\n"
+ "    return new SomeType();\n"
+ "  }\n"
+ "}");
public void testNoWarningIfCanReturnNull() {
testOk(""
+ "/** @return {SomeType} */\n"
+ "function f() {\n"
+ "  if (foo) {\n"
+ "    return new SomeType();\n"
+ "  } else {\n"
+ "    return null;\n"
+ "  }\n"
+ "}");
public void testNoWarningOnEmptyFunction() {
testOk(""
+ "/** @return {SomeType} */\n"
+ "function f() {}");
public void testNoWarningOnXOrNull() {
testOk(""
+ "/**\n"
+ " * @param {!Array.<!Object>} arr\n"
+ " * @return {Object}\n"
+ " */\n"
+ "function f4(arr) {\n"
+ "  return arr[0] || null;\n"
+ "}");
private static String createFunction(String body) {
return "/** @return {?Object} */ function foo() {" + body + "}";
private void testOk(String js) {
testSame(externs, js, null);
private void testError(String js) {
testSame(externs, js, CheckNullableReturn.NULLABLE_RETURN_WITH_NAME);
private void testBodyOk(String body) {
testOk(createFunction(body));
private void testBodyError(String body) {
testError(createFunction(body));
package com.google.javascript.jscomp.lint;
import static com.google.javascript.jscomp.lint.CheckPrototypeProperties.ILLEGAL_PROTOTYPE_MEMBER;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.CompilerPass;
import com.google.javascript.jscomp.CompilerTestCase;
import com.google.javascript.jscomp.DiagnosticGroups;
public class CheckPrototypePropertiesTest extends CompilerTestCase {
protected CompilerPass getProcessor(Compiler compiler) {
return new CheckPrototypeProperties(compiler);
protected CompilerOptions getOptions(CompilerOptions options) {
super.getOptions(options);
options.setWarningLevel(DiagnosticGroups.LINT_CHECKS, CheckLevel.WARNING);
return options;
public void testNoWarning() {
testSame("function C() {}; C.prototype.foo = null;");
testSame("function C() {}; C.prototype.foo = undefined;");
testSame("function C() {}; C.prototype.foo;");
testSame("function C() {}; C.prototype.foo = 0;");
testSame("function C() {}; C.prototype.foo = 'someString';");
testSame("function C() {}; C.prototype.foo = function() {};");
public void testWarnings() {
testSame("function C() {}; C.prototype.foo = [];", ILLEGAL_PROTOTYPE_MEMBER);
testSame("function C() {}; C.prototype.foo = {};", ILLEGAL_PROTOTYPE_MEMBER);
testParseType("function (...number): boolean");
public void testParseFunctionalType4a() throws Exception {
testParseType("function (...[number]): boolean",
"function (...number): boolean");
testParseType("function (number, ...string): boolean");
public void testParseFunctionalType5a() throws Exception {
testParseType("function (number, ...[string]): boolean",
"function (number, ...string): boolean");
"function (this:Array, ...boolean): ?");
"function (this:Array, Date, ...(boolean|null)): ?");
"function (...(Object|null)): (boolean|null)");
"function (...?): ?");
"function (...?): undefined");
"function(...?): void",
"function (...?): undefined");
"Bad type annotation. missing closing )");
"Bad type annotation. type not recognized due to syntax error");
"Bad type annotation. type not recognized due to syntax error");
"Bad type annotation. type not recognized due to syntax error");
public void testParseArrayTypeError5() throws Exception {
parse("@type {[Object]}*/",
"Bad type annotation. type not recognized due to syntax error");
public void testBadSuppress8() throws Exception {
parse("@suppress */", "malformed @suppress tag");
import static com.google.javascript.jscomp.parsing.NewIRFactory.MISPLACED_FUNCTION_ANNOTATION;
import static com.google.javascript.jscomp.parsing.NewIRFactory.MISPLACED_TYPE_ANNOTATION;
public void testThrow() {
parse("throw Error();");
parse("throw new Error();");
parse("throw '';");
parseError("throw;", "semicolon/newline not allowed after 'throw'");
parseError("throw\nError();", "semicolon/newline not allowed after 'throw'");
Node functionNode = parseWarning(
"var a = /** @param {number} index */5;"
+ "/** @return boolean */function f(index){}",
MISPLACED_FUNCTION_ANNOTATION)
public void testJSDocAttachment21() {
mode = LanguageMode.ECMASCRIPT6;
parse("/** @param {string} x */ const f = function() {};");
parse("/** @param {string} x */ let f = function() {};");
createScript(new Node(Token.VAR, a)))
parseError("var [x,] = ['x',];", "Array pattern may not end with a comma");
parseError("var [first, ...more, last] = foo();", "']' expected");
parseError("var [first, ...[re, st]] = foo();", "lvalues in rest elements must be identifiers");
parseError("var {{x}} = foo();", "'}' expected");
parseError("var {[x]} = z;", "':' expected");
parseError("var { 'hello world' } = foo();", "':' expected");
parseError("var { 4 } = foo();", "':' expected");
parseError("var { 'hello' = 'world' } = foo();", "':' expected");
parseError("var { 2 = 5 } = foo();", "':' expected");
parseError("var {while} = foo();", "cannot use keyword 'while' here.");
parseError("var {implements} = foo();", "cannot use keyword 'implements' here.");
parseError("var {foo: bar.x} = baz();", "'}' expected");
parseError("var {foo: bar[x]} = baz();", "'}' expected");
public void testStringLineContinuation() {
Node n = parseError("'one\\\ntwo';",
assertEquals("onetwo", n.getFirstChild().getFirstChild().getString());
parseWarning("'one\\\ntwo';", "String continuations are not recommended. See"
+ " https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Multiline_string_literals");
assertEquals("onetwo", n.getFirstChild().getFirstChild().getString());
parseWarning("'one\\\ntwo';", "String continuations are not recommended. See"
+ " https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Multiline_string_literals");
assertEquals("onetwo", n.getFirstChild().getFirstChild().getString());
public void testStringLiteral() {
Node n = parse("'foo'");
Node stringNode = n.getFirstChild().getFirstChild();
assertEquals(Token.STRING, stringNode.getType());
assertEquals("foo", stringNode.getString());
private Node testTemplateLiteral(String s) {
return parse(s);
public void testTemplateLiteralWithLineContinuation() {
mode = LanguageMode.ECMASCRIPT6;
Node n = parseWarning("`string \\\ncontinuation`",
"String continuations are not recommended. See"
+ " https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Multiline_string_literals");
Node templateLiteral = n.getFirstChild().getFirstChild();
Node stringNode = templateLiteral.getFirstChild();
assertEquals(Token.STRING, stringNode.getType());
assertEquals("string continuation", stringNode.getString());
public void testArrowInvalid() {
parseError("var f = x\n=>2", "No newline allowed before '=>'");
parseError("f = (x,y)\n=>2;", "No newline allowed before '=>'");
parseError("f( (x,y)\n=>2)", "No newline allowed before '=>'");
parse("import {} from './someModule'");
parse("import {x as x1, y as y1, } from './someModule'");
parse("import * as sm from './someModule'");
import com.google.common.collect.Iterables;
public void testApplySuggestedFixes_insideJSDoc() throws Exception {
String code = "/** @type {Foo} */\nvar foo = new Foo()";
Compiler compiler = getCompiler(code);
Node root = compileToScriptRoot(compiler);
Node varNode = root.getFirstChild();
Node jsdocRoot =
Iterables.getOnlyElement(varNode.getJSDocInfo().getTypeNodes());
SuggestedFix fix = new SuggestedFix.Builder()
.insertBefore(jsdocRoot, "!")
.build();
List<SuggestedFix> fixes = ImmutableList.of(fix);
Map<String, String> codeMap = ImmutableMap.of("test", code);
Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
fixes, codeMap);
assertEquals(1, newCodeMap.size());
assertEquals("/** @type {!Foo} */\nvar foo = new Foo()", newCodeMap.get("test"));
public void testApplySuggestedFixes_multipleFixesInJsdoc() throws Exception {
String code = "/** @type {Array<Foo>} */\nvar arr = [new Foo()];";
Compiler compiler = getCompiler(code);
Node root = compileToScriptRoot(compiler);
Node varNode = root.getFirstChild();
Node jsdocRoot =
Iterables.getOnlyElement(varNode.getJSDocInfo().getTypeNodes());
SuggestedFix fix1 = new SuggestedFix.Builder()
.insertBefore(jsdocRoot, "!")
.build();
Node foo = jsdocRoot.getFirstChild().getFirstChild();
SuggestedFix fix2 = new SuggestedFix.Builder()
.insertBefore(foo, "!")
.build();
List<SuggestedFix> fixes = ImmutableList.of(fix1, fix2);
Map<String, String> codeMap = ImmutableMap.of("test", code);
Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
fixes, codeMap);
assertEquals(1, newCodeMap.size());
assertEquals("/** @type {!Array<!Foo>} */\nvar arr = [new Foo()];",
newCodeMap.get("test"));
package com.google.javascript.refactoring;
import static com.google.javascript.jscomp.CheckLevel.ERROR;
import static com.google.javascript.refactoring.testing.SuggestedFixes.assertReplacement;
import static org.junit.Assert.assertEquals;
import com.google.common.collect.ImmutableList;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.DiagnosticGroups;
import com.google.javascript.jscomp.JSError;
import com.google.javascript.jscomp.SourceFile;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import java.util.Arrays;
public class ErrorToFixMapperTest {
public void testDebugger() {
String before = "function f() { ";
String after = "debugger; }";
Compiler compiler = getCompiler(before + after);
JSError[] errors = compiler.getErrors();
assertEquals(Arrays.toString(errors), 1, errors.length);
SuggestedFix fix = ErrorToFixMapper.getFixForJsError(errors[0], compiler);
CodeReplacement replacement = new CodeReplacement(before.length(), "debugger;".length(), "");
assertReplacement(fix, replacement);
public void testRemoveCast() {
String before = "var x = ";
String after = "/** @type {string} */ ('foo');";
Compiler compiler = getCompiler(before + after);
JSError[] errors = compiler.getErrors();
assertEquals(Arrays.toString(errors), 1, errors.length);
SuggestedFix fix = ErrorToFixMapper.getFixForJsError(errors[0], compiler);
CodeReplacement replacement = new CodeReplacement(
before.length(),
after.length() - 1,  // Leave the ";" alone.
"'foo'");
assertReplacement(fix, replacement);
private Compiler getCompiler(String jsInput) {
Compiler compiler = new Compiler();
CompilerOptions options = getCompilerOptions();
compiler.compile(
ImmutableList.<SourceFile>of(), // Externs
ImmutableList.of(SourceFile.fromCode("test", jsInput)),
options);
return compiler;
private CompilerOptions getCompilerOptions() {
CompilerOptions options = RefactoringDriver.getCompilerOptions();
options.setWarningLevel(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT, ERROR);
options.setWarningLevel(DiagnosticGroups.UNNECESSARY_CASTS, ERROR);
return options;
import com.google.common.collect.ImmutableMap;
String originalCode = "var loc = 'str';";
String expectedCode = "'bar';";
assertChanges("", originalCode, expectedCode, template);
+ "function foo() {}\n"
+ "/** @type {Location} var loc;";
String originalCode = "loc.href = 'str';";
String expectedCode = "foo();";
assertChanges(externs, originalCode, expectedCode, template);
+ "FooType.prototype.bar = function() {};\n"
+ "var obj = new FooType();";
String originalCode = "obj.bar();";
String expectedCode = "obj.baz();";
String template = ""
assertChanges(externs, originalCode, expectedCode, template);
String preamble = "var obj = new FooType();\n";
String postamble = "var someOtherCode = 3;\n";
String originalCode = ""
+ preamble
+ "obj.bar();\n"
+ "obj.baz();\n"
+ postamble;
String expectedCode = preamble + "\n\n" + postamble;
String template = ""
+ "/**\n"
+ " * @param {FooType} foo\n"
+ " */\n"
+ "function after_foo(foo) {\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_replaceFunctionArgument() throws Exception {
String externs = ""
+ "/** @constructor */\n"
+ "function MyClass() {};\n"
+ "MyClass.prototype.foo = function() {};\n"
+ "MyClass.prototype.bar = function() {};\n"
+ "var clazz = new MyClass();";
String originalCode = "alert(clazz.foo());";
String expectedCode = "alert(clazz.bar());";
String template = ""
+ "/** @param {MyClass} clazz */"
+ "function before_foo(clazz) {\n"
+ "  clazz.foo();\n"
+ "};\n"
+ "/** @param {MyClass} clazz */"
+ "function after_foo(clazz) {\n"
+ "  clazz.bar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_replaceLeftHandSideOfAssignment() throws Exception {
String externs = ""
+ "/** @constructor */\n"
+ "function MyClass() {};\n";
String originalCode = "MyClass.prototype.foo = function() {};\n";
String expectedCode = "MyClass.prototype.bar = function() {};\n";
String template = ""
+ "function before_foo() {\n"
+ "  MyClass.prototype.foo\n"
+ "};\n"
+ "  MyClass.prototype.bar\n"
assertChanges(externs, originalCode, expectedCode, template);
public void test_replaceRightHandSideOfAssignment() throws Exception {
String externs = ""
+ "/** @constructor */\n"
+ "function MyClass() {};\n"
+ "MyClass.prototype.foo = function() {};\n"
+ "MyClass.prototype.bar = function() {};\n";
String originalCode = "var x = MyClass.prototype.foo;";
String expectedCode = "var x = MyClass.prototype.bar;";
String template = ""
+ "function before_foo() {\n"
+ "  MyClass.prototype.foo\n"
+ "};\n"
+ "function after_foo() {\n"
+ "  MyClass.prototype.bar\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_doesNotAddSpuriousNewline() throws Exception {
String externs = ""
+ "/** @constructor */\n"
+ "function MyClass() {};\n"
+ "MyClass.prototype.foo = function() {};\n"
+ "MyClass.prototype.bar = function() {};\n"
+ "var clazz = new MyClass();\n";
String originalCode = "clazz.foo();";
String expectedCode = "clazz.bar();";
String template = ""
+ "/** @param {MyClass} clazz */"
+ "function before_foo(clazz) {\n"
+ "  clazz.foo();\n"
+ "};\n"
+ "/** @param {MyClass} clazz */"
+ "function after_foo(clazz) {\n"
+ "  clazz.bar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_throwStatements() throws Exception {
String externs = "";
String originalCode = "throw Error('foo');";
String expectedCode = "throw getError();";
String template = ""
+ "/** @param {string} msg */\n"
+ "function before_template(msg) {\n"
+ "  throw Error(msg);\n"
+ "}\n"
+ "/** @param {string} msg */\n"
+ "function after_template(msg) {\n"
+ "  throw getError();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = "function f() {throw Error('foo');}";
expectedCode = "function f() {throw getError();}";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = ""
+ "if (true) {\n"
+ "  throw Error('foo');\n"
+ "}";
expectedCode = ""
+ "if (true) {\n"
+ "  throw getError();\n"
+ "}";
assertChanges(externs, originalCode, expectedCode, template);
public void test_whileStatements() throws Exception {
String externs = "/** @return {string} */ function getFoo() {return 'foo';}";
String originalCode = "while(getFoo()) {}";
String expectedCode = "while(getBar()) {}";
String template = ""
+ "function before_template() {\n"
+ "  getFoo();\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getBar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_doWhileStatements() throws Exception {
String externs = "/** @return {string} */ function getFoo() {return 'foo';}";
String originalCode = "do {} while(getFoo());";
String expectedCode = "do {} while(getBar());";
String template = ""
+ "function before_template() {\n"
+ "  getFoo();\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getBar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_returnStatement() throws Exception {
String externs = "/** @return {string} */ function getFoo() {return 'foo';}";
String originalCode = "function() { return getFoo(); }";
String expectedCode = "function() { return getBar(); }";
String template = ""
+ "function before_template() {\n"
+ "  getFoo();\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getBar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = "function() { return getFoo() == 'foo'; }";
expectedCode = "function() { return getBar() == 'foo'; }";
assertChanges(externs, originalCode, expectedCode, template);
public void test_switchStatement() throws Exception {
String externs = "/** @return {string} */ function getFoo() {return 'foo';}";
String originalCode = ""
+ "switch(getFoo()) {\n"
+ "  default:\n"
+ "    break;\n"
+ "}";
String expectedCode = ""
+ "switch(getBar()) {\n"
+ "  default:\n"
+ "    break;\n"
+ "}";
String template = ""
+ "function before_template() {\n"
+ "  getFoo();\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getBar();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_caseStatement() throws Exception {
String externs = ""
+ "var str = 'foo';\n"
+ "var CONSTANT = 'bar';n";
String originalCode = ""
+ "switch(str) {\n"
+ "  case CONSTANT:\n"
+ "    break;\n"
+ "}";
String expectedCode = ""
+ "switch(str) {\n"
+ "  case getValue():\n"
+ "    break;\n"
+ "}";
String template = ""
+ "function before_template() {\n"
+ "  CONSTANT\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getValue()\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_forStatement() throws Exception {
String externs = ""
+ "var obj = {};\n"
+ "obj.prop = 6;"
+ "var CONSTANT = 3;n";
String originalCode = "for (var i = CONSTANT; i < 5; i++) {}";
String expectedCode = "for (var i = CONSTANT2; i < 5; i++) {}";
String template = ""
+ "function before_template() {\n"
+ "  CONSTANT\n"
+ "}\n"
+ "function after_template() {\n"
+ "  CONSTANT2\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = "for (var i = 0; i < CONSTANT; i++) {}";
expectedCode = "for (var i = 0; i < CONSTANT2; i++) {}";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = "for (var i = 0; i < CONSTANT; i++) {}";
expectedCode = "for (var i = 0; i < obj.prop; i++) {}";
template = ""
+ "function before_template() {\n"
+ "  CONSTANT\n"
+ "}\n"
+ "function after_template() {\n"
+ "  obj.prop\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
originalCode = "for (var prop in obj) {}";
expectedCode = "for (var prop in getObj()) {}";
template = ""
+ "function before_template() {\n"
+ "  obj\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getObj()\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_comparisons() throws Exception {
String externs = ""
+ "var obj = {};\n"
+ "obj.prop = 5;";
String originalCode = "if (obj.prop == 5) {}";
String expectedCode = "if (3 == 5) {}";
String template = ""
+ "function before_template() {\n"
+ "  obj.prop;\n"
+ "}\n"
+ "function after_template() {\n"
+ "  3;\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
public void test_arrayAccess() throws Exception {
String externs = ""
+ "var arr = [];\n"
+ "var i = 0;\n"
+ "/** @return {number} */ function getNewIndex() {}";
String originalCode = "arr[i];";
String expectedCode = "arr[getNewIndex()];";
String template = ""
+ "function before_template() {\n"
+ "  i;\n"
+ "}\n"
+ "function after_template() {\n"
+ "  getNewIndex();\n"
+ "}\n";
assertChanges(externs, originalCode, expectedCode, template);
private void assertChanges(
String externs, String originalCode, String expectedCode, String refasterJsTemplate)
throws Exception {
RefasterJsScanner scanner = new RefasterJsScanner();
scanner.loadRefasterJsTemplateFromCode(refasterJsTemplate);
RefactoringDriver driver = new RefactoringDriver.Builder(scanner)
.addExternsFromCode(externs)
.addInputsFromCode(originalCode)
.build();
List<SuggestedFix> fixes = driver.drive();
String newCode = ApplySuggestedFixes.applySuggestedFixesToCode(
fixes, ImmutableMap.of("input", originalCode)).get("input");
assertEquals(expectedCode, newCode);
import static com.google.javascript.refactoring.testing.SuggestedFixes.assertReplacement;
import com.google.common.collect.Iterables;
String after = "goog.foo();";
before.length(), after.length(), "goog2.get('service');");
assertReplacement(fix, replacement);
public void testReplace_functionArgument() {
String before = ""
+ "var MyClass = function() {};\n"
+ "MyClass.prototype.foo = function() {};\n"
+ "MyClass.prototype.bar = function() {};\n"
+ "var clazz = new MyClass();\n";
String after = "alert(clazz.foo());";
Compiler compiler = getCompiler(before + after);
Node root = compileToScriptRoot(compiler);
Node newNode = IR.call(IR.getprop(IR.name("clazz"), IR.string("bar")));
SuggestedFix fix = new SuggestedFix.Builder()
.replace(root.getLastChild().getFirstChild().getLastChild(), newNode, compiler)
.build();
CodeReplacement replacement = new CodeReplacement(
before.length() + "alert(".length(), "clazz.foo()".length(), "clazz.bar()");
assertReplacement(fix, replacement);
public void testReplace_leftHandSideAssignment() {
String before = "var MyClass = function() {};\n";
String after = "MyClass.prototype.foo = function() {};\n";
Compiler compiler = getCompiler(before + after);
Node root = compileToScriptRoot(compiler);
Node newNode = IR.getprop(
IR.getprop(IR.name("MyClass"), IR.string("prototype")),
IR.string("bar"));
SuggestedFix fix = new SuggestedFix.Builder()
.replace(root.getLastChild().getFirstChild().getFirstChild(), newNode, compiler)
.build();
CodeReplacement replacement = new CodeReplacement(
before.length(), "MyClass.prototype.foo".length(), "MyClass.prototype.bar");
public void testChangeJsDocType2() {
String code = "/** @type {Foo} */\nvar foo = new Foo()";
Compiler compiler = getCompiler(code);
Node root = compileToScriptRoot(compiler);
Node varNode = root.getFirstChild();
Node jsdocRoot =
Iterables.getOnlyElement(varNode.getJSDocInfo().getTypeNodes());
SuggestedFix fix = new SuggestedFix.Builder()
.insertBefore(jsdocRoot, "!")
.build();
CodeReplacement replacement = new CodeReplacement(
"/** @type {".length(), 0, "!");
assertReplacement(fix, replacement);
assertEquals("typeA<string>", stringsOfA.toString());
assertEquals("typeA<number>", numbersOfA.toString());
"function (...*): None", retString, retNumber);
"function (...*): None", retString, retNumber);
" function (...?): boolean",
assertEquals("function (this:T, ...?): boolean", fn.toString());
assertEquals("function (new:Array, ...*): Array",
assertEquals("function (...number): boolean",
assertEquals("function (number, ...string): boolean",
assertEquals("Enum<number>", elementsType.toString());
assertEquals("(function (...?): ?|not.resolved.named.type)",
"(Array|Object<string,?>)",
"(Array|Object<string,?>)",
"(Array<string>|Object<string,?>)",
"(Array<string>|Object<string,?>)",
Map<String, RecordProperty> properties = new HashMap<>();
assertEquals("TestingType<number,string>", templatizedInstance.toString());
assertEquals("TestingType<number,?>", templatizedInstance.toString());
assertEquals("Array<string>", arrOfString.toString());
assertEquals("Array<T>", arrOfTemplateType.toString());
assertEquals("Array<?>", arrOfUnknown.toString());rootPath = tempFolder.getRoot().getPath() + "/";
return compiler.getInput(new InputId(rootPath + s));import junit.framework.TestCase;try (OutputStream file = filenameToOutputStream(functionInformationMapOutputPath)) {
file.flush();
if (options.checkRequires.isOn()) {
return new CheckRequiresForConstructors(compiler, options.checkRequires);
stream.flush();
union = JSType.join(
union, getTypeFromNodeHelper(child, registry, typeParameters));
outstream.flush();try (final OutputStream file = filenameToOutputStream(functionInformationMapOutputPath)) {
if (NodeUtil.isValidPropertyName(n.getString())) {
NodeUtil.isValidPropertyName(right.getString())) {
if (options.checkRequires.isOn()
|| options.enables(DiagnosticGroups.MISSING_REQUIRE)) {
return new CheckRequiresForConstructors(compiler, CheckLevel.WARNING);
NodeUtil.isValidPropertyName(prop.getString())) {
!NodeUtil.isValidPropertyName(prop.getString())) {
if (!NodeUtil.isValidQualifiedName(name)) {
JSType nextType = getTypeFromNodeHelper(child, registry, typeParameters);
if (nextType.isUnknown()) {
warn("This union type is equivalent to '?'.", n);
return JSType.UNKNOWN;
union = JSType.join(union, nextType);
import static junit.framework.Assert.assertEquals;
import junit.framework.Assert;
import junit.framework.Assert;
import static junit.framework.Assert.assertFalse;
import junit.framework.Assert;
public void testQuestionableUnionJsDoc() {
typeCheck(
"/** @type {string|?} */ var x;",
JSTypeCreatorFromJSDoc.BAD_JSDOC_ANNOTATION);
checkNoWarnings(""
+ "/**\n"
+ " * @return {T|S}\n"
+ " * @template T, S\n"
+ " */\n"
+ "function f(){};");
assertTrue(NodeUtil.isValidPropertyName("a"));
assertTrue(NodeUtil.isValidPropertyName("a3"));
assertFalse(NodeUtil.isValidPropertyName("3a"));
assertFalse(NodeUtil.isValidPropertyName("a."));
assertFalse(NodeUtil.isValidPropertyName(".a"));
assertFalse(NodeUtil.isValidPropertyName("a.b"));
assertFalse(NodeUtil.isValidPropertyName("true"));
assertFalse(NodeUtil.isValidPropertyName("a.true"));
assertFalse(NodeUtil.isValidPropertyName("a..b"));
assertTrue(NodeUtil.isValidQualifiedName("a"));
assertTrue(NodeUtil.isValidQualifiedName("a3"));
assertFalse(NodeUtil.isValidQualifiedName("3a"));
assertFalse(NodeUtil.isValidQualifiedName("a."));
assertFalse(NodeUtil.isValidQualifiedName(".a"));
assertTrue(NodeUtil.isValidQualifiedName("a.b"));
assertFalse(NodeUtil.isValidQualifiedName("true"));
assertFalse(NodeUtil.isValidQualifiedName("a.true"));
assertFalse(NodeUtil.isValidQualifiedName("a..b"));
import static junit.framework.Assert.assertEquals;
import junit.framework.Assert;Set<DiGraphNode<JsName, RefType>> required = new HashSet<>();
return createDefaultObjectUnion(rootPath = tempFolder.getRoot().getPath() + "/";
return compiler.getInput(new InputId(rootPath + s));.setNewTypeInference(flags.useNewTypeInference);.setNewTypeInference(flags.useNewTypeInference);boolean inferred = !(
(info != null && (info.hasType()
|| info.hasEnumParameterType()
|| FunctionTypeBuilder.isFunctionTypeDeclaration(info)))
|| (NodeUtil.isConstantDeclaration(
compiler.getCodingConvention(), info, n)
&& valueType != null
&& !valueType.isUnknownType())
);
public void testTypedef() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
"var a = {};\n" +
"/** @typedef {string} */\n" +
"a.b = {}\n",
"var a={};a.b={}");
test(options,
"/** @typedef {string} */\n"
+ "var a = {};\n"
+ "a.b = {}\n",
"var a={};a.b={}");
public void testGoogModuleAliasConstructor1() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
options.inferConsts = true;
options.collapseProperties = true;
options.removeUnusedVars = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
new String[] {
"goog.module('a');\n" +
"/** @constructor */\n" +
"var C = function(){};\n" +
"exports = C;",
"goog.module('b');\n" +
"\n" +
"var a = goog.require('a');\n" +
"\n" +
"/** @type {a} */\n" +
"var x = new a"
new String[] {
"var $jscomp$scope$C=function(){};var a=$jscomp$scope$C\n",
"new a"
public void disable_testGoogModuleAliasConstructor2() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
options.inferConsts = true;
options.collapseProperties = true;
options.removeUnusedVars = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
new String[] {
"goog.module('a.b');\n" +
"/** @constructor */\n" +
"var C = function(){};\n" +
"exports = C;",
"goog.module('a.c');\n" +
"\n" +
"var b = goog.require('a.b');\n" +
"\n" +
"/** @type {b} */\n" +
"var x = new b"
new String[] {
"var $jscomp$scope$C=function(){};\n",
"new $jscomp$scope$C"
public void testGoogModuleAliasEnum() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
options.inferConsts = true;
options.collapseProperties = true;
options.removeUnusedVars = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
new String[] {
"goog.module('a.b');\n" +
"/** @enum {string} */\n" +
"var C = {X:'x'};\n" +
"exports = C;",
"goog.module('a.c');\n" +
"\n" +
"var b = goog.require('a.b');\n" +
"\n" +
"/** @type {b} */\n" +
"var x = b.X"
new String[] {
"",
""
public void disable_testGoogModuleAliasTypedef() {
CompilerOptions options = createCompilerOptions();
options.closurePass = true;
options.inferConsts = true;
options.collapseProperties = true;
options.removeUnusedVars = true;
WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
test(options,
new String[] {
"goog.module('a.b');\n" +
"/** @typedef {string} */\n" +
"var C;\n" +
"/** @const */ exports = C;",
"goog.module('a.c');\n" +
"\n" +
"var b = goog.require('a.b');\n" +
"\n" +
"/** @type {b} */\n" +
"var x = 0;"
new String[] {
"",
""
"/** @constructor @suppress {duplicate} */ goog.F = function() {};");
public void testDeclaredConstType7() throws Exception {
testSame(
"/** " +
" * @param {string} a\n" +
" * @constructor\n" +
"*/\n" +
"var C = function(a) { /** @const */ this.x = a;};\n" +
"var ALIAS = C;" +
"var instance = new ALIAS('a')");
ObjectType instance = (ObjectType) findNameType("instance", globalScope);
assertEquals("C", instance.toString());
assertTrue(instance.hasProperty("x"));
assertEquals("string",
instance.getPropertyType("x").toString());
assertFalse(instance.isPropertyTypeInferred("x"));
public void testDeclaredConstType8() throws Exception {
testSame(
"/** " +
" * @param {string} a\n" +
" * @constructor\n" +
"*/\n" +
"var C = function(a) { /** @const */ this.x = a;};\n" +
"/** @const */ var ns = {};" +
"ns.alias = C;" +
"var instance = new ns.alias('a')");
ObjectType instance = (ObjectType) findNameType("instance", globalScope);
assertEquals("C", instance.toString());
assertTrue(instance.hasProperty("x"));
assertEquals("string",
instance.getPropertyType("x").toString());
assertFalse(instance.isPropertyTypeInferred("x"));import com.google.javascript.jscomp.newtypes.FunctionTypeBuilder;
static final DiagnosticType EXTENDS_NOT_ON_CTOR_OR_INTERF =
DiagnosticType.warning(
"JSC_EXTENDS_NOT_ON_CTOR_OR_INTERF",
"@extends used without @constructor or @interface for {0}.\n");
static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning(
"JSC_EXTENDS_NON_OBJECT",
"{0} extends non-object type {1}.\n");
static final DiagnosticType INHERITANCE_CYCLE = DiagnosticType.warning(
"JSC_INHERITANCE_CYCLE",
"Cycle detected in inheritance chain of type {0}");
static final DiagnosticType DICT_IMPLEMENTS_INTERF = DiagnosticType.warning(
"JSC_DICT_IMPLEMENTS_INTERF",
"Class {0} is a dict. Dicts can't implement interfaces.");
static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR =
DiagnosticType.warning(
"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR",
"@implements used without @constructor or @interface for {0}");
DICT_IMPLEMENTS_INTERF,
EXTENDS_NON_OBJECT,
EXTENDS_NOT_ON_CTOR_OR_INTERF,
IMPLEMENTS_WITHOUT_CONSTRUCTOR,
INHERITANCE_CYCLE,
TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,
TypeCheck.CONFLICTING_SHAPE_TYPE,
globalScope = new Scope(root, null, ImmutableList.<String>of(), commonTypes);
private void maybeRecordBuiltinType(String name, RawNominalType rawNominalType) {
QualifiedName qname = new QualifiedName(n.getLastChild().getString());
JSType retType = n.isNew() ? funType.getThisType() : funType.getReturnType();
ImmutableList<String> typeParameters =
fnDoc == null ? null : fnDoc.getTemplateTypeNames();
FunctionTypeBuilder builder =
typeParser.getFunctionType(fnDoc, declNode, ownerType, parentScope);
RawNominalType ctorType = null;
if (fnDoc != null) {
NominalType parentClass = null;
if (fnDoc.hasBaseType()) {
if (!fnDoc.isConstructor()) {
warnings.add(JSError.make(
declNode, EXTENDS_NOT_ON_CTOR_OR_INTERF, functionName));
Node docNode = fnDoc.getBaseType().getRoot();
if (typeParser.hasKnownType(
docNode, ownerType, parentScope, typeParameters)) {
parentClass = typeParser.getNominalType(
docNode, ownerType, parentScope, typeParameters);
if (parentClass == null) {
warnings.add(JSError.make(
declNode, EXTENDS_NON_OBJECT, functionName,
docNode.toStringTree()));
warnings.add(JSError.make(
declNode, TypeCheck.CONFLICTING_EXTENDED_TYPE,
"constructor", functionName));
parentClass = null;
ctorType =
declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
ImmutableSet<NominalType> implementedIntfs =
typeParser.getImplementedInterfaces(
fnDoc, ownerType, parentScope, typeParameters);
if (ctorType == null &&
(fnDoc.isConstructor() || fnDoc.isInterface())) {
return builder.buildDeclaration();
String className = ctorType.toString();
if (parentClass == null && !"Object".equals(functionName)) {
parentClass = commonTypes.getObjectType();
if (parentClass != null) {
if (!ctorType.addSuperClass(parentClass)) {
warnings.add(JSError.make(
declNode, INHERITANCE_CYCLE, className));
if (ctorType.isStruct() && !parentClass.isStruct()) {
warnings.add(JSError.make(
declNode, TypeCheck.CONFLICTING_SHAPE_TYPE,
"struct", className));
warnings.add(JSError.make(
declNode, TypeCheck.CONFLICTING_SHAPE_TYPE,
"dict", className));
if (ctorType.isDict() && !implementedIntfs.isEmpty()) {
warnings.add(JSError.make(
declNode, DICT_IMPLEMENTS_INTERF, className));
boolean noCycles = ctorType.addInterfaces(implementedIntfs);
Preconditions.checkState(noCycles);
builder.addNominalType(ctorType.getAsNominalType());
if (!implementedIntfs.isEmpty()) {
warnings.add(JSError.make(declNode,
TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, functionName));
boolean noCycles = ctorType.addInterfaces(
typeParser.getExtendedInterfaces(
fnDoc, ownerType, parentScope, typeParameters));
if (!noCycles) {
warnings.add(JSError.make(
declNode, INHERITANCE_CYCLE, ctorType.toString()));
builder.addNominalType(ctorType.getAsNominalType());
warnings.add(JSError.make(
declNode, IMPLEMENTS_WITHOUT_CONSTRUCTOR, functionName));
if (ownerType != null) {
builder.addReceiverType(ownerType.getAsNominalType());
DeclaredFunctionType result = builder.buildDeclaration();
ctorType.setCtorFunction(result.toFunctionType(), commonTypes.getFunctionType());
warnings.add(JSError.make(
initializer.getLastChild(), TypeCheck.INTERFACE_METHOD_NOT_EMPTY));
propDeclType = commonTypes.fromFunctionType(methodType.toFunctionType());
propDeclType = commonTypes.fromFunctionType(methodType.toFunctionType());
if (receiverType == null && other.receiverType != null
|| receiverType != null && other.receiverType == null) {
return false;
if (receiverType != null && !receiverType.unifyWith(
other.receiverType, typeParameters, typeMultimap)) {
import com.google.common.annotations.VisibleForTesting;
return getNodeTypeDeclaration(jsdoc, ownerType, registry, null);
RawNominalType ownerType, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) {
jsdoc.getType(), ownerType, registry, typeParameters);
private JSType getTypeFromJSTypeExpression(
JSTypeExpression expr, RawNominalType ownerType,
JSType result =
getTypeFromNode(expr.getRoot(), ownerType, registry, typeParameters);
return result;
JSType getTypeFromNode(Node n, RawNominalType ownerType,
DeclaredTypeRegistry registry, ImmutableList<String> typeParameters) {
return getTypeFromNodeHelper(n, ownerType, registry, typeParameters);
private JSType getTypeFromNodeHelper(
Node n, RawNominalType ownerType, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters)
throws UnknownTypeException {
return getRecordTypeHelper(n, ownerType, registry, typeParameters);
return getNamedTypeHelper(n, ownerType, registry, typeParameters);
union = JSType.join(union, getTypeFromNodeHelper(
child, ownerType, registry, typeParameters));
n.getFirstChild(), ownerType, registry, typeParameters)
return JSType.join(JSType.NULL, getTypeFromNodeHelper(
child, ownerType, registry, typeParameters));
return getFunTypeHelper(n, ownerType, registry, typeParameters);
private JSType getRecordTypeHelper(Node n, RawNominalType ownerType,
DeclaredTypeRegistry registry,
getTypeFromNodeHelper(fieldTypeNode.getLastChild(), ownerType,
registry, typeParameters);
private static boolean isNonnullAndContains(
ImmutableList<String> collection, String str) {
return collection != null && collection.contains(str);
private static boolean hasTypeVariable(
ImmutableList<String> typeParameters, RawNominalType ownerType,
String typeName) {
return isNonnullAndContains(typeParameters, typeName) ||
ownerType != null &&
isNonnullAndContains(ownerType.getTypeParameters(), typeName);
private JSType getNamedTypeHelper(Node n, RawNominalType ownerType,
DeclaredTypeRegistry registry,
if (hasTypeVariable(outerTypeParameters, ownerType, typeName)) {
namedType, n, ownerType, registry, outerTypeParameters);
tdType = getTypeFromJSTypeExpression(texp, null, registry, null);
enumeratedType = getTypeFromJSTypeExpression(texp, null, registry, null);
RawNominalType ownerType, DeclaredTypeRegistry registry,
ImmutableList<String> outerTypeParameters)
JSType childType = getTypeFromNodeHelper(
child, ownerType, registry, outerTypeParameters);
typeList.add(childType);
nominalTypeName, String.valueOf(typeParamsSize), String.valueOf(typeArgsSize)));
DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters)
FunctionType funType =
getFunTypeBuilder(jsdocNode, ownerType, registry, typeParameters)
.buildFunction();
return registry.getCommonTypes().fromFunctionType(funType);
private FunctionTypeBuilder getFunTypeBuilder(
ImmutableList<String> typeParameters)
FunctionTypeBuilder builder = new FunctionTypeBuilder();
builder.addReceiverType(getNominalType(
child.getFirstChild(), ownerType, registry, typeParameters));
builder.addNominalType(getNominalType(
child.getFirstChild(), ownerType, registry, typeParameters));
builder.addOptFormal(
getTypeFromNodeHelper(
arg.getFirstChild(), ownerType, registry,
typeParameters));
getTypeFromNodeHelper(
restNode, ownerType, registry, typeParameters));
getTypeFromNodeHelper(arg, ownerType, registry,
typeParameters));
builder.addRetType(
getTypeFromNodeHelper(child, ownerType, registry, typeParameters));
return builder;
public boolean hasKnownType(
Node n, RawNominalType ownerType, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) {
try {
getTypeFromNodeHelper(n, ownerType, registry, typeParameters);
return false;
return true;
public NominalType getNominalType(Node n, RawNominalType ownerType,
JSType wrappedClass =
getTypeFromNode(n, ownerType, registry, typeParameters);
if (wrappedClass == null) {
return null;
return wrappedClass.getNominalTypeIfUnique();
public ImmutableSet<NominalType> getImplementedInterfaces(
JSDocInfo jsdoc, RawNominalType ownerType, DeclaredTypeRegistry registry,
return getInterfacesHelper(
jsdoc, ownerType, registry, typeParameters, true);
public ImmutableSet<NominalType> getExtendedInterfaces(
JSDocInfo jsdoc, RawNominalType ownerType, DeclaredTypeRegistry registry,
return getInterfacesHelper(
jsdoc, ownerType, registry, typeParameters, false);
JSDocInfo jsdoc, RawNominalType ownerType, DeclaredTypeRegistry registry,
if (hasKnownType(expRoot, ownerType, registry, typeParameters)) {
NominalType nt =
getNominalType(expRoot, ownerType, registry, typeParameters);
public FunctionTypeBuilder getFunctionType(
JSDocInfo jsdoc, Node declNode, RawNominalType ownerType,
jsdoc, declNode, ownerType, registry);
try {
return getFunTypeBuilder(jsdocNode, ownerType, registry, null);
return FunctionTypeBuilder.qmarkFunctionBuilder();
return FunctionTypeBuilder.qmarkFunctionBuilder();
return getFunTypeFromTypicalFunctionJsdoc(
jsdoc, declNode, ownerType, registry, false);
return FunctionTypeBuilder.qmarkFunctionBuilder();
private FunctionTypeBuilder getFunTypeFromAtTypeJsdoc(
DeclaredTypeRegistry registry) {
FunctionTypeBuilder builder = new FunctionTypeBuilder();
builder.addReceiverType(
getNominalType(childJsdoc.getFirstChild(), ownerType, registry,
null));
getNominalType(childJsdoc.getFirstChild(), ownerType, registry,
null));
paramType.getFirstChild(), ownerType, registry, null));
getTypeFromNode(paramType, ownerType, registry, null));
paramType.getFirstChild(), ownerType, registry, null));
builder.addRetType(
getTypeFromNode(childJsdoc, ownerType, registry, null));
return builder;
private FunctionTypeBuilder getFunTypeFromTypicalFunctionJsdoc(
JSDocInfo jsdoc, Node funNode, RawNominalType ownerType,
DeclaredTypeRegistry registry,
boolean ignoreFunNode  = !funNode.isFunction();
FunctionTypeBuilder builder = new FunctionTypeBuilder();
Node params = ignoreFunNode ? null : funNode.getFirstChild().getNext();
ImmutableList<String> typeParameters = null;
param.getJSDocInfo(), ownerType, registry, typeParameters);
boolean isRequired = true, isRestFormals = false;
JSTypeExpression texp = jsdoc == null ?
null : jsdoc.getParameterType(pname);
fnParamType =
getTypeFromNode(jsdocNode, ownerType, registry, typeParameters);
JSDocInfo inlineRetJsdoc = ignoreJsdoc ? null :
funNode.getFirstChild().getJSDocInfo();
builder.addRetType(getNodeTypeDeclaration(
inlineRetJsdoc, ownerType, registry, typeParameters));
builder.addRetType(getTypeFromJSTypeExpression(
retTypeExp, ownerType, registry, typeParameters));
return builder;
Preconditions.checkState(!other.typeMap.isEmpty());
public void setCtorFunction(FunctionType ctorFn, NominalType builtinFunction) {
return (hasType() && getType().getRoot().isFunction()
|| getFlag(MASK_CONSTRUCTOR | MASK_NOSIDEEFFECTS));
public void testThisInFunctionJsdoc() {
GlobalTypeInfo.EXTENDS_NOT_ON_CTOR_OR_INTERF);
GlobalTypeInfo.EXTENDS_NON_OBJECT);
GlobalTypeInfo.IMPLEMENTS_WITHOUT_CONSTRUCTOR);
GlobalTypeInfo.INHERITANCE_CYCLE);
GlobalTypeInfo.INHERITANCE_CYCLE);
GlobalTypeInfo.INHERITANCE_CYCLE);
GlobalTypeInfo.DICT_IMPLEMENTS_INTERF);import com.google.common.collect.ImmutableSet;
import java.util.Set;
private void assertReplacement(SuggestedFix fix, CodeReplacement expectedReplacement) {
assertReplacements(fix, ImmutableSet.of(expectedReplacement));
private void assertReplacements(SuggestedFix fix, Set<CodeReplacement> expectedReplacements) {
SetMultimap<String, CodeReplacement> replacementMap = fix.getReplacements();
assertEquals(1, replacementMap.size());
Set<CodeReplacement> replacements = replacementMap.get("test");
assertEquals(expectedReplacements.size(), replacements.size());
assertEquals(expectedReplacements, replacements);"Rename is not implemented for node type: " + n.getType());public void testArrow2() {static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning(
"JSC_INEXISTANT_PARAM",
reportWarning(INEXISTANT_PARAM, inexistentName, formatFnName());
static int getCost(Node root, int costThreshhold) {
CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
CompiledSizeEstimator(int costThreshhold) {
this.maxCost = costThreshhold;
if (inContructor(t)) {
private boolean inContructor(NodeTraversal t) {
public static String getOrginalName(String name) {
if (containsSeparator(name) && !getOrginalName(name).isEmpty()) {
String original = getOrginalName(name);
int occurance;
this.occurance = 0;
int result = other.occurance - this.occurance;
c.occurance++;
name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(
.getOrginalName(name);static final DiagnosticType INEXISTENT_PARAM = DiagnosticType.warning(
"JSC_INEXISTENT_PARAM",
reportWarning(INEXISTENT_PARAM, inexistentName, formatFnName());
static int getCost(Node root, int costThreshold) {
CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshold);
CompiledSizeEstimator(int costThreshold) {
this.maxCost = costThreshold;
if (inConstructor(t)) {
private boolean inConstructor(NodeTraversal t) {
public static String getOriginalName(String name) {
if (containsSeparator(name) && !getOriginalName(name).isEmpty()) {
String original = getOriginalName(name);
int occurrence;
this.occurrence = 0;
int result = other.occurrence - this.occurrence;
c.occurrence++;
name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(
.getOriginalName(name);
public void testGlobalAssigment() {
public void testSplitNamedFuntion() {
public void testSplitNamedFuntionWithArgs() {
public void disable_testSplitAnonFuntion() {
public void disable_testSplitMupltiFuntions() {
public void testDoLoopIECompatiblity() {
public void testFunctionSafariCompatiblity() {
public void testComplexInlineInExpresssions1() {
public void testComplexInlineInExpresssions2() {
public void testComplexInlineInExpresssions3() {
public void testComplexInlineInExpresssions4() {
public void testComplexInlineInExpresssions5() {
public void testCallSiteInteraction_contructors() {
public void testTransformationWithMulipleTypeVars() {
public void testUselessUnconditonalBreak() {
public void testNonExistantProvideLoose() throws Exception {
public void testNonExistantProvideStrict() throws Exception {static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning(
"JSC_INEXISTANT_PARAM",
reportWarning(INEXISTANT_PARAM, inexistentName, formatFnName());
static int getCost(Node root, int costThreshhold) {
CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
CompiledSizeEstimator(int costThreshhold) {
this.maxCost = costThreshhold;
if (inContructor(t)) {
private boolean inContructor(NodeTraversal t) {
public static String getOrginalName(String name) {
if (containsSeparator(name) && !getOrginalName(name).isEmpty()) {
String original = getOrginalName(name);
int occurance;
this.occurance = 0;
int result = other.occurance - this.occurance;
c.occurance++;
name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(
.getOrginalName(name);
public void testGlobalAssignment() {
public void testSplitNamedFunction() {
public void testSplitNamedFunctionWithArgs() {
public void disable_testSplitAnonFunction() {
public void disable_testSplitMupltiFunctions() {
public void testDoLoopIECompatibility() {
public void testFunctionSafariCompatibility() {
public void testComplexInlineInExpressionss1() {
public void testComplexInlineInExpressionss2() {
public void testComplexInlineInExpressionss3() {
public void testComplexInlineInExpressionss4() {
public void testComplexInlineInExpressionss5() {
public void testCallSiteInteraction_constructors() {
public void testTransformationWithMultipleTypeVars() {
public void testUselessUnconditionalBreak() {
public void testNonExistentProvideLoose() throws Exception {
public void testNonExistentProvideStrict() throws Exception {public void testGlobalAssigment() {
public void testSplitNamedFuntion() {
public void testSplitNamedFuntionWithArgs() {
public void disable_testSplitAnonFuntion() {
public void disable_testSplitMupltiFuntions() {
public void testDoLoopIECompatiblity() {
public void testFunctionSafariCompatiblity() {
public void testComplexInlineInExpresssions1() {
public void testComplexInlineInExpresssions2() {
public void testComplexInlineInExpresssions3() {
public void testComplexInlineInExpresssions4() {
public void testComplexInlineInExpresssions5() {
public void testCallSiteInteraction_contructors() {
public void testTransformationWithMulipleTypeVars() {
public void testUselessUnconditonalBreak() {
public void testNonExistantProvideLoose() throws Exception {
public void testNonExistantProvideStrict() throws Exception {report(t, n, INEXISTENT_PROPERTY_WITH_SUGGESTION, propName,
report(t, n, reportType, propName,
"Property x never defined on Foo",
"after it is constructed."
"Property x never defined on Foo",
"after it is constructed."import java.util.Arrays;
List<SourceFile> files = Lists.newLinkedList();      
FileResource fr = iter.next().as(FileResource.class);private List<SourceFile> findJavaScriptFiles(FileList fileList) {
List<SourceFile> files = Lists.newLinkedList();
File baseDir = fileList.getDir(getProject());
for (String included : fileList.getFiles(getProject())) {
files.add(SourceFile.fromFile(new File(baseDir, included),
Charset.forName(encoding)));
return files;
private List<SourceFile> findJavaScriptFiles(Path path) {
List<SourceFile> files = Lists.newArrayList();
for (String included : path.list()) {
files.add(SourceFile.fromFile(new File(included),
Charset.forName(encoding)));" must explicity redeclare superclass visibility");if (NodeUtil.isNamespaceDecl(getProp) && currentScope.isNamespace(getProp)
|| NodeUtil.isTypedefDecl(getProp)) {
EnumType et = currentScope.getEnum(declNode.getQualifiedName());
if (et != null) {
return et.toJSType();if (!typeMap.isEmpty()) {
for (String typeVar : rawType.getTypeParameters()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, typeMap.keySet());
JSType otherType = other.typeMap.containsKey(typeVar)
? other.typeMap.get(typeVar) : JSType.fromTypeVar(typeVar);
if (!typeMap.get(typeVar).isSubtypeOf(otherType)) {
return false;
return false;
public void testThisReferenceUsedGenericallyDoesntCrash() {symbolTable.fillSymbolVisibility(this, externsRoot, jsRoot);
import java.io.File;
static final String INDEX_FILE = "index.js";
private final URI moduleRootURI;
this.moduleRootURI = new File(moduleRoot).toURI();
private String resolveInFileSystem(String filename) {
File f = new File(filename);
if (f.exists() && f.isDirectory()) {
File index = new File(f, INDEX_FILE);
if (index.exists()) {
return moduleRootURI.relativize(index.toURI()).getPath();
return filename;
String filename = resolveInFileSystem(uri.normalize().toString());
private static final String GLOBAL_THIS_NAMES[] = {
"window", "top", "goog$global", "goog.global" };
if (n.matchesQualifiedName(GLOBAL_THIS_NAMES[i])) {
RawNominalType rawNominal =
globalScope.getNominalType(new QualifiedName("Object"));
.instantiateGenericsFromArgumentTypes(argTypes.build());
if (jsdoc == null || !jsdoc.isConstant()
|| !jsdoc.getTypeNodes().isEmpty()) {
import com.google.common.collect.ImmutableMap;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.JSDocInfo.Visibility;
import com.google.javascript.rhino.jstype.StaticSourceFile;
void fillSymbolVisibility(
AbstractCompiler compiler, Node externs, Node root) {
CollectFileOverviewVisibility collectPass =
new CollectFileOverviewVisibility(compiler);
collectPass.process(externs, root);
ImmutableMap<StaticSourceFile, Visibility> visibilityMap =
collectPass.getFileOverviewVisibilityMap();
NodeTraversal.traverseRoots(
compiler, Lists.newArrayList(externs, root),
new VisibilityCollector(visibilityMap, compiler.getCodingConvention()));
return this.visibility;
void setVisibility(Visibility v) {
this.visibility = v;
private class VisibilityCollector
extends NodeTraversal.AbstractPostOrderCallback {
private final ImmutableMap<StaticSourceFile, Visibility> fileVisibilityMap;
private final CodingConvention codingConvention;
private VisibilityCollector(
ImmutableMap<StaticSourceFile, Visibility> fileVisibilityMap,
CodingConvention codingConvention) {
this.fileVisibilityMap = fileVisibilityMap;
this.codingConvention = codingConvention;
if (n.isName()) {
visitName(t, n, parent);
visitProperty(t, n, parent);
private void visitName(NodeTraversal t, Node n, Node parent) {
Symbol symbol = symbols.get(n, n.getString());
if (symbol == null) {
return;
if (symbol.getVisibility() != null) {
return;
Var var = t.getScope().getVar(n.getString());
if (var == null) {
return;
Visibility v = AccessControlUtils.getEffectiveNameVisibility(
var, fileVisibilityMap);
if (v == null) {
return;
symbol.setVisibility(v);
private void visitProperty(NodeTraversal t, Node getprop, Node parent) {
String propertyName = getprop.getLastChild().getString();
Symbol symbol = symbols.get(getprop, propertyName);
if (symbol == null) {
return;
if (symbol.getVisibility() != null) {
return;
JSType jsType = getprop.getFirstChild().getJSType();
if (jsType == null) {
return;
boolean isOverride = parent.getJSDocInfo() != null
&& parent.isAssign()
&& parent.getFirstChild() == getprop;
if (isOverride) {
symbol.setVisibility(Visibility.INHERITED);
ObjectType referenceType = ObjectType.cast(jsType.dereference());
Visibility v = AccessControlUtils.getEffectivePropertyVisibility(
getprop,
referenceType,
fileVisibilityMap,
codingConvention);
if (v == null) {
return;
symbol.setVisibility(v);
import java.util.HashMap;
if (this.equals(other)) {
return true;
return instantiateGenericsWithUnknown(this).isSubtypeOf(other);
FunctionType result = FunctionType.meet(this, other);
if (this.isLoose && !result.isLoose()) {
result = result.withLoose();
return result;
if (f1.isGeneric() && f1.isSubtypeOf(f2)) {
return f1;
return f2;
Preconditions.checkState(!f1.isGeneric());
Preconditions.checkState(!f2.isGeneric());
private static FunctionType instantiateGenericsWithUnknown(FunctionType f) {
if (!f.isGeneric()) {
return f;
HashMap<String, JSType> tmpTypeMap = new HashMap<>();
for (String typeParam : f.typeParameters) {
tmpTypeMap.put(typeParam, JSType.UNKNOWN);
return f.instantiateGenerics(tmpTypeMap);
for (Map.Entry<String, JSType> concreteTypeEntry
: concreteTypes.entrySet()) {
public FunctionType instantiateGenericsFromArgumentTypes(
if (argTypes.size() < getMinArity() || argTypes.size() > getMaxArity()) {
return null;
if (peekImplicitSemiColon()) {
reportError("semicolon/newline not allowed after 'throw'");
package com.google.javascript.jscomp;
import com.google.common.collect.ImmutableList;
import com.google.javascript.rhino.InputId;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import junit.framework.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
public class ES6ModuleLoaderFileSystemTest {
private ES6ModuleLoader loader;
private Compiler compiler;
private String rootPath;
public TemporaryFolder tempFolder = new TemporaryFolder();
private void writeFile(File f, String s) throws IOException {
Files.write(f.toPath(), s.getBytes());
public void setup() {
final File indexA, indexB, appFile;
try {
final File tempDirA = tempFolder.newFolder("A");
indexA = new File(tempDirA, "index.js");
writeFile(indexA, "alert('A');");
final File tempDirB = tempFolder.newFolder("B");
indexB = new File(tempDirB, "index.js");
writeFile(indexB, "alert('B');");
appFile = tempFolder.newFile("app.js");
writeFile(appFile, "alert('app');");
throw new RuntimeException(e);
SourceFile in1 = SourceFile.fromFile(indexA);
SourceFile in2 = SourceFile.fromFile(indexB);
SourceFile in3 = SourceFile.fromFile(appFile);
compiler = new Compiler();
compiler.init(
ImmutableList.<SourceFile>of(),
ImmutableList.of(in1, in2, in3),
new CompilerOptions());
rootPath = tempFolder.getRoot().getPath() + "/";
loader = ES6ModuleLoader.createNaiveLoader(compiler, rootPath);
private CompilerInput getInput(String s) {
return compiler.getInput(new InputId(rootPath + s));
public void testFileSystem() {
CompilerInput inputA = getInput("A/index.js");
CompilerInput inputB = getInput("B/index.js");
CompilerInput inputApp = getInput("app.js");
Assert.assertEquals("A/index.js", loader.getLoadAddress(inputA));
Assert.assertEquals("A/index.js", loader.locate("../A", inputB));
Assert.assertEquals("A/index.js", loader.locate("./A", inputApp));
public void testExportOnGoogGlobalFound1() {
assertExported("goog.global['a']", "a");
public void testExportOnGoogGlobalFound2() {
assertExported("goog.global.a", "a");
public void testExportOnGoogGlobalFound3() {
assertExported("goog$global['a']", "a");
public void testExportOnGoogGlobalFound4() {
assertExported("goog$global.a", "a");
"/** @const */\n" +
public void testGenericsSubtyping() {
checkNoWarnings(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {}\n" +
"/** @param {function(number, number)} x */\n" +
"function g(x) {}\n" +
"g(f);");
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {}\n" +
"/** @param {function()} x */\n" +
"function g(x) {}\n" +
"g(f);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
checkNoWarnings(
"/** @interface */\n" +
"function Parent() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"Parent.prototype.method = function(x) {};\n" +
"/**\n" +
" * @constructor\n" +
" * @implements {Parent}\n" +
" */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template U\n" +
" * @param {U} x\n" +
" */\n" +
"Child.prototype.method = function(x) {};");
checkNoWarnings(
"/** @interface */ function Parent() {}\n" +
"/** @param {string} x */\n" +
"Parent.prototype.method = function(x){};\n" +
"/** @constructor @implements {Parent} */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"Child.prototype.method = function(x){};");
checkNoWarnings(
"/** @interface */ function Parent() {}\n" +
"/** @param {*} x */\n" +
"Parent.prototype.method = function(x){};\n" +
"/** @constructor @implements {Parent} */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"Child.prototype.method = function(x){};");
checkNoWarnings(
"/** @interface */ function Parent() {}\n" +
"/** @param {?} x */\n" +
"Parent.prototype.method = function(x){};\n" +
"/** @constructor @implements {Parent} */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"Child.prototype.method = function(x){};");
checkNoWarnings(
"/** @interface */ function Parent() {}\n" +
"/**\n" +
" * @param {string} x\n" +
" * @param {number} y\n" +
" */\n" +
"Parent.prototype.method = function(x, y){};\n" +
"/** @constructor @implements {Parent} */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" * @param {T} y\n" +
" */\n" +
"Child.prototype.method = function(x, y){};");
checkNoWarnings(
"/** @interface */ function Parent() {}\n" +
"/**\n" +
" * @template A, B\n" +
" * @param {A} x\n" +
" * @param {B} y\n" +
" * @return {A}\n" +
" */\n" +
"Parent.prototype.method = function(x, y){};\n" +
"/** @constructor @implements {Parent} */\n" +
"function Child() {}\n" +
"/**\n" +
" * @template A, B\n" +
" * @param {A} x\n" +
" * @param {B} y\n" +
" * @return {B}\n" +
" */\n" +
"Child.prototype.method = function(x, y){ return y; };");
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" * @return {T}\n" +
" */\n" +
"function f(x) { return x; }\n" +
"/** @const */\n" +
"var y = f(1, 2);",
ImmutableList.of(
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,
TypeCheck.WRONG_ARGUMENT_COUNT));
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" * @return {T}\n" +
" */\n" +
"function f(x) { return x; }\n" +
"/** @const */\n" +
"var y = f();",
ImmutableList.of(
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,
TypeCheck.WRONG_ARGUMENT_COUNT));
"/**\n" +
" * @template T\n" +
" * @param {!Array<T>} arr\n" +
" * @return {T}\n" +
" */\n" +
"/** @const */\n" +
"/** @const */ var ns = {};\n" +
"/** @const */ ns.o = { /** @const */ PROP: 5 };");
public void testIndex() {
setFilename("foo/index.js");
test(
"var name = require('../name'); exports.bar = 1;",
"goog.provide('module$foo$index');" +
"var module$foo$index = {};" +
"goog.require('module$name');" +
"var name$$module$foo$index = module$name;" +
"module$foo$index.bar = 1;");
public void testJSDocNameVisibility() {
getGlobalVar(table, "foo").getVisibility());
getGlobalVar(table, "bar").getVisibility());
getGlobalVar(table, "baz").getVisibility());
getGlobalVar(table, "quux").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "xyzzy").getVisibility());
assertNull(getGlobalVar(table, "xyzzy").getJSDocInfo());
public void testJSDocNameVisibilityWithFileOverviewVisibility() {
SymbolTable table = createSymbolTable(
"/** @fileoverview\n @package */\n" +
"/** @public */ var foo;\n" +
"/** @protected */ var bar;\n" +
"/** @package */ var baz;\n" +
"/** @private */ var quux;\n" +
"var xyzzy;");
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "foo").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "bar").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "baz").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "quux").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "xyzzy").getVisibility());
assertNull(getGlobalVar(table, "xyzzy").getJSDocInfo());
public void testJSDocPropertyVisibility() {
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "Foo.prototype.bar").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "Foo.prototype.baz").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.quux").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "Foo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "Foo.prototype.plugh").getVisibility());
assertNull(getGlobalVar(table, "Foo.prototype.plugh").getJSDocInfo());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.bar").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.baz").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.quux").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.INHERITED,
getGlobalVar(table, "SubFoo.prototype.plugh").getVisibility());
public void testJSDocPropertyVisibilityWithFileOverviewVisibility() {
SymbolTable table = createSymbolTable(
"/** @fileoverview\n @package */\n" +
"/** @constructor */ var Foo = function() {};\n" +
"/** @public */ Foo.prototype.bar;\n" +
"/** @protected */ Foo.prototype.baz;\n" +
"/** @package */ Foo.prototype.quux;\n" +
"/** @private */ Foo.prototype.xyzzy;\n" +
"Foo.prototype.plugh;\n" +
"/** @constructor @extends {Foo} */ var SubFoo = function() {};\n" +
"/** @override @public */ SubFoo.prototype.bar = function() {};\n" +
"/** @override @protected */ SubFoo.prototype.baz = function() {};\n" +
"/** @override @package */ SubFoo.prototype.quux = function() {};\n" +
"/** @override @private */ SubFoo.prototype.xyzzy = function() {};\n" +
"/** @override */ SubFoo.prototype.plugh = function() {};");
assertEquals(Visibility.PUBLIC,
getGlobalVar(table, "Foo.prototype.bar").getVisibility());
assertEquals(Visibility.PROTECTED,
getGlobalVar(table, "Foo.prototype.baz").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.quux").getVisibility());
assertEquals(Visibility.PRIVATE,
getGlobalVar(table, "Foo.prototype.xyzzy").getVisibility());
assertEquals(Visibility.PACKAGE,
getGlobalVar(table, "Foo.prototype.plugh").getVisibility());
assertNull(getGlobalVar(table, "Foo.prototype.plugh").getJSDocInfo());
getGlobalVar(table, "SubFoo.prototype.bar").getVisibility());
getGlobalVar(table, "SubFoo.prototype.baz").getVisibility());
getGlobalVar(table, "SubFoo.prototype.quux").getVisibility());
getGlobalVar(table, "SubFoo.prototype.xyzzy").getVisibility());
getGlobalVar(table, "SubFoo.prototype.plugh").getVisibility());
public void testThrow() {
parse("throw Error();");
parse("throw new Error();");
parse("throw '';");
parseError("throw;", "semicolon/newline not allowed after 'throw'");
parseError("throw\nError();", "semicolon/newline not allowed after 'throw'");RawNominalType rawNominal = globalScope.getNominalType(new QualifiedName("Object"));
.instantiateGenericsFromArgumentList(argTypes.build());
return true;
FunctionType result = FunctionType.meet(this, other);
if (this.isLoose && !result.isLoose()) {
result = result.withLoose();
return result;
for (Map.Entry<String, JSType> concreteTypeEntry : concreteTypes.entrySet()) {
public FunctionType instantiateGenericsFromArgumentList(
public void testGenericsSubtyping1() {
public void testGenericsSubtyping2() {
public void testGenericsSubtyping3() {
public void testGenericsSubtyping4() {
public void testGenericsSubtyping5() {
"/** @param {!Array<T>} arr @return {T} @template T */\n" +case Token.PARAM_LIST:
visitParamList(n, parent);
break;
return;
newRHS = IR.getelem(IR.name(tempVarName), child.removeFirstChild());
newLHS = child.removeFirstChild();
return;
String tempVarName = DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
paramList.replaceChild(param, IR.name(tempVarName));
for (Node child = param.getFirstChild();
child != null;
child = child.getNext()) {
Node newLHS, newRHS;
if (child.isComputedProp()) {
Node getelem = IR.getelem(IR.name(tempVarName), child.removeFirstChild());
if (child.getLastChild().isDefaultValue()) {
newLHS = child.getFirstChild().removeFirstChild();
newRHS = defaultValueHook(getelem,
child.getFirstChild().getLastChild().detachFromParent());
newLHS = child.removeFirstChild();
newRHS = getelem;
if (child.hasChildren()) {
Node getprop = new Node(child.isQuotedString() ? Token.GETELEM : Token.GETPROP,
IR.name(tempVarName), IR.string(child.getString()));
if (child.getFirstChild().isDefaultValue()) {
newLHS = child.getFirstChild().removeFirstChild();
newRHS = defaultValueHook(getprop,
child.getFirstChild().getLastChild().detachFromParent());
newLHS = child.removeFirstChild();
newRHS = getprop;
newLHS = IR.name(child.getString());
newRHS = IR.getprop(IR.name(tempVarName), IR.string(child.getString()));
newLHS = child.removeFirstChild();
Node getprop = IR.getprop(IR.name(tempVarName), IR.string(newLHS.getString()));
newRHS = defaultValueHook(getprop, child.removeFirstChild());
Preconditions.checkState(false, "Unexpected object pattern child: %s", child);
return;
Node newDecl = IR.var(newLHS, newRHS);
newDecl.useSourceInfoIfMissingFromForTree(child);
block.addChildAfter(newDecl, insertSpot);
insertSpot = newDecl;
compiler.reportCodeChange();
int index = 0;
Node next;
for (Node child = param.getFirstChild();
child != null;
child = next) {
next = child.getNext();
if (child.isEmpty()) {
child.detachFromParent();
index++;
cannotConvertYet(child, "'...' in an array pattern");
cannotConvertYet(child, "default_value in an array pattern in a param list");
Node newDecl = IR.var(
child.detachFromParent(),
IR.getelem(
IR.name(tempVarName),
IR.number(index++)));
newDecl.useSourceInfoIfMissingFromForTree(child);
block.addChildAfter(newDecl, insertSpot);
insertSpot = newDecl;
Preconditions.checkState(false, "Unexpected array pattern child: %s", child);
compiler.reportCodeChange();
"  var x = $jscomp$destructuring$var0[0];",
"  var y = $jscomp$destructuring$var0[1];",
"  var x = $jscomp$destructuring$var0[0];",
"  var y = $jscomp$destructuring$var0[2];",
"  var x = $jscomp$destructuring$var0['KEY']",
"  var b = $jscomp$destructuring$var0.a",
"  var a = $jscomp$destructuring$var0.a",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0.k;",
"  var a = $jscomp$destructuring$var1.subkey;",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0.k;",
"  var x = $jscomp$destructuring$var1[0];",
"  var y = $jscomp$destructuring$var1[1];",
"  var z = $jscomp$destructuring$var1[2];",
"  var x = $jscomp$destructuring$var0.key === undefined ?",
"      5 : $jscomp$destructuring$var0.key",
"  var x = $jscomp$destructuring$var0[key] === undefined ?",
"      5 : $jscomp$destructuring$var0[key]",
"  var x = $jscomp$destructuring$var0.x === undefined ?",
"      5 : $jscomp$destructuring$var0.x",System.out.println("SuggestedFixes: " + fixes);return replacements.toString();Preconditions.checkState(false);
return;
if (dependencies.size() == 0 || wasModified()) {
Map<Character, String> jsMap = new HashMap<Character, String>();
import java.util.Arrays;
ObjectType[] keptFrom1 = Arrays.copyOf(objs1Arr, objs1Arr.length);
return isValidKeyword(name) ? nameToKeyword(name).kind == kind : false;
"Expected a function node, found " + n);
"Expected a function node, found " + n);
"Expected a call node, found " + n);
"Expected a call node, found " + n);
"Expected a call node, found " + n);
if (expr.getString().equals("")) {
if (jsType != null && jsType.isEnumType()
&& providedJsType.isEquivalentTo(
jsType.toMaybeEnumType().getElementsType().getPrimitiveType())) {
return true;
return false;
if (jsDoc != null && jsType != null
&& providedJsType.isEquivalentTo(jsType.restrictByNotNullOrUndefined())) {
return true;
return false;
Preconditions.checkNotNull(info, "Node " + n + " does not have JS Doc associated with it.");
for (int i = 0; i < outEdges.size(); i++) {
result.add(aResult);
Deque<Node> queue = Lists.newLinkedList();
Deque<Node> queue = Lists.newLinkedList();
assertTrue(vf.equals(same));
assertTrue(same.equals(vf));ClosureBundler.appendInput(out, input, file, inputCharset);
static void appendPrefix(Appendable out, DependencyInfo info) throws IOException {
out.append("goog.loadModule(function(exports) {"
+ "'use strict';");
static void appendPostfix(Appendable out, DependencyInfo info) throws IOException {
if (info.isModule()) {
public static void appendInput(
Appendable out,
DependencyInfo info,
File input, Charset inputCharset) throws IOException {
appendPrefix(out, info);
Files.copy(input, inputCharset, out);
appendPostfix(out, info);
public static void appendInput(
Appendable out,
DependencyInfo info,
String contents) throws IOException {
appendPrefix(out, info);
out.append(contents);
appendPostfix(out, info);import java.util.Iterator;
warnings.add(JSError.make(
declNode, TypeCheck.CONFLICTING_SHAPE_TYPE,
"struct", className));
warnings.add(JSError.make(
declNode, TypeCheck.CONFLICTING_SHAPE_TYPE, "dict", className));
if (symbolTable.getArrayType().isUnknown()) { // no externs
return !t.isUnknown() && t.isSubtypeOf(symbolTable.getArrayType());
checkNoWarnings("", js);
return typeCheck("", js, warningKind);usage = "Displays this message on stdout and exit")
usage = "Prints the compiler version to stdout and exit.")
private void printUsage(PrintStream ps) {
(new CmdLineParser(this)).printUsage(ps);
ps.flush();
private boolean errors = false;
private boolean runCompiler = false;
private PrintStream errorStream;
private void reportError(String message) {
errors = true;
errorStream.println(message);
errorStream.flush();
private void processFlagFile()
reportError("ERROR - Arguments in the file cannot contain "
errorStream = err;
processFlagFile();
reportError(e.getMessage());
reportError("ERROR - " + flags.flagFile + " read error.");
reportError("Please specify --common_js_entry_module.");
reportError("ERROR - invalid output_wrapper_file specified.");
reportError("ERROR - invalid output_wrapper specified. Missing '" +
if (errors) {
errorStream.println("Run with the --help option for the usage");
errorStream.flush();
flags.printUsage(out);
out.println(
"Closure Compiler (http://github.com/google/closure-compiler)\n" +
"Version: " + Compiler.getReleaseVersion() + "\n" +
"Built on: " + Compiler.getReleaseDate());
out.flush();
runCompiler = true;
errorStream = null;
return this.runCompiler;
public boolean hasErrors() {
return this.errors;
if (runner.hasErrors()) {
if (NodeUtil.isNamespaceDecl(parent)) {
Node namespaceName = parent.isAssign() ? parent.getFirstChild() : parent;
visitNamespacePropertyDeclaration(prop, namespaceName, prop.getString());
private JSType getTypeAtPropDeclNode(Node getProp, JSDocInfo jsdoc) {
Node parent = getProp.getParent();
if (parent.isAssign() && parent.getLastChild().isFunction()) {
currentScope.getScope(getFunInternalName(parent.getLastChild()))
if (isEnumDecl(n)) {
JSDocInfo jsdoc = getBestJSDocInfo(n);
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
String output = new String(outReader.toByteArray(), UTF_8);
assertTrue(output.indexOf(" --help ") >= 0);
assertTrue(output.indexOf(" --version ") >= 0);
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertTrue(runner.hasErrors());
if (!runner.shouldRunCompiler()) {
assertTrue(runner.hasErrors());
fail(new String(errReader.toByteArray()));
public void testStringKeyConstants() {
"var x = 5; /** @const */ var o = { /** @const {number} */ PROP: x};");if (inheritedType.isSubtypeOf(resultType)) {
Preconditions.checkState(nominalType == null || receiverType == null);
Preconditions.checkState(!isLoose || receiverType == null);
if (nominalType != null
&& !nominalType.unifyWith(other.nominalType, typeParameters, typeMultimap)) {
if (receiverType != null
&& !receiverType.unifyWith(other.receiverType, typeParameters, typeMultimap)) {
for (String typeVar : rawType.getTypeParameters()) {
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
for (String typeVar : rawType.getTypeParameters()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, typeMap.keySet());
Preconditions.checkState(other.typeMap.containsKey(typeVar));
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
if (t1.nominalType != t2.nominalType) {
if (t1.fn != t2.fn) {
throw new RuntimeException("Unification of functions not yet supported");
return makeObjectType(t1.nominalType, newProps, t1.fn,switch (n.getType()) {
case Token.NAME:
case Token.GETELEM:
case Token.GETPROP:
validateExpression(n);
return;
default:
violation("Expected assignment target expression but was "
+ Token.name(n.getType()), n);
child.detachFromParent(), newRHS, parent.getType())
.useSourceInfoFromForTree(arrayPattern);
if (!validAssignmentTarget(target)) {
if (!validAssignmentTarget(operand)) {
if (!validAssignmentTarget(operand)) {
private boolean validAssignmentTarget(Node target) {
switch (target.getType()) {
case Token.CAST: // CAST is a bit weird, but syntactically valid.
case Token.NAME:
case Token.GETPROP:
case Token.GETELEM:
case Token.ARRAY_PATTERN:
case Token.OBJECT_PATTERN:
return true;
return false;"(setUpPage|setUp|shouldRunTests|tearDown|tearDownPage|test\\w+))$");
if (isTestFunction(n, functionName)) {
if (isTestFunction(functionNode, functionName)) {
if (isTestFunction(n, functionName)) {
private static boolean isTestFunction(Node n, String functionName) {
return !(functionName == null
|| !TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches());
if (!maybeName.isName() || (n.getFirstChild().isClass() && i > 0)) {
+ "function testBar(arg) {}";
+ "function testBar(arg){} google_exportSymbol(\"testBar\",testBar)"boolean needsConversion = options.getLanguageIn() != options.getLanguageOut();
if (needsConversion && options.processCommonJSModules) {
new TransformEs6ModuleToCjsModule(this).process(null, root);
boolean needsConversion = options.getLanguageIn() != options.getLanguageOut();
this, options.commonJSModulePathPrefix), true, !needsConversion);
if (options.processCommonJSModules && !needsConversion) {
private static final String MODULE_SLASH = ES6ModuleLoader.MODULE_SLASH;
static final DiagnosticType LOAD_ERROR = DiagnosticType.error(
"JSC_ES6_MODULE_LOAD_ERROR",
"Failed to load module \"{0}\"");
private final boolean overrideModule;
private boolean dontProcess;
this(compiler, loader, true, true);
boolean reportDependencies, boolean overrideModule) {
this.overrideModule = overrideModule;
dontProcess = false;
NodeTraversal.traverse(compiler, root, new FindGoogProvideAndGoogModule());
if (dontProcess) {
filename.replaceAll("^\\." + Pattern.quote(MODULE_SLASH), "")
.replaceAll(Pattern.quote(MODULE_SLASH), MODULE_NAME_SEPARATOR)
private class FindGoogProvideAndGoogModule extends AbstractPreOrderCallback {
dontProcess = true;
t.makeError(require, LOAD_ERROR, requireName);
if (overrideModule) {
m.addAndOverrideModule(ci);
t.makeError(typeNode, LOAD_ERROR, moduleName);
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.LinkedHashMap;
import java.util.Map;
public class TransformEs6ModuleToCjsModule extends AbstractPostOrderCallback
implements CompilerPass {
private final Compiler compiler;
private int scriptNodeCount = 0;
private Map<String, String> exportMap = new LinkedHashMap<>();
TransformEs6ModuleToCjsModule(Compiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isImport()) {
visitImport(t, n, parent);
visitExport(t, n, parent);
scriptNodeCount++;
visitScript(t, n);
private void visitImport(NodeTraversal t, Node n, Node parent) {
String module = n.getLastChild().getString();
Map<String, String> nameMap = new LinkedHashMap<>();
for (Node child : n.children()) {
if (child.isEmpty() || child.isString()) {
continue;
nameMap.put(child.getString(), child.getString());
for (Node grandChild : child.children()) {
Node origName = grandChild.getFirstChild();
nameMap.put(origName.getString(), grandChild.getChildCount() == 2
? grandChild.getLastChild().getString() // import {a as foo} from "mod"
: origName.getString()); // import {a} from "mod"
for (Map.Entry<String, String> entry : nameMap.entrySet()) {
Node call = IR.call(IR.name("require"), IR.string(module));
call.putBooleanProp(Node.FREE_CALL, true);
parent.addChildBefore(
IR.var(
IR.name(entry.getValue()),
IR.getprop(call, IR.string(entry.getKey())))
.useSourceInfoIfMissingFromForTree(n),
n);
parent.removeChild(n);
compiler.reportCodeChange();
private void visitExport(NodeTraversal t, Node n, Node parent) {
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
compiler.report(JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Default export"));
compiler.report(JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Wildcard export"));
if (n.getChildCount() == 2) {
compiler.report(JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT_YET,
"Export with FromClause"));
return;
if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
for (Node grandChild : n.getFirstChild().children()) {
Node origName = grandChild.getFirstChild();
exportMap.put(
grandChild.getChildCount() == 2
? grandChild.getLastChild().getString()
: origName.getString(),
origName.getString());
parent.removeChild(n);
for (Node grandChild : n.getFirstChild().children()) {
if (!grandChild.isName()) {
break;
String name = grandChild.getString();
Var v = t.getScope().getVar(name);
if (v == null || v.isGlobal()) {
exportMap.put(name, name);
parent.replaceChild(n, n.removeFirstChild());
compiler.reportCodeChange();
private void visitScript(NodeTraversal t, Node script) {
Preconditions.checkArgument(scriptNodeCount == 1,
"ProcessEs6Modules supports only one invocation per "
+ "CompilerInput / script node");
if (exportMap.isEmpty()) {
return;
Node objectlit = IR.objectlit();
for (String name : exportMap.keySet()) {
objectlit.addChildToBack(
IR.stringKey(name, IR.name(exportMap.get(name))));
script.addChildToBack(IR.exprResult(IR.assign(
IR.getprop(IR.name("module"), IR.string("exports")), objectlit))
.useSourceInfoIfMissingFromForTree(script));
compiler.reportCodeChange();
exportMap.clear();
false,
package com.google.javascript.jscomp;
import com.google.common.base.Joiner;
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
public class TransformEs6ModuleToCjsModuleTest extends CompilerTestCase {
public TransformEs6ModuleToCjsModuleTest() {
compareJsDoc = false;
public void setUp() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
enableAstValidation(true);
runTypeCheckAfterProcessing = true;
protected CompilerOptions getOptions() {
CompilerOptions options = super.getOptions();
options.setLanguageOut(LanguageMode.ECMASCRIPT3);
return options;
protected CompilerPass getProcessor(Compiler compiler) {
return new TransformEs6ModuleToCjsModule(compiler);
protected int getNumRepetitions() {
return 1;
public void testImport() {
test("import name from \"test\";", "var name = require(\"test\").name;");
test("import {n as name} from \"test\";", "var name = require(\"test\").n;");
test("import x, {f as foo, b as bar} from \"test\";", Joiner.on('\n').join(
"var x = require(\"test\").x;",
"var foo = require(\"test\").f;",
"var bar = require(\"test\").b"
));
public void testExport() {
test("export var a = 1, b = 2;",
"var a = 1, b = 2; module.exports = {a: a, b: b};");
test("export var a; export var b;",
"var a; var b; module.exports = {a: a, b: b};");
test("export function f() {};", "function f() {} module.exports = {f: f};");
test("export {f as foo, b as bar};", "module.exports = {foo: f, bar: b};");
public void testImportAndExport() {
test(Joiner.on('\n').join(
"import {name as n} from \"test\";",
"export {n as name};"
), Joiner.on('\n').join(
"var n = require(\"test\").name;",
"module.exports = {name: n};"
));if (!n.getFirstChild().isName()) {
call.putBooleanProp(Node.FREE_CALL, true);"based on available information.  Inaccurate type annotations " +
+ "goog.require(), goog.provide(), and goog.exportSymbol()")
+ "not provide dependencies will be removed. This supersedes"
currFuncRenameMap.put(
oldName, oldName + "$" + compiler.getUniqueNameIdSupplier().get());
String newName = doRename
? oldName + "$" + compiler.getUniqueNameIdSupplier().get()
: oldName;
new LoopObject(
LOOP_OBJECT_NAME + "$" + compiler.getUniqueNameIdSupplier().get()));
Node iterName = IR.name(ITER_BASE + compiler.getUniqueNameIdSupplier().get());
Node freshVar = IR.name(FRESH_SPREAD_VAR + compiler.getUniqueNameIdSupplier().get());
String objName = FRESH_COMP_PROP_VAR + compiler.getUniqueNameIdSupplier().get();
if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
JSDocInfoBuilder memberDoc;
if (info == null) {
memberDoc = new JSDocInfoBuilder(true);
memberDoc = JSDocInfoBuilder.copyFrom(info);
memberDoc.recordThisType(
new JSTypeExpression(new Node(Token.BANG, new Node(Token.QMARK)),
member.getSourceFileName()));
info = memberDoc.build(assign);
switch (n.getParent().getType()) {
case Token.EQ:
case Token.GT:
case Token.GE:
case Token.LE:
case Token.LT:
case Token.NE:
Node number = IR.number(n.isTrue() ? 1 : 0);
n.getParent().replaceChild(n, number);
reportCodeChange();
return number;
ExtractionInfo templateInfo = extractSingleLineBlock();
String templateNames;
String typeTransformationStart = "";
if (templateInfo.string.contains(" as")) {
int typeTransformationIndex = templateInfo.string.indexOf(" as");
templateNames = templateInfo.string
.substring(0, typeTransformationIndex);
typeTransformationStart = templateInfo.string
.substring(typeTransformationIndex + 3);
templateNames = templateInfo.string;
.split(templateNames));
if (isTypeTransformation) {
if (names.size() > 1) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.with.multiple.names",
stream.getLineno(), stream.getCharno());
ExtractionInfo typeTransformationInfo =
extractMultilineTextualBlock(templateInfo.token);
String typeTransformationEnd = typeTransformationInfo.string;
String typeTransformationString =
typeTransformationStart + typeTransformationEnd;
if (typeTransformationString.equals("")) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.expression.missing",
stream.getLineno(), stream.getCharno());
token = typeTransformationInfo.token;
token = templateInfo.token;
new Node(type, n, n.getLineno(),
n.getCharno()).clonePropsFrom(templateNode);
case 'e':
case 'E':
case 'e':
case 'E':
return scanExponentOfNumericLiteral(beginToken);
skipDecimalDigits();
if (peek('.')) {
nextChar();
skipDecimalDigits();
return new LiteralToken(
TokenType.NUMBER, getTokenString(beginToken), getTokenRange(beginToken));
"/** @this {?} */",
public void testStaticThis() {
test("class F { static f() { return this; } }", Joiner.on('\n').join(
"/** @constructor @struct */ var F = function() {}",
"/** @this {?} */ F.f = function() { return this; };"));
public void testFoldTrueFalseComparison() {
fold("x == true", "x == 1");
fold("x == false", "x == 0");
fold("x != true", "x != 1");
fold("x < true", "x < 1");
fold("x <= true", "x <= 1");
fold("x > true", "x > 1");
fold("x >= true", "x >= 1");
public void testParserWithTypeTransformationNewline() {
parse("@template R as\n type('string')*/",
"Bad type annotation. Missing type transformation expression");
public void testParserWithTypeTransformation() {
public void testBug16129690() {
parse("@param {T} x\n"
+ "@template T\n"
+ "random documentation text*/");
public void testExponentialLiterals() {
parse("0e0");
parse("0E0");
parse("0E1");
parse("1E0");
parse("1E-0");
parse("10E10");
parse("10E-10");
parse("1.0E1");
parseError("01E0",
"Semi-colon expected");
parseError("0E",
"Exponent part must contain at least one digit");
parseError("1E-",
"Exponent part must contain at least one digit");
parseError("1E1.1",
"Semi-colon expected");JSError error = JSError.make(n, diagnostic, n.toString());
+ Token.name(parent.getType()) + " node.", n);
if (c == n.getLastChild() && NodeUtil.isNameDeclaration(n.getParent())) {
validateRest(c);
case Token.STRING_KEY:
case Token.GETTER_DEF:
case Token.SETTER_DEF:
checkKeyVisibilityConvention(t, n, parent);
break;
private void checkKeyVisibilityConvention(NodeTraversal t,
Node key, Node parent) {
JSDocInfo info = key.getJSDocInfo();
if (info == null) {
return;
if (!isPrivateByConvention(key.getString())) {
return;
Node assign = parent.getParent();
if (assign == null || !assign.isAssign()) {
return;
Node left = assign.getFirstChild();
if (!left.isGetProp()
|| !left.getLastChild().getString().equals("prototype")) {
return;
Visibility declaredVisibility = info.getVisibility();
if (declaredVisibility != Visibility.INHERITED
&& declaredVisibility != Visibility.PRIVATE) {
compiler.report(t.makeError(key, CONVENTION_MISMATCH));
compiler.report(JSError.make(n, EVENTFUL_OBJECT_NOT_DISPOSED));
compiler.report(JSError.make(n, EVENTFUL_OBJECT_PURELY_LOCAL));
compiler.report(JSError.make(n, UNLISTEN_WITH_ANONBOUND));
compiler.report(JSError.make(n, UNLISTEN_WITH_ANONBOUND));
compiler.report(JSError.make(n, UNLISTEN_WITH_ANONBOUND));
JSError.make(ref.node, STRICT_MODULE_DEP_QNAME,
JSError.make(ref.node, level,
JSError.make(n,
JSError.make(ref.node,
JSError.make(ref.node,
JSError.make(n, UNSAFE_THIS, name.getFullName()));
JSError.make(node, UNMATCHED_START_MARKER, startMarkerName));
checks.add(es6HandleDefaultParams);
checks.add(rewriteLetConst);
checks.add(rewriteGenerators);
checks.add(markTranspilationDone);
final HotSwapPassFactory es6HandleDefaultParams =
new HotSwapPassFactory("Es6HandleDefaultParams", true) {
protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
return new Es6HandleDefaultParameters(compiler);
return new Es6ToEs3Converter(compiler);
final HotSwapPassFactory rewriteLetConst =
new HotSwapPassFactory("Es6RewriteLetConst", true) {
protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
return new Es6RewriteLetConst(compiler);
final HotSwapPassFactory rewriteGenerators =
new HotSwapPassFactory("rewriteGenerators", true) {
protected HotSwapCompilerPass create(final AbstractCompiler compiler) {
return new Es6RewriteGenerators(compiler);
final PassFactory markTranspilationDone = new PassFactory("setLanguageMode", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
return new CompilerPass() {
public void process(Node externs, Node root) {
compiler.setLanguageMode(options.getLanguageOut());
n, propertiesToErrorFor.get(name),
child, propertiesToErrorFor.get(name),
node,
public Es6HandleDefaultParameters(AbstractCompiler compiler) {
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator(compiler);
Scope fScope = creator.createScope(n, t.getScope());
Scope fBlockScope = creator.createScope(block, fScope);
currFuncRenameMap.put(
oldName, oldName + "$" + compiler.getUniqueNameIdSupplier().get());
.traverseInnerNode(block, block.getParent(), fScope);
package com.google.javascript.jscomp;
import com.google.common.base.Joiner;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
public class Es6RewriteGenerators extends NodeTraversal.AbstractPostOrderCallback
implements HotSwapCompilerPass {
private final AbstractCompiler compiler;
private static final String ITER_KEY = "$$iterator";
private static final String GENERATOR_CONTEXT = "$jscomp$generator$state";
public Es6RewriteGenerators(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
public void hotSwapScript(Node scriptRoot, Node originalRoot) {
NodeTraversal.traverse(compiler, scriptRoot, this);
public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.FUNCTION:
if (n.isGeneratorFunction()) {
visitGenerator(n, parent);
private void visitGenerator(Node n, Node parent) {
Node genBlock = compiler.parseSyntheticCode(Joiner.on('\n').join(
"{",
"  return {" + ITER_KEY + ": function() {",
"    var " + GENERATOR_CONTEXT + " = 0;",
"    return { next: function() {",
"      while (1) switch (" + GENERATOR_CONTEXT + ") {",
"        case 0:",
"          " + GENERATOR_CONTEXT + " = -1;",
"        default:",
"          return {done: true};",
"      }",
"    }}",
"  }}",
"}"
)).removeFirstChild();
Node genFunc = IR.function(n.removeFirstChild(), n.removeFirstChild(), genBlock);
parent.replaceChild(n, genFunc);
parent.useSourceInfoIfMissingFromForTree(parent);
compiler.reportCodeChange();
public Es6RewriteLetConst(AbstractCompiler compiler) {
String newName = doRename
? oldName + "$" + compiler.getUniqueNameIdSupplier().get()
: oldName;
new LoopObject(
LOOP_OBJECT_NAME + "$" + compiler.getUniqueNameIdSupplier().get()));
Node iterName = IR.name(ITER_BASE + compiler.getUniqueNameIdSupplier().get());
if (!superName.isQualifiedName()) {
return;
Node freshVar = IR.name(FRESH_SPREAD_VAR + compiler.getUniqueNameIdSupplier().get());
String objName = FRESH_COMP_PROP_VAR + compiler.getUniqueNameIdSupplier().get();
if (NodeUtil.referencesSuper(classNode) && !superClassName.isQualifiedName()) {
if (!className.isEmpty() && !className.getString().equals(fullClassName)) {
cannotConvertYet(classNode, "named class in an assignment");
return;
if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
JSDocInfoBuilder memberDoc;
if (info == null) {
memberDoc = new JSDocInfoBuilder(true);
memberDoc = JSDocInfoBuilder.copyFrom(info);
memberDoc.recordThisType(
new JSTypeExpression(new Node(Token.BANG, new Node(Token.QMARK)),
member.getSourceFileName()));
info = memberDoc.build(assign);
compiler.report(JSError.make(errorRoot, warning, args));
compiler.report(JSError.make(errorRoot, error, args));
return new JSError(n == null ? null : n.getSourceFileName(), n, type, arguments);
public static JSError make(Node n, CheckLevel level, DiagnosticType type, String... arguments) {
return new JSError(
n.getSourceFileName(), n, n.getLineno(), n.getCharno(), type, level, arguments);
import java.util.HashSet;
private final Set<Node> googMsgNodes = new HashSet<>();
for (Node msgNode : googMsgNodes) {
compiler.report(JSError.make(msgNode,
googMsgNodes.add(node);
JSError error = JSError.make(n, diagnosticType, arguments);
return JSError.make(n, level, type, arguments);
return JSError.make(n, type, arguments);
compiler.report(JSError.make(n, CATCH_BLOCK_VAR_ERROR, name));
r.requireNode, requiresLevel, error, r.namespace));
compiler.report(JSError.make(
compiler.report(JSError.make(
compiler.report(JSError.make(
ImmutableSet.of(Token.VAR, Token.LET, Token.CONST, Token.PARAM_LIST,
while (parent.isArrayPattern()) {
parent = parent.getParent();
return DECLARATION_PARENTS.contains(parent.getType());
compiler.report(JSError.make(
compiler.report(JSError.make(
compiler.report(JSError.make(e.getNode(),
compiler.report(JSError.make(n, DATAFLOW_ERROR));
report(JSError.make(n, UNKNOWN_TYPEOF_VALUE, found));
report(JSError.make(indexNode,
mismatch(n, "mismatch in declaration of superclass type",
report(JSError.make(n, DUP_VAR_DECLARATION,
report(JSError.make(n, DUP_VAR_DECLARATION_TYPE_MISMATCH,
report(JSError.make(n,
mismatch(n, msg, found, required);
private void mismatch(Node n, String msg, JSType found, JSType required) {
JSError.make(n, TYPE_MISMATCH_WARNING,
checkForClassDefiningCalls(n);
JSError.make(objectLit, UNKNOWN_LENDS, lendsName));
JSError.make(objectLit, LENDS_ON_NON_OBJECT,
compiler.report(JSError.make(n, MULTIPLE_VAR_DEF));
JSError.make(key, ENUM_NOT_CONSTANT, keyName));
JSError.make(key, ENUM_NOT_CONSTANT, keyName));
compiler.report(JSError.make(n, ENUM_INITIALIZER));
JSError.make(n,
private void checkForClassDefiningCalls(Node n) {
compiler.report(JSError.make(n, CONSTRUCTOR_EXPECTED));
compiler.report(JSError.make(n, objectLiteralCast.diagnosticType));
checkForTypedef(n.getFirstChild(), n.getJSDocInfo());
checkForTypedef(n, info);
private void checkForTypedef(Node candidate, JSDocInfo info) {
JSError.make(candidate, MALFORMED_TYPEDEF, typedef));
JSError.make(n,
JSError.make(n, VAR_ARGUMENTS_SHADOWED_ERROR));
JSError.make(
JSError.make(
JSError.make(
JSError.make(
JSError.make(reference.getNode(),
JSError.make(referenceNode,
JSError.make(referenceNode,
ExtractionInfo templateInfo =
extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
String templateString = templateInfo.string;
String ttlStartDelimiter = ":=";
String ttlEndDelimiter = "=:";
String templateNames;
String typeTransformationExpr = "";
if (!templateString.contains(ttlStartDelimiter)) {
if (templateString.contains("\n")) {
templateNames =
templateString.substring(0, templateString.indexOf('\n'));
templateNames = templateString;
int ttlStartIndex = templateString.indexOf(ttlStartDelimiter);
templateNames = templateString.substring(0, ttlStartIndex);
if (!templateString.contains(ttlEndDelimiter)) {
"msg.jsdoc.typetransformation.missing.delimiter",
isTypeTransformation = true;
int ttlEndIndex = templateString.indexOf(ttlEndDelimiter);
typeTransformationExpr = templateString.substring(
ttlStartIndex + ttlStartDelimiter.length(),
ttlEndIndex).trim();
.split(templateNames));
if (isTypeTransformation) {
if (names.size() > 1) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.with.multiple.names",
stream.getLineno(), stream.getCharno());
if (typeTransformationExpr.equals("")) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.expression.missing",
stream.getLineno(), stream.getCharno());
new Node(type, n, n.getLineno(),
n.getCharno()).clonePropsFrom(templateNode);
Node processAssignmentRestElement(AssignmentRestElementTree tree) {
return newStringNode(Token.REST, tree.identifier.value);
case 'e':
case 'E':
import com.google.javascript.jscomp.parsing.parser.trees.AssignmentRestElementTree;
abstract T processAssignmentRestElement(AssignmentRestElementTree tree);
case ASSIGNMENT_REST_ELEMENT:
return processAssignmentRestElement(node.asAssignmentRestElement());
arguments.add(parseAssignmentOrSpread());
private ParseTree parseAssignmentOrSpread() {
boolean rest = false;
rest = true;
if ((rest || kind == PatternKind.INITIALIZER)
return lvalue;
return rest
? new AssignmentRestElementTree(
getTreeLocation(start),
lvalue.asIdentifierExpression().identifierToken)
if (element.isAssignmentRestElement()) {
if (element.isAssignmentRestElement()) {
case 'e':
case 'E':
return scanExponentOfNumericLiteral(beginToken);
skipDecimalDigits();
if (peek('.')) {
nextChar();
skipDecimalDigits();
return new LiteralToken(
TokenType.NUMBER, getTokenString(beginToken), getTokenRange(beginToken));
import com.google.javascript.jscomp.parsing.parser.IdentifierToken;
public class AssignmentRestElementTree extends ParseTree {
public final IdentifierToken identifier;
public AssignmentRestElementTree(SourceRange location, IdentifierToken identifier) {
super(ParseTreeType.ASSIGNMENT_REST_ELEMENT, location);
this.identifier = identifier;
public AssignmentRestElementTree asAssignmentRestElement() {
return (AssignmentRestElementTree) this; }
public boolean isAssignmentRestElement() {
return this.type == ParseTreeType.ASSIGNMENT_REST_ELEMENT;
ASSIGNMENT_REST_ELEMENT,
"/** @protected */ bar: 3" +
"new Foo().bar;"
"/** @protected */ bar: function() {}" +
"new Foo().bar();"
public void testDeclarationAndConventionConflict4a() {
testSame(
"/** @constructor */ function Foo() {}" +
"Foo.prototype = { /** @protected */ length_: 1 }\n" +
"new Foo().length_",
CONVENTION_MISMATCH, true);
public void testDeclarationAndConventionConflict4b() {
testSame(
"var NS = {}; /** @constructor */ NS.Foo = function() {};" +
"NS.Foo.prototype = { /** @protected */ length_: 1 };\n" +
"(new NS.Foo()).length_;",
CONVENTION_MISMATCH, true);
public void testDeclarationAndConventionConflict5() {
testSame(
"/** @constructor */ function Foo() {}\n" +
"Foo.prototype = { /** @protected */ get length_() { return 1; } }\n",
CONVENTION_MISMATCH, true);
public void testDeclarationAndConventionConflict6() {
testSame(
"/** @constructor */ function Foo() {}\n" +
"Foo.prototype = { /** @protected */ set length_(x) { } }\n",
CONVENTION_MISMATCH, true);
return new Es6HandleDefaultParameters(compiler);
return new Es6RewriteLetConst(compiler);
public CompilerPass getProcessor(final Compiler compiler) {
PhaseOptimizer optimizer = new PhaseOptimizer(compiler, null, null);
DefaultPassConfig passConfig = new DefaultPassConfig(getOptions());
optimizer.addOneTimePass(passConfig.es6HandleDefaultParams);
optimizer.addOneTimePass(passConfig.convertEs6ToEs3);
optimizer.addOneTimePass(passConfig.rewriteLetConst);
optimizer.addOneTimePass(passConfig.rewriteGenerators);
return optimizer;
test("goog.example.C = class { foo() {} }", Joiner.on('\n').join(
test("class C { f() { super(); } }",
null, Es6ToEs3Converter.NO_SUPERTYPE);
test("class C { static f() { super(); } }",
null, Es6ToEs3Converter.NO_SUPERTYPE);
public void testMultiNameClass() {
test("var F = class G {}", null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("F = class G {}", null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
"/** @this {?} */",
public void testStaticThis() {
test("class F { static f() { return this; } }", Joiner.on('\n').join(
"/** @constructor @struct */ var F = function() {}",
"/** @this {?} */ F.f = function() { return this; };"));
public void testSimpleGenerator() {
test("function *f() {}", Joiner.on('\n').join(
"function f() {",
"  return { $$iterator: function() {",
"    var $jscomp$generator$state = 0;",
"    return { next: function() {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {done: true}",
"      }",
"    }}",
"  }}",
"}"
));
test("function *f(a,b) {}", Joiner.on('\n').join(
"function f(a,b) {",
"  return { $$iterator: function() {",
"    var $jscomp$generator$state = 0;",
"    return { next: function() {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {done: true}",
"      }",
"    }}",
"  }}",
"}"
));
Node n = Node.newString("foobar", 5, 8);
n.setSourceFileForTesting("javascript/complex.js");
JSError error = JSError.make(n, FOO_TYPE);
Node n = Node.newString("foobar", 5, 6);
n.setSourceFileForTesting("javascript/complex.js");
JSError error = JSError.make(n, FOO_TYPE);
Node n = Node.newString("foobar", 5, 8);
n.setSourceFileForTesting("javascript/complex.js");
JSError error = JSError.make(n, FOO_TYPE);
t.report(new Node(Token.EMPTY), dt, "Foo", "Bar", "Hello");
public void testParserWithTypeTransformationNewline() {
parse("@template R := \n type('string') =:*/");
parse("@template T := type('string') =:*/");
public void testParserWithTypeTransformation2() {
parse("@template T := type('string') =:\n"
+ "Random text*/");
parse("@template T, R := type('string') =:*/",
public void testParserWithMissingTypeTransformationExpression() {
parse("@template T := */",
+ "Expected end delimiter for a type transformation");
public void testParserWithMissingTypeTransformationExpression2() {
parse("@template T := =:*/",
"Bad type annotation. Missing type transformation expression");
public void testBug16129690() {
parse("@param {T} x\n"
+ "@template T\n"
+ "random documentation text*/");
public void testArrayDestructuringRest() {
parseError("var [first, ...[re, st]] = foo();", "'identifier' expected");
public void testExponentialLiterals() {
parse("0e0");
parse("0E0");
parse("0E1");
parse("1E0");
parse("1E-0");
parse("10E10");
parse("10E-10");
parse("1.0E1");
parseError("01E0",
"Semi-colon expected");
parseError("0E",
"Exponent part must contain at least one digit");
parseError("1E-",
"Exponent part must contain at least one digit");
parseError("1E1.1",
"Semi-colon expected");+ parent.getType() + " node.", n);
ImmutableSet.of(Token.VAR, Token.LET, Token.CONST, Token.ARRAY_PATTERN,
Node grandparent = parent.getParent();
return DECLARATION_PARENTS.contains(parent.getType()) ||
parent.isParamList() &&
grandparent.isFunction();IR.getprop(subClassName.detachFromParent(), IR.string(staticMember)),
IR.getprop(superClassName.detachFromParent(), IR.string(staticMember))));
case Token.THIS:
visitThis(n, parent);
break;
private void visitThis(Node node, Node parent) {
Node enclosingMemberDef = NodeUtil.getEnclosingClassMember(node);
if (enclosingMemberDef == null) {
return;
Node enclosingClass = NodeUtil.getEnclosingClass(node);
if (enclosingMemberDef.isStaticMember()) {
parent.replaceChild(node,
IR.name(NodeUtil.getClassName(enclosingClass)).srcref(node));
compiler.reportCodeChange();
Node enclosingMember = NodeUtil.getEnclosingClassMember(enclosing);
methodName = IR.string(enclosingMember.getString()).srcref(enclosing);
public void testStaticMethodsWithThis() {
test(Joiner.on('\n').join(
"class C {",
"  static foo() { alert(this); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.foo = function() { alert(C); };"
));propertyMapOutputPath = basePath + "_props_renaming_report.out";
variableMapOutputPath = basePath + "_vars_renaming_report.out";if (child == n.getLastChild() && n.getParent().isVar()) {
if (!n.getParent().isVar()) {
if (child == n.getLastChild() && n.getParent().isVar()) {
if (!n.getParent().isVar()) {return "LOOSE_TOP_FUNCTION";
return "TOP_FUNCTION";
StringBuilder builder = new StringBuilder("function(");
builder.append(',');
builder.deleteCharAt(builder.length() - 1);
return builder.toString();
return typeToString();
return typeToString() + "@" + location;
private String typeToString() {
return "bottom";
return "*";
return "?";
StringBuilder sb = new StringBuilder();
sb.append('|');
sb.append("boolean");
sb.append("null");
sb.append("number");
sb.append("string");
sb.append("undefined");
sb.append(typeVar);
sb.append(Iterables.getOnlyElement(objs).toString());
PIPE_JOINER.appendTo(sb, strReps);
sb.append(Iterables.getOnlyElement(enums).toString());
PIPE_JOINER.appendTo(sb, strReps);
return sb.toString();
return "truthy";
return "falsy";
return "Unrecognized type: " + tags;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
return rawType.name + rawType.genericSuffix(typeMap);
private String genericSuffix(Map<String, JSType> typeMap) {
return "";
List<String> names = Lists.newArrayList();
names.add(concrete == null ? typeParam : concrete.toString());
return ".<" + Joiner.on(",").join(names) + ">";
return name + genericSuffix(ImmutableMap.<String, JSType>of());
return fn.toString();
return nominalType.toString();
StringBuilder result = new StringBuilder();
result.append(nominalType.toString());
result.append("struct");
result.append("dict");
result.append('{');
result.append(", ");
result.append(pname);
result.append(':');
result.append(props.get(pname).toString());
result.append('}');
result.append(" (loose)");
return result.toString();
return inferredType.toString() + '^';
return inferredType.toString();
return inferredType.toString() + '=';if (e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
if (!e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
if (!e.getEnumeratedType().isSubtypeOf(t2)) {
return objs != null;
int otherMask = other.mask;
if ((otherMask & NON_SCALAR_MASK) == 0 &&
(otherMask & TYPEVAR_MASK) == 0 &&
(otherMask & ENUM_MASK) == 0) {
return ALMOST_TOP.removeType(other);
return this;
if ((otherMask & NON_SCALAR_MASK) == 0 &&
(otherMask & TYPEVAR_MASK) == 0 &&
(otherMask & ENUM_MASK) == 0) {
return new JSType(mask & ~otherMask, location, objs, typeVar, enums);
if (objs == null || (otherMask & ~NON_SCALAR_MASK) != 0) {
return this;
Preconditions.checkState(
otherMask == NON_SCALAR_MASK && other.objs.size() == 1,
"Invalid type to remove: " + other);
NominalType otherKlass =
Iterables.getOnlyElement(other.objs).getNominalType();
ImmutableSet.Builder<ObjectType> newObjs = ImmutableSet.builder();
for (ObjectType obj : objs) {
if (!Objects.equal(obj.getNominalType(), otherKlass)) {
newObjs.add(obj);
return new JSType(mask, location, newObjs.build(), typeVar, enums);
Preconditions.checkNotNull(this.objs);for (Node arg = callNode.getFirstChild(); arg != null;
pair = analyzeExprFwd(
typeofRand, inEnv, JSType.UNKNOWN, comparedType.negate());
rhsType = rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
lhsType = lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
rhsType = rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
lhsType = lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
"Cannot create type with bits <<<%X>>>, " +
private static final JSType TOP_MINUS_NULL = new JSType(
TRUE_MASK | FALSE_MASK | NUMBER_MASK | STRING_MASK | UNDEFINED_MASK |
NON_SCALAR_MASK,
null, ImmutableSet.of(ObjectType.TOP_OBJECT), null, null);
private static final JSType TOP_MINUS_UNDEF = new JSType(
NON_SCALAR_MASK,
return UNKNOWN.removeType(this);
if ((isTop() || isUnknown()) && other.equals(NULL)) {
return TOP_MINUS_NULL;
if ((isTop() || isUnknown()) && other.equals(UNDEFINED)) {
return TOP_MINUS_UNDEF;
if (other.equals(NULL) || other.equals(UNDEFINED)) {
return new JSType(mask & ~other.mask, location, objs, typeVar, enums);
if (objs == null) {
(other.mask & ~NON_SCALAR_MASK) == 0 && other.objs.size() == 1);options.sourceMapLocationMappings = config.sourceMapLocationMappings;
private List<SourceMap.LocationMapping> sourceMapLocationMappings =
Lists.newArrayList();
CommandLineConfig setSourceMapLocationMappings(
List<SourceMap.LocationMapping> locationMappings) {
this.sourceMapLocationMappings.clear();
this.sourceMapLocationMappings.addAll(locationMappings);
return this;
abstract CompilerOptions.LanguageMode getLanguageMode();
abstract void setLanguageMode(CompilerOptions.LanguageMode mode);
private final AbstractCompiler compiler;
public AstValidator(AbstractCompiler compiler, ViolationHandler handler) {
this.compiler = compiler;
public AstValidator(AbstractCompiler compiler) {
this(compiler, new ViolationHandler() {
message + ". Reference node:\n" + n.toStringTree());
case Token.CLASS:
validateClassDeclaration(n);
return;
case Token.SUPER:
case Token.CLASS:
validateClass(n);
return;
private void validateClassDeclaration(Node n) {
validateClass(n);
validateName(n.getFirstChild());
private void validateClass(Node n) {
validateEs6Feature("classes", n);
validateNodeType(Token.CLASS, n);
validateChildCount(n, Token.arity(Token.CLASS));
Node name = n.getFirstChild();
if (name.isEmpty()) {
validateChildless(name);
validateName(name);
Node superClass = name.getNext();
if (superClass.isEmpty()) {
validateChildless(superClass);
validateName(superClass);
validateClassMembers(n.getLastChild());
private void validateClassMembers(Node n) {
validateNodeType(Token.CLASS_MEMBERS, n);
for (Node c : n.children()) {
validateClassMember(c);
private void validateClassMember(Node n) {
validateNodeType(Token.MEMBER_DEF, n);
validateChildCount(n, Token.arity(Token.MEMBER_DEF));
validateFunctionExpression(n.getFirstChild());
private void validateEmptyString(Node n) {
validateNonNullString(n);
if (!n.getString().isEmpty()) {
violation("Expected empty string.", n);
private void validateEmptyName(Node n) {
validateNodeType(Token.NAME, n);
validateEmptyString(n);
validateChildCount(n, Token.arity(Token.NAME));
if (n.isArrowFunction()) {
validateEs6Feature("arrow functions", n);
validateEmptyName(n.getFirstChild());
if (n.getLastChild().getType() == Token.BLOCK) {
validateBlock(n.getLastChild());
validateExpression(n.getLastChild());
validateOptionalName(n.getFirstChild());
validateBlock(n.getLastChild());
if (isEs6OrHigher()) {
validateParametersEs6(n);
validateParametersEs5(n);
private void validateParametersEs5(Node n) {
validateNodeType(Token.PARAM_LIST, n);
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
validateName(c);
private void validateParametersEs6(Node n) {
if (isEs6OrHigher()) {
validateMinimumChildCount(n, 0);
validateMaximumChildCount(n, 1);
validateChildCount(n, 1);
if (n.hasOneChild()) {
validateExpression(n.getFirstChild());
private void validateEs6Feature(String feature, Node n) {
if (!isEs6OrHigher()) {
violation("Feature '" + feature + "' is only allowed in ES6 mode.", n);
private boolean isEs6OrHigher() {
return compiler.getLanguageMode().isEs6OrHigher();
if (n.isArrowFunction()) {
return true;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.JSDocInfo.Visibility;
import com.google.javascript.rhino.JSDocInfoBuilder;
import com.google.javascript.rhino.JSTypeExpression;
import java.util.ArrayList;
import java.util.Set;
final JSDocInfo classInfo;
JSDocInfo classInfo,
this.classInfo = classInfo;
JSDocInfo classInfo = NodeUtil.getBestJSDocInfo(targetName);
if (NodeUtil.isNullOrUndefined(superClass)
|| superClass.matchesQualifiedName("Object")) {
classInfo,
Node var = IR.var(cls.name.cloneTree(), cls.constructor.value)
.srcref(exprRoot);
JSDocInfo mergedClassInfo = mergeJsDocFor(cls, var);
var.setJSDocInfo(mergedClassInfo);
block.addChildToBack(var);
Node assign = IR.assign(cls.name.cloneTree(), cls.constructor.value)
.srcref(exprRoot)
.setJSDocInfo(cls.constructor.info);
JSDocInfo mergedClassInfo = mergeJsDocFor(cls, assign);
assign.setJSDocInfo(mergedClassInfo);
Node expr = IR.exprResult(assign).srcref(exprRoot);
block.addChildToBack(expr);
static final String VIRTUAL_FILE = "<ClosureRewriteClass.java>";
private static JSDocInfo mergeJsDocFor(
ClassDefinition cls, Node associatedNode) {
JSDocInfo classInfo = (cls.classInfo != null)
? cls.classInfo
: new JSDocInfo(true);
JSDocInfo ctorInfo = (cls.constructor.info != null)
? cls.constructor.info
: new JSDocInfo(true);
Node superNode = cls.superClass;
JSDocInfoBuilder mergedInfo = cls.constructor.info != null
? JSDocInfoBuilder.copyFrom(ctorInfo)
: new JSDocInfoBuilder(true);
String blockDescription = Joiner.on("\n").skipNulls().join(
classInfo.getBlockDescription(),
ctorInfo.getBlockDescription());
if (!blockDescription.isEmpty()) {
mergedInfo.recordBlockDescription(blockDescription);
Set<String> suppressions = Sets.newHashSet();
suppressions.addAll(classInfo.getSuppressions());
suppressions.addAll(ctorInfo.getSuppressions());
if (!suppressions.isEmpty()) {
mergedInfo.recordSuppressions(suppressions);
if (classInfo.isDeprecated()) {
mergedInfo.recordDeprecated();
String deprecationReason = null;
if (classInfo.getDeprecationReason() != null) {
deprecationReason = classInfo.getDeprecationReason();
mergedInfo.recordDeprecationReason(deprecationReason);
Visibility visibility = classInfo.getVisibility();
if (visibility != null && visibility != JSDocInfo.Visibility.INHERITED) {
mergedInfo.recordVisibility(classInfo.getVisibility());
if (classInfo.isConstant()) {
mergedInfo.recordConstancy();
if (classInfo.isExport()) {
mergedInfo.recordExport();
boolean isInterface = classInfo.isInterface() || ctorInfo.isInterface();
if (isInterface) {
mergedInfo.recordInterface();
List<JSTypeExpression> extendedInterfaces = null;
if (classInfo.getExtendedInterfacesCount() > 0) {
extendedInterfaces = classInfo.getExtendedInterfaces();
&& superNode != null) {
extendedInterfaces = ImmutableList.of(new JSTypeExpression(
new Node(Token.BANG,
IR.string(superNode.getQualifiedName())),
VIRTUAL_FILE));
if (extendedInterfaces != null) {
for (JSTypeExpression extend : extendedInterfaces) {
mergedInfo.recordExtendedInterface(extend);
mergedInfo.recordConstructor();
if (classInfo.makesUnrestricted() || ctorInfo.makesUnrestricted()) {
mergedInfo.recordUnrestricted();
mergedInfo.recordDict();
mergedInfo.recordStruct();
if (superNode != null) {
JSTypeExpression baseType = new JSTypeExpression(
new Node(Token.BANG,
IR.string(superNode.getQualifiedName())),
VIRTUAL_FILE);
mergedInfo.recordBaseType(baseType);
List<JSTypeExpression> interfaces = classInfo.getImplementedInterfaces();
for (JSTypeExpression implemented : interfaces) {
mergedInfo.recordImplementedInterface(implemented);
List<String> templateNames = new ArrayList<>();
templateNames.addAll(classInfo.getTemplateTypeNames());
templateNames.addAll(ctorInfo.getTemplateTypeNames());
if (templateNames.size() > 0) {
mergedInfo.recordTemplateTypeNames(templateNames);
return mergedInfo.build(associatedNode);
usage = "Source map location mapping separated by a '|' " +
"(i.e. filesystem-path|webserver-path)")
private List<String> sourceMapLocationMapping = Lists.newArrayList();
List<SourceMap.LocationMapping> getSourceMapLocationMappings() {
List<SourceMap.LocationMapping> locationMappings =
Lists.newArrayListWithCapacity(sourceMapLocationMapping.size());
for (String locationMapping : sourceMapLocationMapping) {
String[] pair = locationMapping.split("\\|", 2);
locationMappings.add(new SourceMap.LocationMapping(pair[0], pair[1]));
return locationMappings;
if (flags.outputWrapper != null && !flags.outputWrapper.isEmpty() &&
!flags.outputWrapper.contains(CommandLineRunner.OUTPUT_MARKER)) {
.setSourceMapLocationMappings(flags.getSourceMapLocationMappings())
static final String CONVERT_ES6_PASS_NAME = "convertEs6";
private CompilerOptions.LanguageMode languageMode =
CompilerOptions.LanguageMode.ECMASCRIPT3;
if (options.getLanguageIn().isStrict()) {
languageMode = options.getLanguageIn();
convertEs6ToEs3();
private void convertEs6ToEs3() {
CompilerPass converter = new Es6ToEs3Converter(this, options);
Tracer tracer = newTracer(CONVERT_ES6_PASS_NAME);
beforePass(CONVERT_ES6_PASS_NAME);
converter.process(externsRoot, jsRoot);
stopTracer(tracer, CONVERT_ES6_PASS_NAME);
afterPass(CONVERT_ES6_PASS_NAME);
CompilerOptions.LanguageMode getLanguageMode() {
return languageMode;
void setLanguageMode(CompilerOptions.LanguageMode mode) {
languageMode = mode;
builder.setTagAsStrict(firstOutput && options.getLanguageOut().isStrict());
options.extraAnnotationNames);
languageOut = LanguageMode.ECMASCRIPT3;
public boolean isStrict() {
switch (this) {
case ECMASCRIPT5_STRICT:
case ECMASCRIPT6_STRICT:
return true;
default:
return false;
public boolean isEs6OrHigher() {
switch (this) {
case ECMASCRIPT6:
case ECMASCRIPT6_STRICT:
return true;
default:
return false;
JSDocInfoBuilder builder;
builder = new JSDocInfoBuilder(false);
builder.recordEnumParameterType(oldJSDocInfo.getEnumParameterType());
builder = JSDocInfoBuilder.copyFrom(oldJSDocInfo);
builder.recordSuppressions(ImmutableSet.of("duplicate"));
JSDocInfo jsDocInfo = builder.build(newNode);
if (!c.getString().equals("location")) {
nodes.add(c);
return new AstValidator(compiler);
"missingGetCssName, missingProperties, " +
"missingProvide, missingRequire, missingReturn," +
"undefinedNames, undefinedVars, unknownDefines, uselessCode, " +
"useOfGoogBase, visibility";
TypeValidator.DUP_VAR_DECLARATION_TYPE_MISMATCH,
public static final DiagnosticGroup MISSING_GETCSSNAME =
DiagnosticGroups.registerGroup("missingGetCssName",
CheckMissingGetCssName.MISSING_GETCSSNAME);
package com.google.javascript.jscomp;
import com.google.common.base.Joiner;
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.JSDocInfoBuilder;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
public class Es6ToEs3Converter implements NodeTraversal.Callback, CompilerPass {
private final AbstractCompiler compiler;
private final LanguageMode languageIn;
private final LanguageMode languageOut;
static final DiagnosticType CANNOT_CONVERT = DiagnosticType.error(
"JSC_CANNOT_CONVERT",
"Conversion of ''{0}'' to ES3 is not yet implemented.");
private static final String THIS_VAR = "$jscomp$this";
public Es6ToEs3Converter(AbstractCompiler compiler, CompilerOptions options) {
this.compiler = compiler;
this.languageIn = options.getLanguageIn();
this.languageOut = options.getLanguageOut();
public void process(Node externs, Node root) {
if (languageOut != languageIn &&
languageIn.isEs6OrHigher() && !languageOut.isEs6OrHigher()) {
convert(root);
compiler.setLanguageMode(languageOut);
private void convert(Node root) {
NodeTraversal.traverse(compiler, root, this);
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.FUNCTION:
if (n.isArrowFunction()) {
visitArrowFunction(t, n);
break;
return true;
public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.STRING_KEY:
visitStringKey(n);
break;
case Token.CLASS:
visitClass(n);
break;
case Token.SUPER:
cannotConvert(n, "super");
break;
private void visitStringKey(Node n) {
if (!n.hasChildren()) {
Node name = IR.name(n.getString());
name.copyInformationFrom(n);
n.addChildToBack(name);
compiler.reportCodeChange();
private void visitClass(Node classNode) {
Node className = classNode.getFirstChild();
Node superClassName = className.getNext();
Node classMembers = classNode.getLastChild();
if (!NodeUtil.isStatement(classNode)) {
cannotConvert(classNode, "class expression");
return;
if (!superClassName.isEmpty()) {
cannotConvert(classNode, "extends");
return;
className.detachFromParent();
Node constructor = null;
JSDocInfo ctorJSDocInfo = null;
Node insertionPoint = classNode;
for (Node member : classMembers.children()) {
if (member.isStaticMember()) {
cannotConvert(member, "static member");
if (member.getString().equals("constructor")) {
ctorJSDocInfo = member.getJSDocInfo();
constructor = member.getFirstChild().detachFromParent();
constructor.replaceChild(constructor.getFirstChild(), className);
String qualName = Joiner.on('.').join(
className.getString(),
"prototype",
member.getString());
Node assign = IR.assign(
NodeUtil.newQualifiedNameNode(
compiler.getCodingConvention(),
qualName,
member.getFirstChild().detachFromParent());
assign.srcref(member);
JSDocInfo info = member.getJSDocInfo();
if (info != null) {
info.setAssociatedNode(assign);
assign.setJSDocInfo(info);
Node newNode = NodeUtil.newExpr(assign);
insertionPoint.getParent().addChildAfter(newNode, insertionPoint);
insertionPoint = newNode;
if (constructor == null) {
constructor = IR.function(
className,
IR.paramList().srcref(classNode),
IR.block().srcref(classNode));
JSDocInfo classJSDoc = classNode.getJSDocInfo();
JSDocInfoBuilder newInfo = (classJSDoc != null) ?
JSDocInfoBuilder.copyFrom(classJSDoc) :
new JSDocInfoBuilder(true);
newInfo.recordConstructor();
if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() &&
!newInfo.isStructRecorded()) {
newInfo.recordStruct();
if (ctorJSDocInfo != null) {
newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
for (String param : ctorJSDocInfo.getParameterNames()) {
newInfo.recordParameter(param, ctorJSDocInfo.getParameterType(param));
constructor.setJSDocInfo(newInfo.build(constructor));
classNode.getParent().replaceChild(classNode, constructor);
compiler.reportCodeChange();
private void visitArrowFunction(NodeTraversal t, Node n) {
n.setIsArrowFunction(false);
Node body = n.getLastChild();
if (!body.isBlock()) {
body.detachFromParent();
Node newBody = IR.block(IR.returnNode(body).srcref(body)).srcref(body);
n.addChildToBack(newBody);
UpdateThisNodes thisUpdater = new UpdateThisNodes();
NodeTraversal.traverse(compiler, body, thisUpdater);
if (thisUpdater.changed) {
addThisVar(t);
compiler.reportCodeChange();
private void addThisVar(NodeTraversal t) {
Scope scope = t.getScope();
if (scope.isDeclared(THIS_VAR, false)) {
return;
Node parent = t.getScopeRoot();
if (parent.isFunction()) {
parent = parent.getLastChild();
if (parent.isSyntheticBlock()) {
parent = parent.getFirstChild();
Node name = IR.name(THIS_VAR).srcref(parent);
Node thisVar = IR.var(name, IR.thisNode().srcref(parent));
thisVar.srcref(parent);
parent.addChildToFront(thisVar);
scope.declare(THIS_VAR, name, null, compiler.getInput(parent.getInputId()));
private static class UpdateThisNodes implements NodeTraversal.Callback {
private boolean changed = false;
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isThis()) {
Node name = IR.name(THIS_VAR).srcref(n);
parent.replaceChild(n, name);
changed = true;
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
return !n.isFunction() || n.isArrowFunction();
private void cannotConvert(Node n, String feature) {
compiler.report(JSError.make(n, CANNOT_CONVERT, feature));
import com.google.javascript.jscomp.NewTypeInference.WarningReporter;
import com.google.javascript.jscomp.newtypes.EnumType;
static final DiagnosticType MALFORMED_ENUM =
DiagnosticType.warning(
"JSC_MALFORMED_ENUM",
"An enum must be initialized to a non-empty object literal.");
static final DiagnosticType DUPLICATE_PROP_IN_ENUM =
DiagnosticType.warning(
"JSC_DUPLICATE_PROP_IN_ENUM",
"Property {0} appears twice in the enum declaration.");
DUPLICATE_PROP_IN_ENUM,
MALFORMED_ENUM,
TypeCheck.ENUM_NOT_CONSTANT,
private WarningReporter warnings;
private final CodingConvention convention;
this.warnings = new WarningReporter(compiler);
this.convention = compiler.getCodingConvention();
globalScope.resolveEnums(typeParser);
s.resolveEnums(typeParser);
String varName = n.getFirstChild().getString();
if (currentScope.isDefinedLocally(varName)) {
warnings.add(JSError.make(
n, VariableReferenceCheck.REDECLARED_VARIABLE, varName));
break;
Node init = n.getFirstChild().getFirstChild();
if (init == null || !init.isObjectLit() ||
init.getFirstChild() == null) {
warnings.add(JSError.make(n, MALFORMED_ENUM));
currentScope.addLocal(varName, JSType.UNKNOWN, false);
break;
JSDocInfo jsdoc = n.getJSDocInfo();
Set<String> propNames = Sets.newHashSet();
for (Node prop : init.children()) {
String pname = NodeUtil.getObjectLitKeyName(prop);
if (propNames.contains(pname)) {
warnings.add(JSError.make(n, DUPLICATE_PROP_IN_ENUM, pname));
if (!convention.isValidEnumKey(pname)) {
warnings.add(
JSError.make(prop, TypeCheck.ENUM_NOT_CONSTANT, pname));
propNames.add(pname);
currentScope.addEnum(varName,
EnumType.make(varName, jsdoc.getEnumParameterType(),
ImmutableSet.copyOf(propNames)));
if (NodeUtil.isTypedefDecl(parent) || NodeUtil.isEnumDecl(parent)) {
private Map<String, EnumType> localEnums = Maps.newHashMap();
(localTypedefs != null && localTypedefs.containsKey(name)) ||
(localEnums != null && localEnums.containsKey(name));
private void addEnum(String name, EnumType e) {
Preconditions.checkArgument(!isDefinedLocally(name));
localEnums.put(name, e);
public EnumType getEnum(String name) {
if (isDefinedLocally(name)) {
return localEnums.get(name);
if (parent != null) {
return parent.getEnum(name);
return null;
if (!td.isResolved()) {
typeParser.resolveTypedef(name, this);
private void resolveEnums(JSTypeCreatorFromJSDoc typeParser) {
for (Map.Entry<String, EnumType> entry : localEnums.entrySet()) {
String name = entry.getKey();
EnumType e = entry.getValue();
if (!e.isResolved()) {
typeParser.resolveEnum(name, this);
locals.put(name, e.getObjLitType());
public static class WarningReporter {
AbstractCompiler compiler;
WarningReporter(AbstractCompiler compiler) { this.compiler = compiler; }
void add(JSError warning) { compiler.report(warning); }
private WarningReporter warnings;
this.warnings = new WarningReporter(compiler);
String varName = nameNode.getString();
String varName = nameNode.getString();
case Token.OBJECTLIT:
return analyzeObjLitFwd(expr, inEnv, requiredType, specializedType);
String varName = expr.getString();
rhsPair.env, lhs.getString(), JSType.TOP_SCALAR);
rhsPair.env, rhs.getString(), JSType.TOP_SCALAR);
private EnvTypePair analyzeObjLitFwd(
Node objLit, TypeEnv inEnv, JSType requiredType, JSType specializedType) {
if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
if (objLit.getFirstChild() == null) {
return new EnvTypePair(inEnv, requiredType);
String pname = NodeUtil.getObjectLitKeyName(objLit.getFirstChild());
JSType enumeratedType =
requiredType.getProp(new QualifiedName(pname)).getEnumeratedType();
if (enumeratedType == null) {
return new EnvTypePair(inEnv, requiredType);
TypeEnv env = inEnv;
for (Node prop : objLit.children()) {
EnvTypePair pair =
analyzeExprFwd(prop.getFirstChild(), env, enumeratedType);
if (!pair.type.isSubtypeOf(enumeratedType)) {
warnings.add(JSError.make(
prop, INVALID_OBJLIT_PROPERTY_TYPE,
enumeratedType.toString(), pair.type.toString()));
env = pair.env;
return new EnvTypePair(env, requiredType);
JSDocInfo jsdoc = objLit.getJSDocInfo();
boolean isStruct = jsdoc != null && jsdoc.makesStructs();
boolean isDict = jsdoc != null && jsdoc.makesDicts();
TypeEnv env = inEnv;
JSType result = pickReqObjType(objLit);
for (Node prop : objLit.children()) {
if (isStruct && prop.isQuotedString()) {
warnings.add(
JSError.make(prop, TypeCheck.ILLEGAL_OBJLIT_KEY, "struct"));
warnings.add(
JSError.make(prop, TypeCheck.ILLEGAL_OBJLIT_KEY, "dict"));
String pname = NodeUtil.getObjectLitKeyName(prop);
if (prop.isGetterDef() || prop.isSetterDef()) {
EnvTypePair pair = analyzeExprFwd(prop.getFirstChild(), env);
FunctionType funType = pair.type.getFunType();
Preconditions.checkNotNull(funType);
String specialPropName;
JSType propType;
if (prop.isGetterDef()) {
specialPropName = GETTER_PREFIX + pname;
propType = funType.getReturnType();
specialPropName = SETTER_PREFIX + pname;
propType = pair.type;
result = result.withProperty(
new QualifiedName(specialPropName), propType);
env = pair.env;
QualifiedName qname = new QualifiedName(pname);
JSType jsdocType = symbolTable.getPropDeclaredType(prop);
JSType reqPtype, specPtype;
if (jsdocType != null) {
reqPtype = specPtype = jsdocType;
reqPtype = specPtype = requiredType.getProp(qname);
if (specializedType.mayHaveProp(qname)) {
specPtype = specializedType.getProp(qname);
reqPtype = specPtype = JSType.UNKNOWN;
EnvTypePair pair =
analyzeExprFwd(prop.getFirstChild(), env, reqPtype, specPtype);
if (jsdocType != null) {
result = result.withDeclaredProperty(qname, jsdocType, false);
if (!pair.type.isSubtypeOf(jsdocType)) {
warnings.add(JSError.make(
prop, INVALID_OBJLIT_PROPERTY_TYPE,
jsdocType.toString(), pair.type.toString()));
pair.type = jsdocType;
result = result.withProperty(qname, pair.type);
env = pair.env;
return new EnvTypePair(env, result);
case Token.OBJECTLIT:
return analyzeObjLitBwd(expr, outEnv, requiredType);
String varName = expr.getString();
String name = vdecl.getString();
private EnvTypePair analyzeObjLitBwd(
Node objLit, TypeEnv outEnv, JSType requiredType) {
if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
if (objLit.getFirstChild() == null) {
return new EnvTypePair(outEnv, requiredType);
String pname = NodeUtil.getObjectLitKeyName(objLit.getFirstChild());
JSType enumeratedType =
requiredType.getProp(new QualifiedName(pname)).getEnumeratedType();
if (enumeratedType == null) {
return new EnvTypePair(outEnv, requiredType);
TypeEnv env = outEnv;
for (Node prop = objLit.getLastChild();
prop != null;
prop = objLit.getChildBefore(prop)) {
env = analyzeExprBwd(prop.getFirstChild(), env, enumeratedType).env;
return new EnvTypePair(env, requiredType);
TypeEnv env = outEnv;
JSType result = pickReqObjType(objLit);
for (Node prop = objLit.getLastChild();
prop != null;
prop = objLit.getChildBefore(prop)) {
QualifiedName pname =
new QualifiedName(NodeUtil.getObjectLitKeyName(prop));
if (prop.isGetterDef() || prop.isSetterDef()) {
env = analyzeExprBwd(prop.getFirstChild(), env).env;
JSType jsdocType = symbolTable.getPropDeclaredType(prop);
JSType reqPtype;
if (jsdocType != null) {
reqPtype = jsdocType;
reqPtype = requiredType.getProp(pname);
reqPtype = JSType.UNKNOWN;
EnvTypePair pair = analyzeExprBwd(prop.getFirstChild(), env, reqPtype);
result = result.withProperty(pname, pair.type);
env = pair.env;
return new EnvTypePair(env, result);
Map<Scope, JSType> summaries, WarningReporter warnings) {
callerScope.isKnownFunction(argNode.getString())) {
argType = summaries.get(callerScope.getScope(argNode.getString()));
static boolean isEnumDecl(Node n) {
if (!n.isVar()) {
return false;
JSDocInfo jsdoc = n.getJSDocInfo();
return jsdoc != null && jsdoc.hasEnumParameterType();
Preconditions.checkState(!isEquivalentToExcludingFunctions(main, clone));
Preconditions.checkState(isEquivalentToExcludingFunctions(main, clone));
Preconditions.checkState(
!isEquivalentToExcludingFunctions(n, clone));
Preconditions.checkState(
isEquivalentToExcludingFunctions(n, clone));
private static boolean isEquivalentToExcludingFunctions(
Node thisNode, Node thatNode) {
if (thisNode == null || thatNode == null) {
return thisNode == null && thatNode == null;
if (!thisNode.isEquivalentToShallow(thatNode)) {
return false;
if (thisNode.getChildCount() != thatNode.getChildCount()) {
return false;
Node thisChild = thisNode.getFirstChild();
Node thatChild = thatNode.getFirstChild();
while (thisChild != null && thatChild != null) {
if (thisChild.isFunction()) {
return thatChild.isFunction();
if (!isEquivalentToExcludingFunctions(thisChild, thatChild)) {
return false;
thisChild = thisChild.getNext();
thatChild = thatChild.getNext();
return true;
import com.google.javascript.rhino.Token;
private class SuffixVarsCallback extends AbstractPostOrderCallback {
if (ES6ModuleLoader.isRelativeIdentifier(name)) {
int lastSlash = name.lastIndexOf("/");
int endIndex = name.indexOf('.', lastSlash);
String localTypeName = null;
if (endIndex == -1) {
endIndex = name.length();
localTypeName = name.substring(endIndex);
String moduleName = name.substring(0, endIndex);
String loadAddress = loader.locate(moduleName, t.getInput());
if (loadAddress == null) {
t.makeError(typeNode, LOAD_ERROR, moduleName);
return;
String globalModuleName = toModuleName(loadAddress);
typeNode.setString(
localTypeName == null ?
globalModuleName :
globalModuleName + localTypeName);
int endIndex = name.indexOf('.');
if (endIndex == -1) {
endIndex = name.length();
String baseName = name.substring(0, endIndex);
Scope.Var var = t.getScope().getVar(baseName);
if (var != null && var.isGlobal()) {
typeNode.setString(baseName + "$$" + suffix + name.substring(endIndex));
typeNode.putProp(Node.ORIGINALNAME_PROP, name);
static final DiagnosticType ES6_FEATURE =
DiagnosticType.error("ES6_FEATURE",
"{0}. Use --language_in=ECMASCRIPT6 or ECMASCRIPT6_STRICT " +
"to enable ES6 features.");
.put(Pattern.compile("^this language feature is only supported in es6 mode.*"),
ES6_FEATURE)
private final AstValidator astValidator;
this.astValidator = new AstValidator(compiler);
generator.appendTo(out, fixupSourceLocation(name));
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.JSTypeExpression;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import com.google.javascript.rhino.jstype.JSType;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public final class TemplateAstMatcher {
private static final int TEMPLATE_TYPE_PARAM = Token.PLACEHOLDER1;
private static final int TEMPLATE_LOCAL_NAME = Token.PLACEHOLDER2;
private final AbstractCompiler compiler;
private final Node templateStart;
private final List<String> templateParams = new ArrayList<>();
private final ArrayList<Node> paramNodeMatches = new ArrayList<>();
private final List<String> templateLocals = new ArrayList<>();
private final ArrayList<String> localVarMatches = new ArrayList<>();
private boolean isLooseMatch = false;
public TemplateAstMatcher(
AbstractCompiler compiler, Node templateFunctionNode) {
Preconditions.checkNotNull(compiler);
Preconditions.checkState(
templateFunctionNode.isFunction(),
"Template node must be a function node. Received: %s",
templateFunctionNode);
this.compiler = compiler;
this.templateStart = initTemplate(templateFunctionNode);
public boolean matches(Node n) {
if (matchesTemplateShape(templateStart, n)) {
if (paramNodeMatches.isEmpty() && localVarMatches.isEmpty()) {
return true;
reset();
return matchesTemplate(templateStart, n);
return false;
public boolean isLooseMatch() {
return isLooseMatch;
public Map<String, Node> getTemplateNodeToMatchMap() {
Map<String, Node> map = new HashMap<>();
for (int i = 0; i < templateParams.size(); i++) {
String name = templateParams.get(i);
map.put(name, paramNodeMatches.get(i));
for (int i = 0; i < templateLocals.size(); i++) {
String name = templateLocals.get(i);
map.put(name, IR.name(localVarMatches.get(i)));
return map;
private Node initTemplate(Node templateFunctionNode) {
Node prepped = templateFunctionNode.cloneTree();
prepTemplatePlaceholders(prepped);
Node body = prepped.getLastChild();
Node startNode;
if (body.hasOneChild() && body.getFirstChild().isExprResult()) {
startNode = body.getFirstChild().getFirstChild();
startNode = body.getFirstChild();
for (int i = 0; i < templateLocals.size(); i++) {
this.localVarMatches.add(null);
for (int i = 0; i < templateParams.size(); i++) {
this.paramNodeMatches.add(null);
return startNode;
private void prepTemplatePlaceholders(Node fn) {
final List<String> locals = templateLocals;
final List<String> params = templateParams;
final Map<String, JSType> paramTypes = new HashMap<>();
fn.getFirstChild().setString("");
Node templateParametersNode = fn.getFirstChild().getNext();
JSDocInfo info = NodeUtil.getBestJSDocInfo(fn);
for (Node paramNode : templateParametersNode.children()) {
String name = paramNode.getString();
JSTypeExpression expression = info.getParameterType(name);
JSType type = expression.evaluate(null, compiler.getTypeRegistry());
Preconditions.checkNotNull(type);
params.add(name);
paramTypes.put(name, type);
traverse(fn, new Visitor() {
public void visit(Node n) {
if (n.isName()) {
Node parent = n.getParent();
String name = n.getString();
if (!name.isEmpty() && parent.isVar() && !locals.contains(name)) {
locals.add(n.getString());
if (params.contains(name)) {
JSType type = paramTypes.get(name);
replaceNodeInPlace(n,
createTemplateParameterNode(params.indexOf(name), type));
replaceNodeInPlace(n,
createTemplateLocalNameNode(locals.indexOf(name)));
void replaceNodeInPlace(Node n, Node replacement) {
Node parent = n.getParent();
if (n.hasChildren()) {
Node children = n.removeChildren();
replacement.addChildrenToFront(children);
parent.replaceChild(n, replacement);
private static interface Visitor {
void visit(Node n);
private void traverse(Node n, Visitor callback) {
Node next = null;
for (Node c = n.getFirstChild(); c != null; c = next) {
next = c.getNext(); // in case the child is remove, grab the next node now
traverse(c, callback);
callback.visit(n);
private void reset() {
isLooseMatch = false;
for (int i = 0; i < localVarMatches.size(); i++) {
localVarMatches.set(i, null);
for (int i = 0; i < paramNodeMatches.size(); i++) {
this.paramNodeMatches.set(i, null);
private boolean isTemplateParameterNode(Node n) {
return (n.getType() == TEMPLATE_TYPE_PARAM);
private Node createTemplateParameterNode(int index, JSType type) {
Preconditions.checkState(index >= 0);
Preconditions.checkNotNull(type);
Node n = Node.newNumber(index);
n.setType(TEMPLATE_TYPE_PARAM);
n.setJSType(type);
return n;
private boolean isTemplateLocalNameNode(Node n) {
return (n.getType() == TEMPLATE_LOCAL_NAME);
private Node createTemplateLocalNameNode(int index) {
Preconditions.checkState(index >= 0);
Node n = Node.newNumber(index);
n.setType(TEMPLATE_LOCAL_NAME);
return n;
private boolean matchesTemplateShape(Node template, Node ast) {
while (template != null) {
if (ast == null || !matchesNodeShape(template, ast)) {
return false;
template = template.getNext();
ast = ast.getNext();
return true;
private boolean matchesNodeShape(Node template, Node ast) {
if (isTemplateParameterNode(template)) {
return !NodeUtil.isStatement(ast);
if (!ast.isName()) {
return false;
return false;
Node templateChild = template.getFirstChild();
Node astChild = ast.getFirstChild();
while (templateChild != null) {
if (!matchesNodeShape(templateChild, astChild)) {
return false;
templateChild = templateChild.getNext();
astChild = astChild.getNext();
return true;
private boolean matchesTemplate(Node template, Node ast) {
while (template != null) {
if (ast == null || !matchesNode(template, ast)) {
return false;
template = template.getNext();
ast = ast.getNext();
return true;
private boolean matchesNode(Node template, Node ast) {
if (isTemplateParameterNode(template)) {
int paramIndex = (int) (template.getDouble());
Node previousMatch = paramNodeMatches.get(paramIndex);
if (previousMatch != null) {
return ast.isEquivalentTo(previousMatch);
JSType templateType = template.getJSType();
Preconditions.checkNotNull(templateType, "null template parameter type.");
if (templateType.isNoResolvedType()) {
return false;
boolean isMatch = false;
JSType astType = ast.getJSType();
if (astType == null || astType.isUnknownType() || astType.isAllType()) {
isMatch = true;
isLooseMatch = true;
isMatch = astType.isSubtype(templateType);
if (isMatch && previousMatch == null) {
paramNodeMatches.set(paramIndex, ast);
return isMatch;
int paramIndex = (int) (template.getDouble());
boolean previouslyMatched = this.localVarMatches.get(paramIndex) != null;
if (previouslyMatched) {
return ast.getString().equals(this.localVarMatches.get(paramIndex));
this.localVarMatches.set(paramIndex, ast.getString());
Node templateChild = template.getFirstChild();
Node astChild = ast.getFirstChild();
while (templateChild != null) {
if (!matchesNode(templateChild, astChild)) {
return false;
templateChild = templateChild.getNext();
astChild = astChild.getNext();
return true;
"variable {0} redefined, original definition at {1}:{2}");
static final DiagnosticType DUP_VAR_DECLARATION_TYPE_MISMATCH =
DiagnosticType.warning("JSC_DUP_VAR_DECLARATION_TYPE_MISMATCH",
DUP_VAR_DECLARATION_TYPE_MISMATCH,
if (newType.isEquivalentTo(varType)) {
report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,
variableName, var.getInputName(),
String.valueOf(var.nameNode.getLineno())));
report(JSError.make(sourceName, n, DUP_VAR_DECLARATION_TYPE_MISMATCH,
variableName, newType.toString(), var.getInputName(),
String.valueOf(var.nameNode.getLineno()),
varType.toString()));
if ((aliasedType.isConstructor() || aliasedType.isInterface())
&& !isGoogAbstractMethod(rValue)) {
private boolean isGoogAbstractMethod(Node n) {
return n.matchesQualifiedName("goog.abstractMethod");
return lookupQualifiedName(rValue);
private JSType lookupQualifiedName(Node n) {
String name = n.getQualifiedName();
Var slot = scope.getVar(name);
if (slot != null && !slot.isTypeInferred()) {
JSType type = slot.getType();
if (type != null && !type.isUnknownType()) {
return type;
JSType type = lookupQualifiedName(n.getFirstChild());
if (type != null && type.isRecordType()) {
JSType propType = type.findPropertyType(
n.getLastChild().getString());
return propType;
return null;
public EnumType getEnum(String name);
package com.google.javascript.jscomp.newtypes;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.javascript.rhino.JSTypeExpression;
import java.util.Collection;
public class EnumType {
private enum State {
NOT_RESOLVED,
DURING_RESOLUTION,
RESOLVED
private State state;
private JSTypeExpression typeExpr;
private String name;
private JSType declaredType;
private JSType enumPropType;
private JSType enumObjType;
private ImmutableSet<String> props;
private EnumType(
String name, JSTypeExpression typeExpr, Collection<String> props) {
Preconditions.checkNotNull(typeExpr);
this.state = State.NOT_RESOLVED;
this.name = name;
this.typeExpr = typeExpr;
this.props = ImmutableSet.copyOf(props);
public static EnumType make(
String name, JSTypeExpression typeExpr, Collection<String> props) {
return new EnumType(name, typeExpr, props);
public boolean isResolved() {
return state == State.RESOLVED;
public JSType getEnumeratedType() {
Preconditions.checkState(state == State.RESOLVED);
return declaredType;
public JSType getPropType() {
Preconditions.checkState(state == State.RESOLVED);
return enumPropType;
public JSType getObjLitType() {
Preconditions.checkState(state == State.RESOLVED);
return enumObjType;
public JSTypeExpression getTypeExpr() {
Preconditions.checkState(state != State.RESOLVED);
if (state == State.DURING_RESOLUTION) {
return null;
state = State.DURING_RESOLUTION;
return typeExpr;
public JSTypeExpression getTypeExprForErrorReporting() {
Preconditions.checkState(state == State.DURING_RESOLUTION);
return typeExpr;
void resolveEnum(JSType t) {
Preconditions.checkNotNull(t);
if (state == State.RESOLVED) {
return;
Preconditions.checkState(state == State.DURING_RESOLUTION,
"Expected state DURING_RESOLUTION but found %s", state.toString());
state = State.RESOLVED;
typeExpr = null;
declaredType = t;
enumPropType = JSType.fromEnum(this);
enumObjType = computeObjType();
private JSType computeObjType() {
Preconditions.checkState(enumPropType != null);
PersistentMap<String, Property> propMap = PersistentMap.create();
for (String s : props) {
propMap = propMap.with(s,
Property.makeConstant(enumPropType, enumPropType));
return JSType.fromObjectType(
ObjectType.makeObjectType(
null, propMap, null, false, ObjectKind.UNRESTRICTED));
static ImmutableSet<EnumType> union(
ImmutableSet<EnumType> s1, ImmutableSet<EnumType> s2) {
if (s1 == null) {
return s2;
if (s2 == null || s1.equals(s2)) {
return s1;
return Sets.union(s1, s2).immutableCopy();
static ImmutableSet<EnumType> normalizeForJoin(
ImmutableSet<EnumType> newEnums, JSType joinWithoutEnums) {
boolean recreateEnums = false;
for (EnumType e : newEnums) {
if (e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
recreateEnums = true;
break;
if (!recreateEnums) {
return newEnums;
ImmutableSet.Builder<EnumType> builder = ImmutableSet.builder();
for (EnumType e : newEnums) {
if (!e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
builder.add(e);
return builder.build();
static boolean areSubtypes(JSType t1, JSType t2) {
ImmutableSet<EnumType> s1 = t1.getEnums();
if (s1 == null) {
return true;
ImmutableSet<EnumType> s2 = t2.getEnums();
for (EnumType e : s1) {
if (s2 != null && s2.contains(e)) {
continue;
if (!e.getEnumeratedType().isSubtypeOf(t2)) {
return false;
return true;
public String toString() {
return name;
private static final int TYPEVAR_MASK = 0x1;
private static final int NON_SCALAR_MASK = 0x2;
private static final int ENUM_MASK = 0x4;
private static final int TRUE_MASK = 0x8;  // These two print out
private static final int FALSE_MASK = 0x10; // as 'boolean'
private static final int NUMBER_MASK = 0x40;
private static final int STRING_MASK = 0x80;
private static final int UNDEFINED_MASK = 0x100;
private static final int END_MASK = UNDEFINED_MASK * 2;
private static final int TRUTHY_MASK = 0x200;
private static final int FALSY_MASK = 0x400;
private final ImmutableSet<EnumType> enums;
String typeVar, ImmutableSet<EnumType> enums) {
if (enums == null) {
this.enums = null;
mask &= ~ENUM_MASK;
this.enums = null;
mask |= ENUM_MASK;
this.enums = enums;
mask &= ~NON_SCALAR_MASK;
mask |= NON_SCALAR_MASK;
if (typeVar != null) {
mask |= TYPEVAR_MASK;
this.typeVar = typeVar;
this.location = location;
this.mask = mask;
Preconditions.checkState(isValidType(),
"objs <<<%s>>>, typeVar <<<%s>>>, enums <<<%s>>>",
mask, objs, typeVar, enums);
this(mask, null, null, null, null);
ImmutableSet.of(ObjectType.fromFunction(fn)), null, null);
return new JSType(NON_SCALAR_MASK, null, ImmutableSet.of(obj), null, null);
return new JSType(TYPEVAR_MASK, null, null, template, null);
static JSType fromEnum(EnumType e) {
return new JSType(ENUM_MASK, null, null, null, ImmutableSet.of(e));
if ((mask & ENUM_MASK) != 0 && (enums == null || enums.isEmpty())) {
return false;
if ((mask & ENUM_MASK) == 0 && enums != null) {
return false;
null, ImmutableSet.of(ObjectType.TOP_OBJECT), null, null);
null, ImmutableSet.of(ObjectType.TOP_OBJECT), null, null);
isBoolean();
return (mask & TYPEVAR_MASK) != 0 && (mask & ~TYPEVAR_MASK) == 0;
public boolean isEnumElement() {
return mask == ENUM_MASK && enums.size() == 1;
public boolean isUnion() {
if (isBottom() || isTop() || isUnknown() ||
isScalar() || isTypeVariable() || isEnumElement()) {
return false;
if (mask == NON_SCALAR_MASK && objs.size() == 1) {
return false;
return true;
ImmutableSet<EnumType> getEnums() {
return enums;
public JSType getEnumeratedType() {
return isEnumElement() ?
Iterables.getOnlyElement(enums).getEnumeratedType() : null;
int newMask = lhs.mask | rhs.mask;
String newLoc = joinLocs(lhs.location, rhs.location);
ImmutableSet<ObjectType> newObjs = ObjectType.joinSets(lhs.objs, rhs.objs);
String newTypevar = lhs.typeVar != null ? lhs.typeVar : rhs.typeVar;
ImmutableSet<EnumType> newEnums = EnumType.union(lhs.enums, rhs.enums);
if (newEnums == null) {
return new JSType(newMask, newLoc, newObjs, newTypevar, null);
JSType tmpJoin = new JSType(
newMask & ~ENUM_MASK, newLoc, newObjs, newTypevar, null);
return new JSType(newMask, newLoc, newObjs, newTypevar,
EnumType.normalizeForJoin(newEnums, tmpJoin));
JSType current =
new JSType(mask & ~TYPEVAR_MASK, location, newObjs, null, enums);
ImmutableSet<EnumType> newEnums = null;
if (t1.enums == null) {
if (t2.enums != null) {
return null;
newEnums = null;
return null;
return null;
newEnums = t1.enums;
t1Mask, null, ImmutableSet.copyOf(unifiedObjs), t1.typeVar, newEnums);
updateTypemap(typeMultimap, typeVar,
new JSType(promoteBoolean(other.mask), null, other.objs,
other.typeVar, other.enums));
Set<EnumType> ununifiedEnums = null;
if (this.enums == null) {
ununifiedEnums = other.enums;
return false;
ununifiedEnums = Sets.newHashSet();
for (EnumType e : this.enums) {
if (!other.enums.contains(e)) {
return false;
for (EnumType e : other.enums) {
if (!this.enums.contains(e)) {
ununifiedEnums.add(e);
if (ununifiedEnums.isEmpty()) {
ununifiedEnums = null;
ImmutableSet.copyOf(ununified), otherTypevar,
ununifiedEnums == null ? null : ImmutableSet.copyOf(ununifiedEnums));
newMask &= ~TYPEVAR_MASK;
return meetEnums(
newMask, this.mask | other.mask, this.location,
ObjectType.specializeSet(this.objs, other.objs),
newTypevar, this.objs, other.objs, enums, other.enums);
return meetEnums(
newMask, lhs.mask | rhs.mask, null,
ObjectType.meetSets(lhs.objs, rhs.objs),
newTypevar, lhs.objs, rhs.objs, lhs.enums, rhs.enums);
private static JSType meetEnums(int newMask, int unionMask,
String newLocation, ImmutableSet<ObjectType> newObjs, String newTypevar,
ImmutableSet<ObjectType> objs1, ImmutableSet<ObjectType> objs2,
ImmutableSet<EnumType> enums1, ImmutableSet<EnumType> enums2) {
if (Objects.equal(enums1, enums2)) {
return new JSType(newMask, newLocation, newObjs, newTypevar, enums1);
ImmutableSet.Builder<EnumType> enumBuilder = ImmutableSet.builder();
ImmutableSet<EnumType> allEnums = EnumType.union(enums1, enums2);
for (EnumType e : allEnums) {
if (enums1 != null && enums1.contains(e) &&
enums2 != null && enums2.contains(e)) {
enumBuilder.add(e);
continue;
JSType enumeratedType = e.getEnumeratedType();
if (enumeratedType.isUnknown()) {
enumBuilder.add(e);
continue;
if (enumeratedType.mask != NON_SCALAR_MASK) {
if ((enumeratedType.mask & unionMask) != 0) {
enumBuilder.add(e);
newMask &= ~enumeratedType.mask;
Set<ObjectType> objsToRemove = Sets.newHashSet();
ObjectType enumObj = Iterables.getOnlyElement(enumeratedType.objs);
if (objs1 != null) {
for (ObjectType obj1 : objs1) {
if (enumObj.isSubtypeOf(obj1)) {
enumBuilder.add(e);
objsToRemove.add(obj1);
if (objs2 != null) {
for (ObjectType obj2 : objs2) {
if (enumObj.isSubtypeOf(obj2)) {
enumBuilder.add(e);
objsToRemove.add(obj2);
if (!objsToRemove.isEmpty() && newObjs != null) {
newObjs = Sets.difference(newObjs, objsToRemove).immutableCopy();
newMask, newLocation, newObjs, newTypevar, enumBuilder.build());
private JSType makeTruthy() {
if (this.isTop() || this.isUnknown()) {
return this;
return new JSType(mask & ~NULL_MASK & ~FALSE_MASK & ~UNDEFINED_MASK,
location, objs, typeVar, enums);
private JSType makeFalsy() {
if (this.isTop() || this.isUnknown()) {
return this;
return new JSType(
mask & ~TRUE_MASK & ~NON_SCALAR_MASK, location, null, typeVar, enums);
return UNKNOWN.removeType(this);
if (!EnumType.areSubtypes(this, other)) {
return false;
int mask = this.mask & ~ENUM_MASK;
if ((mask | other.mask) != other.mask) {
if (!Objects.equal(this.typeVar, other.typeVar)) {
if (this.objs == null) {
return new JSType(mask & ~other.mask, location, objs, typeVar, enums);
return new JSType(mask, location, newObjs.build(), typeVar, enums);
typeVar, enums);
ObjectType.withLooseObjects(this.objs), typeVar, enums);
ObjectType.withoutProperty(this.objs, qname), typeVar, enums);
ObjectType.withProperty(this.objs, qname, type), typeVar, enums);
typeVar, enums);
ObjectType.withPropertyRequired(this.objs, pname), typeVar, enums);
if (location == null) {
return typeToString();
return typeToString() + "@" + location;
private static final Joiner PIPE_JOINER = Joiner.on("|");
return "bottom";
return "*";
return "?";
StringBuilder sb = new StringBuilder();
boolean firstIteration = true;
for (int tag = 1; tag != END_MASK; tag <<= 1) {
if ((tags & tag) != 0) {
if (!firstIteration) {
sb.append('|');
firstIteration = false;
switch (tag) {
case TRUE_MASK:
case FALSE_MASK:
sb.append("boolean");
tags &= ~BOOLEAN_MASK;
continue;
case NULL_MASK:
sb.append("null");
tags &= ~NULL_MASK;
continue;
case NUMBER_MASK:
sb.append("number");
tags &= ~NUMBER_MASK;
continue;
case STRING_MASK:
sb.append("string");
tags &= ~STRING_MASK;
continue;
case UNDEFINED_MASK:
sb.append("undefined");
tags &= ~UNDEFINED_MASK;
continue;
case TYPEVAR_MASK:
sb.append(typeVar);
tags &= ~TYPEVAR_MASK;
continue;
case NON_SCALAR_MASK: {
if (objs.size() == 1) {
sb.append(Iterables.getOnlyElement(objs).toString());
Set<String> strReps = Sets.newTreeSet();
for (ObjectType obj : objs) {
strReps.add(obj.toString());
PIPE_JOINER.appendTo(sb, strReps);
tags &= ~NON_SCALAR_MASK;
continue;
case ENUM_MASK: {
if (enums.size() == 1) {
sb.append(Iterables.getOnlyElement(enums).toString());
Set<String> strReps = Sets.newTreeSet();
for (EnumType e : enums) {
strReps.add(e.toString());
PIPE_JOINER.appendTo(sb, strReps);
tags &= ~ENUM_MASK;
continue;
return sb.toString();
private int howmanyTypeVars = 0;
return getNodeTypeDeclaration(jsdoc, ownerType, registry, null);
private JSType getNodeTypeDeclaration(JSDocInfo jsdoc,
RawNominalType ownerType, DeclaredTypeRegistry registry,
ImmutableList<String> typeParameters) {
jsdoc.getType(), ownerType, registry, typeParameters);
if (registry.getEnum(typeName) != null) {
return getEnumPropType(typeName, registry);
howmanyTypeVars++;
private JSType getTypedefType(String name, DeclaredTypeRegistry registry) {
resolveTypedef(name, registry);
return registry.getTypedef(name).getType();
public void resolveTypedef(String name, DeclaredTypeRegistry registry) {
return;
warn("Circular type definitions are not allowed.",
private JSType getEnumPropType(String name, DeclaredTypeRegistry registry) {
resolveEnum(name, registry);
return registry.getEnum(name).getPropType();
public void resolveEnum(String name, DeclaredTypeRegistry registry) {
EnumType e = registry.getEnum(name);
Preconditions.checkState(e != null, "getEnum should only be " +
"called when we know that the enum is defined");
if (e.isResolved()) {
return;
JSTypeExpression texp = e.getTypeExpr();
JSType enumeratedType;
if (texp == null) {
warn("Circular type definitions are not allowed.",
e.getTypeExprForErrorReporting().getRootNode());
enumeratedType = JSType.UNKNOWN;
int numTypeVars = howmanyTypeVars;
enumeratedType = getTypeFromJSTypeExpression(texp, null, registry, null);
if (howmanyTypeVars > numTypeVars) {
warn("An enum type cannot include type variables.", texp.getRootNode());
enumeratedType = JSType.UNKNOWN;
howmanyTypeVars = numTypeVars;
warn("An enum type cannot be *. " +
"Use ? if you do not want the elements checked.",
texp.getRootNode());
enumeratedType = JSType.UNKNOWN;
warn("An enum type cannot be a union type.", texp.getRootNode());
enumeratedType = JSType.UNKNOWN;
e.resolveEnum(enumeratedType);
JSType inlineParamType = ignoreJsdoc ? null : getNodeTypeDeclaration(
param.getJSDocInfo(), ownerType, registry, typeParameters);
inlineRetJsdoc, ownerType, registry, typeParameters));
RawNominalType otherRawType = other.rawType;
if (rawType.isInterface && !otherRawType.isInterface) {
return false;
if (!rawType.isInterface && otherRawType.isInterface) {
if (rawType.interfaces == null) {
return false;
for (NominalType i : rawType.interfaces) {
if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
return true;
return false;
if (rawType.isInterface && otherRawType.isInterface) {
if (rawType.equals(otherRawType)) {
for (String typeVar : rawType.getTypeParameters()) {
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
return true;
return false;
for (NominalType i : rawType.interfaces) {
if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
return true;
return false;
if (rawType.equals(otherRawType)) {
static ImmutableSet<ObjectType> withLocation(
Set<ObjectType> objs, String location) {
if (props.isEmpty() ||
(props.size() == 1 && props.containsKey("prototype"))) {
if (fn != null) {
return fn.toString();
return nominalType.toString();
StringBuilder result = new StringBuilder();
result.append(nominalType.toString());
result.append("struct");
result.append("dict");
if (nominalType == null || !props.isEmpty()) {
result.append('{');
boolean firstIteration = true;
for (String pname : Sets.newTreeSet(props.keySet())) {
if (!firstIteration) {
result.append(", ");
firstIteration = false;
result.append(pname);
result.append(':');
result.append(props.get(pname).toString());
result.append('}');
if (isLoose) {
result.append(" (loose)");
return result.toString();
return inferredType.toString() + '^';
return inferredType.toString();
return inferredType.toString() + '=';
throw new RuntimeException("Unknown Attribute value " + attribute);
void resolveTypedef(JSType t) {
String typeName = stream.getString();
int lineno = stream.getLineno();
int charno = stream.getCharno();
while (match(JsDocToken.EOL) &&
typeName.charAt(typeName.length() - 1) == '.') {
next();
typeName += stream.getString();
Node typeNameNode = newStringNode(typeName, lineno, charno);
Node memberType = parseTypeExpressionList(next());
if (memberType != null) {
typeNameNode.addChildToFront(memberType);
if (!match(JsDocToken.GT)) {
return reportTypeSyntaxWarning("msg.jsdoc.missing.gt");
next();
return typeNameNode;
EQUALS;
return JsDocToken.COLON;
transformOrEmpty(loopNode.initializer, loopNode),
transformOrEmpty(loopNode.condition, loopNode),
transformOrEmpty(loopNode.increment, loopNode));
Node transformOrEmpty(ParseTree tree, ParseTree parent) {
if (tree == null) {
Node n = newNode(Token.EMPTY);
setSourceInfo(n, parent);
return n;
return transform(tree);
Node transformOrEmpty(IdentifierToken token, ParseTree parent) {
if (token == null) {
Node n = newNode(Token.EMPTY);
setSourceInfo(n, parent);
return n;
return processName(token);
Node name = newStringNode(Token.NAME, tree.identifier.identifierToken.value);
Node processTemplateString(LiteralExpressionTree tree) {
maybeWarnEs6Feature(tree, "template strings");
LiteralToken token = tree.literalToken.asLiteral();
Preconditions.checkState(token.type == TokenType.TEMPLATE_STRING);
if (Pattern.compile("[^\\\\]\\$\\{").matcher(token.value).find()) {
errorReporter.warning(
"Placeholders in template strings are not supported yet.",
sourceName, lineno(tree), "", charno(tree));
Node node = newStringNode(Token.STRING, normalizeString(token));
setSourceInfo(node, token);
return node;
Node name = transformOrEmpty(tree.name, tree);
Node superClass = transformOrEmpty(tree.superClass, tree);
transformOrEmpty(tree.defaultBindingIndentifier, tree),
abstract T processTemplateString(LiteralExpressionTree tree);
case TEMPLATE_STRING:
return processTemplateString(expr);
Set<String> extraAnnotationNames) {
isIdeMode, languageMode, acceptConstKeyword);
return parseEs6(sourceFile, sourceString, config, errorReporter, logger);
case TEMPLATE_STRING:
case TEMPLATE_STRING:
case '#':
if (index == 0 && peekChar(1) == '!') {
skipSingleLineComment(Comment.Type.SHEBANG);
return true;
break;
skipSingleLineComment(Comment.Type.LINE);
private void skipSingleLineComment(Comment.Type type) {
recordComment(type, range, value);
case '`':
return scanTemplateString(beginToken);
private Token scanTemplateString(int beginIndex) {
while (peekTemplateStringChar()) {
if (!skipStringLiteralChar()) {
return new LiteralToken(
TokenType.TEMPLATE_STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
if (peekChar() != '`') {
reportError(getPosition(beginIndex), "Unterminated template string");
nextChar();
return new LiteralToken(
TokenType.TEMPLATE_STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
private boolean peekTemplateStringChar() {
return !isAtEnd() && peekChar() != '`';
case '`':
TEMPLATE_STRING("template string"),
JSDOC,
SHEBANG
import com.google.common.annotations.VisibleForTesting;
import java.util.Objects;
public String toString() {
return com.google.common.base.Objects.toStringHelper(this)
.add("bitfield", propertyBitField)
.toString();
private static final int MASK_FLAGS         = 0x3FFFFFFF;
public JSDocInfo(boolean includeDocumentation) {
public static boolean areEquivalent(JSDocInfo jsDoc1, JSDocInfo jsDoc2) {
if (jsDoc1 == null && jsDoc2 == null) {
return true;
if (jsDoc1 == null || jsDoc2 == null) {
return false;
if (!Objects.equals(jsDoc1.getParameterNames(), jsDoc2.getParameterNames())) {
return false;
for (String param : jsDoc1.getParameterNames()) {
if (!Objects.equals(jsDoc1.getParameterType(param), jsDoc2.getParameterType(param))) {
return false;
return Objects.equals(jsDoc1.getAuthors(), jsDoc2.getAuthors()) &&
Objects.equals(jsDoc1.getBaseType(), jsDoc2.getBaseType()) &&
Objects.equals(jsDoc1.getBlockDescription(), jsDoc2.getBlockDescription()) &&
Objects.equals(jsDoc1.getFileOverview(), jsDoc2.getFileOverview()) &&
Objects.equals(jsDoc1.getImplementedInterfaces(), jsDoc2.getImplementedInterfaces()) &&
Objects.equals(jsDoc1.getEnumParameterType(), jsDoc2.getEnumParameterType()) &&
Objects.equals(jsDoc1.getExtendedInterfaces(), jsDoc2.getExtendedInterfaces()) &&
Objects.equals(jsDoc1.getLendsName(), jsDoc2.getLendsName()) &&
Objects.equals(jsDoc1.getLicense(), jsDoc2.getLicense()) &&
Objects.equals(jsDoc1.getMarkers(), jsDoc2.getMarkers()) &&
Objects.equals(jsDoc1.getMeaning(), jsDoc2.getMeaning()) &&
Objects.equals(jsDoc1.getModifies(), jsDoc2.getModifies()) &&
Objects.equals(jsDoc1.getOriginalCommentString(), jsDoc2.getOriginalCommentString()) &&
Objects.equals(jsDoc1.getReferences(), jsDoc2.getReferences()) &&
Objects.equals(jsDoc1.getReturnDescription(), jsDoc2.getReturnDescription()) &&
Objects.equals(jsDoc1.getReturnType(), jsDoc2.getReturnType()) &&
Objects.equals(jsDoc1.getSuppressions(), jsDoc2.getSuppressions()) &&
Objects.equals(jsDoc1.getTemplateTypeNames(), jsDoc2.getTemplateTypeNames()) &&
Objects.equals(jsDoc1.getThisType(), jsDoc2.getThisType()) &&
Objects.equals(jsDoc1.getThrownTypes(), jsDoc2.getThrownTypes()) &&
Objects.equals(jsDoc1.getTypedefType(), jsDoc2.getTypedefType()) &&
Objects.equals(jsDoc1.getType(), jsDoc2.getType()) &&
Objects.equals(jsDoc1.getVersion(), jsDoc2.getVersion()) &&
Objects.equals(jsDoc1.getVisibility(), jsDoc2.getVisibility()) &&
jsDoc1.bitset == jsDoc2.bitset;
boolean isDocumentationIncluded() {
return includeDocumentation;
public String toStringVerbose() {
return com.google.common.base.Objects.toStringHelper(this)
.add("info", info)
.add("bitset", Integer.toHexString(bitset))
.add("originalComment", getOriginalCommentString())
.toString();
this(new JSDocInfo(parseDocumentation), parseDocumentation, false);
private JSDocInfoBuilder(
JSDocInfo info, boolean parseDocumentation, boolean populated) {
this.currentInfo = info;
this.populated = populated;
public static JSDocInfoBuilder copyFrom(JSDocInfo info) {
populateDefaults(info);
return new JSDocInfoBuilder(info.clone(), info.isDocumentationIncluded(), true);
public boolean isUnrestrictedRecorded() {
return currentInfo.makesUnrestricted();
public boolean isStructRecorded() {
return currentInfo.makesStructs();
public boolean isDictRecorded() {
return currentInfo.makesDicts();
Node node, boolean compareJsType, boolean recur, boolean jsDoc) {
boolean equiv = super.isEquivalentTo(node, compareJsType, recur, jsDoc);
Node node, boolean compareJsType, boolean recur, boolean jsDoc) {
return (super.isEquivalentTo(node, compareJsType, recur, jsDoc)
public String checkTreeEquals(Node actual) {
NodeMismatch diff = checkTreeEqualsImpl(actual);
"\n\nTree2:\n" + actual.toStringTree() +
public String checkTreeEqualsIncludingJsDoc(Node actual) {
NodeMismatch diff = checkTreeEqualsImpl(actual, true);
if (diff != null) {
if (diff.nodeA.isEquivalentTo(diff.nodeB, false, true, false)) {
String jsDoc1 = diff.nodeA.getJSDocInfo() == null ?
"(none)" :
diff.nodeA.getJSDocInfo().toStringVerbose();
String jsDoc2 = diff.nodeB.getJSDocInfo() == null ?
"(none)" :
diff.nodeB.getJSDocInfo().toStringVerbose();
return "Node tree inequality:" +
"\nTree:\n" + toStringTree() +
"\n\nJSDoc differs on subtree: " + diff.nodeA +
"\nExpected JSDoc: " + jsDoc1 +
"\nActual JSDoc  : " + jsDoc2;
return "Node tree inequality:" +
"\nExpected tree:\n" + toStringTree() +
"\n\nActual tree:\n" + actual.toStringTree() +
"\n\nExpected subtree: " + diff.nodeA.toStringTree() +
"\n\nActual subtree: " + diff.nodeB.toStringTree();
return null;
return checkTreeEqualsImpl(node2, false);
private NodeMismatch checkTreeEqualsImpl(Node node2, boolean jsDoc) {
if (!isEquivalentTo(node2, false, false, jsDoc)) {
if (node2 == null) {
throw new IllegalStateException();
res = n.checkTreeEqualsImpl(n2, jsDoc);
return isEquivalentTo(node, false, false, false);
return isEquivalentTo(node, true, true, true);
Node node, boolean compareJsType, boolean recurse, boolean jsDoc) {
if (jsDoc && !JSDocInfo.areEquivalent(getJSDocInfo(), node.getJSDocInfo())) {
return false;
if (this.isArrowFunction() != node.isArrowFunction()) {
return false;
if (recurse) {
if (!n.isEquivalentTo(n2, compareJsType, recurse, jsDoc)) {
PLACEHOLDER1   = 1001,
PLACEHOLDER2   = 1002;
case PLACEHOLDER1:        return "PLACEHOLDER1";
case PLACEHOLDER2:        return "PLACEHOLDER2";
throw new IllegalStateException("No name defined for " + token);
case STRING_KEY:      return -1;
case CLASS:           return 3;
case MEMBER_DEF:      return 1;
throw new IllegalStateException(
"No arity defined for " + Token.name(token));
compareJsDoc = false;
compareJsDoc = false;
return createValidator(compiler);
private AstValidator createValidator(Compiler compiler) {
return new AstValidator(compiler, new ViolationHandler() {
AstValidator validator = createValidator(createCompiler());
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
public void testArrowFunction1() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
testFailure("var a = () => this.foo;");
public void testArrowFunction2() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
testFailure("(() => this.foo)();");
public void testArrowFunction3() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
testFailure("function Foo() {} " +
"Foo.prototype.getFoo = () => this.foo;");
public void testArrowFunction4() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
testFailure("function Foo() {} " +
"Foo.prototype.setFoo = (f) => { this.foo = f; };");
private static final String EXTERNS =
"var goog = {};\n" +
"goog.inherits = function(a,b) {};\n" +
"goog.defineClass = function(a,b) {};\n" +
"var use\n";
public ClosureRewriteClassTest() {
super(EXTERNS);
disableTypeCheck();
runTypeCheckAfterProcessing = true;
compareJsDoc = false;
public void testBasic4() {
test(
"var x = goog.defineClass(Object, {\n" +
"  constructor: function(){}\n" +
"});",
"{var x = function() {};}");
public void testAnnotations1() {
enableTypeCheck(CheckLevel.WARNING);
test(
"var x = goog.defineClass(Object, {\n" +
"  constructor: function(){}\n" +
"});" +
"new x();",
"{" +
"var x = function() {};" +
"}" +
"new x();");
public void testAnnotations2a() {
enableTypeCheck(CheckLevel.WARNING);
test(
"var x = goog.defineClass(null, {\n" +
"  /** @interface */\n" +
"  constructor: function(){}\n" +
"});" +
"new x();",
"{" +
"var x = function() {};" +
"}" +
"new x();",
null,
TypeCheck.NOT_A_CONSTRUCTOR);
public void testAnnotations2b() {
enableTypeCheck(CheckLevel.WARNING);
test(
"/** @interface */\n" +
"var x = goog.defineClass(null, {\n" +
"  constructor: function(){}\n" +
"});" +
"new x();",
"{" +
"var x = function() {};" +
"}" +
"new x();",
null,
TypeCheck.NOT_A_CONSTRUCTOR);
public void testAnnotations3a() {
enableTypeCheck(CheckLevel.WARNING);
test(
"/** @constructor */ var y = function () {};\n" +
"var x = goog.defineClass(y, {\n" +
"  constructor: function(){this.a = 1}\n" +
"});\n" +
"use(new y().a);\n",
"var y = function () {};\n" +
"{\n" +
"var x = function() {this.a = 1};\n" +
"goog.inherits(x,y);\n" +
"}\n" +
"use(new y().a);\n",
null,
TypeCheck.CONFLICTING_SHAPE_TYPE);
public void testAnnotations3b() {
enableTypeCheck(CheckLevel.WARNING);
test(
"/** @constructor */ var y = function () {};\n" +
"/** @unrestricted */" +
"var x = goog.defineClass(y, {\n" +
"  constructor: function(){this.a = 1}\n" +
"});\n" +
"use(new y().a);\n",
"var y = function () {};\n" +
"{\n" +
"var x = function() {this.a = 1};\n" +
"goog.inherits(x,y);\n" +
"}\n" +
"use(new y().a);\n");
private static final String EXTERNS =
compareJsDoc = false;
private static final String COMMON_ENUM =
public void setUp() {
compareJsDoc = false;
public void testCrossModuleSubclass5() {
test(createCompilerOptions(),
new String[] {
"/** @constructor */ function Hello() {} " +
"module.exports = Hello;",
"var Hello = require('./i0');" +
"var util = {inherits: function (x, y){}};" +
"/**\n" +
" * @constructor\n" +
" * @extends {./i0}\n" +
" */\n" +
"function SubHello() { Hello.call(this); }" +
"util.inherits(SubHello, Hello);"
new String[] {
"function Hello$$module$i0(){}" +
"var module$i0=Hello$$module$i0;",
"var module$i1={};" +
"var Hello$$module$i1=module$i0;" +
"var util$$module$i1={inherits:function(x,y){}};" +
"function SubHello$$module$i1(){ Hello$$module$i1.call(this); }" +
"util$$module$i1.inherits(SubHello$$module$i1,Hello$$module$i1);"
public void testCrossModuleSubclass6() {
test(createCompilerOptions(),
new String[] {
"/** @constructor */ function Hello() {} " +
"module.exports = {Hello: Hello};",
"var i0 = require('./i0');" +
"var util = {inherits: function (x, y){}};" +
"/**\n" +
" * @constructor\n" +
" * @extends {./i0.Hello}\n" +
" */\n" +
"function SubHello() { i0.Hello.call(this); }" +
"util.inherits(SubHello, i0.Hello);"
new String[] {
"function Hello$$module$i0(){}" +
"var module$i0={Hello: Hello$$module$i0};",
"var module$i1={};" +
"var i0$$module$i1=module$i0;" +
"var util$$module$i1={inherits:function(x,y){}};" +
"function SubHello$$module$i1(){ i0$$module$i1.Hello.call(this); }" +
"util$$module$i1.inherits(SubHello$$module$i1,i0$$module$i1.Hello);"
import java.io.File;
private String normalize(String path) {
return path.replace("/", File.separator);
normalize("generated_js/example.js"),
sourcemap(
normalize("generated_js/example.srcmap"),
normalize("../original/source.html"),
String origSourceName = normalize("original/source.html");
SourceFile.fromCode(origSourceName, "<div ng-show='foo()'>"));
.setOriginalFile(origSourceName)
compiler.getSourceMapping(normalize("generated_js/example.js"), 3, 3));
compiler.getSourceLine(origSourceName, 1));
protected boolean compareJsDoc;
private LanguageMode acceptedLanguage = LanguageMode.ECMASCRIPT5;
this.compareJsDoc = true;
options.setLanguageIn(acceptedLanguage);
this.acceptedLanguage =
acceptES5 ? LanguageMode.ECMASCRIPT5 : LanguageMode.ECMASCRIPT3;
protected void setAcceptedLanguage(LanguageMode acceptedLanguage) {
this.acceptedLanguage = acceptedLanguage;
options.setLanguageIn(acceptedLanguage);
(new AstValidator(compiler)).validateRoot(root);
(new AstValidator(compiler)).validateRoot(root);
String explanation;
if (compareJsDoc) {
explanation = expectedRoot.checkTreeEqualsIncludingJsDoc(mainRoot);
explanation = expectedRoot.checkTreeEquals(mainRoot);
compareJsDoc = false;
compareJsDoc = false;
package com.google.javascript.jscomp;
import com.google.common.base.Joiner;
import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
public class Es6ToEs3ConverterTest extends CompilerTestCase {
public void setUp() {
setAcceptedLanguage(LanguageMode.ECMASCRIPT6);
protected CompilerOptions getOptions() {
CompilerOptions options = super.getOptions();
options.setLanguageOut(LanguageMode.ECMASCRIPT5);
return options;
public CompilerPass getProcessor(Compiler compiler) {
return new Es6ToEs3Converter(compiler, compiler.getOptions());
protected int getNumRepetitions() {
return 1;
public void testExtendedObjLit() {
test("var x = {a, b};", "var x = {a: a, b: b};");
public void testClassStatement() {
test("class C { }", "/** @constructor @struct */ function C() {}");
test("class C { constructor() {} }", "/** @constructor @struct */ function C() {}");
test("class C { constructor(a) { this.a = a; } }",
"/** @constructor @struct */ function C(a) { this.a = a; }");
test(Joiner.on('\n').join(
"class C {",
"  constructor() {}",
"",
"  foo() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"function C() {}",
"",
"C.prototype.foo = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor() {}",
"",
"  foo() {}",
"",
"  bar() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"function C() {}",
"",
"C.prototype.foo = function() {};",
"",
"C.prototype.bar = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  foo() {}",
"",
"  bar() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"function C() {}",
"",
"C.prototype.foo = function() {};",
"",
"C.prototype.bar = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor(a) { this.a = a; }",
"",
"  foo() { console.log(this.a); }",
"",
"  bar() { alert(this.a); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"function C(a) { this.a = a; }",
"",
"C.prototype.foo = function() { console.log(this.a); };",
"",
"C.prototype.bar = function() { alert(this.a); };"
));
public void testClassWithJsDoc() {
test(
"class C { }",
Joiner.on('\n').join(
"/**",
" * @constructor",
" * @struct",
" */",
"function C() {}")
);
test(
"/** @deprecated */ class C { }",
Joiner.on('\n').join(
"/**",
" * @deprecated",
" * @constructor",
" * @struct",
" */",
"function C() {}")
);
test(
"/** @dict */ class C { }",
Joiner.on('\n').join(
"/**",
" * @constructor",
" * @dict",
" */",
"function C() {}")
);
public void testInterfaceWithJsDoc() {
test(Joiner.on('\n').join(
"/**",
" * Converts Xs to Ys.",
" * @interface",
" */",
"class Converter {",
"  /**",
"   * @param {X} x",
"   * @return {Y}",
"   */",
"  convert(x) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * Converts Xs to Ys.",
" * @interface",
" */",
"function Converter() {}",
"",
"/**",
" * @param {X} x",
" * @return {Y}",
" */",
"Converter.prototype.convert = function(x) {};"
));
public void testCtorWithJsDoc() {
test(Joiner.on('\n').join(
"class C {",
"  /** @param {boolean} b */",
"  constructor(b) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * @param {boolean} b",
" * @constructor",
" * @struct",
" */",
"function C(b) {}"
));
public void testMemberWithJsDoc() {
test(Joiner.on('\n').join(
"class C {",
"  /** @param {boolean} b */",
"  foo(b) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * @constructor",
" * @struct",
" */",
"function C() {}",
"",
"/** @param {boolean} b */",
"C.prototype.foo = function(b) {};"
));
public void testClassStatementInsideIf() {
test(Joiner.on('\n').join(
"if (foo) {",
"  class C { }",
"}"
), Joiner.on('\n').join(
"if (foo) {",
"  /** @constructor @struct */",
"  function C() { }",
"}"
));
test(Joiner.on('\n').join(
"if (foo)",
"  class C { }"
), Joiner.on('\n').join(
"if (foo)",
"  /** @constructor @struct */",
"  function C() { }"
));
public void testClassExpression() {
enableAstValidation(false);
test("var C = class { }", "var C = function() {}",
Es6ToEs3Converter.CANNOT_CONVERT);
test("var c = new (class C {})", null,
Es6ToEs3Converter.CANNOT_CONVERT);
public void testExtends() {
enableAstValidation(false);
test("class C extends D { }",
null, Es6ToEs3Converter.CANNOT_CONVERT);
public void testSuper() {
enableAstValidation(false);
test("class C { constructor() { super(); } }",
null, Es6ToEs3Converter.CANNOT_CONVERT);
test(Joiner.on('\n').join(
"class C {",
"  foo() { return super.foo(); }",
"}"
), null, Es6ToEs3Converter.CANNOT_CONVERT);
public void testStaticMethods() {
enableAstValidation(false);
test(Joiner.on('\n').join(
"class C {",
"  static foo() {}",
"}"
), null, Es6ToEs3Converter.CANNOT_CONVERT);
public void testArrowInClass() {
test(Joiner.on('\n').join(
"class C {",
"  constructor() {",
"    this.counter = 0;",
"  }",
"",
"  init() {",
"    document.onclick = () => this.logClick();",
"  }",
"",
"  logClick() {",
"     this.counter++;",
"  }",
"}"
), Joiner.on('\n').join(
"/**",
" * @constructor",
" * @struct",
" */",
"function C() {",
"  this.counter = 0;",
"}",
"",
"C.prototype.init = function() {",
"  var $jscomp$this = this;",
"  document.onclick = function() { return $jscomp$this.logClick(); }",
"};",
"",
"C.prototype.logClick = function() {",
"  this.counter++;",
"}"
));
public void testArrowFunction() {
test("var f = x => { return x+1; };",
"var f = function(x) { return x+1; };");
test("var odds = [1,2,3,4].filter((n) => n%2 == 1);",
"var odds = [1,2,3,4].filter(function(n) { return n%2 == 1; });");
test("var f = x => x+1;",
"var f = function(x) { return x+1; };");
test("var f = x => { this.needsBinding(); return 0; };",
Joiner.on('\n').join(
"var $jscomp$this = this;",
"var f = function(x) {",
"  $jscomp$this.needsBinding();",
"  return 0;",
"};"));
test(Joiner.on('\n').join(
"var f = x => {",
"  this.init();",
"  this.doThings();",
"  this.done();",
"};"
), Joiner.on('\n').join(
"var $jscomp$this = this;",
"var f = function(x) {",
"  $jscomp$this.init();",
"  $jscomp$this.doThings();",
"  $jscomp$this.done();",
"};"));
public void testMultipleArrowsInSameScope() {
test(Joiner.on('\n').join(
"var a1 = x => x+1;",
"var a2 = x => x-1;"
), Joiner.on('\n').join(
"var a1 = function(x) { return x+1; };",
"var a2 = function(x) { return x-1; };"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a1 = x => x+1;",
"  var a2 = x => x-1;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var a1 = function(x) { return x+1; };",
"  var a2 = function(x) { return x-1; };",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a1 = () => this.x;",
"  var a2 = () => this.y;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var $jscomp$this = this;",
"  var a1 = function() { return $jscomp$this.x; };",
"  var a2 = function() { return $jscomp$this.y; };",
"}"
));
test(Joiner.on('\n').join(
"var a = [1,2,3,4];",
"var b = a.map(x => x+1).map(x => x*x);"
), Joiner.on('\n').join(
"var a = [1,2,3,4];",
"var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a = [1,2,3,4];",
"  var b = a.map(x => x+1).map(x => x*x);",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var a = [1,2,3,4];",
"  var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });",
"}"
));
public void testArrowNestedScope() {
test(Joiner.on('\n').join(
"var outer = {",
"  f: function() {",
"     var a1 = () => this.x;",
"     var inner = {",
"       f: function() {",
"         var a2 = () => this.y;",
"       }",
"     };",
"  }",
"}"
), Joiner.on('\n').join(
"var outer = {",
"  f: function() {",
"     var $jscomp$this = this;",
"     var a1 = function() { return $jscomp$this.x; }",
"     var inner = {",
"       f: function() {",
"         var $jscomp$this = this;",
"         var a2 = function() { return $jscomp$this.y; }",
"       }",
"     };",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var setup = () => {",
"    function Foo() { this.x = 5; }",
"    this.f = new Foo;",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var $jscomp$this = this;",
"  var setup = function() {",
"    function Foo() { this.x = 5; }",
"    $jscomp$this.f = new Foo;",
"  }",
"}"
));
public void testArrowception() {
test("var f = x => y => x+y;",
"var f = function(x) {return function(y) { return x+y; }; };");
public void testArrowceptionWithThis() {
test(Joiner.on('\n').join(
"var f = x => {",
"  var g = y => {",
"    this.foo();",
"  }",
"}"
), Joiner.on('\n').join(
"var $jscomp$this = this;",
"var f = function(x) {",
"  var g = function(y) {",
"    $jscomp$this.foo();",
"  }",
"}"
));
compareJsDoc = false;
public void setUp() {
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
"var a = new obj();" +
options.declaredGlobalExternsOnWindow = false;
import com.google.common.base.Joiner;
private static final String BASEJS = Joiner.on("\n").join(
"/** @provideGoog */",
"var COMPILED = false;",
"var goog = goog || {}");
public void testManageDependencies5() throws Exception {
A.add(code("a2", provides("a2"), requires("a1")));
A.add(code("a1", provides("a1"), requires()));
A.add(code("base.js", BASEJS, provides(), requires()));
for (CompilerInput input : A.getInputs()) {
input.setCompiler(compiler);
DependencyOptions depOptions = new DependencyOptions();
depOptions.setDependencySorting(true);
List<CompilerInput> inputs = Lists.newArrayList();
inputs.addAll(A.getInputs());
List<CompilerInput> results = graph.manageDependencies(
depOptions, inputs);
assertInputs(A, "base.js", "a1", "a2");
assertEquals(
Lists.newArrayList("base.js", "a1", "a2"),
sourceNames(results));
return code(sourceName, "", provides, requires);
private SourceFile code(
String sourceName, String source,
List<String> provides, List<String> requires) {
return SourceFile.fromCode(sourceName, text + source);
"variable goog.foo redefined, " +
"original definition at [testcode]:1");
"variable goog.foo redefined, " +
"original definition at [testcode]:1");
"variable a.BB redefined, " +
"original definition at [testcode]:1");
"variable goog.a.BB redefined, " +
"original definition at [testcode]:1");
typeCheck(
"var x; /** @enum */ var x = { ONE: 1 };",
VariableReferenceCheck.REDECLARED_VARIABLE);
typeCheck(
"/** @enum */ var x = { ONE: 1 }; var x;",
VariableReferenceCheck.REDECLARED_VARIABLE);
"    x.prop;\n" +
checkNoWarnings(
"  if (!(typeof x == 'undefined')) {\n" +
"}");
typeCheck(
"function f(x) {\n" +
"  if (!(typeof x == 'undefined')) {\n" +
"    var /** undefined */ y = x;\n" +
"  }\n" +
NewTypeInference.MISTYPED_ASSIGN_RHS);
"  if (typeof x !== 'undefined') {\n" +
"    var /** undefined */ y = x;\n" +
NewTypeInference.MISTYPED_ASSIGN_RHS);
"  if (typeof x == 'undefined') {} else {\n" +
"    var /** undefined */ y = x;\n" +
"  }\n" +
NewTypeInference.MISTYPED_ASSIGN_RHS);
"function f(/** (number|undefined) */ x) {\n" +
"  if (typeof x !== 'undefined') {\n" +
checkNoWarnings(
"/** @interface */\n" +
"function High() {}\n" +
"/** @constructor @implements {High} */\n" +
"function Low() {}\n" +
"var /** !High */ x = new Low");
checkNoWarnings(
"/** @interface */\n" +
"function High() {}\n" +
"/** @interface @extends {High}*/\n" +
"function Low() {}\n" +
"function f(/** !High */ h, /** !Low */ l) { h = l; }");
checkNoWarnings(
"/** @interface */\n" +
"function High() {}\n" +
"/** @interface @extends {High}*/\n" +
"function Low() {}\n" +
"/** @constructor @implements {Low} */\n" +
"function Foo() {}\n" +
"var /** !High */ x = new Foo;");
checkNoWarnings(
"/** @interface */\n" +
"function Foo() {}\n" +
"/** @interface */\n" +
"function High() {}\n" +
"/** @interface @extends {High} */\n" +
"function Med() {}\n" +
"/**\n" +
" * @interface\n" +
" * @extends {Med}\n" +
" * @extends {Foo}\n" +
" */\n" +
"function Low() {}\n" +
"function f(/** !High */ x, /** !Low */ y) { x = y }");
typeCheck(
"/**\n" +
" * @interface\n" +
" * @template T\n" +
" */\n" +
"function Foo() {}\n" +
"function f(/** !Foo.<number> */ x, /** !Foo.<string> */ y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n" +
" * @interface\n" +
" * @template T\n" +
" */\n" +
"function Foo() {}\n" +
"/**\n" +
" * @constructor\n" +
" * @implements {Foo.<number>}\n" +
" */\n" +
"function Bar() {}\n" +
"function f(/** !Foo.<string> */ x, /** Bar */ y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/**\n" +
" * @interface\n" +
" * @template T\n" +
" */\n" +
"function Foo() {}\n" +
"/**\n" +
" * @constructor\n" +
" * @template T\n" +
" * @implements {Foo.<T>}\n" +
" */\n" +
"function Bar() {}\n" +
"function f(/** !Foo.<string> */ x, /** !Bar.<number> */ y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings(
"/**\n" +
" * @interface\n" +
" * @template T\n" +
" */\n" +
"function Foo() {}\n" +
"/**\n" +
" * @constructor\n" +
" * @template T\n" +
" * @implements {Foo.<T>}\n" +
" */\n" +
"function Bar() {}\n" +
"function f(/** !Foo.<string> */ x, /** !Bar.<string> */ y) {\n" +
"  x = y;\n" +
"}");
typeCheck(
"/**\n" +
" * @interface\n" +
" * @template T\n" +
" */\n" +
"function Foo() {}\n" +
"/**\n" +
" * @constructor\n" +
" * @template T\n" +
" * @implements {Foo.<T>}\n" +
" */\n" +
"function Bar() {}\n" +
"/**\n" +
" * @template T\n" +
" * @param {!Foo.<T>} x\n" +
" * @param {!Bar.<number>} y\n" +
" */\n" +
"function f(x, y) { x = y; }",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @template T */\n" +
"function f(/** T */ x, /** T */ y) {}\n" +
"f(1, 'str');",
NewTypeInference.NOT_UNIQUE_INSTANTIATION);
typeCheck(
"/** @template T */\n" +
"function /** T */ f(/** T */ x) { return x; }\n" +
"f('str') - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
public void testEnumBasicTyping() {
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f(/** E */ x) { x < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"/** @enum */\n" + // No type annotation defaults to number
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f(/** E */ x) { x < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
checkNoWarnings(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f(/** E */ x) {}\n" +
"function g(/** number */ x) {}\n" +
"f(E.TWO);\n" +
"g(E.TWO);");
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f(/** E */ x) {}\n" +
"f(1);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f() { E.THREE - 5; }",
TypeCheck.INEXISTENT_PROPERTY);
checkNoWarnings(
"/** @enum {!Foo} */\n" +
"var E = { ONE: new Foo };\n" +
"/** @constructor */\n" +
"function Foo() {}");
typeCheck(
"/** @typedef {number} */\n" +
"var num;\n" +
"/** @enum {num} */\n" +
"var E = { ONE: 1 };\n" +
"function f(/** E */ x) { x < 'str'; }",
NewTypeInference.INVALID_OPERAND_TYPE);
public void testEnumBadInitializer() {
typeCheck(
"/** @enum {number} */\n" +
"var E;",
GlobalTypeInfo.MALFORMED_ENUM);
typeCheck(
"/** @enum {number} */\n" +
"var E = {};",
GlobalTypeInfo.MALFORMED_ENUM);
typeCheck(
"/** @enum {number} */\n" +
"var E = 1;",
GlobalTypeInfo.MALFORMED_ENUM);
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: true\n" +
"};",
NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE);
typeCheck(
"/** @enum {number} */\n" +
"var E = { a: 1 };",
TypeCheck.ENUM_NOT_CONSTANT);
typeCheck(
"/** @enum {number} */\n" +
"var E = { A: 1, A: 2 };",
GlobalTypeInfo.DUPLICATE_PROP_IN_ENUM);
public void testEnumPropertiesConstant() {
checkNoWarnings(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"E.THREE = 3;");
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"E.ONE = E.TWO;",
NewTypeInference.CONST_REASSIGNED);
typeCheck(
"/** @enum {number} */\n" +
"var E = {\n" +
"  ONE: 1,\n" +
"  TWO: 2\n" +
"};\n" +
"function f(/** E */) { E.ONE = E.TWO; }",
NewTypeInference.CONST_REASSIGNED);
public void testEnumIllegalRecursion() {
typeCheck(
"/** @enum {Type2} */\n" +
"var Type1 = {\n" +
"  ONE: null\n" +
"};\n" +
"/** @enum {Type1} */\n" +
"var Type2 = {\n" +
"  ONE: null\n" +
"};",
ImmutableList.of(
RhinoErrorReporter.BAD_JSDOC_ANNOTATION,
NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE));
typeCheck(
"/** @enum {Type2} */\n" +
"var Type1 = {\n" +
"  ONE: null\n" +
"};\n" +
"/** @typedef {Type1} */\n" +
"var Type2;",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
public void testEnumBadDeclaredType() {
typeCheck(
"/** @enum {InexistentType} */\n" +
"var E = { ONE : null };",
GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME);
typeCheck(
"/** @enum {*} */\n" +
"var E = { ONE: 1, STR: '' };",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {\n" +
"  /** @enum {function(T):number} */\n" +
"  var E = { ONE: x };\n" +
"}",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {\n" +
"  /** @enum {T} */\n" +
"  var E1 = { ONE: 1 };\n" +
"  /** @enum {function(E1):E1} */\n" +
"  var E2 = { ONE: function(x) { return x; } };\n" +
"}",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(
"/**\n" +
" * @template T\n" +
" * @param {T} x\n" +
" */\n" +
"function f(x) {\n" +
"  /** @typedef {T} */ var AliasT;\n" +
"  /** @enum {T} */\n" +
"  var E1 = { ONE: 1 };\n" +
"  /** @enum {function(E1):T} */\n" +
"  var E2 = { ONE: function(x) { return x; } };\n" +
"}",
ImmutableList.of(
RhinoErrorReporter.BAD_JSDOC_ANNOTATION,
RhinoErrorReporter.BAD_JSDOC_ANNOTATION));
typeCheck(
"/** @enum {number|string} */\n" +
"var E = { ONE: 1, STR: '' };",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(
"/** @constructor */\n" +
"function Foo() {}\n" +
"/** @enum {Foo} */\n" +
"var E = { ONE: new Foo, TWO: null };",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
typeCheck(
"/** @typedef {number|string} */\n" +
"var NOS;\n" +
"/** @enum {NOS} */\n" +
"var E = { ONE: 1, STR: '' };",
RhinoErrorReporter.BAD_JSDOC_ANNOTATION);
public void testEnumsWithGenerics() {
checkNoWarnings(
"/** @enum */ var E1 = { A: 1};\n" +
"/** @enum */ var E2 = { A: 2};\n" +
"/**\n" +
" * @template T\n" +
" * @param {(T|E1)} x\n" +
" */\n" +
"function f(x) {}\n" +
"f(/** @type {(string|E1)} */ ('str'));");
typeCheck(
"/** @enum */ var E1 = { A: 1};\n" +
"/** @enum */ var E2 = { A: 2};\n" +
"/**\n" +
" * @template T\n" +
" * @param {(T|E1)} x\n" +
" */\n" +
"function f(x) {}\n" +
"f(/** @type {(string|E2)} */ ('str'));",
NewTypeInference.FAILED_TO_UNIFY);
public void testEnumJoinSpecializeMeet() {
typeCheck(
"/** @enum {number} */\n" +
"var E = { ONE: 1 };\n" +
"function f(cond) {\n" +
"  var x = cond ? E.ONE : 5;\n" +
"  x - 2;\n" +
"  var /** E */ y = x;\n" +
"}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
typeCheck(
"/** @constructor */\n" +
"function High() {}\n" +
"/** @constructor @extends {High} */\n" +
"function Low() {}\n" +
"/** @enum {!Low} */\n" +
"var E = { A: new Low };\n" +
"function f(cond) {\n" +
"  var x = cond ? E.A : new High;\n" +
"  var /** High */ y = x;\n" +
"  var /** E */ z = x;\n" +
"}",
NewTypeInference.MISTYPED_ASSIGN_RHS);
checkNoWarnings(
"/** @constructor */\n" +
"function High() {}\n" +
"/** @constructor @extends {High} */\n" +
"function Low() {}\n" +
"/** @enum {!High} */\n" +
"var E = { A: new High };\n" +
"function f(cond) {\n" +
"  var x = cond ? E.A : new Low;\n" +
"  if (!(x instanceof Low)) { var /** E */ y = x; }\n" +
"}");
typeCheck(
"/** @enum {?} */\n" +
"var E = { A: 123 };\n" +
"function f(x) {\n" +
"  var /** string */ s = x;\n" +
"  var /** E */ y = x;\n" +
"  s = x;\n" +
"}\n" +
"f('str');",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @enum {number} */\n" +
"var E1 = { ONE: 1 };\n" +
"/** @enum {number} */\n" +
"var E2 = { TWO: 1 };\n" +
"/** @enum {number} */\n" +
"var E3 = { THREE: 1 };\n" +
"function f(x) {\n" +
"  var /** (E1|E2) */ y = x;\n" +
"  var /** (E1|E3) */ z = x;\n" +
"  var /** E1 */ w = x;\n" +
"}\n" +
"f(E2.TWO);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @enum {number} */\n" +
"var E = { ONE: 1 };\n" +
"function f(x) {\n" +
"  var /** E */ y = x;\n" +
"  var /** number */ z = x;\n" +
"}\n" +
"f(123);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @constructor */\n" +
"function High() {}\n" +
"/** @constructor @extends {High} */\n" +
"function Low() {}\n" +
"/** @enum {!Low} */\n" +
"var E = { A: new Low };\n" +
"function f(x) {\n" +
"  var /** !High */ y = x;\n" +
"  var /** E */ z = x;\n" +
"}\n" +
"f(new High);",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @interface */\n" +
"function High1() {}\n" +
"/** @interface */\n" +
"function High2() {}\n" +
"/** @constructor @implements {High1} @implements {High2} */\n" +
"function Low() {}\n" +
"/** @enum {!Low} */\n" +
"var E = { A: new Low };\n" +
"function f(x) {\n" +
"  var /** (!High1 | !High2) */ y = x;\n" +
"  var /** E */ z = x;\n" +
"}\n" +
"f(/** @type {!High1} */ (new Low));",
NewTypeInference.INVALID_ARGUMENT_TYPE);
typeCheck(
"/** @constructor */\n" +
"function High() {}\n" +
"/** @constructor @extends {High} */\n" +
"function Low() {}\n" +
"/** @enum {!High} */\n" +
"var E = { A: new High };\n" +
"/** @param {function(E)|function(!Low)} x */\n" +
"function f(x) { x(123); }",
NewTypeInference.CALL_FUNCTION_WITH_BOTTOM_FORMAL);
public void testNoDoubleWarnings() {
typeCheck(
"if ((4 - 'str') && true) { 4 + 5; }",
NewTypeInference.INVALID_OPERAND_TYPE);
typeCheck(
"(4 - 'str') ? 5 : 6;",
NewTypeInference.INVALID_OPERAND_TYPE);
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
TypeValidator.DUP_VAR_DECLARATION_TYPE_MISMATCH, false);
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
compareJsDoc = false;
assertTrue(e.getMessage().contains("Expected BLOCK but was EMPTY"));
private static final String EXTERNS = "var window;";
compareJsDoc = false;
if (!observedPositions.containsKey(sourceFile)) {
compareJsDoc = false;
package com.google.javascript.jscomp;
import com.google.common.collect.ImmutableList;
import com.google.javascript.rhino.Node;
import junit.framework.TestCase;
public class TemplateAstMatcherTest extends TestCase {
private Compiler lastCompiler;
public void testMatches_primitives() {
String template = ""
+ "function template() {\n"
+ "  3;\n"
+ "}\n";
TestNodePair pair = compile("", template, "3");
assertMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
pair = compile("", template, "5");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "var foo = 3;");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
pair = compile("", template, "obj.foo();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
template = ""
+ "function template() {\n"
+ "  'str';\n"
+ "}\n";
pair = compile("", template, "'str'");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "'not_str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "var foo = 'str';");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
pair = compile("", template, "obj.foo();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
template = ""
+ "function template() {\n"
+ "  true;\n"
+ "}\n";
pair = compile("", template, "true");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "!true");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "false");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile("", template, "var foo = true;");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
pair = compile("", template, "!undefined");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
public void testMatches_varDeclarations() {
String template = ""
+ "function template() {\n"
+ "  var a = 3;\n"
+ "}\n";
TestNodePair pair;
pair = compile("", template, "var a = 3;");
assertMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile("", template, "var b = 3;");
assertMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile("", template, "var a = 5;");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile("", template, "5;");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
template = ""
+ "function template() {\n"
+ "  var a = {};\n"
+ "}\n";
pair = compile("", template, "var a = {};");
assertMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile("", template, "var a = {'a': 'b'};");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
template = ""
+ "function template() {\n"
+ "  var a = {\n"
+ "    'a': 'b'\n"
+ "  };\n"
+ "}\n";
pair = compile("", template, "var a = {'a': 'b'};");
assertMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile("", template, "var a = {};");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
public void testMatches_templateParameterType() {
String externs = "";
String template = ""
+ "/**\n"
+ " * @param {string} foo\n"
+ " */\n"
+ "function template(foo) {\n"
+ "  foo;\n"
+ "}\n";
TestNodePair pair = compile(externs, template, "'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "'different_str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "var foo = 'str';");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
template = ""
+ "/**\n"
+ " * @param {*} foo\n"
+ " */\n"
+ "function template(foo) {\n"
+ "  foo;\n"
+ "}\n";
pair = compile(externs, template, "'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "3");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "new Object()");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
template = ""
+ "/**\n"
+ " * @param {string} foo\n"
+ " * @param {number} bar\n"
+ " */\n"
+ "function template(foo, bar) {\n"
+ "  bar + foo;\n"
+ "}\n";
pair = compile(externs, template, "'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "3");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "new Object()");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "3 + ''");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "7 + 'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
public void testMatches_functionCall() {
String externs = ""
+ "function foo() {};\n"
+ "function bar(arg) {};\n";
String template = ""
+ "function template() {\n"
+ "  foo();\n"
+ "}\n";
TestNodePair pair = compile(externs, template, "foo();");
assertMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
pair = compile(externs, template, "bar();");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
pair = compile(externs, template, "bar(foo());");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getLastChild());
public void testMatches_functionCallWithArguments() {
String externs = ""
+ "/** @return {string} */\n"
+ "function foo() {};\n"
+ "/** @param {string} arg */\n"
+ "function bar(arg) {};\n"
+ "/**\n"
+ " * @param {string} arg\n"
+ " * @param {number arg2\n"
+ " */\n"
+ "function baz(arg, arg2) {};\n";
String template = ""
+ "function template() {\n"
+ "  bar('str');\n"
+ "}\n";
TestNodePair pair = compile(externs, template, "foo();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar('str');");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar(foo());");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
assertNotMatch(
pair.templateNode, pair.getTestExprResultRoot().getFirstChild().getLastChild());
template = ""
+ "/** @param {string} str */\n"
+ "function template(str) {\n"
+ "  bar(str);\n"
+ "}\n";
pair = compile(externs, template, "foo();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar('str');");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar('str' + 'other_str');");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "bar(String(3));");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
template = ""
+ "/**\n"
+ " * @param {string} str\n"
+ " * @param {number} num\n"
+ " */\n"
+ "function template(str, num) {\n"
+ "  baz(str, num);\n"
+ "}\n";
pair = compile(externs, template, "foo();");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "baz('str', 3);");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "baz('str' + 'other_str', 3 + 4);");
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
public void testMatches_methodCall() {
String externs = ""
+ "/** @return {string} */\n"
+ "function foo() {};\n";
String template = ""
+ "/**\n"
+ " * @param {string} str\n"
+ " */\n"
+ "function template(str) {\n"
+ "  str.toString();\n"
+ "}\n";
TestNodePair pair = compile(externs, template, "'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "'str'.toString()");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "foo().toString()");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
public void testMatches_methodCallWithArguments() {
String externs = ""
+ "/** @constructor */\n"
+ "function AppContext() {}\n"
+ "AppContext.prototype.init = function() {};\n"
+ "/**\n"
+ " * @param {string} arg\n"
+ " */\n"
+ "AppContext.prototype.get = function(arg) {};\n"
+ "/**\n"
+ " * @param {string} arg\n"
+ " */\n"
+ "AppContext.prototype.getOrNull = function(arg) {};";
String template = ""
+ "/**\n"
+ " * @param {AppContext} context\n"
+ " */\n"
+ "function template(context) {\n"
+ "  context.init();\n"
+ "}\n";
TestNodePair pair = compile(externs, template, "'str'");
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot());
assertNotMatch(pair.templateNode, pair.getTestExprResultRoot().getFirstChild());
pair = compile(externs, template, "var context = new AppContext(); context.init();");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
pair = compile(externs, template, "var context = new AppContext(); context.get('str');");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
template = ""
+ "/**\n"
+ " * @param {AppContext} context\n"
+ " * @param {string} service\n"
+ " */\n"
+ "function template(context, service) {\n"
+ "  context.get(service);\n"
+ "}\n";
pair = compile(externs, template, "var context = new AppContext(); context.init();");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
pair = compile(externs, template, "var context = new AppContext(); context.get('s');");
assertMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
pair = compile(externs, template, "var context = new AppContext(); context.get(3);");
assertNotMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
pair = compile(externs, template, "var context = new AppContext(); context.getOrNull('s');");
assertNotMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
public void testMatches_instantiation() {
String externs = ""
+ "/** @constructor */\n"
+ "function AppContext() {}\n";
String template = ""
+ "function template() {\n"
+ "  new AppContext();"
+ "}\n";
TestNodePair pair = compile(externs, template, "var foo = new AppContext()");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
pair = compile(externs, template, "var foo = new Object()");
assertNotMatch(
pair.templateNode, pair.testNode.getFirstChild().getFirstChild().getFirstChild());
public void testMatches_propertyAccess() {
String externs = ""
+ "/** @constructor */\n"
+ "function AppContext() {}\n"
+ "/** @type {string} */\n"
+ "AppContext.prototype.location;\n";
String template = ""
+ "/**\n"
+ " * @param {AppContext} context\n"
+ " */\n"
+ "function template(context) {\n"
+ "  context.location;"
+ "}\n";
TestNodePair pair = compile(
externs, template, "var context = new AppContext(); context.location = '3';");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(
pair.templateNode, pair.testNode.getLastChild().getFirstChild().getFirstChild());
public void testMatches_multiLineTemplates() {
String externs = ""
+ "/** @constructor */\n"
+ "function AppContext() {}\n"
+ "/** @type {string} */\n"
+ "AppContext.prototype.location;\n";
String template = ""
+ "/**\n"
+ " * @param {AppContext} context\n"
+ " * @param {string} str\n"
+ " */\n"
+ "function template(context, str) {\n"
+ "  context.location = str;\n"
+ "  delete context.location;\n"
+ "}\n";
TestNodePair pair = compile(
externs, template, "var context = new AppContext(); context.location = '3';");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertNotMatch(
pair.templateNode, pair.testNode.getLastChild().getFirstChild().getFirstChild());
pair = compile(
externs, template, "var ac = new AppContext(); ac.location = '3'; delete ac.location;");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(pair.templateNode, pair.testNode.getFirstChild().getNext());
externs = ""
+ "/** @param {string} arg */\n"
+ "function bar(arg) {};\n";
template = ""
+ "function template() {\n"
+ "  var a = 'string';\n"
+ "  bar(a);\n"
+ "}\n";
pair = compile(
externs, template, "var loc = 'string'; bar(loc);");
assertMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile(
externs, template, "var loc = 'string'; bar('foo');");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
pair = compile(
externs, template, "var baz = 'qux'; var loc = 'string'; bar(baz);");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getNext());
public void testMatches_subclasses() {
String externs = ""
+ "/** @constructor */\n"
+ "function AppContext() {}\n"
+ "/** @type {string} */\n"
+ "AppContext.prototype.location;\n"
+ "/**\n"
+ " * @constructor\n"
+ " * @extends {AppContext}\n"
+ " */\n"
+ "function SubAppContext() {}\n";
String template = ""
+ "/**\n"
+ " * @param {AppContext} context\n"
+ " * @param {string} str\n"
+ " */\n"
+ "function template(context, str) {\n"
+ "  context.location = str;\n"
+ "}\n";
TestNodePair pair = compile(
externs, template, "var context = new SubAppContext(); context.location = '3';");
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild());
assertNotMatch(pair.templateNode, pair.testNode.getFirstChild().getFirstChild());
assertMatch(pair.templateNode, pair.testNode.getLastChild().getFirstChild());
private void assertMatch(Node templateRoot, Node testNode, boolean shouldMatch) {
TemplateAstMatcher matcher = new TemplateAstMatcher(lastCompiler, templateRoot.getFirstChild());
StringBuilder sb = new StringBuilder();
sb.append("The nodes should").append(shouldMatch ? "" : " not").append(" have matched.\n");
sb.append("Template node:\n").append(templateRoot.toStringTree()).append("\n");
sb.append("Test node:\n").append(testNode.getParent().toStringTree()).append("\n");
assertEquals(sb.toString(), shouldMatch, matcher.matches(testNode));
private void assertMatch(Node templateRoot, Node testNode) {
assertMatch(templateRoot, testNode, true);
private void assertNotMatch(Node templateRoot, Node testNode) {
assertMatch(templateRoot, testNode, false);
private TestNodePair compile(String externs, String template, String code) {
Compiler compiler = lastCompiler = new Compiler();
compiler.disableThreads();
CompilerOptions options = new CompilerOptions();
options.checkTypes = true;
Node templateNode = compiler.parse(SourceFile.fromCode(
"template", template));
compiler.compile(
ImmutableList.of(SourceFile.fromCode("externs", externs)),
ImmutableList.of(
SourceFile.fromCode("test", "{" + code + "}")),
options);
Node root = compiler.getRoot();
return new TestNodePair(templateNode, root.getLastChild());
private static class TestNodePair {
final Node templateNode;
final Node testNode;
TestNodePair(Node template, Node root) {
this.templateNode = template;
this.testNode = root.getLastChild().getFirstChild();
Node getTestExprResultRoot() {
return testNode.getFirstChild().isExprResult() ? testNode.getFirstChild() : null;
"variable goog.foo redefined, original definition at [testcode]:1");
"variable goog.foo redefined, " +
"original definition at [testcode]:1");
"variable F.prototype.bar redefined, " +
"original definition at [testcode]:1");
"variable F.prototype.bar redefined, " +
"original definition at [testcode]:1");
"variable a.BB redefined, original definition at [testcode]:1");
"variable goog.a.BB redefined, original definition at [testcode]:1");
public void testModuleReferenceNotAllowed() throws Exception {
testTypes(
"/** @param {./Foo} z */ function f(z) {}",
"Bad type annotation. Unknown type ./Foo");
public void testDeclaredConstType6() throws Exception {
testSame(
"/** " +
" * @param {{y:string}} a\n" +
" * @constructor\n" +
"*/\n" +
"var C = function(a) { /** @const */ this.x = a.y;};\n" +
"var instance = new C({y:'str'})");
ObjectType instance = (ObjectType) findNameType("instance", globalScope);
assertEquals("C", instance.toString());
assertTrue(instance.hasProperty("x"));
assertEquals("string",
instance.getPropertyType("x").toString());
assertFalse(instance.isPropertyTypeInferred("x"));
compareJsDoc = false;
STRING, COLON, COLON, COLON, ELLIPSIS, STRING, COLON, STRING, EOC);
NewIRFactory.SUSPICIOUS_COMMENT_WARNING;
NewIRFactory.MISPLACED_TYPE_ANNOTATION;
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
private void testTemplateString(String s) {
mode = LanguageMode.ECMASCRIPT5;
parseWarning(s,
"this language feature is only supported in es6 mode: template strings");
mode = LanguageMode.ECMASCRIPT6;
parse(s);
public void testTemplateString() {
testTemplateString("`hello world`;");
testTemplateString("`hello\nworld`;");
testTemplateString("`string containing \\`escaped\\` backticks`;");
public void testTemplateStringPlaceholder() {
mode = LanguageMode.ECMASCRIPT6;
parse("`hello \\${name}`;");
parseWarning("`hello ${name}`;",
"Placeholders in template strings are not supported yet.");
public void testUnterminatedTemplateString() {
mode = LanguageMode.ECMASCRIPT6;
parseError("`hello",
"Unterminated template string");
parseError("`hello\\`",
"Unterminated template string");
public void testIncorrectEscapeSequenceInTemplateString() {
parseError("`hello\\x",
"Hex digit expected");
parseError("`hello\\x`",
"Hex digit expected");
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
parseWarning("var x = {function: 1};", NewIRFactory.INVALID_ES3_PROP_NAME);
parseWarning("x.function;", NewIRFactory.INVALID_ES3_PROP_NAME);
NewIRFactory.GETTER_ERROR_MESSAGE);
parseError("var x = {get function(){} };", NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
NewIRFactory.GETTER_ERROR_MESSAGE);
parseError("var x = {set function(a){} };", NewIRFactory.SETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
NewIRFactory.SETTER_ERROR_MESSAGE);
parseWarning("var x = {class: 1};", NewIRFactory.INVALID_ES3_PROP_NAME);
parseWarning("x.class;", NewIRFactory.INVALID_ES3_PROP_NAME);
NewIRFactory.INVALID_ES3_PROP_NAME);
parseWarning("x().catch();", NewIRFactory.INVALID_ES3_PROP_NAME);
public void testShebang() {
parse("#!/usr/bin/node\n var x = 1;");
parseError("var x = 1; \n #!/usr/bin/node",
"primary expression expected");JSDocInfo jsDocInfo;
JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
builder.recordSuppressions(ImmutableSet.of("duplicate"));
builder.recordEnumParameterType  (oldJSDocInfo.getEnumParameterType());
jsDocInfo = builder.build(newNode);
jsDocInfo = oldJSDocInfo.clone();
nodes.add(c);static boolean isConstantDeclaration(
CodingConvention convention, JSDocInfo info, Node node) {
if (info != null && info.isConstant()) {
return true;
if (node.getBooleanProp(Node.IS_CONSTANT_VAR)) {
return true;
switch (node.getType()) {
case Token.NAME:
return NodeUtil.isConstantByConvention(
convention, node, node.getParent());
case Token.GETPROP:
return node.isQualifiedName() && NodeUtil.isConstantByConvention(
convention, node.getLastChild(), node);
return false;
boolean isTypelessConstDecl =
isVarDeclaration &&
NodeUtil.isConstantDeclaration(
compiler.getCodingConvention(),
var.getJSDocInfo(), var.getNameNode()) &&
!(var.getJSDocInfo() != null &&
var.getJSDocInfo().hasType());
boolean isVarTypeBetter = isVarDeclaration
&& !resultType.isNullType() && !resultType.isVoidType()
&& !isTypelessConstDecl;
resultType : oldType.getLeastSupertype(resultType));
var.setType(resultType);
if (NodeUtil.isConstantDeclaration(
compiler.getCodingConvention(), info, lValue)) {
|| (NodeUtil.isConstantDeclaration(
compiler.getCodingConvention(), info, n)
&& valueType != null
"generated_js/example.js",
sourcemap("generated_js/example.srcmap", "../original/source.html",
SourceFile.fromCode("original/source.html", "<div ng-show='foo()'>"));
.setOriginalFile("original/source.html")
compiler.getSourceMapping("generated_js/example.js", 3, 3));
compiler.getSourceLine("original/source.html", 1));
public void testConstDecl1() throws Exception {
testTypes(
"/** @param {?number} x \n @return {boolean} */" +
"function f(x) { " +
"  if (x) { /** @const */ var y = x; return y } return true; "  +
"}",
"inconsistent return type\n" +
"found   : number\n" +
"required: boolean");
public void testConstDecl2() throws Exception {
testTypes(
"/** @param {?number} x */" +
"function f(x) { " +
"  if (x) {" +
"    /** @const */ var y = x; " +
"    /** @return {boolean} */ function g() { return y; } " +
"  }" +
"}",
"inconsistent return type\n" +
"found   : number\n" +
"required: boolean");abstract protected SourceMap.Format getSourceMapFormat();
abstract protected SourceMapConsumer getSourceMapConsumer();
Map<String, String> inputMap = new LinkedHashMap<String, String>();
private static String generatePreProcessThrowCode(int repititions,
for (int i = 0; i < repititions; i++) {
int repitions = Math.max(ENOUGH_TO_ALIAS_THROW, ENOUGH_TO_ALIAS_LITERAL);
repitions, "var JSCompiler_alias_TRUE=true;",
test(generatePreProcessThrowCode(repitions, "true"), afterCode);
assertTrue(-1 != expected.getMessage().indexOf(
"Existing alias definition"));
import com.google.javascript.jscomp.graph.LinkedDirectedGraph;
new CountingPredicate<String>(Predicates.equalTo("4a"));
return new CheckPathsBetweenNodes<String, String>(graph,
return new CheckPathsBetweenNodes<String, String>(graph,
count ++;
private Map<Integer,String> filenames;
private final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(
assertTrue(builder.toString().indexOf("transitive-dependencies") != -1);
"foo.prototype.x=function(){};"+
Lists.<JSModule>newArrayList(
Lists.<JSModule>newArrayList(
Suppliers.<List<SourceFile>>ofInstance(externs),
test(js, expected, (DiagnosticType) null);
new ControlFlowGraph<Instruction>(inst1, true, true);
new ControlFlowGraph<Instruction>(inst1, true, true);
new ControlFlowGraph<Instruction>(inst1, true, true);
final int MAX_STEP = 10;
Map<String, CheckLevel> propertiesToErrorFor =
Maps.<String, CheckLevel>newHashMap();
import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;
import com.google.javascript.jscomp.graph.DiGraph;
new FixedPointGraphTraversal<Counter, String>(callback);
traversal = new FixedPointGraphTraversal<Counter, String>(
assertEquals(Sets.newHashSet(),
parseFunction("function f(a){ return a==0; }")));
assertEquals(Sets.newHashSet(),
parseFunction("function f(a){ b=a }")));
"function f(a,b){ "+
"function f(a,b){ "+
assertEquals(Sets.newHashSet(), getLastCompiler().getExternProperties());
"external.charAt()", (DiagnosticType) null);
"external.charAt()", (DiagnosticType) null);
(DiagnosticType) null);
assertTrue(e.getMessage().indexOf("Unexpected variable x") != -1);
ImmutableList.<String>of("c2"), inputs);
depOptions.setEntryPoints(ImmutableList.<String>of("c2"));
import java.util.ArrayList;
List<JSModule> modulesInDepOrder = new ArrayList<JSModule>();
assertEquals(ImmutableSet.of(), mod1.getAllDependencies());
((ObjectType) googScopeType).hasProperty("foo"));
((ObjectType) googScopeType).hasProperty("bar"));
previous = VariableMap.fromMap(ImmutableMap.<String,String>of(
previous = VariableMap.fromMap(ImmutableMap.<String,String>of(
final List<JSError> errors = new ArrayList<JSError>();
final String TEST_EXCEPTION = "test me";
currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of();
ImmutableList.<
AbstractPeepholeOptimization>of(note1Applied, note2Applied);
currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(
new RemoveNodesNamedXOptimization(),
new RemoveParentVarsForNodesNamedX());
currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(
new RenameYToX(),
new RemoveParentVarsForNodesNamedX());
import static com.google.javascript.jscomp.PureFunctionIdentifier.INVALID_NO_SIDE_EFFECT_ANNOTATION;
ImmutableList.<String>of("externSENone"));
ImmutableList.<String>of("externObjSEThis"));
ImmutableList.<String>of(
"externObjSEThis", "NEW STRING externObjSEThisMethod"));
ImmutableList.<String>of("externObjSEThis", "f"));
ImmutableList.<String>of(
ImmutableList.<String>of("externObjSEThis"));
ImmutableList.<String>of("externObjSEThis"));
ImmutableList.<String>of("externObjSEThis"));
ImmutableList.<String>of(
ImmutableList.<String>of("o.propWithStubBefore"));
ImmutableList.<String>of("o.propWithStubBeforeWithJSDoc"));
ImmutableList.<String>of("o.propWithStubAfter"));
ImmutableList.<String>of("o.propWithStubAfter"));
List<String> expected = ImmutableList.<String>of();
assertEquals(expected, noSideEffectCalls);
List<String> expected = ImmutableList.<String>of();
ImmutableList.<String>of("f.call"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("A"));
ImmutableList.<String>of("A"));
ImmutableList.<String>of("A"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("f"));
ImmutableList.<String>of("Error"));
ImmutableList.<String>of("Error"));
ImmutableList.<String>of("A", "a.foo"));
ImmutableList.<String>of("A"));
checkMarkedCalls(source, ImmutableList.<String>of("A", "A", "f"));
checkMarkedCalls(source, ImmutableList.<String>of("f"));
checkMarkedCalls(source, ImmutableList.<String>of("f", "g"));
checkMarkedCalls(source, ImmutableList.<String>of("(f || g)", "h"));
checkMarkedCalls(source, ImmutableList.<String>of("(f : g)", "h"));
checkMarkedCalls(source, ImmutableList.<String>of("(f : (g || h))", "i"));
checkMarkedCalls(source, ImmutableList.<String>of("(g || g)", "k"));
checkMarkedCalls(source, ImmutableList.<String>of("(g : g)", "k"));
checkMarkedCalls(source, ImmutableList.<String>of(
checkMarkedCalls(source, ImmutableList.<String>of(
checkMarkedCalls(source, ImmutableList.<String>of(
checkMarkedCalls(source, ImmutableList.<String>of(
checkMarkedCalls(source, ImmutableList.<String>of("F"));
List<String> locals = new ArrayList<String>();
whitelist = ImmutableSet.<String>of("goog", "elephant");
whitelist = ImmutableSet.<String>of("long-prefix");
whitelist = ImmutableSet.<String>of("goog-elephant");
import com.google.common.collect.Maps;
private final static String EXTERNS =
Map<String, CheckLevel> propertiesToErrorFor =
Maps.<String, CheckLevel>newHashMap();
previous = VariableMap.fromMap(ImmutableMap.of("previous","xyz"));
previous = VariableMap.fromMap(ImmutableMap.of("a","unused"));
previous = VariableMap.fromMap(ImmutableMap.of("previous","xyz"));
"a", "goog.net.XhrTransport","b", "my.app.Application" });
assertEquals(substitutedStrings.length/2, results.size());
Result result = results.get(i/2);
U2U_CONSTRUCTOR_TYPE,NUMBER_STRING_BOOLEAN))),
((LinkedFlowScope) scope).inferSlotType(name, type);
ImmutableSet.<String>of("DEF STRING_KEY null -> NUMBER"));
ImmutableSet.<String>of("DEF STRING_KEY null -> NUMBER"));
final String DEF = "var f = function(arg1, arg2){}";
final String USE = "f(1, 2)";
import java.util.ArrayList;
mappings = new ArrayList<SourceMap.LocationMapping>();
mappings.add(new SourceMap.LocationMapping("pre/", ""));
mappings = new ArrayList<SourceMap.LocationMapping>();
mappings.add(new SourceMap.LocationMapping("pre/file", "src"));
mappings = new ArrayList<SourceMap.LocationMapping>();
mappings.add(new SourceMap.LocationMapping("file1", "x"));
mappings.add(new SourceMap.LocationMapping("file2", "y"));
mappings = new ArrayList<SourceMap.LocationMapping>();
mappings.add(new SourceMap.LocationMapping("file1", "x"));
mappings.add(new SourceMap.LocationMapping("file", "y"));
assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());
assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());
assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());
assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());
((ObjectType) googScopeType).hasProperty("foo"));
((ObjectType) googScopeType).hasProperty("bar"));
testTypes(externs, js, (String)null, false);
assertTrue(e.getMessage().indexOf("Unexpected variable x") != -1);
private final static class VariableTestCheck implements CompilerPass {
new SortedDependencies<SimpleDependencyInfo>(
new SortedDependencies<SimpleDependencyInfo>(shuffled);
new SortedDependencies<SimpleDependencyInfo>(shuffled);
import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;
import com.google.javascript.jscomp.graph.GraphNode;
import com.google.javascript.jscomp.graph.Graph.GraphEdge;
new GreedyGraphColoring<String, String>(graph);
new GreedyGraphColoring<String, String>(graph);
new GreedyGraphColoring<String, String>(graph);
new GreedyGraphColoring<String, String>(graph);
new GreedyGraphColoring<String, String>(graph);
assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());
assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());
new GreedyGraphColoring<String, String>(graph, lexicographic);
coloring = new GreedyGraphColoring<String, String>(graph, biasD);
new GraphPruner<String, String>(graph).prune(
new GraphPruner<String, String>(graph).prune(
new GraphPruner<String, String>(graph).prune(
new GraphPruner<String, String>(graph).prune(
new GraphPruner<String, String>(graph).prune(
reachability = new GraphReachability<String, String>(graph);
reachability = new GraphReachability<String, String>(graph);
reachability = new GraphReachability<String, String>(graph);
reachability = new GraphReachability<String, String>(graph);
reachability = new GraphReachability<String, String>(graph);
reachability = new GraphReachability<String, String>(graph);
Set<String> set = new HashSet<String>();
Set<String> otherSet = new HashSet<String>();
for (String target : targets) {
otherSet.add(target);
union = new StandardUnionFind<String>();
UnionFind<String> copy = new StandardUnionFind<String>(union);
UnionFind<String> copy = new StandardUnionFind<String>(union);
assertContentsAnyOrder((String) null, actual, expected);
import com.google.common.collect.ImmutableSet;
assertEquals(ImmutableSet.of(), parser.getWarnings());
import com.google.common.collect.ImmutableSet;
assertEquals(ImmutableSet.of(), parser.getWarnings());
import com.google.javascript.jscomp.regex.CharRanges;
import junit.framework.TestCase;
CharRanges isbs = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });
CharRanges isbs2 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });
CharRanges esbs = CharRanges.withMembers(new int[0]);
CharRanges.withRanges(new int[] { 1 });
CharRanges.withRanges(new int[] { 1, 4, 4, 5 });
CharRanges.withRanges(new int[] { 4, 5, 1, 3 });
CharRanges.withRanges(new int[] { 0, 0 });
CharRanges sbs1 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });
CharRanges sbs2 = CharRanges.withMembers(new int[] { 9, 1, 4, 1, 0 });
CharRanges a = CharRanges.withRanges(new int[] {
0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B });
CharRanges b = CharRanges.withRanges(new int[] {
0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B,
0x1C, 0x1D, 0x21, 0x24 });
CharRanges empty = CharRanges.withMembers(new int[0]);
CharRanges a = CharRanges.withRanges(new int[] {
0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B });
CharRanges b = CharRanges.withRanges(new int[] {
0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B,
0x1C, 0x1D, 0x21, 0x24 });
CharRanges empty = CharRanges.withMembers(new int[0]);if (fnNameNode.isName()) {
String s = fnNameNode.getString();
if (s != null && !s.isEmpty()) {
return s;
if (fnDoc.isConstructor()) {
TypeCheck.NOT_A_CONSTRUCTOR,
expr, TypeCheck.NOT_A_CONSTRUCTOR, funType.toString()));
return n.getFirstChild();
TypeCheck.NOT_A_CONSTRUCTOR);new PassFactory("crossModuleCodeMotion", false) {
lastAst = jsRoot.cloneTree();
mtoc = NodeUtil.mapMainToClone(jsRoot, lastAst);
setSanityCheckState();eatId(); // module
eatId(); // from
nextToken(); // function
nextToken(); // function
eatId(); // get
eatId(); // setPreconditions.checkArgument(funNode.isFunction(),
"TODO(blickly): Support typical function jsdoc without initializer");RawNominalType rawType = currentScope.getLocalNominalType(ctorName);
if (rawType == null) {
return;
RawNominalType classType = currentScope.getLocalNominalType(ctorName);
rawNominalType.addClassProperty(pname, declaredType);
rawNominalType.addUndeclaredClassProperty(pname);
warnings.add(JSError.make(
fn, INHERITANCE_CYCLE, rawNominalType.toString()));
boolean noCycles = rawNominalType.addInterfaces(
fnDoc, ownerType, parentScope, typeParameters));
private RawNominalType getLocalNominalType(String name) {
return localClassDefs.get(name);
JSType initType;
if (declType == null) {
initType = envGetType(entryEnv, name);
declType.getFunTypeIfSingletonObj().isConstructor()) {
initType =
declType.getFunTypeIfSingletonObj().createConstructorObject();
initType = declType;
if (declType == null) {
env = envPutType(env, varName, JSType.UNKNOWN);
env = envPutType(env, varName, declType);
if (propAccessNode.isGetProp()) {
if (mayWarnAboutDictPropAccess(receiver, recvType)) {
return new EnvTypePair(pair.env, requiredType);
Node parent = obj.getParent();if (this.isLoose || obj2.isLoose) {
return this.isLooseSubtypeOf(obj2);
for (String pname : obj2.props.keySet()) {
if (props.containsKey(pname)) {
if (!props.get(pname).getType()
.isSubtypeOf(obj2.props.get(pname).getType())) {
this.isLoose || other.isLoose,pair.type = JSType.UNKNOWN; // No deferred check needed.
pair.type = JSType.UNKNOWN; // No deferred check needed.
argTypes.add(pair.type);
dc = new DeferredCheck(
expr, currentScope, currentScope.getScope(calleeName));
dc.updateReturn(JSType.UNKNOWN);
EnvTypePair pair = analyzeExprFwd(index, inEnv);
JSType objWithProp = JSType.TOP_OBJECT.withProperty(propQname, requiredType);
boolean isNotAnObject =
JSType.BOTTOM.equals(JSType.meet(recvType, JSType.TOP_OBJECT));
boolean mayNotBeAnObject = !recvType.isSubtypeOf(JSType.TOP_OBJECT);
if (isNotAnObject ||
(!specializedType.isTruthy() && !specializedType.isFalsy() &&
mayNotBeAnObject)) {
warnings.add(JSError.make(
receiver, PROPERTY_ACCESS_ON_NONOBJECT, pname, recvType.toString()));
EnvTypePair pair = analyzeExprBwd(index, outEnv);
JSType expectedRetType = JSType.UNKNOWN;
DeferredCheck dc = new DeferredCheck(expr, currentScope, s);
dc.updateReturn(expectedRetType);
this.expectedRetType = this.expectedRetType != null ?
JSType.meet(this.expectedRetType, expectedRetType) : expectedRetType;
if (!fnSummary.getReturnType().isSubtypeOf(this.expectedRetType)) {
if (!argType.isSubtypeOf(formalType)) {n.removeChild(result);
foldSame("x = [foo()] && x");
fold("x = foo() && false || bar()", "x = foo()&&false||bar()");
fold("if(y() || x || 3) z()", "(y()||1)&&z()");
assertResultString("if(foo() && false) z()", "foo()&&0&&z()");Set<JSError> warnings = Sets.newHashSet();
if (!isInterfaceMethodDef(fn) &&
private static boolean isInterfaceMethodDef(Scope methodScope) {
private Map<String, JSType> calcTypeInstantiation(
HashMap<String, JSType> typeMap = Maps.newHashMap();
typeMap.put(typeParam, JSType.UNKNOWN);
typeMap.put(typeParam, Iterables.getOnlyElement(types));
typeMap.put(typeParam, JSType.UNKNOWN);
return typeMap;
static final FunctionType BOTTOM_FUNCTION = FunctionType.normalized(
null, null, JSType.TOP, JSType.BOTTOM, null, null, null, false);
public boolean isBottomFunction() {
return this.equals(BOTTOM_FUNCTION);
return f2;
Preconditions.checkState(loose == false);
typeMultimap.remove(typeParam, other);
if (typeName.equals("boolean")) {
return JSType.BOOLEAN;
return JSType.NULL;
return JSType.NUMBER;
return JSType.STRING;
return JSType.UNDEFINED;
return JSType.fromTypeVar(typeName);
JSType namedType = registry.lookupTypeByName(typeName);
if (namedType == null) {
unknownTypeNames.put(n, typeName);
throw new UnknownTypeException("Unhandled type: " + typeName);
if (namedType.isTypeVariable()) {
return namedType;
return JSType.join(JSType.NULL, getNominalTypeHelper(
namedType, n, ownerType, registry, outerTypeParameters));
if (jsdocNode.getType() == Token.FUNCTION) {
import static com.google.javascript.jscomp.newtypes.FunctionType.BOTTOM_FUNCTION;
assertEquals(BOTTOM_FUNCTION,
FunctionType.meet(BOTTOM_FUNCTION, numToNum));
assertEquals(numToNum, FunctionType.join(BOTTOM_FUNCTION, numToNum));import com.google.javascript.rhino.IR;
Node switchedExp = n.getParent().getFirstChild().cloneTree();
Node syntheticSheq = IR.sheq(
switchedExp, n.getFirstChild().cloneTree());
analyzeConditionalStmFwd(n, syntheticSheq, inEnv);
case Token.SHNE: {
Node lhs = expr.getFirstChild();
Node rhs = expr.getLastChild();
if ((specializedType.isTruthy() || specializedType.isFalsy()) &&
(lhs.isTypeOf() || rhs.isTypeOf())) {
if (lhs.isTypeOf()) {
return analyzeSpecializedTypeof(
lhs, rhs, exprKind, inEnv, specializedType);
return analyzeSpecializedTypeof(
rhs, lhs, exprKind, inEnv, specializedType);
EnvTypePair lhsPair = analyzeExprFwd(lhs, inEnv);
EnvTypePair rhsPair = analyzeExprFwd(rhs, lhsPair.env);
if ((exprKind == Token.SHEQ && specializedType.isTruthy()) ||
(exprKind == Token.SHNE && specializedType.isFalsy())) {
JSType meetType = JSType.meet(lhsPair.type, rhsPair.type);
lhsPair = analyzeExprFwd(lhs, rhsPair.env, JSType.UNKNOWN, meetType);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, meetType);
(exprKind == Token.SHNE && specializedType.isTruthy())) {
JSType lhsType = lhsPair.type;
JSType rhsType = rhsPair.type;
if (lhsType.equals(JSType.NULL) ||
lhsType.equals(JSType.UNDEFINED)) {
rhsType = rhsType.removeType(lhsType);
rhsType.equals(JSType.UNDEFINED)) {
lhsType = lhsType.removeType(rhsType);
lhsPair = analyzeExprFwd(lhs, rhsPair.env, JSType.UNKNOWN, lhsType);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, rhsType);
rhsPair.type = JSType.BOOLEAN;
return rhsPair;
Preconditions.checkState(!other.isGeneric()); // TODO(user): implement it
Preconditions.checkState(!this.isGeneric()); // This should never happen.
private FunctionType applyInstantiation(Map<String, JSType> typeMap) {
Preconditions.checkState(typeParameters == null);
return applyInstantiation(concreteTypes);
return applyInstantiation(typeMap);
uninstantiated));
if (!typeMap.containsKey(newKey) &&
rawType.typeParameters.contains(newKey)) {
if (nominalType != other.nominalType) {if (!JSType.UNDEFINED.isSubtypeOf(declRetType) &&
return nominalType != null;
if (restFormals != null &&
!restFormals.unifyWith(other.restFormals, typeParameters, typeMultimap)) {
Preconditions.checkState(fieldTypeNode.getType() == Token.COLON);
Node fieldNameNode = fieldTypeNode.getFirstChild();
JSType fieldType = getTypeFromNodeHelper(
fieldTypeNode.getLastChild(), ownerType, registry, typeParameters);
Preconditions.checkState(
typeMap.keySet().containsAll(newTypeMap.keySet()));LAST_PROP          = 63;    // Unused in the compiler, but keep for Rhino.
"/** @const */ var Hello = require('./i0');" +
"/** @const */ var Hello = require('./i0');" +
"/** @const */ var Hello = require('./i0');" +
"/** @const */ var Hello = require('./i0');" +closestPreviousComment = currentComment;
return (closestPreviousComment != null
&& closestPreviousComment.type == Comment.Type.JSDOC)
? closestPreviousComment : null;
private Node transformAsString(
ret = newStringNode(Token.STRING,
normalizeString(token.asLiteral()));
node = newStringNode(Token.STRING, identifierToken.toString());
node = newStringNode(Token.NAME, identifierToken.toString());
Node key = transformAsString(tree.propertyName);
Node key = transformAsString(tree.propertyName);
Node key = transformAsString(tree.name);
Node rightChild = transformAsString(nodeProp);
String value = normalizeString(token);
Node n = newStringNode(value);
return new Node(Token.CLASS, name, superClass, body);
return new Node(Token.SUPER);
abstract T processForOf(ForOfStatementTree tree);
case MODULE_DEFINITION:
case EXPORT_DECLARATION:
case IMPORT_DECLARATION:
case IMPORT_SPECIFIER:
return unsupportedLanguageFeature(node, "modules");
case MODULE_DEFINITION:
|| sourceElement.type == ParseTreeType.MODULE_DEFINITION,
case MODULE_DEFINITION: visit(tree.asModuleDefinition()); break;
return parseImportDeclaration();
&& peek(2, TokenType.STRING);
ParseTree export;
case VAR:
case LET:
case CONST:
export = parseVariableStatement();
throw new RuntimeException("UNDONE: export ExportSpecifierSet");
export = null;
return new ExportDeclarationTree(getTreeLocation(start), isDefault, export);
case MODULE_DEFINITION: return transform(tree.asModuleDefinition());
return new ExportDeclarationTree(null, tree.isDefault, declaration);
ParseTree declaration) {
super(ParseTreeType.MODULE_DEFINITION, location);
public ModuleImportTree asModuleDefinition() { return (ModuleImportTree) this; }
MODULE_DEFINITION,
IMPORT_DECLARATION,
LAST_PROP          = 61;    // Unused in the compiler, but keep for Rhino.
EXPORT         = 166,
MODULE         = 167,return JSType.join(
JSType.NULL, JSType.fromObjectType(ObjectType.fromClass(nominalType)));
return JSType.fromObjectType(ObjectType.fromClass(
looseFunctionType.getFunType().checkValid();
builder.addRestFormals(restFormals == null ? null : restFormals);
public void checkValid() {
return JSType.fromObjectType(ObjectType.fromClass(nominalType));
private Property getProp(String pname) {
private ObjectType(NominalType nominalType, ImmutableMap<String, Property> props,
FunctionType fn, boolean isLoose) {
public static ObjectType fromClass(NominalType cl) {
newProps.put(pname, props1.get(pname));
newProps.put(pname, specializeProps1 ?
Property.meet(props1.get(pname), prop2));
newProps.put(pname, prop2);
Preconditions.checkState(areRelatedClasses(this.nominalType, obj2.nominalType));
NominalType.pickSubclass(this.nominalType, obj2.nominalType),
meetPropsHelper(true, this.props, obj2.props),
Preconditions.checkState(areRelatedClasses(obj1.nominalType, obj2.nominalType));
NominalType.pickSubclass(obj1.nominalType, obj2.nominalType),
meetPropsHelper(false, obj1.props, obj2.props),
Preconditions.checkState(areRelatedClasses(obj1.nominalType, obj2.nominalType));
if (nominalType2 == null && nominalType1 != null && !obj1.isSubtypeOf(obj2) ||
nominalType1 == null && nominalType2 != null && !obj2.isSubtypeOf(obj1)) {
p = nominalType.getPropFromClass(objName);
ObjectType foo = ObjectType.fromClass(NominalType.makeClass("Foo", null));
ObjectType bar = ObjectType.fromClass(NominalType.makeClass("Bar", null));
ObjectType foo = ObjectType.fromClass(NominalType.makeClass("Foo", null));
ObjectType bar = ObjectType.fromClass(NominalType.makeClass("Bar", null));
ObjectType baz = ObjectType.fromClass(NominalType.makeClass("Baz", null));
ObjectType foo = ObjectType.fromClass(NominalType.makeClass("Foo", null));
ObjectType parent = ObjectType.fromClass(parentClass);
ObjectType child1 = ObjectType.fromClass(child1Class);
ObjectType child2 = ObjectType.fromClass(child2Class);if (c.isVar()) {
if (c.isFunction()) {
if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {
private boolean isOneExactlyFunctionOrDo(Node n) {
return isOneExactlyFunctionOrDo(labeledStatement);
return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
return (n.isFunction() || n.isDo());
es6LanguageFeature(functionTree, "generators");
es6LanguageFeature(functionTree, "member declarations");
es6LanguageFeature(functionTree, "short function syntax");
if (!config.acceptConstKeyword
&& decl.declarationType == TokenType.CONST) {
unsupportedLanguageFeature(decl, "const declarations");
unsupportedLanguageFeature(decl, "let declarations");
Node node = newNode(Token.VAR);
es6LanguageFeature(tree, "class");
es6LanguageFeature(tree, "super");
void es6LanguageFeature(ParseTree node, String feature) {
errorReporter.warning(
"this language feature is only supported in es6 mode: " + feature,
sourceName,
lineno(node), "", charno(node));
case FOR_OF_STATEMENT:
return unsupportedLanguageFeature(node, "for-of");
case FOR_OF_STATEMENT: visit(tree.asForEachStatement()); break;
checkInitializers(declarations);
reportError("const variables must have an initializer");
reportError("destructuring must have an initializer");
case FOR_OF_STATEMENT: return transform(tree.asForEachStatement());
public ForOfStatementTree asForEachStatement() { return (ForOfStatementTree) this; }
parseError("const x = 3;",
"unsupported language feature: const declarations");
parseError("let x = 3;", "unsupported language feature: let declarations");
parseError("function f() { let x = 3; };",
"unsupported language feature: let declarations");Preconditions.checkState(n.getParent().isObjectLit());
if (type == Token.GETTER_DEF) {
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add("get ");
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add("set ");
ECMASCRIPT5_STRICT;
if (value.equals("ECMASCRIPT5_STRICT") ||
tranformOrEmpty(loopNode.initializer),
tranformOrEmpty(loopNode.condition),
tranformOrEmpty(loopNode.increment));
Node tranformOrEmpty(ParseTree tree) {
if (!functionTree.isExpression) {
node.addChildToBack(newName);
return node;
case CLASS_DECLARATION:
case CLASS_EXPRESSION:
case SUPER_EXPRESSION:
return unsupportedLanguageFeature(node, "classes");
case FOR_OF_STATEMENT:
break;
if (!useExperimentalParser) {
case CLASS_EXPRESSION: visit(tree.asClassExpression()); break;
protected void visit(ClassExpressionTree tree) {
IdentifierToken name = eatId();
getTreeLocation(start), name, superClass, elements);
case FUNCTION:
case IDENTIFIER:
String value = token.asIdentifier().value;
switch (value) {
case "get":
case "set":
return peekId(1);
default:
return false;
if (peekFunction()) {
nextToken(); // function or #
return parseFunctionDeclarationTail(start, isStatic);
getTreeLocation(start), name, isStatic, false,
getTreeLocation(start), name, false, true,
reportError("for-each statement may not have more than one variable declaration");
reportError("for-each statement may not have initializer");
private ParseTree parseClassExpression() {
SourcePosition start = getTreeStartLocation();
eat(TokenType.CLASS);
return new ClassExpressionTree(getTreeLocation(start));
if (!token.asIdentifier().asIdentifier().value.equals(string)) {
return new ClassDeclarationTree(null, name, superClass, elements);
null, null, false, true, formalParameterList, functionBody);
null, name, false, false, formalParameterList, functionBody);
case CLASS_EXPRESSION: return transform(tree.asClassExpression());
protected ParseTree transform(ClassExpressionTree tree) {
return tree;
protected void visit(ClassExpressionTree tree) {
write(TokenType.CLASS);
package com.google.javascript.jscomp.parsing.parser.trees;
import com.google.javascript.jscomp.parsing.parser.util.SourceRange;
public class ClassExpressionTree extends ParseTree {
public ClassExpressionTree(SourceRange location) {
super(ParseTreeType.CLASS_EXPRESSION, location);
public final boolean isExpression;
boolean isStatic, boolean isExpression,
this.isExpression = isExpression;
public ClassExpressionTree asClassExpression() { return (ClassExpressionTree) this; }
case CLASS_EXPRESSION:
case CLASS_EXPRESSION:
CLASS_EXPRESSION,
LAST_PROP          = 57;    // Unused in the compiler, but keep for Rhino.
case STATIC_SOURCE_FILE:    return "source_file";
case INPUT_ID:  return "input_id";
case LENGTH:    return "length";
case SLASH_V:   return "slash_v";
case INFERRED_FUNCTION:   return "inferred";
case CHANGE_TIME: return "change_time";
case REFLECTED_OBJECT: return "reflected_object";
options.setLanguageIn(LanguageMode.ECMASCRIPT5);
assertPrintSame("var x={get function(){return 1}}");
assertPrintSame("var x={set function(x){}}");
assertPrint("x.function=2", "x[\"function\"]=2");
assertPrint("x={function:2}", "x={\"function\":2}");if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {
inferSlotType(symbol, inferredType);return tryFoldDo(subtree);
Node tryFoldDo(Node n) {Node irNode = irFactory.justTransform(tree);
irFactory.setSourceInfo(irNode, tree);
irFactory.setFileOverviewJsDoc(irNode);
return irNode;
if (node.type == ParseTreeType.EXPRESSION_STATEMENT) {
static final boolean ENABLE_TYPE_ANNOTATION_CHECKS = false;
private void validateTypeAnnotations(JSDocInfo info, ParseTree node) {
if (!ENABLE_TYPE_ANNOTATION_CHECKS) {
return;
if (info.hasType()) {
boolean valid = false;
switch (node.type) {
case PAREN_EXPRESSION:
valid = true;
break;
case VARIABLE_STATEMENT:
case VARIABLE_DECLARATION:
valid = true;
break;
case FUNCTION_DECLARATION:
valid = isFunctionDeclaration(node.asFunctionDeclaration());
break;
case IDENTIFIER_EXPRESSION:
ParseTree parent = getParent(node);
valid = parent.type == ParseTreeType.PROPERTY_NAME_ASSIGNMENT
|| parent.type == ParseTreeType.GET_ACCESSOR
|| parent.type == ParseTreeType.SET_ACCESSOR
|| parent.type == ParseTreeType.CATCH
|| parent.type == ParseTreeType.FUNCTION_DECLARATION
|| (parent.type == ParseTreeType.VARIABLE_DECLARATION &&
node == (parent.asVariableDeclaration()).lvalue);
break;
case PROPERTY_NAME_ASSIGNMENT:
valid = true;
break;
case BINARY_OPERATOR:
BinaryOperatorTree binop = node.asBinaryOperator();
if (binop.operator.type == TokenType.EQUAL) {
valid = isExpressionStatement(getParent(node))
&& isPropAccess(binop.left);
break;
case MEMBER_EXPRESSION:
case MEMBER_LOOKUP_EXPRESSION:
valid = isExpressionStatement(getParent(node));
break;
case CALL_EXPRESSION:
valid = info.isDefine();
break;
if (!valid) {
errorReporter.warning(MISPLACED_TYPE_ANNOTATION,
sourceName,
node.location.start.line, "", 0);
private boolean isExpressionStatement(ParseTree node) {
return node.type == ParseTreeType.EXPRESSION_STATEMENT;
private boolean isFunctionDeclaration(FunctionDeclarationTree node) {
return isStmtContainer(getParent(node));
private boolean isStmtContainer(ParseTree node) {
return node.type == ParseTreeType.BLOCK ||
node.type == ParseTreeType.PROGRAM;
private ParseTree getParent(ParseTree tree) {
Preconditions.checkNotNull(tree);
return null;
private static boolean isPropAccess(ParseTree node) {
return node.type == ParseTreeType.MEMBER_EXPRESSION
|| node.type == ParseTreeType.MEMBER_LOOKUP_EXPRESSION;
validateTypeAnnotations(info, tree);
switch (n.getType()) {
case Token.EXPR_RESULT:
attachJSDoc(info, n.getFirstChild());
break;
case Token.LABEL:
attachJSDoc(info, n.getLastChild());
break;
case Token.THROW:
case Token.RETURN:
case Token.IF:
case Token.DO:
case Token.FOR:
case Token.WHILE:
case Token.SWITCH:
case Token.CASE:
case Token.DEFAULT_CASE:
break;
default:
n.setJSDocInfo(info);
break;
private int lineno(com.google.javascript.jscomp.parsing.parser.Token token) {
return lineno(token.location.start);
private int charno(com.google.javascript.jscomp.parsing.parser.Token token) {
return charno(token.location.start);
Node processFunction(FunctionDeclarationTree functionNode) {
IdentifierToken name = functionNode.name;
Boolean isUnnamedFunction = false;
int functionType = functionNode.getFunctionType();
if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
functionNode.getLineno(), "", 0);
isUnnamedFunction = true;
newName.setLineno(lineno(functionNode));
newName.setCharno(charno(functionNode));
int lpColumn = functionNode.getAbsolutePosition() +
functionNode.getLp();
newName.setCharno(position2charno(lpColumn));
node.addChildToBack(transform(functionNode.formalParameterList));
Node bodyNode = transform(functionNode.functionBody);
int c = 2;
int c = 2;
int c = 2;
int c = 1;
location.line, sourceLine, location.offset);
location.line, sourceLine, location.offset);
getTreeLocation(start), name, isStatic, formalParameterList, functionBody);
getTreeLocation(start), name, false, formalParameterList, functionBody);
eatPossibleImplicitSemiColon();
return new FunctionDeclarationTree(null, null, false, formalParameterList, functionBody);
return new FunctionDeclarationTree(null, name, false, formalParameterList, functionBody);
boolean isStatic, FormalParameterListTree formalParameterList,
"};").getFirstChild();
assertNull(ret.getJSDocInfo());
"};").getFirstChild();
assertNull(ret.getJSDocInfo());
public void disable_testMisplacedTypeAnnotation1() {
public void disable_testMisplacedTypeAnnotation2() {
public void disable_testMisplacedTypeAnnotation3() {
public void disable_testMisplacedTypeAnnotation4() {
public void disable_testMisplacedTypeAnnotation5() {
public void disable_testMisplacedTypeAnnotation6() {associatedNode, config, errorReporter);
this.sourceFile = associatedNode == null
? null : associatedNode.getStaticSourceFile();
this.associatedNode != null ?
this.associatedNode.getStaticSourceFile() :
null);
import com.google.common.collect.ImmutableSet;
ErrorReporter errorReporter) {
public static Node transformTree(ProgramTree node,
config, errorReporter);
Node irNode = irFactory.transform(node);
if (node.sourceComments != null) {
for (Comment comment : node.sourceComments) {
irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);
newBlock.setLineno(irNode.getLineno());
newBlock.setCharno(irNode.getCharno());
maybeSetLengthFrom(newBlock, node);
private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
private Comment getJsDocNode(ParseTree tree) {
Preconditions.checkNotNull(tree);
return null;
private Comment getJsDocNode(
Preconditions.checkNotNull(token);
return null;
private JSDocInfo handleJsDoc(ParseTree node, Node irNode) {
Comment comment = getJsDocNode(node);
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
validateTypeAnnotations(info, node);
com.google.javascript.jscomp.parsing.parser.Token token, Node irNode) {
Comment comment = getJsDocNode(token);
if (comment != null) {
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
parsedComments.add(comment);
if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {
JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();
if (info != null) {
return info;
return null;
private Node transform(ParseTree node) {
Node irNode = justTransform(node);
JSDocInfo jsDocInfo = handleJsDoc(node, irNode);
if (jsDocInfo != null) {
irNode = maybeInjectCastNode(node, jsDocInfo, irNode);
irNode.setJSDocInfo(jsDocInfo);
setSourceInfo(irNode, node);
return irNode;
private Node transformNodeWithInlineJsDoc(ParseTree node) {
Comment comment = getJsDocNode(node);
if (comment != null) {
JSDocInfo info = parseInlineTypeDoc(comment, irNode);
if (info != null) {
irNode.setJSDocInfo(info);
double value = Double.valueOf(token.toString());
JSDocInfo jsDocInfo = handleJsDoc(token, irNode);
return node.location.start.line + 1;
return node.location.start.column;
return token.location.start.line + 1;
return token.location.start.column;
if (node.location == null || node.location.start == null) {
return;
int lineno = lineno(node);
irNode.setLineno(lineno);
int charno = charno(node);
irNode.setCharno(charno);
maybeSetLengthFrom(irNode, node);
if (irNode.getLineno() == -1) {
int lineno = lineno(token);
irNode.setLineno(lineno);
int charno = charno(token);
irNode.setCharno(charno);
maybeSetLengthFrom(irNode, token);
private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {
irNode,
private JSDocInfo parseInlineTypeDoc(Comment node, Node irNode) {
irNode,
private void maybeSetLengthFrom(Node node, ParseTree source) {
node.setLength(source.location.end.offset - source.location.start.offset);
private void maybeSetLengthFrom(Node node,
com.google.javascript.jscomp.parsing.parser.Token source) {
node.setLength(source.location.end.offset - source.location.start.offset);
ret = newStringNode(Token.STRING, token.asLiteral().toString());
newName = processName(name);
Node lp = newNode(Token.PARAM_LIST);
for (ParseTree param : functionNode.formalParameterList.parameters) {
Node paramNode = transformNodeWithInlineJsDoc(param);
Preconditions.checkState(paramNode.isName());
lp.addChildToBack(paramNode);
node.addChildToBack(lp);
Node node = newNode(Token.LABEL);
node.addChildToBack(transformLabelName(labelTree.name));
for (ParseTree arg : exprNode.arguments.arguments) {
node.addChildToBack(transform(arg));
double value = Double.valueOf(literalNode.literalToken.asLiteral().value);
Node key;
Node value;
switch (el.type) {
case PROPERTY_NAME_ASSIGNMENT: {
PropertyNameAssignmentTree prop = el.asPropertyNameAssignment();
key = transformAsString(prop.name);
key.setType(Token.STRING_KEY);
value = transform(prop.value);
break;
case GET_ACCESSOR: {
GetAccessorTree prop = el.asGetAccessor();
key = transformAsString(prop.propertyName);
key.setType(Token.GETTER_DEF);
Node body = transform(prop.body);
value = IR.function(IR.name(""), IR.paramList(), body);
break;
case SET_ACCESSOR: {
SetAccessorTree prop = el.asSetAccessor();
key = transformAsString(prop.propertyName);
key.setType(Token.SETTER_DEF);
Node body = transform(prop.body);
value = IR.function(IR.name(""), IR.paramList(
safeProcessName(prop.parameter)), body);
break;
default:
throw new IllegalStateException("Unexpected node type: " + el.type);
key.addChildToFront(value);
flags = rawRegex.substring(rawRegex.lastIndexOf('/'));
setSourceInfo(literalStringNode, token);
private String normalizeString(String value) {
StringBuilder result = new StringBuilder();
int start = 1; // skip the leading quote
int cur = value.indexOf('\\');
if (cur == -1) {
return value;
while (cur != -1) {
if (cur - start > 0) {
result.append(value.substring(start, cur));
cur += 1; // skip the escape char.
char c = value.charAt(cur);
switch (c) {
case '\'':
case '"':
case '\\':
result.append(c);
break;
case 'b':
result.append('\b');
break;
case 'f':
result.append('\f');
break;
case 'n':
result.append('\n');
break;
case 'r':
result.append('\r');
break;
case 't':
result.append('\t');
break;
case 'v':
result.append('\u000B');
break;
case '\n':
break;
case '0':
result.append('\0');
break;
case 'x':
result.append((char)(
hexdigit(value.charAt(cur + 1)) * 16
+ hexdigit(value.charAt(cur + 2))));
cur += 2;
break;
case 'u':
result.append((char)(
hexdigit(value.charAt(cur + 1)) * 16 * 16 * 16
+ hexdigit(value.charAt(cur + 2)) * 16 * 16
+ hexdigit(value.charAt(cur + 3)) * 16
+ hexdigit(value.charAt(cur + 4))));
cur += 4;
break;
default:
result.append(c);
break;
start = cur + 1;
cur = value.indexOf('\\', start);
result.append(value.substring(start, value.length() -1));
return result.toString();
int hexdigit(char c) {
switch (c) {
case '0': return 0;
case '1': return 1;
case '2': return 2;
case '3': return 3;
case '4': return 4;
case '5': return 5;
case '6': return 6;
case '7': return 7;
case '8': return 8;
case '9': return 9;
case 'a': case 'A': return 10;
case 'b': case 'B': return 11;
case 'c': case 'C': return 12;
case 'd': case 'D': return 13;
case 'e': case 'E': return 14;
case 'f': case 'F': return 15;
throw new IllegalStateException("unexpected: " + c);
block.setLineno(lineno(caseNode));
block.setCharno(charno(caseNode));
maybeSetLengthFrom(block, caseNode);
block.setLineno(lineno(caseNode));
block.setCharno(charno(caseNode));
maybeSetLengthFrom(block, caseNode);
if (lineSet == false) {
setSourceInfo(block, cc);
lineSet = true;
block.addChildToBack(transform(cc));
return processVariableDeclarationList(stmt.declarations);
node.addChildToBack(transform(child));
Node node;
Comment comment = getJsDocNode(decl.lvalue);
if (comment != null && !comment.value.contains("@")) {
node = transformNodeWithInlineJsDoc(decl.lvalue);
node = transform(decl.lvalue);
abstract T processArrayLiteral(ArrayLiteralExpressionTree arrayLiteralExpressionTree);
abstract T processAstRoot(ProgramTree programTree);
abstract T processBlock(BlockTree blockTree);
abstract T processCatchClause(CatchTree catchTree);
abstract T processConditionalExpression(ConditionalExpressionTree conditionalExpressionTree);
abstract T processContinueStatement(ContinueStatementTree continueStatementTree);
abstract T processDoLoop(DoWhileStatementTree doWhileStatementTree);
abstract T processElementGet(MemberLookupExpressionTree memberLookupExpressionTree);
abstract T processEmptyStatement(EmptyStatementTree emptyStatementTree);
abstract T processExpressionStatement(ExpressionStatementTree expressionStatementTree);
abstract T processForInLoop(ForInStatementTree forInStatementTree);
abstract T processForLoop(ForStatementTree forStatementTree);
abstract T processFunctionCall(CallExpressionTree callExpressionTree);
abstract T processFunction(FunctionDeclarationTree functionDeclarationTree);
abstract T processIfStatement(IfStatementTree ifStatementTree);
abstract T processBinaryExpression(BinaryOperatorTree binaryOperatorTree);
abstract T processLabeledStatement(LabelledStatementTree labelledStatementTree);
abstract T processName(IdentifierExpressionTree identifierExpressionTree);
abstract T processNewExpression(NewExpressionTree newExpressionTree);
abstract T processNumberLiteral(LiteralExpressionTree literalNode);
abstract T processObjectLiteral(ObjectLiteralExpressionTree objectLiteralExpressionTree);
abstract T processParenthesizedExpression(ParenExpressionTree parenExpressionTree);
abstract T processPropertyGet(MemberExpressionTree memberExpressionTree);
abstract T processRegExpLiteral(LiteralExpressionTree literalNode);
abstract T processReturnStatement(ReturnStatementTree returnStatementTree);
abstract T processStringLiteral(LiteralExpressionTree literalNode);
abstract T processSwitchCase(CaseClauseTree caseClauseTree);
abstract T processSwitchStatement(SwitchStatementTree switchStatementTree);
abstract T processThrowStatement(ThrowStatementTree throwStatementTree);
abstract T processTryStatement(TryStatementTree tryStatementTree);
abstract T processUnaryExpression(UnaryExpressionTree unaryExpressionTree);
abstract T processVariableStatement(VariableStatementTree variableStatementTree);
abstract T processVariableDeclarationList(VariableDeclarationListTree decl);
abstract T processWhileLoop(WhileStatementTree whileStatementTree);
abstract T processWithStatement(WithStatementTree withStatementTree);
abstract T processDebuggerStatement(DebuggerStatementTree asDebuggerStatement);
abstract T processThisExpression(ThisExpressionTree asThisExpression);
abstract T processSwitchDefault(DefaultClauseTree asDefaultClause);
abstract T processBooleanLiteral(LiteralExpressionTree literalNode);
abstract T processNullLiteral(LiteralExpressionTree literalNode);
break;
case GET_ACCESSOR:
break;
case PROPERTY_NAME_ASSIGNMENT:
break;
break;
eat(TokenType.OPEN_PAREN);
eat(TokenType.CLOSE_PAREN);
eat(TokenType.OPEN_PAREN);
eat(TokenType.CLOSE_PAREN);
return new FormalParameterListTree(null, result.build());
elements.add(NullTree.Instance);
private NullTree(SourceRange location) {
public void disable_testJSDocAttachment1() {
public void disable_testJSDocAttachment2() {
public void disable_testJSDocAttachment3() {
public void disable_testJSDocAttachment4() {
public void disable_testJSDocAttachment5() {
public void disable_testJSDocAttachment6() throws Exception {
public void disable_testJSDocAttachment7() {
public void disable_testJSDocAttachment8() {
public void disable_testJSDocAttachment9() {
public void disable_testJSDocAttachment10() {
public void disable_testJSDocAttachment11() {
public void disable_testJSDocAttachment12() {
public void disable_testJSDocAttachment13() {
public void disable_testJSDocAttachment14() {
public void disable_testJSDocAttachment15() {
public void disable_testJSDocAttachment16() {
public void disable_testJSDocAttachment17() {
public void disable_testJSDocAttachment18() {
public void disable_testJSDocAttachment19() {
public void disable_testJSDocAttachment20() {
public void disable_testInlineJSDocAttachment1() {
public void disable_testInlineJSDocAttachment2() {
public void disable_testInlineJSDocAttachment3() {
public void disable_testInlineJSDocAttachment4() {
public void disable_testInlineJSDocAttachment5() {
public void disable_testInlineJSDocAttachment6() {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {
public void disable_testSuspiciousBlockCommentWarning1() {
public void disable_testSuspiciousBlockCommentWarning2() {
public void disable_testSuspiciousBlockCommentWarning3() {
public void disable_testSuspiciousBlockCommentWarning4() {
public void disable_testSuspiciousBlockCommentWarning5() {
public void disable_testSuspiciousBlockCommentWarning6() {
public void disable_testSuspiciousBlockCommentWarning7() {
public void disable_testSuspiciousBlockCommentWarning8() {
public void disable_testFileOverviewJSDoc1() {
public void disable_testFileOverviewJSDoc2() {
public void disable_testParseBlockDescription() {if (root.isFunction()) {
return NodeUtil.getFunctionBody(root);
return root;
rhs.isVar() && rhsPair.type.isUnknown()) {
Node rhs = vdecl.getFirstChild();
TypeEnv env = inEnv;
if (rhs != null) {
env = analyzeExprFwd(rhs, inEnv).env;
envPutType(env, name, JSType.STRING), JSType.STRING);
Node rhs = vdecl.getFirstChild();
TypeEnv env = outEnv;
if (rhs != null) {
env = analyzeExprBwd(rhs, outEnv).env;
envPutType(env, name, JSType.UNKNOWN), JSType.UNKNOWN);
public boolean isTrue() {
return TRUE_MASK == type;
public boolean isFalse() {
return FALSE_MASK == type;if (allowLocalExports) {
compiler.report(t.makeError(n, EXPORT_ANNOTATION_NOT_ALLOWED));
compiler.report(t.makeError(n, NON_GLOBAL_ERROR));
public void testNonGlobalScopeExport() {if (propDef != null && propDef.methodScope != null) {
DeclaredFunctionType propDeclType =
propDef.methodScope.getDeclaredType();
PropertyDef inheritedPropDef = propertyDefs.get(superClass, pname);
propDeclType = propDeclType.withTypeInfoFromSuper(
inheritedPropDef.methodScope.getDeclaredType());
propDef.methodScope.setDeclaredType(propDeclType);
Scope ctorScope = currentScope.getScope(ctorName);
NominalType classType = ctorScope.getDeclaredType().getClassType();
Scope ctorScope = currentScope.getScope(ctorName);
NominalType classType = ctorScope.getDeclaredType().getClassType();
public JSType getNamedTypeByName(String name) {
NominalType klass = localClassDefs.get(name);
if (parent != null) {
return parent.getNamedTypeByName(name);
if (formalType != null) {
if (formalIndex < reqArity) {
builder.addReqFormal(formalType);
builder.addOptFormal(formalType);
builder.addReqFormal(formalType.withLocation(null));
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()));
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()));
import com.google.common.base.Preconditions;
Preconditions.checkState(restFormals != null);
JSType getNamedTypeByName(String name);
JSType namedType = registry.getNamedTypeByName(typeName);
Preconditions.checkState(wrappedClass != null);
Preconditions.checkState(p != null);+ "If the number given is less than 1, the driver will run until "
+ "first error (either in Fuzzer or Compiler) is found. "
+ "Default: 1")
private int numberOfRuns = 1;
File file = new File(configFileName);
try {
return new JSONObject(Files.toString(
file, StandardCharsets.UTF_8));
e.printStackTrace();
return null;
return numberOfRuns < 1;
if (result.success && result.warnings.length == 0) {
getLogger().info("Compilation Succeeded!");
getLogger().info(debugInfo);
getLogger().warning("Compilation Failed!");
getLogger().info(debugInfo);
getLogger().log(Level.SEVERE, "Compiler error!\n", e);
getLogger().warning(debugInfo);
lines1[1].trim().startsWith("throw") &&
lines2[1].trim().startsWith("throw")) {
name = scopeManager.getRandomSymbol(true).name;
new Symbol("JSON", Type.FUNCTION),
if (symbol != null && localSymbols().remove(symbol)) {
numSym--;
if (excludeLocal && localSymbols().indexOf(sym) != -1) {JSType restrictedParameter = iParameterType
if (restrictedParameter != null) {
if (iArgument.isFunction() &&
iArgumentType.isFunctionType() &&
iArgument.getJSDocInfo() == null) {
iArgument.setJSType(restrictedParameter);
if(!seenTypes.contains(paramType)) {
"f(function(g) { });\n",
"   function(item,index,src) {out = item;});",sb.append(Fuzzer.getPrettyCode(script));
logger.info(sb.toString());
sb.append(Fuzzer.getPrettyCode(script));
sb.append(Fuzzer.getPrettyCode(script));
import java.util.Stack;
Stack<String> currentLabels = scopeManager.localScope().labels;
Stack<String> currentLabels = scopeManager.localScope().labels;
Stack<String> currentLabels = scopeManager.localScope().labels;
currentLabels.push(labelName);
currentLabels.pop();
scopeManager.addScope();
scopeManager.addScope();
import java.util.Stack;
Stack<String> labels = new Stack<String>();
import java.util.Stack;
private Stack<Scope> scopeStack = new Stack<Scope>();
public void addScope() {
ArrayList<Scope> scopes = new ArrayList<Scope>(getNumScopes());
Scope s = scopeStack.get(i);
scopes.add(s);
Scope s = scopeStack.get(i);
scopes.add(s);
Random random = new Random(System.currentTimeMillis());
Random random = new Random();
Random random = new Random();
Random random = new Random();
Random random = new Random();
scope.labels.push("testLabel");
scope.labels.push("testLabel");import java.util.Map;
public DiscreteDistribution(Random random, Map<T, Double> pmf) {
items = new ArrayList<T>(pmf.size());
weights = new ArrayList<Double>(pmf.size());
for (T item : pmf.keySet()) {
double p = pmf.get(item);
Preconditions.checkArgument(p >= 0);
Preconditions.checkArgument(!Double.isInfinite(p));
Preconditions.checkArgument(!Double.isNaN(p));
weights.add(p);
sum += p;
items.add(item);
for (int i = 0; i < pmf.size(); i++) {
import java.util.ArrayList;
public Compiler compile(String code) {
compiler.compile(Arrays.asList(SourceFile.fromCode("[externs]", "")),
return compiler;
public Compiler compile(Node script) {
compiler.compileModules(
new ArrayList<SourceFile>(), Arrays.asList(jsModule), getOptions());
return compiler;
public static void main(String[] args) {
Compiler compiler = driver.compile(script);
Result result = compiler.getResult();
System.out.println("Success!\n");
import com.google.common.collect.Maps;
import java.util.Map;
symbolTable.addScope();
Map<Expression, Double> pmf = Maps.newHashMap();
pmf.put(expr, expr.weight);
new DiscreteDistribution<Expression>(random, pmf);
Map<Statement, Double> pmf = Maps.newHashMap();
pmf.put(stmt, stmt.weight);
new DiscreteDistribution<Statement>(random, pmf);
import java.util.HashMap;
private int size = 0;
storage.push(new ArrayList<String>());
HashMap<List<String>, Double> pmf = new HashMap<List<String>, Double>();
List<String> scope = storage.get(i);
pmf.put(scope, Double.valueOf(scope.size()));
List<String> scope = storage.get(i);
pmf.put(scope, Double.valueOf(scope.size()));
new DiscreteDistribution<List<String>>(random, pmf);
Fuzzer fuzzer = spy(new Fuzzer(new Random()));import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Token;
Node getScript(Node root) {
return getScript(new Node[]{root});
Node getScript(Node[] elements) {
Node script = new Node(Token.SCRIPT, elements);
InputId inputId = new InputId("fuzzedInput");
script.setInputId(inputId);
script.setSourceFileForTesting(inputId.getIdName());
return script;
Node script = driver.getScript(nodes);
symbolTable.removeScope();
functionNesting--;
int numElements = random.nextInt(budget) + 1;
verify(fuzzer).generateLiteral(budget);templateTypeNames = ImmutableList.of();
prototypeOwnerTypeMap =
prototypeOwner.getTypeOfThis().getTemplateTypeMap();"accessing name {0} in externs has no effect");add("catch(");
add("for(");
add("for(");
add("while(");
add("while(");
add("if(");
"if(1) {\n" +
"if(1) {\n" +
"  alert(\"\")\n" +
"if(1) {\n" +
"  alert(\"\")\n" +
"if(1) {\n" +
"  alert()\n" +
"label:alert();\n");
"if(1) {\n" +
"  alert()\n" +
"for(;;) {\n" +
"  alert()\n" +
"while(1) {\n" +
"  alert()\n" +
"if(1) {\n" +
"}else {\n  alert(a)\n}\n");
"if(1) {\n" +
"  alert(a)\n" +
"}else {\n" +
"  alert(b)\n" +
"for(;;) {\n" +
"  alert()\n" +
"for(;;) {\n" +
"for(;;) {\n" +
"  alert()\n" +
"  alert()\n" +
"}while(true);\n");
"  alert()\n" +
"myLabel:for(;;) {\n" +
"  continue myLabel\n" +
"if(true) {\n" +
"  f()\n" +
"if(true) {\n" +
"  f()\n" +
"}else {\n" +
"  g()\n" +
"if(true) {\n" +
"  f()\n" +
"for(;;) {\n" +
"  g()\n" +
"}catch(e) {\n" +
"if(1) {\n" +
"  alert()\n" +
"}finally {\n" +
"if(1) {\n" +
"  alert()\n" +
"}catch(e) {\n" +
"}finally {\n" +
"if(1) {\n" +
"  alert()\n" +
"if(1) {\n" +
"  alert()\n" +
"if(1) {\n" +
"  alert()\n" +
"if(1) {\n" +
"  alert()\n" +
"  alert()\n" +
"if(1) {\n" +
"  alert()\n" +
+ "a.Foo.prototype.foo = function(foo) {\n  return 3\n};\n"
"  t1.prototype = t2.prototype\n};\n"Node obj = lvalue.getFirstChild();
JSType objType = getJSType(obj);
String pname = prop.getString();
if (!objType.isStruct() || objType.hasProperty(pname)) {
return;
Scope s = t.getScope();
if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {
return;
Node assgnExp = lvalue.getParent();
Node assgnStm = assgnExp.getParent();
if (objType instanceof ObjectType &&
s.isGlobal() &&
NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {
ObjectType instance =
objType.toObjectType().getOwnerFunction().getInstanceType();
String file = lvalue.getSourceFileName();
Node ctor = instance.getConstructor().getSource();
if (ctor != null && ctor.getSourceFileName().equals(file)) {
JSType rvalueType = assgnExp.getLastChild().getJSType();
instance.defineInferredProperty(pname, rvalueType, lvalue);
return;
report(t, prop, ILLEGAL_PROPERTY_CREATION);
if (!(obj.isThis() &&
getJSType(syntacticScope.getRootNode()).isConstructor())) {
return;
getJSType(syntacticScope.getRootNode()).isConstructor()) {String value = comment.getValue();
if (value.indexOf("/* @") != -1 ||
value.indexOf("\n * @") != -1) {if (num == num && num != 0.0) {
return d == d && d != 0.0;
return (d == d && d != 0.0);
if (d == d) {
if (d != d || Double.isInfinite(d)) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (t == t) {
if (year != year || Double.isInfinite(year)) {
if (t != t) {
if (date == date) {
if (d != d ||
if (d != d || Double.isInfinite(d)) {
if (date != date)
if (date != date) {
result = (d == d
result = (d != d);
if (d != d || ((mask = (int) d) != d) ||
if (d == d && d != Double.POSITIVE_INFINITY &&
if (x == x && -1.0 <= x && x <= 1.0) {
if (d != d) {
if (x == x && x != Double.POSITIVE_INFINITY
if (y != y) {
if (result != result) {
if (end != end || end > target.length())
if (x != x) {
return (d == d && d != 0.0);
if (d != d)
if (d != d)
if (d != d
if (d != d
if (d != d
return d == d;if (!noSideEffectFunctionNames.contains(lValue) &&
definitionTypeContainsFunctionType(def)) {
return;
node.setSideEffectFlags(Node.NO_SIDE_EFFECTS);
public void testAddFunctionProperties1() throws Exception {
String source =
"/** @constructor */ function F() {}" +
"var x = new F();" +
"/** @this {F} */" +
"function g() { this.bar = function() { alert(3); }; }" +
"g.call(x);" +
"x.bar();";
String expected =
"var x = new function() {};" +
"/** @this {F} */" +
"(function () { this.bar = function() { alert(3); }; }).call(x);" +
"x.bar();";
CompilerOptions options = createCompilerOptions();
CompilationLevel.ADVANCED_OPTIMIZATIONS
.setOptionsForCompilationLevel(options);
options.setRenamingPolicy(
VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);
test(options, source, expected);
public void testAddFunctionProperties2() throws Exception {
String source =
"/** @constructor */ function F() {}" +
"var x = new F();" +
"/** @this {F} */" +
"function g(y) { y.bar = function() { alert(3); }; }" +
"g(x);" +
"x.bar();";
String expected =
"var x = new function() {};" +
"/** @this {F} */" +
"(function (y) { y.bar = function() { alert(3); }; })(x);" +
"x.bar();";
CompilerOptions options = createCompilerOptions();
CompilationLevel.ADVANCED_OPTIMIZATIONS
.setOptionsForCompilationLevel(options);
options.setRenamingPolicy(
VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);
test(options, source, expected);
ImmutableList.<String>of("externObjSEThis"));
ImmutableList.<String>of());flags.setMutatesThis();
Node objectNode = getCallThisObject(callSite);
&& !isCallOrApply(callSite)) {
&& !isCallOrApply(callSite)) {
private static Node getCallThisObject(Node callSite) {
Node callTarget = callSite.getFirstChild();
if (!NodeUtil.isGet(callTarget)) {
return null;
String propString = callTarget.getLastChild().getString();
if (propString.equals("call") || propString.equals("apply")) {
return callTarget.getNext();
return callTarget.getFirstChild();
Node callTarget = callSite.getFirstChild();
if (NodeUtil.isGet(callTarget)) {
String propString = callTarget.getLastChild().getString();
if (propString.equals("call") || propString.equals("apply")) {
return true;
return false;
public void setAllFlags() {
public void clearAllFlags() {
public void setMutatesGlobalState() {
public void setThrows() {
public void setMutatesThis() {
public void setMutatesArguments() {
public void setReturnsTainted() {Node assgnStm = lvalue.getParent().getParent();if (NodeUtil.hasFinally(n)) {
Node finallyBlock = n.getLastChild();
tryMinimizeExits(finallyBlock, exitType, labelName);
fold("function f(){try{return;}catch(e){return;}finally{return}}",
"function f(){try{}catch(e){}finally{}}");
fold("function f(){try{return;}finally{return;}}",
"function f(){try{}finally{}}");
fold("function f(){try{g:if(a()){} return;}finally{return}}",
"function f(){try{g:if(a()){}}finally{}}");Node target = entry.getTarget();
target.getParent().addChildAfter(statement, target);break;
break;
break;
break;+ "/* @param {Function} childCtor Child class.\n"
+ "/** @param {function()} f \n@param {number} */\n"
"foo((/** @type {function(string)} */" +
"function(baz) { var f = baz; }))\n");if (n.isSyntheticBlock() ||  n.getParent() == null) {
typeMap = ImmutableMap.of(
replacePlaceHolders(
com.google.javascript.rhino.head.ScriptRuntime
.getMessage0("msg.extra.trailing.comma")),
TRAILING_COMMA,
replacePlaceHolders(
com.google.javascript.rhino.head.ScriptRuntime
.getMessage0("msg.dup.parms")),
DUPLICATE_PARAM,
replacePlaceHolders(ScriptRuntime.getMessage0("msg.bad.jsdoc.tag")),
BAD_JSDOC_ANNOTATION,
Pattern.compile("^Type annotations are not allowed here.*"),
MISPLACED_TYPE_ANNOTATION,
Pattern.compile("^Bad type annotation.*"),
TYPE_PARSE_ERROR
);
for (Entry<Pattern, DiagnosticType> entry : typeMap.entrySet()) {
if (entry.getKey().matcher(message).matches()) {
return JSError.make(
sourceName, line, lineOffset, entry.getValue(), message);expected += "var n = new b(); n.argz();";
expected += letter + "(n);";options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,
CheckLevel.OFF);
options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,
CheckLevel.OFF);
options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,
CheckLevel.WARNING);
public void setExtraAnnotationNames(Set<String> extraAnnotationNames) {
this.extraAnnotationNames = Sets.newHashSet(extraAnnotationNames);import com.google.javascript.jscomp.graph.GraphReachability;
cfa.process(null, scope.getRootNode());
Node root = scope.getRootNode();
NodeTraversal.traverse(
compiler, root, new EliminationPass(cfg));
if (parent == null) {
return;
if (n.isFunction() || n.isScript()) {
private Node tryRemoveUnconditionalBranching(Node n) {
return n;
return n;
List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
removeDeadExprStatementSafely(n);
return fallThrough;
return n;
if (n.isEmpty() ||
(n.isBlock() && !n.hasChildren())) {
if (parent.isTry()) {
if (NodeUtil.isTryCatchNodeContainer(n)) {
return;
"try {var x = 1} finally {}");
public void testUnlessUnconditionalContinue() {
public void testUnlessUnconditonalBreak() {
public void testCascadedRemovalOfUnlessUnconditonalJumps() {
"switch (a) { case 'a': break; case 'b': case 'c': }");
test("switch (a) { case 'a': break; case 'b': case 'c': }",
"switch (a) { case 'a': case 'b': case 'c': }");
"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}",
"function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}");
test("function foo() {" +
"  switch (a) { case 'a':return; case 'b': case 'c': }}",
"function foo() { switch (a) { case 'a': case 'b': case 'c': }}");
testSame("function foo() {" +
"switch (a) { case 'a':return 2; case 'b':return 1}}");reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString());
reportWarning(RESOLVED_TAG_EMPTY, "@extends", fnName);
reportWarning(CONSTRUCTOR_REQUIRED, "@struct", fnName);
reportWarning(CONSTRUCTOR_REQUIRED, "@dict", fnName);
reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);
TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);
reportWarning(CONSTRUCTOR_REQUIRED, "@implements", fnName);
reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
reportWarning(TYPE_REDEFINITION, fnName,token == JsDocToken.PIPE) {return this.wrapsSameRawType(thatType)
&& (thisParameter.isSubtype(thatParameter)
|| thatParameter.isSubtype(thisParameter));
return this.getReferencedTypeInternal().isSubtype(thatType);visitObjLitKey(t, key, n);
private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {
testTypes("(/** @dict */ {x: 123}).x = 321;",.withReturnType(getReturnType());
.withReturnType(isCall ? getReturnType() : getBindReturnType(-1));thisTypeNode.setOptionalArg(isCall);if (lastStm.isBreak()) {return this.isSubtype(
return this.isSubtype(
FunctionType ctor = toObjectType().getConstructor();
return this.toMaybeUnionType().checkUnionEquivalenceHelper(
return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(
return this.toMaybeRecordType().checkRecordEquivalenceHelper(
if (this.isSubtype(that)) {
return true;
return false;
return this.testForEquality(that).equals(UNKNOWN);
return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
switch (this.testForEquality(that)) {
switch (this.testForEquality(that)) {
if (this.isNullType() && that.isNullType() ||
this.isVoidType() && that.isVoidType()) {
return "{" + this.hashCode() + "}";
boolean result = defineProperty(propertyName, type, false,
propertyNode);
this.isFunctionType() ?
return thatObj != null && this.isImplicitPrototype(thatObj);String moduleName = guessCJSModuleName(normalizeSourceName(script
.getSourceFileName()));import java.io.File;
public static final String DEFAULT_FILENAME_PREFIX = "." + File.separator;
this.filenamePrefix = filenamePrefix.endsWith(File.separator) ?
filenamePrefix : filenamePrefix + File.separator;
filename.replaceAll("^\\." + Pattern.quote(File.separator), "")
.replaceAll(Pattern.quote(File.separator), MODULE_NAME_SEPARATOR)
if (requiredFilename.startsWith("." + File.separator) ||
requiredFilename.startsWith(".." + File.separator)) {return;
testTypes("function f() {}" +
testTypes("function f() {}" +
testTypes("function f() {}" +
testTypes("function f() {}" +
testTypes("function f() {}" +
testTypes("function f() {}" +if (merged != null &&
((leftIsRefineable && merged.typeA != null) ||
(rightIsRefineable && merged.typeB != null))) {
FlowScope informed = blindScope.createChildFlowScope();
if (leftIsRefineable && merged.typeA != null) {
declareNameInScope(informed, left, merged.typeA);
if (rightIsRefineable && merged.typeB != null) {
declareNameInScope(informed, right, merged.typeB);
return informed;
leftType = (leftType == null) ? null :
if (leftType == null) {
rightType = (rightType == null) ? null :
if ((leftType != null && leftIsRefineable) ||
(rightType != null && rightIsRefineable)) {
FlowScope informed = blindScope.createChildFlowScope();
if (leftIsRefineable && leftType != null) {
declareNameInScope(informed, left, leftType);
if (rightIsRefineable && rightType != null) {
declareNameInScope(informed, right, rightType);
return informed;
JSType restrictedType =
type.getRestrictedTypeGivenToBooleanOutcome(outcome);
FlowScope informed = blindScope.createChildFlowScope();
declareNameInScope(informed, name, restrictedType);
return informed;
JSType restrictedType =
getRestrictedByTypeOfResult(type, value, resultEqualsValue);
if (restrictedType == null) {
return blindScope;
FlowScope informed = blindScope.createChildFlowScope();
declareNameInScope(informed, node, restrictedType);
return informed;
JSType restrictedLeftType = leftType.visit(visitor);
if (restrictedLeftType != null && !restrictedLeftType.equals(leftType)) {
FlowScope informed = blindScope.createChildFlowScope();
declareNameInScope(informed, left, restrictedLeftType);
return informed;
return blindScope;
public void testMissingProperty20() throws Exception {
testTypes(
"/** @param {Object} x */" +
"function f(x) { if (x.foo) { } else { x.foo(); } }");
"function f(x) { if (x.foo) { } else { x.foo(); } }");
assertTypeEquals(UNKNOWN_TYPE,private final Node aliasReference;
private final String correctedType;
AliasedTypeNode(Node aliasReference, String correctedType) {
this.aliasReference = aliasReference;
this.correctedType = correctedType;
aliasReference.setString(correctedType);
aliasUsages.add(new AliasedTypeNode(typeNode,
aliasedNode.getQualifiedName() + name.substring(endIndex)));if (rValue.getJSType() != nullif (value != null) {if ((long) x == x && !negativeZero) {
addConstant(Long.toString(value));
addConstant(String.valueOf(x));
assertPrintNumber("1.0E-6", 0.000001);
assertPrint("var x = -0.0;", "var x=-0.0");
assertPrint("x- -0", "x- -0.0");childCtor, childCtor.getSource());
"function (new:derived): undefined");
"function (new:derived): undefined");if (parent.isVar()) {
if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
String name = n.getString();
Var aliasVar = scope.getVar(name);
aliases.put(name, aliasVar);
String qualifiedName =
aliasVar.getInitialValue().getQualifiedName();
transformation.addAlias(name, qualifiedName);
report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
"/** @param {Foo.Bar} x */ function actual(x) {3}" +
"/** @param {foo.Foo.Bar} x */ function expected(x) {}",
"/** @param {foo.Foo.Bar} x */ function actual(x) {3}" +
"/** @param {foo.Foo.Bar} x */ function expected(x) {}");private static final int MASK_JAVADISPATCH  = 0x00010000; // @javadispath
public void matchConstraint(ObjectType contraint) {}
public void matchConstraint(ObjectType contraint) {
referencedType.matchConstraint(contraint);if (!alt.getGreatestSubtype(type).isEmptyType()) {
RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {
defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());
return registry.createRecordType(Collections.unmodifiableMap(properties));continue;
staleVars.add(v);
Reference declaration = referenceInfo.references.get(0);
Reference init = referenceInfo.getInitializingReference();
splitObject(v, declaration, init, referenceInfo);
"var JSCompiler_object_inline_a_0;" +
"var JSCompiler_object_inline_b_1;" +
"var JSCompiler_object_inline_c_2;" +
"var b=f();" +
"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b," +
"  JSCompiler_object_inline_c_2=void 0,true;" +
"if(JSCompiler_object_inline_a_0) " +
"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2");
"var JSCompiler_object_inline_x_0;" +
"var JSCompiler_object_inline_y_1;" +
"var JSCompiler_object_inline_y2_2;" +
"JSCompiler_object_inline_x_0=1," +
"JSCompiler_object_inline_y_1=2," +
"JSCompiler_object_inline_y2_2=void 0," +
"true;" +
"f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y2_2);");
"var JSCompiler_object_inline_x_0;" +
"var JSCompiler_object_inline_y_1;" +
"for(;1;) {" +
" f(JSCompiler_object_inline_x_0,JSCompiler_object_inline_y_1);" +
" JSCompiler_object_inline_x_0=1," +
" JSCompiler_object_inline_y_1=1," +
" true" +
"}");allowKeywordAsObjectPropertyName = false;
allowKeywordAsObjectPropertyName
= (languageVersion >= Context.VERSION_1_8);
public boolean isAllowKeywordAsObjectPropertyName() {
return allowKeywordAsObjectPropertyName;
public void setAllowKeywordAsObjectPropertyName(boolean flag) {
this.allowKeywordAsObjectPropertyName = flag;
env.setAllowKeywordAsObjectPropertyName(true);
private boolean allowKeywordAsObjectPropertyName;
!(compilerEnv.isAllowKeywordAsObjectPropertyName()
if ((peekToken() != Token.COLON
&& ("get".equals(propertyName)
|| "set".equals(propertyName))))
boolean allowKeywordsAsObjectLiteralsKeys = false;
allowKeywordsAsObjectLiteralsKeys = false;
allowKeywordsAsObjectLiteralsKeys = true;
allowKeywordsAsObjectLiteralsKeys = true;
allowKeywordsAsObjectLiteralsKeys = true;
CompilerEnvirons environment = new CompilerEnvirons();
environment.setReservedKeywordAsIdentifier(
allowKeywordsAsObjectLiteralsKeys);
CompilerEnvirons environment = new CompilerEnvirons();
compilerEnv.setAllowKeywordAsObjectPropertyName(acceptEs5);addInvalidatingType(mis.typeA);
addInvalidatingType(mis.typeB);
recordInvalidationError(mis.typeA, mis.src);
recordInvalidationError(mis.typeB, mis.src);
if (t.isUnionType()) {
for (JSType alt : t.toMaybeUnionType().getAlternates()) {
recordInvalidationError(alt, error);
return;
private void addInvalidatingType(JSType type) {
addInvalidatingType(alt);
addInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType());
StringBuilder sb = new StringBuilder();
printErrorLocations(sb, jsType);
if (sb.length() != 0) {
suggestion = "Consider fixing errors for the following types: ";
suggestion += sb.toString();
private void printErrorLocations(StringBuilder sb, JSType t) {
if (!t.isObject() || t.isAllType() || t.isUnionType()) {
printErrorLocations(sb, alt);
if(sb.length() != 0) {
sb.append(", ");
sb.append(t.toString());
sb.append(" at ");
sb.append(error.sourceName);
sb.append(":");
sb.append(error.lineNumber);
String js = "function addSingletonGetter(foo) { foo.foobar = 'a'; };";
Compiler compiler = new Compiler();
CompilerOptions options = new CompilerOptions();
compiler.init(ImmutableList.of(SourceFile.fromCode("externs", "")),
ImmutableList.of(SourceFile.fromCode("testcode", js)),
options);
Node root = compiler.parseInputs();
Node externsRoot = root.getFirstChild();
Node mainRoot = externsRoot.getNext();
getProcessor(compiler).process(externsRoot, mainRoot);
assertEquals(1, compiler.getErrors().length);
assertTrue(compiler.getErrors()[0].toString().contains("foobar"));traces.set(null);filename.replaceAll("^\\." + File.separator, "")
.replaceAll(File.separator, "\\$")"Parse error. Internet Explorer has a non-standard " +
"intepretation of trailing commas. Arrays will have the wrong " +
"length and objects will not parse at all.");
"getters are not supported in Internet Explorer",
"setters are not supported in Internet Explorer",
"getters are not supported in Internet Explorer " +
"Parse error. Internet Explorer has a non-standard " +
"intepretation of trailing commas. Arrays will have the wrong " +
"length and objects will not parse at all.";
"getters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"getters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");
"setters are not supported in Internet Explorer");JSType type = getJSType(assertedNode);
JSType narrowed = type.restrictByNotNullOrUndefined();
if (type != narrowed) {
callNode.setJSType(narrowed);
JSType narrowed = type.getGreatestSubtype(getNativeType(assertedType));
if (type != narrowed) {
if (assertedNodeName != null) {
scope = narrowScope(scope, assertedNode, narrowed);
callNode.setJSType(narrowed);
public void disable_testAssert8() { // Fails, out2 is UNKNOWNnew FindCallbackArgumentReferences(callbackFunction, 
"(function(){ jQuery.b = 1; })();" + 
"(function(){ jQuery.b = 1; })();" + 
setupCode + "(function(){ jQuery.a = 0;" + 
"jQuery.a=0;" + import java.util.StringTokenizer;
List<String> argsInFile = Lists.newArrayList();
StringTokenizer tokenizer = new StringTokenizer(
Files.toString(flagFileInput, Charset.defaultCharset()));
while (tokenizer.hasMoreTokens()) {
argsInFile.add(tokenizer.nextToken());(new NodeTraversal(compiler, this)).traverse(root);
if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
def.depends.add(jsScope.getVar(n.getString()));
inline("var x = a + b; print(x);      x = a - b; print(x)",
"var x;         print(a + b);             print(a - b)");
inline("var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)",
"var x; if (g) {           print(a + b)}             print(a - b)");
inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))");
inline("var y; var x = noSFX(Y), z = noSFX(); noSFX(); noSFX(), print(x)",
"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(Y))");(new JsFileParser(compiler.getErrorManager())).parseFile(
getName(), getName(), getCode());
boolean hasProvidesOrRequires = false;
hasProvidesOrRequires = true;
return !shortcutMode || hasProvidesOrRequires ||
"var includeFileWithoutProvides = 1;"
final String CONTENTS = "/*"
DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,
DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);
assertEquals(EXPECTED, result);
assertEquals(0, errorManager.getErrorCount());
assertEquals(0, errorManager.getWarningCount());
final String CONTENTS = "goog.provide('yes1');goog.provide('yes2');/*"
DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,
DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);
assertEquals(EXPECTED, result);
assertEquals(0, errorManager.getErrorCount());
assertEquals(0, errorManager.getWarningCount());
final String CONTENTS = " // hi ! \n /* this is a comment */ "
DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,
DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);
assertEquals(EXPECTED, result);
assertEquals(0, errorManager.getErrorCount());
assertEquals(0, errorManager.getWarningCount());
final String CONTENTS = "/** goog.provide('no1'); \n" +
DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,
DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);
assertEquals(EXPECTED, result);
assertEquals(0, errorManager.getErrorCount());
assertEquals(0, errorManager.getWarningCount());
final String CONTENTS = "/**\n" +
DependencyInfo EXPECTED = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,
DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, CONTENTS);
assertEquals(EXPECTED, result);!options.skipAllPasses &&JSType getTypeIfRefinable(Node node, FlowScope scope) {
final JSType getRestrictedWithoutUndefined(JSType type) {
final JSType getRestrictedWithoutNull(JSType type) {if (!ignoreStar) {
case ANNOTATION:
case EOC:
case EOF:
if (!(option == WhitespaceOption.PRESERVE &&
token == JsDocToken.ANNOTATION)) {
default:
ignoreStar = false;
state = State.SEARCHING_ANNOTATION;
if (builder.length() > 0) {
builder.append(' ');
assertEquals(" Foo\n Bar\n\n Baz", node.getJSDocInfo().getLicense());
assertEquals(" Foo\n Bar\n\n Baz", node.getJSDocInfo().getLicense());"var google = {\n"+
"actual parameter 1 of f does not match formal parameter\n"+
"actual parameter 1 of f does not match formal parameter\n"+addGuards(composeGuard.guards.descendingSet());for (int i = prevCutPosition; i < code.length() - 1; i++) {
code.setCharAt(i, code.charAt(i+1));
code.setLength(code.length() - 1);
reportLineCut(lineIndex, prevCutPosition, false);
"\"123456789012345678901234567890\";\"1234567890\";\n");if (constraintObj != null && constraintObj.isRecordType()) {
ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
if (objType != null) {
for (String prop : constraintObj.getOwnPropertyNames()) {
JSType propType = constraintObj.getPropertyType(prop);
if (!objType.isPropertyTypeDeclared(prop)) {
JSType typeToInfer = propType;
if (!objType.hasProperty(prop)) {
typeToInfer =
getNativeType(VOID_TYPE).getLeastSupertype(propType);
objType.defineInferredProperty(prop, typeToInfer, null);private NodeTraversal currentTraversal;
JSError error = currentTraversal.makeError(n, diagnostic, n.toString());
currentTraversal.getCompiler().report(error);
Preconditions.checkNotNull(currentTraversal);
currentTraversal.getCompiler().reportCodeChange();
Preconditions.checkNotNull(currentTraversal);
return currentTraversal.getCompiler().areNodesEqualForInlining(n1, n2);
Preconditions.checkNotNull(currentTraversal);
Preconditions.checkNotNull(currentTraversal.getCompiler());
return currentTraversal.getCompiler().getLifeCycleStage().isNormalized();
void beginTraversal(NodeTraversal traversal) {
currentTraversal = traversal;
void endTraversal(NodeTraversal traversal) {
currentTraversal = null;
return NodeUtil.mayEffectMutableState(n, currentTraversal.getCompiler());
return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());
return currentTraversal != null
&& currentTraversal.getCompiler().acceptEcmaScript5();
return currentTraversal.getCompiler().getCodingConvention();
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
class PeepholeOptimizationsPass extends AbstractPostOrderCallback
NodeTraversal t = new NodeTraversal(compiler, this);
beginTraversal(t);
t.traverse(root);
endTraversal(t);
public void visit(NodeTraversal t, Node n, Node parent) {
private void beginTraversal(NodeTraversal t) {
optimization.beginTraversal(t);
private void endTraversal(NodeTraversal t) {
optimization.endTraversal(t);
test(options, code, expected);if (x < 0 && prev == '-') {
if ((long) x == x && !isNegativeZero(x)) {implemented.getImplicitPrototype().getOwnPropertyNames()) {
if (!instance.hasProperty(prop)) {
JSType found = instance.getPropertyType(prop);
= implementedInterface.getImplicitPrototype().getPropertyType(prop);
FunctionType constructor
= implementedInterface.toObjectType().getConstructor();
registerMismatch(found, required, report(t.makeError(n,
JSType thatParamType = thatParam.getJSType();
"/** @override */ G.prototype.foo = function(x, y) { };" +
"(new G()).foo();",
"Function G.prototype.foo: called with 0 argument(s). " +
"Function requires at least 2 argument(s) " +
"and no more than 2 argument(s).");
"G.prototype.foo = function(a, opt_b, var_args) { };" +
"(new G()).foo();",
"Function G.prototype.foo: called with 0 argument(s). " +
"Function requires at least 1 argument(s).");
"G.prototype.foo = function(a, var_args, opt_b) { };",
"/** @override */ G.prototype.foo = function(x, y) { };" +
"(new G()).foo();",
"Function G.prototype.foo: called with 0 argument(s). " +
"Function requires at least 2 argument(s) " +
"and no more than 2 argument(s).");
"G.prototype.foo = function(a, opt_b, var_args) { };" +
"(new G()).foo();",
"Function G.prototype.foo: called with 0 argument(s). " +
"Function requires at least 1 argument(s).");
"G.prototype.foo = function(a, var_args, opt_b) { };",
"Function", twoNumbers, oneNumber);
"function (...[*]): None", twoNumbers, oneNumber);
.withParamsNode(registry.createParameters(NUMBER_TYPE))
.withParamsNode(registry.createParameters(NUMBER_TYPE))
false, EVAL_ERROR_TYPE);import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
class ProcessCommonJSModules implements CompilerPass {
public static final String  DEFAULT_FILENAME_PREFIX = "." + File.separator;
this.compiler = compiler;
this.filenamePrefix = filenamePrefix;
this.reportDependencies = true;
this.filenamePrefix = filenamePrefix;
private String guessCJSModuleName(String filename) {
public SuffixVarsCallback(String suffix) {sb.append(getPropertyType(property).toString());
if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
return "{...}";JsName name = getName(ns.name, false);
if (name != null) {
refNodes.add(new ClassDefiningFunctionNode(
name, n, parent, parent.getParent()));return (super.isEquivalentTo(node, compareJsType, recurse)
&& getDouble() == ((NumberNode) node).getDouble());
fold("a=-0", "a=0");logger.info("Aliasing common strings");
logger.info(sb.toString());
logger.info("Collapsed " + numRenamedPropertyNames + " properties into "
logger.info("Creating extern file for exports");
logger.info("Remove try/catch/finally");
logger.info("Strip code");
logger.info("Computing Control Flow Graph");
logger.info("Normalizing");
logger.info("Recording function information");
logger.info("Moving functions + variable into deeper modules");
logger.info("Renamed " + instancesRenamed + " instances of "
logger.info("Skipped renaming " + instancesSkipped + " invalidated "
logger.info("Expanding Jquery Aliases");
logger.info("Named " + namedCount + " anon functions using " +
logger.info("Named " + namedCount + " anon functions using " +
logger.info(name);
logger.info("Parsing Dep: " + filePath);defineObjectLiteral(t, n);
private void defineObjectLiteral(NodeTraversal t, Node objectLit) {
t, objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);
NodeTraversal t, Node objLit, ObjectType objLitType,
getDeclaredType(t.getSourceName(), info, keyNode, value);
boolean isExtern = t.getInput() != null && t.getInput().isExtern();"x = [{}, [\"abc\", {}, [[]]]");
"x = [{}, [\"abc\", {}, [[]]]");t.getScope().getVar(root.getString()),
t.getScope().getVar(root.getString()),
if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {
new PeepholeReplaceKnownMethods(late),
new PeepholeReplaceKnownMethods(late),
import java.util.regex.Pattern;
private final boolean late;
PeepholeReplaceKnownMethods(boolean late) {
this.late = late;
if (functionNameString.equals("split")) {
subtree = tryFoldStringSplit(subtree, stringNode, firstArg);
private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) {
if (late) {
return n;
Preconditions.checkArgument(n.isCall());
Preconditions.checkArgument(stringNode.isString());
String separator = null;
String stringValue = stringNode.getString();
int limit = stringValue.length();
if (arg1 != null) {
if (arg1.isString()) {
separator = arg1.getString();
return n;
Node arg2 = arg1.getNext();
if (arg2 != null) {
if (arg2.isNumber()) {
limit = (int) arg2.getDouble();
if (limit < 0) {
return n;
return n;
String[] stringArray;
if (separator != null) {
stringArray = stringValue.split(Pattern.quote(separator));
stringArray = new String[1];
stringArray[0] = stringValue;
Node arrayOfStrings = IR.arraylit();
for (int i = 0; i < limit && i < stringArray.length; i++) {
arrayOfStrings.addChildToBack(
IR.string(stringArray[i]).srcref(stringNode));
Node parent = n.getParent();
parent.replaceChild(n, arrayOfStrings);
reportCodeChange();
return arrayOfStrings;
private boolean late = true;
new PeepholeReplaceKnownMethods(late));
public void testFoldStringSplit() {
late = false;
fold("x = 'abcde'.split()", "x = ['abcde']");
fold("x = 'abcde'.split(null)", "x = ['abcde']");
fold("x = 'a b c d e'.split(' ')", "x = ['a','b','c','d','e']");
fold("x = 'a b c d e'.split(' ', 0)", "x = []");
fold("x = 'abcde'.split('cd')", "x = ['ab','e']");
fold("x = 'a b c d e'.split(' ', 1)", "x = ['a']");
fold("x = 'a b c d e'.split(' ', 3)", "x = ['a','b','c']");
fold("x = 'a b c d e'.split(null, 1)", "x = ['a b c d e']");
foldSame("x = 'abcde'.split(/ /)");
foldSame("x = 'abcde'.split(' ', -1)");
late = true;
foldSame("x = 'a b c d e'.split(' ')");static final DiagnosticType INVALID_FUNCTION_DECL =
DiagnosticType.error("JSC_INVALID_FUNCTION_DECL",
"Syntax error: function declaration must have a name");
if (!NodeUtil.isFunctionExpression(parent)) {
t.report(n, INVALID_FUNCTION_DECL);
public void testInvalidFunctionDecl1() {
super.enableAstValidation(false);
final CompilerTestCase testcase = this;
testSetupPass = new CompilerPass() {
void visit(Node n) {
if (n.isName()
&& !n.getString().isEmpty()
&& n.getParent().isFunction()) {
n.setString("");
testcase.getLastCompiler().reportCodeChange();
for (Node c : n.children()) {
visit(c);
public void process(Node externs, Node root) {
visit(root);
test("function f() {};", null, VarCheck.INVALID_FUNCTION_DECL);
test("if (true) { function f(){}; }", null, VarCheck.INVALID_FUNCTION_DECL);private ProcessProperties() {
symbolStack.push(new NameContext(globalNode));
symbolStack.peek().scope = t.getScope();
if (isPrototypePropertyAssign(n)) {
symbolStack.push(new NameContext(getNameInfoForName(
n.getFirstChild().getLastChild().getString(), PROPERTY)));
String name = parent.isName() ?
parent.getString() /* VAR */ :
n.getFirstChild().getString() /* named function */;
symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));
symbolStack.push(new NameContext(anonymousNode));
if (propName.equals("prototype")) {
processPrototypeParent(t, parent);
addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
addSymbolUse(propName, t.getModule(), PROPERTY);
!(parent.isAssign() &&
parent.getFirstChild().isGetProp() &&
parent.getFirstChild().getLastChild().getString().equals(
"prototype"))) {
if (!processGlobalFunctionDeclaration(t, n, parent,
parent.getParent())) {
context.name.readClosureVariables = true;
if (isPrototypePropertyAssign(n) ||
isGlobalFunctionDeclaration(t, n) ||
n.isFunction()) {
return t.inGlobalScope() &&
(NodeUtil.isFunctionDeclaration(n) ||
n.isFunction() &&
n.getParent().isName());
private boolean isPrototypePropertyAssign(Node assign) {
Node n = assign.getFirstChild();
if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
&& n.isGetProp()
&& assign.getParent().isExprResult()) {
boolean isChainedProperty =
n.getFirstChild().isGetProp();
if (isChainedProperty) {
Node child = n.getFirstChild().getFirstChild().getNext();
if (child.isString() &&
child.getString().equals("prototype")) {
return true;
return false;
Node nameNode, Node parent, Node gramps) {
new GlobalFunction(nameNode, parent, gramps, t.getModule()));
private void processPrototypeParent(NodeTraversal t, Node n) {
Property prop = new AssignmentProperty(grandParent, t.getModule());
key, key.getFirstChild(), map, n, t.getModule());
class GlobalFunction implements Symbol {
GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {
AssignmentProperty(Node node, JSModule module) {
JSModule module) {
Scope scope;
NameContext(NameInfo name) {
if(deepestCommonModuleRef == null) {
logger.fine("Moved method: " +
proto.getQualifiedName() + "." + nameInfo.name +
" from module " + prop.getModule() + " to module " +
deepestCommonModuleRef);node.addChildToBack(transform(initializerNode.getInitializer()));
node.setLineno(node.getLineno());
maybeSetLengthFrom(node, initializerNode);
assertNodePosition(2, 4, varName);
assertNodePosition(3, 4, varExpr);addJsString(n.getString());
addJsString(n.getString());
void addJsString(String s) {
String cached = ESCAPED_JS_STRINGS.get(s);
if (cached == null) {
cached = jsString(s);
ESCAPED_JS_STRINGS.put(s, cached);
add(cached);
String jsString(String s) {
outputCharsetEncoder);
return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder);
return strEscape(s, '"',  "\\\"", "\'", "\\\\", null);
static String strEscape(String s, char quote,
String doublequoteEscape,
String singlequoteEscape,
String backslashEscape,
CharsetEncoder outputCharsetEncoder) {
result = left.getString().equals(right.getString());
result = !left.getString().equals(right.getString());
default:
return n;  // we only handle == and != here
Node n = newStringNode(literalNode.getValue());
LAST_PROP          = 53;mySymbol = symbols.get(declNode, name);
mySymbol = myScope.ownSymbols.get(otherSymbol.getName());
if (mySymbol == null) {
mySymbol = copySymbolTo(otherSymbol, declNode, myScope);
Preconditions.checkState(replacedSymbol == null);
Preconditions.checkState(replacedSymbol == null);
Symbol namespace = root.scope.getSlot(name);if (var == null || !var.isGlobal() || var.isExtern()) {primitiveObjectType =
(ObjectType) safeResolve(primitiveObjectType, t, scope);pn.setLineno(lineno);
pn.setLineno(opLineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(line);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(line);
node.setLineno(line);
result.setLineno(lineno);
assertEquals(2, var1Add.getLineno());
assertEquals(9, thirdVarDiv.getLineno());
assertEquals(2, compare.getLineno());
assertEquals(2, compare.getLineno());
assertEquals(2, assign.getLineno());
assertEquals(2, comma1.getLineno());
assertEquals(2, orClause.getLineno());
assertEquals(2, firstObjectLit.getLineno());
assertEquals(4, orTest.getLineno());
assertEquals(3, andTest.getLineno());
assertEquals(4, eqTest.getLineno());
assertEquals(9, notEqTest.getLineno());
assertEquals(3, bitOrTest.getLineno());
assertEquals(6, bitAndTest.getLineno());
assertEquals(8, bitXorTest.getLineno());
assertEquals(11, bitShiftTest.getLineno());
assertEquals(2, fnAssignment.getLineno());
n.setCharno(position2charno(exprNode.getAbsolutePosition() +
exprNode.getOperatorPosition()));
"enum initializer must be an object literal or an enum",
"required: enum{goog.a}"));
"required: string"});
"enum initializer must be an object literal or an enum",
"required: enum{goog.a}"));
"SCRIPT 0 [length: 8]\n" +
"    EXPR_RESULT 0 [length: 8]\n" +
"        ARRAYLIT 0 [length: 8]\n" +
"            NAME a 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME b 0 [length: 1]\n");
"SCRIPT 0 [length: 9]\n" +
"    EXPR_RESULT 0 [length: 9]\n" +
"        ARRAYLIT 0 [length: 9]\n" +
"            EMPTY 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME a 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME b 0 [length: 1]\n");
"SCRIPT 0 [length: 11]\n" +
"    EXPR_RESULT 0 [length: 10]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 9]\n" +
"            STRING 1 0 [quoted: 1] [length: 1]\n" +
"                TRUE 0 [length: 4]\n");
"SCRIPT 0 [length: 14]\n" +
"    EXPR_RESULT 0 [length: 13]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 12]\n" +
"            GET 1 0 [quoted: 1] [length: 1]\n" +
"                FUNCTION  0 [length: 6]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 15]\n" +
"    EXPR_RESULT 0 [length: 14]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 13]\n" +
"            SET 1 0 [quoted: 1] [length: 1]\n" +
"                FUNCTION  0 [length: 7]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                        NAME a 0 [length: 1]\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 8]\n" +
"    LABEL 0 [length: 4]\n" +
"        LABEL_NAME foo 0 [length: 4]\n" +
"        EXPR_RESULT 0 [length: 3]\n" +
"            NAME bar 0 [length: 3]\n");
"SCRIPT 0 [length: 43]\n" +
"    LABEL 0 [length: 2]\n" +
"        LABEL_NAME l 0 [length: 2]\n" +
"        WHILE 0 [length: 40]\n" +
"            CALL 0 [length: 3]\n" +
"                NAME f 0 [length: 1]\n" +
"            BLOCK 0 [length: 28]\n" +
"                IF 0 [length: 24]\n" +
"                    CALL 0 [length: 3]\n" +
"                        NAME g 0 [length: 1]\n" +
"                    BLOCK 0 [length: 15]\n" +
"                        CONTINUE 0 [length: 11]\n" +
"                            LABEL_NAME l 0 [length: 1]\n");
"SCRIPT 0 [length: 24]\n" +
"    LABEL 0 [length: 4]\n" +
"        LABEL_NAME Foo 0 [length: 4]\n" +
"        LABEL 0 [length: 4]\n" +
"            LABEL_NAME Bar 0 [length: 4]\n" +
"            LABEL 0 [length: 2]\n" +
"                LABEL_NAME X 0 [length: 2]\n" +
"                BLOCK 0 [length: 14]\n" +
"                    BREAK 0 [length: 10]\n" +
"                        LABEL_NAME Bar 0 [length: 3]\n");
"SCRIPT 0 [length: 2]\n" +
"    EXPR_RESULT 0 [length: 2]\n" +
"        NEG 0 [length: 2]\n" +
"            NAME a 0 [length: 1]\n");
"SCRIPT 0 [length: 2]\n" +
"    EXPR_RESULT 0 [length: 2]\n" +
"        NUMBER -2.0 0 [length: 1]\n");
"SCRIPT 0 [length: 6]\n" +
"    EXPR_RESULT 0 [length: 6]\n" +
"        SUB 0 [length: 6]\n" +
"            NUMBER 1.0 0 [length: 1]\n" +
"            NUMBER -2.0 0 [length: 1]\n");
"SCRIPT 0 [length: 14]\n" +
"    EXPR_RESULT 0 [length: 13]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 12]\n" +
"            GET a 0 [length: 1]\n" +
"                FUNCTION  0 [length: 6]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 15]\n" +
"    EXPR_RESULT 0 [length: 14]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 13]\n" +
"            SET a 0 [length: 1]\n" +
"                FUNCTION  0 [length: 7]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                        NAME x 0 [length: 1]\n" +
"                    BLOCK 0 [length: 2]\n");
assertMarkerPosition(a, 0, 4);
assertMarkerPosition(b, 0, 45);
assertMarkerPosition(root.getFirstChild(), 3, 4);
assertMarkerPosition(root.getFirstChild().getNext().getNext(), 10, 6);
"\nvar d =\n" +
"\nswitch (a) {\n" +
"\nfunction\n" +
"\nvar\n" +
"\nfunction\n" +
"\nfor(\n" +
"\nvar d = a\n" +
assertNodePosition(2, 4, firstVarAdd);
assertNodePosition(6, 6, secondVarAdd);
assertNodePosition(9, 4, thirdVarAdd);
"\na++;\n" +
"\nif\n" +
assertNodePosition(2, 5, eqClause);
"\ntry {\n" +
"\na\n" +
"\nfoo:\n" +
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na,\n" +
assertNodePosition(1, 1, comma2);
"\nvar path =\n" +
"\nif (a && \n" +
assertNodePosition(2, 8, orClause);
assertNodePosition(1, 6, andClause);
"\nif (a & \n" +
assertNodePosition(2, 8, bitOr);
assertNodePosition(1, 6, bitAnd);
"\nvar foo =\n" +
"\ntry {\n" +
"\ntry {\n" +
"\nif\n" +
assertNodePosition(4, 12, orTest);
assertNodePosition(3, 5, andTest);
assertNodePosition(2, 9, aTest);
assertNodePosition(4, 5, bTest);
assertNodePosition(5, 4, cTest);
"\nif (\n" +
assertNodePosition(4, 9, eqTest);
assertNodePosition(9, 7, notEqTest);
assertNodePosition(3, 8, bitOrTest);
assertNodePosition(6, 8, bitAndTest);
assertNodePosition(8, 9, bitXorTest);
assertNodePosition(11, 8, bitShiftTest);
"\na.\n" +
"\na.\n" +
assertNodePosition(2, 1, fnAssignment);
AstRoot script = p.parse(string, null, 0);
script, null, string, config, errorReporter);
assertEquals(2, assign.getCharno());
assertEquals(12, assign.getCharno());
assertEquals(9, lt.getCharno());
assertEquals(11, op.getCharno());result.setLineno(pn.getLineno());
setLineno(left.getLineno());
assertEquals(1, var1Add.getLineno());
assertEquals(8, thirdVarDiv.getLineno());
assertEquals(1, compare.getLineno());
assertEquals(1, compare.getLineno());
assertEquals(1, assign.getLineno());
assertEquals(1, comma1.getLineno());
assertEquals(1, orClause.getLineno());
assertEquals(2, objectLiteral.getLineno());
assertEquals(3, firstObjectLit.getLineno());
assertEquals(2, orTest.getLineno());
assertEquals(2, andTest.getLineno());
assertEquals(2, eqTest.getLineno());
assertEquals(7, notEqTest.getLineno());
assertEquals(2, bitOrTest.getLineno());
assertEquals(5, bitAndTest.getLineno());
assertEquals(7, bitXorTest.getLineno());
assertEquals(10, bitShiftTest.getLineno());
assertEquals(1, fnAssignment.getLineno());
n.setCharno(position2charno(exprNode.getAbsolutePosition()));
"required: enum{goog.a}",
"enum initializer must be an object literal or an enum"));
"required: string"
"required: enum{goog.a}",
"enum initializer must be an object literal or an enum"));
import com.google.javascript.jscomp.SourceFile;
"SCRIPT 1 [source_file: FileName.js] [length: 8]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 8]\n" +
"        ARRAYLIT 1 [source_file: FileName.js] [length: 8]\n" +
"            NAME a 1 [source_file: FileName.js] [length: 1]\n" +
"            EMPTY 1 [source_file: FileName.js] [length: 1]\n" +
"            NAME b 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 9]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 9]\n" +
"        ARRAYLIT 1 [source_file: FileName.js] [length: 9]\n" +
"            EMPTY 1 [source_file: FileName.js] [length: 1]\n" +
"            EMPTY 1 [source_file: FileName.js] [length: 1]\n" +
"            EMPTY 1 [source_file: FileName.js] [length: 1]\n" +
"            NAME a 1 [source_file: FileName.js] [length: 1]\n" +
"            EMPTY 1 [source_file: FileName.js] [length: 1]\n" +
"            NAME b 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 11]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 10]\n" +
"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 9]\n" +
"            STRING 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" +
"                TRUE 1 [source_file: FileName.js] [length: 4]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 14]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\n" +
"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\n" +
"            GET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" +
"                FUNCTION  1 [source_file: FileName.js] [length: 6]\n" +
"                    NAME  1 [source_file: FileName.js]\n" +
"                    LP 1 [source_file: FileName.js]\n" +
"                    BLOCK 1 [source_file: FileName.js] [length: 2]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 15]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\n" +
"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\n" +
"            SET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" +
"                FUNCTION  1 [source_file: FileName.js] [length: 7]\n" +
"                    NAME  1 [source_file: FileName.js]\n" +
"                    LP 1 [source_file: FileName.js]\n" +
"                        NAME a 1 [source_file: FileName.js] [length: 1]\n" +
"                    BLOCK 1 [source_file: FileName.js] [length: 2]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 8]\n" +
"    LABEL 1 [source_file: FileName.js] [length: 4]\n" +
"        LABEL_NAME foo 1 [source_file: FileName.js] [length: 4]\n" +
"        EXPR_RESULT 1 [source_file: FileName.js] [length: 3]\n" +
"            NAME bar 1 [source_file: FileName.js] [length: 3]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 43]\n" +
"    LABEL 1 [source_file: FileName.js] [length: 2]\n" +
"        LABEL_NAME l 1 [source_file: FileName.js] [length: 2]\n" +
"        WHILE 1 [source_file: FileName.js] [length: 40]\n" +
"            CALL 1 [source_file: FileName.js] [length: 3]\n" +
"                NAME f 1 [source_file: FileName.js] [length: 1]\n" +
"            BLOCK 1 [source_file: FileName.js] [length: 28]\n" +
"                IF 1 [source_file: FileName.js] [length: 24]\n" +
"                    CALL 1 [source_file: FileName.js] [length: 3]\n" +
"                        NAME g 1 [source_file: FileName.js] [length: 1]\n" +
"                    BLOCK 1 [source_file: FileName.js] [length: 15]\n" +
"                        CONTINUE 1 [source_file: FileName.js] [length: 11]\n" +
"                            LABEL_NAME l 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 24]\n" +
"    LABEL 1 [source_file: FileName.js] [length: 4]\n" +
"        LABEL_NAME Foo 1 [source_file: FileName.js] [length: 4]\n" +
"        LABEL 1 [source_file: FileName.js] [length: 4]\n" +
"            LABEL_NAME Bar 1 [source_file: FileName.js] [length: 4]\n" +
"            LABEL 1 [source_file: FileName.js] [length: 2]\n" +
"                LABEL_NAME X 1 [source_file: FileName.js] [length: 2]\n" +
"                BLOCK 1 [source_file: FileName.js] [length: 14]\n" +
"                    BREAK 1 [source_file: FileName.js] [length: 10]\n" +
"                        LABEL_NAME Bar 1 [source_file: FileName.js] [length: 3]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 2]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\n" +
"        NEG 1 [source_file: FileName.js] [length: 2]\n" +
"            NAME a 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 2]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\n" +
"        NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 6]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 6]\n" +
"        SUB 1 [source_file: FileName.js] [length: 6]\n" +
"            NUMBER 1.0 1 [source_file: FileName.js] [length: 1]\n" +
"            NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 14]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\n" +
"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\n" +
"            GET a 1 [source_file: FileName.js] [length: 1]\n" +
"                FUNCTION  1 [source_file: FileName.js] [length: 6]\n" +
"                    NAME  1 [source_file: FileName.js]\n" +
"                    LP 1 [source_file: FileName.js]\n" +
"                    BLOCK 1 [source_file: FileName.js] [length: 2]\n");
"SCRIPT 1 [source_file: FileName.js] [length: 15]\n" +
"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\n" +
"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\n" +
"            SET a 1 [source_file: FileName.js] [length: 1]\n" +
"                FUNCTION  1 [source_file: FileName.js] [length: 7]\n" +
"                    NAME  1 [source_file: FileName.js]\n" +
"                    LP 1 [source_file: FileName.js]\n" +
"                        NAME x 1 [source_file: FileName.js] [length: 1]\n" +
"                    BLOCK 1 [source_file: FileName.js] [length: 2]\n");
assertMarkerPosition(a, 1, 4);
assertMarkerPosition(b, 1, 45);
assertMarkerPosition(root.getFirstChild(), 4, 4);
assertMarkerPosition(root.getFirstChild().getNext().getNext(), 11, 6);
"var d =\n" +
"switch (a) {\n" +
"function\n" +
"var\n" +
"function\n" +
"for(\n" +
"var d = a\n" +
assertNodePosition(1, 8, firstVarAdd);
assertNodePosition(6, 4, secondVarAdd);
assertNodePosition(8, 8, thirdVarAdd);
"a++;\n" +
"if\n" +
assertNodePosition(2, 3, eqClause);
"try {\n" +
"a\n" +
"foo:\n" +
"a\n" +
assertNodePosition(1, 0, condClause);
"a\n" +
assertNodePosition(1, 0, condClause);
"a\n" +
assertNodePosition(1, 0, condClause);
"a,\n" +
assertNodePosition(1, 0, comma2);
"var path =\n" +
"if (a && \n" +
assertNodePosition(1, 4, orClause);
assertNodePosition(1, 4, andClause);
"if (a & \n" +
assertNodePosition(1, 4, bitOr);
assertNodePosition(1, 4, bitAnd);
"var foo =\n" +
"try {\n" +
"try {\n" +
"if\n" +
assertNodePosition(2, 7, orTest);
assertNodePosition(2, 7, andTest);
assertNodePosition(2, 7, aTest);
assertNodePosition(4, 3, bTest);
assertNodePosition(5, 2, cTest);
"if (\n" +
assertNodePosition(2, 8, eqTest);
assertNodePosition(7, 8, notEqTest);
assertNodePosition(2, 8, bitOrTest);
assertNodePosition(5, 8, bitAndTest);
assertNodePosition(7, 8, bitXorTest);
assertNodePosition(10, 8, bitShiftTest);
"a.\n" +
"a.\n" +
assertNodePosition(1, 0, fnAssignment);
AstRoot script = p.parse(string, null, 1);
script, SourceFile.fromCode("FileName.js", string), string, config, errorReporter);
assertEquals(0, assign.getCharno());
assertEquals(1, assign.getCharno());
assertEquals(7, lt.getCharno());
assertEquals(8, op.getCharno());pn.setLineno(lineno);
pn.setLineno(opLineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(line);
pn.setLineno(lineno);
pn.setLineno(lineno);
pn.setLineno(line);
node.setLineno(line);
result.setLineno(lineno);
assertEquals(2, var1Add.getLineno());
assertEquals(9, thirdVarDiv.getLineno());
assertEquals(2, compare.getLineno());
assertEquals(2, compare.getLineno());
assertEquals(2, assign.getLineno());
assertEquals(2, comma1.getLineno());
assertEquals(2, orClause.getLineno());
assertEquals(2, firstObjectLit.getLineno());
assertEquals(4, orTest.getLineno());
assertEquals(3, andTest.getLineno());
assertEquals(4, eqTest.getLineno());
assertEquals(9, notEqTest.getLineno());
assertEquals(3, bitOrTest.getLineno());
assertEquals(6, bitAndTest.getLineno());
assertEquals(8, bitXorTest.getLineno());
assertEquals(11, bitShiftTest.getLineno());
assertEquals(2, fnAssignment.getLineno());
n.setCharno(position2charno(exprNode.getAbsolutePosition() +
exprNode.getOperatorPosition()));
"enum initializer must be an object literal or an enum",
"required: enum{goog.a}"));
"required: string"});
"enum initializer must be an object literal or an enum",
"required: enum{goog.a}"));
"SCRIPT 0 [length: 8]\n" +
"    EXPR_RESULT 0 [length: 8]\n" +
"        ARRAYLIT 0 [length: 8]\n" +
"            NAME a 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME b 0 [length: 1]\n");
"SCRIPT 0 [length: 9]\n" +
"    EXPR_RESULT 0 [length: 9]\n" +
"        ARRAYLIT 0 [length: 9]\n" +
"            EMPTY 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME a 0 [length: 1]\n" +
"            EMPTY 0 [length: 1]\n" +
"            NAME b 0 [length: 1]\n");
"SCRIPT 0 [length: 11]\n" +
"    EXPR_RESULT 0 [length: 10]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 9]\n" +
"            STRING 1 0 [quoted: 1] [length: 1]\n" +
"                TRUE 0 [length: 4]\n");
"SCRIPT 0 [length: 14]\n" +
"    EXPR_RESULT 0 [length: 13]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 12]\n" +
"            GET 1 0 [quoted: 1] [length: 1]\n" +
"                FUNCTION  0 [length: 6]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 15]\n" +
"    EXPR_RESULT 0 [length: 14]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 13]\n" +
"            SET 1 0 [quoted: 1] [length: 1]\n" +
"                FUNCTION  0 [length: 7]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                        NAME a 0 [length: 1]\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 8]\n" +
"    LABEL 0 [length: 4]\n" +
"        LABEL_NAME foo 0 [length: 4]\n" +
"        EXPR_RESULT 0 [length: 3]\n" +
"            NAME bar 0 [length: 3]\n");
"SCRIPT 0 [length: 43]\n" +
"    LABEL 0 [length: 2]\n" +
"        LABEL_NAME l 0 [length: 2]\n" +
"        WHILE 0 [length: 40]\n" +
"            CALL 0 [length: 3]\n" +
"                NAME f 0 [length: 1]\n" +
"            BLOCK 0 [length: 28]\n" +
"                IF 0 [length: 24]\n" +
"                    CALL 0 [length: 3]\n" +
"                        NAME g 0 [length: 1]\n" +
"                    BLOCK 0 [length: 15]\n" +
"                        CONTINUE 0 [length: 11]\n" +
"                            LABEL_NAME l 0 [length: 1]\n");
"SCRIPT 0 [length: 24]\n" +
"    LABEL 0 [length: 4]\n" +
"        LABEL_NAME Foo 0 [length: 4]\n" +
"        LABEL 0 [length: 4]\n" +
"            LABEL_NAME Bar 0 [length: 4]\n" +
"            LABEL 0 [length: 2]\n" +
"                LABEL_NAME X 0 [length: 2]\n" +
"                BLOCK 0 [length: 14]\n" +
"                    BREAK 0 [length: 10]\n" +
"                        LABEL_NAME Bar 0 [length: 3]\n");
"SCRIPT 0 [length: 2]\n" +
"    EXPR_RESULT 0 [length: 2]\n" +
"        NEG 0 [length: 2]\n" +
"            NAME a 0 [length: 1]\n");
"SCRIPT 0 [length: 2]\n" +
"    EXPR_RESULT 0 [length: 2]\n" +
"        NUMBER -2.0 0 [length: 1]\n");
"SCRIPT 0 [length: 6]\n" +
"    EXPR_RESULT 0 [length: 6]\n" +
"        SUB 0 [length: 6]\n" +
"            NUMBER 1.0 0 [length: 1]\n" +
"            NUMBER -2.0 0 [length: 1]\n");
"SCRIPT 0 [length: 14]\n" +
"    EXPR_RESULT 0 [length: 13]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 12]\n" +
"            GET a 0 [length: 1]\n" +
"                FUNCTION  0 [length: 6]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                    BLOCK 0 [length: 2]\n");
"SCRIPT 0 [length: 15]\n" +
"    EXPR_RESULT 0 [length: 14]\n" +
"        OBJECTLIT 0 [parenthesized: true] [length: 13]\n" +
"            SET a 0 [length: 1]\n" +
"                FUNCTION  0 [length: 7]\n" +
"                    NAME  0\n" +
"                    LP 0\n" +
"                        NAME x 0 [length: 1]\n" +
"                    BLOCK 0 [length: 2]\n");
assertMarkerPosition(a, 0, 4);
assertMarkerPosition(b, 0, 45);
assertMarkerPosition(root.getFirstChild(), 3, 4);
assertMarkerPosition(root.getFirstChild().getNext().getNext(), 10, 6);
"\nvar d =\n" +
"\nswitch (a) {\n" +
"\nfunction\n" +
"\nvar\n" +
"\nfunction\n" +
"\nfor(\n" +
"\nvar d = a\n" +
assertNodePosition(2, 4, firstVarAdd);
assertNodePosition(6, 6, secondVarAdd);
assertNodePosition(9, 4, thirdVarAdd);
"\na++;\n" +
"\nif\n" +
assertNodePosition(2, 5, eqClause);
"\ntry {\n" +
"\na\n" +
"\nfoo:\n" +
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na\n" +
assertNodePosition(2, 0, condClause);
"\na,\n" +
assertNodePosition(1, 1, comma2);
"\nvar path =\n" +
"\nif (a && \n" +
assertNodePosition(2, 8, orClause);
assertNodePosition(1, 6, andClause);
"\nif (a & \n" +
assertNodePosition(2, 8, bitOr);
assertNodePosition(1, 6, bitAnd);
"\nvar foo =\n" +
"\ntry {\n" +
"\ntry {\n" +
"\nif\n" +
assertNodePosition(4, 12, orTest);
assertNodePosition(3, 5, andTest);
assertNodePosition(2, 9, aTest);
assertNodePosition(4, 5, bTest);
assertNodePosition(5, 4, cTest);
"\nif (\n" +
assertNodePosition(4, 9, eqTest);
assertNodePosition(9, 7, notEqTest);
assertNodePosition(3, 8, bitOrTest);
assertNodePosition(6, 8, bitAndTest);
assertNodePosition(8, 9, bitXorTest);
assertNodePosition(11, 8, bitShiftTest);
"\na.\n" +
"\na.\n" +
assertNodePosition(2, 1, fnAssignment);
AstRoot script = p.parse(string, null, 0);
script, null, string, config, errorReporter);
assertEquals(2, assign.getCharno());
assertEquals(12, assign.getCharno());
assertEquals(9, lt.getCharno());
assertEquals(11, op.getCharno());return alternates;
int i = 0;
if (i == functionTypePosition) {
i++;private static boolean isUnflowable(Var v) {
return v != null && v.isLocal() && v.isMarkedEscaped();int firstDot = symbol.indexOf(".");
Preconditions.checkState(firstDot != -1);
Var owner = functionScope.getVar(symbol.substring(0, firstDot));
Scope ownerScope = owner == null ? functionScope : owner.getScope();
ownerScope.declare(symbol, node, bottomType, null);
public void testGlobalQualifiedNamesInLocalScopes() {
SymbolTable table = createSymbolTable(
"/** @const */ var x = {}; function f() { x.number = 3; }");
Symbol xNumber = getLocalVar(table, "x.number");
assertNotNull(xNumber);
assertTrue(table.getScope(xNumber).isGlobalScope());
assertEquals("?", xNumber.getType().toString());Node prototypeNode = n;
if (prototypeSlot.getDeclaration() != null) {
prototypeNode = prototypeSlot.getDeclaration().getNode();
scopeToDeclareIn.declare(variableName + ".prototype",
prototypeNode, prototypeSlot.getType(), input,
superClassCtor == null ||
superClassCtor.getInstanceType().equals(
getNativeType(OBJECT_TYPE)));return len > 0;childType + " has no properties", getNativeType(OBJECT_TYPE))) {
if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
return false;
if (that.isRecordType()) {
return that.getGreatestSubtype(this);
if (that instanceof RecordType) {
return RecordType.isSubtype(this, (RecordType) that);
public class RecordType extends PrototypeObjectType {
if (!(other instanceof RecordType)) {
RecordType otherRecord = (RecordType) other;
RecordType thatRecord = (RecordType) that;
public JSType getGreatestSubtype(JSType that) {
JSType greatestSubtype = super.getGreatestSubtype(that);
if (greatestSubtype.isNoObjectType() && !that.isNoObjectType()) {
altPropType.isEquivalentTo(propType))) {
public boolean isRecordType() {
return true;
return RecordType.isSubtype(this, (RecordType) that);
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("{");
int i = 0;
for (String property : properties.keySet()) {
if (i > 0) {
sb.append(", ");
sb.append(property);
sb.append(": ");
sb.append(properties.get(property).toString());
++i;
sb.append("}");
return sb.toString();
"undefined has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +
"null has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +public boolean isSubtype(JSType that) {
return JSType.isSubtype(this, that);
if (JSType.isSubtype(this, that)) {
JSType.isSubtype(this, that);
if (JSType.isSubtype(this, that)) {
public abstract boolean isSubtype(JSType that);
static boolean isSubtype(JSType thisType, JSType thatType) {
if (thatType instanceof NamedType) {
return thisType.isSubtype(((NamedType)thatType).getReferencedType());
if (JSType.isSubtype(this, that)) {
if (JSType.isSubtype(this, that)) {
if (JSType.isSubtype(this, that)) {
if (JSType.isSubtype(this, that)) {
public boolean isSubtype(JSType that) {
return JSType.isSubtype(this, that);if (null == source) {
prototypeSlot = null;import com.google.common.collect.ImmutableList;
Iterable<JSType> types = ImmutableList.copyOf(
typeRegistry.getTypesWithProperty(propName));
for (JSType type : types) {
ObjectType objType = type.toObjectType();
if (objType != null) {
Node pNode = objType.getPropertyNode(propName);
if (pNode != null && srcName.equals(pNode.getSourceFileName())) {
typeRegistry.unregisterPropertyOnType(propName, type);
objType.removeProperty(propName);Iterable<ObjectType> types = ImmutableList.copyOf(
typeRegistry.getEachReferenceTypeWithProperty(propName));
for (ObjectType type : types) {
Node pNode = type.getPropertyNode(propName);
if (pNode != null && srcName.equals(pNode.getSourceFileName())) {
typeRegistry.unregisterPropertyOnType(propName, type);
type.removeProperty(propName);return that.getLeastSupertype(this);
TypePair p = that.getTypesUnderEquality(this);
TypePair p = that.getTypesUnderInequality(this);
TypePair p = that.getTypesUnderShallowInequality(this);
public void testUnionType() throws Exception {if (!poType.hasCachedValues()) {
poType.setImplicitPrototype(newImplicitProto);
return true;compiler, Lists.newArrayList(externs, root), new JSDocInfoCollector());
return Node.newString(s, lineno, charno).clonePropsFrom(templateNode);
private List<String> actualTypes = null;
List<String> expectedTypes = Lists.newArrayList();
expectedTypes.add(typeNode.toStringTree());
assertEquals(expectedTypes, actualTypes);
actualTypes.add(typeNode.toStringTree());node.getQualifiedName(), getNativeType(UNKNOWN_TYPE), narrowed);
"goog.isDefAndNotNull = function(x) {};";
"goog.asserts = {};" +
"/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +import com.google.javascript.rhino.jstype.FunctionPrototypeType;
if (type instanceof FunctionPrototypeType) {
addRelatedInstance(
((FunctionPrototypeType) type).getOwnerFunction(), related);
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionPrototypeType protoType = (FunctionPrototypeType) instanceType;
return factory.getConcreteFunction(protoType.getOwnerFunction());
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionPrototypeType prototype = (FunctionPrototypeType) type;
return ((FunctionPrototypeType) type).getOwnerFunction()
.getInstanceType();
constructor = ((FunctionPrototypeType) objType).getOwnerFunction();
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
if (jsType instanceof FunctionPrototypeType) {
thisType = ((FunctionPrototypeType) jsType)
.getOwnerFunction().getInstanceType();
FunctionType baseConstructor = functionType.
getPrototype().getImplicitPrototype().getConstructor();
package com.google.javascript.rhino.jstype;
import com.google.common.collect.ImmutableSet;
import com.google.javascript.rhino.jstype.ObjectType;
public class FunctionPrototypeType extends PrototypeObjectType {
private static final long serialVersionUID = 1L;
private final FunctionType ownerFunction;
FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,
ObjectType implicitPrototype, boolean isNative) {
super(registry, null /* has no class name */, implicitPrototype,
isNative);
this.ownerFunction = ownerFunction;
FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,
ObjectType implicitPrototype) {
this(registry, ownerFunction, implicitPrototype, false);
public String getReferenceName() {
if (ownerFunction == null) {
return "{...}.prototype";
return ownerFunction.getReferenceName() + ".prototype";
public boolean hasReferenceName() {
return ownerFunction != null && ownerFunction.hasReferenceName();
public boolean isFunctionPrototypeType() {
return true;
public FunctionType getOwnerFunction() {
return ownerFunction;
public Iterable<ObjectType> getCtorImplementedInterfaces() {
return getOwnerFunction().getImplementedInterfaces();
public Iterable<ObjectType> getCtorExtendedInterfaces() {
if (getOwnerFunction() != null) {
return getOwnerFunction().getExtendedInterfaces();
return ImmutableSet.of();
private FunctionPrototypeType prototype;
public FunctionPrototypeType getPrototype() {
setPrototype(new FunctionPrototypeType(registry, this, null));
if (prototype == null) {
setPrototype(
new FunctionPrototypeType(
registry, this, baseType, isNativeObjectType()));
prototype.setImplicitPrototype(baseType);
public boolean setPrototype(FunctionPrototypeType prototype) {
return setPrototype(
new FunctionPrototypeType(
registry, this, objType, isNativeObjectType()));
prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);
return getConstructor().isNative() && "Object".equals(getReferenceName());
return getConstructor().isNative() && "Array".equals(getReferenceName());
return getConstructor().isNative() && "String".equals(getReferenceName());
return getConstructor().isNative() && "Boolean".equals(getReferenceName());
return getConstructor().isNative() && "Number".equals(getReferenceName());
return getConstructor().isNative() && "Date".equals(getReferenceName());
return getConstructor().isNative() && "RegExp".equals(getReferenceName());
ObjectType TOP_LEVEL_PROTOTYPE =
new FunctionPrototypeType(this, null, null, true);
OBJECT_FUNCTION_TYPE.defineDeclaredProperty(
"prototype", TOP_LEVEL_PROTOTYPE, null);
ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();
registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);
if (isNative()) {
boolean isNative() {
return nativeType;
return className != null;
public boolean isFunctionPrototypeType() {
return referencedType.isFunctionPrototypeType();
for (int i = 0; i < 4; ++i) {
String desired = "{a=[[Foo.prototype]]}";
String expected = "{}";
String desired = "{a=[[Foo.prototype]]}";
String expected = "{}";
testSets(false, js, js, "{}");
testSets(false, js, js, "{}");
assertFalse(x.getImplicitPrototype().hasOwnProperty("bar"));
assertFalse(x.getImplicitPrototype().hasOwnProperty("alert"));
assertEquals("function (this:Window, ?): undefined",
assertTrue(x.isPropertyTypeDeclared("alert"));
assertEquals("function (this:Window, ?): undefined",
assertFalse(proto1.hasOwnProperty("m1"));
assertFalse(proto1.hasOwnProperty("m2"));
assertTrue(proto2.hasOwnProperty("m1"));
assertTrue(proto2.hasOwnProperty("m2"));
assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());
public void testFunctionCyclycity() throws Exception {
FunctionPrototypeType instanceType =
new FunctionPrototypeType(
registry, U2U_CONSTRUCTOR_TYPE,
U2U_CONSTRUCTOR_TYPE.getInstanceType());
U2U_CONSTRUCTOR_TYPE.setPrototype(instanceType);
U2U_CONSTRUCTOR_TYPE.detectImplicitPrototypeCycle();
instanceType.detectImplicitPrototypeCycle();
public void testInvalidSetPrototypeBasedOn() {
try {
fun.setPrototypeBasedOn(unresolvedNamedType);
fail();
e.printStackTrace();return ((FunctionType) lValueType).getInstanceType();
return ((FunctionType) type).getInstanceType();
JSType scopeType = scope.getJSType();
if (!(scopeType instanceof FunctionType)) {
JSType returnType = ((FunctionType) scopeType).getReturnType();
FunctionType funcType = (FunctionType) func.getJSType();
return (FunctionType) declaration.getJSType();
FunctionType type = (FunctionType) functionNode.getJSType();
import com.google.javascript.rhino.jstype.EnumElementType;
addInvalidatingType(((EnumElementType) type).getPrimitiveType());
((EnumElementType) type).getPrimitiveType());
if (type instanceof EnumElementType) {
field, ((EnumElementType) type).getPrimitiveType());
if (objType instanceof FunctionType) {
constructor = (FunctionType) objType;
cType, ((EnumElementType) jsType).getPrimitiveType(), prop);
FunctionType functionType = (FunctionType) function.getJSType();
FunctionType ownerFnType = ownerType instanceof FunctionType ?
(FunctionType) ownerType : null;
import com.google.javascript.rhino.jstype.FunctionType;
((FunctionType) objType).getInstanceType().setJSDocInfo(
if (type.isFunctionType() && type.isConstructor()) {
name, (FunctionType) type, n, parent, parent.getParent(), rValue);
if (constructor instanceof FunctionType && constructor.isConstructor()) {
classType = (FunctionType) constructor;
FunctionType fntype = ((FunctionType) valueType);
FunctionType fntype = ((FunctionType) valueType);
if (jstype != null && jstype.isFunctionType()) {
FunctionType functionType = (FunctionType) jstype;
FunctionType funType = (FunctionType) n.getJSType();
if (!funType.isConstructor()) {
FunctionType funType = (FunctionType) n.getJSType();
FunctionType funType = (FunctionType) function.getJSType();
import com.google.javascript.rhino.jstype.FunctionType;
if (nodeType != null && nodeType instanceof FunctionType) {
thisType = ((FunctionType) nodeType).getTypeOfThis();
if (rightType instanceof FunctionType) {
targetType = (FunctionType) rightType;
if (target instanceof FunctionType) {
FunctionType funcTarget = (FunctionType) target;
if (funcTarget.hasInstanceType()) {
return funcTarget.getInstanceType();
FunctionType funcTarget = (FunctionType) target;
FunctionType funcTarget = (FunctionType) target;
FunctionType funcTarget = (FunctionType) target;
if (lhs.getJSType() == null
|| !(lhs.getJSType() instanceof FunctionType)) {
ConcreteType retType = createType(((FunctionType)
lhs.getJSType().restrictByNotNullOrUndefined())
.getReturnType());
((FunctionType) recvType).getParameters() != null) {
((FunctionType) recvType).getParameters().iterator();
if (arg.getJSType() instanceof FunctionType) {
((FunctionType) arg.getJSType()).getTypeOfThis(),
arg, thisType, (FunctionType) paramType));
FunctionType callType = null;
if (propType instanceof FunctionType) {
callType = (FunctionType) propType;
if (getConcreteFunction((FunctionType) jsType) != null) {
return getConcreteFunction((FunctionType) jsType);
functionFromJSType.put((FunctionType) decl.getJSType(), funType);
import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;
final TypeCheck outerThis = this;
final FunctionType functionType = (FunctionType) n.getJSType();
if (objectJsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) objectJsType;
JSType jsType = object2.getJSType();
if (jsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) jsType;
FunctionType type = getFunctionType(constructor);
if (type != null && type.isConstructor()) {
visitParameterList(t, n, type);
ensureTyped(t, n, type.getInstanceType());
FunctionType functionType = (FunctionType) n.getJSType();
if (childType instanceof FunctionType) {
FunctionType functionType = (FunctionType) childType;
if (jsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) jsType;
private FunctionType getFunctionType(Node n) {
JSType type = getJSType(n).restrictByNotNullOrUndefined();
if (type.isUnknownType()) {
return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);
return (FunctionType) type;
return null;
type instanceof FunctionType ||
if (functionType instanceof FunctionType) {
FunctionType fnType = (FunctionType) functionType;
JSType iParameterType = iParameter.getJSType();
if (iParameterType instanceof FunctionType) {
FunctionType iParameterFnType = (FunctionType) iParameterType;
iArgumentType instanceof FunctionType &&
if (jParameterType instanceof FunctionType) {
FunctionType jParameterFnType = (FunctionType) jParameterType;
jArgumentType instanceof FunctionType) {
FunctionType jArgumentFnType = (FunctionType) jArgumentType;
FunctionType ct = (FunctionType) constructorType;
if (ct.isConstructor()) {
if (found instanceof FunctionType &&
required instanceof FunctionType) {
FunctionType fnTypeA = ((FunctionType) found);
FunctionType fnTypeB = ((FunctionType) required);
if (type instanceof FunctionType) {
FunctionType funType = (FunctionType) fnNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
if (var != null && var.getType() instanceof FunctionType) {
FunctionType aliasedType  = (FunctionType) var.getType();
functionType = (FunctionType) type;
if (propType instanceof FunctionType) {
return (FunctionType) propType;
if (propType instanceof FunctionType) {
return (FunctionType) propType;
if (type instanceof FunctionType &&
FunctionType fnType = (FunctionType) type;
&& type instanceof FunctionType
.setPrototypeBasedOn(((FunctionType) type).getInstanceType());
(FunctionType) rValue.getJSType(), info, lValue)) {
return o instanceof FunctionType ? ((FunctionType) o) : null;
ObjectType ownerType = getObjectSlot(ownerName);
if (ownerType instanceof FunctionType) {
JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();
defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),
true);
FunctionType functionType = (FunctionType) functionNode.getJSType();
public boolean isEnumElementType() {
return true;
public boolean isFunctionType() {
return true;
FunctionType other = null;
if (that instanceof FunctionType) {
other = (FunctionType) that;
if (!(otherType instanceof FunctionType)) {
return false;
FunctionType that = (FunctionType) otherType;
if (!that.isFunctionType()) {
if (((FunctionType) that).isInterface()) {
FunctionType other = (FunctionType) that;
subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
public boolean isFunctionType() {
return false;
public boolean isEnumElementType() {
return false;
if (thisType instanceof EnumElementType) {
JSType inf = ((EnumElementType) thisType).meet(thatType);
JSType inf = ((EnumElementType) thatType).meet(thisType);
if ((value instanceof FunctionType) &&
(value.isConstructor() || value.isInterface())) {
FunctionType functionType = (FunctionType) value;
public boolean isFunctionType() {
return false;
public boolean isEnumElementType() {
return referencedType.isEnumElementType();putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));
if (getProp(SOURCENAME_PROP) == null) {
sourcePosition = other.sourcePosition;+ "because of type {1} node {2}");
(type == null ? "null" : type.toString()), n.toString()));
(type == null ? "null" : type.toString()), n.toString()));
child = child.getNext();
registerMismatch(rightType, leftType);
registerMismatch(rightType, leftType);
registerMismatch(overridingType, hiddenType);
if (shouldReport) {
compiler.report(
t.makeError(n, HIDDEN_PROPERTY_MISMATCH,
propertyName, ownerType.toString(),
hiddenType.toString(), overridingType.toString()));
if (shouldReport) {
compiler.report(
t.makeError(n, MISSING_EXTENDS_TAG_WARNING,
subObject.toString()));
registerMismatch(superObject, declaredSuper);
if (shouldReport) {
compiler.report(
t.makeError(n, INVALID_CAST,
castType.toString(), type.toString()));
registerMismatch(type, castType);
if (shouldReport) {
compiler.report(
JSError.make(sourceName, n, DUP_VAR_DECLARATION,
variableName, newType.toString(), var.getInputName(),
String.valueOf(var.nameNode.getLineno()),
varType.toString()));
if (shouldReport) {
compiler.report(JSError.make(sourceName, n,
INTERFACE_METHOD_NOT_IMPLEMENTED,
prop, implementedInterface.toString(), instance.toString()));
registerMismatch(instance, implementedInterface);
if (shouldReport) {
FunctionType constructor
= implementedInterface.toObjectType().getConstructor();
compiler.report(t.makeError(n,
HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,
constructor.getTopMostDefiningType(prop).toString(),
required.toString(), found.toString()));
registerMismatch(found, required);
registerMismatch(found, required);
if (shouldReport) {
compiler.report(
JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,
formatFoundRequired(msg, found, required)));
private void registerMismatch(JSType found, JSType required) {
mismatches.add(new TypeMismatch(found, required));
paramItB.next().getJSType());
registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType());
private void registerIfMismatch(JSType found, JSType required) {
registerMismatch(found, required);
TypeMismatch(JSType a, JSType b) {
new TypeMismatch(firstFunction, secondFunction),
new TypeMismatch(firstFunction, secondFunction),
registry.getNativeType(a), registry.getNativeType(b));LocationMapping(String prefix, String replacement) {if (that != null) {
if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
return true;
return this.isImplicitPrototype(thatObj);
return false;return TernaryValue.FALSE;
Node result = trySimpilifyUnusedResult(subtree.getFirstChild());
private Node trySimpilifyUnusedResult(Node n) {
return trySimpilifyUnusedResult(n, true);
private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {
Node trueNode = trySimpilifyUnusedResult(n.getFirstChild().getNext());
Node falseNode = trySimpilifyUnusedResult(n.getLastChild());
result = trySimpilifyUnusedResult(n.getFirstChild());
Node conditionalResultNode = trySimpilifyUnusedResult(
result = trySimpilifyUnusedResult(n.getFirstChild());
Node left = trySimpilifyUnusedResult(n.getFirstChild());
Node right = trySimpilifyUnusedResult(n.getLastChild());
c = trySimpilifyUnusedResult(c);
left = trySimpilifyUnusedResult(left);
init = trySimpilifyUnusedResult(init, false);
increment = trySimpilifyUnusedResult(increment, false);
assertBooleanTrue("true");
assertBooleanTrue("10");
assertBooleanTrue("'0'");
assertBooleanTrue("/a/");
assertBooleanTrue("{}");
assertBooleanTrue("[]");
assertBooleanFalse("false");
assertBooleanFalse("null");
assertBooleanFalse("0");
assertBooleanFalse("''");
assertBooleanFalse("undefined");
assertBooleanFalse("void 0");
assertBooleanFalse("void foo()");
assertBooleanUnknown("b");
assertBooleanUnknown("-'0.0'");
assertBooleanUnknown("{a:foo()}");
assertBooleanUnknown("[foo()]");
private void assertBooleanTrue(String val) {
private void assertBooleanFalse(String val) {
private void assertBooleanUnknown(String val) {
assertExpressionBooleanTrue("a=true");
assertExpressionBooleanFalse("a=false");
assertExpressionBooleanTrue("a=(false,true)");
assertExpressionBooleanFalse("a=(true,false)");
assertExpressionBooleanTrue("a=(false || true)");
assertExpressionBooleanFalse("a=(true && false)");
assertExpressionBooleanTrue("a=!(true && false)");
assertExpressionBooleanTrue("a,true");
assertExpressionBooleanFalse("a,false");
assertExpressionBooleanTrue("true||false");
assertExpressionBooleanFalse("false||false");
assertExpressionBooleanTrue("true&&true");
assertExpressionBooleanFalse("true&&false");
assertExpressionBooleanFalse("!true");
assertExpressionBooleanTrue("!false");
assertExpressionBooleanTrue("!''");
assertExpressionBooleanUnknown("a *= 2");
assertExpressionBooleanUnknown("2 + 2");
assertExpressionBooleanTrue("a=1");
assertExpressionBooleanTrue("a=/a/");
assertExpressionBooleanTrue("a={}");
assertExpressionBooleanTrue("true");
assertExpressionBooleanTrue("10");
assertExpressionBooleanTrue("'0'");
assertExpressionBooleanTrue("/a/");
assertExpressionBooleanTrue("{}");
assertExpressionBooleanTrue("[]");
assertExpressionBooleanFalse("false");
assertExpressionBooleanFalse("null");
assertExpressionBooleanFalse("0");
assertExpressionBooleanFalse("''");
assertExpressionBooleanFalse("undefined");
assertExpressionBooleanFalse("void 0");
assertExpressionBooleanFalse("void foo()");
assertExpressionBooleanTrue("a?true:true");
assertExpressionBooleanFalse("a?false:false");
assertExpressionBooleanUnknown("a?true:false");
assertExpressionBooleanUnknown("a?true:foo()");
assertExpressionBooleanUnknown("b");
assertExpressionBooleanUnknown("-'0.0'");
assertExpressionBooleanTrue("{a:foo()}");
assertExpressionBooleanTrue("[foo()]");
private void assertExpressionBooleanTrue(String val) {
private void assertExpressionBooleanFalse(String val) {
private void assertExpressionBooleanUnknown(String val) {private final HotSwapPassFactory checkControlStructures =
private final HotSwapPassFactory checkRequires =
private final HotSwapPassFactory checkProvides =
private final PassFactory generateExports =
private final PassFactory exportTestFunctions =
private final PassFactory replaceMessages =
private final PassFactory closureCheckGetCssName =
private final PassFactory closureReplaceGetCssName =
private final PassFactory createSyntheticBlocks =
private final PassFactory peepholeOptimizations =
private final PassFactory latePeepholeOptimizations =
private final HotSwapPassFactory checkVars =
private final PassFactory checkRegExp =
private final PassFactory checkShadowVars =
private final HotSwapPassFactory checkVariableReferences =
private final PassFactory objectPropertyStringPreprocess =
private final HotSwapPassFactory checkTypes =
private final HotSwapPassFactory checkControlFlow =
private final HotSwapPassFactory checkAccessControls =
private class GlobalTypeResolver implements HotSwapCompilerPass {
private final PassFactory checkGlobalNames =
private final PassFactory checkStrictMode =
private final PassFactory checkConsts =
private final PassFactory computeFunctionNames =
private final PassFactory ignoreCajaProperties =
private final PassFactory runtimeTypeCheck =
private final PassFactory replaceIdGenerators =
private final PassFactory replaceStrings =
private final PassFactory optimizeArgumentsArray =
private final PassFactory closureCodeRemoval =
private final PassFactory closureOptimizePrimitives =
private final PassFactory collapseProperties =
private final PassFactory collapseObjectLiterals =
private final PassFactory tightenTypesBuilder =
private final PassFactory disambiguateProperties =
private final PassFactory chainCalls =
private final PassFactory devirtualizePrototypeMethods =
private final PassFactory optimizeCallsAndRemoveUnusedVars =
private final PassFactory markPureFunctions =
private final PassFactory markNoSideEffectCalls =
private final PassFactory inlineVariables =
private final PassFactory inlineConstants =
private final PassFactory minimizeExitPoints =
private final PassFactory removeUnreachableCode =
private final PassFactory removeUnusedPrototypeProperties =
private final PassFactory smartNamePass =
private final PassFactory smartNamePass2 =
private final PassFactory inlineSimpleMethods =
private final PassFactory deadAssignmentsElimination =
private final PassFactory inlineFunctions =
private final PassFactory removeUnusedVars =
private final PassFactory crossModuleCodeMotion =
private final PassFactory crossModuleMethodMotion =
private final PassFactory specializeInitialModule =
private final PassFactory flowSensitiveInlineVariables =
private final PassFactory coalesceVariableNames =
private final PassFactory exploitAssign =
private final PassFactory collapseVariableDeclarations =
private final PassFactory groupVariableDeclarations =
private final PassFactory extractPrototypeMemberDeclarations =
private final PassFactory rewriteFunctionExpressions =
private final PassFactory collapseAnonymousFunctions =
private final PassFactory moveFunctionDeclarations =
private final PassFactory nameUnmappedAnonymousFunctions =
private final PassFactory nameMappedAnonymousFunctions =
private final PassFactory operaCompoundAssignFix =
private final PassFactory aliasExternals =
private final PassFactory aliasStrings =
private final PassFactory aliasKeywords =
private final PassFactory objectPropertyStringPostprocess =
private final PassFactory ambiguateProperties =
private final PassFactory markUnnormalized =
private final PassFactory denormalize =
private final PassFactory invertContextualRenaming =
private final PassFactory renameProperties =
private final PassFactory renameVars =
private final PassFactory renameLabels =
private final PassFactory convertToDottedProperties =
private final PassFactory sanityCheckAst =
private final PassFactory sanityCheckVars =
private final PassFactory instrumentFunctions =
private final PassFactory printNameReferenceGraph =
private final PassFactory printNameReferenceReport =void setNext(PropListItem next);
private PropListItem next;
public void setNext(PropListItem next) {
this.next = next;
item.setNext(result);
return item;case '\0': sb.append("\\000"); break;
assertPrint("var x ='\\0';", "var x=\"\\000\"");
assertPrint("var x ='\\x00';", "var x=\"\\000\"");
assertPrint("var x ='\\u0000';", "var x=\"\\000\"");
assertPrint("var x ='\\u00003';", "var x=\"\\0003\"");public abstract class ObjectType extends JSType {
if (properties.get(propertyName) != null) {
return true;
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
if (implicitPrototype.hasProperty(propertyName)) {
return true;
for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
if (interfaceType.hasProperty(propertyName)) {
return true;
return false;
Property p = properties.get(property);
if (p == null) {
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.isPropertyTypeDeclared(property);
return !p.inferred;
Property p = properties.get(property);
if (p == null) {
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.isPropertyTypeInferred(property);
return p.inferred;
public JSType getPropertyType(String propertyName) {
Property p = properties.get(propertyName);
if (p != null) {
return p.type;
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.getPropertyType(propertyName);
return getNativeType(JSTypeNative.UNKNOWN_TYPE);
Property newProp = new Property(type, inferred, inExterns, propertyNode);
private static final class Property implements Serializable {
private Property(JSType type, boolean inferred, boolean inExterns,
Node propertyNode) {
subIface.setExtendedInterfaces(Lists.<ObjectType>newArrayList(iface));typeNode = parseAndRecordTypeNode(token, lineno, charno);
private Node parseAndRecordTypeNode(JsDocToken token, int lineno,
int startCharno) {
return parseAndRecordTypeNode(token, lineno, startCharno,
token == JsDocToken.LC, false);
assertDocumentationInMarker(
assertAnnotationMarker(jsdoc, "return", 0, 0),if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {this.options.initDeserializedProperties();
private transient ComposeWarningsGuard warningsGuard =
void initDeserializedProperties() {
if (warningsGuard == null) {
warningsGuard = new ComposeWarningsGuard();
new Comparator<WarningsGuard>() {
public class DiagnosticGroup {
public class DiagnosticType implements Comparable<DiagnosticType> {
public abstract class WarningsGuard {do {import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;
if (comment.getCommentType() == JSDOC && !comment.isParsed()) {
"/* @return {T} */\n" +
"/* @return {T} */\n" +package com.google.javascript.jscomp;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
class LocaleUtil {
private static final Pattern LOCALE_PATTERN =
Pattern.compile("(^[^_-]*)(?:[_-]([^_-]*)(?:[_-]([^_-]*))?)?");
static Locale getLocaleFromStandardLocaleString(String s) {
if (s == null) {
return null;
Matcher matcher = LOCALE_PATTERN.matcher(s);
matcher.find();
String language = Strings.makeSafe(matcher.group(1));
String country = Strings.makeSafe(matcher.group(2));
String variant = Strings.makeSafe(matcher.group(3));
return new Locale(language, country, variant);return options.getLanguageIn() == LanguageMode.ECMASCRIPT5;OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {
this(compiler);
buildParameterList(parameters, cur);
findConstantParameters(parameters, cur);
optimizeCallSite(parameters, call);
private void findConstantParameters(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, false));
Node value = parameters.get(index).getArg();
if (!nodesAreEqual(cur, value)) {
parameters.get(index).setShouldRemove(false);
private void buildParameterList(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));
private void optimizeCallSite(List<Parameter> parameters, Node call) {
if (parameters.get(index).shouldRemove()) {
eliminateCallParamAt(call, index);
private boolean nodesAreEqual(Node n1, Node n2) {
return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&
n1.isEquivalentTo(n2);
Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),
value.cloneTree());
private Node eliminateCallParamAt(Node call, int argIndex) {
new UseSite(node, traversal.getModule()));
this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null));
UseSite(Node node, JSModule module) {
String src = "function foo(bar) {};" +
"baz = function(a) {};" +
"baz(1);" +
"foo(baz);"; // Baz should be aliased.
testSame(src);new PeepholeFoldConstants());
VariableMap map = null;
if (first.getType() == Token.STRING) {
"var goog = {}; goog.dom = {};");
String prefix =
"var goog = {}; goog.getCssName = function() {};" +
"goog.setCssNameMapping = function() {};";
test(prefix + "goog.setCssNameMapping({'goog': 'a', 'button': 'b'});" +
prefix +
"var a = 'a-b'," +
String resultB = process(exprB);import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
import com.google.javascript.jscomp.Scope.Var;
private List<Node> removedNodes = Lists.newArrayList();
Preconditions.checkState(
compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
for (Node n : removedNodes) {
definitions.removeReferences(n);
boolean continueLooking = false;
continueLooking = buildParameterList(parameters, cur, site.scope);
continueLooking= findFixedParameters(parameters, cur);
if (!continueLooking) {
return;
continueLooking = adjustForSideEffects(parameters);
if (!continueLooking) {
return;
optimizeCallSite(defFinder, parameters, call);
private boolean adjustForSideEffects(List<Parameter> parameters) {
boolean anyMovable = false;
boolean seenUnmovableSideEffects = false;
boolean seenUnmoveableSideEfffected = false;
for (int i = parameters.size() - 1; i >= 0; i--) {
Parameter current = parameters.get(i);
if (current.shouldRemove
&& ((seenUnmovableSideEffects && current.canBeSideEffected())
|| (seenUnmoveableSideEfffected && current.hasSideEffects()))) {
current.shouldRemove = false;
if (current.shouldRemove) {
anyMovable = true;
if (current.canBeSideEffected) {
seenUnmoveableSideEfffected = true;
if (current.hasSideEffects) {
seenUnmovableSideEffects = true;
return anyMovable;
private boolean findFixedParameters(List<Parameter> parameters, Node cur) {
boolean anyMovable = false;
Parameter p;
p = new Parameter(cur, false);
parameters.add(p);
p = parameters.get(index);
if (p.shouldRemove()) {
Node value = p.getArg();
if (!cur.isEquivalentTo(value)) {
p.setShouldRemove(false);
anyMovable = true;
setParameterSideEffectInfo(p, cur);
return anyMovable;
private boolean buildParameterList(
List<Parameter> parameters, Node cur, Scope s) {
boolean anyMovable = false;
boolean movable = isMovableValue(cur, s);
Parameter p = new Parameter(cur, movable);
setParameterSideEffectInfo(p, cur);
parameters.add(p);
if (movable) {
anyMovable = true;
return anyMovable;
private void setParameterSideEffectInfo(Parameter p, Node value) {
if (!p.hasSideEffects()) {
p.setHasSideEffects(NodeUtil.mayHaveSideEffects(value, compiler));
if (!p.canBeSideEffected()) {
p.setCanBeSideEffected(NodeUtil.canBeSideEffected(value));
private boolean isMovableValue(Node n, Scope s) {
switch (n.getType()) {
case Token.THIS:
return false;
case Token.FUNCTION:
return false;
case Token.NAME:
if (n.getString().equals("arguments")) {
return false;
Var v = s.getVar(n.getString());
if (v != null && v.isLocal()) {
return false;
break;
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (!isMovableValue(c, s)) {
return false;
return true;
private void optimizeCallSite(
SimpleDefinitionFinder defFinder, List<Parameter> parameters, Node call) {
Parameter p = parameters.get(index);
if (p.shouldRemove()) {
eliminateCallParamAt(defFinder, p, call, index);
private boolean hasSideEffects;
private boolean canBeSideEffected;
public void setHasSideEffects(boolean hasSideEffects) {
this.hasSideEffects = hasSideEffects;
public boolean hasSideEffects() {
return hasSideEffects;
public void setCanBeSideEffected(boolean canBeSideEffected) {
this.canBeSideEffected = canBeSideEffected;
public boolean canBeSideEffected() {
return canBeSideEffected;
Preconditions.checkState(value.getParent() == null);
Node newVar = NodeUtil.newVarNode(varName.getString(), value);
private Node eliminateCallParamAt(
SimpleDefinitionFinder defFinder, Parameter p, Node call, int argIndex) {
if (p.getArg() != formalArgPtr) {
removedNodes.add(formalArgPtr);
new UseSite(node, traversal.getScope(), traversal.getModule()));
this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));
final Scope scope;
UseSite(Node node, Scope scope, JSModule module) {
this.scope = scope;
super.enableNormalize();
test(
"function foo(bar) {};" +
"baz = function(a) {};" +
"baz(1);" +
"foo(baz);",
"function foo() {var bar = baz};" +
"baz = function(a) {};" +
"baz(1);" +
"foo();");
public void testMutableValues1() {
test("function foo(p1) {} foo()",
"function foo() {var p1} foo()");
test("function foo(p1) {} foo(1)",
"function foo() {var p1=1} foo()");
test("function foo(p1) {} foo([])",
"function foo() {var p1=[]} foo()");
test("function foo(p1) {} foo({})",
"function foo() {var p1={}} foo()");
test("var x;function foo(p1) {} foo(x)",
"var x;function foo() {var p1=x} foo()");
test("var x;function foo(p1) {} foo(x())",
"var x;function foo() {var p1=x()} foo()");
test("var x;function foo(p1) {} foo(new x())",
"var x;function foo() {var p1=new x()} foo()");
test("var x;function foo(p1) {} foo('' + x)",
"var x;function foo() {var p1='' + x} foo()");
testSame("function foo(p1) {} foo(this)");
testSame("function foo(p1) {} foo(arguments)");
testSame("function foo(p1) {} foo(function(){})");
testSame("function foo(p1) {} (function () {var x;foo(x)})()");
public void testMutableValues2() {
test("function foo(p1, p2) {} foo(1, 2)",
"function foo() {var p1=1; var p2 = 2} foo()");
test("var x; var y; function foo(p1, p2) {} foo(x(), y())",
"var x; var y; function foo() {var p1=x(); var p2 = y()} foo()");
public void testMutableValues3() {
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"foo(x(), y()); foo(x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=x(); var p2=y()}" +
"foo(); foo()");
public void testMutableValues4() {
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo(x(), y(), z()); foo(x(),y(),3)");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo(x, y(), z()); foo(x,y(),3)");
test(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo([], y(), z()); foo([],y(),3)",
"var x; var y; var z;" +
"function foo(p2, p3) {var p1=[]}" +
"foo(y(), z()); foo(y(),3)");
public void testMutableValues5() {
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"new foo(new x(), y()); new foo(new x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=new x(); var p2=y()}" +
"new foo(); new foo()");
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"new foo(x(), y()); new foo(x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=x(); var p2=y()}" +
"new foo(); new foo()");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo(x(), y(), z()); new foo(x(),y(),3)");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo(x, y(), z()); new foo(x,y(),3)");
test(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo([], y(), z()); new foo([],y(),3)",
"var x; var y; var z;" +
"function foo(p2, p3) {var p1=[]}" +
"new foo(y(), z()); new foo(y(),3)");
public void testShadows() {
testSame("function foo(a) {}" +
"var x;" +
"function f() {" +
"  var x;" +
"  function g() {" +
"    foo(x());" +
"  }" +
"};" +
"foo(x())");
public void testCrash() {
test(
"function foo(a) {}" +
"foo({o:1});" +
"foo({o:1})",
"function foo() {var a = {o:1}}" +
"foo();" +
"foo()");OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {
this(compiler);
buildParameterList(parameters, cur);
findConstantParameters(parameters, cur);
optimizeCallSite(parameters, call);
private void findConstantParameters(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, false));
Node value = parameters.get(index).getArg();
if (!nodesAreEqual(cur, value)) {
parameters.get(index).setShouldRemove(false);
private void buildParameterList(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));
private void optimizeCallSite(List<Parameter> parameters, Node call) {
if (parameters.get(index).shouldRemove()) {
eliminateCallParamAt(call, index);
private boolean nodesAreEqual(Node n1, Node n2) {
return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&
n1.isEquivalentTo(n2);
Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),
value.cloneTree());
private Node eliminateCallParamAt(Node call, int argIndex) {
new UseSite(node, traversal.getModule()));
this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null));
UseSite(Node node, JSModule module) {
String src = "function foo(bar) {};" +
"baz = function(a) {};" +
"baz(1);" +
"foo(baz);"; // Baz should be aliased.
testSame(src);import com.google.javascript.jscomp.CheckLevel;
private final CheckLevel level;
CheckGlobalThis(AbstractCompiler compiler, CheckLevel level) {
this.level = level;
compiler.report(t.makeError(n, level, GLOBAL_THIS));
if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
options.checkTypes = true;
options.checkTypes = false;
guards.add(
new DiagnosticGroupWarningsGuard(
DiagnosticGroup.forType(
RhinoErrorReporter.TYPE_PARSE_ERROR),
CheckLevel.OFF));
options.checkGlobalThisLevel.isOn()) {
CheckLevel checkGlobalThisLevel = options.checkGlobalThisLevel;
if (checkGlobalThisLevel.isOn()) {
sharedCallbacks.add(
new CheckGlobalThis(compiler, checkGlobalThisLevel));
"externsValidation, fileoverviewTags, internetExplorerChecks, " +
"invalidCasts, missingProperties, nonStandardJsDocs, " +
"strictModuleDepCheck, typeInvalidation, " +
import com.google.javascript.jscomp.CheckLevel;
compiler, new CheckGlobalThis(compiler, CheckLevel.ERROR));
test(js, null, CheckGlobalThis.GLOBAL_THIS);import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
import com.google.javascript.jscomp.Scope.Var;
Preconditions.checkState(
compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
boolean continueLooking = false;
continueLooking = buildParameterList(parameters, cur, site.scope);
continueLooking= findFixedParameters(parameters, cur);
if (!continueLooking) {
return;
continueLooking = adjustForSideEffects(parameters);
if (!continueLooking) {
return;
optimizeCallSite(defFinder, parameters, call);
private boolean adjustForSideEffects(List<Parameter> parameters) {
boolean anyMovable = false;
boolean seenUnmovableSideEffects = false;
boolean seenUnmoveableSideEfffected = false;
for (int i = parameters.size() - 1; i >= 0; i--) {
Parameter current = parameters.get(i);
if (current.shouldRemove
&& ((seenUnmovableSideEffects && current.canBeSideEffected())
|| (seenUnmoveableSideEfffected && current.hasSideEffects()))) {
current.shouldRemove = false;
if (current.shouldRemove) {
anyMovable = true;
if (current.canBeSideEffected) {
seenUnmoveableSideEfffected = true;
if (current.hasSideEffects) {
seenUnmovableSideEffects = true;
return anyMovable;
private boolean findFixedParameters(List<Parameter> parameters, Node cur) {
boolean anyMovable = false;
Parameter p;
p = new Parameter(cur, false);
parameters.add(p);
p = parameters.get(index);
if (p.shouldRemove()) {
Node value = p.getArg();
if (!cur.isEquivalentTo(value)) {
p.setShouldRemove(false);
anyMovable = true;
setParameterSideEffectInfo(p, cur);
return anyMovable;
private boolean buildParameterList(
List<Parameter> parameters, Node cur, Scope s) {
boolean anyMovable = false;
boolean movable = isMovableValue(cur, s);
Parameter p = new Parameter(cur, movable);
setParameterSideEffectInfo(p, cur);
parameters.add(p);
if (movable) {
anyMovable = true;
return anyMovable;
private void setParameterSideEffectInfo(Parameter p, Node value) {
if (!p.hasSideEffects()) {
p.setHasSideEffects(NodeUtil.mayHaveSideEffects(value, compiler));
if (!p.canBeSideEffected()) {
p.setCanBeSideEffected(NodeUtil.canBeSideEffected(value));
private boolean isMovableValue(Node n, Scope s) {
switch (n.getType()) {
case Token.THIS:
return false;
case Token.FUNCTION:
return false;
case Token.NAME:
if (n.getString().equals("arguments")) {
return false;
Var v = s.getVar(n.getString());
if (v != null && v.isLocal()) {
return false;
break;
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (!isMovableValue(c, s)) {
return false;
return true;
private void optimizeCallSite(
SimpleDefinitionFinder defFinder, List<Parameter> parameters, Node call) {
Parameter p = parameters.get(index);
if (p.shouldRemove()) {
eliminateCallParamAt(defFinder, p, call, index);
private boolean hasSideEffects;
private boolean canBeSideEffected;
public void setHasSideEffects(boolean hasSideEffects) {
this.hasSideEffects = hasSideEffects;
public boolean hasSideEffects() {
return hasSideEffects;
public void setCanBeSideEffected(boolean canBeSideEffected) {
this.canBeSideEffected = canBeSideEffected;
public boolean canBeSideEffected() {
return canBeSideEffected;
Preconditions.checkState(value.getParent() == null);
Node newVar = NodeUtil.newVarNode(varName.getString(), value);
private Node eliminateCallParamAt(
SimpleDefinitionFinder defFinder, Parameter p, Node call, int argIndex) {
if (p.getArg() != formalArgPtr) {
defFinder.removeReferences(formalArgPtr);
new UseSite(node, traversal.getScope(), traversal.getModule()));
this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));
final Scope scope;
UseSite(Node node, Scope scope, JSModule module) {
this.scope = scope;
super.enableNormalize();
test(
"function foo(bar) {};" +
"baz = function(a) {};" +
"baz(1);" +
"foo(baz);",
"function foo() {var bar = baz};" +
"baz = function(a) {};" +
"baz(1);" +
"foo();");
public void testMutableValues1() {
test("function foo(p1) {} foo()",
"function foo() {var p1} foo()");
test("function foo(p1) {} foo(1)",
"function foo() {var p1=1} foo()");
test("function foo(p1) {} foo([])",
"function foo() {var p1=[]} foo()");
test("function foo(p1) {} foo({})",
"function foo() {var p1={}} foo()");
test("var x;function foo(p1) {} foo(x)",
"var x;function foo() {var p1=x} foo()");
test("var x;function foo(p1) {} foo(x())",
"var x;function foo() {var p1=x()} foo()");
test("var x;function foo(p1) {} foo(new x())",
"var x;function foo() {var p1=new x()} foo()");
test("var x;function foo(p1) {} foo('' + x)",
"var x;function foo() {var p1='' + x} foo()");
testSame("function foo(p1) {} foo(this)");
testSame("function foo(p1) {} foo(arguments)");
testSame("function foo(p1) {} foo(function(){})");
testSame("function foo(p1) {} (function () {var x;foo(x)})()");
public void testMutableValues2() {
test("function foo(p1, p2) {} foo(1, 2)",
"function foo() {var p1=1; var p2 = 2} foo()");
test("var x; var y; function foo(p1, p2) {} foo(x(), y())",
"var x; var y; function foo() {var p1=x(); var p2 = y()} foo()");
public void testMutableValues3() {
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"foo(x(), y()); foo(x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=x(); var p2=y()}" +
"foo(); foo()");
public void testMutableValues4() {
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo(x(), y(), z()); foo(x(),y(),3)");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo(x, y(), z()); foo(x,y(),3)");
test(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"foo([], y(), z()); foo([],y(),3)",
"var x; var y; var z;" +
"function foo(p2, p3) {var p1=[]}" +
"foo(y(), z()); foo(y(),3)");
public void testMutableValues5() {
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"new foo(new x(), y()); new foo(new x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=new x(); var p2=y()}" +
"new foo(); new foo()");
test(
"var x; var y; var z;" +
"function foo(p1, p2) {}" +
"new foo(x(), y()); new foo(x(),y())",
"var x; var y; var z;" +
"function foo() {var p1=x(); var p2=y()}" +
"new foo(); new foo()");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo(x(), y(), z()); new foo(x(),y(),3)");
testSame(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo(x, y(), z()); new foo(x,y(),3)");
test(
"var x; var y; var z;" +
"function foo(p1, p2, p3) {}" +
"new foo([], y(), z()); new foo([],y(),3)",
"var x; var y; var z;" +
"function foo(p2, p3) {var p1=[]}" +
"new foo(y(), z()); new foo(y(),3)");
public void testShadows() {
testSame("function foo(a) {}" +
"var x;" +
"function f() {" +
"  var x;" +
"  function g() {" +
"    foo(x());" +
"  }" +
"};" +
"foo(x())");OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {
this(compiler);
buildParameterList(parameters, cur);
findConstantParameters(parameters, cur);
optimizeCallSite(parameters, call);
private void findConstantParameters(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, false));
Node value = parameters.get(index).getArg();
if (!nodesAreEqual(cur, value)) {
parameters.get(index).setShouldRemove(false);
private void buildParameterList(List<Parameter> parameters, Node cur) {
parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));
private void optimizeCallSite(List<Parameter> parameters, Node call) {
if (parameters.get(index).shouldRemove()) {
eliminateCallParamAt(call, index);
private boolean nodesAreEqual(Node n1, Node n2) {
return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&
n1.isEquivalentTo(n2);
Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),
value.cloneTree());
private Node eliminateCallParamAt(Node call, int argIndex) {
new UseSite(node, traversal.getModule()));
this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null));
UseSite(Node node, JSModule module) {
String src = "function foo(bar) {};" +
"baz = function(a) {};" +
"baz(1);" +
"foo(baz);"; // Baz should be aliased.
testSame(src);static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(
"JSC_DIVIDE_BY_0_ERROR",
"Divide by 0");
error(DIVIDE_BY_0_ERROR, right);
error(DIVIDE_BY_0_ERROR, right);
fold("x = 1 / 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
fold("x = 1 % 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);boolean first = (n == parent.getFirstChild()); 
if (needToCheckDuplications 
&& !isUnnamedMsg 
newName = original + 
private static final Predicate<Node> NOT_FUNCTION_PREDICATE = 
locationAbstraction = createVisibilityAbstraction(externs, root); 
public boolean safeToMoveBefore(Node source, 
if (node1DeepestControlDependentBlock == 
private static Node closestControlDependentAncestor(Node node) { 
public LocationSummary calculateLocationSummary(Set<Node> nodes) {     
private static class DegenerateLocationAbstraction 
private static class VisibilityLocationAbstraction 
int visibilityModLocations = VISIBILITY_LOCATION_NONE;    
private int effectMaskForVariableReference(Node variableReference) { 
Node declaringNameNode = 
VariableVisibility visibility = 
throw new IllegalStateException("Unrecognized variable" + 
boolean nonSimpleAssign = 
return (nonSimpleAssign 
|| parent.getType() == Token.INC);      
private static class VisibilityBasedEffectLocation 
Preconditions.checkArgument(otherLocation instanceof 
int otherMask = 
Preconditions.checkArgument(otherLocation instanceof 
int otherMask = 
return new VisibilityBasedEffectLocation(joinedMask);       
ReferenceCollectingCallback callback = 
new ReferenceCollectingCallback(compiler, 
for (Reference reference : referenceCollection.references) {      
</pre>
sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth));
int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length);
AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat();
private static ThreadLocal<ThreadTrace> traces = new ThreadLocal<ThreadTrace>();
private ConcurrentMap<String, Long> map = new ConcurrentHashMap<String, Long>();
ReferenceCollectingCallback callback = 
new ReferenceCollectingCallback(compiler, 
visibility = VariableVisibility.PARAMETER;     
visibility = VariableVisibility.CAPTURED_LOCAL;        
visibility = VariableVisibility.LOCAL;          
private static Logger logger = Logger.getLogger(JsFunctionParser.class.getName());
public JsFunctionParser(Collection<String> functions, ErrorManager errorManager) {
public Collection<SymbolInfo> parseFile(String filePath, String fileContents) {
private Collection<SymbolInfo> parseReader(String filePath, Reader fileContents) {
String arg = parseJsString(matcher.group(2)); // Parse the param.  
public void markText(String text, int startLineno, int startCharno, int endLineno,
int endCharno) {
public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,
boolean hasLC) {
public boolean recordParameterDescription(String parameterName, String description) {
public boolean recordThrowDescription(JSTypeExpression type, String description) {
Implementation of resizable array with focus on minimizing memory usage by storing few initial array elements in object fields. Can also be used as a stack.
nf.createCatch(varName, nameLineno, nameCharno, catchCond,
statements(), catchLineno, catchCharno));
pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit), lineno,
ts.getLineno(), ts.getCharno());                        break;
case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;
case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;
case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;
case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;
case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;
else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {
id=Id_char; break L0;} }
else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {
else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {
static final String SHARED_EXTERNS = 
public void testGetAllFunctions() {  
String source = 
"(function C(){A()})()\n" + 
CallGraph.Function functionA = 
assertTrue(allFunctions.contains(functionA));  
String source = 
callgraph.getUniqueFunctionWithName("namespace.A")));  
String source = 
String source = 
CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");   
public void testFunctionGetCallsites() {  
String source = 
"(function C(){A()})()\n" + 
CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
String source = 
assertEquals(1, targetsOfCallsiteInC.size());    
String source = 
assertEquals(1, targetsOfCallsiteInC.size());    
String source = 
"(function (){A()})()\n" + 
assertEquals("A", callsiteNode.getFirstChild().getString()); 
assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());    
public void testGetDirectedGraph_backwardOnBackward() { 
.computeFixedPoint(callgraph.getBackwardDirectedGraph());  
callgraph.getUniqueFunctionWithName("E")));   
public void testGetDirectedGraph_backwardOnForward() { 
.computeFixedPoint(callgraph.getBackwardDirectedGraph());  
callgraph.getUniqueFunctionWithName("E")));   
public void testGetDirectedGraph_forwardOnForward() { 
"function Y(){Z()};\n" + 
.computeFixedPoint(callgraph.getForwardDirectedGraph());  
callgraph.getUniqueFunctionWithName("E"))); 
public void testGetDirectedGraph_forwardOnBackward() { 
"function Y(){Z()};\n" + 
.computeFixedPoint(callgraph.getForwardDirectedGraph());  
callgraph.getUniqueFunctionWithName("E"))); 
assertTrue(callsiteNamesInMain.contains("A"));    
CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A");  
assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC)); 
CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C");  
public void testFunctionGetIsAliased() { 
public void testFunctionGetIsExposedToCallOrApply() { 
Function functionA = callgraph.getUniqueFunctionWithName("A");   
assertEquals(0, callInB.getPossibleTargets().size());  
assertNotNull(caughtException);    
fail();   
callsites) { 
private static final String GET_NAMES = 
assertEquals(6, cb.getColumnIndex());    
"function cow() { a++; }; cow(); var z = x;"}, 
compiler.initOptions(new CompilerOptions());    
"var x = undefined;\"undefined\""); 
currentCompiler = compiler;   
if (currentLocationAbstractionIdentifier == 
public void testDegenerateSafeMoves() {      
public void testVisibilitySafeMoves() {      
"}");   
"case 18:" + 
analysis.analyze(finder);  
public void testFunctionGetIsAliased() { 
public void testFunctionGetIsExposedToCallOrApply() { 
devirtualizePrototypeMethods, inlineFunctions, 
return new CompilerPass() {     
new VarCheck(compiler).process(externs, root);       
"var A = function() {alert(B());A()};" + 
"A();",       
"var A = function() {alert(6);A()};" + /* Specialized A */    
"var B;",    
"var A = function() {alert(B());A()};" + 
"A();",       
"var A = function() {alert(6);A()};" + /* Specialized A */    
"var B, C;",    
"var A = function() {alert(B());A()};" + 
"A();",       
"var A = function() {alert(6);A()};" + /* Specialized A */    
"var B;",    
"ns.A = function() {alert(B());ns.A()};" + 
"ns.A();",       
"ns.A = function() {alert(6);ns.A()};" + /* Specialized A */    
"var B;",    
"function A() {alert(B());A()}" + 
"A();",       
"function A() {alert(6);A()}" + /* Specialized A */    
"var B;",    
"function() {alert(6)};noSpecialize()})()",       
"function() {alert(6)};noSpecialize()})()", 
"var A = function() {alert(B() + C());A()};" + 
"A();",       
"var A = function() {alert(6 + 8);A()};" + /* Specialized A */    
"var B, C;",    
"Foo.prototype.a = function() {this.a()};" + 
"x.a();",       
"x.a();", 
"Foo.prototype.c = function() {return 7};"        
"function A() {alert(B());A()}" + 
"A();",       
"function A() {alert(B());A()}" + 
"A();",       
"Foo.prototype.a = function() {this.a()};" + 
"var aliasC = (new Foo).c",       
"var aliasC = (new Foo).c", 
"Foo.prototype.d = function() {return 7};"        
"function(JSCompiler_StaticMethods_a$self) {" + 
public static class SpecializeModuleSpecializationStateTest 
public void process(Node externs, Node root) {         
SimpleDefinitionFinder defFinder = 
SimpleFunctionAliasAnalysis functionAliasAnalysis = 
functionAliasAnalysis.analyze(defFinder); 
lastState = new SpecializationState(functionAliasAnalysis);       
"ns.H = function(){};" + 
String source = 
String source = 
assertIsGlobal("global"); 
String source = 
assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  
assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  
assertLabeledVariableHasVisibility(label, 
VariableVisibility.CAPTURED_LOCAL); 
assertLabeledVariableHasVisibility(label, 
VariableVisibility.LOCAL); 
assertLabeledVariableHasVisibility(label, 
VariableVisibility.GLOBAL); 
&& functionName.equals(NodeUtil.getFunctionName(n))) { 
+ "goog.require(\"bar.data.SuperstarAddStarThreadActionRequestDelegate\"); "
assertEquals(symbolInfo.symbol, "bar.data.SuperstarAddStarThreadActionRequestDelegate");
TagType[] tags = private ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations;
PeepholeOptimizationsPass(AbstractCompiler compiler,
ImmutableSet<AbstractPeepholeOptimization> optimizations) {
this.compiler = compiler;
this.peepholeOptimizations = optimizations;
this(compiler, ImmutableSet.copyOf(optimizations));
return new PeepholeOptimizationsPass(compiler, currentPeepholePasses);if (child.getType() == Token.STRING) {
public void testOneType() {
public void testTwoTypes() {JSType valueType = getDeclaredTypeInAnnotation(
t, name, name.getJSDocInfo());
JSType getDeclaredTypeInAnnotation(
JSType getDeclaredTypeInAnnotation(String sourceName,
if (value != null && value.getType() == Token.FUNCTION) {
FunctionType valueType = (FunctionType) value.getJSType();
if (info != null || scope.isGlobal() ||
!valueType.isReturnTypeInferred()) {
type = value.getJSType();
private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,
Node n, @Nullable Node rhsValue) {
return getDeclaredTypeInAnnotation(t, n, info);
return rhsValue.getJSType();
if (rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) {
return rhsValue.getJSType();
rhsValue, n.getQualifiedName(), info, n);
rhsValue, n.getQualifiedName(), info, n);
return getDeclaredTypeInAnnotation(t, n, info);
JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);
JSType jsType = getDeclaredGetPropType(t, info, member, value);
"function (number): ?",
"{y: function (number): ?}",
"function (): number",
"{y: function (): number}",String param = params.getParameter(0);case Token.SET:
case Token.GET:
throw new IllegalStateException("not yet implemented");
nameNode.getQualifiedName(),
"var b=function(){};var b=function(){};b(1,2)");  transformElement(element.getChild(0), parent);
GetterProp,         // not supported by Closure Compiler
SetterProp,         // not supported by Closure Compiler
validateDataProp(element);
private void validateDataProp(JsonML element) {
validateChildType(element, TagType.DataProp, i);
Iterator<Node> it = node.children().iterator();
while (it.hasNext()) {
JsonML item = new JsonML(TagType.DataProp);
Node child = it.next();
Object name = null;
switch (child.getType()) {
name = child.getString();
name = child.getDouble();
processNode(it.next(), item);
throw new Exception(errorMsg);
TagType.ObjectExpr, TagType.DataProp, TagType.IdExpr, 1);if (propNameNode.getType() == Token.STRING &&
Property prop = new AssignmentProperty(grandParent,
grandParent.getParent(), t.getModule());
if (key.getType() == Token.STRING) {
Node getValueParent();
private final Node node;
AssignmentProperty(Node node, Node parent, JSModule module) {
this.node = node;
NodeUtil.removeChild(node.getParent(), node);
return getValueParent().getFirstChild().getFirstChild();
return getValueParent().getLastChild();
public Node getValueParent() {
return node.getFirstChild();
public Node getValueParent() {
return map;
Node valueParent = prop.getValueParent();
public void testMovePrototypeMethod() {if (isExpressBlock(thenBranch)) {
boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);
boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);
private boolean isExpressBlock(Node n) {
return NodeUtil.isExpressionNode(n.getFirstChild());
Preconditions.checkState(isExpressBlock(n));if (newVar.getInitialValue() == null && !isExtern) {
if (token == JsDocToken.STRING && "this".equals(stream.getString())) {
if (match(JsDocToken.COLON)) {
next();
skipEOLs();
Node thisType = wrapNode(Token.THIS, parseTypeName(next()));
if (thisType == null) {
return null;
functionType.addChildToFront(thisType);
return reportTypeSyntaxWarning("msg.jsdoc.missing.colon");
if (match(JsDocToken.COMMA)) {
next();
skipEOLs();
token = next();
hasParams = false;
this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ?
b.append("this:");
if (current.getType() == Token.THIS) {
Node thisNode = current.getFirstChild();
thisNode, sourceName, scope, false)
ScriptRuntime.getMessage0("msg.jsdoc.function.thisnotobject"),
sourceName, thisNode.getLineno(), "", thisNode.getCharno());
"FUNCTION a = function (this:a): undefined",
+ "Foo.function__this_Foo___undefined$a = 0;"
+ "Bar.function__this_Bar___undefined$a = 0;";
"{a=[[function (this:Bar): undefined]," +
" [function (this:Foo): undefined]]}");
+ "found   : function (this:String, *): number\n"
+ "expected: function (this:String, *): string");
+ "found   : function (this:String): string\n"
+ "expected: function (this:String, *): string");
+ "found   : function (this:String, ?, ?): string\n"
+ "expected: function (this:String, *): string");
+ "found   : function (this:String, ?): string\n"
+ "expected: function (this:String, *): string");
+ "found   : function (this:Function, ?): ?\n"
+ "expected: function (this:Function, ...[*]): ?");
"function (this:f.subclass): ?");
"variable a.A redefined with type function (this:a.A): undefined, " +
"found   : function (this:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
"function (this:derived): undefined");
"Constructor function (this:Foo): undefined should be called " +
"with type function (this:goog.Bar): undefined");
"with type function (this:goog.Bar): undefined");
"function (this:f.subclass): ?");
"variable a.A redefined with type function (this:a.A): undefined, " +
"found   : function (this:Date, ?, ?, ?, ?, ?, ?, ?): string\n" +
"function (this:derived): undefined");
"Constructor function (this:Foo): undefined should be called " +
"with type function (this:goog.Bar): undefined");
"with type function (this:goog.Bar): undefined");
assertEquals("function (this:foo.Bar): undefined", fooBar.toString());
assertEquals("function (this:Extern): ?", e.toString());
assertEquals("function (this:goog.Foo): undefined", ctor.toString());
assertEquals("function (this:Array, ...[*]): Array",
assertEquals("function (this:Boolean, *): boolean",
assertEquals("function (this:Number, *): number",
assertEquals("function (this:String, *): string",import com.google.common.collect.Iterables;
addGuards(Iterables.reverse(((ComposeWarningsGuard) guard).guards));
import com.google.common.collect.Iterables;
for (Node n : Iterables.reverse(entry.getValue())) {
private final class NodeWithJsDoc {
private Node node = null;
import com.google.common.collect.Sets;package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Collection;
import java.util.List;
import java.util.Set;
class FunctionSideEffectData {
private final boolean extern;
private final List<Node> callsInFunctionBody = Lists.newArrayList();
private final Scope localScope;
private Set<ValueEntry> nonLocalValues = Sets.newHashSet();
private Set<ValueEntry> modifiedLocals = Sets.newHashSet();
private Multimap<ValueEntry, ValueEntry> valueInfluenceMap =
HashMultimap.create();
private boolean pureFunction = false;
private boolean functionThrows = false;
private boolean taintsGlobalState = false;
private boolean taintsThis = false;
private boolean taintsArguments = false;
private boolean taintsUnknown = false;
private boolean taintsReturn = false;
interface ValueEntry {
static class KeywordValueEntry implements ValueEntry {
final static ValueEntry THIS = new KeywordValueEntry();
final static ValueEntry RETURN = new KeywordValueEntry();
final static ValueEntry ARGUMENTS = new KeywordValueEntry();
KeywordValueEntry() {}
static class NameValueEntry implements ValueEntry {
private final String name;
NameValueEntry(Node node) {
Preconditions.checkState(node.getType() == Token.NAME);
this.name = node.getString();
NameValueEntry(Var var) {
this.name = var.name;
public int hashCode() {
return name.hashCode();
public boolean equals(Object o) {
return o != null
&& o instanceof NameValueEntry
&& name.equals(((NameValueEntry)o).name);
public String toString() {
return name;
static class CallValueEntry implements ValueEntry {
private final Node node;
CallValueEntry(Node node) {
Preconditions.checkState(
node.getType() == Token.CALL || node.getType() == Token.NEW);
this.node = node;
public int hashCode() {
return node.hashCode();
public boolean equals(Object o) {
return o != null
&& o instanceof CallValueEntry
&& node.equals(((CallValueEntry)o).node);
public String toString() {
return node.toString();
FunctionSideEffectData(boolean extern, Scope scope) {
this.extern = extern;
this.localScope = scope;
checkInvariant();
Scope getScope() {
return localScope;
private Multimap<ValueEntry, ValueEntry> getValueInfluenceMap() {
return valueInfluenceMap;
boolean isInformationStable() {
return (mutatesGlobalState() && taintsReturn);
void clearLocalityState() {
nonLocalValues = null;
modifiedLocals = null;
valueInfluenceMap = null;
void addModified(Var var) {
Preconditions.checkState(var.scope == localScope);
modifiedLocals.add(new NameValueEntry(var));
void addNonLocalValue(Var var) {
Preconditions.checkState(var.scope == localScope);
nonLocalValues.add(new NameValueEntry(var));
void addInfluence(ValueEntry source, ValueEntry sink) {
valueInfluenceMap.put(source, sink);
boolean isLocalValue(Node value) {
switch (value.getType()) {
case Token.NAME:
String name = value.getString();
return getScope().isDeclared(name, false)
&& !nonLocalValues.contains(new NameValueEntry(value));
case Token.CALL:
return !nonLocalValues.contains(new CallValueEntry(value));
return false;
boolean mayBePure() {
return !(functionThrows ||
taintsGlobalState ||
taintsThis ||
taintsArguments ||
taintsUnknown);
boolean mayHaveSideEffects() {
return !pureFunction;
void setIsPure() {
pureFunction = true;
checkInvariant();
void setTaintsGlobalState() {
taintsGlobalState = true;
checkInvariant();
void setTaintsThis() {
taintsThis = true;
checkInvariant();
void setTaintsArguments() {
taintsArguments = true;
checkInvariant();
void setFunctionThrows() {
functionThrows = true;
checkInvariant();
void setTaintsUnknown() {
taintsUnknown = true;
checkInvariant();
void setTaintsReturn() {
taintsReturn = true;
checkInvariant();
boolean hasNonLocalReturnValue() {
return taintsReturn;
boolean mutatesGlobalState() {
return taintsGlobalState || taintsArguments || taintsUnknown;
boolean mutatesThis() {
return taintsThis;
boolean functionThrows() {
return functionThrows;
private void checkInvariant() {
boolean invariant = mayBePure() || mayHaveSideEffects();
if (!invariant) {
throw new IllegalStateException("Invariant failed.  " + toString());
void appendCall(Node callNode) {
callsInFunctionBody.add(callNode);
List<Node> getCallsInFunctionBody() {
return callsInFunctionBody;
public String toString() {
List<String> status = Lists.newArrayList();
if (extern) {
status.add("extern");
if (pureFunction) {
status.add("pure");
if (taintsThis) {
status.add("this");
if (taintsGlobalState) {
status.add("global");
if (functionThrows) {
status.add("throw");
if (taintsUnknown) {
status.add("complex");
return "Side effects: " + status.toString();
void normalizeValueMaps() {
if (!mutatesGlobalState() || !taintsReturn) {
for (ValueEntry entry : nonLocalValues.toArray(new ValueEntry[0])) {
propagateNonLocal(entry);
if (!mutatesGlobalState()) {
for (ValueEntry entry : modifiedLocals.toArray(new ValueEntry[0])) {
propagateModified(entry);
if (isInformationStable()){
clearLocalityState();
boolean maybePropagateNonLocal(ValueEntry value) {
if (!nonLocalValues.contains(value)) {
nonLocalValues.add(value);
return propagateNonLocal(value);
return false;
boolean propagateNonLocal(ValueEntry value) {
Preconditions.checkState(nonLocalValues != null);
Preconditions.checkState(modifiedLocals != null);
boolean changed = false;
if (modifiedLocals.contains(value)) {
if (!mutatesGlobalState()) {
setTaintsGlobalState();
changed = true;
if (value == KeywordValueEntry.RETURN) {
if (!taintsReturn) {
setTaintsReturn();
changed = true;
Collection<ValueEntry> dependents = getValueInfluenceMap().get(value);
if (dependents != null) {
for (ValueEntry dependent : dependents) {
if (!nonLocalValues.contains(dependent)) {
nonLocalValues.add(dependent);
changed = propagateNonLocal(dependent) || changed;
return changed;
private boolean propagateModified(ValueEntry value) {
Preconditions.checkState(nonLocalValues != null);
Preconditions.checkState(modifiedLocals != null);
boolean changed = false;
if (nonLocalValues != null
&& nonLocalValues.contains(value)) {
if (!mutatesGlobalState()) {
setTaintsUnknown();
changed = true;
if (!taintsThis) {
setTaintsThis();
changed = true;
if (!taintsArguments) {
setTaintsArguments();
changed = true;
Collection<ValueEntry> dependents = getValueInfluenceMap().get(value);
if (dependents != null) {
for (ValueEntry dependent : dependents) {
if (!modifiedLocals.contains(dependent)) {
modifiedLocals.add(dependent);
changed = propagateModified(dependent) || changed;
return changed;
import com.google.javascript.jscomp.FunctionSideEffectData.CallValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.KeywordValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.ValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.NameValueEntry;
private final Map<Node, FunctionSideEffectData> functionSideEffectMap;
for (Map.Entry<Node, FunctionSideEffectData> entry :
FunctionSideEffectData functionInfo = entry.getValue();
for (Map.Entry<Node, FunctionSideEffectData> entry :
FunctionSideEffectData functionInfo = entry.getValue();
DiGraph<FunctionSideEffectData, Node> sideEffectGraph =
new LinkedDirectedGraph<FunctionSideEffectData, Node>();
for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
FunctionSideEffectData dep = functionSideEffectMap.get(defValue);
for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
FunctionSideEffectData functionInfo =
if (functionInfo.functionThrows()) {
if (functionInfo.mutatesThis()) {
if (functionInfo.hasNonLocalReturnValue()) {
FunctionSideEffectData sideEffectInfo =
if (value != null && !analyzeSet(
new NameValueEntry(node), value, sideEffectInfo)) {
sideEffectInfo.addNonLocalValue(var);
if (node.hasChildren() && !analyzeSet(
KeywordValueEntry.RETURN, node.getFirstChild(),
sideEffectInfo)) {
public void enterScope(NodeTraversal traversal) {
Node enclosingFunction = traversal.getEnclosingFunction();
if (enclosingFunction != null) {
visitFunction(traversal, enclosingFunction);
if (t.inGlobalScope() || inExterns) {
FunctionSideEffectData sideEffectInfo =
functionSideEffectMap.get(t.getScopeRoot());
sideEffectInfo.normalizeValueMaps();
FunctionSideEffectData sideEffectInfo,
&& !analyzeSet(
new NameValueEntry(lhs), rhs, sideEffectInfo)) {
sideEffectInfo.addNonLocalValue(var);
sideEffectInfo.addModified(var);
private void visitCall(FunctionSideEffectData sideEffectInfo, Node node) {
private void visitFunction(NodeTraversal traversal, Node node) {
FunctionSideEffectData sideEffectInfo = new FunctionSideEffectData(
inExterns, traversal.getScope());
if (!inExterns) {
Scope localScope = traversal.getScope();
Iterator<Var> i = localScope.getVars();
while (i.hasNext()) {
Var v = i.next();
Node parent = v.getParentNode();
if (parent.getType() == Token.LP
|| parent.getType() == Token.CATCH) {
sideEffectInfo.addNonLocalValue(v);
processFunctionAnnotations(sideEffectInfo, traversal, node);
private void processFunctionAnnotations(
FunctionSideEffectData sideEffectInfo,
NodeTraversal traversal, Node function) {
JSType jstype = function.getJSType();
JSDocInfo info = getJSDocInfoForFunction(function);
traversal.report(function, INVALID_MODIFIES_ANNOTATION);
traversal.report(function, INVALID_MODIFIES_ANNOTATION);
traversal.report(function, INVALID_NO_SIDE_EFFECT_ANNOTATION);
private void visitThrow(FunctionSideEffectData sideEffectInfo) {
private JSDocInfo getJSDocInfoForFunction(Node node) {
Node parent = node.getParent();
Node gramp = parent.getParent();
private static boolean analyzeSet(
final ValueEntry lValue,
Node rValue,
final FunctionSideEffectData info) {
final boolean isReturnResult = lValue.equals(KeywordValueEntry.RETURN);
final Predicate<Node> taintingPredicate = new Predicate<Node>() {
Preconditions.checkState(
!NodeUtil.isImmutableValue(value.getLastChild()));
Node lhs = value.getFirstChild();
if (NodeUtil.isName(lhs)
&& info.getScope().isDeclared(lhs.getString(), false)) {
addValue(lhs);
return true;
addValue(KeywordValueEntry.THIS);
return true;
if (info.getScope().isDeclared(value.getString(), false)) {
addValue(value);
return true;
case Token.CALL:
addCall(value);
return true;
default:
throw new IllegalStateException("unexpected");
private void addCall(Node callNode) {
Preconditions.checkState(callNode.getType() == Token.CALL);
info.addInfluence(new CallValueEntry(callNode), lValue);
private void addValue(Node name) {
ValueEntry value = new NameValueEntry(name);
addValue(value);
private void addValue(ValueEntry value) {
info.addInfluence(value, lValue);
if (!isReturnResult) {
info.addInfluence(lValue, value);
return NodeUtil.evaluatesToLocalValue(rValue, taintingPredicate);
private static Predicate<Node> getLocalPredicate(
final FunctionSideEffectData caller) {
return new Predicate<Node>() {
public boolean apply(Node value) {
return caller.isLocalValue(value);
implements EdgeCallback<FunctionSideEffectData, Node> {
public boolean traverseEdge(final FunctionSideEffectData callee,
final Node callSite,
final FunctionSideEffectData caller) {
if (caller.isInformationStable()) {
return false;
Predicate<Node> locals = getLocalPredicate(caller);
if (callee.hasNonLocalReturnValue()) {
if (caller.maybePropagateNonLocal(new CallValueEntry(callSite))) {
changed = true;
if (objectNode != null && NodeUtil.isThis(objectNode)) {
if (!caller.mutatesThis()) {
caller.setTaintsThis();
changed = true;
if (!NodeUtil.evaluatesToLocalValue(objectNode, locals)) {
if (caller.isInformationStable()) {
caller.clearLocalityState();
ImmutableList.<String>of("externObjSEThis", "f"));
public void testResultLocalitySimpleSample() throws Exception {
String prefix = "var g; function f(){";
String suffix = "} f()";
List<String> expected = ImmutableList.of("f");
List<String> notExpected = ImmutableList.of();
checkLocalityOfMarkedCalls(
prefix + "var a = (g = []); return a" + suffix, notExpected);
prefix + "var a = 1; return a" + suffix, expected);
prefix + "var a = 1; a = 2; return a" + suffix, expected);
checkLocalityOfMarkedCalls(
prefix + "var a = (g = 2); return a" + suffix, expected);
checkLocalityOfMarkedCalls(
prefix + "var a = (g = []); return a" + suffix, notExpected);
ImmutableList.<String>of("A", "f"));
public void testLocalizedSideEffects12() throws Exception {
checkMarkedCalls("var g = 1;" +
"function f() {" +
"  var a = (g = new Foo); return a;" +
"}" +
"f()",
ImmutableList.<String>of());
public void testLocalizedSideEffects13() throws Exception {
checkMarkedCalls("var g = 1;" +
"function f() {" +
"  var a = (g = 2); return a;" +
"}" +
"f()",
ImmutableList.<String>of());
checkMarkedCalls(source, ImmutableList.<String>of("A", "A", "f", "g"));import java.util.Collections;
private final Map<Node, FunctionInformation> functionSideEffectMap;
for (Map.Entry<Node, FunctionInformation> entry :
FunctionInformation functionInfo = entry.getValue();
for (Map.Entry<Node, FunctionInformation> entry :
FunctionInformation functionInfo = entry.getValue();
DiGraph<FunctionInformation, Node> sideEffectGraph =
new LinkedDirectedGraph<FunctionInformation, Node>();
for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
FunctionInformation dep = functionSideEffectMap.get(defValue);
for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
FunctionInformation functionInfo =
if (functionInfo.functionThrows) {
if (functionInfo.taintsThis) {
if (functionInfo.taintsReturn) {
if (NodeUtil.isFunction(node)) {
Node gramp = parent.getParent();
visitFunction(traversal, node, parent, gramp);
FunctionInformation sideEffectInfo =
if (value != null && !NodeUtil.evaluatesToLocalValue(value)) {
sideEffectInfo.blacklistLocal(var);
if (node.hasChildren()
&& !NodeUtil.evaluatesToLocalValue(node.getFirstChild())) {
public void enterScope(NodeTraversal t) {
if (t.inGlobalScope()) {
FunctionInformation sideEffectInfo =
functionSideEffectMap.get(t.getScopeRoot());
if (sideEffectInfo.mutatesGlobalState()){
sideEffectInfo.resetLocalVars();
return;
for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {
Var v = i.next();
boolean localVar = false;
if (v.getParentNode().getType() == Token.VAR) {
sideEffectInfo.knownLocals.add(v.getName());
localVar = true;
if (!localVar || sideEffectInfo.blacklisted.contains(v)) {
if (sideEffectInfo.taintedLocals.contains(v)) {
sideEffectInfo.setTaintsUnknown();
sideEffectInfo.resetLocalVars();
break;
sideEffectInfo.taintedLocals = null;
sideEffectInfo.blacklisted = null;
FunctionInformation sideEffectInfo,
&& !NodeUtil.evaluatesToLocalValue(rhs)) {
sideEffectInfo.blacklistLocal(var);
sideEffectInfo.addTaintedLocalObject(var);
private void visitCall(FunctionInformation sideEffectInfo, Node node) {
private void visitFunction(NodeTraversal traversal,
Node node,
Node parent,
Node gramp) {
FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);
JSType jstype = node.getJSType();
JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);
traversal.report(node, INVALID_MODIFIES_ANNOTATION);
traversal.report(node, INVALID_MODIFIES_ANNOTATION);
traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);
private void visitThrow(FunctionInformation sideEffectInfo) {
private JSDocInfo getJSDocInfoForFunction(
Node node, Node parent, Node gramp) {
private static boolean isKnownLocalValue(final Node value) {
Predicate<Node> taintingPredicate = new Predicate<Node>() {
return false;
case Token.CALL:
return false;
return false;
return NodeUtil.evaluatesToLocalValue(value, taintingPredicate);
implements EdgeCallback<FunctionInformation, Node> {
public boolean traverseEdge(FunctionInformation callee,
Node callSite,
FunctionInformation caller) {
if (objectNode != null && NodeUtil.isName(objectNode)
&& !isCallOrApply(callSite)) {
String name = objectNode.getString();
if (!caller.mutatesThis()) {
caller.setTaintsThis();
changed = true;
&& NodeUtil.evaluatesToLocalValue(objectNode)
&& !isCallOrApply(callSite)) {
private static class FunctionInformation {
private final boolean extern;
private final List<Node> callsInFunctionBody = Lists.newArrayList();
private Set<Var> blacklisted = Sets.newHashSet();
private Set<Var> taintedLocals = Sets.newHashSet();
private Set<String> knownLocals = Sets.newHashSet();
private boolean pureFunction = false;
private boolean functionThrows = false;
private boolean taintsGlobalState = false;
private boolean taintsThis = false;
private boolean taintsArguments = false;
private boolean taintsUnknown = false;
private boolean taintsReturn = false;
FunctionInformation(boolean extern) {
this.extern = extern;
checkInvariant();
void addTaintedLocalObject(Var var) {
taintedLocals.add(var);
void resetLocalVars() {
blacklisted = null;
taintedLocals = null;
knownLocals = Collections.emptySet();
public void blacklistLocal(Var var) {
blacklisted.add(var);
boolean mayBePure() {
return !(functionThrows ||
taintsGlobalState ||
taintsThis ||
taintsArguments ||
taintsUnknown);
boolean mayHaveSideEffects() {
return !pureFunction;
void setIsPure() {
pureFunction = true;
checkInvariant();
void setTaintsGlobalState() {
taintsGlobalState = true;
checkInvariant();
void setTaintsThis() {
taintsThis = true;
checkInvariant();
void setTaintsArguments() {
taintsArguments = true;
checkInvariant();
void setFunctionThrows() {
functionThrows = true;
checkInvariant();
void setTaintsUnknown() {
taintsUnknown = true;
checkInvariant();
void setTaintsReturn() {
taintsReturn = true;
checkInvariant();
boolean mutatesGlobalState() {
return taintsGlobalState || taintsArguments || taintsUnknown;
boolean mutatesThis() {
return taintsThis;
boolean functionThrows() {
return functionThrows;
private void checkInvariant() {
boolean invariant = mayBePure() || mayHaveSideEffects();
if (!invariant) {
throw new IllegalStateException("Invariant failed.  " + toString());
void appendCall(Node callNode) {
callsInFunctionBody.add(callNode);
List<Node> getCallsInFunctionBody() {
return callsInFunctionBody;
public String toString() {
List<String> status = Lists.newArrayList();
if (extern) {
status.add("extern");
if (pureFunction) {
status.add("pure");
if (taintsThis) {
status.add("this");
if (taintsGlobalState) {
status.add("global");
if (functionThrows) {
status.add("throw");
if (taintsUnknown) {
status.add("complex");
return "Side effects: " + status.toString();
ImmutableList.<String>of("externObjSEThis"));
prefix + "var a = 1; return a" + suffix, notExpected);
prefix + "var a = 1; a = 2; return a" + suffix, notExpected);
ImmutableList.<String>of("A"));
checkMarkedCalls(source, ImmutableList.<String>of("A", "A", "f"));private static class ThrowAliasSpecification extends AliasSpecification {
Node name = NodeUtil.newName(getAliasName(), throwNode, getAliasName());
static int estimateMinOccurrencesRequriedToAlias() {
Node alias = createAliasFunctionNode("TT");
return InlineCostEstimator.getCost(alias) / 2 + 1;
private static Node createAliasFunctionNode(String aliasName) {
Node parameterName = Node.newString(Token.NAME, "jscomp_throw_param");
List<Node> parameters = Lists.newArrayList(parameterName.cloneNode());
Node throwStatement = new Node(Token.THROW, parameterName);
Node body = new Node(Token.BLOCK, throwStatement);
return NodeUtil.newFunctionNode(aliasName, parameters, body, -1, -1);
private static class KeywordAliasSpecification extends AliasSpecification {
Node aliasNode = NodeUtil.newName(getAliasName(), n, getAliasName());
Node name = NodeUtil.newName(getAliasName(), varNode, getAliasName());
ThrowAliasSpecification.estimateMinOccurrencesRequriedToAlias();
Node ref = NodeUtil.newName(alias, n, originalName);
Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),
Node qualifiedPath = NodeUtil.newQualifiedNameNode(path, -1, -1);
NodeUtil.newQualifiedNameNode(className + ".prototype",
NodeUtil.newQualifiedNameNode(exportSymbolFunction,
call.addChildToBack(NodeUtil.newQualifiedNameNode(export,
NodeUtil.newQualifiedNameNode(exportPropertyFunction,
NodeUtil.newQualifiedNameNode(parent,
NodeUtil.newQualifiedNameNode(export,
public static Node newQualifiedNameNode(String name, int lineno, int charno) {
return Node.newString(Token.NAME, name, lineno, charno);
Node node = Node.newString(Token.NAME, name.substring(0, endPos),
lineno, charno);
node = new Node(Token.GETPROP, node,
Node.newString(Token.STRING, part, lineno, charno),
lineno, charno);
static Node newQualifiedNameNode(String name, Node basisNode,
Node node = newQualifiedNameNode(name, -1, -1);
static Node newName(String name, Node basisNode) {
static Node newName(String name, Node basisNode, String originalName) {
Node nameNode = newName(name, basisNode);
n.putBooleanProp(Node.IS_CONSTANT_NAME, true);
"  gramps:" + n.getParent().getParent().toStringTree());
private Map<String,Boolean> constantMap = Maps.newHashMap();
if (NodeUtil.isConstantByConvention(
NodeUtil.newQualifiedNameNode(namespace, node, namespace),
Node classNode = NodeUtil.newQualifiedNameNode(className, -1, -1);
private static class AddChecks
private static Node jsCode(String prop) {
return NodeUtil.newQualifiedNameNode("jscomp.typecheck." + prop, -1, -1);
SimpleFunctionAliasAnalysis initialModuleFunctionAliasAnalysis = 
initialModuleFunctionAliasAnalysis.analyze(defFinder); 
replaceOriginalModuleInputsWithSpecialized();    
addOriginalFunctionVersionsToDependentModules(module);   
private Collection<SpecializationAwareCompilerPass> 
Preconditions.checkState(pass instanceof 
private void matchTopLevelFunctions(Node original, Node toBeSpecialized) {  
new NodeMatcher() {   
OriginalFunctionInformation functionInfo = 
functionInfoBySpecializedFunctionNode.keySet()) {      
for (Node modifiedFunction : possiblyModifiedFunctions) {   
boolean declarationWasRemoved = 
Node newDefinition = 
directDependents.add(possibleDependent);       
private static class OriginalFunctionInformation {
private boolean isAssignFunction; 
private Node generateFixupDefinition() {  
NodeUtil.newQualifiedNameNode(name, functionCopy, name);
NodeUtil.newName("", nameNode));
public SpecializationState(SimpleFunctionAliasAnalysis 
Node parent = functionNode.getParent();    public class ExpresssionDecomposerTest extends TestCase {Node n, Node rhsValue) {
maybeCollectMember(t, child.getFirstChild(), child);
maybeCollectMember(t, child, child);
Node member, Node nodeWithJsDocInfo) {
JSType jsType = getDeclaredTypeInAnnotation(t, member, info);iArgumentType.getJSDocInfo() == null) {
Node source = fnType.getSource();
compiler.report(JSError.make(NodeUtil.getSourceName(source), source,if (this.isSubtype(that)) {if (isOrdinaryFunction() && that.isOrdinaryFunction() &&
that instanceof FunctionType) {
FunctionType other = (FunctionType) that;
if (call.hasEqualParameters(other.call) &&
isEquivalent(typeOfThis, other.typeOfThis)) {
JSType newReturnType = leastSuper ?
call.returnType.getLeastSupertype(other.call.returnType) :
call.returnType.getGreatestSubtype(other.call.returnType);
return cloneWithNewReturnType(
newReturnType,
call.returnTypeInferred || other.call.returnTypeInferred);
return leastSuper ?
registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE) :
registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
registry, null, source,
registry, call.parameters, newReturnType, inferred),
typeOfThis, null, false, false);
"Expected: " + b + "\n" +
"Actual  : " + a,
package com.google.javascript.rhino;
import com.google.javascript.rhino.jstype.BooleanLiteralSetTest;
import com.google.javascript.rhino.jstype.FunctionParamBuilderTest;
import com.google.javascript.rhino.jstype.JSTypeRegistryTest;
import com.google.javascript.rhino.jstype.JSTypeTest;
import com.google.javascript.rhino.jstype.TernaryValueTest;
import com.google.javascript.rhino.jstype.UnionTypeBuilderTest;
import junit.framework.Test;
import junit.framework.TestSuite;
import java.util.logging.Level;
import java.util.logging.Logger;
public class AllTests {
public static Test suite() throws Exception {
Logger.getLogger("com.google").setLevel(Level.OFF);
TestSuite suite = new TestSuite();
suite.addTestSuite(JSDocInfoTest.class);
suite.addTestSuite(NodeTest.class);
suite.addTestSuite(ParserTest.class);
suite.addTestSuite(TokenStreamTest.class);
suite.addTestSuite(BooleanLiteralSetTest.class);
suite.addTestSuite(FunctionParamBuilderTest.class);
suite.addTestSuite(JSTypeRegistryTest.class);
suite.addTestSuite(JSTypeTest.class);
suite.addTestSuite(TernaryValueTest.class);
suite.addTestSuite(UnionTypeBuilderTest.class);
return suite;
"NoObject", retString, retNumber);
"Function", retString, retNumber);
"NoObject", retString, retNumber);
NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));
NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));"((function(){return function(){foo()}})())();" +
"}");public void testDefineWithBadValue() {scope.undeclare(qVar);ObjectType objectType = (ObjectType) n.getJSType();
Preconditions.checkNotNull(objectType);
if (objectType.hasReferenceName()) {if (scope.isDeclared(variableName, false)) {
Var oldVar = scope.getVar(variableName);
scope.declare(variableName, n, type, input, inferred);
if (scope.isGlobal() && type instanceof FunctionType) {
scope.declare(variableName + ".prototype", n,GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
newScope = new Scope(parent, root);
LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder.build();
scopeBuilder.resolveTypes();
public abstract void visit(NodeTraversal t, Node n, Node parent);
if (rValue != null && rValue.isQualifiedName()) {
private final class GlobalScopeBuilder extends AbstractScopeBuilder {
private final List<Node> nonExternFunctions = Lists.newArrayList();
private final List<StubDeclaration> stubDeclarations =
Lists.newArrayList();
private GlobalScopeBuilder(Scope scope) {
super(scope);
attachLiteralTypes(n);
switch (n.getType()) {
case Token.CALL:
checkForClassDefiningCalls(t, n, parent);
break;
case Token.FUNCTION:
if (!t.getInput().isExtern()) {
nonExternFunctions.add(n);
if (parent.getType() == Token.ASSIGN ||
parent.getType() == Token.NAME) {
return;
defineDeclaredFunction(n, parent);
break;
case Token.ASSIGN:
defineNamedTypeAssign(n, parent);
checkForOldStyleTypedef(t, n);
Node firstChild = n.getFirstChild();
if (firstChild.getType() == Token.GETPROP &&
firstChild.isQualifiedName()) {
maybeDeclareQualifiedName(t, n.getJSDocInfo(),
firstChild, n, firstChild.getNext());
break;
case Token.CATCH:
defineCatch(n, parent);
break;
case Token.VAR:
defineVar(n, parent);
if (n.hasOneChild()) {
checkForOldStyleTypedef(t, n);
checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
break;
case Token.GETPROP:
if (parent.getType() == Token.EXPR_RESULT &&
n.isQualifiedName()) {
checkForTypedef(t, n, n.getJSDocInfo());
maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
break;
private void checkForTypedef(
NodeTraversal t, Node candidate, JSDocInfo info) {
if (info == null || !info.hasTypedefType()) {
return;
String typedef = candidate.getQualifiedName();
if (typedef == null) {
return;
typeRegistry.forwardDeclareType(typedef);
JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
if (candidate.getType() == Token.GETPROP) {
defineSlot(candidate, candidate.getParent(),
getNativeType(NO_TYPE), false);
private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {
String typedef = codingConvention.identifyTypeDefAssign(candidate);
if (typedef != null) {
typeRegistry.forwardDeclareType(typedef);
JSDocInfo info = candidate.getJSDocInfo();
JSType realType = null;
if (info != null && info.getType() != null) {
realType = info.getType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
n, t.getInput().isExtern(), ownerName));
boolean isExtern = t.getInput().isExtern();
private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,
Node n, Node rhsValue) {
if (info != null && info.hasType()) {
return getDeclaredTypeInAnnotation(t, n, info);
return n.getJSType();
rhsValue.getType() == Token.FUNCTION) {
return rhsValue.getJSType();
return getDeclaredTypeInAnnotation(t, n, info);
private void resolveStubDeclarations() {
private final class StubDeclaration {
private final Node node;
private final boolean isExtern;
private final String ownerName;
private StubDeclaration(Node node, boolean isExtern, String ownerName) {
this.node = node;
this.isExtern = isExtern;
this.ownerName = ownerName;
attachLiteralTypes(n);
switch (n.getType()) {
case Token.FUNCTION:
if (parent.getType() == Token.NAME) {
return;
defineDeclaredFunction(n, parent);
break;
case Token.CATCH:
defineCatch(n, parent);
break;
case Token.VAR:
defineVar(n, parent);
break;AbstractScopeBuilder scopeBuilder = null;
GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
if (parent == null) {
private final List<Node> nonExternFunctions = Lists.newArrayList();
private final List<StubDeclaration> stubDeclarations =
Lists.newArrayList();
public void visit(NodeTraversal t, Node n, Node parent) {
attachLiteralTypes(n);
switch (n.getType()) {
case Token.CALL:
checkForClassDefiningCalls(t, n, parent);
break;
case Token.FUNCTION:
if (t.getInput() == null || !t.getInput().isExtern()) {
nonExternFunctions.add(n);
if (parent.getType() != Token.ASSIGN &&
parent.getType() != Token.NAME) {
defineDeclaredFunction(n, parent);
break;
case Token.ASSIGN:
defineNamedTypeAssign(n, parent);
Node firstChild = n.getFirstChild();
if (firstChild.getType() == Token.GETPROP &&
firstChild.isQualifiedName()) {
maybeDeclareQualifiedName(t, n.getJSDocInfo(),
firstChild, n, firstChild.getNext());
break;
case Token.CATCH:
defineCatch(n, parent);
break;
case Token.VAR:
defineVar(n, parent);
break;
case Token.GETPROP:
if (parent.getType() == Token.EXPR_RESULT &&
n.isQualifiedName()) {
maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
break;
if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,
Node n, Node rhsValue) {
if (info != null && info.hasType()) {
return getDeclaredTypeInAnnotation(t, n, info);
return n.getJSType();
rhsValue.getType() == Token.FUNCTION) {
return rhsValue.getJSType();
return getDeclaredTypeInAnnotation(t, n, info);
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
n,
t.getInput() != null && t.getInput().isExtern(),
ownerName));
boolean isExtern = t.getInput() != null && t.getInput().isExtern();
void resolveStubDeclarations() {
private static final class StubDeclaration {
private final Node node;
private final boolean isExtern;
private final String ownerName;
private StubDeclaration(Node node, boolean isExtern, String ownerName) {
this.node = node;
this.isExtern = isExtern;
this.ownerName = ownerName;
private final class GlobalScopeBuilder extends AbstractScopeBuilder {
private GlobalScopeBuilder(Scope scope) {
super(scope);
super.visit(t, n, parent);
switch (n.getType()) {
case Token.ASSIGN:
checkForOldStyleTypedef(t, n);
break;
case Token.VAR:
if (n.hasOneChild()) {
checkForOldStyleTypedef(t, n);
checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
break;
void maybeDeclareQualifiedName(
NodeTraversal t, JSDocInfo info,
Node n, Node parent, Node rhsValue) {
checkForTypedef(t, n, info);
super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);
private void checkForTypedef(
NodeTraversal t, Node candidate, JSDocInfo info) {
if (info == null || !info.hasTypedefType()) {
return;
String typedef = candidate.getQualifiedName();
if (typedef == null) {
return;
typeRegistry.forwardDeclareType(typedef);
JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
if (candidate.getType() == Token.GETPROP) {
defineSlot(candidate, candidate.getParent(),
getNativeType(NO_TYPE), false);
private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {
String typedef = codingConvention.identifyTypeDefAssign(candidate);
if (typedef != null) {
typeRegistry.forwardDeclareType(typedef);
JSDocInfo info = candidate.getJSDocInfo();
JSType realType = null;
if (info != null && info.getType() != null) {
realType = info.getType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
super.visit(t, n, parent);
public void testCollectedFunctionStubLocal() {
testSame(
"(function() {" +
"/** @constructor */ function f() { " +
"  /** @return {number} */ this.foo;" +
"}" +
"var x = new f();" +
"});");
ObjectType x = (ObjectType) findNameType("x", lastLocalScope);
assertEquals("f", x.toString());
assertTrue(x.hasProperty("foo"));
assertEquals("function (this:f): number",
x.getPropertyType("foo").toString());
assertFalse(x.isPropertyTypeInferred("foo"));
public void testNamespacedFunctionStubLocal() {
testSame(
"(function() {" +
"var goog = {};" +
"/** @param {number} x */ goog.foo;" +
"});");
ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope);
assertTrue(goog.hasProperty("foo"));
assertEquals("function (number): ?",
goog.getPropertyType("foo").toString());
assertTrue(goog.isPropertyTypeDeclared("foo"));
assertEquals(lastLocalScope.getVar("goog.foo").getType(),
goog.getPropertyType("foo"));GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
newScope = new Scope(parent, root);
LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder.build();
scopeBuilder.resolveTypes();
public abstract void visit(NodeTraversal t, Node n, Node parent);
if (rValue != null && rValue.isQualifiedName()) {
private final class GlobalScopeBuilder extends AbstractScopeBuilder {
private final List<Node> nonExternFunctions = Lists.newArrayList();
private final List<StubDeclaration> stubDeclarations =
Lists.newArrayList();
private GlobalScopeBuilder(Scope scope) {
super(scope);
attachLiteralTypes(n);
switch (n.getType()) {
case Token.CALL:
checkForClassDefiningCalls(t, n, parent);
break;
case Token.FUNCTION:
if (!t.getInput().isExtern()) {
nonExternFunctions.add(n);
if (parent.getType() == Token.ASSIGN ||
parent.getType() == Token.NAME) {
return;
defineDeclaredFunction(n, parent);
break;
case Token.ASSIGN:
defineNamedTypeAssign(n, parent);
checkForOldStyleTypedef(t, n);
Node firstChild = n.getFirstChild();
if (firstChild.getType() == Token.GETPROP &&
firstChild.isQualifiedName()) {
maybeDeclareQualifiedName(t, n.getJSDocInfo(),
firstChild, n, firstChild.getNext());
break;
case Token.CATCH:
defineCatch(n, parent);
break;
case Token.VAR:
defineVar(n, parent);
if (n.hasOneChild()) {
checkForOldStyleTypedef(t, n);
checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());
break;
case Token.GETPROP:
if (parent.getType() == Token.EXPR_RESULT &&
n.isQualifiedName()) {
checkForTypedef(t, n, n.getJSDocInfo());
maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
break;
private void checkForTypedef(
NodeTraversal t, Node candidate, JSDocInfo info) {
if (info == null || !info.hasTypedefType()) {
return;
String typedef = candidate.getQualifiedName();
if (typedef == null) {
return;
typeRegistry.forwardDeclareType(typedef);
JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
if (candidate.getType() == Token.GETPROP) {
defineSlot(candidate, candidate.getParent(),
getNativeType(NO_TYPE), false);
private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {
String typedef = codingConvention.identifyTypeDefAssign(candidate);
if (typedef != null) {
typeRegistry.forwardDeclareType(typedef);
JSDocInfo info = candidate.getJSDocInfo();
JSType realType = null;
if (info != null && info.getType() != null) {
realType = info.getType().evaluate(scope, typeRegistry);
if (realType == null) {
compiler.report(
JSError.make(
t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));
typeRegistry.declareType(typedef, realType);
private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
n, t.getInput().isExtern(), ownerName));
boolean isExtern = t.getInput().isExtern();
private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,
Node n, Node rhsValue) {
if (info != null && info.hasType()) {
return getDeclaredTypeInAnnotation(t, n, info);
return n.getJSType();
rhsValue.getType() == Token.FUNCTION) {
return rhsValue.getJSType();
return getDeclaredTypeInAnnotation(t, n, info);
private void resolveStubDeclarations() {
private final class StubDeclaration {
private final Node node;
private final boolean isExtern;
private final String ownerName;
private StubDeclaration(Node node, boolean isExtern, String ownerName) {
this.node = node;
this.isExtern = isExtern;
this.ownerName = ownerName;
attachLiteralTypes(n);
switch (n.getType()) {
case Token.FUNCTION:
if (parent.getType() == Token.NAME) {
return;
defineDeclaredFunction(n, parent);
break;
case Token.CATCH:
defineCatch(n, parent);
break;
case Token.VAR:
defineVar(n, parent);
break;name.addChildToFront(new Node(Token.OBJECTLIT));
NodeUtil.newQualifiedNameNode(namespace, node, namespace),
new Node(Token.OBJECTLIT)));
if (objectType == null) {
return scope;
n.setJSType(typeRegistry.createAnonymousObjectType());removeDuplicateDeclarations(root);
private void removeDuplicateDeclarations(Node root) {
t.traverse(root);
NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());
testSame("/** @suppress {duplicate} */\nvar window;");for (Definition prevDef : nameDefinitionMultimap.get(name)) {
if (prevDef instanceof ExternalNameOnlyDefinition
&& node.getJSDocInfo() == null) {
String prevName = prevDef.getLValue().getQualifiedName();
if (qualifiedName.equals(prevName)) {
stubsToRemove.add(prevDef);
for (Definition prevDef : stubsToRemove) {
nameDefinitionMultimap.remove(name, prevDef);addGuards(((ComposeWarningsGuard) guard).guards);parent.replaceChild(n, n.removeFirstChild());
return null;
if (left.getType() == Token.NUMBER &&
right.getType() == Token.NUMBER) {
double resultDouble;
double lval = left.getDouble();
double rval = right.getDouble();
if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||
rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {
return n;
int lvalInt = (int) lval;
if (lvalInt != lval) {
return n;
int rvalInt = (int) rval;
if (rvalInt != rval) {
return n;
switch (n.getType()) {
case Token.BITAND:
resultDouble = lvalInt & rvalInt;
break;
case Token.BITOR:
resultDouble = lvalInt | rvalInt;
break;
default:
throw new Error("Unknown bitwise operator");
Node newNumber = Node.newNumber(resultDouble);
n.getParent().replaceChild(n, newNumber);
reportCodeChange();
return n;
class PeepholeOptimizationsPass extends AbstractPostOrderCallback 
PeepholeOptimizationsPass(AbstractCompiler compiler, 
PeepholeOptimizationsPass(AbstractCompiler compiler, 
this(compiler, ImmutableSet.copyOf(optimizations));     
Node newVersionOfNode = 
case Token.HOOK:
return tryFoldHookIf(subtree);
private Node tryFoldHookIf(Node n) {
boolean changes = false;
if (type == Token.IF) {
if (elseBody != null && !mayHaveSideEffects(elseBody)) {
n.removeChild(elseBody);
elseBody = null;
changes = true;
if (!mayHaveSideEffects(thenBody) && elseBody != null) {
n.removeChild(elseBody);
n.replaceChild(thenBody, elseBody);
Node notCond = new Node(Token.NOT);
n.replaceChild(cond, notCond);
notCond.addChildToFront(cond);
cond = notCond;
thenBody = cond.getNext();
elseBody = null;
changes = true;
if (!mayHaveSideEffects(thenBody) && elseBody == null) {
if (mayHaveSideEffects(cond)) {
n.removeChild(cond);
Node replacement = NodeUtil.newExpr(cond);
parent.replaceChild(n, replacement);
reportCodeChange();
return replacement;
NodeUtil.removeChild(parent, n);
reportCodeChange();
return null;
Preconditions.checkState(type == Token.HOOK);
if (NodeUtil.isExpressionNode(parent)) {
if (!mayHaveSideEffects(thenBody)) {
Node ifNode = new Node(Token.IF);
if (cond.getType() == Token.NOT) {
Node expr = cond.getFirstChild();
cond.removeChild(expr);
ifNode.addChildToBack(expr);
Node not = new Node(Token.NOT).copyInformationFrom(cond);
n.removeChild(cond);
not.addChildToBack(cond);
ifNode.addChildToBack(not);
n.removeChild(elseBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))
.copyInformationFrom(elseBody));
parent.getParent().replaceChild(parent, ifNode);
reportCodeChange();
return ifNode;
Node ifNode = new Node(Token.IF);
n.removeChild(cond);
ifNode.addChildToBack(cond);
n.removeChild(thenBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))
.copyInformationFrom(thenBody));
parent.getParent().replaceChild(parent, ifNode);
reportCodeChange();
return ifNode;
if (n.getType() == Token.HOOK) {
Node replacement = new Node(Token.BLOCK).copyInformationFrom(n);
n.detachChildren();
replacement.addChildToFront(
new Node(Token.EXPR_RESULT, cond).copyInformationFrom(cond));
Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody;
replacement.addChildToBack(
NodeUtil.newExpr(branchToKeep)
.copyInformationFrom(branchToKeep));
parent.getParent().replaceChild(parent, replacement);
reportCodeChange();
return replacement;
Preconditions.checkState(n.getType() == Token.IF);
Node firstBranch = n.getFirstChild().getNext();
Node secondBranch = firstBranch.getNext();
Node branch = condTrue ? firstBranch : secondBranch;
Node notBranch = condTrue ? secondBranch : firstBranch;
NodeUtil.redeclareVarsInsideBranch(notBranch);
n.removeChild(branch);
parent.replaceChild(n, branch);
return branch;
public void testHookIf() {
fold("if (x){ x = 1; } else if (false) { x = 3; }", "if(x)x=1");private class GlobalFunction implements Symbol {
private static class AssignmentProperty implements Property {
private static class LiteralProperty implements Property {
class DevirtualizePrototypeMethods implements CompilerPass {
class InlineFunctions implements CompilerPass {
private static class Inline implements CallVisitorCallback {
class RemoveUnusedPrototypeProperties implements CompilerPass {
boolean canModifyExterns, boolean anchorUnusedVars) {
declaration.remove();
changed = true;passes.add(removeAbstractMethods);
private final PassFactory removeAbstractMethods =
new PassFactory("removeAbstractMethods", true) {
return new GoogleCodeRemoval(compiler);
final class GoogleCodeRemoval implements CompilerPass {
GoogleCodeRemoval(AbstractCompiler compiler) {
public class GoogleCodeRemovalTest extends CompilerTestCase {
public GoogleCodeRemovalTest() {
protected GoogleCodeRemoval getProcessor(Compiler compiler) {
return new GoogleCodeRemoval(compiler);com.google.protobuf.GeneratedMessage {
com.google.protobuf.GeneratedMessage {
private java.lang.String sourceName_;
return sourceName_;
private java.lang.String moduleName_;
return moduleName_;
private java.lang.String name_;
return name_;
private java.lang.String compiledSource_;
return compiledSource_;
output.writeString(3, getSourceName());
output.writeString(5, getModuleName());
output.writeString(7, getName());
output.writeString(8, getCompiledSource());
.computeStringSize(3, getSourceName());
.computeStringSize(5, getModuleName());
.computeStringSize(7, getName());
.computeStringSize(8, getCompiledSource());
com.google.protobuf.GeneratedMessage.Builder<Builder> {
if (((bitField0_ & 0x00000001) == 0x00000001)) {
result.bitField0_ = (result.bitField0_ | 0x00000001);
if (((bitField0_ & 0x00000002) == 0x00000002)) {
result.bitField0_ = (result.bitField0_ | 0x00000002);
if (((bitField0_ & 0x00000004) == 0x00000004)) {
result.bitField0_ = (result.bitField0_ | 0x00000004);
if (((bitField0_ & 0x00000008) == 0x00000008)) {
result.bitField0_ = (result.bitField0_ | 0x00000008);
if (((bitField0_ & 0x00000010) == 0x00000010)) {
result.bitField0_ = (result.bitField0_ | 0x00000010);
if (((bitField0_ & 0x00000020) == 0x00000020)) {
result.bitField0_ = (result.bitField0_ | 0x00000020);
if (((bitField0_ & 0x00000040) == 0x00000040)) {
result.bitField0_ = (result.bitField0_ | 0x00000040);
setId(input.readInt32());
setSourceName(input.readString());
setLineNumber(input.readInt32());
setModuleName(input.readString());
setSize(input.readInt32());
setName(input.readString());
setCompiledSource(input.readString());
bitField0_ = (bitField0_ | 0x00000001);
private java.lang.String sourceName_ = "";
public java.lang.String getSourceName() {
return sourceName_;
bitField0_ = (bitField0_ | 0x00000002);
bitField0_ = (bitField0_ | 0x00000004);
private java.lang.String moduleName_ = "";
public java.lang.String getModuleName() {
return moduleName_;
bitField0_ = (bitField0_ | 0x00000008);
bitField0_ = (bitField0_ | 0x00000010);
private java.lang.String name_ = "";
public java.lang.String getName() {
return name_;
bitField0_ = (bitField0_ | 0x00000020);
private java.lang.String compiledSource_ = "";
public java.lang.String getCompiledSource() {
return compiledSource_;
bitField0_ = (bitField0_ | 0x00000040);
com.google.protobuf.GeneratedMessage {
private java.lang.String name_;
return name_;
private java.lang.String compiledSource_;
return compiledSource_;
output.writeString(102, getName());
output.writeString(103, getCompiledSource());
.computeStringSize(102, getName());
.computeStringSize(103, getCompiledSource());
com.google.protobuf.GeneratedMessage.Builder<Builder> {
if (((bitField0_ & 0x00000001) == 0x00000001)) {
result.bitField0_ = (result.bitField0_ | 0x00000001);
if (((bitField0_ & 0x00000002) == 0x00000002)) {
result.bitField0_ = (result.bitField0_ | 0x00000002);
setName(input.readString());
setCompiledSource(input.readString());
private java.lang.String name_ = "";
public java.lang.String getName() {
return name_;
bitField0_ = (bitField0_ | 0x00000001);
private java.lang.String compiledSource_ = "";
public java.lang.String getCompiledSource() {
return compiledSource_;
bitField0_ = (bitField0_ | 0x00000002);
com.google.protobuf.GeneratedMessage.Builder<Builder> {
bitField0_ = (bitField0_ | 0x00000001);
bitField0_ = (bitField0_ | 0x00000002);
com.google.protobuf.GeneratedMessage {
private java.lang.String reportDefined_;
return reportDefined_;
private java.lang.String reportCall_;
return reportCall_;
private java.lang.String reportExit_;
return reportExit_;
private java.util.List<java.lang.String> declarationToRemove_;
private java.util.List<java.lang.String> init_;
private java.lang.String appNameSetter_;
return appNameSetter_;
declarationToRemove_ = java.util.Collections.emptyList();
init_ = java.util.Collections.emptyList();
output.writeString(1, getReportDefined());
output.writeString(2, getReportCall());
for (java.lang.String element : getDeclarationToRemoveList()) {
output.writeString(3, element);
for (java.lang.String element : getInitList()) {
output.writeString(4, element);
output.writeString(5, getAppNameSetter());
output.writeString(6, getReportExit());
.computeStringSize(1, getReportDefined());
.computeStringSize(2, getReportCall());
for (java.lang.String element : getDeclarationToRemoveList()) {
.computeStringSizeNoTag(element);
for (java.lang.String element : getInitList()) {
.computeStringSizeNoTag(element);
.computeStringSize(5, getAppNameSetter());
.computeStringSize(6, getReportExit());
com.google.protobuf.GeneratedMessage.Builder<Builder> {
declarationToRemove_ = java.util.Collections.emptyList();
init_ = java.util.Collections.emptyList();
if (((bitField0_ & 0x00000001) == 0x00000001)) {
result.bitField0_ = (result.bitField0_ | 0x00000001);
if (((bitField0_ & 0x00000002) == 0x00000002)) {
result.bitField0_ = (result.bitField0_ | 0x00000002);
if (((bitField0_ & 0x00000004) == 0x00000004)) {
result.bitField0_ = (result.bitField0_ | 0x00000004);
declarationToRemove_ = java.util.Collections.unmodifiableList(declarationToRemove_);
init_ = java.util.Collections.unmodifiableList(init_);
if (((bitField0_ & 0x00000020) == 0x00000020)) {
result.bitField0_ = (result.bitField0_ | 0x00000008);
setReportDefined(input.readString());
setReportCall(input.readString());
addDeclarationToRemove(input.readString());
addInit(input.readString());
setAppNameSetter(input.readString());
setReportExit(input.readString());
private java.lang.String reportDefined_ = "";
public java.lang.String getReportDefined() {
return reportDefined_;
bitField0_ = (bitField0_ | 0x00000001);
private java.lang.String reportCall_ = "";
public java.lang.String getReportCall() {
return reportCall_;
bitField0_ = (bitField0_ | 0x00000002);
private java.lang.String reportExit_ = "";
public java.lang.String getReportExit() {
return reportExit_;
bitField0_ = (bitField0_ | 0x00000004);
private java.util.List<java.lang.String> declarationToRemove_ =
java.util.Collections.emptyList();
declarationToRemove_ = new java.util.ArrayList<java.lang.String>(declarationToRemove_);
bitField0_ = (bitField0_ | 0x00000008);
declarationToRemove_ = java.util.Collections.emptyList();
private java.util.List<java.lang.String> init_ =
java.util.Collections.emptyList();
init_ = new java.util.ArrayList<java.lang.String>(init_);
bitField0_ = (bitField0_ | 0x00000010);
init_ = java.util.Collections.emptyList();
private java.lang.String appNameSetter_ = "";
public java.lang.String getAppNameSetter() {
return appNameSetter_;
bitField0_ = (bitField0_ | 0x00000020);import com.google.javascript.jscomp.DefinitionsRemover.UnknownDefinition;
result.add(new UnknownDefinition(useSite, false));
module != provided.firstModule /* covers null case */ &&
!moduleGraph.dependsOn(module,
provided.firstModule)) {
provided.firstModule.getName(),
void reset() {
static final DiagnosticType INTERFACE_FUNCTION_MEMBERS_ONLY =
"JSC_INTERFACE_FUNCTION_MEMBERS_ONLY",
"interface members can only be plain functions or {0}");
INTERFACE_FUNCTION_MEMBERS_ONLY,
t.makeError(object, INTERFACE_FUNCTION_MEMBERS_ONLY,
abstractMethodName));
ASSIGN_BITAND  = 89,  // |=
"interface members can only be plain functions" +
" or goog.abstractMethod");
"interface members can only be plain functions" +
" or goog.abstractMethod");
"interface members can only be plain functions or goog.abstractMethod"
"interface members can only be plain functions" +
" or goog.abstractMethod");
"interface members can only be plain functions" +
" or goog.abstractMethod");
"interface members can only be plain functions or goog.abstractMethod"if (n == null || NodeUtil.isLiteralValue(n) ||
return NodeUtil.isLiteralValue(value)
throw new IllegalStateException("Unexpected initialiation parent");
static boolean isLiteralValue(Node n) {
if (!isLiteralValue(child)) {
return !isFunctionExpression(n);
return !(isLiteralValue(current) ||
current.getType() == Token.FUNCTION);
parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur)));
if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
if (NodeUtil.isLiteralValue(left)
if (NodeUtil.isLiteralValue(right) &&
if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {
if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
boolean rightLiteral = NodeUtil.isLiteralValue(right);
&& NodeUtil.isLiteralValue(right.getFirstChild())));
if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
if (!NodeUtil.isLiteralValue(argumentNode) &&
if (!NodeUtil.isLiteralValue(cond)) {
if (NodeUtil.isLiteralValue(cond)) {
!NodeUtil.isLiteralValue(value);
assign.assignNode.getLastChild())) {
assertTrue(NodeUtil.isLiteralValue(n));
assertTrue(NodeUtil.isLiteralValue(n));
assertFalse(NodeUtil.isLiteralValue(n));
assertMutableState(false, "(function() { })");
assertMutableState(false, "(function() { i++ })");
assertMutableState(false, "(function(a, b) {  })");DiagnosticType.warning(
DiagnosticType.disabled(
externValidationpErrorLevel = CheckLevel.ERROR;
externValidationpErrorLevel = CheckLevel.ERROR;private String prototypeAlias = null;
if (prototypeAlias == null) {
prototypeAlias =
new VariableNameGenerator(t.getScope()).getNameNewName();
private static final String TMP = "a";
public void testUsedNameInScope() {
test(
"var a = 0;" +
"x.prototype.y.a = 1;" +
"x.prototype.y.b = 1;" +
"x.prototype.y.c = 1;" +
"x.prototype.y.d = 1;" +
"x.prototype.y.e = 1;" +
"x.prototype.y.f = 1;" +
"x.prototype.y.g = 1;",
"var b;" +
"var a = 0;" +
"b = x.prototype;" +
"b.y.a = 1;" +
"b.y.b = 1;" +
"b.y.c = 1;" +
"b.y.d = 1;" +
"b.y.e = 1;" +
"b.y.f = 1;" +
"b.y.g = 1;");boolean oldParamsNodeHasVarArgs = false;
oldParamsNodeHasVarArgs = true;
oldParamsNodeHasVarArgs,private Map<String, Node> aliases = Maps.newHashMap();
aliases.put(n.getString(), n.getFirstChild());
t.getScope().undeclare(t.getScope().getVar(n.getString()));
if (type == Token.NAME && NodeUtil.isAssignmentOp(parent)) {
Node aliasedNode = aliases.get(n.getString());
if (t.getScope().getVar(n.getString()) == null &&
aliasedNode != null) {
Node aliasedNode = aliases.get(baseName);
if (aliasedNode != null) {
import com.google.common.collect.Maps;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map;
out.append(escapeString(sourceFile));
out.append(originalPosition.getLineNumber() + "");
out.append(originalPosition.getCharacterIndex() + "");
out.append(escapeString(originalName));
private static class LineMapping {
int lineNumber;
int length;
List<LineCharMapping> characterMappings = Lists.newArrayList();
Map<Integer, LineCharMapping> charToMap = Maps.newHashMap();
void appendCharMapTo(Appendable out) throws IOException {
out.append("[");
for (int j = 0; j <= length; ++j) {
if (j > 0) {
out.append(",");
LineCharMapping current = charToMap.get(j);
if (current == null) {
out.append("-1");
out.append(String.valueOf(current.basisMapping.id));
out.append("]");
private static class LineCharMapping {
int startCharacter;
int endCharacter;
Mapping basisMapping;
Object sourceFile = node.getProp(Node.SOURCEFILE_PROP);
mapping.sourceFile = sourceFile.toString();
Object originalName = node.getProp(Node.ORIGINALNAME_PROP);
mapping.originalName = originalName.toString();
private static class LineMappingInformation {
Map<Integer, LineMapping> mappings;
int maxLine;
public LineMappingInformation(Map<Integer, LineMapping> mappings,
int maxLine) {
this.maxLine = maxLine;
this.mappings = mappings;
private LineMappingInformation determineLineMappings() {
Map<Integer, LineMapping> lineMappings = Maps.newHashMap();
int prefixLine = prefixPosition.getLineNumber();
int startPositionLine =
prefixLine + mapping.startPosition.getLineNumber();
int endPositionLine = prefixLine + mapping.endPosition.getLineNumber();
for (int i = startPositionLine; i <= endPositionLine; ++i) {
LineMapping lineMapping = lineMappings.get(i);
if (lineMapping == null) {
lineMapping = new LineMapping();
lineMapping.lineNumber = i;
lineMappings.put(i, lineMapping);
int startCharacter = mapping.startPosition.getCharacterIndex();
if (mapping.startPosition.getLineNumber() == 0) {
startCharacter += prefixPosition.getCharacterIndex();
int endCharacter = mapping.endPosition.getCharacterIndex();
if (mapping.endPosition.getLineNumber() == 0) {
endCharacter += prefixPosition.getCharacterIndex();
lineMapping.length = Math.max(lineMapping.length, endCharacter);
if (i > startPositionLine) {
startCharacter = 0;
if (i < endPositionLine) {
endCharacter = Integer.MAX_VALUE;
LineCharMapping lcm = new LineCharMapping();
lcm.startCharacter = startCharacter;
lcm.endCharacter = endCharacter;
lcm.basisMapping = mapping;
lineMapping.characterMappings.add(lcm);
return new LineMappingInformation(lineMappings, maxLine);
private void buildCharacterMappings(Collection<LineMapping> lineMappings) {
for (LineMapping lineMapping : lineMappings) {
for (int i = 0; i <= lineMapping.length; ++i) {
int minLength = Integer.MAX_VALUE;
LineCharMapping current = null;
Collections.sort(lineMapping.characterMappings,
new Comparator<LineCharMapping>() {
public int compare(LineCharMapping first, LineCharMapping second) {
Mapping firstBasis = first.basisMapping;
Mapping secondBasis = second.basisMapping;
String firstName = firstBasis.originalName;
String secondName = secondBasis.originalName;
firstName = firstName == null ? "" : firstName;
secondName = secondName == null ? "" : secondName;
return firstName.compareTo(secondName);
for (LineCharMapping lcm : lineMapping.characterMappings) {
if (i < lcm.startCharacter || i > lcm.endCharacter) {
continue;
int lcmLength = lcm.endCharacter - lcm.startCharacter;
if (lcmLength == minLength && lcm.basisMapping.originalName != null) {
current = lcm;
continue;
if (lcmLength < minLength) {
minLength = lcmLength;
current = lcm;
lineMapping.charToMap.put(i, current);
Mapping getMappingFor(Position position) {
LineMappingInformation info = determineLineMappings();
Map<Integer, LineMapping> lineMappings = info.mappings;
buildCharacterMappings(lineMappings.values());
LineMapping lineMapping = lineMappings.get(position.getLineNumber());
if (lineMapping == null) {
return null;
LineCharMapping lcm =
lineMapping.charToMap.get(position.getCharacterIndex());
if (lcm == null) {
return null;
return lcm.basisMapping;
LineMappingInformation info = determineLineMappings();
Map<Integer, LineMapping> lineMappings = info.mappings;
int maxLine = info.maxLine;
buildCharacterMappings(lineMappings.values());
out.append((maxLine + 1) + "");
for (int i = 0; i <= maxLine; ++i) {
LineMapping lineMapping = lineMappings.get(i);
if (lineMapping == null) {
out.append("[]");
lineMapping.appendCharMapTo(out);
out.append("\n");
for (int i = 0; i < mappings.size(); ++i) {
Mapping mapping = mappings.get(i);
switch (assertedNode.getType()) {
case Token.NAME:
JSType type = getJSType(assertedNode);
JSType narrowed = type.restrictByNotNullOrUndefined();
if (type != narrowed) {
scope = scope.createChildFlowScope();
redeclare(scope, assertedNode.getString(), narrowed);
break;
case Token.AND:
case Token.OR:
BooleanOutcomePair conditionOutcomes =
traverseWithinShortCircuitingBinOp(assertedNode, scope);
scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(
assertedNode, conditionOutcomes.getOutcomeFlowScope(
assertedNode.getType(), true), true);
break;
redeclare(scope, assertedNode.getString(), narrowed);
"[0]\n" +
"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9," +
"10,10,10,10,11,11,12,12,12,12,12,12,13,13,13,13,13,6]\n" +
"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9," +
"9,10,10,10,10,11,11,11,11,12,12,12,12,12,12,13,13,13," +
"13,13,6]\n" +
"[2,2,2,2]\n" +
Map<String, Token> tokens = Maps.newHashMap();
Map<String, Token> originalTokens = findTokens(js);
Map<String, Token> resultTokens = findTokens(result.generatedSource);
SourceMap.Mapping mapping =
result.sourceMap.getMappingFor(token.position);
assertEquals(mapping.originalPosition.getLineNumber(),
assertNotNull(mapping.originalName);
if (mapping.originalName != null) {private final Map<String, Property> props = Maps.newHashMap();
private final Map<String, Property> globals = Maps.newHashMap();
props.put("prototype", new Property("prototype"));
for (Property prop : props.values()) {
for (Property prop : props.values()) {
for (Property prop : props.values()) {
Property prop = props.get(propNameNode.getString());
props.put(dest.getString(), new Property(dest.getString()));
for (Property global : globals.values()) {
for (Property global : globals.values()) {
addGlobalAliasNode(global.name,
globals.put(name, new Property(name));
Property global = globals.get(name);
private void addGlobalAliasNode(String globalName, Node root) {
Node globalValue = Node.newString(Token.NAME, globalName);
private class Property {
public String name;
public Property(String name) {
private static final Logger logger_ =
private final AbstractCompiler compiler_;
private int numRemoved_ = 0;
private final Set<Var> warnedVars_ = Sets.newHashSet();
compiler_ = compiler;
warnedVars_.clear();
numRemoved_ = 0;
if (numRemoved_ > 0) {
compiler_.reportCodeChange();
Scope scope = new SyntacticScopeCreator(compiler_).createScope(root, null);
compiler_.getCodingConvention().isExported(
Scope fnScope = new SyntacticScopeCreator(compiler_).createScope(n, scope);
numRemoved_++;
CodingConvention convention = compiler_.getCodingConvention();
compiler_.addToDebugLog("Unreferenced var: " + var.name);
compiler_.reportCodeChange();
if (!warnedVars_.contains(var)) {
warnedVars_.add(var);
String inputName = var.input != null
? var.input.getName()
: "<unknown>";
logger_.info("Unused var " + var.name +
" declared in " + inputName +
" at line " + toRemove.getLineno() +
" may have side effects and can't be removed");
numRemoved_++;
numRemoved_++;
numRemoved_++;
List<String> files = Lists.newArrayList();
out.append(current.basisMapping.id + "");
out.append("]");
void appendFileMapTo(Appendable out) throws IOException {
Collections.sort(files);
out.append("[");
for (int j = 0; j < files.size(); ++j) {
if (j > 0) {
out.append(",");
out.append(escapeString(files.get(j)));
if (!lineMapping.files.contains(mapping.sourceFile)) {
lineMapping.files.add(mapping.sourceFile);
LineMapping lineMapping = lineMappings.get(i);
if (lineMapping == null) {
out.append("[]");
lineMapping.appendFileMapTo(out);
out.append("\n");
nodes.add(parameterType.getRoot());
nodes.add(thrownType.getRoot());
"var window;var document;var arguments;var _USER_ID;var ActiveXObject;" +
"[\"testcode\"]\n" +
"[\"testcode\"]\n" +
"[\"c:\\\\myfile.js\"]\n" +public static void internalForceInit() {}
if (!hasId) return false;
if (!hasSourceName) return false;
if (!hasLineNumber) return false;
if (!hasModuleName) return false;
if (!hasSize) return false;
if (!hasName) return false;
if (!hasCompiledSource) return false;
if (!hasId) return false;
if (!hasSourceName) return false;
if (!hasLineNumber) return false;
if (!hasModuleName) return false;
if (!hasSize) return false;
if (!hasName) return false;
if (!hasCompiledSource) return false;
com.google.javascript.jscomp.FunctionInfo.internalForceInit();
if (!hasName) return false;
if (!hasCompiledSource) return false;
if (!hasName) return false;
if (!hasCompiledSource) return false;
com.google.javascript.jscomp.FunctionInfo.internalForceInit();
entry_ = java.util.Collections.emptyList();
isEntryMutable = false;
module_ = java.util.Collections.emptyList();
isModuleMutable = false;
if (isEntryMutable) {
entry_ = java.util.Collections.unmodifiableList(entry_);
isEntryMutable = false;
result.entry_ = entry_;
if (isModuleMutable) {
module_ = java.util.Collections.unmodifiableList(module_);
isModuleMutable = false;
result.module_ = module_;
if (!other.entry_.isEmpty()) {
if (entry_.isEmpty()) {
entry_ = other.entry_;
isEntryMutable = false;
ensureEntryIsMutable();
entry_.addAll(other.entry_);
if (!other.module_.isEmpty()) {
if (module_.isEmpty()) {
module_ = other.module_;
isModuleMutable = false;
ensureModuleIsMutable();
module_.addAll(other.module_);
return java.util.Collections.unmodifiableList(entry_);
return entry_.size();
return entry_.get(index);
if (value == null) {
throw new NullPointerException();
ensureEntryIsMutable();
entry_.set(index, value);
ensureEntryIsMutable();
entry_.set(index, builderForValue.build());
if (value == null) {
throw new NullPointerException();
ensureEntryIsMutable();
entry_.add(value);
ensureEntryIsMutable();
entry_.add(builderForValue.build());
ensureEntryIsMutable();
super.addAll(values, entry_);
entry_ = java.util.Collections.emptyList();
isEntryMutable = false;
return java.util.Collections.unmodifiableList(module_);
return module_.size();
return module_.get(index);
if (value == null) {
throw new NullPointerException();
ensureModuleIsMutable();
module_.set(index, value);
ensureModuleIsMutable();
module_.set(index, builderForValue.build());
if (value == null) {
throw new NullPointerException();
ensureModuleIsMutable();
module_.add(value);
ensureModuleIsMutable();
module_.add(builderForValue.build());
ensureModuleIsMutable();
super.addAll(values, module_);
module_ = java.util.Collections.emptyList();
isModuleMutable = false;
com.google.javascript.jscomp.FunctionInfo.internalForceInit();
com.google.javascript.jscomp.InstrumentationTemplate.internalForceInit();
public static void internalForceInit() {}
new SourceInformationAnnotator(input.getName());
private String sourceFile = null;
public SourceInformationAnnotator(String sourceFile) {
if (sourceFile != null) {
n.putProp(Node.SOURCEFILE_PROP, sourceFile);
Node newBlock = new Node(Token.BLOCK, irNode,
irNode.getLineno(), irNode.getCharno());
Node node = new Node(transformTokenType(n.getType()));
Node node = new Node(Token.ARRAYLIT);
Node node = new Node(Token.SCRIPT);
Node node = new Node(Token.BREAK);
Node node = new Node(Token.CATCH, transform(catchVar));
Node catchCondition = new Node(Token.EMPTY);
return new Node(
Node node = new Node(Token.CONTINUE);
return new Node(
return new Node(
Node node = new Node(Token.EMPTY);
Node node = new Node(transformTokenType(statementNode.getType()));
return new Node(
Node node = new Node(
Node node = new Node(transformTokenType(callNode.getType()),
Node node = new Node(Token.FUNCTION);
Node lp = new Node(Token.LP);
Node node = new Node(Token.IF);
Node n =  new Node(
return new Node(transformTokenType(literalNode.getType()));
return Node.newString(Token.LABEL_NAME, labelNode.getName());
Node node = new Node(Token.LABEL);
cur = new Node(Token.LABEL);
return Node.newString(Token.NAME, nameNode.getIdentifier());
Node newNode = Node.newNumber(literalNode.getNumber());
return newNode;
Node node = new Node(Token.OBJECTLIT);
return new Node(
Node literalStringNode = Node.newString(literalNode.getValue());
Node node = new Node(Token.REGEXP, literalStringNode);
Node flagsNode = Node.newString(flags);
Node node = new Node(Token.RETURN);
Node n = Node.newString(literalNode.getValue());
node = new Node(Token.DEFAULT);
node = new Node(Token.CASE, transform(expr));
Node block = new Node(Token.BLOCK);
Node node = new Node(Token.SWITCH,
return new Node(Token.THROW,
Node node = new Node(Token.TRY,
Node block = new Node(Token.BLOCK);
Node node = new Node(type, operand);
Node node = new Node(Token.VAR);
return new Node(
return new Node(
return new Node(Token.EMPTY);
StringBuffer s = new StringBuffer();
StringBuffer buf = new StringBuffer(details);
return new TypePair(null, null);
StringBuffer sb = new StringBuffer(prepend);
StringBuffer sb = new StringBuffer();
StringBuffer actual = new StringBuffer();
StringBuffer expected = new StringBuffer();
private StringBuffer visited = new StringBuffer();
private StringBuffer shouldTraversed = new StringBuffer();
StringBuffer srcBuffer = new StringBuffer();
StringBuffer expectedBuffer = new StringBuffer();
StringBuffer sb = new StringBuffer("\"foo\";");
StringBuffer sb = new StringBuffer();
StringBuffer sb = new StringBuffer();
import com.google.common.collect.ImmutableList;
import java.util.Collections;
StringBuffer sb = new StringBuffer();Node actualParameterIterator = NodeUtil.getFnParameters(exportedFunction)
.getFirstChild();
while (actualParameterIterator != null) {
externParameters.add(actualParameterIterator.cloneNode());
actualParameterIterator = actualParameterIterator.getNext();
String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {
import java.io.FileWriter;
files.add(JSSourceFile.fromFile(new File(baseDir, included)));
FileWriter out = new FileWriter(this.outputFile);parent.replaceChild(block, block.removeFirstChild());
return true;
super.enableLineNumberCheck(true);
assertTrue(NodeUtil.tryMergeBlock(childBlock));
String expected = "foo:a();";
String difference = parse(expected).checkTreeEquals(actual);
assertNull("Nodes do not match:\n" + difference, difference);
"a:break a;");private FunctionInformationMap() {
initFields();
private Entry() {
initFields();
private int id_ = 0;
private java.lang.String sourceName_ = "";
private int lineNumber_ = 0;
private java.lang.String moduleName_ = "";
private int size_ = 0;
private java.lang.String name_ = "";
private java.lang.String compiledSource_ = "";
private com.google.javascript.jscomp.FunctionInformationMap.Entry result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap.Entry internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
com.google.javascript.jscomp.FunctionInformationMap.Entry returnMe = result;
result = null;
return returnMe;
return result.hasId();
return result.getId();
result.hasId = true;
result.id_ = value;
result.hasId = false;
result.id_ = 0;
return result.hasSourceName();
return result.getSourceName();
result.hasSourceName = true;
result.sourceName_ = value;
result.hasSourceName = false;
result.sourceName_ = getDefaultInstance().getSourceName();
return result.hasLineNumber();
return result.getLineNumber();
result.hasLineNumber = true;
result.lineNumber_ = value;
result.hasLineNumber = false;
result.lineNumber_ = 0;
return result.hasModuleName();
return result.getModuleName();
result.hasModuleName = true;
result.moduleName_ = value;
result.hasModuleName = false;
result.moduleName_ = getDefaultInstance().getModuleName();
return result.hasSize();
return result.getSize();
result.hasSize = true;
result.size_ = value;
result.hasSize = false;
result.size_ = 0;
return result.hasName();
return result.getName();
result.hasName = true;
result.name_ = value;
result.hasName = false;
result.name_ = getDefaultInstance().getName();
return result.hasCompiledSource();
return result.getCompiledSource();
result.hasCompiledSource = true;
result.compiledSource_ = value;
result.hasCompiledSource = false;
result.compiledSource_ = getDefaultInstance().getCompiledSource();
private Module() {
initFields();
private java.lang.String name_ = "";
private java.lang.String compiledSource_ = "";
private com.google.javascript.jscomp.FunctionInformationMap.Module result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap.Module internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
com.google.javascript.jscomp.FunctionInformationMap.Module returnMe = result;
result = null;
return returnMe;
return result.hasName();
return result.getName();
result.hasName = true;
result.name_ = value;
result.hasName = false;
result.name_ = getDefaultInstance().getName();
return result.hasCompiledSource();
return result.getCompiledSource();
result.hasCompiledSource = true;
result.compiledSource_ = value;
result.hasCompiledSource = false;
result.compiledSource_ = getDefaultInstance().getCompiledSource();
private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =
java.util.Collections.emptyList();
private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =
java.util.Collections.emptyList();
private com.google.javascript.jscomp.FunctionInformationMap result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
if (result.entry_ != java.util.Collections.EMPTY_LIST) {
result.entry_ =
java.util.Collections.unmodifiableList(result.entry_);
if (result.module_ != java.util.Collections.EMPTY_LIST) {
result.module_ =
java.util.Collections.unmodifiableList(result.module_);
com.google.javascript.jscomp.FunctionInformationMap returnMe = result;
result = null;
return returnMe;
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.addAll(other.entry_);
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.addAll(other.module_);
return java.util.Collections.unmodifiableList(result.entry_);
return result.getEntryCount();
return result.getEntry(index);
result.entry_.set(index, value);
result.entry_.set(index, builderForValue.build());
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.add(value);
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.add(builderForValue.build());
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
super.addAll(values, result.entry_);
result.entry_ = java.util.Collections.emptyList();
return java.util.Collections.unmodifiableList(result.module_);
return result.getModuleCount();
return result.getModule(index);
result.module_.set(index, value);
result.module_.set(index, builderForValue.build());
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.add(value);
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.add(builderForValue.build());
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
super.addAll(values, result.module_);
result.module_ = java.util.Collections.emptyList();
private Instrumentation() {
initFields();
private java.lang.String reportDefined_ = "";
private java.lang.String reportCall_ = "";
private java.lang.String reportExit_ = "";
private java.util.List<java.lang.String> declarationToRemove_ =
java.util.Collections.emptyList();
private java.util.List<java.lang.String> init_ =
java.util.Collections.emptyList();
private java.lang.String appNameSetter_ = "";
private com.google.javascript.jscomp.Instrumentation result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.Instrumentation();
return builder;
protected com.google.javascript.jscomp.Instrumentation internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.Instrumentation();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
if (result.declarationToRemove_ != java.util.Collections.EMPTY_LIST) {
result.declarationToRemove_ =
java.util.Collections.unmodifiableList(result.declarationToRemove_);
if (result.init_ != java.util.Collections.EMPTY_LIST) {
result.init_ =
java.util.Collections.unmodifiableList(result.init_);
com.google.javascript.jscomp.Instrumentation returnMe = result;
result = null;
return returnMe;
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
result.declarationToRemove_.addAll(other.declarationToRemove_);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
result.init_.addAll(other.init_);
return result.hasReportDefined();
return result.getReportDefined();
result.hasReportDefined = true;
result.reportDefined_ = value;
result.hasReportDefined = false;
result.reportDefined_ = getDefaultInstance().getReportDefined();
return result.hasReportCall();
return result.getReportCall();
result.hasReportCall = true;
result.reportCall_ = value;
result.hasReportCall = false;
result.reportCall_ = getDefaultInstance().getReportCall();
return result.hasReportExit();
return result.getReportExit();
result.hasReportExit = true;
result.reportExit_ = value;
result.hasReportExit = false;
result.reportExit_ = getDefaultInstance().getReportExit();
return java.util.Collections.unmodifiableList(result.declarationToRemove_);
return result.getDeclarationToRemoveCount();
return result.getDeclarationToRemove(index);
result.declarationToRemove_.set(index, value);
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
result.declarationToRemove_.add(value);
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
super.addAll(values, result.declarationToRemove_);
result.declarationToRemove_ = java.util.Collections.emptyList();
return java.util.Collections.unmodifiableList(result.init_);
return result.getInitCount();
return result.getInit(index);
result.init_.set(index, value);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
result.init_.add(value);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
super.addAll(values, result.init_);
result.init_ = java.util.Collections.emptyList();
return result.hasAppNameSetter();
return result.getAppNameSetter();
result.hasAppNameSetter = true;
result.appNameSetter_ = value;
result.hasAppNameSetter = false;
result.appNameSetter_ = getDefaultInstance().getAppNameSetter();
static final String ALIAS_NULL = "$$ALIAS_NULL";
static final String ALIAS_TRUE = "$$ALIAS_TRUE";
static final String ALIAS_FALSE = "$$ALIAS_FALSE";
static final String ALIAS_THROW = "$$ALIAS_THROW";
String code = toSource(root);
"function JSCompiler_stubMethod(id) {" +
"    return JSCompiler_stubMap[id].apply(this, arguments);" +
"function JSCompiler_unstubMethod(id, body) {" +
"  return JSCompiler_stubMap[id] = body;" +
private Node createExternFunction(Node exportedFunction) {   
checkForFunctionsWithUnknownTypes(exportedFunction);
new Node(Token.BLOCK), -1, -1);      
JSDocInfo functionJSDocInfo = function.getJSType().getJSDocInfo();
FunctionType functionType = (FunctionType) function.getJSType();
if (!Character.isUpperCase(name.charAt(0))) {
|| compiler.getCodingConvention().isConstant(n.getString())) {
private final boolean assertOnChange;
PrepareAst(AbstractCompiler compiler, boolean forbidChanges) {
this.assertOnChange = forbidChanges;
if (assertOnChange) {
if (assertOnChange) {
if (externs != null) {
NodeTraversal.traverse(
compiler, externs, new PrepareAnnotations(compiler));
if (root != null) {
NodeTraversal.traverse(
compiler, root, new PrepareAnnotations(compiler));
case Token.STRING:
if (convention.isConstant(nString)) {
Strings.truncateAtMaxLength(source, 100, true),
Strings.truncateAtMaxLength(source2, 100, true)));
if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {
if (NodeUtil.isAssignmentOp(parent)) {
report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
if (n.getType() == Token.RETURN) {
report(t, n, GOOG_SCOPE_USES_RETURN);
if (n.getType() == Token.THIS) {
report(t, n, GOOG_SCOPE_REFERENCES_THIS);
t.getCompiler().report(
t.makeError(call, WRONG_ARGUMENT_COUNT,
" and no more than " + maxArgs + " argument(s)" : ""));
import com.google.common.collect.ImmutableSet;
return this.isSubtype(that) && that.isSubtype(this);
ImmutableSet.Builder<JSType> resolvedTypes = ImmutableSet.builder();
Preconditions.checkState(newAlternates.hashCode() == this.hashcode);
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.javascript.rhino.jstype.UnionType;
import java.util.Set;
if (!alternate.isUnknownType()) {
Iterator<JSType> it = alternates.iterator();
while (it.hasNext()) {
JSType current = it.next();
if (!current.isUnknownType()) {
if (alternate.isSubtype(current)) {
return this;
it.remove();
Set<JSType> alternateSet = ImmutableSet.copyOf(alternates);
int size = alternateSet.size();
result = new UnionType(registry, alternateSet);
"var $$ALIAS_TRUE=true;"));
"var $$ALIAS_FALSE=false;"));
"var $$ALIAS_NULL=null;"));
"var $$ALIAS_TRUE=true;var $$ALIAS_NULL=null;var $$ALIAS_FALSE=false;");
repitions, "var $$ALIAS_TRUE=true;", AliasKeywords.ALIAS_TRUE);
testSame("var $$ALIAS_TRUE='foo';");
super.enableLineNumberCheck(true);
"var a$b = 0; var a$b = 1; var c = a$b;");
test("function CreateClass(a) {}" +
"function CreateClass(a) {}" +
"function CreateClass(a) {}" +
"function CreateClass(a) {}" +
options.checkTypes = true;if (condition != null && NodeUtil.isLiteralValue(condition) ) {
return NodeUtil.getBooleanValue(condition) ==
(Branch.ON_TRUE == branch);
if (condition != null && NodeUtil.isImmutableValue(condition)) {
return NodeUtil.getBooleanValue(condition) ==
(branch == Branch.ON_TRUE);
addExpr(first.getNext(), p);
addExpr(last, p);
boolean liftedExterns = false;
if (n.getJSDocInfo() != null && n.getJSDocInfo().isExterns()) {
externsRoot.addChildToBack(n);
input.setIsExtern(true);
input.getModule().remove(input);
externs.add(input);
liftedExterns = true;
if (liftedExterns) {
import com.google.common.collect.ImmutableSet;
private static final PassFactory peepholeOptimizations =
ImmutableSet<AbstractPeepholeOptimization> optimizations =
ImmutableSet.<AbstractPeepholeOptimization>of(
new PeepholeSubstituteAlternateSyntax());
final PeepholeOptimizationsPass peepholePass =
new PeepholeOptimizationsPass(compiler, optimizations);
return peepholePass;
private String tempNamePrefix = "JSCompiler_temp_";
return tempNamePrefix + safeNameIdSupplier.get();
String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get();
this.knownConstants.add(sName);
return sName;
class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback
private final StringBuilder sb;
private final List<String> paths;
abstract void generateExterns();
protected void appendInferredPaths(String path) {
for (int i = 0; i < pieces.size(); ++i) {
String cPath = Joiner.on(".").join(Iterables.limit(pieces, i + 1));
if (i == pieces.size() - 1 || !paths.contains(cPath)) {
if (i == 0) {
sb.append("var ");
sb.append(cPath);
if (i < pieces.size() - 1) {
sb.append(";\n");
paths.add(cPath);
protected Node getFunctionValue(Node value) {
Node definition = definitionParent.getLastChild();
protected void appendFunctionValue(Node definition) {
sb.append(" = ");
sb.append("function(");
Node parameters = definition.getFirstChild().getNext();
int i = 0;
for (Node current = parameters.getFirstChild();
current != null;
current = current.getNext()) {
if (i > 0) {
sb.append(", ");
sb.append(current.getString());
++i;
sb.append(") {}");
private final String symbolName;
private final Node value;
this.symbolName = symbolName;
this.value = value;
void generateExterns() {
appendInferredPaths(symbolName);
Node functionValue = getFunctionValue(value);
if (functionValue != null) {
appendFunctionValue(functionValue);
sb.append(";\n");
private final String symbolName;
private final Node value;
this.symbolName = symbolName;
this.value = value;
void generateExterns() {
String exportedPath = getExportedPath();
appendInferredPaths(exportedPath);
Node functionValue = getFunctionValue(value);
if (functionValue != null) {
appendFunctionValue(functionValue);
sb.append(";\n");
this.sb = new StringBuilder();
this.paths = Lists.newArrayList();
return sb.toString();
if (parent.getType() == Token.ASSIGN) {
import com.google.common.base.Predicates;
if (type == Token.BLOCK) {
tryFoldBlock(t, n, parent);
return;
if (!NodeUtil.isLiteralValue(left)) {
int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :
Token.TRUE;
if (type == Token.IF || type == Token.HOOK) {
tryFoldHookIf(t, n, parent);
return;
if (type == Token.DO) {
tryFoldDo(t, n, parent);
return;
if (type == Token.WHILE) {
tryFoldWhile(t, n, parent);
return;
if (type == Token.FOR) {
Node condition = NodeUtil.getConditionExpression(n);
if (condition != null) {
this.tryFoldForCondition(condition, n);
tryFoldFor(t, n, parent);
return;
if (type == Token.COMMA) {
tryFoldComma(t, n, left, right, parent);
return;
private void tryFoldComma(
NodeTraversal t, Node n, Node left, Node right, Node parent) {
if (!NodeUtil.mayHaveSideEffects(left)) {
n.removeChild(right);
parent.replaceChild(n, right);
t.getCompiler().reportCodeChange();
if (parent.getType() == Token.EXPR_RESULT) {
n.detachChildren();
parent.replaceChild(n, left);
Node newStatement = new Node(Token.EXPR_RESULT, right);
newStatement.copyInformationFrom(n);
parent.getParent().addChildAfter(newStatement, parent);
t.getCompiler().reportCodeChange();
void tryFoldBlock(NodeTraversal t, Node n, Node parent) {
for (Node c = n.getFirstChild(); c != null; ) {
Node next = c.getNext();  // save c.next, since 'c' may be removed
if (!NodeUtil.mayHaveSideEffects(c)) {
n.removeChild(c);  // lazy kids
t.getCompiler().reportCodeChange();
c = next;
if (n.isSyntheticBlock() || parent == null) {
return;
if (NodeUtil.tryMergeBlock(n)) {
t.getCompiler().reportCodeChange();
boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {
int type = n.getType();
Node cond = n.getFirstChild();
Node thenBody = cond.getNext();
Node elseBody = thenBody.getNext();
boolean changes = false;
if (type == Token.IF) {
if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {
n.removeChild(elseBody);
elseBody = null;
t.getCompiler().reportCodeChange();
changes = true;
if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {
n.removeChild(elseBody);
n.replaceChild(thenBody, elseBody);
Node notCond = new Node(Token.NOT);
n.replaceChild(cond, notCond);
notCond.addChildToFront(cond);
cond = notCond;
thenBody = cond.getNext();
elseBody = null;
t.getCompiler().reportCodeChange();
changes = true;
if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {
if (NodeUtil.mayHaveSideEffects(cond)) {
n.removeChild(cond);
parent.replaceChild(n, NodeUtil.newExpr(cond));
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
return true; // The if has been removed. There is nothing to do.
Preconditions.checkState(type == Token.HOOK);
if (NodeUtil.isExpressionNode(parent)) {
if (!NodeUtil.mayHaveSideEffects(thenBody)) {
Node ifNode = new Node(Token.IF);
if (cond.getType() == Token.NOT) {
Node expr = cond.getFirstChild();
cond.removeChild(expr);
ifNode.addChildToBack(expr);
Node not = new Node(Token.NOT).copyInformationFrom(cond);
n.removeChild(cond);
not.addChildToBack(cond);
ifNode.addChildToBack(not);
n.removeChild(elseBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))
.copyInformationFrom(elseBody));
parent.getParent().replaceChild(parent, ifNode);
t.getCompiler().reportCodeChange();
return true;
Node ifNode = new Node(Token.IF);
n.removeChild(cond);
ifNode.addChildToBack(cond);
n.removeChild(thenBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))
.copyInformationFrom(thenBody));
parent.getParent().replaceChild(parent, ifNode);
t.getCompiler().reportCodeChange();
return true;
if (!NodeUtil.isLiteralValue(cond)) {
return changes;  // We can't remove branches otherwise!
boolean condTrue = NodeUtil.getBooleanValue(cond);
if (n.getChildCount() == 2) {
Preconditions.checkState(type == Token.IF);
if (condTrue) {
Node thenStmt = n.getFirstChild().getNext();
n.removeChild(thenStmt);
parent.replaceChild(n, thenStmt);
t.getCompiler().reportCodeChange();
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
Node firstBranch = n.getFirstChild().getNext();
Node secondBranch = firstBranch.getNext();
Node branch = condTrue ? firstBranch : secondBranch;
Node notBranch = condTrue ? secondBranch : firstBranch;
NodeUtil.redeclareVarsInsideBranch(notBranch);
n.removeChild(branch);
parent.replaceChild(n, branch);
t.getCompiler().reportCodeChange();
return true;
if (NodeUtil.isLiteralValue(left)) {
boolean lval = NodeUtil.getBooleanValue(left);
boolean rval = NodeUtil.getBooleanValue(right);
void tryFoldWhile(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.WHILE);
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
void tryFoldFor(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.FOR);
if (n.getChildCount() != 4) return;
if (n.getFirstChild().getType() != Token.EMPTY) return;
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
void tryFoldDo(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.DO);
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
if (hasBreakOrContinue(n)) {
return;
Preconditions.checkState(
NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));
Node block = n.removeFirstChild();
parent.replaceChild(n, block);
t.getCompiler().reportCodeChange();
boolean hasBreakOrContinue(Node n) {
return NodeUtil.has(
n,
Predicates.<Node>or(
new NodeUtil.MatchNodeType(Token.BREAK),
new NodeUtil.MatchNodeType(Token.CONTINUE)),
new NodeUtil.MatchNotFunction());
private void tryFoldForCondition(Node n, Node parent) {
if (NodeUtil.isLiteralValue(n)) {
boolean result = NodeUtil.getBooleanValue(n);
if (result) {
parent.replaceChild(n, new Node(Token.EMPTY));
compiler.reportCodeChange();
return "JSCompiler_inline_result_" + safeNameIdSupplier.get();
if (containsSeparator(name)) {
String newName = getOrginalName(name);
if (TokenStream.isJSIdentifier(newName) &&
!referencedNames.contains(newName) && 
!newName.equals(ARGUMENTS)) {
referencedNames.remove(name);
referencedNames.add(newName);
List<Node> references = nameMap.get(name);
Preconditions.checkState(references != null);
for (Node n : references) {
Preconditions.checkState(n.getType() == Token.NAME);
n.setString(newName);
compiler.reportCodeChange();
import com.google.common.collect.HashMultimap;
HashMultimap.create();
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
if (NodeUtil.isLiteralValue(cond) && !NodeUtil.getBooleanValue(cond)) {
static boolean getBooleanValue(Node n) {
return n.getString().length() > 0;
return n.getDouble() != 0;
return false;
return false;
return true;
return true;
throw new IllegalArgumentException("Non-literal value: " + n);
if (NodeUtil.isLiteralValue(n)) {
boolean result = NodeUtil.getBooleanValue(n);
sb.append(" * @param {" + n.getJSType() + "} ");
(currentInfo.hasFileOverview() || currentInfo.isExterns());
import com.google.common.collect.ImmutableList;
import java.util.List;
List<String> parsePrintParseTestCases = ImmutableList.of(
"3;",
"var a = b;",
"var x, y, z;",
"try { foo() } catch(e) { bar() }",
"try { foo() } catch(e) { bar() } finally { stuff() }",
"try { foo() } finally { stuff() }",
"throw 'me'",
"function foo(a) { return a + 4; }",
"function foo() { return; }",
"var a = function(a, b) { foo(); return a + b; }",
"b = [3, 4, 'paul', \"Buchhe it\",,5];",
"v = (5, 6, 7, 8)",
"d = 34.0; x = 0; y = .3; z = -22",
"d = -x; t = !x + ~y;",
"'hi'; /* just a test */ stuff(a,b) \n foo(); // and another \n bar();",
"a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;",
"a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5",
"a = (2 + 3) * 4;",
"a = 1 + (2 + 3) + 4;",
"x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());",
"a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o",
"a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);",
"if (a > b) a = b; if (b < 3) a = 3; else c = 4;",
"if (a == b) { a++; } if (a == 0) { a++; } else { a --; }",
"for (var i in a) b += i;",
"for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}",
"for (x = 0; x < 10; x++) a /= 2;",
"for (;;) a++;",
"while(true) { blah(); }while(true) blah();",
"do stuff(); while(a>b);",
"[0, null, , true, false, this];",
"s.replace(/absc/, 'X').replace(/ab/gi, 'Y');",
"new Foo; new Bar(a, b,c);",
"with(foo()) { x = z; y = t; } with(bar()) a = z;",
"delete foo['bar']; delete foo;",
"var x = { 'a':'paul', 1:'3', 2:(3,4) };",
"switch(a) { case 2: case 3: { stuff(); break; }" +
"case 4: morestuff(); break; default: done();}",
"x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;",
"a.v = b.v; x['foo'] = y['zoo'];",
"'test' in x; 3 in x; a in x;",
"'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'",
"x.__proto__;");
for (String testCase : parsePrintParseTestCases) {
Node parse1 = parse(testCase);
Node parse2 = parse(new CodePrinter.Builder(parse1).build());
assertTrue(testCase, parse1.checkTreeEqualsSilent(parse2));
helperMoveExpression("foo()", "foo", "var temp_0 = foo(); temp_0;");
"var temp_0 = foo(); x = temp_0;");
"var temp_0 = foo(); var x = temp_0;");
"var temp_0 = foo(); if (temp_0);");
"var temp_0 = foo(); switch(temp_0){}");
"var temp_0 = foo(); switch(1 + temp_0){}");
"function (){ var temp_0 = foo(); return temp_0;}");
"var temp_0 = foo(); x = temp_0 && 1");
"var temp_0 = foo(); x = temp_0 || 1");
"var temp_0 = foo(); x = temp_0 ? 0 : 1");
"var temp_0; if (temp_0 = 0) temp_0 = foo(); x = temp_0;");
"var temp_0; if (temp_0 = 1); else temp_0 = foo(); x = temp_0;");
"var temp_0; if (1) temp_0 = foo(); else temp_0 = 0;var x = temp_0;");
"var temp_0; if (temp_0 = goo()) temp_0 = foo(); x = temp_0;");
"var temp_0; if (temp_0 = goo()) temp_0 = foo();" +
"var x = 1 + temp_0;");
"var temp_0;" +
"if (temp_0 = goo()) temp_0 = foo();" +
"if(temp_0);");
"var temp_0;" +
"if (temp_0 = goo()) temp_0 = foo();" +
"switch(temp_0){}");
"var temp_const_0 = 1 + goo();" +
"switch(temp_const_0 + foo()){}");
"var temp_0; if (temp_0 = goo()) temp_0 = foo();" +
"return temp_0;" +
"var temp_const_1 = goo;" +
"var temp_const_0 = goo(2);" +
"var temp_2;" +
"if (1) temp_2 = foo(); else temp_2 = 0;" +
"if (temp_const_1(1, temp_const_0, temp_2));");
"var x = 0; var temp_const_0 = x;" +
"x = temp_const_0 + (foo() + 1);");
"var x = 0; var temp_const_0 = x;" +
"y = (x = temp_const_0 + foo()) + x");
"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;" +
"temp_const_0.a = temp_const_1 + (foo() + 1);");
"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;" +
"y = (temp_const_0.a = temp_const_1 + foo()) + x.a");
"var XX = {}; var temp_const_0 = XX.a;" +
"XX.a = temp_const_0 + (foo() + 1);");
"var XX = {}; var temp_const_0 = XX.a;" +
"y = (XX.a = temp_const_0 + foo()) + XX.a");
"var temp_const_0 = goo();" +
"var temp_const_1 = temp_const_0.a;" +
"temp_const_0.a = temp_const_1 + (foo() + 1);");
"var temp_const_0 = goo();" +
"var temp_const_1 = temp_const_0.a;" +
"y = (temp_const_0.a = temp_const_1 + foo()) + goo().a");
"var temp_const_0 = goo().a;" +
"var temp_const_1 = temp_const_0.b;" +
"temp_const_0.b = temp_const_1 + (foo() + 1);");
"var temp_const_0 = goo().a;" +
"var temp_const_1 = temp_const_0.b;" +
"y = (temp_const_0.b = temp_const_1 + foo()) + goo().a");
decomposer.setTempNamePrefix("temp_");
decomposer.setTempNamePrefix("temp_");
private static final JSSourceFile[] EXTERNS = {
JSSourceFile.fromCode("externs", "")
"var foobar = function(d, e, f) {};\n");
"var a;\na.b;\na.b.cprop = function(d, e, f) {};\n");
"var a;\n" +
"a.b = function(p1) {};\n" +
"a.b.c = function(d, e, f) {};\n" +
"a.b.prototype;\n" +
"a.b.prototype.c = function(g, h, i) {};\n");
"var hello;\n" +
"hello.b;\n" +
"hello.b.c = function(d, e, f) {};\n" +
"hello.b.prototype;\n" +
"hello.b.prototype.c = function(g, h, i) {};\n");
"var prefix = function(p1) {};\n" +
"prefix.c = function(d, e, f) {};\n");
"var foobar;\n");
"var foobar;\n");
public void testExportNonexistantProperty() throws Exception {
"var a;\n" +
"a.b;\n" +
"a.b.none;\n");
System.err.println(compile(js));
assertEquals(expected, compile(js));
private String compile(String js) {
Result result = compiler.compile(EXTERNS, inputs, options);
return result.externExport;
import com.google.common.collect.ImmutableSet;
ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations =
ImmutableSet.<AbstractPeepholeOptimization>of(
new PeepholeSubstituteAlternateSyntax());
new PeepholeOptimizationsPass(compiler, peepholeOptimizations);
fold("if(x && true) z()", "x&&z()");
fold("if(x && false) z()", "");
fold("if(x==y && false) z()", "");
fold("do { foo() } while(!true);", "foo()");
fold("if(foo())do {foo()} while(false) else bar()", "foo()?foo():bar()");
fold("!!true", "0");
fold("!(!x&&!y)", "!x&&!y");
oneRepetitiontest.fold("x ? x() : void 0", "x&&x();");
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"if (JSCompiler_inline_result_0) throw 'test'; }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"return JSCompiler_inline_result_0; }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"switch(JSCompiler_inline_result_0) { default:break; } }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0?0:1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0&&1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"1 + JSCompiler_inline_result_0 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0&&1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"1 + JSCompiler_inline_result_0 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"var b = 1 + JSCompiler_inline_result_0 }",
"function x() { a:{{var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0?0:1 }}",
"function x() { var JSCompiler_temp_const_0=goo();" +
"var JSCompiler_temp_1;" +
"  {JSCompiler_temp_1=true;} " +
"  JSCompiler_temp_1=1;" +
"JSCompiler_temp_const_0 + JSCompiler_temp_1" +
"var JSCompiler_temp_const_0=z;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"var JSCompiler_temp_const_0=z;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"var JSCompiler_temp_const_1=z;" +
"var JSCompiler_temp_const_0=bar();" +
"var JSCompiler_inline_result_2;" +
"JSCompiler_inline_result_2 = true;" +
"JSCompiler_temp_const_1[JSCompiler_temp_const_0] = " +
"JSCompiler_inline_result_2;" +
"var JSCompiler_temp_const_0=z.y.x;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=_g;}" +
"1 + JSCompiler_inline_result_0() }",
"  {var JSCompiler_inline_result_0; JSCompiler_inline_result_0=_g;}" +
"  var CONSTANT_RESULT = JSCompiler_inline_result_0;" +
ImmutableList.of("foo?(bar=0):(baz=0)"));
"{var JSCompiler_inline_result_0;a();}" +
"c=z=JSCompiler_inline_result_0");
"{var JSCompiler_inline_result_0;a();}" +
"c=JSCompiler_inline_result_0=z");
"{var JSCompiler_inline_result_0;a();}" +
"if(z=JSCompiler_inline_result_0);");
"var JSCompiler_temp_const_0=z;" +
"{var JSCompiler_inline_result_1;a()}" +
"if(JSCompiler_temp_const_0.y=JSCompiler_inline_result_1);");
"var JSCompiler_temp_const_0 = x;" +
"{var JSCompiler_inline_result_1; a=1; JSCompiler_inline_result_1=1}" +
"x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;");
"var JSCompiler_inline_result_0;" +
"JSCompiler_inline_result_0 = ret$$inline_2;\n" +
"descriptions_=JSCompiler_inline_result_0;" +
"var a;function foo(){var a$$inline_1; a = 1}");
testSameInFunction(
"var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}");
testSameInFunction(
"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };");
testSameInFunction(
"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;");
testSameInFunction(
"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2");
invert = true;
testSameWithInversion(
"function foo(){var arguments$$1;}");
"function f(a, a$$1) {}");
"function f(a, a$$2) {}");
testSame("function () {" +
"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}");
"  var a$$1;" +
"  var a$$1;" +
"    var a;a$$1++" +
assertTrue(NodeUtil.getBooleanValue(getNode("true")));
assertTrue(NodeUtil.getBooleanValue(getNode("10")));
assertTrue(NodeUtil.getBooleanValue(getNode("'0'")));
assertTrue(NodeUtil.getBooleanValue(getNode("/a/")));
assertTrue(NodeUtil.getBooleanValue(getNode("{}")));
assertTrue(NodeUtil.getBooleanValue(getNode("[]")));
assertFalse(NodeUtil.getBooleanValue(getNode("false")));
assertFalse(NodeUtil.getBooleanValue(getNode("null")));
assertFalse(NodeUtil.getBooleanValue(getNode("0")));
assertFalse(NodeUtil.getBooleanValue(getNode("''")));
assertFalse(NodeUtil.getBooleanValue(getNode("undefined")));
assertFalse(NodeUtil.getBooleanValue(getNode("void 0")));
result = node.getFirstChild().toString(false, false, false);
result += " " + node.getLastChild().toString(false, false, false);&& aliasRefs.isAssignedOnce()) {
referenceInfo.isAssignedOnce()) {
referenceInfo.isAssignedOnce()) {
if (!refInfo.isAssignedOnce()) {
boolean isAssignedOnce() {
boolean assigned = false;
if (!assigned) {
assigned = true;
return false;
return assigned;import javax.annotation.Nullable;
import java.util.*;
private final ArrayList<String> localTempNames = new ArrayList<String>();
private boolean generatePseudoNames;
this.generatePseudoNames = generatePseudoNames;
localTempNames.add(tempName);
String newName = getNewLocalName(n, count);
if (generatePseudoNames) {
return getPseudoName(oldName);
private String getNewLocalName(Node n, int index) {
String oldTempName = localTempNames.get(index);
if (generatePseudoNames) {
return getPseudoName(n.getString());
private String getPseudoName(String s) {
Preconditions.checkState(generatePseudoNames);
return '$' + s + "$$";public void defineDelegateProxyProperties(
Map<ObjectType, FunctionType> delegateProxyMap);
public void defineDelegateProxyProperties(
Map<ObjectType, FunctionType> delegateProxyMap) {
if (NodeUtil.isFunctionExpression(n) ||
compiler_.getCodingConvention().isExported(
n.getFirstChild().getString())) {
import com.google.common.collect.Maps;
import java.util.Map;
private Map<ObjectType, FunctionType> delegateProxyMap = Maps.newHashMap();
codingConvention.defineDelegateProxyProperties(
typeRegistry, newScope, delegateProxyMap);
delegateProxyMap.put(delegateProxy.getPrototype(), delegateBaseCtor);
final Map<String, INPUT> provides = Maps.newHashMap();
provides.put(provide, input);
INPUT dep = provides.get(req);
node.addChildToBack(transformAsString(el.getLeft()));
node.addChildToBack(transform(el.getRight()));
JSType type = registry.createFromTypeNodes(root, sourceName, scope);
if (root.getBooleanProp(Node.BRACELESS_TYPE)) {
type.forgiveUnknownNames();
return type;
public void forgiveUnknownNames() {}
return createFromTypeNodes(n.getFirstChild(), sourceName, scope)
createFromTypeNodes(firstChild, sourceName, scope));
public void forgiveUnknownNames() {
public void forgiveUnknownNames() {
testSame("function foo(a) {}");
test("function foo(a) {}",
"function foo($a$$) {}");
testSame("foo(function bar(){})");    
public void testRemoveGlobal() {if (NodeUtil.isFunctionAnonymous(n)) {
Map<ObjectType, ObjectType> delegateProxyMap);
Map<ObjectType, ObjectType> delegateProxyMap) {
if (!NodeUtil.isAnonymousFunction(parent)) {
return new AnonymousFunctionDefinition(parent);
static final class AnonymousFunctionDefinition extends FunctionDefinition {
AnonymousFunctionDefinition(Node node) {
NodeUtil.isAnonymousFunction(node));
AnonymousFunctionNamer namer = new AnonymousFunctionNamer(functionMap);
private static class AnonymousFunctionNamer
AnonymousFunctionNamer(Map<Node, FunctionRecord> functionMap) {
if (!NodeUtil.isAnonymousFunction(node)) {
if (!NodeUtil.isAnonymousFunction(node)) {
if (!NodeUtil.isAnonymousFunction(node)) {
if (!NodeUtil.isAnonymousFunction(node)) {
if (!NodeUtil.isAnonymousFunction(node)) {
NodeUtil.isFunctionAnonymous(parent)) return;
private final boolean inlineAnonymousFunctionExpressions;
boolean inlineAnonymousFunctionExpressions,
this.inlineAnonymousFunctionExpressions =
inlineAnonymousFunctionExpressions;
return inlineLocalFunctions || inlineAnonymousFunctionExpressions
if (inlineAnonymousFunctionExpressions) {
findAnonymousFunctionExpressions(t, n);
if (!NodeUtil.isFunctionAnonymous(n)) {
public void findAnonymousFunctionExpressions(NodeTraversal t, Node n) {
Function fn = new AnonymousFunction(fnNode, callsSeen++);
private static class AnonymousFunction implements Function {
public AnonymousFunction(Node fn, int index) {
removeDeclaration(declaration);
return declaration.getParent().getType() == Token.VAR
&& declaration.getGrandparent().getType() != Token.FOR;
return initialization.getNameNode().getFirstChild() != null;
boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);
if (!anonymous) {
if (anonymous) {
return !isFunctionAnonymous(n);
Preconditions.checkState(isAnonymousFunction(n));
return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n);
static boolean isAnonymousFunction(Node n) {
return n.getType() == Token.FUNCTION && isFunctionAnonymous(n);
static boolean isFunctionAnonymous(Node n) {
return !isStatement(n);
if (!NodeUtil.isFunctionAnonymous(n)
!NodeUtil.isFunctionAnonymous(n)) {
return NodeUtil.getAssignedValue(getNameNode());
private boolean preserveAnonymousFunctionNames;
boolean preserveAnonymousFunctionNames) {
this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;
if (NodeUtil.isFunctionAnonymous(n) ||
NodeUtil.isFunctionAnonymous(toRemove)) {
if (!preserveAnonymousFunctionNames) {
private boolean preserveAnonymousFunctionNames;
boolean preserveAnonymousFunctionNames,
this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;
if (preserveAnonymousFunctionNames
&& NodeUtil.isAnonymousFunction(var.getParentNode())) {
if (name.length() > 0) {
if (!fnName.isEmpty() && NodeUtil.isFunctionAnonymous(n)) {
if (NodeUtil.isFunctionAnonymous(n)) {
private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();
ObjectType delegatorObject = ObjectType.cast(
typeRegistry.getType(delegateRelationship.delegator));
ObjectType delegateBaseObject = ObjectType.cast(
typeRegistry.getType(delegateRelationship.delegateBase));
ObjectType delegateSuperObject = ObjectType.cast(
typeRegistry.getType(
codingConvention.getDelegateSuperclassName()));
if (delegatorObject != null &&
delegateBaseObject != null &&
delegateSuperObject != null) {
FunctionType delegatorCtor = delegatorObject.getConstructor();
FunctionType delegateBaseCtor =
delegateBaseObject.getConstructor();
FunctionType delegateSuperCtor =
delegateSuperObject.getConstructor();
if (delegatorCtor != null && delegateBaseCtor != null &&
delegateSuperCtor != null) {
FunctionParamBuilder functionParamBuilder =
new FunctionParamBuilder(typeRegistry);
functionParamBuilder.addRequiredParams(
typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));
FunctionType findDelegate = typeRegistry.createFunctionType(
typeRegistry.createDefaultObjectUnion(
delegateBaseObject),
functionParamBuilder.build());
FunctionType delegateProxy =
typeRegistry.createConstructorType(
delegateBaseObject.getReferenceName(), null, null,
null);
delegateProxy.setPrototypeBasedOn(delegateBaseCtor);
codingConvention.applyDelegateRelationship(
delegateSuperObject, delegateBaseObject, delegatorObject,
delegateProxy, findDelegate);
delegateProxyMap.put(
delegateProxy.getPrototype(),
delegateBaseCtor.getPrototype());
if (!NodeUtil.isAnonymousFunction(parent)) {
if (NodeUtil.isAnonymousFunction(parent)) {
test("function Foo() {};" +
"function a() {};" +
"throw new a().a;");
test("function Foo() {};" +
"function $Foo$$() {};" +
"throw new $Foo$$().$x$;");
public void testRemoveAnonymousFunctionName() {
helperCanExposeAnonymousFunctionExpression(
private void helperCanExposeAnonymousFunctionExpression(
final boolean allowAnonymousFunctionExpressionInlining = true;
allowAnonymousFunctionExpressionInlining,
public void testDecomposeAnonymousInCall() {
public void testAnonymousFunctionInlining1() {
public void testAnonymousFunctionInlining2() {
public void testAnonymousFunctionInlining3() {
public void testAnonymousFunctionInlining4() {
public void testAnonymousFunctionCallInlining1() {
public void testAnonymousFunctionCallInlining2() {
public void testAnonymousFunctionCallInlining3() {
public void testAnonymousFunctionCallInlining4() {
public void testAnonymousFunctionCallInlining5() {
public void testAnonymousFunctionCallInlining6() {
public void testAnonymousFunctionCallInlining7() {
public void testAnonymousFunctionCallInlining8() {
public void testAnonymousFunctionCallInlining9() {
public void testAnonymousFunctionCallInlining10() {
public void testAnonymousFunctionCallInlining11() {
public void testAnonymousFunctionCallInlining12() {
public void testAnonymousFunctionOmega() {
public void testAnonymousFunctionYCombinator() {
"function cow() { a++; }; cow(); var z = x;"});
public void testInlineFunctionAlias1() {
"function f(x) {};" +
public void testInlineFunctionAlias2() {
"var y; y = f;" +
"f;" +
public void testAnonymousFunctions() {
public void testAnonymousFunction() {
public void testAnonymousFunction2() {
public void testIsFunctionAnonymous() {
assertEquals(expected, NodeUtil.isFunctionAnonymous(funcNode));
public void testIsAnonymousFunction1() {
assertTrue(NodeUtil.isAnonymousFunction(functionNode));
public void testIsAnonymousFunction2() {
assertFalse(NodeUtil.isAnonymousFunction(functionNode));
private boolean preserveAnonymousFunctionNames = false;
preserveAnonymousFunctionNames = false;
compiler, removeGlobal, preserveAnonymousFunctionNames);
preserveAnonymousFunctionNames = true;
preserveAnonymousFunctionNames = true;
private boolean preserveAnonymousFunctionNames = false;
localRenamingOnly, preserveAnonymousFunctionNames,
preserveAnonymousFunctionNames = false;
preserveAnonymousFunctionNames = true;private final boolean validation;
CodeConsumer consumer, Charset outputCharset, boolean validation) {
this.validation = validation;
CodeGenerator(CodeConsumer consumer, Charset outputCharset) {
this(consumer, outputCharset, true);
this(consumer, null, false);
if (first.getType() != Token.LABEL_NAME && validation) {
if (first.getType() != Token.LABEL_NAME && validation) {
if (type == Token.EXPR_VOID && validation) {
if (first.getType() != Token.LABEL_NAME && validation) {
if (validation) {
throw new Error("Missing BLOCK child.");
private boolean validation = true;
Builder setValidation(boolean validation) {
this.validation = validation;
return this;
sourceMap, outputCharset, validation);
Charset outputCharset,
boolean validation) {
: new CodeGenerator(cp, outputCharset, validation);
private final TypeValidator typeValidator;
this.typeValidator = new TypeValidator(this);
typeRegistry = new JSTypeRegistry(oldErrorReporter);
if (options.closurePass) {
checks.add(closureReplaceGetCssName);
Node.newString("-" + second.getString()));
super(consumer, outputCharset, true);
typeRegistry.createNullableType(delegateBaseObject), null);
return createNullableType(
return createNullableType(namedType);
BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry());
compiler.initCompilerOptionsIfTesting();
compiler.getOptions().setWarningLevel(
DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);
new SyntacticScopeCreator(new Compiler()));
new SyntacticScopeCreator(new Compiler()));
"definition at  [testcode] :3 with type (Number|null)");
"definition at  [testcode] :1 with type (Number|null)");
"original definition at  [testcode] :1 with type function (number): ?");
"original definition at  [testcode] :1 with type function (?): ?");
"original definition at  [testcode] :1 with type Foo");
"original definition at  [testcode] :1 with type Foo");
"original definition at  [testcode] :1 with type Foo");
"original definition at  [testcode] :2 with type number");
"original definition at  [testcode] :1 with type enum{a.A}");
"original definition at  [testcode] :1 " +
"original definition at  [testcode] :1 " +
private TypeCheckResult parseAndTypeCheckWithScope(String externs,
String js) {
Node externsNode = compiler.parseTestCode(externs);
Node n = compiler.parseTestCode(js);static final String DIAGNOSTIC_GROUP_NAMES = "accessControls, checkVars, " +
"checkTypes, deprecated, fileoverviewTags, invalidCasts, " +
public static DiagnosticGroup CHECK_VARIABLES =
DiagnosticGroups.registerGroup("checkVars",
new DiagnosticGroup(
VarCheck.UNDEFINED_VAR_ERROR,
SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));
if (parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT) {
protected CompilerPass getProcessor(Compiler compiler) {
return new FlowSensitiveInlineVariables(compiler);
"for(var x = 0; x < 10; x++) {j = x.next()};");
test("function _func() {" + input + "}",
"function _func() {" + expected + "}");private CompilerInput[] externs;
private JSModule[] modules;
private CompilerInput[] inputs;
private CompilerInput[] makeCompilerInput(
JSSourceFile[] files, boolean isExtern) {
CompilerInput [] inputs = new CompilerInput[files.length];
for (int i = 0; i < files.length; ++i) {
inputs[i] = new CompilerInput(files[i], isExtern);
private void checkFirstModule(JSModule[] modules) {
if (modules.length == 0) {
modules[0].getName()));
private void fillEmptyModules(JSModule[] modules) {
for (int i = 1; i < modules.length; i ++) {
JSModule module = modules[i];
private CompilerInput[] getAllInputsFromModules() {
List<CompilerInput> inputs = new ArrayList<CompilerInput>();
Map<String, JSModule> inputMap = new HashMap<String, JSModule>();
return new CompilerInput[0];
return inputs.toArray(new CompilerInput[inputs.size()]);
init(externs, modules, options);
int numInputs = inputs.length;
Node scriptNode = inputs[i].getAstRoot(Compiler.this);
if (inputs.length == 0) {
return inputs[0].getAstRoot(this);
List<CompilerInput> inputs = module.getInputs();
if (inputs.size() > 0) {
return inputs.get(0).getAstRoot(this);
private CompilerInput[] externs;
private CompilerInput[] inputs;
private JSModule[] modules;
private final boolean isExtern;
moduleDepths = new HashMap<JSModule, Integer>(modulesInDepOrder.length);
modulesByDepth = new ArrayList<List<JSModule>>();
private void markAllParametersEscaped() {
case ANNOTATION:
case EOC:
case EOF:
String multilineText = builder.toString();
if (option != WhitespaceOption.PRESERVE) {
multilineText = multilineText.trim();
int endLineno = stream.getLineno();
int endCharno = stream.getCharno();
if (multilineText.length() > 0) {
jsdocBuilder.markText(multilineText, startLineno, startCharno,
endLineno, endCharno);
return new ExtractionInfo(multilineText, token);
"function FUNC(x, y) {         y; y=0; y; x; x=0; x}");if (!NodeUtil.isLabelName(n) && !isDeclaration(n)) {
if (NodeUtil.isLabelName(n)) {
return;private Predicate<N> nodePredicate;
private Predicate<DiGraphEdge<N, E>> edgePredicate;
private boolean result;
Predicate<DiGraphEdge<N, E>> edgePredicate) {
graph.pushNodeAnnotations();
graph.pushEdgeAnnotations();
discoverBackEdges(a);
result = checkAllPathsWithoutBackEdges(a, b);
graph.popNodeAnnotations();
graph.popEdgeAnnotations();
if (nodePredicate.apply(a.getValue())) {if (numJsFiles < 1) {
CompilerOptions options_ = null;
private CompilerInput[] externs_;
private JSModule[] modules_;
private JSModuleGraph moduleGraph_;
private CompilerInput[] inputs_;
private Map<String, CompilerInput> inputsByName_;
private SourceMap sourceMap_;
private String externExports_ = null;
private FunctionInformationMap functionInformationMap_;
private final StringBuilder debugLog_ = new StringBuilder();
private static final Logger logger_ =
boolean colorize = options_.shouldColorizeErrorOutput();
return options_.errorFormat.toFormatter(this, colorize);
options_ = options;
new LoggerErrorManager(createMessageFormatter(), logger_));
printer.setSummaryDetailLevel(options_.summaryDetailLevel);
externs_ = makeCompilerInput(externs, true);
modules_ = null;
moduleGraph_ = null;
inputs_ = makeCompilerInput(inputs, false);
externs_ = makeCompilerInput(externs, true);
modules_ = modules;
moduleGraph_ = new JSModuleGraph(modules);
inputs_ = getAllInputsFromModules();
if (options_.sourceMapOutputPath != null) {
sourceMap_ = new SourceMap();
inputs_ = getAllInputsFromModules();
for (JSModule module : modules_) {
inputsByName_ = new HashMap<String, CompilerInput>();
for (CompilerInput input : externs_) {
if (!inputsByName_.containsKey(name)) {
inputsByName_.put(name, input);
for (CompilerInput input : inputs_) {
if (!inputsByName_.containsKey(name)) {
inputsByName_.put(name, input);
final boolean dumpTraceReport = options_.tracer.isOn();
if (options_.nameAnonymousFunctionsOnly) {
if (!options_.skipAllPasses) {
if (options_.externExportsPath != null) {
if (!options_.ideMode) {
if (options_.recordFunctionInformation) {
if (options_.devMode == DevMode.START_AND_END) {
return new DefaultPassConfig(options_);
if (options_.devMode == DevMode.EVERY_PASS) {
if (options_.nameAnonymousFunctionsOnly) {
if (options_.removeTryCatchFinally) {
if (!options_.stripTypes.isEmpty() ||
!options_.stripNameSuffixes.isEmpty() ||
!options_.stripTypePrefixes.isEmpty() ||
!options_.stripNamePrefixes.isEmpty()) {
stripCode(options_.stripTypes, options_.stripNameSuffixes,
options_.stripTypePrefixes, options_.stripNamePrefixes);
logger_.info("Creating extern file for exports");
externExports_ = pass.getGeneratedExterns();
if (options_.devMode == DevMode.EVERY_PASS) {
logger_.info("Remove try/catch/finally");
logger_.info("Strip code");
if (options_.customPasses != null) {
for (CompilerPass p : options_.customPasses.get(executionTime)) {
if (options_.tracer.isOn()) {
if (options_.tracer.isOn()) {
return new Result(getErrors(), getWarnings(), debugLog_.toString(),
state.anonymousFunctionNameMap, functionInformationMap_,
sourceMap_, externExports_, state.cssNames);
if (options_.ambiguateProperties ||
options_.disambiguateProperties) {
return inputsByName_.get(name);
if (inputsByName_.containsKey(name)) {
inputsByName_.put(name, input);
inputsByName_.put(sourceName, new CompilerInput(ast));
return moduleGraph_;
if (options_.closurePass) {
boolean devMode = options_.devMode != DevMode.OFF;
if (options_.tracer.isOn()) {
options_.tracer == TracerMode.ALL);
for (CompilerInput input : externs_) {
for (CompilerInput input : inputs_) {
if (options_.sourceMapOutputPath != null ||
options_.nameReferenceReportPath != null) {
inputsByName_.put(input.getName(), input);
if (options_ == null) {
if (inputsByName_ == null) {
inputsByName_ = Maps.newHashMap();
inputsByName_.put(input.getName(), input);
int numInputs = inputs_.length;
Node scriptNode = inputs_[i].getAstRoot(Compiler.this);
if (options_.printInputDelimiter) {
String delimiter = options_.inputDelimiter;
if (options_.sourceMapOutputPath != null) {
sourceMap_.setStartingPosition(
builder.setPrettyPrint(options_.prettyPrint);
builder.setLineBreak(options_.lineBreak);
builder.setSourceMap(sourceMap_);
builder.setOutputCharset(options_.outputCharset);
if (options_.devMode == DevMode.EVERY_PASS) {
options_.cssRenamingMap = map;
return options_.cssRenamingMap;
(new DefaultPassConfig(options_)).processDefines.create(this)
return options_.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||
options_.propertyRenaming ==
logger_.info("Computing Control Flow Graph");
logger_.info("Normalizing");
logger_.info("Recording function information");
functionInformationMap_ = recordFunctionInfoPass.getMap();
CodingConvention convention = options_.getCodingConvention();
return options_.ideMode;
return options_.checkTypes;
WarningsGuard guard = options_.getWarningsGuard();
debugLog_.append(str);
debugLog_.append('\n');
logger_.fine(str);
if (inputsByName_.containsKey(sourceName)) {
return inputsByName_.get(sourceName).getSourceFile();
if (inputs_.length == 0) {
return inputs_[0].getAstRoot(this);
for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
inputs = m.getInputs();
if (inputs.size() > 0) {
return inputs.get(0).getAstRoot(this);
return sourceMap_;
return options_;
return functionInformationMap_;
logger_.setLevel(level);
if (options_ == null) {
state.externs = externs_;
state.inputs = inputs_;
state.modules = modules_;
externs_ = state.externs;
inputs_ = state.inputs;
modules_ = state.modules;
compiler.options_.setWarningLevel(
compiler.options_.setCodingConvention(new GoogleCodingConvention());
compiler.options_.setCodingConvention(new GoogleCodingConvention());
compiler.options_.setCodingConvention(new GoogleCodingConvention());
compiler.options_.setCodingConvention(new GoogleCodingConvention());protected DiagnosticGroups getDiagnoticGroups() {
DiagnosticGroups diagnosticGroups = getDiagnoticGroups();
abstract void report(JSError error);
void report(JSError error) {
DiagnosticGroup forName(String name) {
if (parent.getType() == Token.VAR) {
if (n.hasChildren()) {
Node value = n.getFirstChild();
n.removeChild(value);
Node replacement = new Node(Token.ASSIGN, n, value);
gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));
if (NodeUtil.isStatementBlock(gramps)) {
gramps.removeChild(parent);
parent.removeChild(n);
gramps.replaceChild(parent, n);
Preconditions.checkState(gramps.getType() == Token.LABEL);
gramps.replaceChild(parent, new Node(Token.EMPTY));
reportCodeChange("Duplicate VAR declaration");
"function f() { f(); a:{function bar() {}}}");
testSame("function f() { f(); {function bar() {}}}");
testSame("function f() { f(); if (true) {function bar() {}}}");((PrintStreamErrorManager) compiler.getErrorManager())
.setSummaryDetailLevel(config.summaryDetailLevel);
CompilerOptions options_ = createDefaultOptions();
addChangeHandler(recentChange);
this.typeValidator = new TypeValidator(this);
setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger_));
this();
setErrorManager(
new PrintStreamErrorManager(createMessageFormatter(), stream));
CompilerOptions createDefaultOptions() {
return new CompilerOptions();
options_ = options;
options_ = options;
mod.sortInputsByDeps(new Compiler(System.err));logger.log(level, "{0} error(s), {1} warning(s)",
new Object[] {getErrorCount(), getWarningCount()});
import java.text.*;
VariableMap vm = new VariableMap(Maps.immutableMap("AAA", "a", "BBB", "b"));import com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig;PrintStream out = openSourceMapStream(options, path + ".js");
convention.getClassesDefinedByCall(insertionPoint) == null) {
int i = 0;
do {
numRemoved_ = 0;
referenced.clear();
traverseAndRemoveUnusedReferences(root);
if (numRemoved_ > 0) {
compiler_.reportCodeChange();
logger_.fine("RemoveUnusedVars(" + i + "): removed " + numRemoved_);
if (i == MAX_ITERATIONS) {
logger_.warning("Reached max allowable iterations. Stopping.");
"var d;var f=[d];print(f[0])");
"var e,f,h;" +node.replaceChild(child, Node.newString(Token.NAME, name));
if (var != null &&
!var.isTypeInferred() &&
!objectType.hasOwnProperty(propName) &&
(!objectType.isInstanceType() ||
(var.isExtern() && !objectType.isNativeObjectType()))) {
objectType.defineDeclaredProperty(
propName, var.getType(), var.isExtern());
return true;
return new FunctionTypeInformationGatherer(
private static class FunctionTypeInformationGatherer
FunctionTypeInformationGatherer(Compiler compiler,
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));
assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));"output to the specified path. If %module% is added, " +
"a source map will be generated for each module, with the " +
" module's name placed into the path at that spot")
mapOut = openSourceMapStream(options, moduleFilePrefix, null);
mapOut =
openSourceMapStream(options, moduleFilePrefix, m.getName());
&& options.sourceMapOutputPath.contains("%module%");
private PrintStream openSourceMapStream(B options, String path,
String module) throws IOException {
if (module != null) {
sourceMapPath = sourceMapPath.replace("%module%", module);
PrintStream out = openSourceMapStream(options, path, null);
Node value = init.getAssignedValue();
return compiler.getCodingConvention().isExported(var.name) ||
staleVars.contains(var);
Reference refInit = refInfo.getInitializingReference();
if (!isValidInitialization(refInit)) {
return false;
if (refDecl != refInit) {
Preconditions.checkState(refInit == refSet.get(1));
startingReadRef = 2;
if (!refInfo.isWellDefined()) {
return false;
Node value = refInit.getAssignedValue();
Preconditions.checkNotNull(value);
return NodeUtil.isImmutableValue(value) &&
(value.getType() != Token.STRING ||
isStringWorthInlining(v, refInfo.references));
final JSType returnType;
private final JSType primitiveType;
private final ObjectType primitiveObjectType;
private final EnumElementType elementsType;
private final ArrowType call;
private boolean isResolved = false;
public boolean isResolved() {
return isResolved;
public void clearResolved() {
isResolved = false;
public void resolve(ErrorReporter t, StaticScope<JSType> enclosing) {
if (isResolved()) return;
resolveViaRegistry(t, enclosing);
if (isResolved()) return;
private void resolveViaRegistry(
isResolved = true;
isResolved = true;
isResolved = true;
private final JSType type;
private final Map<String, JSType> properties = new HashMap<String, JSType>();
private final Map<String, JSType> properties = Maps.newHashMap();
if (properties.size() == 0) {
return registry.createRecordType(properties);
final Set<JSType> alternates;
import com.google.common.collect.ImmutableList;
import com.google.javascript.rhino.jstype.JSType.TypePair;
private static final StaticScope<JSType> EMPTY_SCOPE =
new StaticScope<JSType>() {
public StaticScope<JSType> getParentScope() { return null; }
public StaticSlot<JSType> getSlot(String name) { return null; }
public StaticSlot<JSType> getOwnSlot(String name) { return null; }
public JSType getTypeOfThis() { return null; }import com.google.javascript.jscomp.graph.GraphNode;
import com.google.javascript.jscomp.graph.UndiGraph;
private final Deque<GraphColoring<Var, ?>> colorings;
private StringBuilder coalescedLog;
CoalesceVariableNames(AbstractCompiler compiler) {
coalescedLog = new StringBuilder();
compiler.addToDebugLog("JS vars coalesced:\n" + coalescedLog.toString());
coalescedLog = new StringBuilder();
GraphColoring<Var, ?> coloring =
if (vNode.getValue().equals(coalescedVar)) {
return;
if (var.getNameNode() == n) {
coalescedLog.append(n.getString()).append(" => ")
.append(coalescedVar.name).append(" in ")
.append(t.getSourceName()).append(':')
.append(n.getLineno()).append('\n');
n.setString(coalescedVar.name);
compiler.reportCodeChange();
if (NodeUtil.isVar(parent)) {
removeVarDeclaration(n);
return new CoalesceVariableNames(compiler);
error(t, INVALID_GETELEM_INDEX_ERROR, right);
new CoalesceVariableNames(compiler));
fold("x = [10, 20]['abc']", "", FoldConstants.INVALID_GETELEM_INDEX_ERROR);CodeGenerator(CodeConsumer consumer, Charset outputCharset) {
this(consumer, null);
sourceMap, outputCharset);
Charset outputCharset) {
: new CodeGenerator(cp, outputCharset);
if (root == null) {
NodeTraversal.traverse(compiler, root, renamer);
super(consumer, outputCharset);
assertTrue(conv.isVarArgsParameter(args.getLastChild()));
assertTrue(conv.isVarArgsParameter(optArgs.getLastChild()));
assertTrue(conv.isOptionalParameter(args.getFirstChild()));
assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));
Node mainRootClone = mainRoot.cloneTree();
normalize.process(externsRoot, mainRootClone);
assertFalse(ALL_TYPE.matchesObjectContext());final protected void initOptionsFromFlags(CompilerOptions options) {
DiagnosticGroups.setWarningLevels(
DiagnosticGroups.setWarningLevels(
DiagnosticGroups.setWarningLevels(
initInputsByNameMap();
if (options_.sourceMapOutputPath != null) {
this.sourceMap_ = new SourceMap();
import java.util.ArrayDeque;
import java.util.Deque;
private Deque<String> switchLabels = new ArrayDeque<String>();
static final DiagnosticType INVALID_BREAK = DiagnosticType.error(
"JSC_INVALID_BREAK",
"unlabeled break must be inside loop or switch");
static final DiagnosticType INVALID_CONTINUE = DiagnosticType.error(
"JSC_INVALID_CONTINUE",
"continue must be inside loop");
static final DiagnosticType INVALID_LABEL_CONTINUE = DiagnosticType.error(
"JSC_INVALID_LABEL_CONTINUE",
"continue can only target labels of loop structures");
check(root, false, false);
private void check(Node node, boolean inLoop, boolean inSwitch) {
case Token.FUNCTION:
Deque<String> oldSwitchLabels = switchLabels;
switchLabels = new ArrayDeque<String>();
Node body = node.getFirstChild().getNext().getNext();
check(body, false, false);
switchLabels = oldSwitchLabels;
break;
case Token.FOR:
Node child = node.getFirstChild();
check(child, inLoop, inSwitch);
child = child.getNext();
check(child, inLoop, inSwitch);
child = child.getNext();
if (child.getNext() == null) {
check(child, true, inSwitch);
check(child, inLoop, inSwitch);
check(child.getNext(), true, inSwitch);
break;
case Token.WHILE:
check(node.getFirstChild(), inLoop, inSwitch);
check(node.getFirstChild().getNext(), true, inSwitch);
break;
case Token.DO:
check(node.getFirstChild(), true, inSwitch);
break;
case Token.SWITCH:
check(node.getFirstChild(), inLoop, inSwitch);
for (Node cChild = node.getFirstChild().getNext(); cChild != null;) {
Node next = cChild.getNext();
check(cChild, inLoop, true);
cChild = next;
break;
for (Node sChild = node.getFirstChild(); sChild != null;) {
Node next = sChild.getNext();
check(sChild, false, false);
sChild = next;
break;
case Token.LABEL:
Node switchNode = node.getLastChild();
if (switchNode.getType() == Token.SWITCH) {
String label = node.getFirstChild().getString();
switchLabels.addFirst(label);
check(node.getFirstChild().getNext(), inLoop, inSwitch);
switchLabels.removeFirst();
check(node.getFirstChild().getNext(), inLoop, inSwitch);
case Token.BREAK:
if (!node.hasChildren() && !inLoop && !inSwitch) {
report(node, INVALID_BREAK);
break;
case Token.CONTINUE:
if (!inLoop) {
report(node, INVALID_CONTINUE);
if (node.hasChildren()) {
Node label = node.getFirstChild();
if (switchLabels.contains(label.getString())) {
report(node, INVALID_LABEL_CONTINUE);
break;
default:
for (Node bChild = node.getFirstChild(); bChild != null;) {
Node next = bChild.getNext();
check(bChild, inLoop, inSwitch);
bChild = next;
private DiagnosticGroups() {} // all static
static DiagnosticGroup forName(String name) {
static void setWarningLevels(CompilerOptions options,
DiagnosticGroup group = DiagnosticGroups.forName(name);
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
case Token.FUNCTION:
JSType fnType = n.getJSType();
if (fnType == null) {
break;
(parent.getType() == Token.ASSIGN ||
parent.getType() == Token.NAME)) {
if (docInfo == null) {
Node gramps = parent.getParent();
if (gramps != null && gramps.getType() == Token.VAR &&
gramps.hasOneChild()) {
docInfo = gramps.getJSDocInfo();
if (docInfo != null && fnType instanceof FunctionType) {
FunctionType maybeCtorType = (FunctionType) fnType;
maybeCtorType.setJSDocInfo(docInfo);
if (maybeCtorType.isConstructor()) {
maybeCtorType.getInstanceType().setJSDocInfo(docInfo);
JSType lhsType = n.getFirstChild().getJSType();
if (lhsType != null &&
lhsType instanceof ObjectType) {
ObjectType objectType = (ObjectType) lhsType;
objectType.setPropertyJSDocInfo(
n.getLastChild().getString(), docInfo, inExterns);
sanityCheckCodeGeneration(root);
private void sanityCheckCodeGeneration(Node root) {
return;
return;
DiagnosticType.warning(
DiagnosticType.warning(
DiagnosticType.warning(
boolean isNominalType() {
boolean isNominalType() {
boolean isNominalType() {
boolean isNominalType() {
boolean isNominalType() {
ErrorManager symbolTableWarnings = new BlackHoleErrorManager(compiler);
JSError[] warnings = symbolTableWarnings.getWarnings();
assertEquals("There should be one symbol table warning",
1, warnings.length);
assertEquals(warning, warnings[0].getType());
assertInvalidLabelContinue(
public void testContinueNotCrossFunction() {
assertSomeError(js, ControlStructureCheck.INVALID_BREAK);
assertSomeError(js, ControlStructureCheck.INVALID_CONTINUE);
private void assertInvalidLabelContinue(String js) {
assertSomeError(js, ControlStructureCheck.INVALID_LABEL_CONTINUE);
private void assertSomeError(String js, DiagnosticType error) {
if (!hasParseError(js)) {
test(js, js, error);
private boolean hasParseError(String js) {
return compiler.getErrorCount() > 0;
fold("for(;!false;) foo() ", "for(;1;) foo()");
fold("for(;true;) foo() ", "for(;1;) foo() ");
fold("for(;!void 0;) foo()", "for(;1;) foo()");
compiler.init(new JSSourceFile[] {}, new JSSourceFile[] {foo, bar}, null);
DiagnosticType targetWarning = null;
targetWarning = null;
targetWarning = VARIABLE_COUNT_MISMATCH;
test("var x = 3, y = 5;", "", null, targetWarning);
targetWarning = MOVED_VARIABLE;
test("var x = 3, y = 5;", "var x, y = 5;", null, targetWarning);
targetWarning = MISSING_VARIABLE;
test("var x = 3, y = 5;", "var z = 3, y = 5;", null, targetWarning);
if (targetWarning == null) {import java.io.FileReader;
import java.text.ParseException;
private FunctionNames functionNames_;
private VariableMap variableMap_;
private VariableMap propertyMap_;
private VariableMap anonFunctionNameMap_;
public static final DiagnosticType READ_ERROR = DiagnosticType.error(
"JSC_READ_ERROR", "Cannot read: {0}");
private static final DiagnosticType INPUT_MAP_PROP_PARSE =
DiagnosticType.error("JSC_INPUT_MAP_PROP_PARSE",
"Input property map parse error: {0}");
private static final DiagnosticType INPUT_VAR_PROP_PARSE =
DiagnosticType.error("JSC_INPUT_MAP_VAR_PARSE",
"Input variable map parse error: {0}");
nameAnonymousFunctions(options_.anonymousFunctionNaming);
if (options_.instrumentationTemplate != null ||
options_.recordFunctionInformation) {
computeFunctionNames();
private void aliasStrings(Set<String> aliasableStrings,
boolean aliasAllStrings,
String aliasStringsBlacklist,
boolean outputStringUsage) {
logger_.info("Aliasing strings");
startPass("aliasStrings");
AliasStrings aliasStrings = new AliasStrings(
this,
getModuleGraph(),
aliasAllStrings ? null : aliasableStrings,
aliasStringsBlacklist,
outputStringUsage);
process(aliasStrings);
endPass();
private void aliasKeywords() {
logger_.info("Aliasing true/false/null");
startPass("aliasKeywords");
AliasKeywords aliasKeywords = new AliasKeywords(this);
process(aliasKeywords);
endPass();
variableMap_, propertyMap_, anonFunctionNameMap_,
functionInformationMap_, sourceMap_, externExports_,
getPassConfig().getCssNames());
if (options_.flowSensitiveInlineVariables) {
flowSensitiveInlineVariables();
if (options_.collapseAnonymousFunctions) {
collapseAnonymousFunctions();
if (options_.moveFunctionDeclarations) {
moveFunctionDeclarations();
if (options_.anonymousFunctionNaming ==
AnonymousFunctionNamingPolicy.MAPPED) {
nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);
if (options_.extractPrototypeMemberDeclarations &&
(options_.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&
options_.propertyRenaming !=
PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {
extractPrototypeMemberDeclarations();
if (options_.coalesceVariableNames) {
coalesceVariableNames();
VariableMap prevPropertyMap = null;
if (options_.inputPropertyMapSerialized != null) {
try {
prevPropertyMap =
VariableMap.fromBytes(options_.inputPropertyMapSerialized);
report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));
if (options_.ambiguateProperties && (options_.propertyRenaming
== PropertyRenamingPolicy.ALL_UNQUOTED)) {
ambiguateProperties(options_.anonymousFunctionNaming
.getReservedCharacters());
switch (options_.propertyRenaming) {
case HEURISTIC:
renamePrototypes(false,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
case AGGRESSIVE_HEURISTIC:
renamePrototypes(true,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
case ALL_UNQUOTED:
renameProperties(options_.generatePseudoNames,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
if (options_.convertToDottedProperties) {
convertToDottedProperties();
if (options_.rewriteFunctionExpressions) {
rewriteFunctionExpressions();
if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {
aliasStrings(options_.aliasableStrings,
options_.aliasAllStrings,
options_.aliasStringsBlacklist,
options_.outputJsStringUsage);
if (options_.aliasExternals) {
aliasExternals();
if (options_.aliasKeywords) {
aliasKeywords();
if (options_.collapseVariableDeclarations) {
collapseVariableDeclarations();
denormalize();
if (options_.instrumentationTemplate != null) {
instrumentFunctions();
if (options_.variableRenaming != VariableRenamingPolicy.ALL) {
invertContextualRenaming();
if (options_.variableRenaming != VariableRenamingPolicy.OFF) {
VariableMap prevVariableMap = null;
if (options_.inputVariableMapSerialized != null) {
try {
prevVariableMap =
VariableMap.fromBytes(options_.inputVariableMapSerialized);
report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));
renameVars(options_.renamePrefix,
options_.variableRenaming == VariableRenamingPolicy.LOCAL,
options_.anonymousFunctionNaming,
options_.generatePseudoNames,
prevVariableMap);
if (options_.processObjectPropertyString) {
objectPropertyStringPostprocess();
if (options_.labelRenaming) {
renameLabels();
if (options_.anonymousFunctionNaming ==
AnonymousFunctionNamingPolicy.UNMAPPED) {
nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);
if (options_.checkSymbols) {
sanityCheckVars();
void sanityCheckVars() {
logger_.info("Checking for undefined vars");
startPass("sanityCheckVars");
VarCheck v = new VarCheck(this, true);
process(v);
endPass();
void computeFunctionNames() {
logger_.info("Computing fully-qualified function names and ids");
startPass("computeFunctionNames");
functionNames_ = new FunctionNames(this);
process(functionNames_);
endPass();
void flowSensitiveInlineVariables() {
logger_.info("Flow Sensitive Inline Variables");
startPass("flowSensitiveInlineVariables");
process(new FlowSensitiveInlineVariables(this));
endPass();
void coalesceVariableNames() {
logger_.info("Coalesce Variable Names");
startPass("coalesceVariableNames");
process(new CoalesceVariableNames(this));
endPass();
void collapseVariableDeclarations() {
logger_.info("Collapsing variable declarations");
startPass("collapseVariableDeclarations");
process(new CollapseVariableDeclarations(this));
setUnnormalized();
endPass();
void extractPrototypeMemberDeclarations() {
logger_.info("Extracting Common Prototype Member Declarations");
startPass("extractPrototypeMemberDeclarations");
process(new ExtractPrototypeMemberDeclarations(this));
endPass();
void rewriteFunctionExpressions() {
logger_.info("Rewrite function expressions");
startPass("rewriteFunctionExpressions");
process(new FunctionRewriter(this));
endPass();
void collapseAnonymousFunctions() {
logger_.info("Collapsing anonymous functions");
startPass("collapseAnonymousFunctions");
process(new CollapseAnonymousFunctions(this));
endPass();
void moveFunctionDeclarations() {
logger_.info("Move function declarations");
startPass("moveFunctionDeclarations");
process(new MoveFunctionDeclarations(this));
endPass();
void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {
logger_.info("Naming anonymous functions");
startPass("nameAnonymousFunctions");
if (policy == AnonymousFunctionNamingPolicy.UNMAPPED) {
process(new NameAnonymousFunctions(this));
NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(this);
process(naf);
anonFunctionNameMap_ = naf.getFunctionMap();
endPass();
void aliasExternals() {
logger_.info("Creating alias functions for externals");
startPass("aliasExternals");
AliasExternals ae = new AliasExternals(this,
getModuleGraph(),
options_.unaliasableGlobals,
options_.aliasableGlobals);
process(ae);
endPass();
void objectPropertyStringPostprocess() {
logger_.info("goog.testing.ObjectPropertyString postprocess");
startPass("ObjectPropertyStringPostprocess");
process(new ObjectPropertyStringPostprocess(this));
endPass();
void ambiguateProperties(char[] reservedCharacters) {
logger_.info("Ambiguating properties");
startPass("ambiguateProperties");
process(new AmbiguateProperties(this, reservedCharacters));
endPass();
private void denormalize() {
logger_.info("Denormalizing");
startPass("denormalize");
process(new Denormalize(this));
setUnnormalized();
endPass();
void renameVars(String renamePrefix, boolean renameLocalVarsOnly,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
boolean generatePseudoNames,
VariableMap prevVariableMap) {
logger_.info("Renaming vars");
startPass("renameVars");
boolean preserveAnonymousFunctionNames =
anonFunctionNamePolicy != AnonymousFunctionNamingPolicy.OFF;
RenameVars rn = new RenameVars(
this, renamePrefix,
renameLocalVarsOnly, preserveAnonymousFunctionNames,
generatePseudoNames,
prevVariableMap,
anonFunctionNamePolicy.getReservedCharacters(),
getPassConfig().getExportedNames());
process(rn);
variableMap_ = rn.getVariableMap();
endPass();
void renameProperties(boolean generatePseudoNames,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
VariableMap prevPropertyMap) {
logger_.info("Renaming properties");
startPass("renameProperties");
RenameProperties rp = new RenameProperties(
this, generatePseudoNames, prevPropertyMap,
anonFunctionNamePolicy.getReservedCharacters());
process(rp);
propertyMap_ = rp.getPropertyMap();
endPass();
void invertContextualRenaming() {
logger_.info("Denormalizing local names");
startPass("invertNames");
process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));
endPass();
void renamePrototypes(boolean aggressive,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
VariableMap prevPropertyMap) {
logger_.info("Renaming prototypes");
startPass("renamePrototypes");
RenamePrototypes rp = new RenamePrototypes(this, aggressive,
anonFunctionNamePolicy.getReservedCharacters(),
prevPropertyMap);
process(rp);
propertyMap_ = rp.getPropertyMap();
endPass();
void renameLabels() {
logger_.info("Renaming labels");
startPass("renameLabels");
RenameLabels rn = new RenameLabels(this);
process(rn);
endPass();
void convertToDottedProperties() {
logger_.info("Converting quoted property accesses to dot syntax");
startPass("convertToDottedProperties");
process(new ConvertToDottedProperties(this));
endPass();
void instrumentFunctions() {
logger_.info("Instrumenting functions");
startPass("instrumentFunctions");
try {
FileReader templateFile =
new FileReader(options_.instrumentationTemplate);
process(new InstrumentFunctions(this,
functionNames_,
options_.instrumentationTemplate,
options_.appNameStr,
templateFile));
report(JSError.make(READ_ERROR, options_.instrumentationTemplate));
endPass();
new RecordFunctionInformation(this, functionNames_);
return variableMap_;
return propertyMap_;
private FunctionNames functionNames;
state.functionNames = functionNames_;
functionNames_ = state.functionNames;
setExportedNames(pass.getExportedVariableNames());
Map<String, Integer> cssNames = null;
cssNames = Maps.newHashMap();
(new ReplaceCssNames(compiler, cssNames)).process(
setCssNames(cssNames);
compiler, getCrossModuleIdGenerator(),
private final DiagnosticType error;
compiler.report(JSError.make(error));
JSError.make(Compiler.READ_ERROR, sourceFile.getName()));
compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import java.util.Collections;
private Set<String> exportedNames = null;
private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =
new CrossModuleMethodMotion.IdGenerator();
private Map<String, Integer> cssNames = null;
Map<String, Integer> getCssNames() {
return cssNames == null ? null : Maps.newHashMap(cssNames);
Set<String> getExportedNames() {
return exportedNames == null ? null :
Collections.unmodifiableSet(exportedNames);
CrossModuleMethodMotion.IdGenerator getCrossModuleIdGenerator() {
return crossModuleIdGenerator;
void setCssNames(Map<String, Integer> newVal) {
cssNames = newVal == null ? null : Maps.newHashMap(newVal);
void setExportedNames(Set<String> newVal) {
exportedNames = newVal == null ? null : Sets.newHashSet(newVal);
State getIntermediateState() {
return new State(getCssNames(), getExportedNames(),
crossModuleIdGenerator);
void setIntermediateState(State state) {
setCssNames(state.cssNames);
setExportedNames(state.exportedNames);
crossModuleIdGenerator = state.crossModuleIdGenerator;
return delegate.getCssNames();
return delegate.getExportedNames();
delegate.setCssNames(newVal);
delegate.setExportedNames(newVal);
private final Map<String, Integer> cssNames;
private final Set<String> exportedNames;
private final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;
private State(Map<String, Integer> cssNames, Set<String> exportedNames,
CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator) {
Preconditions.checkState(variable != null);
assigns.add(new Assignment(variable, argTypes.get(i)));
allInstantiatedTypes.add(thisType);
ConcreteType thisType = inferConcreteType(scope, firstArgument);
ConcreteType ret;
private class MyScopeCreator implements ScopeCreator {
private final AbstractCompiler compiler;
private final TypedScopeCreator delegate;
MyScopeCreator(AbstractCompiler compiler) {
this.compiler = compiler;
this.delegate = new TypedScopeCreator(compiler);
public Scope createScope(Node root, Scope parent) {
Scope typedScope = delegate.createScope(root, parent);
TypeInference typeInference = new TypeInference(
compiler, computeCfg(root),
compiler.getReverseAbstractInterpreter(), typedScope);
typeInference.analyze();
return typedScope;
private ControlFlowGraph<Node> computeCfg(Node n) {
ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);
cfa.process(null, n);
return cfa.getCfg();
compiler, callback, new MyScopeCreator(compiler));static final String CALL_SLOT_NAME = "$call";
static final String THIS_SLOT_NAME = "$this";
static final String RETURN_SLOT_NAME = "$return";
if (ref.getParent().getType() != Token.GETELEM) {
String oldName = n.getString();
Assignment a = assignments.get(oldName);
if (a.newName != null) {
n.setString(a.newName);
changed = changed || !a.newName.equals(oldName);
String oldName = localTempNames.get(count);
Assignment a = assignments.get(oldName);
n.setString(a.newName);
changed = changed || !a.newName.equals(oldName);
return isPopulated() && currentInfo.hasFileOverview();
import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;
import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;
import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;
import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;
import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;
Multimaps.newArrayListMultimap();
Multimaps.newArrayListMultimap();
return new RenameVars(compiler, prefix, true, false, null, null, null);
false, false, previouslyUsedMap, null,new File(dirName).mkdirs();
if (aliasRefs.isWellDefined() && aliasRefs.isNeverReassigned()) {
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
if (parent.getFirstChild().getType() == Token.NAME) {
Node functionExpression = parent.getFirstChild();
decomposeSubExpressions(
functionExpression.getNext(), child, state);
if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {
state.sideEffects = true;
Node replacement = rewriteCallExpression(parent, state);
parent = replacement;
if (isSubexpressionMovable(expressionRoot, subExpression)) {
return DecompositionType.MOVABLE;
return DecompositionType.DECOMPOSABLE;
private boolean isSubexpressionMovable(
boolean callExpressionHasSideEffects = NodeUtil.mayHaveSideEffects(
subExpression);
return true;
return false;
if (parentType == Token.ASSIGN
&& parent.getFirstChild().getType() == Token.NAME) {
n, callExpressionHasSideEffects)) {
return false;
private boolean canBeSideEffected(Node n) {
return NodeUtil.has(
n, new SideEffected(this.knownConstants),
Predicates.<Node>alwaysTrue());
private static class SideEffected implements Predicate<Node> {
final Set<String> additionalConsts;
SideEffected(Set<String> additionalConsts) {
this.additionalConsts = additionalConsts;
public boolean apply(Node n) {
switch (n.getType()) {
case Token.CALL:
case Token.NEW:
case Token.NAME:
return !NodeUtil.isConstantName(n)
&& !additionalConsts.contains(n.getString());
default:
return false;
return canBeSideEffected(n);
private static boolean canBeSideEffected(Node n) {
switch (n.getType()) {
case Token.CALL:
if (!n.isNoSideEffectsCall()) {
return true;
break;
case Token.NEW:
return true;
case Token.NAME:
if (!NodeUtil.isConstantName(n)) {
return true;
break;
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (canBeSideEffected(c)) {
return true;
return false;
private final Set<Var> declaredConstants = Sets.newHashSet();
Predicates.<Var>or(
identifyConstants, Predicates.<Var>alwaysTrue()));
if (declaredConstants.contains(var)) {
return true;
if (!var.isConst()) {
return false;
if (var.getInitialValue() == null) {
return false;
if (!NodeUtil.isImmutableValue(var.getInitialValue())) {
return false;
declaredConstants.add(var);
return true;
referenceInfo.isNeverReassigned()) {
Reference declaration = referenceInfo.references.get(0);
Node value = declaration.getNameNode().getFirstChild();
if (declaration.getParent().getType() == Token.VAR &&
value != null && value.getType() == Token.NAME) {
inlineDeclaredConstant(v, referenceInfo.references);
inlineNonConstants(t.getScope(), v, referenceInfo);
private void inlineNonConstants(Scope scope,
if (referenceInfo.references.size() >= 2 &&
inlineWellDefinedVariable(v, referenceInfo.references);
Reference declaration = referenceInfo.references.get(0);
Reference reference = referenceInfo.references.get(1);
if (canInline(declaration, reference)) {
blacklistVarReferencesInTree(
declaration.getNameNode().getFirstChild(), scope);
inline(v, declaration, reference);
referenceInfo.isNeverReassigned()) {
inlineWellDefinedVariable(
candidate.alias, candidate.refInfo.references);
private void inline(Var v, Reference declaration, Reference reference) {
Node name = declaration.getNameNode();
Preconditions.checkState(name.getFirstChild() != null);
Node value = name.removeFirstChild();
inlineValue(v, reference, value);
private void inlineWellDefinedVariable(Var v,
inlineValue(v, refSet.get(i),
decl.getNameNode().getFirstChild().cloneTree());
private void inlineDeclaredConstant(Var v, List<Reference> refSet) {
inlineValue(v, r, v.getInitialValue().cloneTree());
ref.getParent().replaceChild(ref.getNameNode(), value);
List<Reference> refs) {
return var.getInitialValue().getType() != Token.STRING ||
isStringWorthInlining(var, refs);
private boolean canInline(Reference declaration, Reference reference) {
if (!isValidDeclaration(declaration) || !isValidReference(reference)) {
if (declaration.getBasicBlock() != reference.getBasicBlock()) {
if (declaration.getNameNode().getFirstChild().getType() == Token.GETPROP
&& reference.getParent().getType() == Token.CALL) {
return canMoveAggressively(declaration) ||
canMoveModerately(declaration, reference);
private boolean canMoveAggressively(Reference declaration) {
Node value = declaration.getNameNode().getFirstChild();
private boolean canMoveModerately(Reference declaration,
Iterator<Node> it = new NodeIterators.LocalVarMotion(
declaration.getNameNode(),
declaration.getParent(),
declaration.getGrandparent());
return declaration.isDeclaration() &&
declaration.getNameNode().getFirstChild() != null;
if (!isValidDeclaration(refSet.get(0))) {
for (int i = 1; i < refSet.size(); i++) {
Node value = refSet.get(0).getNameNode().getFirstChild();
LocalVarMotion(Node ... ancestors) {
Preconditions.checkArgument(ancestors.length >= 2);
Preconditions.checkArgument(ancestors[0].getType() == Token.NAME);
Preconditions.checkArgument(ancestors[1].getType() == Token.VAR);
this.iterator = new FunctionlessLocalScope(ancestors);
Node nameNode = ancestors[0];
Node valueNode = nameNode.getFirstChild();
private static final boolean ALLOW_ASSIGNMENT_SPLITTING = false;
if (ALLOW_ASSIGNMENT_SPLITTING) {
splitAssignments(n);
private void splitAssignments(Node n) {
for (Node next, c = n.getFirstChild(); c != null; c = next) {
next = c.getNext();
if (NodeUtil.isExpressionNode(c)) {
Node expression = c;
while (isCompoundAssignment(expression.getFirstChild())) {
Node assign = expression.getFirstChild();
Node rhs = assign.getLastChild();
Node nameNode = rhs.getFirstChild();
if (NodeUtil.mayEffectMutableState(nameNode)) {
break;
assign.removeChild(rhs);
assign.addChildToBack(nameNode.cloneTree());
Node newChild = NodeUtil.newExpr(rhs);
n.addChildBefore(newChild, expression);
expression = newChild;  // next iteration.
compiler.reportCodeChange();
private static boolean isCompoundAssignment(Node n) {
return (NodeUtil.isAssignmentOp(n)
&& NodeUtil.isAssignmentOp(n.getLastChild()));
Reference decl = references.get(0);
if (!decl.isInitializingDeclaration()) {
BasicBlock declBlock = decl.getBasicBlock();
if (!declBlock.provablyExecutesBefore(
boolean isNeverReassigned() {
for (int i = 1; i < size; i++) {
if (references.get(i).isLvalue()) {
return false;
return true;
return parentType == Token.VAR 
scope.declare(varName, nameNode,
public void testExposeExpression12() {
helperExposeExpression(
"if (goo.a(1, foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1.a;" +
"if (temp_const_0.call(temp_const_1, 1, foo()));");
public void testExposeExpression13() {
helperExposeExpression(
"if (goo['a'](foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1['a'];" +
"if (temp_const_0.call(temp_const_1, foo()));");
public void testExposeExpression14() {
helperExposeExpression(
"z:if (goo.a(1, foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1.a;" +
"z:if (temp_const_0.call(temp_const_1, 1, foo()));");
testSame("var AA; AA=1");
testSame("/** @const */var aa; aa=1;");
public void testDoNotExitConditional() {
testSame("var x = {};\nvar y = x.a;\nx.a = 1;\nvar z = y;");
Iterator<Node> moveIt = new LocalVarMotion(
currentAncestors.toArray(new Node[currentAncestors.size()]));
public void disable_testSplitAssign() {
testSame("a = 0");
test("a = b = 0",
"b = 0; a = b");
test("a = b = c = foo()",
"c = foo(); b = c; a = b");
test("a.a = a.b = 0",
"a.b = 0; a.a = a.b");
test("a[0] = a[1] = 0",
"a[1] = 0; a[0] = a[1]");
testSame("a[x++] = a[x++] = 0");
testSame("a[getNext()] = a[getNext()] = 0");
testSame("for(;a=b=0;c=d=0);");
test("a *= b -= c += foo()",
"c += foo(); b -= c; a *= b");
checkSynthesizedExtern("function(x){}", "");
checkSynthesizedExtern("function(){x}", "var x");
checkSynthesizedExtern("function(){function() {x}}", "var x");public boolean allowsUndeclaredVariables() {
return true;
NodeUtil.isRValue(name);
public boolean allowsUndeclaredVariables();
options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,
CheckLevel.OFF);
options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,
CheckLevel.OFF);
VarCheck v = new VarCheck(this, false);
this, renamePrefix, renameLocalVarsOnly, prevVariableMap,
public boolean allowBrokenClosureRequires;
allowBrokenClosureRequires = false;
public boolean allowsUndeclaredVariables() {
return true;
if (options.checkSymbols) {
checks.add(checkVars);
final ProcessClosurePrimitives pass =
options.brokenClosureRequiresLevel != null ?
new ProcessClosurePrimitives(
compiler,
options.brokenClosureRequiresLevel,
options.rewriteNewDateGoogNow) :
new ProcessClosurePrimitives(
compiler,
options.allowBrokenClosureRequires,
options.rewriteNewDateGoogNow);
Node name1 = thenAssign.getFirstChild();
if (name2.hasChildren() && name1.getString().equals(name2.getString())) {
&& NodeUtil.isRValue(callNode)
public boolean allowsUndeclaredVariables() {
return false;
return NodeUtil.isLiteralValue(
declaration.getNameNode().getFirstChild());
traverseBranch(fnName, n);
static boolean isLValue(Node n) {
return getRValue(n) != null;
static Node getRValue(Node n) {
Node current = n;
Node ancestor;
while ((ancestor = current.getParent()) != null) {
switch (ancestor.getType()) {
case Token.EXPR_RESULT:
case Token.GETPROP:
break;
case Token.ASSIGN:
if (ancestor.getFirstChild() == current) {
return ancestor.getLastChild();
break;
case Token.SCRIPT:
case Token.FUNCTION:
case Token.LP:
case Token.BLOCK:
return null;
case Token.VAR:
if (n.hasChildren()) {
return n.getFirstChild();
return null;
default:
return null;
current = ancestor;
return null;
static boolean isRValue(Node n) {
Node current = n;
Node parent;
while ((parent = current.getParent()) != null) {
switch (parent.getType()) {
case Token.EXPR_RESULT:
case Token.GETPROP:
break;
case Token.ASSIGN:
if (parent.getFirstChild() != current) {
return true;
break;
case Token.SCRIPT:
case Token.FUNCTION:
case Token.LP:
case Token.BLOCK:
case Token.VAR:
return false;
default:
return true;
current = parent;
return false;
ProcessClosurePrimitives(AbstractCompiler compiler,
boolean allowBrokenRequires,
boolean rewriteNewDateGoogNow) {
this(compiler,
allowBrokenRequires ? CheckLevel.WARNING : CheckLevel.ERROR,
rewriteNewDateGoogNow);
if (n.getType() == Token.FUNCTION) {
String fnName = n.getFirstChild().getString();
Scope s = t.getScope();
if (!fnName.isEmpty() && s.getVar(fnName).scope == s) {
addReference(t, s.getVar(fnName),
Reference.newBleedingFunction(t, parent, n));
RenameVars(AbstractCompiler compiler, String prefix,
boolean localRenamingOnly, VariableMap prevUsedRenameMap,
private final String[] checkWarningsOnlyForPath;
Preconditions.checkArgument(checkWarningsOnlyForPath != null);
this.checkWarningsOnlyForPath = new String[] { checkWarningsOnlyForPath };
Preconditions.checkArgument(checkWarningsOnlyForPath != null);
this.checkWarningsOnlyForPath = checkWarningsOnlyForPath;
final String filePath = error.sourceName;
if (error.level != CheckLevel.ERROR && filePath != null) {
boolean checkMe = false;
for (String checkedPath : checkWarningsOnlyForPath) {
checkMe |= filePath.contains(checkedPath);
if (!checkMe) {
JSType delegateType = typeRegistry.getType(
codingConvention.getDelegateSuperclassName());
private final boolean nonStrictModuleChecks;
this(compiler, true);
VarCheck(AbstractCompiler compiler, boolean nonStrictModuleChecks) {
this.nonStrictModuleChecks = nonStrictModuleChecks;
Node nameNode = Node.newString(Token.NAME, varName);
getSynthesizedExternsRoot().addChildToBack(
new Node(Token.VAR, nameNode));
scope.declare(varName, nameNode,
null, getSynthesizedExternsInput());
if (nonStrictModuleChecks && scope.isGlobal()) {
return new ProcessClosurePrimitives(compiler, false, true);
return new RenameVars(compiler, prefix, true, null, null, null);
localRenamingOnly, previouslyUsedMap, null, null);
new ProcessClosurePrimitives(compiler, true, true);
false, previouslyUsedMap, null,
checkSourceMap("function(foo, bar) { foo = foo + bar + 2; return foo; }",
"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9," +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,8,\"\"]\n" +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,9,\"foo\"]\n" +
"[\"testcode\",1,14,\"bar\"]\n" +
"[\"testcode\",1,19]\n" +
"[\"testcode\",1,21,\"foo\"]\n" +
"[\"testcode\",1,27,\"foo\"]\n" +
"[\"testcode\",1,33,\"bar\"]\n" +
"[\"testcode\",1,39]\n" +
"[\"testcode\",1,42]\n" +
"[\"testcode\",1,49,\"foo\"]\n");
checkSourceMap("function(foo, bar) {\r\n\n\n\nfoo = foo + bar + foo;" +
"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9," +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,8,\"\"]\n" +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,9,\"foo\"]\n" +
"[\"testcode\",1,14,\"bar\"]\n" +
"[\"testcode\",1,19]\n" +
private boolean nonStrictModuleChecks = true;
nonStrictModuleChecks = true;
return new VarCheck(compiler, nonStrictModuleChecks);
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
(new VarCheck(compiler)).process(externs, root);
(new VariableTestCheck(compiler)).process(externs, root);