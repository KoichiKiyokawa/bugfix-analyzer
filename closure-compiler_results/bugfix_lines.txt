final List<MemberDefinition> methods, Node block, String basePath) {
appendMethodsToBlock(cls.methods, block, interfaceBasePath);
appendMethodsToBlock(behavior.functionsToCopy, block, interfaceBasePath);
private final PolymerExportPolicy polymerExportPolicy = PolymerExportPolicy.LEGACY;
behaviorName, PolymerClassDefinition.DefinitionType.ObjectLiteral, compiler),
behaviorValue, PolymerClassDefinition.DefinitionType.ObjectLiteral, compiler),
descriptor, DefinitionType.ObjectLiteral, compiler));
propertiesDescriptor, DefinitionType.ES6Class, compiler);
import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_MISPLACED_PROPERTY_JSDOC;
import java.util.HashSet;
import java.util.Set;
Set<String> constructorPropertyNames = new HashSet<>();
collectConstructorPropertyNames(cls.constructor.value, constructorPropertyNames);
List<PolymerPass.MemberDefinition> propertiesToAddToPrototype = new ArrayList<>();
for (MemberDefinition polymerProp : cls.props) {
if (!constructorPropertyNames.contains(polymerProp.name.getString())) {
propertiesToAddToPrototype.add(polymerProp);
compiler.report(JSError.make(polymerProp.name, POLYMER_MISPLACED_PROPERTY_JSDOC));
appendPropertiesToBlock(
propertiesToAddToPrototype, block, cls.target.getQualifiedName() + ".prototype.");
PolymerPassStaticUtils.extractProperties(objLit, defType, compiler)) {
PolymerPassStaticUtils.extractProperties(objLit, defType, compiler)) {
private static void collectConstructorPropertyNames(Node node, Set<String> names) {
if (node == null) {
return;
for (Node child : node.children()) {
if (child.isGetProp()
&& child.getFirstChild().isThis()
&& child.getSecondChild().isString()) {
names.add(child.getSecondChild().getString());
collectConstructorPropertyNames(child, names);
Node descriptor, PolymerClassDefinition.DefinitionType defType, AbstractCompiler compiler) {
members.add(new MemberDefinition(NodeUtil.getBestJSDocInfo(keyNode), keyNode,
keyNode.getFirstChild()));
behaviorValue, PolymerClassDefinition.DefinitionType.ObjectLiteral, compiler);
behaviorValue, PolymerClassDefinition.DefinitionType.ObjectLiteral, compiler)) {
String source = compiler.getCurrentJsSource();
assertThat(source).doesNotContain("FooElement.prototype.p1");
assertThat(source).doesNotContain("FooElement.prototype.p2");
assertThat(source).doesNotContain("FooElement.prototype.p3");
assertThat(source).contains("FooElement.prototype.p4");
assertThat(source).contains("FooElement.prototype.p5");
(target.hasStringKey() && !target.hasDefaultValue())
? target.getInferredTypeSupplier()
: () -> null;
Node initialValue = newVar.getInitialValue();
boolean isValidValue =
initialValue != null
&& (initialValue.isObjectLit() || initialValue.isQualifiedName());
if (!isValidValue) {
report(JSError.make(declarationNode, ENUM_INITIALIZER));
assertFalse(aVar.isTypeInferred());
if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
type = Name.Type.GET;
break;
type = Name.Type.SET;
nameObj.type = type;
CLASS,
OBJECTLIT,
FUNCTION,
GET,
SET,
OTHER,
return this.type == Type.GET || this.type == Type.SET;
oldParamsListHitOptArgs = oldParamsListHitOptArgs ||
oldParam.isVarArgs() ||
oldParam.isOptionalArg();
warnedAboutArgList |= addParameter(
paramBuilder,
typeRegistry.getNativeType(UNKNOWN_TYPE),
warnedAboutArgList,
codingConvention.isOptionalParameter(currentParam) ||
oldParamsListHitOptArgs,
codingConvention.isVarArgsParameter(currentParam));
isVarArgs = isVarArgsParameter(param, info);
isOptionalParam = isOptionalParameter(param, info);
parameterType = info.getParameterType(paramName).evaluate(templateScope, typeRegistry);
private boolean isOptionalParameter(Node param, @Nullable JSDocInfo info) {
if (codingConvention.isOptionalParameter(param)) {
return true;
String paramName = param.getString();
return info != null && info.hasParameterType(paramName) &&
info.getParameterType(paramName).isOptionalArg();
private boolean isVarArgsParameter(
Node param, @Nullable JSDocInfo info) {
if (codingConvention.isVarArgsParameter(param)) {
return true;
String paramName = param.getString();
return info != null && info.hasParameterType(paramName) &&
info.getParameterType(paramName).isVarArgs();
assign.useSourceInfoIfMissingFromForTree(method);
context = context.cloneTree();
return IR.getelem(context, member.removeFirstChild());
new UnionTypeBuilder(registry)
UnionTypeBuilder unionTypeBuilder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);
private static final int PROPERTY_CHECKING_UNION_SIZE = 3000;
propertyName, k -> new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE));
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(this);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
builder.addAlternate(alternate, true);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
builder.addAlternate(alternate);
alternatesWithoutStucturalTyping = builder.getAlternates();
builder = new UnionTypeBuilder(registry);
for (JSType alternate : alternatesWithoutStucturalTyping) {
builder.addAlternate(alternate, true);
alternates = builder.getAlternates();
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder restricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
public class UnionTypeBuilder implements Serializable {
private final int maxUnionSize;
public UnionTypeBuilder(JSTypeRegistry registry) {
this(registry, DEFAULT_MAX_UNION_SIZE);
UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {
private boolean isSubtype(
JSType rightType, JSType leftType, boolean isStructural) {
if (isStructural && !thisUnresolved && !thatUnresolved) {
public UnionTypeBuilder addAlternate(JSType alternate, boolean isStructural) {
if (alternate.isEquivalentTo(current, isStructural)) {
if (isSubtype(alternate, current, isStructural)) {
if (isSubtype(current, alternate, isStructural)) {
public UnionTypeBuilder addAlternate(JSType alternate) {
return addAlternate(alternate, false);
JSType type = null;
type = typeRegistry.createObjectType("type: " + i, null);
assertFalse(typeRegistry.getGreatestSubtypeWithProperty(type, "foo").isUnknownType());
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
n.replaceWith(IR.name(data.getGlobalName(name)).useSourceInfoFromForTree(n));
t.reportCodeChange();
SourceFile srcEs6 =
SourceFile.fromCode("es6.js", "export var x; goog.module.declareNamespace('my.es6');");
SourceFile expectedEs6 =
SourceFile.fromCode(
"es6.js",
lines(
"var x$$module$es6;/** @const */ var module$es6={};",
"/** @const */ module$es6.x=x$$module$es6;"));
srcEs6,
expectedEs6,
rewriteRequires(script);
checkState(parent.isName());
namesToInlineByAlias.put(parent.getString(), m.getGlobalName(namespace));
Node replacement =
NodeUtil.newQName(compiler, m.getGlobalName(namespace)).srcrefTree(requireCall);
parent.replaceChild(requireCall, replacement);
"const y$$module$testcode = closure.provide;",
"const {a:a$$module$testcode, b:c$$module$testcode} = closure.provide;",
"const y$$module$testcode = module$exports$closure$module;",
"const {a:a$$module$testcode, b:c$$module$testcode} = module$exports$closure$module;",
"const y$$module$testcode=closure.legacy.module;",
"const {a:a$$module$testcode,b:c$$module$testcode} = closure.legacy.module;",
"const {a} = goog.require('closure.provide');",
"export {a};"),
lines(
"const {a:a$$module$testcode} = closure.provide",
"/** @const */ module$testcode.a = a$$module$testcode;"));
Node getprop, @Nullable ObjectType referenceType, String propertyName) {
return getprop.getStaticSourceFile();
private static Visibility getOverriddenPropertyVisibility(
ObjectType objectType, String propertyName) {
private static Visibility getEffectiveVisibilityForOverriddenProperty(
case GETPROP:
checkPropertyDeprecation(t, n, parent);
checkPropertyVisibility(t, n, parent);
checkConstantProperty(t, n);
break;
checkConstructorDeprecation(t, n, parent);
private void checkConstructorDeprecation(NodeTraversal t, Node n,
Node parent) {
if (deprecationInfo != null && shouldEmitDeprecationWarning(t, n, parent)) {
if (docInfo != null && docInfo.isDeprecated() && shouldEmitDeprecationWarning(t, n, parent)) {
private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {
if (parent.isNew()) {
ObjectType objectType = castToObject(dereference(n.getFirstChild().getJSType()));
String propertyName = n.getLastChild().getString();
if (deprecationInfo != null && shouldEmitDeprecationWarning(t, n, parent)) {
t.makeError(n, DEPRECATED_PROP_REASON, propertyName,
typeRegistry.getReadableTypeName(n.getFirstChild()),
t.makeError(n, DEPRECATED_PROP, propertyName,
typeRegistry.getReadableTypeName(n.getFirstChild())));
Node getprop) {
String propertyName = getprop.getLastChild().getString();
t.makeError(getprop,
propertyName,
private void checkConstantProperty(NodeTraversal t, Node getprop) {
Node parent = getprop.getParent();
boolean isDelete = parent.isDelProp();
if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)
&& !parent.isInc() && !parent.isDec()
&& !isDelete) {
ObjectType objectType = castToObject(dereference(getprop.getFirstChild().getJSType()));
String propertyName = getprop.getLastChild().getString();
JSDocInfo info = parent.getJSDocInfo();
if (isDelete) {
compiler.report(t.makeError(getprop, CONST_PROPERTY_DELETED, propertyName));
compiler.report(t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE, propertyName));
if (type == null) {
return typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE);
return type;
private void checkPropertyVisibility(NodeTraversal t,
Node getprop, Node parent) {
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(getprop);
JSType rawReferenceType = typeOrUnknown(getprop.getFirstChild().getJSType()).autobox();
String propertyName = getprop.getLastChild().getString();
if (isPrivateByConvention
&& propertyIsDeclaredButNotPrivate(getprop, parent)) {
compiler.report(t.makeError(getprop, CONVENTION_MISMATCH));
StaticSourceFile definingSource = AccessControlUtils.getDefiningSource(
getprop, referenceType, propertyName);
boolean isOverride =
jsdoc != null
&& (parent.isExprResult() || (parent.isAssign() && parent.getFirstChild() == getprop));
Visibility visibility = AccessControlUtils.getEffectivePropertyVisibility(
getprop,
referenceType,
defaultVisibilityForFiles,
enforceCodingConventions ? compiler.getCodingConvention() : null);
Visibility overriding = getOverridingPropertyVisibility(parent);
overriding, visibility, fileOverviewVisibility, t, getprop);
StaticSourceFile referenceSource = getprop.getStaticSourceFile();
t,
getprop,
parent,
visibility,
fileOverviewVisibility,
reportType,
sameInput);
t,
getprop,
parent,
visibility,
isClassType,
reportType,
referenceSource,
definingSource);
private static boolean propertyIsDeclaredButNotPrivate(Node getprop, Node parent) {
JSDocInfo info = NodeUtil.getBestJSDocInfo(getprop);
if ((parent.isAssign() || parent.isExprResult())
&& parent.getFirstChild() == getprop
&& info != null) {
Visibility declaredVisibility = info.getVisibility();
if (declaredVisibility != Visibility.PRIVATE
&& declaredVisibility != Visibility.INHERITED) {
return true;
return false;
Node getprop,
Node parent,
JSDocInfo overridingInfo = parent.getJSDocInfo();
Visibility overridingVisibility = overridingInfo == null
? Visibility.INHERITED
: overridingInfo.getVisibility();
t.makeError(getprop, PRIVATE_OVERRIDE,
objectType.toString()));
t.makeError(getprop, VISIBILITY_MISMATCH,
visibility.name(), objectType.toString(),
Node getprop,
Node parent,
checkPackagePropertyVisibility(t, getprop, referenceSource, definingSource);
checkPrivatePropertyVisibility(t, getprop, parent, isClassType, ownerType);
checkProtectedPropertyVisibility(t, getprop, ownerType);
Node getprop,
String propertyName = getprop.getLastChild().getString();
t.makeError(getprop, BAD_PACKAGE_PROPERTY_ACCESS,
propertyName,
typeRegistry.getReadableTypeName(getprop.getFirstChild())));
NodeTraversal t,
Node getprop,
Node parent,
boolean isClassType,
JSType ownerType) {
if (isClassType && isValidPrivateConstructorAccess(parent)) {
JSType accessedType = getprop.getFirstChild().getJSType();
String propertyName = getprop.getLastChild().getString();
String readableTypeName = ownerType.equals(accessedType)
? typeRegistry.getReadableTypeName(getprop.getFirstChild())
: ownerType.toString();
t.makeError(getprop,
propertyName,
NodeTraversal t,
Node getprop,
JSType ownerType) {
String propertyName = getprop.getLastChild().getString();
t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
propertyName,
typeRegistry.getReadableTypeName(getprop.getFirstChild())));
private boolean shouldEmitDeprecationWarning(
NodeTraversal t, Node n, Node parent) {
if (!((parent.isCall() && parent.getFirstChild() == n) || n.isNew())) {
if (n.isGetProp() && n == parent.getFirstChild() && NodeUtil.isAssignmentOp(parent)) {
if (n.isGetProp() && parent.isExprResult() && n.getJSDocInfo().isDeprecated()) {
private static ObjectType dereference(JSType type) {
return type == null ? null : type.dereference();
public void testPackagePrivateAccessForNames() {
test(
srcs(
SourceFile.fromCode(
Compiler.joinPathParts("foo", "bar.js"),
lines(
"class Parent {",
"  constructor() {",
"    /** @package */",
"    this.prop = 'foo';",
"  }",
"}")),
SourceFile.fromCode(
Compiler.joinPathParts("baz", "quux.js"),
lines(
"class Child extends Parent {",
"  constructor() {",
"    this.prop = 'asdf';",
"  }",
"}",
"",
"Child.prototype = new Parent();"))),
error(BAD_PACKAGE_PROPERTY_ACCESS));
"/** @constructor @extends {A} */",
"/** @constructor @extends {A} */",
"/** @constructor */\n"
+ "function Parent() {\n"
+ "/** @package */\n"
+ "this.prop = 'foo';\n"
+ "}\n;"),
Compiler.joinPathParts("baz", "quux.js"),
"/**"
+ " * @constructor\n"
+ " * @extends {Parent}\n"
+ " */\n"
+ "function Child() {\n"
+ "  this.prop = 'asdf';\n"
+ "}\n"
+ "Child.prototype = new Parent();")),
testSame("var o = { /** @const */ x: 1 };"
+ "o.x = 2;");
testSame("/** @const */ var o = { /** @const */ x: 1 };"
+ "o.x = 2;");
testSame("var o = { XYZ: 1 };"
+ "o.XYZ = 2;");
testSame("/** @const */ var o = { XYZ: 1 };"
+ "o.XYZ = 2;");
if (var.isTypeInferred() && var.getType() == unknownType) {
FunctionType functionType =
JSType.toMaybeFunctionType(functionNode.getJSType());
public void isEqualTo(Node node) {
if (!declaredOverride && interfaceHasProperty && !"__proto__".equals(propertyName)) {
import com.google.javascript.rhino.jstype.EnumType;
class InferJSDocInfo extends AbstractPostOrderCallback
implements HotSwapCompilerPass {
attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());
if (objType.isConstructor() ||
objType.isEnumType() ||
objType.isInterface()) {
if (objType.hasReferenceName() &&
objType.getReferenceName().equals(qName)) {
objType.setJSDocInfo(docInfo);
if (objType.isConstructor() || objType.isInterface()) {
JSType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(docInfo);
((EnumType) objType).getElementsType().setJSDocInfo(docInfo);
import static com.google.common.truth.Truth.assertWithMessage;
import com.google.javascript.rhino.JSDocInfo;
private static final String OBJECT_EXTERNS = ""
+ "/**\n"
+ " * Object.\n"
+ " * @param {*=} x\n"
+ " * @return {!Object}\n"
+ " * @constructor\n"
+ " */\n"
+ "function Object(x) {};";
(new TypeInferencePass(
compiler, compiler.getReverseAbstractInterpreter(),
topScope, scopeCreator)).process(externs, root);
NodeTraversal t = new NodeTraversal(
compiler, callback, scopeCreator);
(new InferJSDocInfo(compiler)).process(externs, root);
public void testNativeCtor() {
externs(OBJECT_EXTERNS),
srcs("var x = new Object();" + "/** Another object. */ var y = new Object();"));
assertEquals(
"Object.",
findGlobalNameType("x").getJSDocInfo().getBlockDescription());
assertEquals(
"Object.",
findGlobalNameType("y").getJSDocInfo().getBlockDescription());
assertEquals(
"Object.",
globalScope.getVar("y").getType().getJSDocInfo().getBlockDescription());
public void testStructuralFunctions() {
externs(OBJECT_EXTERNS),
"/** Function. \n * @param {*} x */ "
+ "function fn(x) {};"
+ "var goog = {};"
+ "/** Another object. \n * @type {Object} */ goog.x = new Object();"
+ "/** Another function. \n * @param {number} x */ goog.y = fn;"));
assertEquals(
"(Object|null)",
globalScope.getVar("goog.x").getType().toString());
assertEquals(
"Object.",
globalScope.getVar("goog.x").getType().restrictByNotNullOrUndefined()
.getJSDocInfo().getBlockDescription());
assertEquals(
"Another function.",
globalScope.getVar("goog.y").getType()
.getJSDocInfo().getBlockDescription());
public void testInstanceObject() {
"/** @constructor */ function Foo() {}" +
"var f = new Foo();" +
"/** @type {number} */ f.bar = 4;");
ObjectType type = (ObjectType) globalScope.getVar("f").getType();
assertEquals("Foo", type.toString());
assertFalse(type.hasProperty("bar"));
assertNull(type.getOwnPropertyJSDocInfo("bar"));
public void testInterface() {
testInterface("var");
testInterface("let");
testInterface("const");
private void testInterface(String varOrLetOrConst) {
"/**", // preserve newlines
" * An interface.",
" * @interface",
" */",
varOrLetOrConst + " Foo = function Foo() {}",
""));
assertThat(getGlobalVarTypeJSDocInfoBlockDescription("Foo")).isEqualTo("An interface.");
private String getGlobalVarTypeJSDocInfoBlockDescription(String varName) {
TypedVar var = globalScope.getVar(varName);
assertWithMessage("%s is not defined", varName).that(var).isNotNull();
ObjectType type = (ObjectType) var.getType();
assertWithMessage("%s has no type", varName).that(type).isNotNull();
JSDocInfo jsDocInfo = type.getJSDocInfo();
assertWithMessage("%s type has no JSDocInfo", varName).that(jsDocInfo).isNotNull();
return jsDocInfo.getBlockDescription();
public void testNamespacedCtor() {
"var goog = {};" +
"/** Hello! \n * @constructor */ goog.Foo = function() {};" +
"goog.Foo.bar = goog.Foo;" +
"/** Bye! \n * @param {string=} opt_x */" +
"goog.Foo.prototype.baz = goog.Foo;" +
"/** Blargh */ var x = new goog.Foo();");
assertEquals(
"Hello!",
findGlobalNameType("x").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType("goog.Foo").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType(
"goog.Foo.bar").getJSDocInfo().getBlockDescription());
assertEquals(
"Hello!",
findGlobalNameType(
"goog.Foo.prototype.baz").getJSDocInfo().getBlockDescription());
ObjectType proto = (ObjectType) findGlobalNameType("goog.Foo.prototype");
assertEquals(
"Bye!",
proto.getPropertyType("baz").getJSDocInfo().getBlockDescription());
public void testAbstractMethod() {
"/** Abstract method. \n * @type {!Function} */ var abstractMethod;" +
"/** @constructor */ function Foo() {}" +
"/** Block description. \n * @param {number} x */" +
"Foo.prototype.bar = abstractMethod;");
FunctionType abstractMethod =
(FunctionType) findGlobalNameType("abstractMethod");
assertNull(abstractMethod.getJSDocInfo());
FunctionType ctor = (FunctionType) findGlobalNameType("Foo");
ObjectType proto = ctor.getInstanceType().getImplicitPrototype();
FunctionType method = (FunctionType) proto.getPropertyType("bar");
assertEquals(
"Block description.",
method.getJSDocInfo().getBlockDescription());
assertEquals(
"Block description.",
proto.getOwnPropertyJSDocInfo("bar").getBlockDescription());
public void testPrototypeObjectLiteral() {
"/** @constructor */ function Foo() {}",
FunctionType ctor = findGlobalNameType("Foo").toMaybeFunctionType();
private JSType findGlobalNameType(String name) {
return findNameType(name, globalScope);
private JSType findNameType(String name, TypedScope scope) {
if (isCandidatePropertyDefinition(n) && isNonConstCheckablePrivatePropDecl(n)) {
private boolean isNonConstCheckablePrivatePropDecl(Node n) {
private boolean isCandidatePropertyDefinition(Node n) {
Node target = n.getFirstChild();
return target.isThis() || isConstructor(target);
ALL,   // Instrument to collect both line coverage and branch coverage.
String jscovData;
if (instrumentOption == InstrumentOption.BRANCH_ONLY) {
jscovData = "{'fileNames':[], 'branchPresent':[], 'branchesInLine': [], 'branchesTaken': []}";
jscovData = "{'fileNames':[], 'instrumentedLines': [], 'executedLines': []}";
jscovData =
"{'fileNames:[], 'instrumentedLines: [], 'executedLines': [],"
+ " 'branchPresent':[], 'branchesInLine': [], 'branchesTaken': []}";
String jscovDecl =
" var " + name + " = window.top['__jscov'] || (window.top['__jscov'] = " + jscovData + ");";
Node script = compiler.parseSyntheticCode(jscovDecl);
Node var = script.removeFirstChild();
return getClosestContainerScope() == other.getClosestContainerScope();
public static List<Node> findLhsNodesInNode(Node declNode) {
isNameDeclaration(declNode)
|| declNode.isParamList()
|| isAssignmentOp(declNode)
|| declNode.isCatch()
|| declNode.isDestructuringLhs()
|| declNode.isDefaultValue()
|| declNode.isImport(),
declNode);
getLhsNodesHelper(declNode, lhsNodes);
Node enclosingFunction = traversal.getEnclosingFunction();
if (enclosingFunction == null) {
if (NodeUtil.isAssignmentOp(node) || node.isInc() || node.isDelProp() || node.isDec()) {
visitAssignmentOrUnaryOperator(
sideEffectInfo, traversal.getScope(), node, enclosingFunction);
if (!t.getScope().isFunctionBlockScope() && !t.getScope().isFunctionScope()) {
return;
Node function = NodeUtil.getEnclosingFunction(t.getScopeRoot());
if (function == null) {
private boolean isVarDeclaredInScope(@Nullable Var v, Scope scope) {
if (v == null) {
return false;
if (v.scope == scope) {
return true;
Node declarationRoot = NodeUtil.getEnclosingFunction(v.scope.getRootNode());
Node scopeRoot = NodeUtil.getEnclosingFunction(scope.getRootNode());
return declarationRoot == scopeRoot;
private void visitAssignmentOrUnaryOperator(
FunctionInformation sideEffectInfo, Scope scope, Node op, Node enclosingFunction) {
Iterable<Node> lhsNodes;
if (isIncDec(op) || op.isDelProp()) {
lhsNodes = ImmutableList.of(op.getOnlyChild());
lhsNodes = NodeUtil.findLhsNodesInNode(op);
if (isVarDeclaredInScope(var, scope)) {
if (isVarDeclaredInScope(var, scope)) {
checkState(NodeUtil.isAssignmentOp(op) || isIncDec(op) || op.isDelProp());
Node rhs = NodeUtil.getRValueOfLValue(lhs);
if (rhs != null && op.isAssign() && !NodeUtil.evaluatesToLocalValue(rhs)) {
private static boolean isIncDec(Node n) {
Token type = n.getToken();
return (type == Token.INC || type == Token.DEC);
return ownerName + "." + getObjectLitKeyName(lValue);
"var x = new ns.Foo.Bar;"));
defineSlot(keyNode, objLit, qualifiedName, keyType, inferred);
defineSlot(catchName, n, getDeclaredType(catchName.getJSDocInfo(), catchName, null));
defineName(name, n, name.getJSDocInfo());
defineName(name, n, (info != null) ? info : name.getJSDocInfo());
defineSlot(n.getFirstChild(), n, functionType);
private void defineName(Node name, Node var, JSDocInfo info) {
defineSlot(name, var, type);
private void defineSlot(Node name, Node parent, JSType type) {
defineSlot(name, parent, type, type == null);
void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
defineSlot(n, parent, n.getQualifiedName(), type, inferred);
void defineSlot(Node n, Node parent, String variableName,
JSType type, boolean inferred) {
defineSlot(n, parent, valueType, inferred);
Node parent = n.getParent();
defineSlot(n, parent, stubType, true);
defineSlot(candidate, candidate.getParent(), getNativeType(NO_TYPE), false);
defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);
defineSlot(astParameter, functionNode, paramType, inferred);
actualType,
"found   : string",
"required: number"));
"found   : string",
"required: number"));
passes.add(rewriteBlockScopedDeclaration);
import java.util.Collection;
public Collection<Set<E>> allEquivalenceClasses() {
Map<Node<E>, ImmutableSet.Builder<E>> groupsTmp = new LinkedHashMap<>();
Node<E> root = findRoot(elem);
ImmutableSet.Builder<E> builder =
groupsTmp.computeIfAbsent(root, (Node<E> k) -> ImmutableSet.builder());
builder.add(elem.element);
ImmutableList.Builder<Set<E>> result = ImmutableList.builder();
for (ImmutableSet.Builder<E> group : groupsTmp.values()) {
result.add(group.build());
import java.util.Collection;
public Collection<Set<E>> allEquivalenceClasses();
import junit.framework.TestCase;
import java.util.Collection;
Collection<Set<String>> classes = union.allEquivalenceClasses();
if (var == null) {
return false;
Node n = var.getScopeRoot();
return n.isFunction()
&& NodeUtil.isBleedingFunctionName(n.getFirstChild())
&& name.equals(n.getFirstChild().getString());
if (propertyMap.containsKey(propName)) {
return propertyMap.get(propName);
Property property = new Property(propName);
propertyMap.put(propName, property);
for (Node n : parent.children()) {
private class RewriteScopeCallback extends AbstractPostOrderCallback {
if (n.isName() && !NodeUtil.isLhsByDestructuring(n)) {
visitDestructuringPattern(t, n, parent);
private void visitDestructuringPattern(NodeTraversal t, Node n, Node parent) {
if (!(parent.isAssign() || parent.isParamList() || parent.isDestructuringLhs())) {
return;
List<Node> lhsNodes = NodeUtil.findLhsNodesInNode(n.getParent());
boolean hasCrossModuleName = false;
for (Node lhs : lhsNodes) {
if (!lhs.isName()) {
continue;
visitName(t, lhs, lhs.getParent());
hasCrossModuleName = hasCrossModuleName || isCrossModuleName(lhs.getString());
if (!parent.isDestructuringLhs()) {
return;
Node nameDeclaration = parent.getParent();
if (hasCrossModuleName
&& (t.inGlobalScope() || (nameDeclaration.isVar() && t.inGlobalHoistScope()))) {
Node value = n.getNext();
if (value != null) {
parent.removeChild(n);
parent.removeChild(value);
Node assign = IR.assign(n, value).srcref(n);
nameDeclaration.replaceChild(parent, assign);
parent.removeChild(n);
nameDeclaration.replaceChild(parent, n);
compiler.reportChangeToEnclosingScope(nameDeclaration);
CompilerInput input = t.getInput();
for (Node lhs : lhsNodes) {
if (!lhs.isName()) {
continue;
String name = lhs.getString();
if (!isCrossModuleName(name)) {
preDeclarations.add(
new ModuleGlobal(input.getAstRoot(compiler), IR.name(name).srcref(lhs)));
if (!var.isGlobal()) {
replaceSymbol(t, n, name, t.getInput());
private void replaceSymbol(NodeTraversal t, Node node, String name, CompilerInput input) {
boolean isCrossModule = isCrossModuleName(name);
if (!isCrossModule) {
if (!NodeUtil.isNameDeclaration(parent)) {
return;
boolean hasInterestingChildren = false;
for (Node c : parent.children()) {
if (!c.isName() || isCrossModuleName(c.getString()) || isExternVar(c.getString(), t)) {
hasInterestingChildren = true;
break;
if (!hasInterestingChildren) {
return;
Node replacement = isCrossModule
? IR.getprop(
IR.name(globalSymbolNamespace).srcref(node),
IR.string(name).srcref(node))
: IR.name(name).srcref(node);
replacement.srcref(node);
if (node.hasChildren()) {
Node assign = IR.assign(
replacement,
node.removeFirstChild());
parent.replaceChild(node, assign);
compiler.reportChangeToEnclosingScope(assign);
parent.replaceChild(node, replacement);
compiler.reportChangeToEnclosingScope(replacement);
if (parent.isCall() && !maybeReferencesThis.contains(name)) {
parent.putBooleanProp(Node.FREE_CALL, false);
if (!isCrossModule && NodeUtil.isNameDeclaration(parent)) {
preDeclarations.add(new ModuleGlobal(
input.getAstRoot(compiler),
IR.name(name).srcref(node)));
if (NodeUtil.isNameDeclaration(parent) && nameNode.hasOneChild()) {
Node assign = IR.assign(windowPropAccess, nameNode.removeFirstChild());
assign.setJSDocInfo(parent.getJSDocInfo());
parent.replaceChild(nameNode, assign.srcrefTree(parent));
parent.replaceChild(nameNode, windowPropAccess.srcrefTree(nameNode));
public void testConstPolymerNotAllowed() {
options.setLanguageIn(LanguageMode.ECMASCRIPT_2015);
externs = ImmutableList.of(SourceFile.fromCode("<externs>",
"var Polymer = function() {}; var PolymerElement = function() {};"));
builder.recordType(new JSTypeExpression(type, ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("?"), ""));
JSTypeExpression expr = new JSTypeExpression(getCallArgument(ttlAst, 0), "");
assertTypeEquals(expected, new JSTypeExpression(actual, ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("number"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("string"), ""));
new JSTypeExpression(new Node(Token.EQUALS, IR.string("number")), ""));
new JSTypeExpression(new Node(Token.ELLIPSIS, IR.string("number")), ""));
new JSTypeExpression(new Node(Token.ELLIPSIS, IR.empty()), ""));
JsDocInfoParser.parseTypeString("{foo: number}"), ""));
JsDocInfoParser.parseTypeString("{foo}"), ""));
JsDocInfoParser.parseTypeString("{foo, bar}"), ""));
JsDocInfoParser.parseTypeString("{foo: number, bar}"), ""));
JsDocInfoParser.parseTypeString("{foo, bar: number}"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("number|string"), ""));
new JSTypeExpression(new Node(Token.ELLIPSIS, IR.string("number")), ""));
builder.recordThrowType(new JSTypeExpression(new Node(Token.STAR), ""));
builder.recordTypedef(new JSTypeExpression(new Node(Token.QMARK), ""));
builder.recordType(new JSTypeExpression(new Node(Token.VOID), ""));
JsDocInfoParser.parseTypeString("{foo:number,bar:string}"), ""));
JsDocInfoParser.parseTypeString("{foo:(number|string)}"), ""));
JsDocInfoParser.parseTypeString("?Object"), ""));
JsDocInfoParser.parseTypeString("!Object"), ""));
JsDocInfoParser.parseTypeString("!Array<(number|string)>"), ""));
JsDocInfoParser.parseTypeString("Array"), ""));
JsDocInfoParser.parseTypeString("!Set<number|string>"), ""));
JsDocInfoParser.parseTypeString("!Map<!Foo, !Bar<!Baz|string>>"), ""));
JsDocInfoParser.parseTypeString("Map"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Foo"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("!Foo"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Foo"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("!Foo"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Bar"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Bar.Baz"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Foo"), ""));
new JSTypeExpression(JsDocInfoParser.parseTypeString("Bar"), ""));
JsDocInfoParser.parseTypeString("function()"), ""));
JsDocInfoParser.parseTypeString("function(foo,bar)"), ""));
JsDocInfoParser.parseTypeString("function(foo):number"), ""));
JsDocInfoParser.parseTypeString("function(new:goog,number)"), ""));
JsDocInfoParser.parseTypeString("function(this:number,...)"), ""));
JsDocInfoParser.parseTypeString("function(...number)"), ""));
JsDocInfoParser.parseTypeString("function():void"), ""));
JsDocInfoParser.parseTypeString("function():number"), ""));
JsDocInfoParser.parseTypeString("function(string):number"), ""));
JsDocInfoParser.parseTypeString("function(this:foo):?"), ""));
JsDocInfoParser.parseTypeString("string"), ""));
JsDocInfoParser.parseTypeString("string"), ""));
return parent.isAssign()
&& parent.getFirstChild() == getProp
&& getProp.getLastChild().getString().equals("prototype");
private boolean isLooseAssignmentToPrototype(
Node getprop, JSType currentPrototype, JSType newPrototype) {
return NodeUtil.isPrototypeAssignment(getprop)
&& !currentPrototype.isUnknownType()
&& (newPrototype.isUnknownType()
|| newPrototype.isEquivalentTo(getNativeType(JSTypeNative.OBJECT_TYPE)))
&& currentPrototype.isSubtype(newPrototype);
if (isLooseAssignmentToPrototype(left, leftType, resultType)) {
return;
boolean isVarDeclaration = left.hasChildren() && varType != null && !var.isTypeInferred();
ObjectType objType = ObjectType.cast(rawObjType.restrictByNotNullOrUndefined());
ObjectType objectType = ObjectType.cast(nodeType.restrictByNotNullOrUndefined());
private boolean ensurePropertyDeclaredHelper(Node getprop, ObjectType objectType) {
return objectType.defineDeclaredProperty(propName, var.getType(), getprop);
void maybeDeclareQualifiedName(
NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {
if (rhsValue != null && rhsValue.getJSType() != null) {
qVar.getScope().undeclare(qVar);
boolean inferred = isQualifiedNameInferred(qName, n, info, rhsValue, valueType);
"}",
"Property x never defined on ns.Foo");
lines(
"/** @constructor */ function Foo() {}",
"/** @constructor */ function Bar() {}",
"/** @type {Array} */ Bar.prototype = new Foo()"),
"variable Bar.prototype redefined with type (Array|null),"
+ " original definition at [testcode]:2 with type Bar.prototype");
public void testPrototypeAssignmentDoesntMessUpInterfaceInheritance1() {
testTypes(
lines(
"/** @record */",
"function Toggle() {}",
"/**",
" * @param {string} x",
" * @return {string}",
" */",
"Toggle.prototype.foobar = function(x) {};",
"function f() {",
"  /**",
"   * @constructor",
"   * @implements {Toggle}",
"   */",
"  function Foo() {}",
"  Foo.prototype = Object.create(Toggle.prototype);",
"  /** @override */",
"  Foo.prototype.foobar = function(x) { return ''; };",
"  var /** number */ s = (new Foo).foobar('asdf');",
"}"),
lines(
"initializing variable",
"found   : string",
"required: number"));
public void testPrototypeAssignmentDoesntMessUpInterfaceInheritance2() {
testTypes(
lines(
"/** @record */",
"function Toggle() {}",
"/**",
" * @param {string} x",
" * @return {string}",
" */",
"Toggle.prototype.foobar = function(x) {};",
"function f(x) {",
"  /**",
"   * @constructor",
"   * @implements {Toggle}",
"   */",
"  function Foo() {}",
"  Foo.prototype = x;",
"  /** @override */",
"  Foo.prototype.foobar = function(x) { return ''; };",
"  var /** number */ s = (new Foo).foobar('asdf');",
"}"),
lines(
"initializing variable",
"found   : string",
"required: number"));
return parent.isAssign() && parent.getFirstChild() == getProp
&& parent.getFirstChild().getLastChild().getString().equals("prototype");
boolean isVarDeclaration = left.hasChildren()
&& varType != null && !var.isTypeInferred();
ObjectType objType = ObjectType.cast(
rawObjType.restrictByNotNullOrUndefined());
ObjectType objectType = ObjectType.cast(
nodeType.restrictByNotNullOrUndefined());
private boolean ensurePropertyDeclaredHelper(
Node getprop, ObjectType objectType) {
return objectType.defineDeclaredProperty(
propName, var.getType(), getprop);
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
Node n, Node parent, Node rhsValue) {
qVar.getScope().undeclare(qVar);
boolean inferred = isQualifiedNameInferred(
qName, n, info, rhsValue, valueType);
"}");
"/** @constructor */ function Foo() {}" +
"/** @constructor */ function Bar() {}" +
"/** @type {Array} */ Bar.prototype = new Foo()");
return !n.isSyntheticBlock() &&
isFusableControlStatement(n.getFirstChild());
computeMustDef(c.getFirstChild(), cfgNode, output, conditional);
return;
if (n.isName() && "arguments".equals(n.getString())) {
escapeParameters(output);
inline(
"var x = 1; if (true) { x = 3; } var y = [[0]], z = x; for ([x] in y) {}; alert(z);",
"var x = 1; if (true) { x = 3; } var y = [[0]], z    ; for ([x] in y) {}; alert(x);");
inline(
"var x = 1; if (true) { x = 3; } var y = [[0]], z = x; for ([x] of y) {}; alert(z);",
"var x = 1; if (true) { x = 3; } var y = [[0]], z    ; for ([x] of y) {}; alert(x);");
inline(
"var x = 1; if (true) { x = 2; } var y = x; [x] = []; print(y);",
"var x = 1; if (true) { x = 2; } var y    ; [x] = []; print(x);");
inline(
"var x = 1; if (true) { x = 2; } var y = x; ({x} = {}); print(y);",
"var x = 1; if (true) { x = 2; } var y    ; ({x} = {}); print(x);");
inline(
"var x = 1; if (true) { x = 2; } var y = x; var [z] = [x = 3]; print(y);",
"var x = 1; if (true) { x = 2; } var y    ; var [z] = [x = 3]; print(x);");
enableNormalize();
defineSlot(n, parent, unknownType, true);
propName, unknownType, n);
propName, ownerType == null ? unknownType : ownerType);
private JSType getInheritedInterfacePropertyType(ObjectType obj, String propName) {
if (obj != null && obj.isPrototypeObject()) {
FunctionType f = obj.getOwnerFunction();
for (ObjectType i : f.getImplementedInterfaces()) {
if (i.hasProperty(propName)) {
return i.getPropertyType(propName);
return null;
JSType inheritedType = getInheritedInterfacePropertyType(ownerType, propName);
JSType stubType = inheritedType == null ? unknownType : inheritedType;
defineSlot(n, parent, stubType, true);
propName, stubType, n);
propName, ownerType == null ? stubType : ownerType);
public void testStubMethodDeclarationDoesntBlockTypechecking_1() {
testTypes(
lines(
"/** @interface */",
"function Foo() {}",
"/** @return {number} */",
"Foo.prototype.method = function() {};",
"/**",
" * @constructor",
" * @implements {Foo}",
" */",
"function Bar() {}",
"Bar.prototype.method;",
"var /** null */ n = (new Bar).method();"),
lines(
"initializing variable",
"found   : number",
"required: null"));
public void testStubMethodDeclarationDoesntBlockTypechecking_2() {
testTypes(
lines(
"/** @constructor */",
"function Foo() {}",
"/** @return {number} */",
"Foo.prototype.method = function() {};",
"/**",
" * @constructor",
" * @extends {Foo}",
" */",
"function Bar() {}",
"Bar.prototype.method;",
"var /** null */ n = (new Bar).method();"),
lines(
"initializing variable",
"found   : number",
"required: null"));
if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
if (!aliasRefs.isAssignedOnceInLifetime()) {
if (name.isConstructor() && referencesCollapsibleProperty(aliasRefs, name, namespace)) {
compiler.report(JSError.make(aliasParent, UNSAFE_CTOR_ALIASING, aliasVarName));
return false;
return partiallyInlineAlias(alias, namespace, aliasRefs, aliasLhsNode);
return true;
return false;
private boolean canReplaceAliasAssignment(Ref alias, Node aliasLhsNode) {
if (NodeUtil.isNameDeclaration(aliasLhsNode)) {
Node assign = aliasLhsNode.getParent();
return !NodeUtil.isExpressionResultUsed(assign);
"    var b = a.b;",
"    alert(b.staticProp); } }"),
warning(AggressiveInlineAliases.UNSAFE_CTOR_ALIASING));
test(
lines(
"/** @constructor @struct */ var Main = function() {};",
"Main.doSomething = function(i) {}",
"function f() {",
"  var tmp;",
"  for (let i = 0; i < n(); i++) {",
"    tmp = Main;",
"    Main.doSomething(5);",
"    use(Main);",
"  }",
"  use(tmp);",
"  use(tmp.doSomething);", // This line may break if Main$doSomething is collapsed.
"}"));
testSame(
"}"));
test(
"  use(tmp.doSomething);",
lines(
"/** @constructor */ var Main = function() {};",
"var Main$doSomething = function(i) {}",
"function f() {",
"  var tmp;",
"  if (g()) {",
"    use(tmp.doSomething);",
"    tmp = Main;",
"    Main$doSomething(5);",
"  }",
"  use(tmp.doSomething);", // This line will work incorrectly if g() is true.
"}"));
"var a = {};\n"
+ "/** @constructor */ a.b = function() {};\n"
+ "a.b.staticProp = 5;\n"
+ "function f() {\n"
+ "  while (true) {\n"
+ "    var b = a.b;\n"
+ "    alert(b.staticProp);\n"
+ "  }\n"
+ "}\n", "/** @constructor */ var a$b = function() {};\n"
+ "var a$b$staticProp = 5;\n"
+ "\n"
+ "function f() {\n"
+ "  while (true) {\n"
+ "    var b = a$b;\n"
+ "    alert(b.staticProp);\n"
+ "  }\n"
+ "}",
warning(AggressiveInlineAliases.UNSAFE_CTOR_ALIASING));
defineSlot(n, parent, unknownType, true);
propName, unknownType, n);
propName, ownerType == null ? unknownType : ownerType);
if (rootNode.isFromExterns()) return null;
if (type == null || !type.isFunctionType()) return null;
ParseTree right = parseUnaryExpression();
System.err.println("PKID: " + child.toStringTree());
assertSideEffect(false, "({[a]: x})");
assertSideEffect(true, "({[a()]: x})");
assertSideEffect(true, "({[a]: x()})");
if (defSite.isGetterDef()) {
if ("arguments".equals(name) && NodeUtil.isVanillaFunction(scope.getRootNode())) {
public V getArgumentsVar() {
private static final String ARGUMENTS = "arguments";
if (!scope.isDeclared(name, false)
&& !(scope.isLocal() && name.equals(ARGUMENTS))) {
public Var getArgumentsVar() {
throw new IllegalStateException("Method getArgumentsVar cannot be called on typed scopes.");
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
check(c);
return ES5;
if (lhs.isName()) {
addToSetIfLocal(lhs, kill);
addToSetIfLocal(lhs, gen);
computeGenKill(lhs, gen, kill, conditional);
computeGenKill(c, gen, kill, conditional);
return;
case DESTRUCTURING_LHS:
if (n.hasTwoChildren()) {
computeGenKill(n.getSecondChild(), gen, kill, conditional);
if (!conditional) {
Iterable<Node> allVars = NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child, kill);
"for (let [y = x] of arr) { y; }"),
lines(
"let x;",
"[];",
"foo;"),
lines(
"let bar;",
"[];",
"const {foo = bar} = obj;",
inFunction(
lines(
"let bar;",
"bar = [];",
"const [foo = bar] = arr;",
"foo;"),
lines(
"let bar;",
"[];",
"const [foo = bar] = arr;",
"foo;"));
"let str;",
"str = 'bar'",
"const {[str + 'baz']: foo} = obj;",
"foo;"),
lines(
"let str;",
"'bar'",
"const {[str + 'baz']: foo} = obj;",
public void testDestructuring() {
public final String debugLog;
this.debugLog = null;
public Result(JSError[] errors, JSError[] warnings, String debugLog,
VariableMap variableMap, VariableMap propertyMap,
VariableMap namedAnonFunctionMap,
FunctionInformationMap functionInformationMap,
SourceMap sourceMap, String externExport) {
this(errors, warnings, variableMap, propertyMap,
namedAnonFunctionMap, null, functionInformationMap, sourceMap,
externExport, null, null, null);
abstract void addToDebugLog(String... message);
private final StringBuilder debugLog = new StringBuilder();
return new Result(getErrors(), getWarnings(), debugLog.toString(),
void addToDebugLog(String... strings) {
logger.warning("addToDebugLog is no longer supported. Use a java.util.logging.Logger instead");
logger.info(Joiner.on("").join(strings));
Result(JSError[] errors, JSError[] warnings, String debugLog,
this.debugLog = debugLog;
this(errors, warnings, debugLog, variableMap, propertyMap,
if (mode != Mode.SINGLE_FILE) { // TODO(tbreisacher): Fix violations and remove this check.
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
computeGenKill(c.getFirstChild(), gen, kill, conditional);
if (!conditional) {
addToSetIfLocal(c, kill);
Iterable<Node> allVars = NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child, kill);
"    var {foo: obj} = obj;",
"    var {foo: obj} = obj;",
"    alert(obj);",
"    var {foo: obj} = obj;",
"    alert(obj);",
if (!NodeUtil.isLValue(n) && !parent.isGetProp()) {
import com.google.javascript.jscomp.Normalize.NormalizeStatements;
if (compiler.getOptions().needsTranspilationFrom(FeatureSet.ES6)) {
RewriteBlockScopedFunctionDeclaration rewriteFunction =
new RewriteBlockScopedFunctionDeclaration();
for (Node singleRoot : root.children()) {
FeatureSet features = (FeatureSet) singleRoot.getProp(Node.FEATURE_SET);
if (features.has(Feature.BLOCK_SCOPED_FUNCTION_DECLARATION)) {
NodeTraversal.traverseEs6(compiler, singleRoot, rewriteFunction);
NodeTraversal.traverseEs6(compiler, scriptRoot, new RewriteBlockScopedFunctionDeclaration());
private class RewriteBlockScopedFunctionDeclaration extends AbstractPostOrderCallback {
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isFunction()) {
NormalizeStatements.visitFunction(n, compiler);
if (isDeclaration) {
features = features.with(Feature.BLOCK_SCOPED_FUNCTION_DECLARATION);
BLOCK_SCOPED_FUNCTION_DECLARATION("block function", LangVersion.ES3),
"  function f() {",
"  function f() {",
public void testFunctionInLoop() {
test(
lines(
"for (var x of y) {",
"  function f() {",
"    let z;",
"  }",
"}"),
lines(
"for (var x of y) {",
"  var f = function() {",
"    var z;",
"  };",
"}"));
"  function f() {",
"    return function f() {",
"  function f() {",
"    return function f() {",
"    return function () {",
"  function f() {",
"    return function f() {",
"  function f() {",
"    return function f() {",
public void testBlockScopedFunctionDeclaration() {
test(
lines(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    function x() { return x; }",
"  }",
"  return x;",
"}"),
lines(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    var x$0 = function() { return x$0; };",
"  }",
"  return x;",
"}"));
"    function f(e) {",
public void testBlockScopedGeneratorFunction() {
test(
"{ function *f() {yield 1;} }",
"{ var f = function*() { yield 1; }; }");
""
+ "visit NAME a [source_file: [testcode]] @1:4\n"
+ "visit VAR [source_file: [testcode]] @1:0\n"
+ "visit NAME foo [source_file: [testcode]] @2:9\n"
+ "visit PARAM_LIST [source_file: [testcode]] @2:12\n"
+ "visit NAME b [source_file: [testcode]] @3:6\n"
+ "visit VAR [source_file: [testcode]] @3:2\n"
+ "visit NAME a [source_file: [testcode]] @4:6\n"
+ "visit NAME c [source_file: [testcode]] @4:15\n"
+ "visit VAR [source_file: [testcode]] @4:11\n"
+ "visit BLOCK [source_file: [testcode]] @4:9\n"
+ "visit IF [source_file: [testcode]] @4:2\n"
+ "visit BLOCK [source_file: [testcode]] @2:15\n"
+ "visit FUNCTION foo [source_file: [testcode]] @2:0\n"
+ "visit SCRIPT [source_file: [testcode]] "
+ "[input_id: InputId: [testcode]] "
+ "[feature_set: [block function]] @1:0\n";
parseError("while(1) { function f() { break; } }", UNLABELED_BREAK);
parse("a:switch(1){case(1):function f(){a:while(1){continue a;}}}");
"a:switch(1){case(1):function f(){while(1){continue a;}}}",
public void testBlockScopeFunctionDeclaration() {
parse("if (1) { function f() {} }");
parse("function f() {}");
Node result = parse("if (1) { var f = function() {} }");
FeatureSet features = (FeatureSet) result.getProp(Node.FEATURE_SET);
assertFS(features).doesNotHave(Feature.BLOCK_SCOPED_FUNCTION_DECLARATION);
if (expectedFeatures != null) {
assertFS(result.features).contains(expectedFeatures);
if (expectedFeatures != null) {
assertFS(result.features).contains(expectedFeatures);
Node superClassNameNode = NodeUtil.newQName(compiler, superClassString)
.useSourceInfoIfMissingFrom(metadata.superClassNameNode);
addToDebugLog("Parsing: " + file.getName());
if (options.useDebugLog) {
String log = Joiner.on("").join(strings);
debugLog.append(log);
debugLog.append('\n');
logger.fine(log);
boolean useDebugLog;
useDebugLog = false;
if (checkDeterminism) {
this.useDebugLog = true;
.add("useDebugLog", useDebugLog)
t.getCompiler().addToDebugLog("Inlined function: ", fn.getName());
System.err.println(hashCodeMsg);
compiler.addToDebugLog(hashCodeMsg);
Node finalValue = inputValue != null ?
inputValue : info.getLastValue();
compiler.addToDebugLog("Overriding @define variable ", defineName);
compiler.addToDebugLog("Unreferenced var: ", var.name);
compiler.addToDebugLog("label renamed: ", name, " => ", newName);
compiler.addToDebugLog("JS property assignments:");
compiler.addToDebugLog(p.oldName + " => " + p.newName);
private StringBuilder assignmentLog;
assignmentLog = new StringBuilder();
compiler.addToDebugLog("JS var assignments:\n" + assignmentLog);
assignmentLog = null;
assignmentLog.append(a.oldName).append(" => ").append(newName).append('\n');
Node aliasDeclarationParent = aliasVar.getParentNode();
Scope scope =
aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
collector.processScope(scope);
codeChanged = true;
if ((name.type == Name.Type.OBJECTLIT
|| name.type == Name.Type.FUNCTION
|| name.type == Name.Type.CLASS)
collector.processScope(aliasVar.getScope());
public void testStaticInheritance_superclassIsStaticProperty() {
test(
lines(
"class Foo {}",
"Foo.Builder = class {}",
"Foo.Builder.baz = 3;",
"var Bar = class extends Foo.Builder {}",
"use(Bar.baz);"),
lines(
"class Foo {}",
"Foo.Builder = class {}",
"Foo.Builder.baz = 3;",
"var Bar = class extends Foo.Builder {}",
"use(Foo.Builder.baz);"));
"use(Foo.Builder.baz);"));
"use(Foo$Builder$baz);"));
if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION)
Node aliasDeclarationParent = aliasVar.getParentNode();
Scope scope =
aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
collector.processScope(scope);
"use(Bar.baz);"));
"use(Bar.baz);"));
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
static final DiagnosticType SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES =
"JSC_NTI_SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES",
"Interface {0} has a property {1} with incompatible types in "
+ "its super interfaces: {2}");
SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
Multimap<String, DeclaredFunctionType> propMethodTypesToProcess = LinkedHashMultimap.create();
Multimap<String, JSType> propTypesToProcess = LinkedHashMultimap.create();
checkSuperProperty(
rawType, superClass, pname, propMethodTypesToProcess, propTypesToProcess);
checkSuperProperty(
rawType, superInterf, pname, propMethodTypesToProcess, propTypesToProcess);
for (String pname : propMethodTypesToProcess.keySet()) {
Collection<DeclaredFunctionType> methodTypes = propMethodTypesToProcess.get(pname);
PropertyDef localPropDef = propertyDefs.get(rawType, pname);
warnings.add(JSError.make(localPropDef.defSite,
SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
rawType.getName(), pname, methodTypes.toString()));
propTypesToProcess.put(pname,
add_interface_props:
for (String pname : propTypesToProcess.keySet()) {
Collection<JSType> defs = propTypesToProcess.get(pname);
JSType resultType = getCommonTypes().TOP;
resultType = JSType.meet(resultType, inheritedType);
if (!resultType.isBottom()) {
resultType = inheritedType;
SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
continue add_interface_props;
rawType.addProtoProperty(pname, null, resultType, false);
SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES,
Multimap<String, DeclaredFunctionType> propMethodTypesToProcess,
Multimap<String, JSType> propTypesToProcess) {
Collection<PropertyDef> inheritedPropDefs;
if (superType.isInterface()) {
inheritedPropDefs = getPropDefsFromInterface(superType, pname);
PropertyDef propdef = getPropDefFromClass(superType, pname);
if (propdef == null) {
inheritedPropDefs = ImmutableSet.of(propdef);
if (superType.isInterface()
&& current.isClass()
&& !isCtorDefinedByCall(current)
&& !current.mayHaveNonStrayProp(pname)) {
warnings.add(JSError.make(
inheritedPropDefs.iterator().next().defSite,
INTERFACE_METHOD_NOT_IMPLEMENTED,
pname, superType.toString(), current.toString()));
return;
JSType localPropType =
localPropDef == null ? null : current.getInstancePropDeclaredType(pname);
if (localPropDef != null && superType.isClass()
&& localPropType != null
&& localPropType.getFunType() != null
&& superType.hasConstantProp(pname)) {
warnings.add(JSError.make(
localPropDef.defSite, CANNOT_OVERRIDE_FINAL_METHOD, pname));
if (localPropType == null && superType.isInterface()) {
propTypesToProcess.put(pname, inheritedPropType);
propMethodTypesToProcess.put(pname, inheritedPropDef.methodType);
"/** @constructor @implements{I} */ function C() {}",
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
GlobalTypeInfoCollector.SUPER_INTERFACES_HAVE_INCOMPATIBLE_PROPERTIES);
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
class AliasStrings extends AbstractPostOrderCallback
implements CompilerPass {
import com.google.common.collect.ArrayListMultimap;
private final Set<Var> referenced = new HashSet<>();
private List<Var> maybeUnreferenced = new ArrayList<>();
private final Multimap<Var, Removable> assignsByVar =
ArrayListMultimap.create();
private final Set<Node> assignsByNode = new HashSet<>();
private final Multimap<Var, Node> classDefiningCalls =
ArrayListMultimap.create();
private final Multimap<Var, Continuation> continuations =
ArrayListMultimap.create();
private final ScopeCreator scopeCreator;
traverseNode(root, null, scope);
if (removeGlobals) {
collectMaybeUnreferencedVars(scope);
interpretAssigns();
private void traverseNode(Node n, Node parent, Scope scope) {
if (NodeUtil.isFunctionDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
traverseFunction(n, scope);
return;
Assign maybeAssign = Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
var = scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var, maybeAssign);
assignsByNode.add(maybeAssign.nameNode);
if (isRemovableVar(var)
&& !maybeAssign.mayHaveSecondarySideEffects) {
continuations.put(var, new Continuation(n, scope));
return;
Var modifiedVar = null;
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
modifiedVar = scope.getVar(subclassRelationship.subclassName);
String className = codingConvention.getSingletonGetterClassName(n);
if (className != null) {
modifiedVar = scope.getVar(className);
if (modifiedVar != null && modifiedVar.isGlobal()
&& !referenced.contains(modifiedVar)) {
classDefiningCalls.put(modifiedVar, parent);
continuations.put(modifiedVar, new Continuation(n, scope));
return;
case BLOCK:
if (NodeUtil.createsBlockScope(n)) {
Scope blockScope = scopeCreator.createScope(n, scope);
collectMaybeUnreferencedVars(blockScope);
scope = blockScope;
if (NodeUtil.isClassDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
return;
case DEFAULT_VALUE: {
Node target = n.getFirstChild();
if (target.isName()) {
Node value = n.getLastChild();
var = scope.getVar(target.getString());
if (!NodeUtil.mayHaveSideEffects(value)) {
continuations.put(var, new Continuation(n, scope));
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
markReferencedVar(var);
assignsByNode.add(target);
break;
case REST: {
Node target = n.getFirstChild();
if (target.isName()) {
assignsByNode.add(target);
var = scope.getVar(target.getString());
assignsByVar.put(var, new DestructuringAssign(n, target));
break;
case ARRAY_PATTERN:
for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {
if (c.isName()) {
assignsByNode.add(c);
var = scope.getVar(c.getString());
assignsByVar.put(var, new DestructuringAssign(c, c));
case COMPUTED_PROP:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
Node value = n.getFirstChild();
if (!NodeUtil.mayHaveSideEffects(value)) {
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
Node defaultTarget = target.getFirstChild();
var = scope.getVar(defaultTarget.getString());
markReferencedVar(var);
case STRING_KEY:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
case NAME:
if (parent.isParamList()) {
break;
var = scope.getVar(n.getString());
if (NodeUtil.isNameDeclaration(parent)) {
Node value = n.getFirstChild();
if (value != null && var != null && isRemovableVar(var)
&& !NodeUtil.mayHaveSideEffects(value, compiler)) {
continuations.put(var, new Continuation(n, scope));
return;
if (var != null
&& "arguments".equals(n.getString())
&& var.equals(scope.getArgumentsVar())) {
Scope fnScope = var.getScope();
Node paramList = NodeUtil.getFunctionParameters(fnScope.getRootNode());
for (Node p : NodeUtil.findLhsNodesInNode(paramList)) {
Var paramVar = fnScope.getOwnSlot(p.getString());
checkNotNull(paramVar);
markReferencedVar(paramVar);
if (isRemovableVar(var)) {
if (!assignsByNode.contains(n)) {
markReferencedVar(var);
markReferencedVar(var);
traverseChildren(n, scope);
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, n, scope);
private boolean isRemovableVar(Var var) {
if (var.equals(var.getScope().getArgumentsVar())) {
return false;
if (!removeGlobals && var.isGlobal()) {
return false;
if (var.getParentNode() != null && NodeUtil.isEnhancedFor(var.getParentNode().getParent())) {
return false;
if (referenced.contains(var)) {
return false;
return !codingConvention.isExported(var.getName());
collectMaybeUnreferencedVars(fparamScope);
collectMaybeUnreferencedVars(fbodyScope);
private void collectMaybeUnreferencedVars(Scope scope) {
for (Var var : scope.getVarIterable()) {
if (isRemovableVar(var)) {
maybeUnreferenced.add(var);
if (!referenced.contains(var)) {
if (!referenced.contains(var)) {
private void interpretAssigns() {
boolean changes = false;
do {
changes = false;
int removedCount = 0;
for (int current = 0; current < maybeUnreferenced.size(); current++) {
Var var = maybeUnreferenced.get(current);
if (var == null) {
continue;
if (referenced.contains(var)) {
maybeUnreferenced.set(current, null);
removedCount++;
boolean assignedToUnknownValue = false;
if (NodeUtil.isNameDeclaration(var.getParentNode())
&& !var.getParentNode().getParent().isForIn()) {
Node value = var.getInitialValue();
assignedToUnknownValue = value != null
&& !NodeUtil.isLiteralValue(value, true);
assignedToUnknownValue = false;
assignedToUnknownValue = true;
boolean maybeEscaped = false;
boolean hasPropertyAssign = false;
for (Removable removable : assignsByVar.get(var)) {
if (removable instanceof DestructuringAssign) {
assignedToUnknownValue = true;
continue;
Assign assign = (Assign) removable;
if (assign.isPropertyAssign) {
hasPropertyAssign = true;
assign.assignNode.getLastChild(), true)) {
assignedToUnknownValue = true;
if (assign.maybeAliased) {
maybeEscaped = true;
if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
changes = markReferencedVar(var) || changes;
maybeUnreferenced.set(current, null);
removedCount++;
if (removedCount > 0) {
int size = maybeUnreferenced.size();
ArrayList<Var> refreshed = new ArrayList<>(size - removedCount);
for (int i = 0; i < size; i++) {
Var var = maybeUnreferenced.get(i);
if (var != null) {
refreshed.add(var);
maybeUnreferenced = refreshed;
private void removeAllAssigns(Var var) {
for (Removable removable : assignsByVar.get(var)) {
removable.remove(compiler);
private boolean markReferencedVar(Var var) {
if (referenced.add(var)) {
for (Continuation c : continuations.get(var)) {
c.apply();
return true;
return false;
for (Var var : maybeUnreferenced) {
for (Node exprCallNode : classDefiningCalls.get(var)) {
compiler.reportChangeToEnclosingScope(exprCallNode);
NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);
removeAllAssigns(var);
compiler.addToDebugLog("Unreferenced var: ", var.name);
Node nameNode = var.nameNode;
if (toRemove == null) {
continue;
Node parent = toRemove != null ? toRemove.getParent() : null;
Node grandParent = parent != null ? parent.getParent() : null;
if (toRemove.isDefaultValue() || toRemove.isRest()) {
checkState(parent == null || grandParent == null);
checkState(parent == null, "unremoved destructuring ", toRemove);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(toRemove, nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
compiler.reportChangeToEnclosingScope(nameNode);
NodeUtil.removeChild(toRemove, nameNode);
&& nameNode.hasChildren()
&& NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {
if (toRemove.hasOneChild()) {
compiler.reportChangeToEnclosingScope(toRemove);
parent.replaceChild(toRemove,
IR.exprResult(nameNode.removeFirstChild()));
compiler.reportChangeToEnclosingScope(toRemove);
toRemove.removeChild(nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
NodeUtil.markFunctionsDeleted(toRemove, compiler);
if (NodeUtil.isFunctionDeclaration(node)) {
for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {
traverseNode(child, node, scope);
private static interface Removable {
public void remove(AbstractCompiler compiler);
private class DestructuringAssign implements Removable {
DestructuringAssign(Node removableNode, Node nameNode) {
public void remove(AbstractCompiler compiler) {
private static class Assign implements Removable {
final boolean isPropertyAssign;
final boolean mayHaveSecondarySideEffects;
Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {
this.isPropertyAssign = isPropertyAssign;
this.mayHaveSecondarySideEffects =
maybeAliased
|| NodeUtil.mayHaveSideEffects(assignNode.getFirstChild())
|| NodeUtil.mayHaveSideEffects(assignNode.getLastChild());
static Assign maybeCreateAssign(Node assignNode) {
checkState(NodeUtil.isAssignmentOp(assignNode));
boolean isPropAssign = false;
Node current = assignNode.getFirstChild();
if (NodeUtil.isGet(current)) {
current = current.getFirstChild();
isPropAssign = true;
if (current.isGetProp()
&& current.getLastChild().getString().equals("prototype")) {
current = current.getFirstChild();
if (current.isName()) {
return new Assign(assignNode, current, isPropAssign);
return null;
public void remove(AbstractCompiler compiler) {
compiler.reportChangeToEnclosingScope(assignNode);
if (mayHaveSecondarySideEffects) {
Node replacement = assignNode.getLastChild().detach();
for (Node current = assignNode.getFirstChild();
!current.isName();
current = current.getFirstChild()) {
if (current.isGetElem()) {
replacement = IR.comma(
current.getLastChild().detach(), replacement);
replacement.useSourceInfoIfMissingFrom(current);
assignNode.replaceWith(replacement);
Node parent = assignNode.getParent();
if (parent.isExprResult()) {
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).srcref(assignNode));
super("function alert() {}");
testSame("for(let x; ;){}");
testSame("for(let x, y; ;) {x} ");
testSame("for(let x=0,y=0;;y++){}");
testSame("for(item in items){}");
testSame("for(item of items){}");
import static com.google.common.base.Preconditions.checkArgument;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
private final Deque<Continuation> worklist = new ArrayDeque<>();
private final Map<Var, VarInfo> varInfoMap = new HashMap<>();
private final Set<String> referencedPropertyNames = new HashSet<>();
private final Multimap<String, VarInfo> varInfoForPropertyNameMap = HashMultimap.create();
private final List<Scope> allFunctionParamScopes = new ArrayList<>();
private final boolean removeUnusedProperties = false;
worklist.add(new Continuation(root, scope));
while (!worklist.isEmpty()) {
Continuation continuation = worklist.remove();
continuation.apply();
if (removeUnusedProperties) {
removeUnreferencedProperties();
private void removeUnreferencedProperties() {
for (VarInfo varInfo : varInfoForPropertyNameMap.values()) {
varInfo.removeUnreferencedProperties();
private void traverseNode(Node n, Scope scope) {
Node parent = n.getParent();
case CATCH:
traverseCatch(n, scope);
break;
case FUNCTION:
VarInfo varInfo = null;
if (NodeUtil.isFunctionDeclaration(n)) {
varInfo = getVarInfo(scope.getVar(n.getFirstChild().getString()));
FunctionDeclaration functionDeclaration =
new RemovableBuilder()
.addContinuation(new Continuation(n, scope))
.buildFunctionDeclaration(n);
varInfo.addRemovable(functionDeclaration);
if (parent.isExport()) {
varInfo.markAsReferenced();
traverseFunction(n, scope);
case ASSIGN:
traverseAssign(n, scope);
break;
case CALL:
traverseCall(n, scope);
traverseChildren(
n, NodeUtil.createsBlockScope(n) ? scopeCreator.createScope(n, scope) : scope);
case MODULE_BODY:
traverseChildren(n, scopeCreator.createScope(n, scope));
break;
case CLASS:
traverseClass(n, scope);
break;
case DEFAULT_VALUE:
traverseDefaultValue(n, scope);
break;
case REST:
traverseRest(n, scope);
break;
traverseArrayPattern(n, scope);
case OBJECT_PATTERN:
traverseObjectPattern(n, scope);
case OBJECTLIT:
traverseObjectLiteral(n, scope);
case FOR:
traverseVanillaFor(n, scope);
break;
case FOR_IN:
case FOR_OF:
traverseEnhancedFor(n, scope);
break;
case LET:
case CONST:
case VAR:
checkState(NodeUtil.isStatement(n));
traverseDeclarationStatement(n, scope);
break;
case NAME:
checkState(!n.hasChildren());
if (!parent.isParamList()) {
checkState(!NodeUtil.isNameDeclaration(parent));
checkState(!((parent.isFunction() || parent.isClass()) && parent.getFirstChild() == n));
var = scope.getVar(n.getString());
getVarInfo(var).markAsReferenced();
case GETPROP:
Node objectNode = n.getFirstChild();
Node propertyNameNode = objectNode.getNext();
String propertyName = propertyNameNode.getString();
markPropertyNameReferenced(propertyName);
traverseNode(objectNode, scope);
break;
traverseChildren(n, scope);
private void traverseCall(Node callNode, Scope scope) {
Node parent = callNode.getParent();
String classVarName = null;
if (parent.isExprResult() || parent.isComma() && parent.getFirstChild() == callNode) {
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(callNode);
if (subclassRelationship != null) {
classVarName = subclassRelationship.subclassName;
classVarName = codingConvention.getSingletonGetterClassName(callNode);
Var classVar = (classVarName == null) ? null : scope.getVar(classVarName);
if (classVar == null || !classVar.isGlobal()) {
traverseChildren(callNode, scope);
VarInfo classVarInfo = getVarInfo(classVar);
RemovableBuilder builder = new RemovableBuilder();
for (Node child = callNode.getFirstChild(); child != null; child = child.getNext()) {
builder.addContinuation(new Continuation(child, scope));
classVarInfo.addRemovable(builder.buildClassSetupCall(callNode));
private void traverseRest(Node restNode, Scope scope) {
Node target = restNode.getOnlyChild();
if (!target.isName()) {
traverseNode(target, scope);
Var var = scope.getVar(target.getString());
if (var != null) {
VarInfo varInfo = getVarInfo(var);
varInfo.addRemovable(new RemovableBuilder().buildDestructuringAssign(restNode, target));
private void traverseObjectLiteral(Node objectLiteral, Scope scope) {
for (Node propertyNode = objectLiteral.getFirstChild();
propertyNode != null;
propertyNode = propertyNode.getNext()) {
if (propertyNode.isStringKey() && !propertyNode.isQuotedString()) {
markPropertyNameReferenced(propertyNode.getString());
traverseNode(propertyNode.getFirstChild(), scope);
traverseNode(propertyNode, scope);
private void traverseCatch(Node catchNode, Scope scope) {
Node exceptionNameNode = catchNode.getFirstChild();
Node block = exceptionNameNode.getNext();
VarInfo exceptionVarInfo = getVarInfo(scope.getVar(exceptionNameNode.getString()));
exceptionVarInfo.setCannotRemoveAnything();
traverseNode(block, scope);
private void traverseEnhancedFor(Node enhancedFor, Scope scope) {
Scope forScope = scopeCreator.createScope(enhancedFor, scope);
Node iterationTarget = enhancedFor.getFirstChild();
Node collection = iterationTarget.getNext();
Node body = collection.getNext();
if (iterationTarget.isName()) {
VarInfo varInfo = getVarInfo(forScope.getVar(iterationTarget.getString()));
varInfo.setCannotRemoveAnything();
Node declNode = iterationTarget.getOnlyChild();
if (declNode.isDestructuringLhs()) {
traverseNode(declNode, forScope);
checkState(declNode.isName());
checkState(!declNode.hasChildren());
VarInfo varInfo = getVarInfo(forScope.getVar(declNode.getString()));
varInfo.setCannotRemoveAnything();
traverseNode(iterationTarget, forScope);
traverseNode(collection, forScope);
traverseNode(body, forScope);
private void traverseVanillaFor(Node forNode, Scope scope) {
Scope forScope = scopeCreator.createScope(forNode, scope);
Node initialization = forNode.getFirstChild();
Node condition = initialization.getNext();
Node update = condition.getNext();
Node block = update.getNext();
if (NodeUtil.isNameDeclaration(initialization)) {
traverseVanillaForNameDeclarations(initialization, forScope);
traverseNode(initialization, forScope);
traverseNode(condition, forScope);
traverseNode(update, forScope);
traverseNode(block, forScope);
private void traverseVanillaForNameDeclarations(Node nameDeclaration, Scope scope) {
for (Node child = nameDeclaration.getFirstChild(); child != null; child = child.getNext()) {
if (!child.isName()) {
traverseNode(child, scope);
Node nameNode = child;
VarInfo varInfo = getVarInfo(scope.getVar(nameNode.getString()));
if (valueNode == null) {
varInfo.addRemovable(new RemovableBuilder().buildVanillaForNameDeclaration(nameNode));
varInfo.setIsExplicitlyNotRemovable();
traverseNode(valueNode, scope);
VanillaForNameDeclaration vanillaForNameDeclaration =
new RemovableBuilder()
.setAssignedValue(valueNode)
.addContinuation(new Continuation(valueNode, scope))
.buildVanillaForNameDeclaration(nameNode);
varInfo.addRemovable(vanillaForNameDeclaration);
private void traverseDeclarationStatement(Node declarationStatement, Scope scope) {
Node nameNode = declarationStatement.getOnlyChild();
if (!nameNode.isName()) {
traverseNode(nameNode, scope);
Node valueNode = nameNode.getFirstChild();
VarInfo varInfo = getVarInfo(checkNotNull(scope.getVar(nameNode.getString())));
RemovableBuilder builder = new RemovableBuilder();
if (valueNode == null) {
varInfo.addRemovable(builder.buildNameDeclarationStatement(declarationStatement));
if (NodeUtil.mayHaveSideEffects(valueNode)) {
traverseNode(valueNode, scope);
builder.addContinuation(new Continuation(valueNode, scope));
NameDeclarationStatement removable =
builder.setAssignedValue(valueNode).buildNameDeclarationStatement(declarationStatement);
varInfo.addRemovable(removable);
private void traverseAssign(Node assignNode, Scope scope) {
checkState(NodeUtil.isAssignmentOp(assignNode));
Node lhs = assignNode.getFirstChild();
Node nameNode = null;
Node propertyNode = null;
boolean isVariableAssign = false;
boolean isComputedPropertyAssign = false;
boolean isNamedPropertyAssign = false;
if (lhs.isName()) {
isVariableAssign = true;
nameNode = lhs;
propertyNode = lhs.getLastChild();
Node possibleNameNode = lhs.getFirstChild();
if (possibleNameNode.isGetProp()
&& possibleNameNode.getSecondChild().getString().equals("prototype")) {
possibleNameNode = possibleNameNode.getFirstChild();
if (possibleNameNode.isName()) {
nameNode = possibleNameNode;
if (lhs.isGetProp()) {
isNamedPropertyAssign = true;
checkState(lhs.isGetElem());
isComputedPropertyAssign = true;
Var var = (nameNode == null) ? null : scope.getVar(nameNode.getString());
if (var == null) {
traverseChildren(assignNode, scope);
Node valueNode = assignNode.getLastChild();
RemovableBuilder builder = new RemovableBuilder().setAssignedValue(valueNode);
if (NodeUtil.isExpressionResultUsed(assignNode) || NodeUtil.mayHaveSideEffects(valueNode)) {
traverseNode(valueNode, scope);
builder.addContinuation(new Continuation(valueNode, scope));
VarInfo varInfo = getVarInfo(var);
if (isNamedPropertyAssign) {
varInfo.addRemovable(builder.buildNamedPropertyAssign(assignNode, nameNode, propertyNode));
varInfo.addRemovable(builder.buildVariableAssign(assignNode, nameNode));
checkState(isComputedPropertyAssign);
if (NodeUtil.mayHaveSideEffects(propertyNode)) {
traverseNode(propertyNode, scope);
builder.addContinuation(new Continuation(propertyNode, scope));
varInfo.addRemovable(
builder.buildComputedPropertyAssign(assignNode, nameNode, propertyNode));
private void traverseDefaultValue(Node defaultValueNode, Scope scope) {
Var var;
Node target = defaultValueNode.getFirstChild();
Node value = target.getNext();
if (!target.isName()) {
traverseNode(target, scope);
traverseNode(value, scope);
var = scope.getVar(target.getString());
if (var == null) {
traverseNode(value, scope);
VarInfo varInfo = getVarInfo(var);
if (NodeUtil.mayHaveSideEffects(value)) {
varInfo.markAsReferenced();
traverseNode(value, scope);
DestructuringAssign assign =
new RemovableBuilder()
.addContinuation(new Continuation(value, scope))
.buildDestructuringAssign(defaultValueNode, target);
varInfo.addRemovable(assign);
private void traverseArrayPattern(Node arrayPattern, Scope scope) {
for (Node c = arrayPattern.getFirstChild(); c != null; c = c.getNext()) {
if (!c.isName()) {
traverseNode(c, scope);
Var var = scope.getVar(c.getString());
if (var != null) {
VarInfo varInfo = getVarInfo(var);
varInfo.addRemovable(new RemovableBuilder().buildDestructuringAssign(c, c));
private void traverseObjectPattern(Node objectPattern, Scope scope) {
for (Node propertyNode = objectPattern.getFirstChild();
propertyNode != null;
propertyNode = propertyNode.getNext()) {
traverseObjectPatternElement(propertyNode, scope);
private void traverseObjectPatternElement(Node elm, Scope scope) {
Node propertyExpression = null;
String propertyName = null;
Node target = null;
Node defaultValue = null;
if (elm.isComputedProp()) {
propertyExpression = elm.getFirstChild();
target = elm.getLastChild();
checkState(elm.isStringKey());
target = elm.getOnlyChild();
if (!elm.isQuotedString()) {
propertyName = elm.getString();
if (target.isDefaultValue()) {
target = target.getFirstChild();
defaultValue = checkNotNull(target.getNext());
Var var = target.isName() ? scope.getVar(target.getString()) : null;
boolean cannotRemove =
var == null
|| (propertyExpression != null && NodeUtil.mayHaveSideEffects(propertyExpression))
|| (defaultValue != null && NodeUtil.mayHaveSideEffects(defaultValue));
if (cannotRemove) {
if (propertyExpression != null) {
traverseNode(propertyExpression, scope);
if (propertyName != null) {
markPropertyNameReferenced(propertyName);
traverseNode(target, scope);
if (defaultValue != null) {
traverseNode(defaultValue, scope);
if (var != null) {
getVarInfo(var).markAsReferenced();
RemovableBuilder builder = new RemovableBuilder();
if (propertyName != null) {
markPropertyNameReferenced(propertyName);
if (propertyExpression != null) {
builder.addContinuation(new Continuation(propertyExpression, scope));
if (defaultValue != null) {
builder.addContinuation(new Continuation(defaultValue, scope));
getVarInfo(var).addRemovable(builder.buildDestructuringAssign(elm, target));
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, scope);
private void traverseClass(Node classNode, Scope scope) {
checkArgument(classNode.isClass());
Node classNameNode = classNode.getFirstChild();
Node baseClassExpression = classNameNode.getNext();
Node classBodyNode = baseClassExpression.getNext();
Scope classScope = scopeCreator.createScope(classNode, scope);
if (!NodeUtil.isNamedClass(classNode) || classNode.getParent().isExport()) {
traverseNode(baseClassExpression, classScope);
traverseNode(classBodyNode, classScope);
traverseNode(baseClassExpression, classScope);
traverseNode(classBodyNode, classScope);
RemovableBuilder builder =
new RemovableBuilder()
.addContinuation(new Continuation(baseClassExpression, classScope))
.addContinuation(new Continuation(classBodyNode, classScope));
VarInfo varInfo = getVarInfo(classScope.getVar(classNameNode.getString()));
if (NodeUtil.isClassDeclaration(classNode)) {
varInfo.addRemovable(builder.buildClassDeclaration(classNode));
varInfo.addRemovable(builder.buildNamedClassExpression(classNode));
getFunctionNameVarInfo(function, fparamScope);
if (NodeUtil.isVarArgsFunction(function)) {
for (Node p : NodeUtil.findLhsNodesInNode(paramlist)) {
Var paramVar = checkNotNull(fparamScope.getOwnSlot(p.getString()));
getVarInfo(paramVar).markAsReferenced();
private VarInfo getFunctionNameVarInfo(Node function, Scope scope) {
Node nameNode = checkNotNull(function.getFirstChild());
checkState(nameNode.isName());
String name = nameNode.getString();
if (name.isEmpty()) {
return null;
Var var = checkNotNull(scope.getVar(name));
return getVarInfo(var);
private void markPropertyNameReferenced(String propertyName) {
if (referencedPropertyNames.add(propertyName)) {
for (VarInfo varInfo : varInfoForPropertyNameMap.get(propertyName)) {
varInfo.markPropertyNameReferenced(propertyName);
VarInfo varInfo = getVarInfo(var);
if (varInfo.isRemovable()) {
VarInfo varInfo = getVarInfo(var);
if (varInfo.isRemovable()) {
private VarInfo getVarInfo(Var var) {
checkNotNull(var);
VarInfo varInfo = varInfoMap.get(var);
if (varInfo == null) {
varInfo = new VarInfo(var);
varInfoMap.put(var, varInfo);
return varInfo;
for (VarInfo varInfo : varInfoMap.values()) {
if (!varInfo.isRemovable()) {
continue;
varInfo.removeAllRemovables();
compiler.addToDebugLog("Unreferenced var: ", varInfo.var.name);
Node nameNode = varInfo.var.nameNode;
if (toRemove == null || alreadyRemoved(toRemove)) {
throw new IllegalStateException("unremoved code");
if (node.isFunction()) {
traverseNode(node, scope);
private abstract class Removable {
private final List<Continuation> continuations;
private boolean continuationsAreApplied = false;
private boolean isRemoved = false;
Removable(RemovableBuilder builder) {
continuations = builder.continuations;
propertyName = builder.propertyName;
assignedValue = builder.assignedValue;
String getPropertyName() {
checkState(isNamedPropertyAssignment());
return checkNotNull(propertyName);
abstract void removeInternal(AbstractCompiler compiler);
void remove(AbstractCompiler compiler) {
if (!isRemoved) {
isRemoved = true;
removeInternal(compiler);
public void applyContinuations() {
if (!continuationsAreApplied) {
continuationsAreApplied = true;
for (Continuation c : continuations) {
worklist.add(c);
continuations.clear();
boolean isLiteralValueAssignment() {
return assignedValue == null
|| NodeUtil.isLiteralValue(assignedValue, /* includeFunctions */ true);
boolean isVariableAssignment() {
return false;
boolean isPropertyAssignment() {
return false;
boolean isNamedPropertyAssignment() {
return propertyName != null;
boolean assignedValueMayEscape() {
return false;
private class RemovableBuilder {
final List<Continuation> continuations = new ArrayList<>();
RemovableBuilder addContinuation(Continuation continuation) {
continuations.add(continuation);
return this;
RemovableBuilder setAssignedValue(@Nullable Node assignedValue) {
this.assignedValue = assignedValue;
return this;
DestructuringAssign buildDestructuringAssign(Node removableNode, Node nameNode) {
return new DestructuringAssign(this, removableNode, nameNode);
ClassDeclaration buildClassDeclaration(Node classNode) {
return new ClassDeclaration(this, classNode);
NamedClassExpression buildNamedClassExpression(Node classNode) {
return new NamedClassExpression(this, classNode);
FunctionDeclaration buildFunctionDeclaration(Node functionNode) {
return new FunctionDeclaration(this, functionNode);
NameDeclarationStatement buildNameDeclarationStatement(Node declarationStatement) {
return new NameDeclarationStatement(this, declarationStatement);
Assign buildNamedPropertyAssign(Node assignNode, Node nameNode, Node propertyNode) {
this.propertyName = propertyNode.getString();
checkNotNull(assignedValue);
return new Assign(this, assignNode, nameNode, Kind.NAMED_PROPERTY, propertyNode);
Assign buildComputedPropertyAssign(Node assignNode, Node nameNode, Node propertyNode) {
checkNotNull(assignedValue);
return new Assign(this, assignNode, nameNode, Kind.COMPUTED_PROPERTY, propertyNode);
Assign buildVariableAssign(Node assignNode, Node nameNode) {
return new Assign(this, assignNode, nameNode, Kind.VARIABLE, /* propertyNode */ null);
ClassSetupCall buildClassSetupCall(Node callNode) {
return new ClassSetupCall(this, callNode);
VanillaForNameDeclaration buildVanillaForNameDeclaration(Node nameNode) {
return new VanillaForNameDeclaration(this, nameNode);
private class DestructuringAssign extends Removable {
DestructuringAssign(RemovableBuilder builder, Node removableNode, Node nameNode) {
super(builder);
boolean isVariableAssignment() {
return true;
boolean isLiteralValueAssignment() {
return false;
public void removeInternal(AbstractCompiler compiler) {
if (alreadyRemoved(removableNode)) {
return;
private class ClassDeclaration extends Removable {
final Node classDeclarationNode;
ClassDeclaration(RemovableBuilder builder, Node classDeclarationNode) {
super(builder);
this.classDeclarationNode = classDeclarationNode;
public void removeInternal(AbstractCompiler compiler) {
NodeUtil.deleteNode(classDeclarationNode, compiler);
private class NamedClassExpression extends Removable {
final Node classNode;
NamedClassExpression(RemovableBuilder builder, Node classNode) {
super(builder);
this.classNode = classNode;
public void removeInternal(AbstractCompiler compiler) {
if (!alreadyRemoved(classNode)) {
Node nameNode = classNode.getFirstChild();
if (!nameNode.isEmpty()) {
classNode.replaceChild(nameNode, IR.empty().useSourceInfoFrom(nameNode));
compiler.reportChangeToEnclosingScope(classNode);
private class FunctionDeclaration extends Removable {
final Node functionDeclarationNode;
FunctionDeclaration(RemovableBuilder builder, Node functionDeclarationNode) {
super(builder);
this.functionDeclarationNode = functionDeclarationNode;
public void removeInternal(AbstractCompiler compiler) {
NodeUtil.deleteNode(functionDeclarationNode, compiler);
private class NameDeclarationStatement extends Removable {
private final Node declarationStatement;
public NameDeclarationStatement(RemovableBuilder builder, Node declarationStatement) {
super(builder);
this.declarationStatement = declarationStatement;
void removeInternal(AbstractCompiler compiler) {
Node nameNode = declarationStatement.getOnlyChild();
Node valueNode = nameNode.getFirstChild();
if (valueNode != null && NodeUtil.mayHaveSideEffects(valueNode)) {
compiler.reportChangeToEnclosingScope(declarationStatement);
valueNode.detach();
declarationStatement.replaceWith(IR.exprResult(valueNode).useSourceInfoFrom(valueNode));
NodeUtil.deleteNode(declarationStatement, compiler);
boolean isVariableAssignment() {
return true;
enum Kind {
VARIABLE,
NAMED_PROPERTY,
COMPUTED_PROPERTY;
private class Assign extends Removable {
final Node assignNode;
final Kind kind;
Assign(
RemovableBuilder builder,
Node assignNode,
Node nameNode,
Kind kind,
super(builder);
if (kind == Kind.VARIABLE) {
checkArgument(
propertyNode == null,
"got property node for simple variable assignment: %s",
propertyNode);
checkArgument(propertyNode != null, "missing property node");
if (kind == Kind.NAMED_PROPERTY) {
checkArgument(propertyNode.isString(), "property name is not a string: %s", propertyNode);
this.kind = kind;
this.propertyNode = propertyNode;
boolean assignedValueMayEscape() {
return maybeAliased;
boolean isVariableAssignment() {
return kind == Kind.VARIABLE;
boolean isPropertyAssignment() {
return isNamedPropertyAssignment() || isComputedPropertyAssignment();
boolean isNamedPropertyAssignment() {
return kind == Kind.NAMED_PROPERTY;
boolean isComputedPropertyAssignment() {
return kind == Kind.COMPUTED_PROPERTY;
public void removeInternal(AbstractCompiler compiler) {
if (alreadyRemoved(assignNode)) {
return;
Node parent = assignNode.getParent();
compiler.reportChangeToEnclosingScope(parent);
Node lhs = assignNode.getFirstChild();
Node rhs = assignNode.getSecondChild();
boolean mustPreserveRhs =
NodeUtil.mayHaveSideEffects(rhs) || NodeUtil.isExpressionResultUsed(assignNode);
boolean mustPreserveGetElmExpr =
lhs.isGetElem() && NodeUtil.mayHaveSideEffects(lhs.getLastChild());
if (mustPreserveRhs && mustPreserveGetElmExpr) {
Node replacement =
IR.comma(lhs.getLastChild().detach(), rhs.detach()).useSourceInfoFrom(assignNode);
assignNode.replaceWith(lhs.getLastChild().detach());
NodeUtil.markFunctionsDeleted(rhs, compiler);
assignNode.replaceWith(rhs.detach());
NodeUtil.markFunctionsDeleted(lhs, compiler);
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).useSourceInfoFrom(assignNode));
NodeUtil.markFunctionsDeleted(assignNode, compiler);
private class ClassSetupCall extends Removable {
final Node callNode;
ClassSetupCall(RemovableBuilder builder, Node callNode) {
super(builder);
this.callNode = callNode;
public void removeInternal(AbstractCompiler compiler) {
Node parent = callNode.getParent();
if (parent.isExprResult()) {
NodeUtil.deleteNode(parent, compiler);
checkState(parent.isComma());
Node rhs = checkNotNull(callNode.getNext());
compiler.reportChangeToEnclosingScope(parent);
parent.replaceWith(rhs.detach());
private class VarInfo {
final Var var;
final List<Removable> removables = new ArrayList<>();
Multimap<String, Removable> namedPropertyRemovables = null;
boolean isEntirelyRemovable = true;
boolean unreferencedPropertiesMayBeRemoved = removeUnusedProperties;
boolean propertyAssignmentsWillPreventRemoval = false;
boolean hasPropertyAssignments = false;
VarInfo(Var var) {
this.var = var;
boolean isGlobal = var.isGlobal();
if (isGlobal && !removeGlobals) {
setCannotRemoveAnything();
setCannotRemoveAnything();
setCannotRemoveAnything();
propertyAssignmentsWillPreventRemoval = true;
unreferencedPropertiesMayBeRemoved = false;
void addRemovable(Removable removable) {
if (removable.isPropertyAssignment()) {
hasPropertyAssignments = true;
if (propertyAssignmentsWillPreventRemoval) {
setIsExplicitlyNotRemovable();
&& (removable.assignedValueMayEscape() || !removable.isLiteralValueAssignment())) {
propertyAssignmentsWillPreventRemoval = true;
if (hasPropertyAssignments) {
setIsExplicitlyNotRemovable();
if (removable.isNamedPropertyAssignment()) {
String propertyName = removable.getPropertyName();
if (isPropertyRemovable(propertyName)) {
if (namedPropertyRemovables == null) {
namedPropertyRemovables = HashMultimap.create();
namedPropertyRemovables.put(propertyName, removable);
varInfoForPropertyNameMap.put(propertyName, this);
removable.applyContinuations();
removables.add(removable);
removable.applyContinuations();
boolean markAsReferenced() {
return setIsExplicitlyNotRemovable();
void markPropertyNameReferenced(String propertyName) {
if (!isEntirelyRemovable && namedPropertyRemovables != null) {
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.applyContinuations();
boolean isRemovable() {
return isEntirelyRemovable;
void setCannotRemoveAnything() {
unreferencedPropertiesMayBeRemoved = false;
setIsExplicitlyNotRemovable();
boolean isPropertyRemovable(String propertyName) {
return isEntirelyRemovable
|| unreferencedPropertiesMayBeRemoved && !referencedPropertyNames.contains(propertyName);
boolean setIsExplicitlyNotRemovable() {
if (isEntirelyRemovable) {
isEntirelyRemovable = false;
for (Removable r : removables) {
r.applyContinuations();
removables.clear();
if (namedPropertyRemovables != null) {
for (String propertyName : ImmutableList.copyOf(namedPropertyRemovables.keySet())) {
if (!isPropertyRemovable(propertyName)) {
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.applyContinuations();
return true;
return false;
void removeAllRemovables() {
checkState(isEntirelyRemovable);
for (Removable removable : removables) {
removable.remove(compiler);
removables.clear();
if (namedPropertyRemovables != null) {
for (Removable removable : namedPropertyRemovables.values()) {
removable.remove(compiler);
namedPropertyRemovables.clear();
namedPropertyRemovables = null;
void removeUnreferencedProperties() {
checkState(!isEntirelyRemovable && unreferencedPropertiesMayBeRemoved);
if (namedPropertyRemovables != null) {
for (String propertyName : ImmutableList.copyOf(namedPropertyRemovables.keySet())) {
checkState(!referencedPropertyNames.contains(propertyName));
for (Removable r : namedPropertyRemovables.removeAll(propertyName)) {
r.remove(compiler);
private class VanillaForNameDeclaration extends Removable {
private final Node nameNode;
private VanillaForNameDeclaration(RemovableBuilder builder, Node nameNode) {
super(builder);
this.nameNode = nameNode;
void removeInternal(AbstractCompiler compiler) {
Node declaration = checkNotNull(nameNode.getParent());
compiler.reportChangeToEnclosingScope(declaration);
if (nameNode.getPrevious() == null && nameNode.getNext() == null) {
declaration.replaceWith(IR.empty().useSourceInfoFrom(declaration));
declaration.removeChild(nameNode);
NodeUtil.markFunctionsDeleted(nameNode, compiler);
public void testUsageBeforeDefinition() {
test("function f(a) { x[a] = 1; } var x; x = {}; f();", "function f() {} f();");
public void testReferencedPropertiesOnUnreferencedVar() {
test("var x = {}; x.a = 1; var y = {a: 2}; y.a;", "var y = {a: 2}; y.a;");
public void testPropertyValuesAddedAfterReferenceAreRemoved() {
testSame("var x = 1; var y = {}; y; y.foo = x;");
public void testReferenceInObjectLiteral() {
testSame(LINE_JOINER.join(
"function f(a) {",
"  return {a: a};",
"}",
"f(1);"));
public void testSelfOverwrite() {
testSame("var a = function() { a = function() {}; }; a();");
public void testPropertyReferenceAddsPropertyReference() {
testSame("var a = {}; a.foo = function() { b.foo = 1; }; var b = {}; a.foo(); b.foo;");
public void testUnknownVarDestructuredAssign() {
testSame("({a:x} = {a:1});");
testSame("({a:x = 1} = {});");
testSame("({['a']:x} = {a:1});");
testSame("({['a']:x = 1} = {});");
testSame("[x] = [1];");
testSame("[x = 1] = [];");
testSame("[, ...x] = [1];");
testSame("[, ...[x = 1]] = [1];");
public void testRemoveVarDeclaration1() {
test("var a = 0, b = a = 1", "");
public void testRemoveVarDeclaration2() {
test("var a;var b = 0, c = a = b = 1", "");
public void testDollarSuperParameterNotRemoved() {
testSame("function f($super) {} f();");
public void testFunctionArgRemovalWithLeadingUnderscore() {
test("function f(__$jscomp$1) {__$jscomp$1 = 1;} f();", "function f() {} f();");
public void testES6ModuleExports() {
test("const X = 1; function f() {}", "");
test("const X = 1; export function f() {}", "function f() {} export {f as f}");
test("const X = 1; export class C {}", "class C {} export { C as C }");
test("const X = 1; export default function f() {};", "export default function f() {}");
test("const X = 1; export default class C {}", "export default class C {}");
public void testRemoveInheritedClass12() {
testSame(
LINE_JOINER.join(
"function goog$inherits(){}",
"function a(){}",
"function b(){}",
"goog$inherits(b, a) + 1;"));
test(
LINE_JOINER.join(
"function goog$inherits(){}",
"function a(){}",
"function b(){}",
"(goog$inherits(b, a), 1);"),
"1");
test("var C = class {};", "");
test("var C = class X {}; new C;", "var C = class {}; new C;");
public void testReferencesInClasses() {
testSame(
LINE_JOINER.join(
"const A = 15;",
"const C = class {",
"  constructor() {",
"    this.a = A;",
"  }",
"}",
"new C;"));
test("for(let x; ;){}", "for(;;){}");
test("for(let x, y; ;) {x}", "for(let x; ;) {x}");
test("for(let x, y; ;) {y}", "for(let y; ;) {y}");
test("for(let x=0,y=0;;y++){}", "for(let y=0;;y++){}");
testSame("let item; for(item in items){}");
testSame("for(let item in items){}");
testSame("let item; for(item of items){}");
import com.google.common.collect.ArrayListMultimap;
private final Set<Var> referenced = new HashSet<>();
private List<Var> maybeUnreferenced = new ArrayList<>();
private final Multimap<Var, Removable> assignsByVar =
ArrayListMultimap.create();
private final Set<Node> assignsByNode = new HashSet<>();
private final Multimap<Var, Node> classDefiningCalls =
ArrayListMultimap.create();
private final Multimap<Var, Continuation> continuations =
ArrayListMultimap.create();
private final ScopeCreator scopeCreator;
traverseNode(root, null, scope);
if (removeGlobals) {
collectMaybeUnreferencedVars(scope);
interpretAssigns();
private void traverseNode(Node n, Node parent, Scope scope) {
if (NodeUtil.isFunctionDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
traverseFunction(n, scope);
return;
Assign maybeAssign = Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
var = scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var, maybeAssign);
assignsByNode.add(maybeAssign.nameNode);
if (isRemovableVar(var)
&& !maybeAssign.mayHaveSecondarySideEffects) {
continuations.put(var, new Continuation(n, scope));
return;
Var modifiedVar = null;
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
modifiedVar = scope.getVar(subclassRelationship.subclassName);
String className = codingConvention.getSingletonGetterClassName(n);
if (className != null) {
modifiedVar = scope.getVar(className);
if (modifiedVar != null && modifiedVar.isGlobal()
&& !referenced.contains(modifiedVar)) {
classDefiningCalls.put(modifiedVar, parent);
continuations.put(modifiedVar, new Continuation(n, scope));
return;
case BLOCK:
if (NodeUtil.createsBlockScope(n)) {
Scope blockScope = scopeCreator.createScope(n, scope);
collectMaybeUnreferencedVars(blockScope);
scope = blockScope;
if (NodeUtil.isClassDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
return;
case DEFAULT_VALUE: {
Node target = n.getFirstChild();
if (target.isName()) {
Node value = n.getLastChild();
var = scope.getVar(target.getString());
if (!NodeUtil.mayHaveSideEffects(value)) {
continuations.put(var, new Continuation(n, scope));
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
markReferencedVar(var);
assignsByNode.add(target);
break;
case REST: {
Node target = n.getFirstChild();
if (target.isName()) {
assignsByNode.add(target);
var = scope.getVar(target.getString());
assignsByVar.put(var, new DestructuringAssign(n, target));
break;
case ARRAY_PATTERN:
for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {
if (c.isName()) {
assignsByNode.add(c);
var = scope.getVar(c.getString());
assignsByVar.put(var, new DestructuringAssign(c, c));
case COMPUTED_PROP:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
Node value = n.getFirstChild();
if (!NodeUtil.mayHaveSideEffects(value)) {
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
return;
Node defaultTarget = target.getFirstChild();
var = scope.getVar(defaultTarget.getString());
markReferencedVar(var);
case STRING_KEY:
if (n.getParent().isObjectPattern()) {
Node target = n.getLastChild();
if (target.isName()) {
var = scope.getVar(target.getString());
assignsByNode.add(target);
assignsByVar.put(var, new DestructuringAssign(n, target));
case NAME:
if (parent.isParamList()) {
break;
var = scope.getVar(n.getString());
if (NodeUtil.isNameDeclaration(parent)) {
Node value = n.getFirstChild();
if (value != null && var != null && isRemovableVar(var)
&& !NodeUtil.mayHaveSideEffects(value, compiler)) {
continuations.put(var, new Continuation(n, scope));
return;
if (var != null
&& "arguments".equals(n.getString())
&& var.equals(scope.getArgumentsVar())) {
Scope fnScope = var.getScope();
Node paramList = NodeUtil.getFunctionParameters(fnScope.getRootNode());
for (Node p : NodeUtil.findLhsNodesInNode(paramList)) {
Var paramVar = fnScope.getOwnSlot(p.getString());
checkNotNull(paramVar);
markReferencedVar(paramVar);
if (isRemovableVar(var)) {
if (!assignsByNode.contains(n)) {
markReferencedVar(var);
markReferencedVar(var);
traverseChildren(n, scope);
private void traverseChildren(Node n, Scope scope) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, n, scope);
private boolean isRemovableVar(Var var) {
if (var.equals(var.getScope().getArgumentsVar())) {
return false;
if (!removeGlobals && var.isGlobal()) {
return false;
if (var.getParentNode() != null && NodeUtil.isEnhancedFor(var.getParentNode().getParent())) {
return false;
if (referenced.contains(var)) {
return false;
return !codingConvention.isExported(var.getName());
collectMaybeUnreferencedVars(fparamScope);
collectMaybeUnreferencedVars(fbodyScope);
private void collectMaybeUnreferencedVars(Scope scope) {
for (Var var : scope.getVarIterable()) {
if (isRemovableVar(var)) {
maybeUnreferenced.add(var);
if (!referenced.contains(var)) {
if (!referenced.contains(var)) {
private void interpretAssigns() {
boolean changes = false;
do {
changes = false;
int removedCount = 0;
for (int current = 0; current < maybeUnreferenced.size(); current++) {
Var var = maybeUnreferenced.get(current);
if (var == null) {
continue;
if (referenced.contains(var)) {
maybeUnreferenced.set(current, null);
removedCount++;
boolean assignedToUnknownValue = false;
if (NodeUtil.isNameDeclaration(var.getParentNode())
&& !var.getParentNode().getParent().isForIn()) {
Node value = var.getInitialValue();
assignedToUnknownValue = value != null
&& !NodeUtil.isLiteralValue(value, true);
assignedToUnknownValue = false;
assignedToUnknownValue = true;
boolean maybeEscaped = false;
boolean hasPropertyAssign = false;
for (Removable removable : assignsByVar.get(var)) {
if (removable instanceof DestructuringAssign) {
assignedToUnknownValue = true;
continue;
Assign assign = (Assign) removable;
if (assign.isPropertyAssign) {
hasPropertyAssign = true;
assign.assignNode.getLastChild(), true)) {
assignedToUnknownValue = true;
if (assign.maybeAliased) {
maybeEscaped = true;
if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
changes = markReferencedVar(var) || changes;
maybeUnreferenced.set(current, null);
removedCount++;
if (removedCount > 0) {
int size = maybeUnreferenced.size();
ArrayList<Var> refreshed = new ArrayList<>(size - removedCount);
for (int i = 0; i < size; i++) {
Var var = maybeUnreferenced.get(i);
if (var != null) {
refreshed.add(var);
maybeUnreferenced = refreshed;
private void removeAllAssigns(Var var) {
for (Removable removable : assignsByVar.get(var)) {
removable.remove(compiler);
private boolean markReferencedVar(Var var) {
if (referenced.add(var)) {
for (Continuation c : continuations.get(var)) {
c.apply();
return true;
return false;
for (Var var : maybeUnreferenced) {
for (Node exprCallNode : classDefiningCalls.get(var)) {
compiler.reportChangeToEnclosingScope(exprCallNode);
NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);
removeAllAssigns(var);
compiler.addToDebugLog("Unreferenced var: ", var.name);
Node nameNode = var.nameNode;
if (toRemove == null) {
continue;
Node parent = toRemove != null ? toRemove.getParent() : null;
Node grandParent = parent != null ? parent.getParent() : null;
if (toRemove.isDefaultValue() || toRemove.isRest()) {
checkState(parent == null || grandParent == null);
checkState(parent == null, "unremoved destructuring ", toRemove);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(toRemove, nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
compiler.reportChangeToEnclosingScope(nameNode);
NodeUtil.removeChild(toRemove, nameNode);
&& nameNode.hasChildren()
&& NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {
if (toRemove.hasOneChild()) {
compiler.reportChangeToEnclosingScope(toRemove);
parent.replaceChild(toRemove,
IR.exprResult(nameNode.removeFirstChild()));
compiler.reportChangeToEnclosingScope(toRemove);
toRemove.removeChild(nameNode);
compiler.reportChangeToEnclosingScope(toRemove);
NodeUtil.removeChild(parent, toRemove);
NodeUtil.markFunctionsDeleted(toRemove, compiler);
if (NodeUtil.isFunctionDeclaration(node)) {
for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {
traverseNode(child, node, scope);
private static interface Removable {
public void remove(AbstractCompiler compiler);
private class DestructuringAssign implements Removable {
DestructuringAssign(Node removableNode, Node nameNode) {
public void remove(AbstractCompiler compiler) {
private static class Assign implements Removable {
final boolean isPropertyAssign;
final boolean mayHaveSecondarySideEffects;
Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {
this.isPropertyAssign = isPropertyAssign;
this.mayHaveSecondarySideEffects =
maybeAliased
|| NodeUtil.mayHaveSideEffects(assignNode.getFirstChild())
|| NodeUtil.mayHaveSideEffects(assignNode.getLastChild());
static Assign maybeCreateAssign(Node assignNode) {
checkState(NodeUtil.isAssignmentOp(assignNode));
boolean isPropAssign = false;
Node current = assignNode.getFirstChild();
if (NodeUtil.isGet(current)) {
current = current.getFirstChild();
isPropAssign = true;
if (current.isGetProp()
&& current.getLastChild().getString().equals("prototype")) {
current = current.getFirstChild();
if (current.isName()) {
return new Assign(assignNode, current, isPropAssign);
return null;
public void remove(AbstractCompiler compiler) {
compiler.reportChangeToEnclosingScope(assignNode);
if (mayHaveSecondarySideEffects) {
Node replacement = assignNode.getLastChild().detach();
for (Node current = assignNode.getFirstChild();
!current.isName();
current = current.getFirstChild()) {
if (current.isGetElem()) {
replacement = IR.comma(
current.getLastChild().detach(), replacement);
replacement.useSourceInfoIfMissingFrom(current);
assignNode.replaceWith(replacement);
Node parent = assignNode.getParent();
if (parent.isExprResult()) {
parent.detach();
NodeUtil.markFunctionsDeleted(parent, compiler);
assignNode.replaceWith(IR.number(0).srcref(assignNode));
testSame("for(let x; ;){}");
testSame("for(let x, y; ;) {x} ");
testSame("for(let x=0,y=0;;y++){}");
testSame("for(item in items){}");
testSame("for(item of items){}");
new PassFactory("rewriteAsyncFunctions", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
new PassFactory("convertEs7ToEs6", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
protected static final ImmutableList<SourceFile> EXTERNS =
Result result = compiler.compile(EXTERNS, inputs, options);
"/** @interface */",
"function IThenable () {}",
"IThenable.prototype.then = function(onFulfilled) {};",
"/**",
" * @template T",
" * @constructor",
" * @implements {IThenable}",
" */",
"function Promise(resolver) {};",
"/**",
" * @param {VALUE} value",
" * @return {!Promise<VALUE>}",
" * @template VALUE",
" */",
"Promise.resolve = function(value) {};",
"/**",
" * @template RESULT",
" * @param {function(): RESULT} onFulfilled",
" * @return {RESULT}",
" */",
"Promise.prototype.then = function(onFulfilled) {};",
Result result = compiler.compile(EXTERNS, inputs, options);
Result result = compiler.compile(EXTERNS, inputs, options);
compiler.compile(EXTERNS, inputs, options);
public void testFunctionInference21() throws Exception {
public void testBug901455() throws Exception {
public void testBug911118() throws Exception {
testTypes("/** @constructor */ function Foo() {} \n" +
"/** @type {Foo} */ var x = /** @type {Foo} */ (y)");
public void testCast33() throws Exception {
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {string|undefined} */(x);");
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {string?} */(x);");
"/** @constructor */ function C() {}\n" +
"/** @type {null|undefined} */ var x ;\n" +
"var y = /** @type {null} */(x);");
public void testMissingProperty28() throws Exception {
public void testGenerics1() throws Exception {
testTypes(
fnDecl +
"/** @type {string} */" +
"var out;" +
"var result = f(0, function(x){ out = x; return x; });",
"assignment\n" +
"found   : number\n" +
"required: string");
fnDecl +
"var out;" +
"/** @type {string} */" +
"var result = f(0, function(x){ out = x; return x; });",
"assignment\n" +
"found   : number\n" +
"required: string");
public void testIssue1024() throws Exception {
testTypes(
"/** @param {Object} a */\n" +
"function f(a) {\n" +
"  a.prototype = {foo:3};\n" +
"}\n" +
"/** @param {Object} b\n" +
" */\n" +
"function g(b) {\n" +
"  b.prototype = function(){};\n" +
"}\n",
"assignment to property prototype of Object\n" +
"found   : {foo: number}\n" +
"required: function(): undefined");
public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules() throws Exception {
private JSType TOP;
this.TOP = this.commonTypes.TOP;
lhsPair = analyzeExprFwd(lhs, preciseEnv,
UNKNOWN, lhsPair.type.specialize(rhsPair.type));
rhsPair = analyzeExprFwd(rhs, lhsPair.env,
UNKNOWN, rhsPair.type.specialize(lhsPair.type));
(comparisonOp == Token.SHNE && specializedType.isTrueOrTruthy())) {
return maybeCtor;
if (n.getNext().isName()) { // class it extends from
nameInfo.superclass = n.getNext().getString();
checkState(isAnalyzableObjectDefinePropertiesDefinition(n));
return ImmutableList.of(n.getLastChild());
return qnameNode.isName()
? new QualifiedName(qnameNode.getString())
: new QualifiedName(ImmutableList.copyOf(
Splitter.on('.').split(qnameNode.getQualifiedName())));
public void testIssue2210() {
public void testIssue2210b() {
"var y = 1;",
"goog.scope(function () {",
"  function x(y) {}",
"  ns.fact = function y(n) {",
"    return n == 1 ? 1 : n * y(n - 1);",
"  };",
"});"),
public void testIssue2210c() {
"    use(y);", "  };",
if (exitEnv == null) {
exitEnv = envPutType(new TypeEnv(), RETVAL_ID, BOTTOM);
builder.addRetType(firstNonBottom(actualRetType, TOP));
public void testDontInferBottomReturn() {
typeCheck(
"function f() { throw ''; } f() - 5;",
NewTypeInference.INVALID_OPERAND_TYPE);
if (options.getNewTypeInference()) {
if (options.getNewTypeInference()) {
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType()
&& !type.hasUninstantiatedTypeVariables();
public void testIsTemplatized() {
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized('Array'), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 'asdf'; }",
"var /** string */ s = f();"));
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized(type('Array', 'number')), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 123; }",
"var /** number */ n = f();"));
typeCheck(LINE_JOINER.join(
"/**",
" * @template T := cond(isTemplatized('number'), 'number', 'string') =:",
" * @return {T}",
" */",
"function f() { return 'asdf'; }",
"var /** string */ s = f();"));
abstract void throwInternalError(String msg, Exception cause);
void throwInternalError(String message, Exception cause) {
private void throwUnexpectedException(Exception unexpectedException) {
if (scope.ownSymbols.remove(s.getName()) != s) {
if (symbols.remove(s.getDeclaration().getNode(), s.getName()) != s) {
for (Symbol s : Iterables.concat(googModuleExportTypes, types)) {
createPropertyScopeFor(s);
import com.google.javascript.rhino.JSDocInfo;
static boolean isCtorDefinedByCall(Node qnameNode) {
if (!qnameNode.isName() && !qnameNode.isGetProp()) {
return false;
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(qnameNode);
Node rhs = NodeUtil.getRValueOfLValue(qnameNode);
return jsdoc != null && jsdoc.isConstructor() && rhs != null && rhs.isCall();
checkSuperProperty(rawType, superClass, pname,
propMethodTypesToProcess, propTypesToProcess);
if (GlobalTypeInfo.isCtorDefinedByCall(NodeUtil.getBestLValue(current.getDefSite()))) {
PropertyDef propdef = checkNotNull(
getPropDefFromClass(superType, pname),
"getPropDefFromClass(%s, %s) returned null", superType, pname);
&& !GlobalTypeInfo.isCtorDefinedByCall(NodeUtil.getBestLValue(current.getDefSite()))
if (GlobalTypeInfo.isCtorDefinedByCall(lhs)) {
if (GlobalTypeInfo.isCtorDefinedByCall(nameNode)) {
if (classType.hasCtorProp(pname)
if (GlobalTypeInfo.isCtorDefinedByCall(getProp)) {
|| (ns.hasProp(pname)
|| (GlobalTypeInfo.isCtorDefinedByCall(nameNode)
|| (GlobalTypeInfo.isCtorDefinedByCall(lhs)
public final boolean hasProp(String pname) {
return maybeWin.getProp(pname);
Property getProp(String pname) {
Property p = this.rawType.getProp(pname);
Property p = this.rawType.getOwnProp(pname);
Property p = this.rawType.getProp(pname);
Property prop2 = other.getProp(pname);
Property prop1 = this.getProp(pname);
Property otherProp = resultNominalType.getProp(pname);
Property otherProp = resultNominalType.getProp(pname);
return nom.getProp(pname);
return this.nominalType.getProp(pname);
Property getOwnProp(String pname) {
p = randomProps.get(pname);
if (p != null) {
return p;
Property p = getPropFromClass(pname);
private Property getPropFromClass(String pname) {
Property p = getOwnProp(pname);
p = this.superclass.getProp(pname);
private Property getPropFromInterface(String pname) {
Property p = getOwnProp(pname);
p = interf.getProp(pname);
Property getProp(String pname) {
return getPropFromInterface(pname);
return getPropFromClass(pname);
return getOwnProp(pname) != null;
return getProp(pname) != null;
Property p = getProp(pname);
public boolean hasCtorProp(String pname) {
return super.hasProp(pname);
testSame("var foo = {}; /** @nocollapse */ foo.bar = true;",
"foo.bar;", MISPLACED_ANNOTATION);
return !found;
Preconditions.checkArgument(root.isRoot());
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.ObjectType;
JSType type = node.getJSType();
return "/** @enum {" +
type.toMaybeEnumType().getElementsType().toAnnotationString() +
"} */\n";
&& !type.isEmptyType()
&& !type.isFunctionPrototypeType()) {
return "/** @type {" + node.getJSType().toAnnotationString() + "} */\n";
JSType type = fnNode.getJSType();
FunctionType funType = type.toMaybeFunctionType();
if (JSType.isEquivalent(
type, (JSType) registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) {
int i = 0;
for (Node n : funType.getParameters()) {
appendAnnotation(sb, "param", getParameterNodeJSDocType(n));
i++;
JSType retType = funType.getReturnType();
if (retType != null &&
!retType.isEmptyType() && // There is no annotation for the empty type.
!funType.isInterface() && // Interfaces never return a value.
!(funType.isConstructor() && retType.isVoidType())) {
FunctionType superConstructor = funType.getSuperClassConstructor();
if (superConstructor != null) {
ObjectType superInstance =
funType.getSuperClassConstructor().getInstanceType();
if (!superInstance.toString().equals("Object")) {
appendAnnotation(sb, "extends", superInstance.toAnnotationString());
if (funType.isInterface()) {
for (ObjectType interfaceType : funType.getExtendedInterfaces()) {
appendAnnotation(sb, "extends", interfaceType.toAnnotationString());
Set<String> interfaces = new TreeSet<>();
for (ObjectType interfaze : funType.getImplementedInterfaces()) {
interfaces.add(interfaze.toAnnotationString());
for (String interfaze : interfaces) {
sb.append(" * ");
appendAnnotation(sb, "implements", interfaze);
sb.append("\n");
if (funType.isConstructor()) {
if (!funType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {
Joiner.on(",").appendTo(sb, funType.getTemplateTypeMap().getTemplateKeys());
private String getParameterNodeJSDocType(Node parameterNode) {
JSType parameterType = parameterNode.getJSType();
String typeString;
if (parameterNode.isOptionalArg()) {
typeString = restrictByUndefined(parameterType).toNonNullAnnotationString() +
"=";
typeString = "..." +
restrictByUndefined(parameterType).toNonNullAnnotationString();
typeString = parameterType.toNonNullAnnotationString();
return typeString;
private JSType restrictByUndefined(JSType type) {
if (type.isUnionType()) {
return type.toMaybeUnionType().getRestrictedUnion(
(JSType) registry.getNativeType(JSTypeNative.VOID_TYPE));
return type;
boolean isEnumObject() {
return false;
EnumType e = null;
e = Iterables.getOnlyElement(t.getEnums());
break;
return e != null && this.equals(e.toJSType().getObjTypeIfSingletonObj());
return sb.append(forAnnotations ? "Object" : getReferenceName());
if (forAnnotations && isObject()
&& !isUnknownType() && !isTemplateType() && !isRecordType() && !isFunctionType()) {
assertPrettyPrintSame(
"var x = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;\n");
"/**\n * @constructor\n */\n"
+ "function Foo() {\n}\n");
Joiner.on("\n").join(
Joiner.on("\n").join(
"/** @typedef {Array<number>} */ goog.java.Long;\n"
+ "/** @param {!goog.java.Long} a*/\n"
+ "function f(a){};\n",
"goog.java.Long;\n"
+ "/**\n"
+ " * @param {(Array<number>|null)} a\n"
+ " * @return {undefined}\n"
+ " */\n"
+ "function f(a) {\n}\n");
assertTypeAnnotations("/** @constructor */ var Foo = function(){}",
"/**\n * @constructor\n */\n"
+ "var Foo = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){};"
+ "/** @constructor \n @extends {a.Foo} */ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @constructor\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @interface */ a.Foo = function(){};"
+ "/** @interface \n @extends {a.Foo} */ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @interface\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @interface */ a.Foo1 = function(){};"
+ "/** @interface */ a.Foo2 = function(){};"
+ "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */"
+ "a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo1 = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.Foo2 = function() {\n};\n"
+ "/**\n * @extends {a.Foo1}\n"
+ " * @extends {a.Foo2}\n"
+ " * @interface\n */\n"
+ "a.Bar = function() {\n};\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){}"
+ "/** @param {string} foo\n"
+ "  * @return {number} */\n"
+ "a.Foo.prototype.foo = function(foo) { return 3; };"
+ "/** @type {string|undefined} */"
+ "a.Foo.prototype.bar = '';",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n"
+ " * @param {string} foo\n"
+ " * @return {number}\n"
+ " */\n"
+ "a.Foo.prototype.foo = function(foo) {\n  return 3;\n};\n"
+ "/** @type {string} */\n"
+ "a.Foo.prototype.bar = \"\";\n");
assertTypeAnnotations("/** @interface */ function I(){};"
+ "/** @return {undefined} @param {number} x */ I.prototype.method;",
"/**\n"
+ " * @interface\n"
+ " */\n"
+ "function I() {\n"
+ "}\n"
+ "I.prototype.method;\n");
assertTypeAnnotations("var a = {};"
+ "/** @constructor */ a.Foo = function(){};\n"
+ "/** @interface */ a.I = function(){};\n"
+ "/** @interface */ a.I2 = function(){};\n"
+ "/** @constructor \n @extends {a.Foo}\n"
+ " * @implements {a.I} \n @implements {a.I2}\n"
+ "*/ a.Bar = function(){}",
"var a = {};\n"
+ "/**\n * @constructor\n */\n"
+ "a.Foo = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.I = function() {\n};\n"
+ "/**\n * @interface\n */\n"
+ "a.I2 = function() {\n};\n"
+ "/**\n * @extends {a.Foo}\n"
+ " * @implements {a.I}\n"
+ " * @implements {a.I2}\n * @constructor\n */\n"
+ "a.Bar = function() {\n};\n");
"/** @type {!Function} */\n" +
"var x = function() {\n};\n");
"/** @type {!Function} */\n" +
"var x = function() {\n};\n");
"/**\n" +
" * @param {?} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"/**\n" +
" * @param {string=} x \n" +
" */\n" +
"var a = function(x) {}",
"/**\n" +
" * @param {string=} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"/**\n" +
" * @param {...string} x \n" +
" */\n" +
"var a = function(x) {}",
"/**\n" +
" * @param {...string} x\n" +
" * @return {undefined}\n" +
" */\n" +
"var a = function(x) {\n};\n");
"var x = function() {\n/**\n * @constructor\n */\nfunction t1() {}\n" +
" /**\n * @constructor\n */\nfunction t2() {}\n" +
" t1.prototype = t2.prototype}",
"/**\n * @return {undefined}\n */\nvar x = function() {\n" +
"  /**\n * @constructor\n */\n" +
"function t1() {\n  }\n" +
"  /**\n * @constructor\n */\n" +
"function t2() {\n  }\n" +
"  t1.prototype = t2.prototype;\n};\n"
);
"var goog = goog || {};" +
"/** @enum {string} */ goog.Enum = {FOO: 'x', BAR: 'y'};" +
"/** @const */ goog.Enum2 = goog.x ? {} : goog.Enum;",
"var goog = goog || {};\n" +
"/** @enum {string} */\ngoog.Enum = {FOO:\"x\", BAR:\"y\"};\n" +
"/** @type {(Object|{})} */\ngoog.Enum2 = goog.x ? {} : goog.Enum;\n");
"goog.removeHashCode = goog.removeUid;",
""));
String js = LINE_JOINER.join(
"/**",
" @type {number}",
" @deprecated See {@link replacementClass} for more details.",
" */",
"var x;",
"");
assertEquals(expected,
new CodePrinter.Builder(parse(js, true))
Node call =  n.getFirstFirstChild();
Node call =  n.getFirstFirstChild();
String result = defaultBuilder(parse("var x", true)).setTagAsStrict(true).build();
String result = defaultBuilder(parse("var x", true)).setTagAsExterns(true).build();
import com.google.javascript.rhino.InputId;
import com.google.javascript.rhino.Token;
return parse(js, false);
Node parse(String js, boolean checkTypes) {
compiler.initOptions(options);
Node n = compiler.parseTestCode(js);
if (checkTypes) {
Node externs = new Node(Token.SCRIPT);
externs.setInputId(new InputId("externs"));
Node externAndJsRoot = new Node(Token.ROOT, externs, n);
typeResolver.process(externs, n);
inferTypes.process(externs, n);
return n;
if (isDefinedLocally(varName, false)) {
Preconditions.checkState(!this.localNamespaces.containsKey(varName));
private static ImmutableMap<String, JSType> joinTypeMaps(
Set<String> domain, ImmutableMap<String, JSType> m1, ImmutableMap<String, JSType> m2) {
for (String typevar : domain) {
JSType t1 = m1.get(typevar);
JSType t2 = m2.get(typevar);
if (t1 == null) {
builder.put(typevar, Preconditions.checkNotNull(t2));
builder.put(typevar, t1);
builder.put(typevar, JSType.join(t1, t2));
if (c1.isRawSubtypeOf(c2)) {
return new NominalType(joinTypeMaps(c2.typeMap.keySet(), c1.typeMap, c2.typeMap), c2.rawType);
if (c2.isRawSubtypeOf(c1)) {
return new NominalType(joinTypeMaps(c1.typeMap.keySet(), c1.typeMap, c2.typeMap), c1.rawType);
import com.google.javascript.jscomp.newtypes.ObjectsBuilder.ResolveConflictsBy;
import java.util.Arrays;
Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType, obj2.nominalType));
NominalType resultNomType = NominalType.pickSubclass(obj1.nominalType, obj2.nominalType);
ObjectType[] objs1Arr = objs1.toArray(new ObjectType[0]);
ObjectType[] keptFrom1 = Arrays.copyOf(objs1Arr, objs1Arr.length);
ObjectsBuilder newObjs = new ObjectsBuilder(ResolveConflictsBy.JOIN);
for (ObjectType obj2 : objs2) {
boolean addedObj2 = false;
for (int i = 0; i < objs1Arr.length; i++) {
ObjectType obj1 = objs1Arr[i];
NominalType nt1 = obj1.nominalType;
if (areRelatedNominalTypes(nt1, nt2)) {
if ((nt2.isBuiltinObject() && nt1 != null
&& !obj1.isSubtypeOf(obj2, SubtypeCache.create()))
|| (nt1.isBuiltinObject() && nt2 != null
&& !obj2.isSubtypeOf(obj1, SubtypeCache.create()))) {
break;
keptFrom1[i] = null;
addedObj2 = true;
newObjs.add(join(obj1, obj2));
break;
if (!addedObj2) {
newObjs.add(obj2);
for (ObjectType o : keptFrom1) {
if (o != null) {
newObjs.add(o);
return newObjs.build();
boolean specializeObjs1,
Set<ObjectType> objs1, Set<ObjectType> objs2) {
ObjectsBuilder newObjs = new ObjectsBuilder(ResolveConflictsBy.MEET);
static ImmutableSet<ObjectType> meetSets(
Set<ObjectType> objs1, Set<ObjectType> objs2) {
static ImmutableSet<ObjectType> specializeSet(
Set<ObjectType> objs1, Set<ObjectType> objs2) {
static enum ResolveConflictsBy {
JOIN,
MEET
private final ResolveConflictsBy resolution;
ObjectsBuilder(ResolveConflictsBy resolution) {
this.resolution = resolution;
if (NominalType.equalRawTypes(
oldObj.getNominalType(), newObj.getNominalType())) {
if (this.resolution == ResolveConflictsBy.JOIN) {
this.objs.set(i, ObjectType.join(oldObj, newObj));
this.objs.set(i, ObjectType.meet(oldObj, newObj));
if (parentModuleCanSeeSymbolsDeclaredInChildren &&
parent.isInstanceOf() && parent.getLastChild() == n) {
instanceofNodes.put(parent, new InstanceofInfo(getModule(ref), info));
processRead(ref, info);
Node parent = n.getParent();
if (parent.isAnd() && parent.getLastChild() == n
&& parent.getFirstChild().isNE()) {
Node ne = parent.getFirstChild();
if (ne.getFirstChild().isString()
&& "undefined".equals(ne.getFirstChild().getString())
&& ne.getLastChild().isTypeOf()) {
Node ref = ne.getLastChild().getFirstChild();
if (ref.isEquivalentTo(n.getLastChild())) {
continue;
Node reference = n.getLastChild().cloneNode();
private static int promoteBoolean(int mask) {
int t1Mask = promoteBoolean(t1.getMask());
int t2Mask = promoteBoolean(t2.getMask());
Preconditions.checkNotNull(other);
if (other.isTheTrueType() || other.isTheFalseType()) {
other = this.commonTypes.BOOLEAN;
if (this.isUnknown() || this.isTop()) {
return true;
updateTypemap(typeMultimap, getTypeVar(), other);
return true;
return true;
if (hasTypeVariable() && typeParameters.contains(getTypeVar())) {
updateTypemap(typeMultimap, getTypeVar(), other);
return true;
return false;
Set<EnumType> ununifiedEnums = ImmutableSet.of();
if (!other.getEnums().isEmpty()) {
ununifiedEnums = new LinkedHashSet<>();
for (EnumType e : other.getEnums()) {
if (!fromEnum(e).isSubtypeOf(this, SubtypeCache.create())) {
ununifiedEnums.add(e);
Set<ObjectType> ununifiedObjs = new LinkedHashSet<>(other.getObjs());
for (ObjectType targetObj : getObjs()) {
for (ObjectType sourceObj : other.getObjs()) {
if (targetObj.unifyWithSubtype(
sourceObj, typeParameters, typeMultimap, subSuperMap)) {
ununifiedObjs.remove(sourceObj);
String otherTypevar = other.getTypeVar();
if (thisTypevar == null || !typeParameters.contains(thisTypevar)) {
return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty()
&& (otherTypevar == null || otherTypevar.equals(thisTypevar))
&& getMask() == (getMask() | (other.getMask() & ~ENUM_MASK));
int thisScalarBits = getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
int templateMask = other.getMask() & ~thisScalarBits;
if (ununifiedObjs.isEmpty()) {
templateMask &= ~NON_SCALAR_MASK;
if (templateMask == BOTTOM_MASK) {
return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty();
JSType templateType = makeType(
this.commonTypes,
promoteBoolean(templateMask),
ImmutableSet.copyOf(ununifiedObjs),
otherTypevar, ImmutableSet.copyOf(ununifiedEnums));
updateTypemap(typeMultimap, getTypeVar(), templateType);
return true;
public final Iterable<TypeI> getUnionMembers() {
ImmutableSet.Builder<TypeI> builder = ImmutableSet.builder();
JSType result = this.commonTypes.BOTTOM;
for (JSType t : getSubtypesWithProperty(new QualifiedName(pname))) {
result = join(result, t);
return result;
if (thisNt.unifyWithSubtype(
otherNt, typeParameters, typeMultimap, subSuperMap)) {
if (thisNt.isClass()) {
return false;
return commonTypes.TRUE_TYPE;
return commonTypes.FALSE_TYPE;
return Character.isLetter(ch);
public static MismatchInfo whyNotSubtypeOf(JSType t1, JSType t2) {
if (t1.isSingletonObj() && t2.isSingletonObj()) {
t1.getObjTypeIfSingletonObj(),
t2.getObjTypeIfSingletonObj(),
if (t1.isUnion()) {
t1.isSubtypeOfHelper(true, t2, SubtypeCache.create(), boxedInfo);
Preconditions.checkArgument(!nominalType.isClassy() || !isLoose,
"Cannot create loose objectType with nominal type %s", nominalType);
return this.nominalType != null && this.nominalType.isInterface();
|| this.nominalType != null && this.nominalType.isClassy()
return isUnionSubtypeHelper(
keepLoosenessOfThis, objs1, objs2, subSuperMap, null);
static void whyNotSubtypeOf(
ObjectType obj1, ObjectType obj2, MismatchInfo[] boxedInfo) {
boolean areSubtypes =
obj1.isSubtypeOfHelper(true, obj2, SubtypeCache.create(), boxedInfo);
Preconditions.checkState(!areSubtypes);
Preconditions.checkState(
areRelatedNominalTypes(this.nominalType, other.nominalType));
boolean isLoose = obj1.isLoose && obj2.isLoose || fn != null && fn.isLoose();
if (this.nominalType != null) {
return this.nominalType.getProp(pname);
if (this.commonTypes.getObjectType() != null) {
return this.commonTypes.getObjectType().getProp(pname);
return null;
return this.nominalType.appendTo(builder);
private final Map<InputId, CompilerInput> inputsById = new ConcurrentHashMap<>();
private Map<String, List<Comment>> commentsPerFile = new ConcurrentHashMap<>();
private volatile Config parserConfig = null;
this.errorManager = new ThreadSafeDelegatingErrorManager(errorManager);
this.commentsPerFile = new ConcurrentHashMap<>(inputs.size());
inputsById.clear();
if (options.numParallelThreads > 1) {
new PrebuildAst(this, options.numParallelThreads).prebuild(inputs);
synchronized (this) {
if (parserConfig == null) {
Config.LanguageMode configLanguageMode = getParserConfigLanguageMode(
options.getLanguageIn());
Config.StrictMode strictMode =
expectStrictModeInput() ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY;
parserConfig = createConfig(configLanguageMode, strictMode);
externsParserConfig =
configLanguageMode.equals(Config.LanguageMode.ECMASCRIPT3)
? createConfig(Config.LanguageMode.ECMASCRIPT5, strictMode)
: parserConfig;
initOptions(new CompilerOptions());
int numParallelThreads = 1;
public void setNumParallelThreads(int parallelism) {
numParallelThreads = parallelism;
package com.google.javascript.jscomp;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
class PrebuildAst {
private final AbstractCompiler compiler;
private final int numParallelThreads;
PrebuildAst(AbstractCompiler compiler, int numParalleThreads) {
this.compiler = compiler;
this.numParallelThreads = numParalleThreads;
void prebuild(List<CompilerInput> inputList) {
ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(
numParallelThreads,
numParallelThreads,
Integer.MAX_VALUE,
TimeUnit.SECONDS,
new LinkedBlockingQueue<Runnable>());
ListeningExecutorService executorService = MoreExecutors.listeningDecorator(poolExecutor);
List<ListenableFuture<?>> futureList = new ArrayList<>(inputList.size());
for (final CompilerInput input : inputList) {
futureList.add(executorService.submit(new Runnable() {
public void run() {
input.getAstRoot(compiler);
poolExecutor.shutdown();
try {
Futures.allAsList(futureList).get();
throw new RuntimeException(e);
package com.google.javascript.jscomp;
public class ThreadSafeDelegatingErrorManager implements ErrorManager {
private final ErrorManager delegated;
public ThreadSafeDelegatingErrorManager(ErrorManager delegated) {
this.delegated = delegated;
public synchronized void report(CheckLevel level, JSError error) {
delegated.report(level, error);
public synchronized void generateReport() {
delegated.generateReport();
public synchronized int getErrorCount() {
return delegated.getErrorCount();
public synchronized int getWarningCount() {
return delegated.getWarningCount();
public synchronized JSError[] getErrors() {
return delegated.getErrors();
public synchronized JSError[] getWarnings() {
return delegated.getWarnings();
public synchronized void setTypedPercent(double typedPercent) {
delegated.setTypedPercent(typedPercent);
public synchronized double getTypedPercent() {
return delegated.getTypedPercent();
package com.google.javascript.jscomp;
import java.util.List;
class PrebuildAst {
PrebuildAst(AbstractCompiler compiler, int numParalleThreads) {
void prebuild(List<CompilerInput> inputList) {}
&& (filename.contains("synthetic:es6/weakmap")
NominalType tmp = NominalType.pickSuperclass(n1, n2);
static NominalType pickSuperclass(NominalType c1, NominalType c2) {
return c2.instantiateGenericsWithUnknown();
return c1.instantiateGenericsWithUnknown();
NominalType nominal = NominalType.pickSuperclass(nt1, nt2);
"Index out of bounds in templateTypeOf: {0} > {1}");
if (index > templateTypes.size()) {
"Index out of bounds in templateTypeOf: 2 > 1");
reportLineCut(lineIndex, prevCutPosition + 1, false);
void generateSourceMap(SourceMap map){
map.addMapping(mapping.node, mapping.start, mapping.end);
mcp.generateSourceMap(sourceMap);
builder.addOptFormal(JSType.join(
this.commonTypes.getArrayInstance(), this.commonTypes.getArgumentsArrayType()));
private static final Pattern MSG_EXTERNAL_PATTERN =
Pattern.compile("MSG_EXTERNAL_(\\d+)");
Pattern.compile("MSG_UNNAMED_\\d+");
extractMessagesSafely("var MSG_UNNAMED_2 = goog.getMsg('Hullo');");
public void testMessageIsNoUnnamed() {
extractMessagesSafely("var MSG_UNNAMED_ITEM = goog.getMsg('Hullo');");
assertThat(messages).hasSize(1);
JsMessage msg = messages.get(0);
assertEquals("MSG_UNNAMED_ITEM", msg.getKey());
assertFalse(msg.isHidden());
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.SetMultimap;
private final Multimap<Node, FunctionInformation> functionSideEffectMap;
private final Map<String, FunctionInformation> functionInfoByName = new HashMap<>();
private final LinkedDirectedGraph<FunctionInformation, CallSitePropagationInfo> sideEffectGraph =
LinkedDirectedGraph.createWithoutAnnotations();
this.functionSideEffectMap = ArrayListMultimap.create();
buildGraph();
for (Node call : allFunctionCalls) {
sb.append("  ");
Iterable<Node> expanded = unwrapCallableExpression(call.getFirstChild());
if (expanded != null) {
for (Node comp : expanded) {
String name = NameBasedDefinitionProvider.getSimplifiedName(comp);
sb.append(name).append("|");
sb.append("<cant expand>");
sb.append(" ")
.append(new Node.SideEffectFlags(call.getSideEffectFlags()))
.append(" from: ")
.append(call.getSourceFileName())
private List<FunctionInformation> getSideEffectsForCall(Node call) {
results.addAll(Preconditions.checkNotNull(functionSideEffectMap.get(expression)));
continue;
if (name != null && functionInfoByName.containsKey(name)) {
results.add(functionInfoByName.get(name));
return null;
private void buildGraph() {
final FunctionInformation unknownDefinitionFunction = new FunctionInformation();
unknownDefinitionFunction.setTaintsGlobalState();
unknownDefinitionFunction.setFunctionThrows();
unknownDefinitionFunction.setTaintsReturn();
unknownDefinitionFunction.graphNode = sideEffectGraph.createNode(unknownDefinitionFunction);
for (DefinitionSite site : definitionProvider.getDefinitionSites()) {
Definition definition = site.definition;
if (definition.getLValue() != null) {
Node getOrName = definition.getLValue();
Preconditions.checkArgument(getOrName.isGetProp() || getOrName.isName(), getOrName);
String name = NameBasedDefinitionProvider.getSimplifiedName(getOrName);
Preconditions.checkNotNull(name);
if (isSupportedFunctionDefinition(definition.getRValue())) {
addSupportedDefinition(site, name);
if (functionInfoByName.containsKey(name)) {
functionInfoByName.get(name).setTaintsGlobalState();
functionInfoByName.get(name).setFunctionThrows();
functionInfoByName.get(name).setTaintsReturn();
functionInfoByName.put(name, unknownDefinitionFunction);
private void addSupportedDefinition(DefinitionSite definitionSite, String name) {
for (Node function : unwrapCallableExpression(definitionSite.definition.getRValue())) {
FunctionInformation functionInfo;
if (functionInfoByName.containsKey(name)) {
functionInfo = functionInfoByName.get(name);
functionInfo = new FunctionInformation();
functionInfo.graphNode = sideEffectGraph.createNode(functionInfo);
functionInfoByName.put(name, functionInfo);
functionSideEffectMap.put(function, functionInfo);
if (definitionSite.inExterns) {
functionInfo.updateSideEffectsFromExtern(function, compiler);
private void propagateSideEffects() {
List<FunctionInformation> possibleSideEffects = getSideEffectsForCall(callNode);
private final SetMultimap<Node, Var> blacklistedVarsByFunction = HashMultimap.create();
private final SetMultimap<Node, Var> taintedVarsByFunction = HashMultimap.create();
private void resetFunctionVars(Node function) {
blacklistedVarsByFunction.replaceValues(function, Collections.<Var>emptySet());
taintedVarsByFunction.replaceValues(function, Collections.<Var>emptySet());
if (!functionSideEffectMap.containsKey(node)) {
FunctionInformation functionInfo = new FunctionInformation();
functionSideEffectMap.put(node, functionInfo);
functionInfo.graphNode = sideEffectGraph.createNode(functionInfo);
for (FunctionInformation sideEffectInfo : functionSideEffectMap.get(enclosingFunction)) {
Preconditions.checkNotNull(sideEffectInfo);
updateSideEffectsForNode(sideEffectInfo, traversal, node, enclosingFunction);
public void updateSideEffectsForNode(
FunctionInformation sideEffectInfo,
NodeTraversal traversal,
Node node,
Node enclosingFunction) {
visitAssignmentOrUnaryOperator(
sideEffectInfo, traversal.getScope(), node, enclosingFunction);
Preconditions.checkArgument(NodeUtil.isNameDeclaration(node.getParent()));
blacklistedVarsByFunction.put(enclosingFunction, var);
for (FunctionInformation sideEffectInfo : functionSideEffectMap.get(function)) {
Preconditions.checkNotNull(sideEffectInfo, "%s has no side effect info.", function);
if (sideEffectInfo.mutatesGlobalState()) {
resetFunctionVars(function);
return;
for (Var v : t.getScope().getVarIterable()) {
boolean param = v.getParentNode().isParamList();
if (param
&& !blacklistedVarsByFunction.containsEntry(function, v)
&& taintedVarsByFunction.containsEntry(function, v)) {
sideEffectInfo.setTaintsArguments();
continue;
boolean localVar = false;
if (v.getParentNode().isVar()) {
localVar = true;
if (!localVar || blacklistedVarsByFunction.containsEntry(function, v)) {
if (taintedVarsByFunction.containsEntry(function, v)) {
sideEffectInfo.setTaintsGlobalState();
resetFunctionVars(function);
break;
resetFunctionVars(function);
FunctionInformation sideEffectInfo, Scope scope, Node op, Node enclosingFunction) {
Preconditions.checkState(NodeUtil.isAssignmentOp(op) || isIncDec(op) || op.isDelProp());
if (rhs != null && op.isAssign() && !NodeUtil.evaluatesToLocalValue(rhs)) {
blacklistedVarsByFunction.put(enclosingFunction, var);
taintedVarsByFunction.put(enclosingFunction, var);
List<FunctionInformation> possibleSideEffects = getSideEffectsForCall(node);
if (possibleSideEffects == null) {
sideEffectInfo.setTaintsGlobalState();
sideEffectInfo.setFunctionThrows();
return;
for (FunctionInformation sideEffectNode : possibleSideEffects) {
CallSitePropagationInfo edge = CallSitePropagationInfo.computePropagationType(node);
sideEffectGraph.connect(sideEffectNode.graphNode, edge, sideEffectInfo.graphNode);
private static final int FUNCTION_THROWS_MASK = 1 << 1;
private static final int TAINTS_GLOBAL_STATE_MASK = 1 << 2;
private static final int TAINTS_THIS_MASK = 1 << 3;
private static final int TAINTS_ARGUMENTS_MASK = 1 << 4;
private static final int TAINTS_RETURN_MASK = 1 << 5;
if (mutatesArguments()) {
status.add("args");
private void updateSideEffectsFromExtern(Node externFunction, AbstractCompiler compiler) {
Preconditions.checkArgument(externFunction.isFunction());
Preconditions.checkArgument(externFunction.isFromExterns());
JSDocInfo info = NodeUtil.getBestJSDocInfo(externFunction);
JSType jstype = externFunction.getJSType();
FunctionType functionType = JSType.toMaybeFunctionType(jstype);
if (functionType != null) {
JSType jstypeReturn = functionType.getReturnType();
if (!PureFunctionIdentifier.isLocalValueType(jstypeReturn, compiler)) {
setTaintsReturn();
if (info == null) {
setTaintsGlobalState();
setFunctionThrows();
if (info.modifiesThis()) {
setTaintsThis();
setTaintsArguments();
setFunctionThrows();
setTaintsGlobalState();
private static boolean isLocalValueType(JSType jstype, AbstractCompiler compiler) {
Preconditions.checkNotNull(jstype);
JSType subtype =
jstype.getGreatestSubtype(
(JSType) compiler.getTypeIRegistry().getNativeType(JSTypeNative.OBJECT_TYPE));
return subtype.isNoType();
return cache.getUnchecked(new Key(path, code));
if (returnTypeInferred) {
hashCode += 1;
if (paramType != null) {
hashCode += paramType.hashCode();
if (isConstructor()) {
if (that.isConstructor()) {
return this == that;
if (isInterface()) {
if (that.isInterface()) {
return false;
if (that.isInterface()) {
return false;
return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod, eqCache) &&
call.checkArrowEquivalenceHelper(that.call, eqMethod, eqCache);
return isInterface() ? getReferenceName().hashCode() : call.hashCode();
return list.isEmpty() ? null : list;
public void testInterface_noDirectImplementors() {
String js = ""
+ "/** @interface */\n"
+ "function I() {}\n"
+ "I.prototype.a;\n"
+ "I.prototype.b;\n"
+ "/** @interface @extends {I} */\n"
+ "function J() {}\n"
+ "/** @constructor @implements {J} */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.a;\n"
+ "Foo.prototype.b;\n"
+ "function f(/** !I */ x) {\n"
+ "  return x.a;\n"
+ "}\n"
+ "/** @interface */\n"
+ "function Z() {}\n"
+ "Z.prototype.a;\n"
+ "Z.prototype.b;";
String output = ""
+ "/** @interface */\n"
+ "function I() {}\n"
+ "I.prototype.Foo_prototype$a;\n"
+ "I.prototype.Foo_prototype$b;\n"
+ "/** @interface @extends {I} */\n"
+ "function J() {}\n"
+ "/** @constructor @implements {J} */\n"
+ "function Foo() {}\n"
+ "Foo.prototype.Foo_prototype$a;\n"
+ "Foo.prototype.Foo_prototype$b;\n"
+ "function f(/** !I */ x){\n"
+ "  return x.Foo_prototype$a;\n"
+ "}\n"
+ "/** @interface */\n"
+ "function Z() {}\n"
+ "Z.prototype.Z_prototype$a;\n"
+ "Z.prototype.Z_prototype$b";
testSets(
js,
output,
"{a=[[Foo.prototype, I.prototype], [Z.prototype]],"
+ " b=[[Foo.prototype, I.prototype], [Z.prototype]]}");
return list;
this.nameDefinitionMultimap.remove(name, node);
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.IR;
import com.google.javascript.rhino.Node;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
public class ConvertIIFEArgsToVars implements CompilerPass, NodeTraversal.Callback {
private final AbstractCompiler compiler;
private final Set<Node> iifeCallsWithArgsToRemove = new HashSet<>();
public ConvertIIFEArgsToVars(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
NodeTraversal.traverseEs6(compiler, root, this);
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
return true;
public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isCall() && this.iifeCallsWithArgsToRemove.contains(n)) {
this.iifeCallsWithArgsToRemove.remove(n);
Node removeRef;
if (n.getBooleanProp(Node.FREE_CALL)) {
removeRef = n.getFirstChild();
removeRef = n.getSecondChild();
while (removeRef.getNext() != null) {
n.removeChildAfter(removeRef);
return;
if (!n.isFunction() || parent == null) {
return;
Node call;
Node grandparent = parent.getParent();
if (parent.isCall() && parent.getFirstChild() == n) {
call = parent;
&& parent.getFirstChild() == n
&& n.getNext() != null
&& n.getNext().isString()
&& n.getNext().getString().equals("call")
&& grandparent != null
&& grandparent.isCall()
&& grandparent.getFirstChild() == parent) {
call = grandparent;
return;
Node funcParams = NodeUtil.getFunctionParameters(n);
if (!funcParams.hasChildren() || NodeUtil.isVarArgsFunction(n)) {
return;
Node param = funcParams.getFirstChild();
List<Node> newVars = new ArrayList<>();
while (param != null) {
newVars.add(
IR.var(param.cloneNode(), getCallArgument(param, call)).useSourceInfoFromForTree(param));
param = param.getNext();
funcParams.removeChildren();
for (int i = newVars.size() - 1; i >= 0; i--) {
funcParams.getNext().addChildToFront(newVars.get(i));
this.iifeCallsWithArgsToRemove.add(call);
compiler.reportCodeChange();
public Node getCallArgument(Node param, Node call) {
Preconditions.checkState(param.isName());
Preconditions.checkState(param.getParent() != null && param.getParent().isParamList());
Preconditions.checkState(call != null && call.isCall());
int argIndex = param.getParent().getIndexOfChild(param);
Node callArg = call.getSecondChild();
if (!call.getBooleanProp(Node.FREE_CALL)) {
callArg = callArg.getNext();
for (int i = 0; i < argIndex && callArg != null; i++) {
callArg = callArg.getNext();
if (callArg == null) {
return NodeUtil.newName(compiler, "undefined", param, param.getString());
return callArg.cloneTree();
if (options.optimizeCalls) {
passes.add(convertIIFEArgsToVars);
private final PassFactory convertIIFEArgsToVars =
new PassFactory("convertIIFEArgsToVars", true) {
protected CompilerPass create(AbstractCompiler compiler) {
return new ConvertIIFEArgsToVars(compiler);
package com.google.javascript.jscomp;
public final class ConvertIIFEArgsToVarsTest extends CompilerTestCase {
public CompilerPass getProcessor(Compiler compiler) {
return new ConvertIIFEArgsToVars(compiler);
public void setUp() {
enableNormalize();
public void testBasic() {
test(
"var a = 1; var b = 2; (function(c, d) { console.log(c, d); })(a, b);",
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function() {",
"  var c = a;",
"  var d = b;",
"  console.log(c, d);",
"})()"));
public void testExplicitThis() {
test(
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function(c, d) {",
"  console.log(c, d);",
"}).call(null, a, b)"),
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function() {",
"  var c = a;",
"  var d = b;",
"  console.log(c, d);",
"}).call(null)"));
public void testNested() {
test(
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function(c, d) {",
"  (function(e, f) {",
"    console.log(e, f);",
"  })(c, d);",
"}).call(null, a, b);"),
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function() {",
"  var c = a;",
"  var d = b;",
"  (function() {",
"    var e = c;",
"    var f = d;",
"    console.log(e, f);",
"  })();",
"}).call(null)"));
public void testArgumentsReference() {
testSame(
LINE_JOINER.join(
"var a = 1;",
"var b = 2;",
"(function(c, d) {",
"  var len = arguments.length;",
"  console.log(c, d, len);",
"}).call(null, a, b);"));
public void testUndefinedAlias() {
test(
"(function(c, d) { console.log(c, d); })();",
LINE_JOINER.join(
"(function() {",
"  var c = undefined;",
"  var d = undefined;",
"  console.log(c, d);",
"})();"));
public void testMoreArgsThanParams() {
test(
"(function(c, d) { console.log(c, d); })(1, 2, 3);",
"(function() { var c = 1; var d = 2; console.log(c, d); })();");
public void testParamsSameNameAsArgs() {
test(
"var c = 1; var d = 2; (function(c, d) { console.log(c, d); })(c, d);",
LINE_JOINER.join(
"var c = 1;",
"var d = 2;",
"(function() {",
"  var c$jscomp$1 = c;",
"  var d$jscomp$1 = d;",
"  console.log(c$jscomp$1, d$jscomp$1);",
"})();"));
public void testExprResult() {
test(
LINE_JOINER.join(
"var foo = 4;",
"var bar = {};",
"bar.baz = (function(bar) {",
"  return bar + 2;",
"})(foo);"),
LINE_JOINER.join(
"var foo = 4;",
"var bar = {};",
"bar.baz = (function() {",
"  var bar = foo;",
"  return bar + 2;",
"})();"));
public void testPreventAccidentalVariableCapture() {
test(
"var a = 1; (function(c) { var a = 2; console.log(c); })(a)",
LINE_JOINER.join(
"var a = 1;",
"(function() {",
" var c = a;",
" var a$jscomp$1 = 2;",
" console.log(c);",
"})()"));
test(
"var a = 1; (function(f) { var a = 2; })(function() { return a; });",
"var a = 1; (function() { var f=function() { return a; }; var a$jscomp$1 = 2; })();");
public void testRewriteFunctionArgument() {
test(
"(function(f) {})(function() {});",
"(function() { var f=function() {}; })();");
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR,
static final DiagnosticType STRUCTDICT_WITHOUT_CTOR = DiagnosticType.warning(
"JSC_NTI_STRUCTDICT_WITHOUT_CTOR",
"{0} used without @constructor.");
STRUCTDICT_WITHOUT_CTOR,
if (fnDoc.usesImplicitMatch()) {
commonTypes, defSite, qname, typeParameters);
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeStructClass(
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeDictClass(
commonTypes, defSite, qname, typeParameters);
rawType = RawNominalType.makeUnrestrictedClass(
commonTypes, defSite, qname, typeParameters);
warnings.add(JSError.make(defSite, STRUCTDICT_WITHOUT_CTOR, "@struct"));
warnings.add(JSError.make(defSite, STRUCTDICT_WITHOUT_CTOR, "@dict"));
class ObjectKind {
static final ObjectKind UNRESTRICTED = new ObjectKind(UNRESTRICTED_MASK);
static final ObjectKind STRUCT = new ObjectKind(STRUCT_MASK);
static final ObjectKind DICT = new ObjectKind(DICT_MASK);
public static RawNominalType makeUnrestrictedClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.UNRESTRICTED);
public static RawNominalType makeStructClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.STRUCT);
public static RawNominalType makeDictClass(JSTypes commonTypes,
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.CLASS, ObjectKind.DICT);
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.INTERFACE, ObjectKind.UNRESTRICTED);
Node defSite, String name, ImmutableList<String> typeParameters) {
return new RawNominalType(commonTypes, defSite,
name, typeParameters, Kind.RECORD, ObjectKind.UNRESTRICTED);
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
if (obj1.isTopObject() || obj2.isTopObject()) {
switch (options.getLanguageIn()) {
case ECMASCRIPT3:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT3, Config.StrictMode.SLOPPY);
externsParserConfig =
createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.SLOPPY);
break;
case ECMASCRIPT5:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.SLOPPY);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT5_STRICT:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT5, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT6, Config.StrictMode.SLOPPY);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6_STRICT:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT6, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT6_TYPED:
parserConfig =
createConfig(Config.LanguageMode.TYPESCRIPT, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT7:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT7, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
case ECMASCRIPT8:
parserConfig = createConfig(Config.LanguageMode.ECMASCRIPT8, Config.StrictMode.STRICT);
externsParserConfig = parserConfig;
break;
default:
throw new IllegalStateException("unexpected language mode: "
+ options.getLanguageIn());
Preconditions.checkArgument(declNode.isGetProp() || declNode.isStringKey());
"Invalid name. Did you mean to use NodeUtil.newQName?");
output.append("$wnd=this;typeof gwtOnLoad==='function'&&gwtOnLoad()})();");
String parent = outputFile.getParent();
if (parent != null) {
exPath = parent + File.separatorChar + exPath;
private boolean printSourceAfterEachPass = false;
usage = "Create an externs file from @export annotations, and store it in the specified "
+ "output file.")
private String createExternsFromExports;
options.setExternExportsPath(flags.createExternsFromExports);
private List<Export> exports;
case SCRIPT:
sortAndProcessExports();
break;
private void sortAndProcessExports() {
Set<Export> sorted =
new TreeSet<>(new Comparator<Export>() {
public int compare(Export e1, Export e2) {
return e1.getExportedPath().compareTo(e2.getExportedPath());
sorted.addAll(exports);
for (Export export : sorted) {
export.generateExterns();
exports = new ArrayList<>();
import java.util.ArrayList;
public void testDependencyOrderingOfExterns() throws Exception {
compileAndCheck(ImmutableList.of(
Joiner.on("\n").join(
"goog.provide('ns.a');",
"goog.require('ns.b');",
"/**",
" * @param {ns.b} b",
" * @return {number}",
" */",
"ns.a = function(b) {",
"  return b.x + b.y.length;",
"};",
"goog.exportSymbol('ns.a', ns.a);"),
Joiner.on("\n").join(
"goog.provide('ns.b');",
"/** @constructor */",
"ns.b = function() {",
"  /** @type {number} */ this.x = 5;",
"  /** @type {string} */ this.y = 'foo';",
"};",
"goog.exportSymbol('ns.b', ns.b);"),
Joiner.on("\n").join(
"goog.provide('ns.c');",
"goog.require('ns.b');",
"/**",
" * @param {ns.b} b",
" * @return {string}",
" */",
"ns.c = function(b) {",
"  return 'b: {x: ' + b.x + ', y: \"' + b.y + '\"}';",
"};",
"goog.exportSymbol('ns.c', ns.c);")),
Joiner.on("\n").join(
"/**",
" @const",
" @suppress {const,duplicate}",
" */",
"var ns = {};",
"/**",
" * @constructor",
" */",
"ns.b = function() {",
"};",
"/**",
" * @param {(ns.b|null)} b",
" * @return {number}",
" */",
"ns.a = function(b) {",
"};",
"/**",
" * @param {(ns.b|null)} b",
" * @return {string}",
" */",
"ns.c = function(b) {",
"};",
""));
checkResult(result, expected);
private void compileAndCheck(List<String> jsList, String expected) {
Result result = compileAndExportExterns(jsList);
checkResult(result, expected);
private void checkResult(Result result, String expected) {
private Result compileAndExportExterns(List<String> jsList) {
return compileAndExportExterns(jsList, "");
private Result compileAndExportExterns(String js, String externs) {
List<String> jsList = ImmutableList.of(js);
return compileAndExportExterns(jsList, externs);
private Result compileAndExportExterns(List<String> jsList, String externs) {
options.setClosurePass(true);
options.getDependencyOptions().setDependencySorting(true);
List<SourceFile> inputs = new ArrayList<SourceFile>();
inputs.add(SourceFile.fromCode(
"goog",
+ "goog.exportProperty = function(a, b, c) {};"));
for (int i = 0; i < jsList.size(); ++i) {
String name = "source" + i;
String code = jsList.get(i);
inputs.add(SourceFile.fromCode(name, code));
inputs = ImmutableList.copyOf(inputs);
final CompilerOptions options;
exPath = outputFile.getParent() + File.separatorChar + exPath;
private boolean printSourceAfterEachPass = false;
private final List<Export> exports;
Set<Export> sorted =
new TreeSet<>(new Comparator<Export>() {
public int compare(Export e1, Export e2) {
return e1.getExportedPath().compareTo(e2.getExportedPath());
sorted.addAll(exports);
for (Export export : sorted) {
export.generateExterns();
import java.util.List;
private Result compileAndExportExterns(String js, String externs) {
List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(
"testcode",
+ "goog.exportProperty = function(a, b, c) {}; " + js));
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.ObjectType;
Preconditions.checkState(type instanceof ObjectType);
FunctionType owner = ((ObjectType) type).getOwnerFunction();
if (owner.isConstructor()) {
return owner.getInstanceType();
public abstract class JSType implements FunctionTypeI, ObjectTypeI {
return new FormalParameterListTree(getTreeLocation(start), ImmutableList.<ParseTree>of());
ParseTree result = new FormalParameterListTree(
getTreeLocation(start), ImmutableList.of(parseParameter(ParamContext.IMPLEMENTATION)));
return result;
if (left.type == ParseTreeType.FORMAL_PARAMETER_LIST) {
reportError("invalid paren expression");
public void testExpressionsThatLookLikeParameters() {
parseError("();", "invalid paren expression");
parseError("(...xs);", "invalid paren expression");
public void testArrowInvalid() {
String jsdocAsString = JSDocInfoPrinter.print(n.getJSDocInfo());
public static String print(JSDocInfo info) {
private static Node stripBang(Node typeNode) {
private static String buildAnnotationWithType(String annotation, JSTypeExpression type) {
private static String buildAnnotationWithType(String annotation, Node type) {
private static String buildParamType(String name, JSTypeExpression type) {
private static String typeNode(Node typeNode) {
private static void appendTypeNode(StringBuilder sb, Node typeNode) {
private static void appendFunctionNode(StringBuilder sb, Node function) {
add(JSDocInfoPrinter.print(assign.getJSDocInfo()));
add(JSDocInfoPrinter.print(n.getJSDocInfo()));
assertEquals("/** @const */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @constructor */ ", JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
assertEquals("/** */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @final */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @record */ ", JSDocInfoPrinter.print(info));
assertEquals("/**\n @template T,U\n */\n", JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
assertEquals("/**\n @param {number=} foo\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @param {...number} foo\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @param {...} foo\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @param foo\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/** @type {{foo:number}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {{foo}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {{foo,bar}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {{foo:number,bar}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {{foo,bar:number}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/**\n @return {(number|string)}\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @param {...number} foo\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/** @throws {*} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @typedef {?} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {void} */ ", JSDocInfoPrinter.print(info));
"/** @enum {{foo:number,bar:string}} */ ", JSDocInfoPrinter.print(info));
"/** @enum {{foo:(number|string)}} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {?Object} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {!Object} */ ", JSDocInfoPrinter.print(info));
"/** @type {!Array<(number|string)>} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** Array */ ", JSDocInfoPrinter.print(info));
"/** @type {!Set<(number|string)>} */ ", JSDocInfoPrinter.print(info));
"/** @type {!Map<!Foo,!Bar<(!Baz|string)>>} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** Map */ ", JSDocInfoPrinter.print(info));
assertEquals("/**\n @implements {Foo}\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @implements {Foo}\n */\n", JSDocInfoPrinter.print(info));
assertEquals("/**\n @extends {Foo}\n */\n", JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
assertEquals("/** @type {function()} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {function(foo,bar)} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {function(foo):number} */ ", JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
assertEquals("/** @type {function():void} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {function():number} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {function(string):number} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @type {function(this:foo):?} */ ", JSDocInfoPrinter.print(info));
assertEquals("/** @define {string} */ ", JSDocInfoPrinter.print(info));
JSDocInfoPrinter.print(info));
assertThat(JSDocInfoPrinter.print(info)).isEqualTo(output);
&& n.getTypeI().isSomeUnknownType()
return isUnknown();
if (templateType.isNoResolvedType()) {
return typeInJsdoc != null && previousType != null
&& typeInJsdoc.equals(previousType);
this.mode = TypeInferenceMode.OtiOnly;
TypeI type = getprop.getTypeIIfOld();
new FunctionNamespace(commonTypes, funQname.getQualifiedName(), s));
new FunctionNamespace(getCommonTypes(), varName, s));
new FunctionNamespace(getCommonTypes(), qname.toString(), s));
new NamespaceLit(getCommonTypes(), qnameNode.getQualifiedName()));
private EnumType(JSTypes commonTypes, String name,
super(commonTypes, name);
public static EnumType make(JSTypes commonTypes, String name,
return new EnumType(commonTypes, name, typeExpr, props);
JSTypes commonTypes, String name, DeclaredTypeRegistry scope) {
super(commonTypes, name);
protected Namespace(JSTypes commonTypes, String name) {
return Property.make(subns.namespaceType, subns.namespaceType);
public NamespaceLit(JSTypes commonTypes, String name) {
super(commonTypes, name);
private final Node defSite;
super(commonTypes, name);
this.defSite = defSite;
public Node getDefSite() {
return this.defSite;
this.mode = TypeInferenceMode.OtiOnly;
templateKeys = templateKeys == null ?
ImmutableList.<TemplateType>of() : templateKeys;
templateValues = templateValues == null ?
ImmutableList.<JSType>of() : templateValues;
return (templateKeys.isEmpty() && templateValues.isEmpty()) ?
emptyTemplateTypeMap :
new TemplateTypeMap(this, templateKeys, templateValues);
import java.util.HashSet;
primaryParent.collectPropertyNames(props);
p.collectPropertyNames(props);
import com.google.common.collect.Sets;
import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
Set<PropertyMap> identitySet = Sets.newIdentityHashSet();
collectPropertyNamesHelper(props, identitySet);
private void collectPropertyNamesHelper(
Set<String> props, Set<PropertyMap> cache) {
if (cache.contains(this)) {
return;
cache.add(this);
primaryParent.collectPropertyNamesHelper(props, cache);
p.collectPropertyNamesHelper(props, cache);
cache.remove(this);
public Iterable<ObjectType> getCtorExtendedInterfaces() {
return this.referencedObjType == null
? Collections.<ObjectType>emptyList()
: this.referencedObjType.getCtorExtendedInterfaces();
public void testPropInParentInterface1() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" * @template T",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection<?>}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
public void testPropInParentInterface2() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection<?>}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
public void testPropInParentInterface3() {
String js = LINE_JOINER.join(
"/** @interface */",
"function MyIterable() {}",
"MyIterable.prototype.iterator = function() {};",
"/**",
" * @interface",
" * @extends {MyIterable}",
" */",
"function MyCollection() {}",
"/**",
" * @constructor",
" * @implements {MyCollection}",
" */",
"function MyAbstractCollection() {}",
"/** @override */",
"MyAbstractCollection.prototype.iterator = function() {};");
testSets(js, js, "{iterator=[[MyAbstractCollection.prototype, MyIterable.prototype]]}");
testClosureTypes(
"Parse error. Cycle detected in inheritance chain of type F");
import java.io.Serializable;
primaryParent.collectPropertyNames(props);
p.collectPropertyNames(props);
testClosureTypesMultipleWarnings(
ImmutableList.of(
"extends loop involving F, "
+ "loop: F -> G -> F",
"extends loop involving G, "
+ "loop: G -> F -> G"));
return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isObject();
return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isNumberValueType();
return jsType == null || jsType.isUnknownType() || jsType.isNoType();
"var unknown = null;",
"Equality.$same(num, unknown);",
"Equality.$same(str, unknown);"));
if (recvType.isUnknown()
if (isBottom() || isUnknown()) {
"Can't getProp of type %s", this);
private PropertyDef getPropDefFromClass(
NominalType nominalType, String pname) {
jsdoc.getEnumParameterType(),
ImmutableSet.copyOf(propNames)));
rawType = RawNominalType.makeStructuralInterface(defSite, qname, typeParameters);
rawType = RawNominalType.makeNominalInterface(defSite, qname, typeParameters);
rawType = RawNominalType.makeStructClass(defSite, qname, typeParameters);
rawType = RawNominalType.makeDictClass(defSite, qname, typeParameters);
rawType = RawNominalType.makeUnrestrictedClass(defSite, qname, typeParameters);
new FunctionNamespace(funQname.getQualifiedName(), s));
for (Node objLitChild : getProp.getParent().getLastChild().children()) {
for (Node objLitChild : getProp.getParent().getLastChild().children()) {
this.localNamespaces.put(varName, new FunctionNamespace(varName, s));
new FunctionNamespace(qname.toString(), s));
addNamespace(qnameNode, new NamespaceLit(qnameNode.getQualifiedName()));
JSTypes commonTypes = getCommonTypes();
t = nslit.toJSType(commonTypes);
t = ns.toJSType(commonTypes);
&& parent.getFirstChild().getLastChild().getString().equals("prototype")
&& parent.getLastChild().isObjectLit();
private EnumType(
String name, JSTypeExpression typeExpr, Collection<String> props) {
this.name = name;
public static EnumType make(
String name, JSTypeExpression typeExpr, Collection<String> props) {
return new EnumType(name, typeExpr, props);
protected JSType computeJSType(JSTypes commonTypes) {
public FunctionNamespace(String name, DeclaredTypeRegistry scope) {
this.name = name;
protected JSType computeJSType(JSTypes commonTypes) {
commonTypes.getFunctionType(),
&& !this.nominalType.isSubtypeOf(other.nominalType)) {
Preconditions.checkState(this.typeParameters.isEmpty());
protected String name;
protected abstract JSType computeJSType(JSTypes commonTypes);
public final JSType toJSType(JSTypes commonTypes) {
ns.toJSType(commonTypes);
this.namespaceType = Preconditions.checkNotNull(computeJSType(commonTypes));
win.addProtoProperty(entry.getKey(), null, ns.toJSType(commonTypes), true);
public NamespaceLit(String name) {
this.name = name;
protected JSType computeJSType(JSTypes commonTypes) {
Node defSite, String name, ImmutableList<String> typeParameters,
Kind kind, ObjectKind objectKind) {
this.name = name;
public static RawNominalType makeUnrestrictedClass(
return new RawNominalType(
defSite, name, typeParameters, Kind.CLASS, ObjectKind.UNRESTRICTED);
public static RawNominalType makeStructClass(
return new RawNominalType(
defSite, name, typeParameters, Kind.CLASS, ObjectKind.STRUCT);
public static RawNominalType makeDictClass(
return new RawNominalType(
defSite, name, typeParameters, Kind.CLASS, ObjectKind.DICT);
public static RawNominalType makeNominalInterface(
return new RawNominalType(
defSite, name, typeParameters, Kind.INTERFACE, ObjectKind.STRUCT);
public static RawNominalType makeStructuralInterface(
return new RawNominalType(
defSite, name, typeParameters, Kind.RECORD, ObjectKind.STRUCT);
protected JSType computeJSType(JSTypes commonTypes) {
commonTypes.getFunctionType(), null, ctorFn,
this, ctorFn.isLoose(), ObjectKind.UNRESTRICTED));
GlobalTypeInfo.INVALID_PROP_OVERRIDE,
NewTypeInference.MISTYPED_ASSIGN_RHS);
return !jsType.isUnknownType() && jsType.isObject();
public class DeadPropertyAssignmentElimination extends AbstractPostOrderCallback
implements CompilerPass {
NodeTraversal.traverseEs6(compiler, root, this);
public void visit(NodeTraversal t, Node n, Node parent) {
if (!n.isFunction()) {
return;
Node body = NodeUtil.getFunctionBody(n);
if (!body.hasChildren() || NodeUtil.containsFunction(body)) {
return;
FindCandidateAssignmentTraversal traversal =
new FindCandidateAssignmentTraversal(NodeUtil.isConstructor(n));
NodeTraversal.traverseEs6(compiler, body, traversal);
for (Property property : traversal.propertyMap.values()) {
if (property.writes.size() <= 1) {
continue;
PeekingIterator<PropertyWrite> iter = Iterators.peekingIterator(property.writes.iterator());
while (iter.hasNext()) {
PropertyWrite propertyWrite = iter.next();
if (iter.hasNext() && propertyWrite.isSafeToRemove(iter.peek())) {
Node lhs = propertyWrite.assignedAt;
Node rhs = lhs.getNext();
Node assignNode = lhs.getParent();
rhs.detachFromParent();
assignNode.getParent().replaceChild(assignNode, rhs);
compiler.reportCodeChange();
FindCandidateAssignmentTraversal(boolean isConstructor) {
property.markChildrenRead();
nameProp.markChildrenRead();
declType.toString(), rhsPair.type.toString()));
declType.toString(), rhsPair.type.toString()));
"----------------------------------------------------------------");
"----------------------------------------------------------------"),
"----------------------------------------------------------------"),
return x == 0.0 && Math.copySign(1, x) == -1.0;
types.add(sym);
for (Symbol s : types) {
if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
liveness.markAllParametersEscaped();
public void testParameter4() {
add(JSDocInfoPrinter.print(n.getJSDocInfo()));
appendPathDefinition(pathPrefix, initializer);
private void appendPathDefinition(String path, Node initializer) {
externFunction.setJSType(exportedFunction.getJSType());
parts.add("@suppress {" + Joiner.on(',').join(suppressions) + "}");
Node rhs = n.getFirstChild().getLastChild();
add(getTypeAnnotation(rhs));
add(getTypeAnnotation(n.getFirstFirstChild()));
private static final Pattern GOOG_PROVIDE_REQUIRE_PATTERN = Pattern.compile(
"(?:^|;|=)\\s*goog\\.(provide|module|require|addDependency)\\s*\\((.*?)\\)");
codeChange.reset();
boolean lhsOfForInLoop =
(NodeUtil.isForIn(declNode.getParent())
&& declNode == declNode.getParent().getFirstChild())
|| (NodeUtil.isForIn(declNode.getGrandparent())
&& declNode
.getParent()
.getParent()
.getFirstChild()
.getFirstChild()
== declNode);
JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(existingInfo);
builder.recordConstancy();
JSDocInfo info = builder.build();
declaration.setJSDocInfo(info);
enableNormalize(true);
private boolean normalizeExpected = false;
enableNormalize(true);
protected void enableNormalize(boolean normalizeExpected) {
normalizeEnabled = true;
this.normalizeExpected = normalizeExpected;
if (normalizeEnabled && normalizeExpected && !compiler.hasErrors()) {
super.enableNormalize(true);
enableNormalize(true);
enableNormalize(true);
enableNormalize(true);
enableNormalize(true);
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ModificationVisitor;
import com.google.javascript.rhino.jstype.TemplateType;
import com.google.javascript.rhino.jstype.TemplateTypeMap;
if (restrictedReplacement.isTemplatizedType()
&& restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
return type;
return Objects.equals(instantiated.typeMap, other.typeMap);
boolean allowStdIn) throws FlagUsageException, IOException {
return createInputs(files, null /* jsonFiles */, allowStdIn);
List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
return createInputs(files, jsonFiles, false);
List<JsonFileSpec> jsonFiles, boolean allowStdIn)
throws FlagUsageException, IOException {
for (FlagEntry<JsSourceType> file : files) {
return createInputs(files, jsonFiles);
return createInputs(files, true);
return createInputs(externFiles, false);
List<String> specs, List<SourceFile> inputs)
boolean isFirstModule = true;
for (String spec : specs) {
String[] parts = spec.split(":");
if (parts.length < 2 || parts.length > 4) {
throw new FlagUsageException("Expected 2-4 colon-delimited parts in "
+ "module spec: " + spec);
String name = parts[0];
checkModuleName(name);
if (modulesByName.containsKey(name)) {
throw new FlagUsageException("Duplicate module name: " + name);
JSModule module = new JSModule(name);
if (parts.length > 2) {
String depList = parts[2];
if (depList.length() > 0) {
String[] deps = depList.split(",");
for (String dep : deps) {
JSModule other = modulesByName.get(dep);
if (other == null) {
throw new FlagUsageException("Module '" + name
+ "' depends on unknown module '" + dep
+ "'. Be sure to list modules in dependency order.");
module.addDependency(other);
int numJsFiles = -1;
try {
numJsFiles = Integer.parseInt(parts[1]);
numJsFiles = -1;
if (numJsFiles < 0) {
if (parts.length == 2 && "auto".equals(parts[1])) {
if (isFirstModule) {
numJsFilesExpected = -1;
throw new FlagUsageException("Invalid JS file count '" + parts[1]
+ "' for module: " + name + ". Only the first module may specify " +
"a size of 'auto' and it must have no dependencies.");
throw new FlagUsageException("Invalid JS file count '" + parts[1]
+ "' for module: " + name);
minJsFilesRequired += numJsFiles;
numJsFilesExpected += numJsFiles;
moduleNames.add(0, name);
modulesFileCountMap.put(name, numJsFiles);
modulesByName.put(name, module);
List<String> moduleSpecs = config.module;
boolean createCommonJsModules = false;
if (options.processCommonJSModules
&& (moduleSpecs.size() == 1 && "auto".equals(moduleSpecs.get(0)))) {
createCommonJsModules = true;
moduleSpecs.remove(0);
createSourceInputs(config.mixedJsSources, jsonFiles);
if (!moduleSpecs.isEmpty()) {
modules = createJsModules(moduleSpecs, inputs);
.isEqualTo("{m0}\n"
+ "i0\n"
+ "\n"
+ "{m1:m0}\n"
+ "i1\n"
+ "\n"
+ "{m2:m1}\n"
+ "i2\n"
+ "\n"
+ "{m3:m2}\n"
+ "i3\n");
.isEqualTo("{m0}\n"
+ "i0\n"
+ "\n"
+ "{m1:m0}\n"
+ "i1\n"
+ "\n"
+ "{m2:m0}\n"
+ "i2\n"
+ "\n"
+ "{m3:m0}\n"
+ "i3\n");
import com.google.common.base.Joiner;
private static final Joiner LINE_JOINER = Joiner.on('\n');
protected final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(
SourceFile.fromCode("externs",
"var arguments;\n"
+ "/** @constructor */ function Window() {}\n"
+ "/** @type {string} */ Window.prototype.name;\n"
+ "/** @type {string} */ Window.prototype.offsetWidth;\n"
+ "/** @type {Window} */ var window;\n"
+ "/** @nosideeffects */ function noSideEffects() {}\n"
+ "/** @constructor\n * @nosideeffects */ function Widget() {}\n"
+ "/** @modifies {this} */ Widget.prototype.go = function() {};\n"
+ "/** @return {string} */ var widgetToken = function() {};\n"
+ "function alert(message) {}"
+ "function Object() {}"
+ "Object.seal;"
+ "Object.defineProperties;"
+ "/**\n"
+ " * @param {...*} var_args\n"
+ " * @constructor\n"
+ " */\n"
+ "function Function(var_args) {}\n"
+ "/** @param {...*} var_args */\n"
+ "Function.prototype.call = function (var_args) {};\n"
+ "/** @constructor */\n"
+ "function Arguments() {}"));
assertEquals(warning, compiler.getErrors()[0].getType());
assertEquals(warning, compiler.getWarnings()[0].getType());
for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {
if ("*".equals(entry.groupName)) {
diagnosticGroups.setWarningLevel(options, groupName, entry.level);
diagnosticGroups.setWarningLevel(options, entry.groupName,
entry.level);
protected List<SourceFile> createInputs(List<String> files,
return createInputs(files, new ArrayList<String>() /* zips */, allowStdIn);
protected List<SourceFile> createInputs(List<String> files,
return createInputs(files, new ArrayList<String>() /* zips */, jsonFiles, false);
protected List<SourceFile> createInputs(List<String> files,
List<String> zips, boolean allowStdIn) throws FlagUsageException, IOException {
return createInputs(files, zips, null, allowStdIn);
protected List<SourceFile> createInputs(List<String> files,
List<String> zips, List<JsonFileSpec> jsonFiles, boolean allowStdIn)
for (String filename : files) {
if (!"-".equals(filename)) {
for (String zipName : zips) {
if (!"-".equals(zipName)) {
List<SourceFile> newFiles = SourceFile.fromZipFile(zipName, inputCharset);
inputs.addAll(newFiles);
private List<SourceFile> createSourceInputs(List<String> files, List<String> zips,
if (files.isEmpty() && zips.isEmpty() && jsonFiles == null) {
files = Collections.singletonList("-");
return createInputs(files, zips, true);
return createInputs(files, false);
List<String> jsFiles = config.js;
List<SourceFile> inputs = createSourceInputs(jsFiles, config.jsZip, jsonFiles);
private WarningGuardSpec warningGuards = null;
CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {
this.warningGuards = spec;
protected static class WarningGuardSpec {
private static class Entry {
private final CheckLevel level;
private final String groupName;
private Entry(CheckLevel level, String groupName) {
this.level = level;
this.groupName = groupName;
private final List<Entry> entries = new ArrayList<>();
protected void add(CheckLevel level, String groupName) {
entries.add(new Entry(level, groupName));
protected void clear() {
entries.clear();
private static class GuardLevel {
final String name;
final CheckLevel level;
GuardLevel(String name, CheckLevel level) {
this.name = name;
this.level = level;
private static List<GuardLevel> guardLevels =
Collections.synchronizedList(new ArrayList<CommandLineRunner.GuardLevel>());
super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR));
new WarningGuardSetter(setter, CheckLevel.WARNING));
super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF));
private static class WarningGuardSetter implements Setter<String> {
private final CheckLevel level;
private WarningGuardSetter(
Setter<? super String> proxy, CheckLevel level) {
this.level = level;
guardLevels.add(new GuardLevel(value, level));
public static WarningGuardSpec getWarningGuardSpec() {
WarningGuardSpec spec = new WarningGuardSpec();
for (GuardLevel guardLevel : guardLevels) {
spec.add(guardLevel.level, guardLevel.name);
return spec;
List<GuardLevel> previous = new ArrayList<>(Flags.guardLevels);
Flags.guardLevels.addAll(previous);
.setWarningGuardSpec(Flags.getWarningGuardSpec())
String zipFile1 = createZipFile(zip1Contents);
compileZipFiles("console.log(\"Hello World\");", zipFile1);
String zipFile1 = createZipFile(zip1Contents);
String zipFile2 = createZipFile(zip2Contents);
compileZipFiles(
String zipFile1 = createZipFile(zip1Contents);
compileZipFiles(
private String createZipFile(Map<String, String> entryContentsByName) throws IOException {
return tempZipFile.getAbsolutePath();
private void compileZipFiles(String expectedOutput, String... filenames)
for (String filename : filenames) {
args.add("--jszip=" + filename);
Preconditions.checkState(n.isGetProp());
Preconditions.checkState(n.isScript());
Preconditions.checkState(n.isGetProp());
Preconditions.checkState(n.isCall());
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE));
Preconditions.checkState(n.isBlock());
Preconditions.checkState(n.isFunction());
Preconditions.checkState(n.hasOneChild());
Preconditions.checkState(n.canCollapseUnannotatedChildNames());
Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
Preconditions.checkState(n.getParent().isAssign());
Preconditions.checkState(n.hasOneChild());
Preconditions.checkState(n.getChildCount() == 2);
Preconditions.checkState(n.hasOneChild());
if (nameNode.isName() && nameNode.hasChildren()
Preconditions.checkState(n.isName());
Preconditions.checkState(n.isGetProp() && parent.isAssign());
Preconditions.checkState(n.isName());
Preconditions.checkState(n.hasChildren(), "AST should be normalized");
Preconditions.checkState(n.getChildCount() == 3);
Preconditions.checkState(n.isFunction());
Preconditions.checkState(n.isFunction() || n.isClass());
Preconditions.checkState(n.isCall());
Preconditions.checkState(n.isNew());
Preconditions.checkState(n.isName());
Preconditions.checkState(n.isFunction());
Preconditions.checkState(n.hasOneChild());
Preconditions.checkState(n.isReturn()
|| n.isThrow());
Preconditions.checkState(n.isIf());
Preconditions.checkState(n.isTry());
Preconditions.checkState(n.getChildCount() == 2);
Preconditions.checkState(n.getChildCount() == 2);
Preconditions.checkState(n.hasOneChild());
Preconditions.checkState(n.isSwitch());
Preconditions.checkState(n.isSwitch());
Preconditions.checkState(n.isIf());
Preconditions.checkState(n.isHook());
Preconditions.checkState(n.isCall());
Preconditions.checkState(n.isCall());
Preconditions.checkState(n.isName());
Preconditions.checkState(n.isScript());
Preconditions.checkState(n.isGetProp());
Preconditions.checkState(n.getChildCount() == 3);
Preconditions.checkState(n.isFunction());
Preconditions.checkState(body.getNext() == null &&
body.isBlock());
Preconditions.checkState(n.isString() || n.isStringKey());
Preconditions.checkState(n.getChildCount() == 2);
Preconditions.checkState(n.getFirstChild().isName());
return;  // only one child to scan
Preconditions.checkState(n.isName());
Preconditions.checkState(n.isGetElem());
Preconditions.checkState(n.getType() == type);
Preconditions.checkState(n.isName() || n.isRest() || n.isStringKey());
Preconditions.checkState(n.getChildCount() == 3);
Preconditions.checkState(n.isCall());
Preconditions.checkState(n.getFirstChild().isBlock());
Preconditions.checkState(n.getParent().isGetProp());
if (!Objects.equals(t1.nominalType, t2.nominalType)) {
return makeObjectType(t1.nominalType, newProps, newFn,
import java.util.HashSet;
if (getReferenceName().equals(that.getReferenceName())) {
return true;
if (this.isStructuralInterface()
&& that.isStructuralInterface()) {
return checkStructuralInterfaceEquivalenceHelper(
that, eqMethod, eqCache);
return false;
boolean checkStructuralInterfaceEquivalenceHelper(
final JSType that, EquivalenceMethod eqMethod, EqCache eqCache) {
Preconditions.checkState(eqCache.isStructuralTyping());
Preconditions.checkState(this.isStructuralInterface());
Preconditions.checkState(that.isRecordType() || that.isFunctionType());
MatchStatus result = eqCache.checkCache(this, that);
if (result != null) {
return result.subtypeValue();
if (this.hasAnyTemplateTypes() || that.hasAnyTemplateTypes()) {
return false;
Map<String, JSType> thisPropList = getPropertyTypeMap(this);
Map<String, JSType> thatPropList = that.isRecordType()
? that.toMaybeRecordType().getOwnPropertyTypeMap()
: getPropertyTypeMap(that.toMaybeFunctionType());
if (thisPropList.size() != thatPropList.size()) {
eqCache.updateCache(this, that, MatchStatus.NOT_MATCH);
return false;
for (String propName : thisPropList.keySet()) {
JSType typeInInterface = thisPropList.get(propName);
JSType typeInFunction = thatPropList.get(propName);
if (typeInFunction == null
|| !typeInFunction.checkEquivalenceHelper(
typeInInterface, eqMethod, eqCache)) {
eqCache.updateCache(this, that, MatchStatus.NOT_MATCH);
return false;
eqCache.updateCache(this, that, MatchStatus.MATCH);
return true;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
return toMaybeRecordType().checkRecordEquivalenceHelper(
if (isNominalType() && that.isNominalType()) {
if (getConcreteNominalTypeName(this.toObjectType())
.equals(getConcreteNominalTypeName(that.toObjectType()))) {
return true;
FunctionType thatConstructor = that.toObjectType().getConstructor();
FunctionType thisConstructor = this.toObjectType().getConstructor();
return thisConstructor.checkStructuralInterfaceEquivalenceHelper(
thatConstructor, eqMethod, eqCache);
return checkObjectRecordEquivalenceHelper(that, eqMethod, eqCache);
private boolean checkObjectRecordEquivalenceHelper(final JSType that,
EquivalenceMethod eqMethod, EqCache eqCache) {
Preconditions.checkState((isInstanceType() && that.isRecordType())
|| (isRecordType() && that.isInstanceType()));
FunctionType constructor = isInstanceType() ?
toObjectType().getConstructor()
: that.toObjectType().getConstructor();
RecordType recordType = isRecordType() ? toMaybeRecordType()
: that.toMaybeRecordType();
return constructor.checkStructuralInterfaceEquivalenceHelper(
recordType, eqMethod, eqCache);
protected static boolean implicitMatch(JSType rightType, JSType leftType,
if (rightType.isUnionType() || leftType.isUnionType()) {
return false;
if (!rightType.isObject() || !leftType.isObject()) {
if (leftType.isTemplatizedType()) {
if (leftType.isStructuralInterface() && rightType.isFunctionType()) {
return checkConstructorImplicitMatch(rightType.toMaybeFunctionType(),
leftType.toMaybeFunctionType(), implicitImplCache);
if (leftType.isStructuralInterface() && rightType.isRecordType()) {
return checkObjectImplicitMatch(rightType.toMaybeObjectType(),
leftType.toMaybeFunctionType(), implicitImplCache);
FunctionType leftConstructor = leftType.toMaybeObjectType().getConstructor();
FunctionType rightConstructor = rightType.toMaybeObjectType().getConstructor();
if (leftConstructor == null || !leftConstructor.isStructuralInterface()) {
if (rightConstructor != null) {
return checkConstructorImplicitMatch(rightConstructor, leftConstructor,
implicitImplCache);
rightType.toMaybeObjectType(), leftConstructor, implicitImplCache);
ObjectType rightType, FunctionType leftType,
Preconditions.checkArgument(leftType.isStructuralInterface());
Map<String, JSType> leftPropList = getPropertyTypeMap(leftType);
Map<String, JSType> rightPropList = getPropertyTypeMap(rightType);
for (String propName : leftPropList.keySet()) {
JSType leftPropType = leftPropList.get(propName);
JSType rightPropType = rightPropList.get(propName);
if (rightPropType == null) {
return false;
if (!rightPropType.isSubtype(leftPropType, implicitImplCache)) {
return false;
return true;
protected static boolean checkConstructorImplicitMatch(FunctionType rightType,
FunctionType leftType,
ImplCache implicitImplCache) {
Preconditions.checkArgument(leftType.isStructuralInterface());
if (rightType.explicitlyImplOrExtInterface(leftType)) {
return true;
MatchStatus result = implicitImplCache.checkCache(rightType, leftType);
if (leftType.hasAnyTemplateTypes()) {
implicitImplCache.updateCache(leftType, rightType, MatchStatus.NOT_MATCH);
Map<String, JSType> interfacePropList = getPropertyTypeMap(leftType);
Map<String, JSType> functionPropList = getPropertyTypeMap(rightType);
for (String propName : interfacePropList.keySet()) {
JSType typeInInterface = interfacePropList.get(propName);
JSType typeInFunction = functionPropList.get(propName);
if (typeInFunction == null
|| !typeInFunction.isSubtype(typeInInterface, implicitImplCache)) {
implicitImplCache.updateCache(leftType, rightType, MatchStatus.NOT_MATCH);
return false;
implicitImplCache.updateCache(leftType, rightType, MatchStatus.MATCH);
protected static Map<String, JSType> getPropertyTypeMap(ObjectType type) {
if (type == null) { return ImmutableMap.of(); }
return type.getPropertyTypeMap();
void updateCache(JSType leftType,
JSType rightType, MatchStatus isMatch) {
this.matchCache.put(leftType, rightType, isMatch);
MatchStatus checkCache(JSType rightType, JSType leftType) {
if (this.matchCache.contains(leftType, rightType)) {
return this.matchCache.get(leftType, rightType);
this.updateCache(leftType, rightType, MatchStatus.PROCESSING);
import java.util.HashMap;
import java.util.Set;
boolean checkRecordEquivalenceHelper(RecordType otherRecord,
EquivalenceMethod eqMethod, EqCache eqCache) {
MatchStatus result = eqCache.checkCache(this, otherRecord);
if (result != null) {
return result.subtypeValue();
Set<String> keySet = getOwnPropertyNames();
Set<String> otherKeySet = otherRecord.getOwnPropertyNames();
if (!otherKeySet.equals(keySet)) {
return false;
for (String key : keySet) {
if (!otherRecord.getPropertyType(key).checkEquivalenceHelper(
getPropertyType(key), eqMethod, eqCache)) {
eqCache.updateCache(this, otherRecord, MatchStatus.NOT_MATCH);
return false;
eqCache.updateCache(this, otherRecord, MatchStatus.MATCH);
return true;
public Map<String, JSType> getOwnPropertyTypeMap() {
Map<String, JSType> propTypeMap = new HashMap<>();
for (String name : this.getOwnPropertyNames()) {
propTypeMap.put(name, this.getPropertyType(name));
return propTypeMap;
+ mainAsSource);
private final Multimap<String, Node> staticMethods = ArrayListMultimap.create();
private final Multimap<String, Node> staticProperties = ArrayListMultimap.create();
if (multiplyDefinedClasses.contains(superclassNameNode.getQualifiedName())) {
for (Node staticMethod : staticMethods.get(superclassNameNode.getQualifiedName())) {
copyStaticMethod(staticMethod, superclassNameNode, subclassNameNode, parent);
for (Node staticProperty : staticProperties.get(superclassNameNode.getQualifiedName())) {
Preconditions.checkState(staticProperty.isGetProp(), staticProperty);
String memberName = staticProperty.getLastChild().getString();
Node getprop = IR.getprop(subclassNameNode.cloneTree(), IR.string(memberName));
JSDocInfoBuilder info = JSDocInfoBuilder.maybeCopyFrom(staticProperty.getJSDocInfo());
JSTypeExpression unknown = new JSTypeExpression(new Node(Token.QMARK), "<synthetic>");
info.recordType(unknown); // In case there wasn't a type specified on the base class.
info.addSuppression("visibility");
getprop.setJSDocInfo(info.build());
Node declaration = IR.exprResult(getprop);
declaration.useSourceInfoIfMissingFromForTree(n);
parent.getParent().addChildAfter(declaration, parent);
staticProperties.put(subclassNameNode.getQualifiedName(), staticProperty);
compiler.reportCodeChange();
private void copyStaticMethod(
Node staticMember, Node superclassNameNode, Node subclassNameNode, Node insertionPoint) {
for (Node subclassMember : staticMethods.get(subclassNameNode.getQualifiedName())) {
staticMethods.put(subclassNameNode.getQualifiedName(), assign);
staticProperties.put(className, n);
if (classNames.contains(n.getLastChild().getQualifiedName())) {
staticMethods.putAll(maybeAlias, staticMethods.get(n.getLastChild().getQualifiedName()));
staticMethods.put(maybeClassName, n);
staticMethods.putAll(maybeAlias, staticMethods.get(maybeOriginalName));
test(
"Subclass.staticMethod = function() { return 5; };"),
"",
"/** @return {string} */",
"Example.staticMethod = function() { return ''; }",
"",
"",
"// This should be a type error, but currently we don't catch it.",
"Subclass.staticMethod = function() { return 5; };"));
null : objType.getTemplateTypeMap().getTemplateType(
paramTypeMap.getTemplateType(key),
argTypeMap.getTemplateType(key),
.getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()),
public JSType getTemplateType(TemplateType key) {
int index = getTemplateTypeIndex(key);
resolvedTemplateValues.get(index);
JSType replacement = replacements.getTemplateType(type);
builder.add(getTemplateTypeMap().getTemplateType(filledTemplateKey));
assertThat(resolve(te).getTemplateTypeMap().getTemplateType(key)).isEqualTo(expected);
assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(keyA));
assertEquals(STRING_TYPE, templateTypeMap.getTemplateType(keyB));
assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(unknownKey));
assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(keyA));
assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(keyB));
assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(unknownKey));
for (JSType templateValue : templateValues) {
Collections.sort(statEntries, new Comparator<Entry<String, Stats>>() {
public int compare(Entry<String, Stats> e1, Entry<String, Stats> e2) {
return (int) (e1.getValue().runtime - e2.getValue().runtime);
continue;
out.append("(0,eval(\"");
out.append("\"));");
assertThat(sb.toString()).isEqualTo("(0,eval(\"\\x22a string\\x22\"));");
.isEqualTo("(0,eval(\"\\x22a string\\x22\\n//# sourceURL\\x3dURL\\n\"));");
boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {
!thisParamType.checkEquivalenceHelper(
otherParamType, eqMethod)) {
return hasEqualParameters(that, eqMethod);
if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {
"/** @type {{x:number}} @suppress {duplicate} */ ns.x;",
"/** @type {{x:number}} @suppress {duplicate} */ ns.x;"),
"/** @type {{x:number}} @suppress {duplicate} */ ns.x;",
"/** @type {{x:string}} @suppress {duplicate} */ ns.x;"),
"/** @type {{x:number}} @suppress {duplicate} */ ns.x;",
"/** @type {{x:number, y:boolean}} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec3} @suppress {duplicate} */ ns.x;",
"/** @type {!rec4} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec3} @suppress {duplicate} */ ns.x;",
"/** @type {!rec4} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec3} @suppress {duplicate} */ ns.x;",
"/** @type {!rec4} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:number}} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:number}} @suppress {duplicate} */ ns.y;",
"/** @type {!rec} @suppress {duplicate} */ ns.y;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:string}} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:number}} @suppress {duplicate} */ ns.y;",
"/** @type {!rec} @suppress {duplicate} */ ns.y;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:string}} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:number}} @suppress {duplicate} */ ns.y;",
"/** @type {!rec} @suppress {duplicate} */ ns.y;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:I}} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:I<number>}} @suppress {duplicate} */ ns.x;"),
"/** @type {!rec} @suppress {duplicate} */ ns.x;",
"/** @type {{prop:I<string>}} @suppress {duplicate} */ ns.x;"),
"/** @type {rec<string>} @suppress {duplicate} */ ns.x;",
"/** @type {{value: string}} @suppress {duplicate} */ ns.x;"),
lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, meetType);
lhsPair = analyzeExprFwd(lhs, rhsPair.env, JSType.UNKNOWN, lhsType);
rhs, lhsPair.env, JSType.UNKNOWN, JSType.NULL_OR_UNDEF);
lhs, inEnv, JSType.UNKNOWN, JSType.NULL_OR_UNDEF);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, rhsType);
lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, lhsType);
rhsPair = analyzeExprFwd(rhs, lhsPair.env, JSType.UNKNOWN, rhsType);
lhsPair = analyzeExprFwd(lhs, inEnv, JSType.UNKNOWN, lhsType);
typeCheck(Joiner.on('\n').join(
"function f(/** (null | { prop: (null|number) }) */ x) {",
"  if (x.prop !== null) {",
"    return x.prop - 1;",
"  }",
"}"),
NewTypeInference.NULLABLE_DEREFERENCE);
String[] sources = (String[]) consumer.getOriginalSources().toArray();
assertThat(sources).hasLength(1);
assertThat(sources[0]).isEqualTo("testcode");
String[] sources = (String[]) consumer.getOriginalSources().toArray();
assertThat(sources).hasLength(1);
assertThat(sources[0]).isEqualTo("testcode");
sb.append("@param {");
appendTypeNode(sb, info.getParameterType(name).getRoot());
sb.append("} ");
if (lvalue.isQualifiedName()) {
name = namespace.getSlot(lvalue.getQualifiedName());
if (name != null && isInlinableGlobalAlias(name)) {
List<AstChange> newNodes = new ArrayList<>();
List<Ref> refs = new ArrayList<>(name.getRefs());
for (Ref ref : refs) {
switch (ref.type) {
case SET_FROM_GLOBAL:
continue;
case DIRECT_GET:
case ALIASING_GET:
Node newNode = alias.node.cloneTree();
Node node = ref.node;
node.getParent().replaceChild(node, newNode);
newNodes.add(new AstChange(ref.module, ref.scope, newNode));
name.removeRef(ref);
break;
default:
throw new IllegalStateException();
rewriteAliasProps(name, alias.node, 0, newNodes);
aliasParent.replaceChild(alias.node, IR.nullNode());
compiler.reportCodeChange();
namespace.scanNewNodes(newNodes);
return true;
Name name, Node value, int depth, List<AstChange> newNodes) {
if (name.props != null) {
Preconditions.checkState(!
value.matchesQualifiedName(name.getFullName()));
for (Name prop : name.props) {
rewriteAliasProps(prop, value, depth + 1, newNodes);
List<Ref> refs = new ArrayList<>(prop.getRefs());
for (Ref ref : refs) {
Node target = ref.node;
for (int i = 0; i <= depth; i++) {
if (target.isGetProp()) {
target = target.getFirstChild();
Node gparent = target.getParent().getParent();
if (gparent.isAssign()) {
target = gparent.getFirstChild();
Preconditions.checkState(NodeUtil.isObjectLitKey(gparent));
target = gparent;
throw new IllegalStateException("unexpected: " + target);
Preconditions.checkState(target.isGetProp() || target.isName());
target.getParent().replaceChild(target, value.cloneTree());
prop.removeRef(ref);
newNodes.add(new AstChange(ref.module, ref.scope, ref.node));
List<AstChange> newNodes = new ArrayList<>();
if (n.props != null) {
for (Name p : n.props) {
collapseDeclarationOfNameAndDescendants(
p, appendPropForAlias(alias, p.getBaseName()));
if (!p.inExterns && canCollapseChildNames &&
p.getDeclaration() != null &&
p.canCollapse() &&
p.getDeclaration().node != null &&
p.getDeclaration().node.getParent() != null &&
p.getDeclaration().node.getParent().isAssign()) {
updateSimpleDeclaration(
appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());
if (n.props != null) {
for (Name p : n.props) {
if (p.needsToBeStubbed()) {
String propAlias = appendPropForAlias(alias, p.getBaseName());
Node nameNode = IR.name(propAlias);
Node newVar = IR.var(nameNode)
.copyInformationFromForTree(addAfter);
parent.addChildAfter(newVar, addAfter);
addAfter = newVar;
numStubs++;
compiler.reportCodeChange();
if (p.getRefs().get(0).node.getLastChild().getBooleanProp(
Node.IS_CONSTANT_NAME)) {
nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
void scanNewNodes(List<AstChange> newNodes) {
public void testCrashInCommaOperator() {
public void testDontCrashAtComma() {
test(
"var ns = {};\n"
+ "ns.Foo = {};\n"
+ "var Baz = {};\n"
+ "Baz.Foo = ns.Foo;\n"
+ "(Baz.Foo.bar = 10, 123);",
"var Baz$Foo=null;\n"
+ "(ns$Foo$bar = 10, 123);");
private static final Joiner lineJoiner = Joiner.on("\n");
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
private static final String EXTERNS_WITH_IOBJECT_DECLS = lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
lineJoiner.join(
boolean isArrow = n.isArrowFunction();
boolean notSingleExpr = n.getParent() == null || !n.getParent().isExprResult();
boolean funcNeedsParens = (context == Context.START_OF_EXPR)
&& (!isArrow || notSingleExpr);
if (funcNeedsParens) {
add("(");
if (!isArrow) {
add("function");
if (n.isGeneratorFunction()) {
add("*");
if (!first.getString().isEmpty()) {
cc.maybeInsertSpace();
add(first);
maybeAddGenericTypes(first);
add(first.getNext()); // param list
maybeAddTypeDecl(n);
if (isArrow) {
cc.addOp("=>", true);
add(last, Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(")");
MEMBER_VARIABLE_DEF = 180,
import com.google.common.base.Joiner;
+ "  constructor: function(){\n"
+ "    this.foo = 1;\n"
+ "  },\n"
+ "  statics: function(cls) {\n"
+ "    cls.prop1 = 1;\n"
+ "    /** @const */\n"
+ "    cls.PROP2 = 2;\n"
+ "  },\n"
+ "  anotherProp: 1,\n"
+ "  aMethod: function() {}\n"
+ "});",
Joiner.on('\n').join(
test(Joiner.on('\n').join(
"/** @private */",
"x.y_ = goog.defineClass(null, {",
"  constructor: function() {}",
"});"),
test(Joiner.on('\n').join(
"/** @private */",
"x.y_ = goog.defineClass(null, {",
"  /** @param {string} s */",
"  constructor: function(s) {}",
"});"),
Joiner.on('\n').join(
"goog.loadModule(function(exports) {" +
"goog.module('ns.a');" +
"var b = goog.require('ns.b');" +
"return exports;});",
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
"goog.loadModule(function(exports) {" +
"goog.module('ns.a');" +
"var b = goog.require('ns.b');" +
"return exports;});" +
"goog.loadModule(function(exports) {" +
"goog.module('ns.c');" +
"var b = goog.require('ns.b');" +
"return exports;});",
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});" +
"goog.provide('ns.c');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('ns.a');" +
"goog.module.declareLegacyNamespace();" +
"var b = goog.require('ns.b');" +
"return exports;});",
"'use strict';" +
"goog.provide('ns.a');" +
"goog.require('ns.b');" +
"goog.scope(function(){" +
"  var b = ns.b;" +
"});");
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('ns.a');" +
"var b = goog.require('goog.asserts');" +
"return exports;});",
"'use strict';" +
"goog.provide('ns.a');" +
"goog.require('goog.asserts');" +
"goog.scope(function(){" +
"  var b = goog.asserts;" +
"});");
"goog.loadModule(function(exports) {'use strict';" +
"goog.module('xid');" +
"" +
"goog.module.declareLegacyNamespace();" +
"" +
"var asserts = goog.require('goog.asserts');" +
"" +
"exports = function(id) {" +
"  return xid.internal_(id);" +
"};" +
"var xid = exports;" +
"return exports;});",
"goog.provide('xid');" +
"goog.require('goog.asserts');" +
"goog.scope(function(){" +
"var asserts=goog.asserts;" +
"/** @const */ xid=function(id){return xid_module.internal_(id)};" +
"var xid_module=xid})");
assertNotNull("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()), root);
assertEquals("Unexpected parse warnings(s): " + Joiner.on("\n").join(compiler.getWarnings()),
0, compiler.getWarnings().length);
"Unexpected error(s): " + Joiner.on("\n").join(compiler.getErrors()),
0, compiler.getErrorCount());
assertEquals("Unexpected symbol table error(s): " +
Joiner.on("\n").join(stErrors),
0, stErrors.length);
"Unexpected warning(s): " + Joiner.on("\n").join(aggregateWarnings),
0, aggregateWarningCount);
assertEquals("There should be one warning, repeated " + numRepetitions
+ " time(s). Warnings: " + aggregateWarnings, numRepetitions, aggregateWarningCount);
fail("Unexpected changes to externs" +
"\nExpected: " + compiler.toSource(externsRootClone) +
"\nResult:   " + compiler.toSource(externsRoot) +
"\n" + explanation);
"compiler.reportCodeChange() was called " +
"even though nothing changed",
assertTrue("compiler.reportCodeChange() should have been called."
+ "\nOriginal: " + mainRootClone.toStringTree()
+ "\nNew: " + mainRoot.toStringTree(), hasCodeChanged);
"\nExpected: " + compiler.toSource(expectedRoot) +
"\nResult:   " + compiler.toSource(mainRoot) +
"\n" + explanation, explanation);
Node normalizeCheckExternsRootClone =
normalizeCheckRootClone.getFirstChild();
new PrepareAst(compiler).process(
normalizeCheckExternsRootClone, normalizeCheckMainRootClone);
String explanation =
normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
assertNull("Node structure normalization invalidated." +
"\nExpected: " +
compiler.toSource(normalizeCheckMainRootClone) +
"\nResult:   " + compiler.toSource(mainRoot) +
"\n" + explanation, explanation);
new Normalize(compiler, true).process(
normalizeCheckExternsRootClone, normalizeCheckMainRootClone);
explanation =  normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
assertNull("Normalization invalidated." +
"\nExpected: " +
compiler.toSource(normalizeCheckMainRootClone) +
"\nResult:   " + compiler.toSource(mainRoot) +
"\n" + explanation, explanation);
assertEquals("There should be one error. " + errors,
1, compiler.getErrorCount());
assertEquals("There should be one warning. " + warnings,
1, compiler.getWarningCount());
assertNotNull("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()), root);
private static String newlineJoin(String ... parts) {
return Joiner.on("\n").join(parts);
static final String INPUT = newlineJoin(
"/** @constructor */",
"function a(){ this.x = 3; }",
"/** @return {number} */",
"a.prototype.foo = function() {return this.x};",
"/** @param {number} p\n@return {number} */",
"a.prototype.bar = function(p) {return this.x};",
"a.prototype.baz = function() {};",
"var o = new a;",
"o.foo();",
"o.bar(2);",
"o.baz()");
static final String EXPECTED = newlineJoin(
"function a(){ this.x = 3; }",
"var JSCompiler_StaticMethods_foo = ",
"function(JSCompiler_StaticMethods_foo$self) {",
"  return JSCompiler_StaticMethods_foo$self.x",
"};",
"var JSCompiler_StaticMethods_bar = ",
"function(JSCompiler_StaticMethods_bar$self, p) {",
"  return JSCompiler_StaticMethods_bar$self.x",
"};",
"var JSCompiler_StaticMethods_baz = ",
"function(JSCompiler_StaticMethods_baz$self) {",
"};",
"var o = new a;",
"JSCompiler_StaticMethods_foo(o);",
"JSCompiler_StaticMethods_bar(o, 2);",
"JSCompiler_StaticMethods_baz(o)");
String source = newlineJoin(
"A.prototype.foo = function(){return this.b};",
"B.prototype.bar = function(){};",
"o.foo().bar()");
String expected = newlineJoin(
"var JSCompiler_StaticMethods_foo = ",
"function(JSCompiler_StaticMethods_foo$self) {",
"  return JSCompiler_StaticMethods_foo$self.b",
"};",
"var JSCompiler_StaticMethods_bar = ",
"function(JSCompiler_StaticMethods_bar$self) {",
"};",
"JSCompiler_StaticMethods_bar(JSCompiler_StaticMethods_foo(o))");
static final String INPUT = newlineJoin(
"function a(){}",
"a.prototype.foo = function() {return this.x};",
"var o = new a;",
"o.foo()");
String expected = newlineJoin(
"function a(){}",
"var JSCompiler_StaticMethods_foo = ",
"function(JSCompiler_StaticMethods_foo$self) {",
"  return JSCompiler_StaticMethods_foo$self.x",
"};",
"var o = new a;",
"JSCompiler_StaticMethods_foo(o);");
String source = newlineJoin(
"function a(){}",
"a.foo = function() {return this.x};",
"a.foo()");
String source = newlineJoin(
"function a(){}",
"a.prototype.foo = function(args) {return args};",
"var o = new a;",
"o.foo()");
String expected = newlineJoin(
"function a(){}",
"var JSCompiler_StaticMethods_foo = ",
"  function(JSCompiler_StaticMethods_foo$self, args) {return args};",
"var o = new a;",
"JSCompiler_StaticMethods_foo(o)");
String source = newlineJoin(
"function a(){}",
"a.prototype.foo = function(var_args) {return arguments};",
"var o = new a;",
"o.foo()");
static final String BASE = newlineJoin(
"function a(){}",
"a.prototype.foo = function() {return this.x};",
"var o = new a;");
String expected = newlineJoin(
"function a(){}",
"var JSCompiler_StaticMethods_foo = ",
"function(JSCompiler_StaticMethods_foo$self) {",
"  return JSCompiler_StaticMethods_foo$self.x",
"};",
"var o = new a;",
"JSCompiler_StaticMethods_foo(o);");
String source = newlineJoin(
"function a(){}",
"a.prototype.foo = function(args) {return args};",
"var o = new a;",
"o.foo()");
String expected = newlineJoin(
"function a(){}",
"var JSCompiler_StaticMethods_foo = ",
"  function(JSCompiler_StaticMethods_foo$self, args) {return args};",
"var o = new a;",
"JSCompiler_StaticMethods_foo(o)");
String source = newlineJoin(
"function a(){}",
"a.prototype['foo'] = function(args) {return args};",
"var o = new a;",
"o.foo()");
String source = newlineJoin(
"function a(){}",
"a.prototype.foo = function(args) {return args};",
"var o = new a;",
"o['foo']");
String source = newlineJoin(
"function a(){}",
"a.prototype['foo'] = function(args) {return args};",
"var o = new a;",
"o['foo']");
String source = newlineJoin(
"(function() {this.foo()}).prototype.foo = function() {extern();};");
String source = newlineJoin(
"function a(){}",
"a.prototype = {foo: function(args) {return args}};",
"var o = new a;",
"o.foo()");
String source = newlineJoin(
"function a(){}",
"a.prototype = {get foo(){return f}};",
"var o = new a;",
"o.foo()");
testSame(source);
String source = newlineJoin(
"function a(){}",
"a.prototype = {get foo(){return 1}};",
"var o = new a;",
"o.foo");
testSame(source);
String source = newlineJoin(
"function a(){}",
"a.prototype = {set foo(a){}};",
"var o = new a;",
"o.foo()");
String source = newlineJoin(
"function a(){}",
"a.prototype = {set foo(a){}};",
"var o = new a;",
"o.foo = 1");
testSame(newlineJoin("function a(){}",
"var o = new a;",
"o.foo()"));
import com.google.common.base.Joiner;
compiler.init(externsInputs,
asList(SourceFile.fromCode("expected", Joiner.on("\n").join(lines))),
.isEqualTo("'use strict';" + Joiner.on("\n").join(lines));
import com.google.common.base.Joiner;
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x; y++;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x$0; y++;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x;",
"  { let x; x++; }",
"  x++;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x$0;",
"  { let x; x++; }",
"  x$0++;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x; { x++ };",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { return x(); }())) {",
"  var x$0; { x$0++ };",
"}"
));
test(Joiner.on('\n').join(
"function f(a = x, b = y) {",
"  var y, x;",
"  return function() { var x = () => y };",
"}"
), Joiner.on('\n').join(
"function f(a = x, b = y) {",
"  var y$0, x$1;",
"  return function() { var x = () => y$0 };",
"}"
));
test(Joiner.on('\n').join(
"var x = 4;",
"function f(a=x) { let x = 5; { let x = 99; } return a + x; }"
), Joiner.on('\n').join(
"var x = 4;",
"function f(a=x) { let x$0 = 5; { let x = 99; } return a + x$0; }"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=x()) {",
"  x();",
"  function x() {}",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=x()) {",
"  x$0();",
"  function x$0() {}",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { w = 5; return w; }())) {",
"  let x = w;",
"  var w = 3;",
"  return w;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function y() { w = 5; return w; }())) {",
"  let x = w$0;",
"  var w$0 = 3;",
"  return w$0;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w;",
"  return w;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w;",
"  return w;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w;",
"  var w = 3;",
"  return w;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w$0;",
"  var w$0 = 3;",
"  return w$0;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w;",
"  let w = 3;",
"  return w;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"function f(y=(function () { w = 5; return w; }())) {",
"  w$0;",
"  let w$0 = 3;",
"  return w$0;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"var y = 1;",
"function f(z=x, w=y) {",
"  let x = y;",
"  var y = 3;",
"  return w;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"var y = 1;",
"function f(z=x, w=y) {",
"  let x$0 = y$1;",
"  var y$1 = 3;",
"  return w;",
"}"
));
test(Joiner.on('\n').join(
"function x() {}",
"var y = 1;",
"function f(z=x, w=y) {",
"  var x;",
"  { let y; y++; }",
"  { var y; y++; }",
"  x++;",
"}"
), Joiner.on('\n').join(
"function x() {}",
"var y = 1;",
"function f(z=x, w=y) {",
"  var x$0;",
"  { let y; y++; }",
"  { var y$1; y$1++; }",
"  x$0++;",
"}"
));
import com.google.common.base.Joiner;
test("function *f() {" + beforeBody + "}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
varDecls,
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
afterBody,
"    }",
"  }",
"  var iterator = {",
"    next: function(arg) { return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
rewriteGeneratorBody("", Joiner.on('\n').join(
"case 0:",
"  $jscomp$generator$state = -1;",
"default:",
"  return {value: undefined, done: true}"
));
rewriteGeneratorBody("yield 1;", Joiner.on('\n').join(
"case 0:",
"  $jscomp$generator$state = 1;",
"  return {value: 1, done: false};",
"case 1:",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    $jscomp$generator$state = 2; break;",
"  }",
"  $jscomp$generator$state = -1;",
"  throw $jscomp$generator$throw$arg;",
"case 2:",
"  $jscomp$generator$state = -1;",
"default:",
"  return {value: undefined, done: true}"
));
test("/** @param {*} a */ function *f(a, b) {}", Joiner.on('\n').join(
"/** @param {*} a @suppress {uselessCode} */",
"function f(a, b) {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
rewriteGeneratorBodyWithVars("var i = 0, j = 2",
Joiner.on('\n').join(
"case 0:",
"  i = 0;",
"  j = 2;",
"  $jscomp$generator$state = -1;",
"default:",
"  return {value: undefined, done: true}"
));
Joiner.on('\n').join(
"case 0:",
"  i = 0;",
"  $jscomp$generator$state = 1;",
"  return {value: i, done: false};",
"case 1:",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    $jscomp$generator$state = 2; break;",
"  }",
"  $jscomp$generator$state = -1;",
"  throw $jscomp$generator$throw$arg;",
"case 2:",
"  i = 1;",
"  $jscomp$generator$state = 3;",
"  return {value: i, done: false};",
"case 3:",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    $jscomp$generator$state = 4; break;",
"  }",
"  $jscomp$generator$state = -1;",
"  throw $jscomp$generator$throw$arg;",
"case 4:",
"  i = i + 1;",
"  $jscomp$generator$state = 5;",
"  return {value: i, done: false};",
"case 5:",
"  if (!($jscomp$generator$throw$arg !== undefined)) {",
"    $jscomp$generator$state = 6; break;",
"  }",
"  $jscomp$generator$state = -1;",
"  throw $jscomp$generator$throw$arg;",
"case 6:",
"  $jscomp$generator$state = -1;",
"default:",
"  return {value: undefined, done: true}"
));
test("function f() { return function *g() {yield 1;} }", Joiner.on('\n').join(
"function f() {",
"  return /** @suppress {uselessCode} */ function g() {",
"    var $jscomp$generator$state = 0;",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        $jscomp$generator$throw$arg) {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = 1;",
"          return {value: 1, done: false};",
"        case 1:",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 2; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        case 2:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {value: undefined, done: true}",
"      }",
"    }",
"    var iterator = {",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    };",
"    $jscomp.initSymbolIterator();",
"    iterator[Symbol.iterator] = function() { return this; };",
"    return iterator;",
"  }",
"}"
));
test("function *f() { function *g() {yield 2;} yield 1; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  /** @suppress {uselessCode} */",
"  function g() {",
"    var $jscomp$generator$state = 0;",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        $jscomp$generator$throw$arg) {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = 1;",
"           return {value: 2, done: false};",
"        case 1:",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 2; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        case 2:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {value: undefined, done: true}",
"      }",
"    }",
"    var iterator = {",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    }",
"    $jscomp.initSymbolIterator();",
"    iterator[Symbol.iterator] = function() { return this; };",
"    return iterator;",
"  }",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"         return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {var i = 0; for (var j = 0; j < 10; j++) { i += j; } yield i;}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */ function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        for (var j = 0; j < 10; j++) { i += j; }",
"        $jscomp$generator$state = 1;",
"        return {value: i, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"      case 2:",
"        j++",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
Joiner.on('\n').join(
"      case 0:",
"        i = 0;",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        i += j;",
"        $jscomp$generator$state = -1;",
"        throw 5;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = 4;",
"        return {value: i, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
test("function *f() {var i = 0; while (i < 10) { i++; i++; i++; } yield i;}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        while (i < 10) { i ++; i++; i++; }",
"        $jscomp$generator$state = 1;",
"        return {value: i, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { var j = 0; while (j < 10) { yield j; j++; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        j++",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"      }",
"    }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {throw 1;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        throw 1;",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { l: if (true) { break l; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        l: if (true) { break l; }",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { l: for (;;) { yield i; continue l; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"      case 1:",
"        if (!true) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: i, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { var j = 0; if (j < 1) { yield j; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"        if (!(j < 1)) { $jscomp$generator$state = 1; break; }",
"        $jscomp$generator$state = 2;",
"        return {value: j, done: false};",
"      case 2:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 3; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 3:",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f(i) { if (i < 1) { yield i; } else { yield 1; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f(i) {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        if (!(i < 1)) { $jscomp$generator$state = 1; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: i, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 5;",
"        return {value: 1, done: false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { return 1; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        return {value: 1, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { var j = 0; while (j < 10) { yield j; break; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 2;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { var j = 0; while (j < 10) { yield j; continue; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; break; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = 3;",
"        break;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; continue; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { do { yield j; } while (j < 10); }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$first$do;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$first$do = true;",
"      case 1:",
"        if (!($jscomp$generator$first$do || j < 10)) {",
"          $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"      case 2:",
"        $jscomp$generator$first$do = false;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { yield; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: undefined, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { return; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        return {value: undefined, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { return (yield 1); }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$next$arg0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$next$arg0 = $jscomp$generator$next$arg;",
"        $jscomp$generator$state = -1;",
"        return {value: $jscomp$generator$next$arg0, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { function g() {} }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function g() {}",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {yield * n;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$yield$entry;",
"  var $jscomp$generator$yield$all;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$yield$all = $jscomp.makeIterator(n);",
"      case 1:",
"        if (!!($jscomp$generator$yield$entry =",
"            $jscomp$generator$yield$all.next($jscomp$generator$next$arg)).done) {",
"          $jscomp$generator$state = 2;",
"          break;",
"        }",
"        $jscomp$generator$state = 3;",
"        return {value: $jscomp$generator$yield$entry.value, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
rewriteGeneratorBodyWithVars("var i = yield * n;",
"var i;"
+ "var $jscomp$generator$yield$entry;"
+ "var $jscomp$generator$yield$all;",
Joiner.on('\n').join(
"  return {value: undefined, done: true}"
));
test("function *f() {yield arguments[0];}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$arguments = arguments;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: $jscomp$generator$arguments[0], done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {yield this;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$this = this;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: $jscomp$generator$this, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
rewriteGeneratorBody("0 || (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 3;",
"        return{value:1, done:false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
rewriteGeneratorBody("0 && (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        return{value:1, done:false};",
"      case 2:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 3:",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
rewriteGeneratorBody("0 ? 1 : (yield 1);", Joiner.on('\n').join(
"      case 0:",
"        if (!0) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        1;",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 3;",
"        return{value:1, done:false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}"
));
test(Joiner.on('\n').join(
"function *f() {",
"  while (1) {",
"    switch (i) {",
"      case 1:",
"        yield 2;",
"        break;",
"      case 2:",
"        yield 3;",
"        continue;",
"      case 3:",
"        yield 4;",
"      default:",
"        yield 5;",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$switch$val1;",
"  var $jscomp$generator$switch$entered0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"      case 1:",
"        if (!1) {",
"          $jscomp$generator$state = 2;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = false;",
"        $jscomp$generator$switch$val1 = i;",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 1)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 5;",
"        return {value: 2, done: false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"        $jscomp$generator$state = 3;",
"        break;",
"      case 4:",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 2)) {",
"          $jscomp$generator$state = 7;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 8;",
"        return {value: 3, done: false};",
"      case 8:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 9; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 9:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 7:",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 3)) {",
"          $jscomp$generator$state = 10;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 11;",
"        return{value: 4, done: false};",
"      case 11:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 12; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 12:",
"      case 10:",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 13;",
"        return {value: 5, done: false};",
"      case 13:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 14; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 14:",
"      case 3:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { if (1) { try {} catch (e) {} throw 1; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        if (!1) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        try {} catch (e) {}",
"        $jscomp$generator$state = -1;",
"        throw 1;",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() { for (var i in j) { yield 1; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  var $jscomp$generator$forin$iter0;",
"  var $jscomp$generator$forin$var0;",
"  var $jscomp$generator$forin$array0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$forin$array0 = [];",
"        $jscomp$generator$forin$iter0 = j;",
"        for (i in $jscomp$generator$forin$iter0) {",
"          $jscomp$generator$forin$array0.push(i);",
"        }",
"        $jscomp$generator$forin$var0 = 0;",
"      case 1:",
"        if (!($jscomp$generator$forin$var0",
"            < $jscomp$generator$forin$array0.length)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        i = $jscomp$generator$forin$array0[$jscomp$generator$forin$var0];",
"        if (!(!(i in $jscomp$generator$forin$iter0))) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 4:",
"        $jscomp$generator$state = 5;",
"        return{value:1, done:false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"      case 2:",
"        $jscomp$generator$forin$var0++;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {try {yield 1;} catch (e) {}}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var e;",
"  var $jscomp$generator$global$error;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        try {",
"          $jscomp$generator$state = 3;",
"          return {value: 1, done: false};",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 3:",
"        try {",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 4; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 4:",
"        try {",
"          $jscomp$generator$state = 2;",
"          break;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 1:",
"        e = $jscomp$generator$global$error;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
test("function *f() {try {yield 1;} catch (e) {} finally {b();}}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var e;",
"  var $jscomp$generator$finally0;",
"  var $jscomp$generator$global$error;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        try {",
"          $jscomp$generator$state = 4;",
"          return {value: 1, done: false};",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 4:",
"        try {",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 5; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 5:",
"        try {",
"          $jscomp$generator$finally0 = 3;",
"          $jscomp$generator$state = 2;",
"          break;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 1:",
"        e = $jscomp$generator$global$error;",
"        $jscomp$generator$finally0 = 3;",
"      case 2:",
"        b();",
"        $jscomp$generator$state = $jscomp$generator$finally0;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  var iterator = {",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"  $jscomp.initSymbolIterator();",
"  iterator[Symbol.iterator] = function() { return this; };",
"  return iterator;",
"}"
));
import com.google.common.base.Joiner;
test(Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    let x = 2;",
"    x = function() { return x; };",
"  }",
"  return x;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    var x$0 = 2;",
"    x$0 = function() { return x$0; };",
"  }",
"  return x;",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  const x = 3;",
"  if (true) {",
"    let x;",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  /** @const */ var x = 3;",
"  if (true) {",
"    var x$0 = undefined;",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    var g = function() { return x; };",
"    let x = 2;",
"    return g();",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    var g = function() { return x$0; };",
"    var x$0 = 2;",
"    return g();",
"  }",
"}"
));
test(Joiner.on('\n').join(
"var x = 2;",
"function f() {",
"  x = 1;",
"  if (a) {",
"    let x = 2;",
"  }",
"}"
), Joiner.on('\n').join(
"var x = 2;",
"function f() {",
"  x = 1;",
"  if (a) {",
"    var x$0 = 2;",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  {",
"    let inner = 2;",
"  }",
"  use(inner)",
"}"
), Joiner.on('\n').join(
"function f() {",
"  {",
"    var inner$0 = 2;",
"  }",
"  use(inner)",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    let x = 2;",
"    assert(x === 2);",
"  }",
"  if (b) {",
"    let x;",
"    assert(x === undefined);",
"  }",
"  assert(x === 1);",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    var x$0 = 2;",
"    assert(x$0 === 2);",
"  }",
"  if (b) {",
"    var x$1 = undefined;",
"    assert(x$1 === undefined);",
"  }",
"  assert(x === 1);",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    let x = 2;",
"    assert(x === 2);",
"    if (b) {",
"      let x;",
"      assert(x === undefined);",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    var x = 2;",
"    assert(x === 2);",
"    if (b) {",
"      var x$0 = undefined;",
"      assert(x$0 === undefined);",
"    }",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  let x = 5;",
"  for (let x of [1,2,3]) {",
"    console.log(x);",
"  }",
"  console.log(x);",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var x = 5;",
"  for(var x$0 of [1,2,3]) {",
"    console.log(x$0);",
"  }",
"  console.log(x);",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  const y = 0;",
"  for (let x = 0; x < 10; x++) {",
"    const y = x * 2;",
"    const z = y;",
"  }",
"  console.log(y);",
"}"
), Joiner.on('\n').join(
"function f() {",
"  /** @const */ var y = 0;",
"  for (var x = 0; x < 10; x++) {",
"    /** @const */ var y$0 = x * 2;",
"    /** @const */ var z = y$0;",
"  }",
"  console.log(y);",
"}"
));
test(Joiner.on('\n').join(
"for (let i in [0, 1]) {",
"  function f() {",
"    let i = 0;",
"    if (true) {",
"      let i = 1;",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"for (var i in [0, 1]) {",
"  var f = function() {",
"    var i = 0;",
"    if (true) {",
"      var i$0 = 1;",
"    }",
"  }",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0; i < 10; i++) {",
"  arr.push(function() { return i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined};",
"$jscomp$loop$0.i = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i}, $jscomp$loop$0.i++) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.i; };",
"  })($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0; i < 10; i++) {",
"  let y = i;",
"  arr.push(function() { return y; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {y: undefined};",
"var i = 0;",
"for (; i < 10; $jscomp$loop$0 = {y: $jscomp$loop$0.y}, i++) {",
"  $jscomp$loop$0.y = i;",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.y; };",
"  })($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"while (true) {",
"  let i = 0;",
"  arr.push(function() { return i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined}",
"while (true) {",
"  $jscomp$loop$0.i = 0;",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.i; };",
"  })($jscomp$loop$0));",
"  $jscomp$loop$0 = {i: $jscomp$loop$0.i}",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0; i < 10; i++) {",
"  let y = i;",
"  arr.push(function() { return y + i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {y: undefined, i: undefined};",
"$jscomp$loop$0.i = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {y: $jscomp$loop$0.y, i: $jscomp$loop$0.i},",
"        $jscomp$loop$0.i++) {",
"  $jscomp$loop$0.y = $jscomp$loop$0.i;",
"  arr.push((function($jscomp$loop$0) {",
"          return function() {",
"              return $jscomp$loop$0.y + $jscomp$loop$0.i;",
"          };",
"  }($jscomp$loop$0)));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"let x = 0",
"for (let i = 0; i < 10; i++) {",
"  let i = x + 1;",
"  arr.push(function() { return i + i; });",
"  x++;",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var x = 0",
"var $jscomp$loop$1 = {i$0: undefined};",
"var i = 0;",
"for (; i < 10; $jscomp$loop$1 = {i$0: $jscomp$loop$1.i$0}, i++) {",
"  $jscomp$loop$1.i$0 = x + 1;",
"  arr.push((function($jscomp$loop$1) {",
"      return function() {",
"          return $jscomp$loop$1.i$0 + $jscomp$loop$1.i$0;",
"      };",
"  }($jscomp$loop$1)));",
"  x++;",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"let x = 0",
"for (let i = 0; i < 10; i++) {",
"  arr.push(function() { return i + i; });",
"  let i = x + 1;",
"  arr.push(function() { return i + i; });",
"  x++;",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var x = 0",
"var $jscomp$loop$1 = {i$0: undefined};",
"var i = 0;",
"for (; i < 10; $jscomp$loop$1 = {i$0: $jscomp$loop$1.i$0}, i++) {",
"  arr.push((function($jscomp$loop$1) {",
"      return function() {",
"          return $jscomp$loop$1.i$0 + $jscomp$loop$1.i$0;",
"      };",
"  }($jscomp$loop$1)));",
"  $jscomp$loop$1.i$0 = x + 1;",
"  arr.push((function($jscomp$loop$1) {",
"      return function() {",
"          return $jscomp$loop$1.i$0 + $jscomp$loop$1.i$0;",
"      };",
"  }($jscomp$loop$1)));",
"  x++;",
"}"
));
test(Joiner.on('\n').join(
"for (let i = 0; i < 10; i++) {",
"  if (true) {",
"    let i = x - 1;",
"    arr.push(function() { return i + i; });",
"  }",
"  let i = x + 1;",
"  arr.push(function() { return i + i; });",
"  x++;",
"}"
), Joiner.on('\n').join(
"var $jscomp$loop$2 = {i$0 : undefined, i$1: undefined};",
"var i = 0;",
"for (; i < 10;",
"    $jscomp$loop$2 = {i$0: $jscomp$loop$2.i$0, i$1: $jscomp$loop$2.i$1}, i++) {",
"  if (true) {",
"    $jscomp$loop$2.i$0 = x - 1;",
"    arr.push((function($jscomp$loop$2) {",
"        return function() { return $jscomp$loop$2.i$0 + $jscomp$loop$2.i$0; };",
"    })($jscomp$loop$2));",
"  }",
"  $jscomp$loop$2.i$1 = x + 1;",
"  arr.push((function($jscomp$loop$2) {",
"      return function() { return $jscomp$loop$2.i$1 + $jscomp$loop$2.i$1; };",
"  })($jscomp$loop$2));",
"  x++;",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"let j = 0;",
"for (let i = 0; i < 10; i++) {",
"  let i, j = 0;",
"  arr.push(function() { return i + j; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var j = 0;",
"var $jscomp$loop$1 = {i$0: undefined, j: undefined};",
"var i = 0;",
"for (; i < 10; $jscomp$loop$1 = {i$0: $jscomp$loop$1.i$0,",
"    j: $jscomp$loop$1.j}, i++) {",
"    $jscomp$loop$1.i$0 = undefined;",
"    $jscomp$loop$1.j = 0;",
"  arr.push((function($jscomp$loop$1) {",
"      return function() { return $jscomp$loop$1.i$0 + $jscomp$loop$1.j; };",
"  })($jscomp$loop$1));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"let j = 0;",
"for (let i = 0; i < 10; i++, j++) {",
"  arr.push(function() { return i + j; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var j = 0;",
"var $jscomp$loop$0 = {i: undefined};",
"$jscomp$loop$0.i = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i}, ($jscomp$loop$0.i++, j++)) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.i + j; };",
"  })($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0, j = 0; i < 10; i++, j++) {",
"  arr.push(function() { return i + j; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined, j: undefined};",
"$jscomp$loop$0.i = 0;",
"$jscomp$loop$0.j = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i, j : $jscomp$loop$0.j},",
"        ($jscomp$loop$0.i++, $jscomp$loop$0.j++)) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.i + $jscomp$loop$0.j; };",
"  })($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0, j = 0; i < 10; i++, j++) {",
"  arr.push(function() { return j; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {j: undefined};",
"var i = 0;",
"$jscomp$loop$0.j = 0;",
"for (; i < 10; $jscomp$loop$0 = {j : $jscomp$loop$0.j},",
"    (i++, $jscomp$loop$0.j++)) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.j; };",
"  })($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0; i < 10; i++) {",
"  arr.push(function() { return ++i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined};",
"$jscomp$loop$0.i = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i}, $jscomp$loop$0.i++) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() {",
"          return ++$jscomp$loop$0.i;",
"      };",
"  }($jscomp$loop$0)));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i = 0; i < 10; i++) {",
"  arr.push(function() { return i; });",
"  i += 100;",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined};",
"$jscomp$loop$0.i = 0;",
"for (; $jscomp$loop$0.i < 10;",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i}, $jscomp$loop$0.i++) {",
"  arr.push((function($jscomp$loop$0) {",
"      return function() {",
"          return $jscomp$loop$0.i;",
"      };",
"  }($jscomp$loop$0)));",
"  $jscomp$loop$0.i += 100;",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  let arr = [];",
"  for (let i = 0; i < 10; i++) {",
"    for (let j = 0; j < 10; j++) {",
"      arr.push(function() { return j++ + i++; });",
"      arr.push(function() { return j++ + i++; });",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var arr = [];",
"  var $jscomp$loop$1 = {i : undefined};",
"  $jscomp$loop$1.i = 0;",
"  for (; $jscomp$loop$1.i < 10;",
"      $jscomp$loop$1 = {i: $jscomp$loop$1.i}, $jscomp$loop$1.i++) {",
"    var $jscomp$loop$0 = {j : undefined};",
"    $jscomp$loop$0.j = 0;",
"    for (; $jscomp$loop$0.j < 10;",
"        $jscomp$loop$0 = {j: $jscomp$loop$0.j}, $jscomp$loop$0.j++) {",
"      arr.push((function($jscomp$loop$0, $jscomp$loop$1) {",
"          return function() {",
"              return $jscomp$loop$0.j++ + $jscomp$loop$1.i++;",
"          };",
"      }($jscomp$loop$0, $jscomp$loop$1)));",
"      arr.push((function($jscomp$loop$0, $jscomp$loop$1) {",
"          return function() {",
"              return $jscomp$loop$0.j++ + $jscomp$loop$1.i++;",
"          };",
"      }($jscomp$loop$0, $jscomp$loop$1)));",
"    }",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  let arr = [];",
"  for (let i = 0; i < 10; i++) {",
"    arr.push(function() { return i++ + i++; });",
"    for (let i = 0; i < 10; i++) {",
"      arr.push(function() { return i++ + i++; });",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var arr = [];",
"  var $jscomp$loop$1 = {i : undefined};",
"  $jscomp$loop$1.i = 0;",
"  for (; $jscomp$loop$1.i < 10;",
"      $jscomp$loop$1 = {i: $jscomp$loop$1.i}, $jscomp$loop$1.i++) {",
"    arr.push((function($jscomp$loop$1) {",
"        return function() {",
"            return $jscomp$loop$1.i++ + $jscomp$loop$1.i++;",
"        };",
"    }($jscomp$loop$1)));",
"    var $jscomp$loop$2 = {i$0 : undefined};",
"    $jscomp$loop$2.i$0 = 0;",
"    for (; $jscomp$loop$2.i$0 < 10;",
"        $jscomp$loop$2 = {i$0: $jscomp$loop$2.i$0}, $jscomp$loop$2.i$0++) {",
"      arr.push((function($jscomp$loop$2) {",
"          return function() {",
"              return $jscomp$loop$2.i$0++ + $jscomp$loop$2.i$0++;",
"          };",
"      }($jscomp$loop$2)));",
"    }",
"  }",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i in [0, 1]) {",
"  arr.push(function() { return i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$0 = {i: undefined};",
"for (var i in [0, 1]) {",
"  $jscomp$loop$0.i = i;",
"  arr.push((function($jscomp$loop$0) {",
"      return function() { return $jscomp$loop$0.i; };",
"  })($jscomp$loop$0));",
"  $jscomp$loop$0 = {i: $jscomp$loop$0.i};",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"for (let i of [0, 1]) {",
"  let i = 0;",
"  arr.push(function() { return i; });",
"}"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$1 = {i$0: undefined};",
"for (var i of [0, 1]) {",
"  $jscomp$loop$1.i$0 = 0;",
"  arr.push((function($jscomp$loop$1) {",
"      return function() { return $jscomp$loop$1.i$0; };",
"  })($jscomp$loop$1));",
"  $jscomp$loop$1 = {i$0: $jscomp$loop$1.i$0}",
"}"
));
test(Joiner.on('\n').join(
"for (;;) {",
"  let a = getArray();",
"  f = function() {",
"    for (var x in use(a)) {",
"      f(a);",
"      a.push(x);",
"      return x;",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"var $jscomp$loop$0 = {a: undefined};",
"for (;; $jscomp$loop$0 = {a: $jscomp$loop$0.a}) {",
"  $jscomp$loop$0.a = getArray();",
"  f = (function($jscomp$loop$0) {",
"    return function() {",
"      for (var x in use($jscomp$loop$0.a)) {",
"        f($jscomp$loop$0.a);",
"        $jscomp$loop$0.a.push(x);",
"        return x;",
"      }",
"    };",
"  }($jscomp$loop$0));",
"}"
));
test(Joiner.on('\n').join(
"const arr = [];",
"do {",
"  let special = 99;",
"  for (let i of [0, 1, special, 3, 4, 5]) {",
"    i = Number(i);",
"    arr.push(function() { return i++; });",
"    arr.push(function() { return i + special; });",
"  }",
"} while (false);"
), Joiner.on('\n').join(
"/** @const */ var arr = [];",
"var $jscomp$loop$1 = {special: undefined};",
"do {",
"  $jscomp$loop$1.special = 99;",
"  var $jscomp$loop$0 = {i: undefined};",
"  for (var i of [0, 1, $jscomp$loop$1.special, 3, 4, 5]) {",
"    $jscomp$loop$0.i = i",
"    $jscomp$loop$0.i = Number($jscomp$loop$0.i);",
"    arr.push((function($jscomp$loop$0) {",
"        return function() { return $jscomp$loop$0.i++; };",
"    }($jscomp$loop$0)));",
"    arr.push((function($jscomp$loop$0, $jscomp$loop$1) {",
"        return function() { return $jscomp$loop$0.i + $jscomp$loop$1.special; };",
"    }($jscomp$loop$0, $jscomp$loop$1)));",
"    $jscomp$loop$0 = {i: $jscomp$loop$0.i};",
"  }",
"  $jscomp$loop$1 = {special: $jscomp$loop$1.special};",
"} while (false);"
));
test(Joiner.on('\n').join(
"while (true) {",
"  /** @type {number} */ let x = 5;",
"  (function() { x++; })();",
"  x = 7;",
"}"
), null);
test(Joiner.on('\n').join(
"for (/** @type {number} */ let x = 5;;) {",
"  (function() { x++; })();",
"  x = 7;",
"}"
), null);
test(Joiner.on('\n').join(
"while (true) {",
"  /** @type {number} */ let x = 5;",
"  (function() { x++; })();",
"  x = 5;",
"}"
), null);
test(Joiner.on('\n').join(
"for (/** @type {number} */ let x = 5;;) {",
"  (function() { x++; })();",
"  x = 'str';",
"}"
), null);
test(Joiner.on('\n').join(
"{",
"  let l = [];",
"  for (var vx = 1, vy = 2, vz = 3; vx < 10; vx++) {",
"    let lx = vx, ly = vy, lz = vz;",
"    l.push(function() { return [ lx, ly, lz ]; });",
"  }",
"}"
), Joiner.on('\n').join(
"{",
"  var l = [];",
"  var $jscomp$loop$0 = {lx: undefined, ly: undefined, lz: undefined};",
"  var vx = 1, vy = 2, vz = 3;",
"  for (; vx < 10; $jscomp$loop$0 = {lx: $jscomp$loop$0.lx,",
"      ly: $jscomp$loop$0.ly, lz: $jscomp$loop$0.lz}, vx++){",
"    $jscomp$loop$0.lx = vx;",
"    $jscomp$loop$0.ly = vy;",
"    $jscomp$loop$0.lz = vz;",
"    l.push(function($jscomp$loop$0) {",
"        return function() {",
"            return [ $jscomp$loop$0.lx, $jscomp$loop$0.ly, $jscomp$loop$0.lz ];",
"        };",
"    }($jscomp$loop$0));",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    label0: label1: label2:",
"      function x() { return x; }",
"  }",
"  return x;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var x = 1;",
"  if (a) {",
"    label0: label1: label2:",
"      var x$0 = function() { return x$0; };",
"  }",
"  return x;",
"}"
));
import com.google.common.base.Joiner;
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
import com.google.common.base.Joiner;
private static final String EXTERNS_BASE = Joiner.on('\n').join(
"/**",
" * @param {...*} var_args",
" * @return {*}",
" */",
"Function.prototype.apply = function(var_args) {};",
"",
"/**",
" * @param {...*} var_args",
" * @return {*}",
" */",
"Function.prototype.call = function(var_args) {};",
"",
"function Object() {}",
"Object.defineProperties;",
"",
"$jscomp.copyProperties = function(x,y) {};",
"$jscomp.inherits = function(x,y) {};"
);
test("class C { *foo() { yield 1; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.foo = function*() { yield 1;};"
));
test("class C { }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};"
));
test("class C { constructor() {} }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};"
));
test("class C { method() {}; }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.method = function() {};"
));
test("class C { constructor(a) { this.a = a; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function(a) { this.a = a; };"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor() {}",
"",
"  foo() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.foo = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor() {}",
"",
"  foo() {}",
"",
"  bar() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.foo = function() {};",
"C.prototype.bar = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  foo() {}",
"",
"  bar() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.foo = function() {};",
"C.prototype.bar = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor(a) { this.a = a; }",
"",
"  foo() { console.log(this.a); }",
"",
"  bar() { alert(this.a); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function(a) { this.a = a; };",
"C.prototype.foo = function() { console.log(this.a); };",
"C.prototype.bar = function() { alert(this.a); };"
));
test(Joiner.on('\n').join(
"class A {",
"  /** @ngInject */",
"  constructor($scope) {}",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct @ngInject */",
"var A = function($scope) {}"));
test(Joiner.on('\n').join(
"/** @ngInject */",
"class A {",
"  constructor($scope) {}",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct @ngInject */",
"var A = function($scope) {}"));
test(
"class C { }",
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() { };")
);
Joiner.on('\n').join(
"/** @constructor @struct @deprecated */",
"var C = function() {};")
);
Joiner.on('\n').join(
"/** @constructor @dict */",
"var C = function() {};")
);
test(Joiner.on('\n').join(
"/**",
" * Converts Xs to Ys.",
" * @interface",
" */",
"class Converter {",
"  /**",
"   * @param {X} x",
"   * @return {Y}",
"   */",
"  convert(x) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * Converts Xs to Ys.",
" * @interface",
" */",
"var Converter = function() { };",
"",
"/**",
" * @param {X} x",
" * @return {Y}",
" */",
"Converter.prototype.convert = function(x) {};"
));
test(Joiner.on('\n').join(
"class C {",
"  /** @param {boolean} b */",
"  constructor(b) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * @param {boolean} b",
" * @constructor",
" * @struct",
" */",
"var C = function(b) {};"
));
test(Joiner.on('\n').join(
"class C {",
"  /** @param {boolean} b */",
"  foo(b) {}",
"}"
), Joiner.on('\n').join(
"/**",
" * @constructor",
" * @struct",
" */",
"var C = function() {};",
"",
"/** @param {boolean} b */",
"C.prototype.foo = function(b) {};"
));
test(Joiner.on('\n').join(
"if (foo) {",
"  class C { }",
"}"
), Joiner.on('\n').join(
"if (foo) {",
"  /** @constructor @struct */",
"  var C = function() {};",
"}"
));
test(Joiner.on('\n').join(
"if (foo)",
"  class C { }"
), Joiner.on('\n').join(
"if (foo) {",
"  /** @constructor @struct */",
"  var C = function() {};",
"}"
));
test("var C = class { foo() {} }", Joiner.on('\n').join(
"/** @constructor @struct */ var C = function() {}",
"",
"C.prototype.foo = function() {}"
));
test("var C = class C { foo() {} }", Joiner.on('\n').join(
"/** @constructor @struct */ var C = function() {}",
"",
"C.prototype.foo = function() {};"
));
test("goog.example.C = class { foo() {} }", Joiner.on('\n').join(
"/** @constructor @struct */ goog.example.C = function() {}",
"goog.example.C.prototype.foo = function() {};"
));
test("class D {} class C extends D {}", Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"/** @constructor @struct @extends {D} */",
"var C = function(var_args) { D.apply(this, arguments); };",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);"
));
test("class D {} class C extends D { constructor() { super(); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"/** @constructor @struct @extends {D} */",
"var C = function() {",
"  D.call(this);",
"}",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);"
));
test("class D {} class C extends D { constructor(str) { super(str); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"/** @constructor @struct @extends {D} */",
"var C = function(str) { ",
"  D.call(this, str);",
"}",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);"
));
test("class C extends ns.D { }", Joiner.on('\n').join(
"/** @constructor @struct @extends {ns.D} */",
"var C = function(var_args) { ns.D.apply(this, arguments); };",
"$jscomp.copyProperties(C, ns.D);",
"$jscomp.inherits(C, ns.D);"
));
test(Joiner.on('\n').join(
"/** @interface */",
"class D {",
"  f() {}",
"}",
"/** @interface */",
"class C extends D {",
"  g() {}",
"}"
), Joiner.on('\n').join(
"/** @interface */",
"var D = function() {};",
"D.prototype.f = function() {};",
"/** @interface @extends{D} */",
"var C = function(var_args) { D.apply(this, arguments); };",
"C.prototype.g = function() {};"
));
test(Joiner.on('\n').join(
"/** @interface */",
"class D {",
"  f() {}",
"}",
"/** @implements {D} */",
"class C {",
"  f() {console.log('hi');}",
"}"
), Joiner.on('\n').join(
"/** @interface */",
"var D = function() {};",
"D.prototype.f = function() {};",
"/** @constructor @struct @implements{D} */",
"var C = function() {};",
"C.prototype.f = function() {console.log('hi');};"
));
test("class D {} class C extends D { constructor() { super(); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"/** @constructor @struct @extends {D} */",
"var C = function() {",
"  D.call(this);",
"}",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);"
));
test("class D {} class C extends D { constructor(str) { super(str); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {}",
"/** @constructor @struct @extends {D} */",
"var C = function(str) {",
"  D.call(this,str);",
"}",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);"
));
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor() { }",
"  foo() { return super.foo(); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {}",
"/** @constructor @struct @extends {D} */",
"var C = function() { }",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.prototype.foo = function() {",
"  return D.prototype.foo.call(this);",
"}"
));
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor() {}",
"  foo(bar) { return super.foo(bar); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {}",
"/** @constructor @struct @extends {D} */",
"var C = function() {};",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.prototype.foo = function(bar) {",
"  return D.prototype.foo.call(this, bar);",
"}"
));
test("class C { method() { class D extends C { constructor() { super(); }}}}",
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {}",
"C.prototype.method = function() {",
"  /** @constructor @struct @extends{C} */",
"  var D = function() {",
"    C.call(this);",
"  }",
"  $jscomp.copyProperties(D, C);",
"  $jscomp.inherits(D, C);",
"};"
));
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor() {}",
"  f() {super();}",
"}"), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"/** @constructor @struct @extends {D} */",
"var C = function() {}",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.prototype.f = function() {",
"  D.prototype.f.call(this);",
"}"));
test("class C { f() { class D {} } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.f = function() {",
"  /** @constructor @struct */",
"  var D = function() {}",
"};"
));
test("class C { f() { class D extends C {} } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype.f = function() {",
"  /** @constructor @struct @extends{C} */",
"  var D = function(var_args) { C.apply(this, arguments); };",
"  $jscomp.copyProperties(D, C);",
"  $jscomp.inherits(D, C);",
"};"
));
testError(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  foo() { return super.m.foo(); }",
"}"
), Es6ToEs3Converter.CANNOT_CONVERT_YET);
testError(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  static foo() { return super.m.foo(); }",
"}"
), Es6ToEs3Converter.CANNOT_CONVERT_YET);
test(Joiner.on('\n').join(
"class D {}",
"class C extends D {",
"  constructor(args) {",
"    super(...args)",
"  }",
"}"), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function(){};",
"/** @constructor @struct @extends {D} */",
"var C=function(args) {",
"  D.call.apply(D, [].concat([this], args));",
"};",
"$jscomp.copyProperties(C,D);",
"$jscomp.inherits(C,D);"));
test("class S extends B { static f() { super(); } }", Joiner.on('\n').join(
"/** @constructor @struct @extends {B} */",
"var S = function(var_args) { B.apply(this, arguments); };",
"$jscomp.copyProperties(S, B);",
"$jscomp.inherits(S, B);",
"/** @this {?} */",
"S.f=function() { B.f.call(this) }"));
test("class S extends B { f() { super(); } }", Joiner.on('\n').join(
"/** @constructor @struct @extends {B} */",
"var S = function(var_args) { B.apply(this, arguments); };",
"$jscomp.copyProperties(S, B);",
"$jscomp.inherits(S, B);",
"S.prototype.f=function() {",
"  B.prototype.f.call(this);",
"}"));
test("class F { static f() { return this; } }", Joiner.on('\n').join(
"/** @constructor @struct */ var F = function() {}",
"/** @this {?} */ F.f = function() { return this; };"));
test(Joiner.on('\n').join(
"class C {",
"  static foo() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.foo = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  static foo() {}",
"",
"  foo() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"",
"C.foo = function() {};",
"",
"C.prototype.foo = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  static foo() {}",
"",
"  bar() { C.foo(); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"",
"C.foo = function() {};",
"",
"C.prototype.bar = function() { C.foo(); };"
));
test(Joiner.on('\n').join(
"class D {",
"  static f() {}",
"}",
"class C extends D { constructor() {} }",
"C.f();"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"D.f = function () {};",
"/** @constructor @struct @extends{D} */",
"var C = function() {};",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.f();"
));
test(Joiner.on('\n').join(
"class D {",
"  static f() {}",
"}",
"class C extends D {",
"  constructor() {}",
"  f() {}",
"}",
"C.f();"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"D.f = function() {};",
"/** @constructor @struct @extends{D} */",
"var C = function() { };",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.prototype.f = function() {};",
"C.f();"
));
test(Joiner.on('\n').join(
"class D {",
"  static f() {}",
"}",
"class C extends D {",
"  constructor() {}",
"  static f() {}",
"  g() {}",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var D = function() {};",
"D.f = function() {};",
"/** @constructor @struct @extends{D} */",
"var C = function() { };",
"$jscomp.copyProperties(C, D);",
"$jscomp.inherits(C, D);",
"C.f = function() {};",
"C.prototype.g = function() {};"
));
test(Joiner.on('\n').join(
"class C {",
"  constructor() {",
"    this.counter = 0;",
"  }",
"",
"  init() {",
"    document.onclick = () => this.logClick();",
"  }",
"",
"  logClick() {",
"     this.counter++;",
"  }",
"}"
), Joiner.on('\n').join(
"/**",
" * @constructor",
" * @struct",
" */",
"var C = function() { this.counter = 0; };",
"",
"C.prototype.init = function() {",
"  /** @const */ var $jscomp$this = this;",
"  document.onclick = function() { return $jscomp$this.logClick(); }",
"};",
"",
"C.prototype.logClick = function() {",
"  this.counter++;",
"}"
));
test(EXTERNS_BASE, Joiner.on('\n').join(
"/** @constructor @struct */",
"function Foo() {}",
"Foo.prototype.f = function() {};",
"class Sub extends Foo {}",
"(new Sub).f();"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"function Foo() {}",
"Foo.prototype.f = function() {};",
"/** @constructor @struct @extends {Foo} */",
"var Sub=function(var_args) { Foo.apply(this, arguments); }",
"$jscomp.copyProperties(Sub, Foo);",
"$jscomp.inherits(Sub, Foo);",
"(new Sub).f();"
), null, null);
test(EXTERNS_BASE, Joiner.on('\n').join(
"/** @constructor @struct */",
"function Foo() {}",
"Foo.f = function() {};",
"class Sub extends Foo {}",
"Sub.f();"
), null, null, TypeCheck.INEXISTENT_PROPERTY);
test(EXTERNS_BASE, Joiner.on('\n').join(
"/** @constructor */",
"function Foo() {}",
"Foo.f = function() {};",
"class Sub extends Foo {}"), Joiner.on('\n').join(
"function Foo(){}Foo.f=function(){};",
"var Sub=function(var_args){Foo.apply(this,arguments)};",
"$jscomp.copyProperties(Sub,Foo);",
"$jscomp.inherits(Sub,Foo)"
), null, null);
test("class C { get value() { return 0; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {?} */",
"C.prototype.value;",
"Object.defineProperties(C.prototype, {",
"  value: {",
"    /** @this {C} */",
"    get: function() {",
"      return 0;",
"    }",
"  }",
"});"));
test("class C { set value(val) { this.internalVal = val; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {?} */",
"C.prototype.value;",
"Object.defineProperties(C.prototype, {",
"  value: {",
"    /** @this {C} */",
"    set: function(val) {",
"      this.internalVal = val;",
"    }",
"  }",
"});"));
test(Joiner.on('\n').join(
"class C {",
"  set value(val) {",
"    this.internalVal = val;",
"  }",
"  get value() {",
"    return this.internalVal;",
"  }",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {?} */",
"C.prototype.value;",
"Object.defineProperties(C.prototype, {",
"  value: {",
"    /** @this {C} */",
"    set: function(val) {",
"      this.internalVal = val;",
"    },",
"    /** @this {C} */",
"    get: function() {",
"      return this.internalVal;",
"    }",
"  }",
"});"));
test(Joiner.on('\n').join(
"class C {",
"  get alwaysTwo() {",
"    return 2;",
"  }",
"",
"  get alwaysThree() {",
"    return 3;",
"  }",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {?} */",
"C.prototype.alwaysTwo;",
"/** @type {?} */",
"C.prototype.alwaysThree;",
"Object.defineProperties(C.prototype, {",
"  alwaysTwo: {",
"    /** @this {C} */",
"    get: function() {",
"      return 2;",
"    }",
"  },",
"  alwaysThree: {",
"    /** @this {C} */",
"    get: function() {",
"      return 3;",
"    }",
"  },",
"});"));
test(Joiner.on('\n').join(
"class C {",
"  /** @return {number} */",
"  get value() { return 0; }",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {number} */",
"C.prototype.value;",
"Object.defineProperties(C.prototype, {",
"  value: {",
"    /**",
"     * @return {number}",
"     * @this {C}",
"     */",
"    get: function() {",
"      return 0;",
"    }",
"  }",
"});"));
test(Joiner.on('\n').join(
"class C {",
"  /** @param {string} v */",
"  set value(v) { }",
"}"),
Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"/** @type {string} */",
"C.prototype.value;",
"Object.defineProperties(C.prototype, {",
"  value: {",
"    /**",
"     * @this {C}",
"     * @param {string} v",
"     */",
"    set: function(v) {}",
"  }",
"});"));
testError(Joiner.on('\n').join(
"class C {",
"  /** @return {string} */",
"  get value() { }",
"",
"  /** @param {number} v */",
"  set value(v) { }",
"}"), Es6ToEs3Converter.CONFLICTING_GETTER_SETTER_TYPE);
test(EXTERNS_BASE, Joiner.on('\n').join(
"class C {",
"  /** @type {string} */",
"  get value() { }",
"}"),
Joiner.on('\n').join(
"});"), null, TypeValidator.TYPE_MISMATCH_WARNING);
test(EXTERNS_BASE, Joiner.on('\n').join(
"class C {",
"  /** @type {string} */",
"  set value(v) { }",
"}"),
Joiner.on('\n').join(
"});"), null, TypeValidator.TYPE_MISMATCH_WARNING);
test("var f = () => this;",
Joiner.on('\n').join(
test("var f = x => { this.needsBinding(); return 0; };",
Joiner.on('\n').join(
test(Joiner.on('\n').join(
"var f = x => {",
"  this.init();",
"  this.doThings();",
"  this.done();",
"};"
), Joiner.on('\n').join(
"/** @const */ var $jscomp$this = this;",
"var f = function(x) {",
"  $jscomp$this.init();",
"  $jscomp$this.doThings();",
"  $jscomp$this.done();",
"};"));
test("switch(a) { case b: (() => { this; })(); }", Joiner.on('\n').join(
"switch(a) {",
"  case b:",
"    /** @const */ var $jscomp$this = this;",
"    (function() { $jscomp$this; })();",
"}"
));
test(Joiner.on('\n').join(
"var a1 = x => x+1;",
"var a2 = x => x-1;"
), Joiner.on('\n').join(
"var a1 = function(x) { return x+1; };",
"var a2 = function(x) { return x-1; };"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a1 = x => x+1;",
"  var a2 = x => x-1;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var a1 = function(x) { return x+1; };",
"  var a2 = function(x) { return x-1; };",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a1 = () => this.x;",
"  var a2 = () => this.y;",
"}"
), Joiner.on('\n').join(
"function f() {",
"  /** @const */ var $jscomp$this = this;",
"  var a1 = function() { return $jscomp$this.x; };",
"  var a2 = function() { return $jscomp$this.y; };",
"}"
));
test(Joiner.on('\n').join(
"var a = [1,2,3,4];",
"var b = a.map(x => x+1).map(x => x*x);"
), Joiner.on('\n').join(
"var a = [1,2,3,4];",
"var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });"
));
test(Joiner.on('\n').join(
"function f() {",
"  var a = [1,2,3,4];",
"  var b = a.map(x => x+1).map(x => x*x);",
"}"
), Joiner.on('\n').join(
"function f() {",
"  var a = [1,2,3,4];",
"  var b = a.map(function(x) { return x+1; }).map(function(x) { return x*x; });",
"}"
));
test(Joiner.on('\n').join(
"var outer = {",
"  f: function() {",
"     var a1 = () => this.x;",
"     var inner = {",
"       f: function() {",
"         var a2 = () => this.y;",
"       }",
"     };",
"  }",
"}"
), Joiner.on('\n').join(
"var outer = {",
"  f: function() {",
"     /** @const */ var $jscomp$this = this;",
"     var a1 = function() { return $jscomp$this.x; }",
"     var inner = {",
"       f: function() {",
"         /** @const */ var $jscomp$this = this;",
"         var a2 = function() { return $jscomp$this.y; }",
"       }",
"     };",
"  }",
"}"
));
test(Joiner.on('\n').join(
"function f() {",
"  var setup = () => {",
"    function Foo() { this.x = 5; }",
"    this.f = new Foo;",
"  }",
"}"
), Joiner.on('\n').join(
"function f() {",
"  /** @const */ var $jscomp$this = this;",
"  var setup = function() {",
"    function Foo() { this.x = 5; }",
"    $jscomp$this.f = new Foo;",
"  }",
"}"
));
test(Joiner.on('\n').join(
"var f = x => {",
"  var g = y => {",
"    this.foo();",
"  }",
"}"
), Joiner.on('\n').join(
"/** @const */ var $jscomp$this = this;",
"var f = function(x) {",
"  var g = function(y) {",
"    $jscomp$this.foo();",
"  }",
"}"
));
test(Joiner.on('\n').join(
"var x = true;",
"function f(a=x) { var x = false; return a; }"), Joiner.on('\n').join(
"var x = true;",
"function f(a) {",
"  a = (a === undefined) ? x : a;",
"  var x$0 = false;",
"  return a;",
"}"));
test("function f(zero, one = 1, two = 2) {}; f(1); f(1,2,3);",
Joiner.on('\n').join(
"function f(zero, one, two) {",
"  one = (one === undefined) ? 1 : one;",
"  two = (two === undefined) ? 2 : two;",
"};",
"f(1); f(1,2,3);"
));
test("function f(zero, one = 1, two = 2) {}; f();",
Joiner.on('\n').join(
"function f(zero, one, two) {",
"  one = (one === undefined) ? 1 : one;",
"  two = (two === undefined) ? 2 : two;",
"}; f();"
),
test("function f(zero, one='undefined') {}",
Joiner.on('\n').join(
"function f(zero, one) {",
"  one = (one === undefined) ? 'undefined' : one;",
"}"
));
test("function f(zero, one=void g()) {}",
Joiner.on('\n').join(
"function f(zero, one) {",
"  one = (one === undefined) ? void g() : one;",
"}"
));
test("function f(...zero) {}",
Joiner.on('\n').join(
"function f(zero) {",
"  zero = [].slice.call(arguments, 0);",
"}"
));
test("function f(zero, ...one) {}",
Joiner.on('\n').join(
"function f(zero, one) {",
"  one = [].slice.call(arguments, 1);",
"}"
));
test("function f(zero, one, ...two) {}",
Joiner.on('\n').join(
"function f(zero, one, two) {",
"  two = [].slice.call(arguments, 2);",
"}"
));
test("function f(zero, one = 1, ...two) {}",
Joiner.on('\n').join(
"function f(zero, one, two) {",
"  one = (one === undefined) ? 1 : one;",
"  two = [].slice.call(arguments, 2);",
"}"
));
test(Joiner.on('\n').join(
"for (var i of [1,2,3]) {",
"  console.log(i);",
"}"
), Joiner.on('\n').join(
"for (var $jscomp$iter$0 = $jscomp.makeIterator([1,2,3]),",
"    $jscomp$key$i = $jscomp$iter$0.next();",
"    !$jscomp$key$i.done; $jscomp$key$i = $jscomp$iter$0.next()) {",
"  var i = $jscomp$key$i.value;",
"  console.log(i);",
"}"
));
test(Joiner.on('\n').join(
"for (i of [1,2,3]) {",
"  console.log(i);",
"}"
), Joiner.on('\n').join(
"for (var $jscomp$iter$0 = $jscomp.makeIterator([1,2,3]),",
"    $jscomp$key$i = $jscomp$iter$0.next();",
"    !$jscomp$key$i.done; $jscomp$key$i = $jscomp$iter$0.next()) {",
"  i = $jscomp$key$i.value;",
"  console.log(i);",
"}"
));
test(Joiner.on('\n').join(
"for (var i of arr) {",
"  console.log(i);",
"}"
), Joiner.on('\n').join(
"for (var $jscomp$iter$0 = $jscomp.makeIterator(arr),",
"    $jscomp$key$i = $jscomp$iter$0.next();",
"    !$jscomp$key$i.done; $jscomp$key$i = $jscomp$iter$0.next()) {",
"  var i = $jscomp$key$i.value;",
"  console.log(i);",
"}"
));
test(Joiner.on('\n').join(
"for (var i of [1,2,3])",
"  console.log(i);"
), Joiner.on('\n').join(
"for (var $jscomp$iter$0 = $jscomp.makeIterator([1,2,3]),",
"    $jscomp$key$i = $jscomp$iter$0.next();",
"    !$jscomp$key$i.done; $jscomp$key$i = $jscomp$iter$0.next()) {",
"  var i = $jscomp$key$i.value;",
"  console.log(i);",
"}"
));
test(Joiner.on('\n').join(
"var i = 'outer';",
"for (let i of [1, 2, 3]) {",
"  alert(i);",
"}",
"alert(i);"
), Joiner.on('\n').join(
"var i = 'outer';",
"for (var $jscomp$iter$0 = $jscomp.makeIterator([1,2,3]),",
"    $jscomp$key$i = $jscomp$iter$0.next();",
"    !$jscomp$key$i.done; $jscomp$key$i = $jscomp$iter$0.next()) {",
"  var i$1 = $jscomp$key$i.value;",
"  alert(i$1);",
"}",
"alert(i);"
));
test(Joiner.on('\n').join(
"for ({x} of y) {",
"  console.log(x);",
"}"
), Joiner.on('\n').join(
"for (var $jscomp$iter$0 = $jscomp.makeIterator(y),",
"         $jscomp$key$$jscomp$destructuring$var0 = $jscomp$iter$0.next();",
"     !$jscomp$key$$jscomp$destructuring$var0.done;",
"     $jscomp$key$$jscomp$destructuring$var0 = $jscomp$iter$0.next()) {",
"  var $jscomp$destructuring$var0 = $jscomp$key$$jscomp$destructuring$var0.value;",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0;",
"  x = $jscomp$destructuring$var1.x",
"  console.log(x);",
"}"));
Joiner.on('\n').join(
Joiner.on('\n').join(
"var $jscomp$spread$args0;",
"var x = b ? ($jscomp$spread$args0 = Factory.create()).m.apply($jscomp$spread$args0, ",
"    [].concat(arr)) : null;"
));
test("F.c().m(...a); G.d().n(...b);",
Joiner.on('\n').join(
"var $jscomp$spread$args0;",
"($jscomp$spread$args0 = F.c()).m.apply($jscomp$spread$args0,",
"    [].concat(a));",
"var $jscomp$spread$args1;",
"($jscomp$spread$args1 = G.d()).n.apply($jscomp$spread$args1,",
"    [].concat(b));"
));
test(EXTERNS_BASE, Joiner.on('\n').join(
"class C {}",
"class Factory {",
"  /** @return {C} */",
"  static create() {return new C()}",
"}",
"var arr = [1,2]",
"Factory.create().m(...arr);"
), null, null, TypeCheck.INEXISTENT_PROPERTY);
test(EXTERNS_BASE, Joiner.on('\n').join(
), Joiner.on('\n').join(
test(Joiner.on('\n').join(
"var obj = {",
"  f() { alert(1); },",
"  x",
"};"), Joiner.on('\n').join(
"var obj = {",
"  f: function() { alert(1); },",
"  x: x",
"};"));
test(Joiner.on('\n').join(
"var obj = {",
"  ['f' + 1] : 1,",
"  m() {},",
"  ['g' + 1] : 1,",
"};"), Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var obj = ($jscomp$compprop0['f' + 1] = 1,",
"  ($jscomp$compprop0.m = function() {}, ",
"     ($jscomp$compprop0['g' + 1] = 1, $jscomp$compprop0)));"));
test("var obj = { ['f' + 1] : 1, ['g' + 1] : 1 };",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var obj = ($jscomp$compprop0['f' + 1] = 1,",
"  ($jscomp$compprop0['g' + 1] = 1, $jscomp$compprop0));"
));
test("var obj = { ['f'] : 1};",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var obj = ($jscomp$compprop0['f'] = 1,",
"  $jscomp$compprop0);"
));
test("var o = { ['f'] : 1}; var p = { ['g'] : 1};",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var o = ($jscomp$compprop0['f'] = 1,",
"  $jscomp$compprop0);",
"var $jscomp$compprop1 = {};",
"var p = ($jscomp$compprop1['g'] = 1,",
"  $jscomp$compprop1);"
));
test("({['f' + 1] : 1})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"($jscomp$compprop0['f' + 1] = 1,",
"  $jscomp$compprop0)"
));
test("({'a' : 2, ['f' + 1] : 1})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"($jscomp$compprop0['a'] = 2,",
"  ($jscomp$compprop0['f' + 1] = 1, $jscomp$compprop0));"
));
test("({['f' + 1] : 1, 'a' : 2})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"($jscomp$compprop0['f' + 1] = 1,",
"  ($jscomp$compprop0['a'] = 2, $jscomp$compprop0));"
));
Joiner.on('\n').join(
test("({'a' : x++, ['f' + x++] : 1, 'b' : x++})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"($jscomp$compprop0['a'] = x++, ($jscomp$compprop0['f' + x++] = 1,",
"  ($jscomp$compprop0['b'] = x++, $jscomp$compprop0)))"
));
test("({a : x++, ['f' + x++] : 1, b : x++})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"($jscomp$compprop0.a = x++, ($jscomp$compprop0['f' + x++] = 1,",
"  ($jscomp$compprop0.b = x++, $jscomp$compprop0)))"
));
test("({a, ['f' + 1] : 1})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"  ($jscomp$compprop0.a = a, ($jscomp$compprop0['f' + 1] = 1, $jscomp$compprop0))"
));
test("({['f' + 1] : 1, a})",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"  ($jscomp$compprop0['f' + 1] = 1, ($jscomp$compprop0.a = a, $jscomp$compprop0))"
));
test("var obj = { [foo]() {}}", Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var obj = ($jscomp$compprop0[foo] = function(){}, $jscomp$compprop0)"
));
test("var obj = { *[foo]() {}}", Joiner.on('\n').join(
"var $jscomp$compprop0 = {};",
"var obj = (",
"  $jscomp$compprop0[foo] = function*(){},",
"  $jscomp$compprop0)"));
test("var obj = {'a' : 2, get l () {return null;}, ['f' + 1] : 1}",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {get l () {return null;}};",
"var obj = ($jscomp$compprop0['a'] = 2,",
"  ($jscomp$compprop0['f' + 1] = 1, $jscomp$compprop0));"
));
test("var obj = {['a' + 'b'] : 2, set l (str) {}}",
Joiner.on('\n').join(
"var $jscomp$compprop0 = {set l (str) {}};",
"var obj = ($jscomp$compprop0['a' + 'b'] = 2, $jscomp$compprop0);"
));
test("class C { [foo]() { alert(1); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype[foo] = function() { alert(1); };"
));
test("class C { static [foo]() { alert(2); } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C[foo] = function() { alert(2); };"
));
test("class C { *[foo]() { yield 1; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.prototype[foo] = function*() { yield 1; };"
));
test("class C { static *[foo]() { yield 2; } }", Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C[foo] = function*() { yield 2; };"
));
test("{ function *f() {yield 1;} }", Joiner.on('\n').join(
"{",
"  var f = function*() { yield 1; };",
"}"
));
Joiner.on('\n').join(
"var x,y;\n"
+ "[x,y] = z();",
Joiner.on('\n').join(
"var [a,b] = c();"
+ "var [x,y] = z();",
Joiner.on('\n').join(
test("var a; [a=1] = b();", Joiner.on('\n').join(
"var a;",
"var $jscomp$destructuring$var0 = b()",
"a = ($jscomp$destructuring$var0[0] === undefined) ?",
"    1 :",
"    $jscomp$destructuring$var0[0];"));
test("var [a=1] = b();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = b()",
"var a = ($jscomp$destructuring$var0[0] === undefined) ?",
"    1 :",
"    $jscomp$destructuring$var0[0];"));
test("var [a, b=1, c] = d();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0=d();",
"var a = $jscomp$destructuring$var0[0];",
"var b = ($jscomp$destructuring$var0[1] === undefined) ?",
"    1 :",
"    $jscomp$destructuring$var0[1];",
"var c=$jscomp$destructuring$var0[2]"));
test("var a; [[a] = ['b']] = [];", Joiner.on('\n').join(
"var a;",
"var $jscomp$destructuring$var0 = [];",
"var $jscomp$destructuring$var1 = ($jscomp$destructuring$var0[0] === undefined)",
"    ? ['b']",
"    : $jscomp$destructuring$var0[0];",
"a = $jscomp$destructuring$var1[0]"));
test("function f([x,y]) { use(x); use(y); }", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0;",
"  var x = $jscomp$destructuring$var1[0];",
"  var y = $jscomp$destructuring$var1[1];",
"  use(x);",
"  use(y);",
"}"));
test("function f([x, , y]) { use(x); use(y); }", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0;",
"  var x = $jscomp$destructuring$var1[0];",
"  var y = $jscomp$destructuring$var1[2];",
"  use(x);",
"  use(y);",
"}"));
test("let [one, ...others] = f();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = f();",
"var one = $jscomp$destructuring$var0[0];",
"var others = [].slice.call($jscomp$destructuring$var0, 1);"));
test("function f([first, ...rest]) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0;",
"  var first = $jscomp$destructuring$var1[0];",
"  var rest = [].slice.call($jscomp$destructuring$var1, 1);",
"}"));
test("var {a: b, c: d} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = $jscomp$destructuring$var0.a;",
"var d = $jscomp$destructuring$var0.c;"));
test("var {a,b} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var a = $jscomp$destructuring$var0.a;",
"var b = $jscomp$destructuring$var0.b;"));
test("var x; ({a: x}) = foo();", Joiner.on('\n').join(
"var x;",
"var $jscomp$destructuring$var0 = foo();",
"x = $jscomp$destructuring$var0.a;"));
test("var {a : b = 'default'} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = ($jscomp$destructuring$var0.a === undefined) ?",
"    'default' :",
"    $jscomp$destructuring$var0.a"));
test("var {a = 'default'} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var a = ($jscomp$destructuring$var0.a === undefined) ?",
"    'default' :",
"    $jscomp$destructuring$var0.a"));
test("var {a: {b}} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var $jscomp$destructuring$var1 = $jscomp$destructuring$var0.a;",
"var b = $jscomp$destructuring$var1.b"));
test("var {[a]: b} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = $jscomp$destructuring$var0[a];"));
test("({[a]: b}) = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"b = $jscomp$destructuring$var0[a];"));
test("var {[foo()]: x = 5} = {};", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = {};",
"var $jscomp$destructuring$var1 = $jscomp$destructuring$var0[foo()];",
"var x = $jscomp$destructuring$var1 === undefined ?",
"    5 : $jscomp$destructuring$var1"));
test("function f({['KEY']: x}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var x = $jscomp$destructuring$var1['KEY']",
"}"));
test("var {5: b} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = $jscomp$destructuring$var0['5']"));
test("var {0.1: b} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = $jscomp$destructuring$var0['0.1']"));
test("var {'str': b} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var b = $jscomp$destructuring$var0['str']"));
test("function f({a: b}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var b = $jscomp$destructuring$var1.a",
"}"));
test("function f({a}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var a = $jscomp$destructuring$var1.a",
"}"));
test("function f({k: {subkey : a}}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var $jscomp$destructuring$var2 = $jscomp$destructuring$var1.k;",
"  var a = $jscomp$destructuring$var2.subkey;",
"}"));
test("function f({k: [x, y, z]}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var $jscomp$destructuring$var2 = $jscomp$destructuring$var1.k;",
"  var x = $jscomp$destructuring$var2[0];",
"  var y = $jscomp$destructuring$var2[1];",
"  var z = $jscomp$destructuring$var2[2];",
"}"));
test("function f({key: x = 5}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var x = $jscomp$destructuring$var1.key === undefined ?",
"      5 : $jscomp$destructuring$var1.key",
"}"));
test("function f({[key]: x = 5}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var $jscomp$destructuring$var2 = $jscomp$destructuring$var1[key]",
"  var x = $jscomp$destructuring$var2 === undefined ?",
"      5 : $jscomp$destructuring$var2",
"}"));
test("function f({x = 5}) {}", Joiner.on('\n').join(
"function f($jscomp$destructuring$var0) {",
"  var $jscomp$destructuring$var1 = $jscomp$destructuring$var0",
"  var x = $jscomp$destructuring$var1.x === undefined ?",
"      5 : $jscomp$destructuring$var1.x",
"}"));
test("var [a,{b,c}] = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var a = $jscomp$destructuring$var0[0];",
"var $jscomp$destructuring$var1 = $jscomp$destructuring$var0[1];",
"var b=$jscomp$destructuring$var1.b;",
"var c=$jscomp$destructuring$var1.c"));
test("var {a,b:[c,d]} = foo();", Joiner.on('\n').join(
"var $jscomp$destructuring$var0 = foo();",
"var a = $jscomp$destructuring$var0.a;",
"var $jscomp$destructuring$var1 = $jscomp$destructuring$var0.b;",
"var c = $jscomp$destructuring$var1[0];",
"var d = $jscomp$destructuring$var1[1]"));
test("tag``", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = [''];",
"$jscomp$templatelit$0['raw'] = [''];",
"tag($jscomp$templatelit$0);"
));
test("tag`${hello} world`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['', ' world'];",
"$jscomp$templatelit$0['raw'] = ['', ' world'];",
"tag($jscomp$templatelit$0, hello);"
));
test("tag`${hello} ${world}`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['', ' ', ''];",
"$jscomp$templatelit$0['raw'] = ['', ' ', ''];",
"tag($jscomp$templatelit$0, hello, world);"
));
test("tag`\"`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['\\\"'];",
"$jscomp$templatelit$0['raw'] = ['\\\"'];",
"tag($jscomp$templatelit$0);"
));
test("tag`a\tb`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['a\tb'];",
"$jscomp$templatelit$0['raw'] = ['a\\tb'];",
"tag($jscomp$templatelit$0);"
));
test("tag()`${hello} world`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['', ' world'];",
"$jscomp$templatelit$0['raw'] = ['', ' world'];",
"tag()($jscomp$templatelit$0, hello);"
));
test("a.b`${hello} world`", Joiner.on('\n').join(
"var $jscomp$templatelit$0 = ['', ' world'];",
"$jscomp$templatelit$0['raw'] = ['', ' world'];",
"a.b($jscomp$templatelit$0, hello);"
));
import com.google.common.base.Joiner;
Joiner.on('\n').join(
"class C {",
"  mv: number;",
"  constructor() {",
"    this.f = 1;",
"  }",
"}"),
Joiner.on('\n').join(
Joiner.on('\n').join(
"class C {",
"  mv: number;",
"}"),
Joiner.on('\n').join(
"class C {",
"  constructor() {",
"    /** @type {number} */ this.mv;",
"  }",
"}"));
Joiner.on('\n').join(
"class C {",
"  static smv;",
"}"),
Joiner.on('\n').join(
"class C {",
"  constructor() {",
"  }",
"}\n",
"C.smv;"));
Joiner.on('\n').join(
"(class {",
"  x: number;",
"})"),
Joiner.on('\n').join(
Joiner.on('\n').join(
Joiner.on('\n').join(
"class C {",
"  static ['smv' + 2]: number;",
"}"),
Joiner.on('\n').join(
"class C {",
"  constructor() {}",
"}",
"/** @type {number} */ C['smv' + 2];"));
import com.google.common.base.Joiner;
assertEarlyReferenceError(Joiner.on('\n').join(
"if (a) {",
"  x = 3;",
"  let x;",
"}"
));
assertEarlyReferenceError(Joiner.on('\n').join(
"var x = 1;",
"if (true) {",
"  x++;",
"  let x = 3;",
"}"
));
assertEarlyReferenceError(Joiner.on('\n').join(
"if (a) {",
"  x = 3;",
"  const x = 3;",
"}"
));
assertEarlyReferenceError(Joiner.on('\n').join(
"var x = 1;",
"if (true) {",
"  x++;",
"  const x = 3;",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"if (a) {",
"  let x;",
"  var x;",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"if (a) {",
"  let x;",
"  let x;",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  let x;",
"  if (a) {",
"    var x;",
"  }",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    let x;",
"  }",
"  var x;",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    let x;",
"  }",
"  if (b) {",
"    var x;",
"  }",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"if (a) {",
"  const x = 3;",
"  var x;",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  const x = 3;",
"  if (a) {",
"    var x;",
"  }",
"}"
));
assertRedeclare(Joiner.on('\n').join(
"if (a) {",
"  var x;",
"  var x;",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"if (a) {",
"  var x;",
"  let x;",
"}"
));
assertRedeclare(Joiner.on('\n').join(
"function f() {",
"  var x;",
"  if (a) {",
"    var x;",
"  }",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    var x;",
"  }",
"  let x;",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function f() {",
"  var x;",
"  if (a) {",
"    let x;",
"  }",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function f() {",
"  if (a) {",
"    var x;",
"  }",
"  if (b) {",
"    let x;",
"  }",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function outer(x) {",
"  function inner() {",
"    let x = 1;",
"  }",
"}"
));
assertNoWarning(Joiner.on('\n').join(
"function outer(x) {",
"  function inner() {",
"    var x = 1;",
"  }",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  try {",
"    let e = 0;",
"    if (true) {",
"      let e = 1;",
"    }",
"  } catch (e) {",
"    let e;",
"  }",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  try {",
"    let e = 0;",
"    if (true) {",
"      let e = 1;",
"    }",
"  } catch (e) {",
"      var e;",
"  }",
"}"
));
assertRedeclareError(Joiner.on('\n').join(
"function f() {",
"  try {",
"    let e = 0;",
"    if (true) {",
"      let e = 1;",
"    }",
"  } catch (e) {",
"    function e() {",
"      var e;",
"    }",
"  }",
"}"
));
import com.google.common.base.Joiner;
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.Bar');",
"",
"/** @constructor @extends {goog.foo.Bar.Inner} */",
"function SubClass() {}");
import com.google.common.base.Joiner;
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('foo.bar.goo');",
"var bar = new foo.bar.goo();");
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.Bar');",
"var bar = new goog.foo.Bar.Baz();");
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.IDBar');",
"var bar = new goog.foo.IDBar.Baz();");
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.Bar');",
"goog.require('goog.foo.Baz');",
"var str = new goog.foo.Bar('g4'),",
"    num = new goog.foo.Baz(5);");
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.Bar');",
"var str = new goog.foo.Bar(new goog.foo.Bar('5'));");
String js = Joiner.on('\n').join(
"var goog = {};",
"goog.require('goog.foo.Bar');",
"",
"/** @constructor @extends {goog.foo.Bar.Inner} */",
"function SubClass() {}");
String js = Joiner.on('\n').join(
"/**",
" * @interface",
" * @extends {some.other.Interface}",
" */",
"function AnInterface() {}");
String localVar = Joiner.on('\n').join(
"/** @constructor */ function tempCtor() {}",
"function baz() {",
"  /** @constructor */ function tempCtor() {}",
"  var foo = new tempCtor();",
"}");
String js = Joiner.on('\n').join(
"var goog = {};",
"/** @constructor */",
"goog.ui.Option = function() {};",
"goog.ui.Option.optionDecorator = function() {",
"  return new goog.ui.Option();",
"};");
String[] js = new String[] {
Joiner.on('\n').join(
"var goog = {};",
"/** @constructor */",
"function Bar() {}",
"/** @suppress {extraRequire} */",
"goog.require('Bar');"),
"var bar = new Bar();"};
String[] js = new String[] {
Joiner.on('\n').join(
"var goog = {};",
"goog.require('Foo');",
"var foo = new Foo();"),
"goog.require('Bar'); var bar = new Bar();"};
String[] js = new String[] {
Joiner.on('\n').join(
"var goog = {};",
"/** @constructor */",
"function Bar() {}",
"/** @suppress {extraRequire} */",
"goog.require('Bar');"),
"var bar = new Bar();"};
String js = Joiner.on('\n').join(
"var goog = {};",
"/** @constructor */goog.Foo = function() {};",
"goog.Foo.bar = function() {",
"  return new this.constructor;",
"};");
Joiner.on('\n').join(
String[] js = new String[]{
Joiner.on('\n').join(
"var goog = {};",
"/** @constructor */",
"goog.Foo = function() {};",
"goog.Foo.bar = function(){",
"  var first = new goog.Forgot();",
"  var second = new goog.Forgot();",
"};")
String js = Joiner.on('\n').join(
"var foo = {};",
"/** @type {function(new:Date)} */",
"foo.bar = Date;",
"new foo.bar();");
String js = Joiner.on('\n').join(
"var foo = {};",
"/** @type {function(new:Date)} */",
"foo.bar = function() {};",
"new foo.bar();");
import com.google.common.base.Joiner;
return Joiner.on("\n").join(parts);
import com.google.common.base.Joiner;
private static final String EXTERNS = Joiner.on("\n").join(
"/** @constructor */",
"var HTMLElement = function() {};",
"/** @constructor @extends {HTMLElement} */",
"var HTMLInputElement = function() {};",
"/** @constructor @extends {HTMLElement} */",
"var PolymerElement = function() {",
"  /** @type {Object} */",
"  this.$;",
"};",
"PolymerElement.prototype.created = function() {};",
"PolymerElement.prototype.ready = function() {};",
"PolymerElement.prototype.attached = function() {};",
"PolymerElement.prototype.domReady = function() {};",
"PolymerElement.prototype.detached = function() {};",
"/**",
" * Call the callback after a timeout. Calling job again with the same name",
" * resets the timer but will not result in additional calls to callback.",
" *",
" * @param {string} name",
" * @param {Function} callback",
" * @param {number} timeoutMillis The minimum delay in milliseconds before",
" *     calling the callback.",
" */",
"PolymerElement.prototype.job = function(name, callback, timeoutMillis) {};",
"/**",
" * @param a {!Object}",
" * @return {!function()}",
" */",
"var Polymer = function(a) {};",
"var alert = function(msg) {};");
private static final String INPUT_EXTERNS = Joiner.on("\n").join(
"/** @constructor */",
"var HTMLElement = function() {};",
"/** @constructor @extends {HTMLElement} */",
"var HTMLInputElement = function() {};",
"/** @constructor @extends {HTMLElement} */",
"var PolymerElement = function() {",
"  /** @type {Object} */",
"  this.$;",
"};",
"/** @constructor @extends {HTMLInputElement} */",
"var PolymerInputElement = function() {",
"  /** @type {Object} */",
"  this.$;",
"};",
"PolymerInputElement.prototype.created = function() {};",
"PolymerInputElement.prototype.ready = function() {};",
"PolymerInputElement.prototype.attached = function() {};",
"PolymerInputElement.prototype.domReady = function() {};",
"PolymerInputElement.prototype.detached = function() {};",
"/**",
" * Call the callback after a timeout. Calling job again with the same name",
" * resets the timer but will not result in additional calls to callback.",
" *",
" * @param {string} name",
" * @param {Function} callback",
" * @param {number} timeoutMillis The minimum delay in milliseconds before",
" *     calling the callback.",
" */",
"PolymerInputElement.prototype.job = function(name, callback, timeoutMillis) {};",
"PolymerElement.prototype.created = function() {};",
"PolymerElement.prototype.ready = function() {};",
"PolymerElement.prototype.attached = function() {};",
"PolymerElement.prototype.domReady = function() {};",
"PolymerElement.prototype.detached = function() {};",
"/**",
" * Call the callback after a timeout. Calling job again with the same name",
" * resets the timer but will not result in additional calls to callback.",
" *",
" * @param {string} name",
" * @param {Function} callback",
" * @param {number} timeoutMillis The minimum delay in milliseconds before",
" *     calling the callback.",
" */",
"PolymerElement.prototype.job = function(name, callback, timeoutMillis) {};",
"/**",
" * @param a {!Object}",
" * @return {!function()}",
" */",
"var Polymer = function(a) {};",
"var alert = function(msg) {};",
"/** @interface */",
"var PolymerXInputElementInterface = function() {};");
private static final String READONLY_EXTERNS = EXTERNS + Joiner.on("\n").join(
"/** @interface */",
"var Polymera_BInterface = function() {};",
"/** @type {!Array<string>} */",
"Polymera_BInterface.prototype.pets;",
"/** @type {string} */",
"Polymera_BInterface.prototype.name;",
"/** @param {!Array<string>} pets **/",
"Polymera_BInterface.prototype._setPets;");
private static final String BEHAVIOR_READONLY_EXTERNS = EXTERNS + Joiner.on("\n").join(
"/** @interface */",
"var PolymerAInterface = function() {};",
"/** @type {boolean} */",
"PolymerAInterface.prototype.isFun;",
"/** @type {!Array} */",
"PolymerAInterface.prototype.pets;",
"/** @type {string} */",
"PolymerAInterface.prototype.name;",
"/** @param {boolean} isFun **/",
"PolymerAInterface.prototype._setIsFun;");
test(Joiner.on("\n").join(
"var X = Polymer({",
"  is: 'x-element',",
"});"),
Joiner.on("\n").join(
"/** @constructor @extends {PolymerElement} @implements {PolymerXInterface} */",
"var X = function() {};",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"});"));
test(Joiner.on("\n").join(
"Polymer({",
"  is: 'x',",
"});"),
Joiner.on("\n").join(
"/**",
" * @implements {PolymerXElementInterface}",
" * @constructor @extends {PolymerElement}",
" */",
"var XElement = function() {};",
"Polymer(/** @lends {XElement.prototype} */ {",
"  is: 'x',",
"});"));
test(Joiner.on("\n").join(
"var x = {};",
"x.Z = Polymer({",
"  is: 'x-element',",
"});"),
Joiner.on("\n").join(
"var x = {};",
"/** @constructor @extends {PolymerElement} @implements {Polymerx_ZInterface} */",
"x.Z = function() {};",
"x.Z = Polymer(/** @lends {x.Z.prototype} */ {",
"  is: 'x-element',",
"});"));
test(Joiner.on("\n").join(
"var x = {};",
"(function() {",
"  x.Z = Polymer({",
"    is: 'x-element',",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"),
Joiner.on("\n").join(
"var x = {};",
"(function() {",
"  /** @constructor @extends {PolymerElement} @implements {Polymerx_ZInterface}*/",
"  x.Z = function() {};",
"  x.Z = Polymer(/** @lends {x.Z.prototype} */ {",
"    is: 'x-element',",
"    /** @this {x.Z} */",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"));
test(Joiner.on("\n").join(
"(function() {",
"  Polymer({",
"    is: 'x',",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"),
Joiner.on("\n").join(
"/**",
" * @constructor @extends {PolymerElement}",
" * @implements {PolymerXElementInterface}",
" */",
"var XElement = function() {};",
"(function() {",
"  Polymer(/** @lends {XElement.prototype} */ {",
"    is: 'x',",
"    /** @this {XElement} */",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"));
test(Joiner.on("\n").join(
"(function() {",
"  var FooThing = Polymer({",
"    is: 'x',",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"),
Joiner.on("\n").join(
"/**",
" * @constructor @extends {PolymerElement}",
" * @implements {PolymerFooThingInterface}",
" */",
"var FooThing = function() {};",
"(function() {",
"  FooThing = Polymer(/** @lends {FooThing.prototype} */ {",
"    is: 'x',",
"    /** @this {FooThing} */",
"    sayHi: function() { alert('hi'); },",
"  });",
"})()"));
test(Joiner.on("\n").join(
"var X = Polymer({",
"  is: 'x-element',",
"  /**",
"   * @param {string} name",
"   */",
"  factoryImpl: function(name) { alert('hi, ' + name); },",
"});"),
Joiner.on("\n").join(
"/**",
" * @param {string} name",
" * @constructor @extends {PolymerElement}",
" * @implements {PolymerXInterface}",
" */",
"var X = function(name) { alert('hi, ' + name); };",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"  factoryImpl: function(name) { alert('hi, ' + name); },",
"});"));
test(Joiner.on("\n").join(
"var X = Polymer({",
"  is: 'x-element',",
"  listeners: {",
"    'click': 'handleClick',",
"  },",
"",
"  handleClick: function(e) {",
"    alert('Thank you for clicking');",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor @extends {PolymerElement} @implements {PolymerXInterface}*/",
"var X = function() {};",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"  listeners: {",
"    'click': 'handleClick',",
"  },",
"",
"  /** @this {X} */",
"  handleClick: function(e) {",
"    alert('Thank you for clicking');",
"  },",
"});"));
String js = Joiner.on("\n").join(
"Polymer({",
"  is: 'x-input',",
"  extends: 'input',",
"});");
test(js,
Joiner.on("\n").join(
"/**",
" * @constructor @extends {PolymerInputElement}",
" * @implements {PolymerXInputElementInterface}",
" */",
"var XInputElement = function() {};",
"Polymer(/** @lends {XInputElement.prototype} */ {",
"  is: 'x-input',",
"  extends: 'input',",
"});"));
String js = Joiner.on("\n").join(
"Polymer({",
"  is: 'x-input',",
"  extends: 'input',",
"});",
"Polymer({",
"  is: 'y-input',",
"  extends: 'input',",
"});");
String newExterns = INPUT_EXTERNS + "\n" + Joiner.on("\n").join(
"/** @interface */",
"var PolymerYInputElementInterface = function() {};");
test(Joiner.on("\n").join(
"/** @constructor */",
"var User = function() {};",
"var a = {};",
"a.B = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    /** @type {!User} @private */",
"    user_: Object,",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"    thingToDo: Function,",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor */",
"var User = function() {};",
"var a = {};",
"/** @constructor @extends {PolymerElement} @implements {Polymera_BInterface}*/",
"a.B = function() {};",
"/** @type {!User} @private */",
"a.B.prototype.user_;",
"/** @type {!Array} */",
"a.B.prototype.pets;",
"/** @type {string} */",
"a.B.prototype.name;",
"/** @type {!Function} */",
"a.B.prototype.thingToDo;",
"a.B = Polymer(/** @lends {a.B.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    user_: Object,",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"    thingToDo: Function,",
"  },",
"});"));
test(Joiner.on("\n").join(
"/** @constructor */",
"var User = function() {};",
"var a = {};",
"a.B = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    /** @type {!User} @private */",
"    user_: {",
"      type: Object,",
"      value: function() { return new User(); },",
"    },",
"    pets: {",
"      type: Array,",
"      notify: true,",
"      value: function() { return [this.name]; },",
"    },",
"    name: String,",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor */",
"var User = function() {};",
"var a = {};",
"/** @constructor @extends {PolymerElement} @implements {Polymera_BInterface}*/",
"a.B = function() {};",
"/** @type {!User} @private */",
"a.B.prototype.user_;",
"/** @type {!Array} */",
"a.B.prototype.pets;",
"/** @type {string} */",
"a.B.prototype.name;",
"a.B = Polymer(/** @lends {a.B.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    user_: {",
"      type: Object,",
"      /** @this {a.B} @return {!User} */",
"      value: function() { return new User(); },",
"    },",
"    pets: {",
"      type: Array,",
"      notify: true,",
"      /** @this {a.B} @return {!Array} */",
"      value: function() { return [this.name]; },",
"    },",
"    name: String,",
"  },",
"});"));
String js = Joiner.on("\n").join(
"var a = {};",
"a.B = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    /** @type {!Array<string>} */",
"    pets: {",
"      type: Array,",
"      readOnly: true,",
"    },",
"    name: String,",
"  },",
"});");
test(js,
Joiner.on("\n").join(
"var a = {};",
"/** @constructor @extends {PolymerElement} @implements {Polymera_BInterface} */",
"a.B = function() {};",
"/** @type {!Array<string>} */",
"a.B.prototype.pets;",
"/** @type {string} */",
"a.B.prototype.name;",
"/** @override */",
"a.B.prototype._setPets = function(pets) {};",
"a.B = Polymer(/** @lends {a.B.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      readOnly: true,",
"    },",
"    name: String,",
"  },",
"});"));
test(Joiner.on("\n").join(
"var X = Polymer({",
"  is: 'x-element',",
"  sayHi: function() {",
"    alert('hi');",
"  },",
"  /** @override */",
"  created: function() {",
"    this.sayHi();",
"    this.sayHelloTo_('Tester');",
"  },",
"  /**",
"   * @param {string} name",
"   * @private",
"   */",
"  sayHelloTo_: function(name) {",
"    alert('Hello, ' + name);",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor @extends {PolymerElement} @implements {PolymerXInterface} */",
"var X = function() {};",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"  /** @this {X} */",
"  sayHi: function() {",
"    alert('hi');",
"  },",
"  /** @override @this {X} */",
"  created: function() {",
"    this.sayHi();",
"    this.sayHelloTo_('Tester');",
"  },",
"  /**",
"   * @param {string} name",
"   * @private",
"   * @this {X}",
"   */",
"  sayHelloTo_: function(name) {",
"    alert('Hello, ' + name);",
"  },",
"});"));
test(Joiner.on("\n").join(
"/** @constructor */",
"var SomeType = function() {};",
"SomeType.prototype.toggle = function() {};",
"SomeType.prototype.switch = function() {};",
"SomeType.prototype.touch = function() {};",
"var X = Polymer({",
"  is: 'x-element',",
"  sayHi: function() {",
"    this.$.checkbox.toggle();",
"  },",
"  /** @override */",
"  created: function() {",
"    this.sayHi();",
"    this.$.radioButton.switch();",
"  },",
"  /**",
"   * @param {string} name",
"   * @private",
"   */",
"  sayHelloTo_: function(name) {",
"    this.$.otherThing.touch();",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor */",
"var SomeType = function() {};",
"SomeType.prototype.toggle = function() {};",
"SomeType.prototype.switch = function() {};",
"SomeType.prototype.touch = function() {};",
"/** @constructor @extends {PolymerElement} @implements {PolymerXInterface} */",
"var X = function() {};",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"  /** @this {X} */",
"  sayHi: function() {",
"    this.$['checkbox'].toggle();",
"  },",
"  /** @override @this {X} */",
"  created: function() {",
"    this.sayHi();",
"    this.$['radioButton'].switch();",
"  },",
"  /**",
"   * @param {string} name",
"   * @private",
"   * @this {X}",
"   */",
"  sayHelloTo_: function(name) {",
"    this.$['otherThing'].touch();",
"  },",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    /** @type {boolean} */",
"    isFun: {",
"      type: Boolean,",
"      value: true,",
"    }",
"  },",
"  /** @type {string} */",
"  foo: 'hooray',",
"",
"  /** @return {number} */",
"  get someNumber() {",
"    return 5*7+2;",
"  },",
"  /** @param {string} funAmount */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @override */",
"  created: function() {}",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: {",
"      type: Boolean,",
"      value: true,",
"    }",
"  },",
"  /** @type {string} */",
"  foo: 'hooray',",
"",
"  /** @suppress {checkTypes|globalThis} */",
"  get someNumber() {",
"    return 5*7+2;",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {",
"  alert('Something ' + funAmount + ' fun!');",
"};",
"/** @type {string} */",
"A.prototype.foo;",
"/** @type {number} */",
"A.prototype.someNumber;",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    /** @type {boolean} */",
"    isFun: {",
"      type: Boolean,",
"      value: true,",
"    },",
"    funObject: {",
"      type: Object,",
"      value: function() { return {fun: this.isFun }; },",
"    },",
"    funArray: {",
"      type: Array,",
"      value: function() { return [this.isFun]; },",
"    },",
"  },",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: {",
"      type: Boolean,",
"      value: true,",
"    },",
"    funObject: {",
"      type: Object,",
"      /** @suppress {checkTypes|globalThis} */",
"      value: function() { return {fun: this.isFun }; },",
"    },",
"    funArray: {",
"      type: Array,",
"      /** @suppress {checkTypes|globalThis} */",
"      value: function() { return [this.isFun]; },",
"    },",
"  },",
"};",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {!Object} */",
"A.prototype.funObject;",
"/** @type {!Array} */",
"A.prototype.funArray;",
"/** @type {string} */",
"A.prototype.name;",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @param {string} funAmount */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @override */",
"  created: function() {}",
"};",
"/** @polymerBehavior */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @param {number} radAmount */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @override */",
"  ready: function() {}",
"};",
"/** @polymerBehavior */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"/** @polymerBehavior */",
"var BoringBehavior = {",
"  properties: {",
"    boringString: String",
"  },",
"  /** @param {boolean} boredYet */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.boringString); },",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, BoringBehavior ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  ready: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"/** @polymerBehavior @nocollapse */",
"var BoringBehavior = {",
"  properties: {",
"    boringString: String",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.boringString); },",
"};",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {number} */",
"A.prototype.howRad;",
"/** @type {string} */",
"A.prototype.boringString;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {",
"  alert('Something ' + funAmount + ' fun!');",
"};",
"/** @param {number} radAmount */",
"A.prototype.doSomethingRad = function(radAmount) {",
"  alert('Something ' + radAmount + ' rad!');",
"};",
"/** @param {boolean} boredYet */",
"A.prototype.doSomething = function(boredYet) {",
"  alert(boredYet + ' ' + this.boringString);",
"};",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, BoringBehavior ],",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @param {string} funAmount */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @override */",
"  created: function() {}",
"};",
"/** @polymerBehavior */",
"var SuperCoolBehaviors = [FunBehavior, {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @param {number} radAmount */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @override */",
"  ready: function() {}",
"}];",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var SuperCoolBehaviors = [FunBehavior, {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  ready: function() {}",
"}];",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {number} */",
"A.prototype.howRad;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {",
"  alert('Something ' + funAmount + ' fun!');",
"};",
"/** @param {number} radAmount */",
"A.prototype.doSomethingRad = function(radAmount) {",
"  alert('Something ' + radAmount + ' rad!');",
"};",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors ],",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @param {boolean} boredYet */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.isFun); },",
"  /** @override */",
"  created: function() {}",
"};",
"/** @polymerBehavior */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @param {boolean} boredYet */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.howRad); },",
"  /** @override */",
"  ready: function() {}",
"};",
"/** @polymerBehavior */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"/** @polymerBehavior */",
"var BoringBehavior = {",
"  properties: {",
"    boringString: String",
"  },",
"  /** @param {boolean} boredYet */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.boringString); },",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, BoringBehavior ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.isFun); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.howRad); },",
"  /** @suppress {checkTypes|globalThis} */",
"  ready: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"/** @polymerBehavior @nocollapse */",
"var BoringBehavior = {",
"  properties: {",
"    boringString: String",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomething: function(boredYet) { alert(boredYet + ' ' + this.boringString); },",
"};",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {number} */",
"A.prototype.howRad;",
"/** @type {string} */",
"A.prototype.boringString;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {boolean} boredYet */",
"A.prototype.doSomething = function(boredYet) {",
"  alert(boredYet + ' ' + this.boringString);",
"};",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, BoringBehavior ],",
"});"));
String js = Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    isFun: {",
"      type: Boolean,",
"      readOnly: true,",
"    },",
"  },",
"  /** @param {string} funAmount */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @override */",
"  created: function() {}",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});");
test(js,
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: {",
"      type: Boolean,",
"      readOnly: true,",
"    },",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {",
"  alert('Something ' + funAmount + ' fun!');",
"};",
"/** @override */",
"A.prototype._setIsFun = function(isFun) {};",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ FunBehavior ],",
"});"));
test(Joiner.on("\n").join(
"(function() {",
"  /** @polymerBehavior */",
"  Polymer.FunBehavior = {",
"    properties: {",
"      /** @type {boolean} */",
"      isFun: {",
"        type: Boolean,",
"        value: true,",
"      }",
"    },",
"    /** @type {string} */",
"    foo: 'hooray',",
"    /** @return {number} */",
"    get someNumber() {",
"      return 5*7+2;",
"    },",
"    /** @param {string} funAmount */",
"    doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"    /** @override */",
"    created: function() {}",
"  };",
"})();",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ Polymer.FunBehavior ],",
"});"),
Joiner.on("\n").join(
"(function() {",
"  /** @polymerBehavior @nocollapse */",
"  Polymer.FunBehavior = {",
"    properties: {",
"      isFun: {",
"        type: Boolean,",
"        value: true,",
"      }",
"    },",
"    /** @type {string} */",
"    foo: 'hooray',",
"    /** @suppress {checkTypes|globalThis} */",
"    get someNumber() {",
"      return 5*7+2;",
"    },",
"    /** @suppress {checkTypes|globalThis} */",
"    doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"    /** @suppress {checkTypes|globalThis} */",
"    created: function() {}",
"  };",
"})();",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {};",
"/** @type {string} */",
"A.prototype.foo;",
"/** @type {number} */",
"A.prototype.someNumber;",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ Polymer.FunBehavior ],",
"});"));
test(Joiner.on("\n").join(
"/** @polymerBehavior */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @param {string} funAmount */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @override */",
"  created: function() {}",
"};",
"",
"/** @polymerBehavior */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @param {number} radAmount */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @override */",
"  ready: function() {}",
"};",
"",
"/** @polymerBehavior */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"var A = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, FunBehavior ],",
"});"),
Joiner.on("\n").join(
"/** @polymerBehavior @nocollapse */",
"var FunBehavior = {",
"  properties: {",
"    isFun: Boolean",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingFun: function(funAmount) { alert('Something ' + funAmount + ' fun!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  created: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var RadBehavior = {",
"  properties: {",
"    howRad: Number",
"  },",
"  /** @suppress {checkTypes|globalThis} */",
"  doSomethingRad: function(radAmount) { alert('Something ' + radAmount + ' rad!'); },",
"  /** @suppress {checkTypes|globalThis} */",
"  ready: function() {}",
"};",
"/** @polymerBehavior @nocollapse */",
"var SuperCoolBehaviors = [FunBehavior, RadBehavior];",
"/** @constructor @extends {PolymerElement} @implements {PolymerAInterface}*/",
"var A = function() {};",
"/** @type {number} */",
"A.prototype.howRad;",
"/** @type {boolean} */",
"A.prototype.isFun;",
"/** @type {!Array} */",
"A.prototype.pets;",
"/** @type {string} */",
"A.prototype.name;",
"/** @param {number} radAmount */",
"A.prototype.doSomethingRad = function(radAmount) {",
"  alert('Something ' + radAmount + ' rad!');",
"};",
"/** @param {string} funAmount */",
"A.prototype.doSomethingFun = function(funAmount) {",
"  alert('Something ' + funAmount + ' fun!');",
"};",
"A = Polymer(/** @lends {A.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    pets: {",
"      type: Array,",
"      notify: true,",
"    },",
"    name: String,",
"  },",
"  behaviors: [ SuperCoolBehaviors, FunBehavior ],",
"});"));
Joiner.on("\n").join(
"Polymer({",
"  is: 'x-element',",
"  properties: {",
"    isHappy: true,",
"  },",
"});"),
POLYMER_INVALID_PROPERTY, true);
Joiner.on("\n").join(
"Polymer({",
"  is: 'x-element',",
"  properties: {",
"    isHappy: {",
"      value: true,",
"    },",
"  },",
"});"),
POLYMER_INVALID_PROPERTY, true);
Joiner.on("\n").join(
"(function() {",
"  var isNotGloabl = {};",
"  Polymer({",
"    is: 'x-element',",
"    behaviors: [",
"      isNotGlobal",
"    ],",
"  });",
"})();"),
POLYMER_UNQUALIFIED_BEHAVIOR, true);
Joiner.on("\n").join(
"var foo = {};",
"(function() {",
"  Polymer({",
"    is: 'x-element',",
"    behaviors: [",
"      foo.IsNotDefined",
"    ],",
"  });",
"})();"),
POLYMER_UNQUALIFIED_BEHAVIOR, true);
Joiner.on("\n").join(
"var foo = {};",
"foo.Bar;",
"(function() {",
"  Polymer({",
"    is: 'x-element',",
"    behaviors: [",
"      foo.Bar",
"    ],",
"  });",
"})();"),
POLYMER_UNQUALIFIED_BEHAVIOR, true);
Joiner.on("\n").join(
"Polymer({",
"  is: 'x-element',",
"  behaviors: [",
"    DoesNotExist",
"  ],",
"});"),
POLYMER_UNQUALIFIED_BEHAVIOR, true);
testError(Joiner.on("\n").join(
"var FunBehavior = {",
"  /** @override */",
"  created: function() {}",
"};",
"var A = Polymer({",
"  is: 'x-element',",
"  behaviors: [ FunBehavior ],",
"});"),
Joiner.on("\n").join(
"var X = Polymer({",
"  is: 'x-element',",
"  properties: {",
"    isHappy: Boolean,",
"  },",
"  /** @override */",
"  created: function() {",
"    this.isHappy = 7;",
"  },",
"});"),
Joiner.on("\n").join(
"/** @constructor @extends {PolymerElement} @implements {PolymerXInterface} */",
"var X = function() {};",
"/** @type {boolean} */",
"X.prototype.isHappy;",
"X = Polymer(/** @lends {X.prototype} */ {",
"  is: 'x-element',",
"  properties: {",
"    isHappy: Boolean,",
"  },",
"  /** @override @this {X} */",
"  created: function() {",
"    this.isHappy = 7;",
"  },",
"});"),
import com.google.common.base.Joiner;
test("import name from 'test'; use(name);", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$test');",
"use(module$test.default);"
));
test("import x, {f as foo, b as bar} from 'test'; use(x);", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$test');",
"use(module$test.default);"
));
test("export var a = 1, b = 2;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var a$$module$testcode = 1, b$$module$testcode = 2;",
"var module$testcode = {};",
"module$testcode.a = a$$module$testcode;",
"module$testcode.b = b$$module$testcode;"
));
test("export var a; export var b;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var a$$module$testcode; var b$$module$testcode;",
"var module$testcode = {};",
"module$testcode.a = a$$module$testcode;",
"module$testcode.b = b$$module$testcode;"
));
test("export function f() {};", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"function f$$module$testcode() {}",
"var module$testcode = {};",
"module$testcode.f = f$$module$testcode;"
));
test("export function f() {}; function g() { f(); }", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"function f$$module$testcode() {}",
"function g$$module$testcode() { f$$module$testcode(); }",
"var module$testcode = {};",
"module$testcode.f = f$$module$testcode;"
));
test(
Joiner.on('\n').join(
"export function MyClass() {};",
"MyClass.prototype.foo = function() {};"),
Joiner.on('\n').join(
"module$testcode.MyClass = MyClass$$module$testcode;"
));
Joiner.on('\n').join(
test("/** @constructor */ export function F() { return '';}",
Joiner.on('\n').join(
test("/** @return {string} */ export function f() { return '';}",
Joiner.on('\n').join(
test("/** @return {string} */ export var f = function() { return '';}",
Joiner.on('\n').join(
test("/** @type {number} */ export var x = 3",
Joiner.on('\n').join(
test(Joiner.on('\n').join(
"import {name as n} from 'other';",
"use(n);",
"export {n as name};"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('module$other');",
"use(module$other.name);",
"var module$testcode = {};",
"module$testcode.name = module$other.name;"
));
test("export {name} from 'other';", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('module$other');",
"var module$testcode={};",
"module$testcode.name = module$other.name;"));
test("export {a, b as c, d} from 'other';", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('module$other');",
"var module$testcode={};",
"module$testcode.a = module$other.a;",
"module$testcode.c = module$other.b;",
"module$testcode.d = module$other.d;"));
test("export default 'someString';", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var $jscompDefaultExport$$module$testcode = 'someString';",
"var module$testcode={};",
"module$testcode.default = $jscompDefaultExport$$module$testcode;"));
test("var x = 5; export default x;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var x$$module$testcode = 5;",
"var $jscompDefaultExport$$module$testcode = x$$module$testcode;",
"var module$testcode={};",
"module$testcode.default = $jscompDefaultExport$$module$testcode;"));
test("export default function f(){}; var x = f();", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"function f$$module$testcode() {}",
"var x$$module$testcode = f$$module$testcode();",
"var module$testcode = {};",
"module$testcode.default = f$$module$testcode;"));
test("export default class Foo {}; var x = new Foo;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"class Foo$$module$testcode {}",
"var x$$module$testcode = new Foo$$module$testcode;",
"var module$testcode = {};",
"module$testcode.default = Foo$$module$testcode;"));
test("export default class {};", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var $jscompDefaultExport$$module$testcode = class {};",
"var module$testcode = {};",
"module$testcode.default = $jscompDefaultExport$$module$testcode;"));
test("export default function() {}", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var $jscompDefaultExport$$module$testcode = function() {}",
"var module$testcode = {};",
"module$testcode.default = $jscompDefaultExport$$module$testcode;"));
test(Joiner.on('\n').join(
"import {Parent} from 'parent';",
"class Child extends Parent {",
"  /** @param {Parent} parent */",
"  useParent(parent) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$parent');",
"class Child$$module$testcode extends module$parent.Parent {",
"  /** @param {Parent$$module$parent} parent */",
"  useParent(parent) {}",
"}"
));
test(Joiner.on('\n').join(
"import {Parent} from 'parent';",
"class Child extends Parent {",
"  /** @param {./parent.Parent} parent */",
"  useParent(parent) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$parent');",
"class Child$$module$testcode extends module$parent.Parent {",
"  /** @param {module$parent.Parent} parent */",
"  useParent(parent) {}",
"}"
));
test(Joiner.on('\n').join(
"import {Parent} from 'parent';",
"export class Child extends Parent {",
"  /** @param {Parent} parent */",
"  useParent(parent) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('module$parent');",
"class Child$$module$testcode extends module$parent.Parent {",
"  /** @param {Parent$$module$parent} parent */",
"  useParent(parent) {}",
"}",
"var module$testcode = {};",
"/** @const */ module$testcode.Child = Child$$module$testcode;"
));
test(Joiner.on('\n').join(
"export class Child {",
"  /** @param {Child} child */",
"  useChild(child) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"class Child$$module$testcode {",
"  /** @param {Child$$module$testcode} child */",
"  useChild(child) {}",
"}",
"var module$testcode = {};",
"/** @const */ module$testcode.Child = Child$$module$testcode;"
));
test(Joiner.on('\n').join(
"export class Child {",
"  /** @param {Child.Foo.Bar.Baz} baz */",
"  useBaz(baz) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"class Child$$module$testcode {",
"  /** @param {Child$$module$testcode.Foo.Bar.Baz} baz */",
"  useBaz(baz) {}",
"}",
"var module$testcode = {};",
"/** @const */ module$testcode.Child = Child$$module$testcode;"
));
test(Joiner.on('\n').join(
"export class Foo {",
"  /** @param {./other.Baz} baz */",
"  useBaz(baz) {}",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"class Foo$$module$testcode {",
"  /** @param {module$other.Baz} baz */",
"  useBaz(baz) {}",
"}",
"var module$testcode = {};",
"/** @const */ module$testcode.Foo = Foo$$module$testcode;"
));
test(Joiner.on('\n').join(
"import 'other';",
"/** @typedef {string|!Object} */",
"export var UnionType;"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('module$other');",
"/** @typedef {string|!Object} */",
"var UnionType$$module$testcode;",
"var module$testcode = {};",
"/** @typedef {UnionType$$module$testcode} */",
"module$testcode.UnionType;"
));
test(Joiner.on('\n').join(
"import {f} from 'test';",
"import {b as bar} from 'test';",
"f();",
"function g() {",
"  f();",
"  bar++;",
"  function h() {",
"    var f = 3;",
"    { let f = 4; }",
"  }",
"}"
), Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$test');",
"module$test.f();",
"function g$$module$testcode() {",
"  module$test.f();",
"  module$test.b++;",
"  function h() {",
"    var f = 3;",
"    { let f = 4; }",
"  }",
"}"
));
test("goog.require('foo.bar'); export var x;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('foo.bar');",
"var x$$module$testcode;",
"var module$testcode = {};",
"module$testcode.x = x$$module$testcode"));
test("export var x; goog.require('foo.bar');", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var x$$module$testcode;",
"goog.require('foo.bar');",
"var module$testcode = {};",
"module$testcode.x = x$$module$testcode"));
test("var bar = goog.require('foo.bar'); export var x;", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"goog.require('foo.bar');",
"var bar$$module$testcode = foo.bar;",
"var x$$module$testcode;",
"var module$testcode = {};",
"module$testcode.x = x$$module$testcode"));
test("export var x; var bar = goog.require('foo.bar');", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.provide('module$testcode');",
"var x$$module$testcode;",
"goog.require('foo.bar');",
"var bar$$module$testcode = foo.bar;",
"var module$testcode = {};",
"module$testcode.x = x$$module$testcode"));
test("import * as s from 'someplace'; var bar = goog.require('foo.bar');", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$someplace');",
"goog.require('foo.bar');",
"var bar$$module$testcode = foo.bar;"));
test("var bar = goog.require('foo.bar'); import * as s from 'someplace';", Joiner.on('\n').join(
FILEOVERVIEW,
"goog.require('module$someplace');",
"goog.require('foo.bar');",
"var bar$$module$testcode = foo.bar;"));
import com.google.common.base.Joiner;
testScoped(Joiner.on('\n').join(
"var Foo = goog.Foo;",
"goog.x = {",
"  /** @param {Foo} foo */",
"  y: function(foo) { }",
"};"),
testScoped(Joiner.on('\n').join(
"var Foo = goog.Foo;",
"goog.x = {",
"  y:",
"  /** @param {Foo} foo */ function(foo) {}",
"};"),
testScoped(Joiner.on('\n').join(
"var Foo = goog.Foo;",
"goog.x = {",
"  y:",
"  /** @type {function(Foo)} */ (function(foo) {})",
"};"),
String externs = Joiner.on('\n').join(
"var ns;",
"/** @constructor */",
"ns.Foo;",
"",
"var goog;",
"/** @param {function()} fn */",
"goog.scope = function(fn) {}");
String js = Joiner.on('\n').join(
"goog.scope(function() {",
"  var Foo = ns.Foo;",
"  var x = {",
"    /** @param {Foo} foo */ y: function(foo) {}",
"  };",
"  x.y('');",
"});");
js = Joiner.on('\n').join(
"goog.scope(function() {",
"  var Foo = ns.Foo;",
"  var x = {",
"    y: /** @param {Foo} foo */ function(foo) {}",
"  };",
"  x.y('');",
"});");
String js = Joiner.on('\n').join(
"goog.scope(function () {",
"  /** @constructor */ function F() {}",
"  /** @return {F} */ function createFoo() { return 1; }",
"});");
import com.google.common.base.Joiner;
Joiner.on('\n').join(
"class Foo {",
"  /** @param {number} x */",
"  constructor(x) {}",
"}"));
Joiner.on('\n').join(
"class Foo {",
"  /** @constructor */",
"  constructor() {}",
"}"),
Joiner.on('\n').join(
"class Foo {",
"  /** @interface */",
"  constructor() {}",
"}"),
Joiner.on('\n').join(
"class Foo {",
"  /** @extends {Foo} */",
"  constructor() {}",
"}"),
Joiner.on('\n').join(
"class Foo {",
"  /** @implements {Foo} */",
"  constructor() {}",
"}"),
Joiner.on('\n').join(
testSame(Joiner.on('\n').join(
"/**",
" * @param {string} x",
" * @param {string} y",
" */",
"function f(x, y) {}"));
testSame(Joiner.on('\n').join(
"/** @override */",
"Foo.bar = function(x, y) {}"));
Joiner.on('\n').join(
"X.prototype.foo_ = function() { return 0; }"),
MUST_BE_PRIVATE);
testSame(Joiner.on('\n').join(
"/**",
" * @return {number}",
" * @private",
" */",
"X.prototype.foo_ = function() { return 0; }"));
Joiner.on('\n').join(
"/**",
" * @param {number=} n",
" */",
"function f(n) {}"),
Joiner.on('\n').join(
"/**",
" * @param {number} opt_n",
" */",
"function f(opt_n) {}"),
testSame(
Joiner.on('\n').join(
"/**",
" * @param {number=} opt_n",
" */",
"function f(opt_n) {}"));
if (NodeUtil.isFunctionBind(parent) && !NodeUtil.isGoogPartial(parent)) {
Node call = parent.isCall() ? parent : parent.getParent();
if (NodeUtil.isGoogBind(call) && call.getChildCount() <= 2
|| !NodeUtil.isGoogPartial(call) && call.getChildCount() == 1) {
return n.isCall()
&& n.getFirstChild().isQualifiedName()
&& n.getFirstChild().matchesQualifiedName("goog.bind");
return n.isCall()
&& n.getFirstChild().isQualifiedName()
&& n.getFirstChild().matchesQualifiedName("goog.partial");
if (expr.isCall()) {
expr = expr.getFirstChild();
if (isGoogBind(expr.getParent()) || isGoogPartial(expr.getParent())) {
Preconditions.checkState(!this.classProps.containsKey(pname));
Preconditions.checkState(!this.protoProps.containsKey(pname));
if (this.rawType.typeParameters.isEmpty()) {
hasUnified = hasUnified && typeMap.get(typeParam).unifyWithSubtype(
other.typeMap.get(typeParam), typeParameters, typeMultimap);
return hasUnified;
if (!firstIteration) {
+ "function f(/** (Array.<string>|Foo) */ o) {\n"
+ " * @param {!Array.<T>|!Foo.<T>} arr\n"
+ " * @param {Array.<T>} arr\n"
+ " * @param {Array.<T>} arr\n"
+ " * @param {U|!Array.<T>} arr\n"
+ " * @param {U|!Array.<T>} arr\n"
+ " * @param {!Map.<K, (V | !Box.<V>)>} inMap\n"
+ "/** @return {(boolean |!Box.<boolean>)} */\n"
+ "/** @param {!WrappedMap.<string, boolean>} x */\n"
assertEquals("/**@return {number|string} */", JSDocInfoPrinter.print(info));
JsDocInfoParser.parseTypeString("!Array.<number|string>"), ""));
"/**@type {!Array.<number|string>} */", JSDocInfoPrinter.print(info));
return this.symbolTable;
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.jscomp.newtypes.FunctionType;
import com.google.javascript.jscomp.newtypes.JSType;
import com.google.javascript.jscomp.newtypes.JSTypes;
import com.google.javascript.jscomp.newtypes.NominalType;
import com.google.javascript.jscomp.newtypes.ObjectType;
import com.google.javascript.jscomp.newtypes.QualifiedName;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.TypeI;
import com.google.javascript.rhino.jstype.FunctionBuilder;
import com.google.javascript.rhino.jstype.FunctionParamBuilder;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.UnionTypeBuilder;
import java.util.HashMap;
import java.util.Map;
public final class ConvertNewTypesToOld extends AbstractPostOrderCallback implements CompilerPass {
private final AbstractCompiler compiler;
private final JSTypeRegistry registry;
private final JSTypes commonTypes;
private final com.google.javascript.rhino.jstype.JSType OLD_UNKNOWN_FUNCTION_TYPE;
private final com.google.javascript.rhino.jstype.JSType OLD_UNKNOWN_TYPE;
private Node currentNode;
private final Map<JSType, com.google.javascript.rhino.jstype.JSType> cachedTypes =
new HashMap<>();
private final Map<NominalType, com.google.javascript.rhino.jstype.FunctionType> cachedNomTypes =
new HashMap<>();
ConvertNewTypesToOld(AbstractCompiler compiler) {
this.compiler = compiler;
this.registry = compiler.getTypeRegistry();
this.commonTypes = compiler.getSymbolTable().getTypesUtilObject();
this.OLD_UNKNOWN_FUNCTION_TYPE = registry.getNativeType(JSTypeNative.U2U_FUNCTION_TYPE);
this.OLD_UNKNOWN_TYPE = registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);
com.google.javascript.rhino.jstype.JSType oldNativeType;
oldNativeType = registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
JSType.BOOLEAN.setOldType(oldNativeType);
cachedTypes.put(JSType.BOOLEAN, oldNativeType);
JSType.TRUE_TYPE.setOldType(oldNativeType);
cachedTypes.put(JSType.TRUE_TYPE, oldNativeType);
JSType.FALSE_TYPE.setOldType(oldNativeType);
cachedTypes.put(JSType.FALSE_TYPE, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NO_TYPE);
JSType.BOTTOM.setOldType(oldNativeType);
cachedTypes.put(JSType.BOTTOM, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NULL_TYPE);
JSType.NULL.setOldType(oldNativeType);
cachedTypes.put(JSType.NULL, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.NUMBER_TYPE);
JSType.NUMBER.setOldType(oldNativeType);
cachedTypes.put(JSType.NUMBER, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.STRING_TYPE);
JSType.STRING.setOldType(oldNativeType);
cachedTypes.put(JSType.STRING, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.ALL_TYPE);
JSType.TOP.setOldType(oldNativeType);
cachedTypes.put(JSType.TOP, oldNativeType);
oldNativeType = registry.getNativeType(JSTypeNative.VOID_TYPE);
JSType.UNDEFINED.setOldType(oldNativeType);
cachedTypes.put(JSType.UNDEFINED, oldNativeType);
JSType.UNKNOWN.setOldType(OLD_UNKNOWN_TYPE);
cachedTypes.put(JSType.UNKNOWN, OLD_UNKNOWN_TYPE);
commonTypes.topFunction().setOldType(OLD_UNKNOWN_FUNCTION_TYPE);
cachedTypes.put(commonTypes.topFunction(), OLD_UNKNOWN_FUNCTION_TYPE);
commonTypes.qmarkFunction().setOldType(OLD_UNKNOWN_FUNCTION_TYPE);
cachedTypes.put(commonTypes.qmarkFunction(), OLD_UNKNOWN_FUNCTION_TYPE);
public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, externs, this);
NodeTraversal.traverse(compiler, root, this);
compiler.setSymbolTable(null);
public void visit(NodeTraversal t, Node n, Node parent) {
TypeI ti = n.getTypeI();
if (ti instanceof com.google.javascript.rhino.jstype.JSType) {
return;
JSType newType = (JSType) ti;
if (newType != null) {
this.currentNode = n;
n.setTypeI(convertNewTypeToOld(newType));
private com.google.javascript.rhino.jstype.JSType convertNewTypeToOld(JSType newType) {
if (newType == null) {
return null;
com.google.javascript.rhino.jstype.JSType oldType =
(com.google.javascript.rhino.jstype.JSType) newType.getOldType();
if (cachedTypes.containsKey(newType)) {
return cachedTypes.get(newType);
if (newType.isUnion()) {
oldType = convertUnionType(newType);
FunctionType ft = newType.getFunTypeIfSingletonObj();
if (ft != null) {
oldType = convertFunctionType(ft);
return OLD_UNKNOWN_TYPE;
ObjectType ot = newType.getObjectTypeIfSingletonObj();
Preconditions.checkNotNull(ot, "Null object type for JSType: %s", newType);
oldType = convertObjectType(ot);
newType.setOldType(oldType);
return oldType;
private com.google.javascript.rhino.jstype.JSType convertUnionType(JSType newType) {
UnionTypeBuilder builder = new UnionTypeBuilder(this.registry);
for (JSType alternate : newType.getAlternates()) {
builder.addAlternate(convertNewTypeToOld(alternate));
return builder.build();
private com.google.javascript.rhino.jstype.JSType convertObjectType(ObjectType ot) {
NominalType nt = ot.getNominalType();
if (nt == null) {
com.google.javascript.rhino.jstype.ObjectType oldObject =
this.registry.createAnonymousObjectType(NodeUtil.getBestJSDocInfo(currentNode));
for (String pname : ot.getAllOwnProps()) {
QualifiedName qname = new QualifiedName(pname);
JSType ptype = ot.getDeclaredProp(qname);
if (ptype == null) {
ptype = ot.getProp(qname);
Preconditions.checkNotNull(ptype);
oldObject.defineInferredProperty(pname, convertNewTypeToOld(ptype), null);
oldObject.defineDeclaredProperty(pname, convertNewTypeToOld(ptype), null);
Node defSite = ot.getPropDefsite(qname);
if (defSite != null) {
oldObject.setPropertyNode(pname, defSite);
oldObject.setPropertyJSDocInfo(pname, NodeUtil.getBestJSDocInfo(defSite));
return oldObject;
if (cachedNomTypes.containsKey(nt)) {
return cachedNomTypes.get(nt).getTypeOfThis();
return OLD_UNKNOWN_TYPE;
private com.google.javascript.rhino.jstype.JSType convertFunctionType(FunctionType ft) {
if (ft.isTopFunction() || ft.isQmarkFunction()) {
return OLD_UNKNOWN_FUNCTION_TYPE;
if (ft.isConstructor()) {
return convertConstructorFunction(ft);
FunctionBuilder funBuilder = new FunctionBuilder(this.registry);
funBuilder.withParamsNode(convertFunctionParams(ft));
funBuilder.withReturnType(convertNewTypeToOld(ft.getReturnType()));
funBuilder.withTypeOfThis(convertNewTypeToOld(ft.getThisType()));
com.google.javascript.rhino.jstype.FunctionType result = funBuilder.build();
result.setJSDocInfo(NodeUtil.getBestJSDocInfo(currentNode));
return result;
private Node convertFunctionParams(FunctionType ft) {
FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this.registry);
int minArity = ft.getMinArity();
com.google.javascript.rhino.jstype.JSType[] requiredFormals =
new com.google.javascript.rhino.jstype.JSType[minArity];
for (int i = 0; i < minArity; i++) {
requiredFormals[i] = convertNewTypeToOld(ft.getFormalType(i));
paramBuilder.addRequiredParams(requiredFormals);
int maxArity = ft.getMaxArityWithoutRestFormals();
if (maxArity > minArity) {
com.google.javascript.rhino.jstype.JSType[] optionalFormals =
new com.google.javascript.rhino.jstype.JSType[maxArity - minArity];
for (int i = minArity; i < maxArity; i++) {
optionalFormals[i - minArity] = convertNewTypeToOld(ft.getFormalType(i));
paramBuilder.addOptionalParams(optionalFormals);
if (ft.hasRestFormals()) {
paramBuilder.addVarArgs(convertNewTypeToOld(ft.getRestFormalsType()));
return paramBuilder.build();
private com.google.javascript.rhino.jstype.JSType convertConstructorFunction(FunctionType ft) {
NominalType nt = ft.getInstanceTypeOfCtor().getNominalTypeIfSingletonObj();
if (cachedNomTypes.containsKey(nt)) {
return cachedNomTypes.get(nt);
String ntName = nt.getName();
Node source = nt.getDefsite();
com.google.javascript.rhino.jstype.FunctionType oldCtor =
this.registry.createConstructorType(ntName, source,
convertFunctionParams(ft), convertNewTypeToOld(ft.getReturnType()), null);
convertClassProperties(nt, oldCtor);
oldCtor.setSource(source);
NominalType superNt = nt.getInstantiatedSuperclass();
if (superNt != null) {
com.google.javascript.rhino.jstype.ObjectType oldPrototype =
convertNewTypeToOld(superNt.getInstanceAsJSType()).toObjectType();
if (oldPrototype != null) {
oldCtor.setPrototypeBasedOn(oldPrototype);
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(source);
oldCtor.setJSDocInfo(jsdoc);
oldCtor.getInstanceType().setJSDocInfo(jsdoc);
cachedNomTypes.put(nt, oldCtor);
return oldCtor;
private void convertClassProperties(
NominalType nt, com.google.javascript.rhino.jstype.FunctionType oldCtor) {
com.google.javascript.rhino.jstype.ObjectType oldInstance = oldCtor.getInstanceType();
for (String pname : nt.getAllOwnProps()) {
JSType ptype = nt.getPropDeclaredType(pname);
if (ptype == null) {
oldInstance.defineInferredProperty(pname, OLD_UNKNOWN_TYPE, null);
oldInstance.defineDeclaredProperty(pname, convertNewTypeToOld(ptype), null);
Node defSite = nt.getPropDefsite(pname);
if (defSite != null) {
oldInstance.setPropertyNode(pname, defSite);
oldInstance.setPropertyJSDocInfo(pname, NodeUtil.getBestJSDocInfo(defSite));
private final PassFactory convertNewTypesToOld =
new PassFactory("ConvertNewTypesToOld", true) {
protected CompilerPass create(final AbstractCompiler compiler) {
return new TypeConverter(compiler);
private class TypeConverter implements CompilerPass {
private final AbstractCompiler compiler;
TypeConverter(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
Preconditions.checkState(topScope == null);
(new ConvertNewTypesToOld(this.compiler)).process(externs, root);
regenerateGlobalTypedScopeAfterNTI(compiler, root);
private boolean needsAttachedType(Node n) {
Node parent = n.getParent();
return n.isGetProp()
|| n.isName()
|| n.isFunction()
|| n.isThis()
|| n.isNew();
if (!needsAttachedType(n)) {
return;
void regenerateGlobalTypedScopeAfterNTI(AbstractCompiler compiler, Node root) {
typedScopeCreator = new MemoizedScopeCreator(SyntacticScopeCreator.makeTyped(compiler));
topScope = TypedScope.createGlobalScope(root.getParent());
protected Object oldType = null;
public Object getOldType() {
return this.oldType;
public void setOldType(Object t) {
this.oldType = t;
return this.typei;
public void setUp() {
enableNewTypeInference();
disableNewTypeInference();
public void testPrivateAccessForProperties4a() {
testSame(new String[] {
"/** @constructor */ function Foo() {}" +
"/** @private */ Foo.prototype.bar_ = function() {};",
"Foo.prototype.baz = function() { (new Foo()).bar_(); };"
"/** @const */ var goog = {};" +
disableNewTypeInference();
"/** @const */ var goog = {};" +
"/** @const */ var foo = {};\n" +
"foo.bar = function() { return 'asdf'; };");
"/** @const */ var goog = {};" +
"/** @const */ var goog = {};" +
"/** @const */ var NS = {}; /** @constructor */ NS.Foo = function() {};" +
disableNewTypeInference();
disableNewTypeInference();
testError(
"/** @const */ var o = {};\n" +
testSame(
"/** @const */ var o = {};\n" +
"/** @const */ var o2 = {};\n" +
testError(
disableNewTypeInference();
disableNewTypeInference();
disableNewTypeInference();
testSame("/** @const */ var o = { /** @const */ x: 1 };" +
disableNewTypeInference();
disableNewTypeInference();
disableNewTypeInference();
" */ function B() { /** @const */ this.bar = 3; this.bar += 4; }");
private boolean newTypeInferenceEnabled = false;
this.typeCheckEnabled = true;
this.typeCheckLevel = level;
void enableNewTypeInference() {
Preconditions.checkState(typeCheckEnabled);
Preconditions.checkState(!runTypeCheckAfterProcessing);
this.newTypeInferenceEnabled = true;
void disableNewTypeInference() {
this.newTypeInferenceEnabled = false;
DiagnosticType error, DiagnosticType warning, String description) {
if (newTypeInferenceEnabled) {
Compiler compiler = createCompiler();
lastCompiler = compiler;
compiler.init(externsInputs, js, getOptions());
test(compiler, expected, error, warning, description, true);
test(compiler, expected, error, warning, description, false);
test(compiler, (List<SourceFile>) null, error, warning, description, false);
if (newTypeInferenceEnabled) {
List<SourceFile> inputs = Lists.newArrayList();
for (int i = 0; i < expected.length; i++) {
inputs.add(SourceFile.fromCode("expected" + i, expected[i]));
test(compiler, inputs, error, warning, description, true);
test(compiler, inputs, error, warning, description, false);
String description, boolean runNewTypeInference) {
if (runNewTypeInference) {
GlobalTypeInfo symbolTable = new GlobalTypeInfo(compiler);
compiler.setSymbolTable(symbolTable);
symbolTable.process(externsRoot, mainRoot);
(new NewTypeInference(compiler, rewriteClosureCode)).process(externsRoot, mainRoot);
(new ConvertNewTypesToOld(compiler)).process(externsRoot, mainRoot);
(new InferJSDocInfo(compiler)).process(externsRoot, mainRoot);
TypeCheck check = createTypeCheck(compiler, typeCheckLevel);
check.processForTesting(externsRoot, mainRoot);
Node description = NodeUtil.getArgumentForCallOrNew(callNode, 0);
if (description == null || !description.isObjectLit()) {
Node elName = NodeUtil.getFirstPropMatchingKey(description, "is");
Node constructor = NodeUtil.getFirstPropMatchingKey(description, "constructor");
Node baseClass = NodeUtil.getFirstPropMatchingKey(description, "extends");
JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);
new MemberDefinition(info, null, constructor), nativeBaseElement,
objectLitToList(description));
private static List<MemberDefinition> objectLitToList(Node objlit) {
for (Node keyNode : objlit.children()) {
parent.addChildBefore(stmts, exprRoot);
String polymerElementType = this.getPolymerElementType(cls);
JSDocInfoBuilder constructorDoc = new JSDocInfoBuilder(true);
new Node(Token.BANG, IR.string(this.getPolymerElementType(cls))), VIRTUAL_FILE);
"  constructor: function() { alert('hi'); },",
"/** @constructor @extends {PolymerElement} */",
"var X = function() { alert('hi'); };",
"  constructor: function() { alert('hi'); },",
usage = "Disable the optimizations " +
"based on available type information. Inaccurate type annotations " +
private boolean disableTypeOptimizations = false;
if (!flags.disableTypeOptimizations) {
return parent.isAssign() && getProp == parent.getFirstChild() &&
currentScope.isConstructor();
public void testTypedDisabledAdvanced() {
args.add("--compilation_level=ADVANCED_OPTIMIZATIONS");
args.add("--disable_type_optimizations");
test(
"/** @constructor */\n" +
"function Foo() {}\n" +
"Foo.prototype.handle1 = function(x, y) { alert(y); };\n" +
"/** @constructor */\n" +
"function Bar() {}\n" +
"Bar.prototype.handle1 = function(x, y) {};\n" +
"new Foo().handle1(1, 2);\n" +
"new Bar().handle1(1, 2);\n",
"function a() {}\n" +
"a.prototype.a = function(d, c) { alert(c); };\n" +
"function b() {}\n" +
"b.prototype.a = function() {};\n" +
"(new a).a(1, 2);\n" +
"(new b).a(1, 2);");
public void testBasicTypeCheck() throws Exception {
public void testBasicTypeCheck_error() throws Exception {
public void testFunctionType_correct() throws Exception {
public void testFunctionType_error() throws Exception {
public void testFunctionParameter() throws Exception {
public void testFunctionParameter_error() throws Exception {
public void testClassMemberVariable() throws Exception {
public void testClassMemberVariable_static() throws Exception {
+ "C.x = '12';",
if (!Objects.equals(getTypeVar(), other.getTypeVar())) {
analyzeExprFwd(lhs, inEnv, requiredType, stopAfterLhsType);
private void visitExport(NodeTraversal t, Node n, Node parent) {
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
Node var = IR.var(IR.name(DEFAULT_EXPORT_NAME), n.removeFirstChild());
var.useSourceInfoIfMissingFromForTree(n);
var.setJSDocInfo(n.getJSDocInfo());
n.setJSDocInfo(null);
n.getParent().replaceChild(n, var);
exportMap.put("default", DEFAULT_EXPORT_NAME);
compiler.report(JSError.make(n, Es6ToEs3Converter.CANNOT_CONVERT_YET,
Node moduleIdentifier = n.getLastChild();
importNode.copyInformationFrom(n);
parent.addChildBefore(importNode, n);
for (Node exportSpec : n.getFirstChild().children()) {
parent.removeChild(n);
if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
for (Node exportSpec : n.getFirstChild().children()) {
parent.removeChild(n);
Node declaration = n.getFirstChild();
declaration.setJSDocInfo(n.getJSDocInfo());
n.setJSDocInfo(null);
parent.replaceChild(n, declaration.detachFromParent());
test("export default class Foo {}", Joiner.on('\n').join(
"var $jscompDefaultExport$$module$testcode = class Foo{};",
"module$testcode.default = $jscompDefaultExport$$module$testcode"));
Node child = n.getFirstChild();
n.getSourceOffset() + n.getLength() - jsDoc.getOriginalCommentPosition(),
generateCode(compiler, child)));
String before = "var x = ";
String after = "/** @type {string} */ ('foo');";
Compiler compiler = getCompiler(before + after);
CodeReplacement replacement = new CodeReplacement(
before.length(),
after.length() - 1,  // Leave the ";" alone.
"'foo'");
assertReplacement(fix, replacement);
CodeReplacement replacement = new CodeReplacement(
"var x = ".length(), "/** @type {string} */ (y)".length(), "y");
assertReplacement(fix, replacement);
addList(first, false, getContextForNoInOperator(context));
addList(first, false, getContextForNoInOperator(context));
addList(first, false, getContextForNoInOperator(context));
case Token.NULL_TYPE:
add("null");
break;
case Token.UNDEFINED_TYPE:
add("undefined");
break;
add(": ");
addList(firstInList, true, Context.OTHER);
Context lhsContext) {
cc.listSeparator();
n.setDeclaredTypeExpression(convert(bestJSDocInfo.getReturnType()));
compiler.reportCodeChange();
n.setDeclaredTypeExpression(convert(parentJSDoc.getType()));
compiler.reportCodeChange();
n.setDeclaredTypeExpression(convert(parameterType));
compiler.reportCodeChange();
public static TypeDeclarationNode nullType() {
return new TypeDeclarationNode(Token.NULL_TYPE);
for (Map.Entry<String, TypeDeclarationNode> property : properties.entrySet()) {
if (property.getValue() == null) {
node.addChildToBack(IR.string(property.getKey()));
Node stringKey = IR.stringKey(property.getKey());
stringKey.addChildToFront(property.getValue());
Node returnType, LinkedHashMap<String, TypeDeclarationNode> parameters) {
Preconditions.checkArgument(!Iterables.isEmpty(options), "union must have at least one option");
public static TypeDeclarationNode restParams(TypeDeclarationNode type) {
return new TypeDeclarationNode(Token.REST_PARAMETER_TYPE, type);
case "null":
return nullType();
return undefinedType();
Iterables.transform(n.getFirstChild().children(), CONVERT_TYPE_NODE));
return child == null ? anyType() : unionType(nullType(), convertTypeNodeAST(child));
return unionType(Iterables.transform(n.children(), CONVERT_TYPE_NODE));
case Token.ELLIPSIS:
return restParams(convertTypeNodeAST(n.getFirstChild()));
parameters.put("p" + paramIdx++, convertTypeNodeAST(param));
return functionType(returnType, parameters);
NULL_TYPE          = 208,
case NULL_TYPE:       return "NULL_TYPE";
private final List<SourceFile> externsInputs;
test("/** @type {undefined} */ var n;", "var n: undefined;");
import static com.google.javascript.jscomp.parsing.TypeDeclarationsIRFactory.nullType;
import static com.google.javascript.rhino.Token.NULL_TYPE;
import static com.google.javascript.rhino.Token.UNDEFINED_TYPE;
assertParseTypeAndConvert("null").hasType(NULL_TYPE);
assertParseTypeAndConvert("void").hasType(UNDEFINED_TYPE);
assertParseTypeAndConvert("undefined").hasType(UNDEFINED_TYPE);
.isEqualTo(parameterizedType(namedType("Array"), asList(stringType())));
Node prop2 = IR.string("myObject");
Node prop1 = IR.string("length");
.isEqualTo(new TypeDeclarationNode(PARAMETERIZED_TYPE,
namedType("Array"),
.isEqualTo(unionType(nullType(), numberType()));
stringKey2.addChildToFront(new TypeDeclarationNode(REST_PARAMETER_TYPE, numberType()));
.isEqualTo(new TypeDeclarationNode(FUNCTION_TYPE, numberType(), stringKey1, stringKey2));
parameters.put("p1", optionalParameter(unionType(nullType(), stringType())));
.isEqualTo(TypeDeclarationsIRFactory.functionType(anyType(), parameters));
if (oldAST == null) {
fail(typeExpr + " did not produce a parsed AST");
if (options.getLanguageOut() == LanguageMode.ECMASCRIPT6_TYPED) {
checks.add(convertToTypedES6);
public Builder delete(Node n) {
return delete(googRequireNode);
String expectedCode = preamble + "\n\n" + postamble;
if (getLastChar() != ' ' && op.charAt(0) != ',') {
append(" ");
append(op);
append(op);
CompilerOptions newCompilerOptions(boolean prettyprint, int lineThreshold) {
options.setPrettyPrint(prettyprint);
options.setLineLengthThreshold(lineThreshold);
CompilerOptions newCompilerOptions(boolean prettyprint, int lineThreshold, boolean lineBreak) {
CompilerOptions options = newCompilerOptions(prettyprint, lineThreshold);
options.setLineBreak(lineBreak);
return options;
String parsePrint(String js, boolean prettyprint, int lineThreshold) {
return parsePrint(js, newCompilerOptions(prettyprint, lineThreshold));
String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold) {
return parsePrint(js, newCompilerOptions(prettyprint, lineThreshold, lineBreak));
String parsePrint(String js, boolean prettyprint, boolean lineBreak,
boolean preferLineBreakAtEof, int lineThreshold) {
CompilerOptions options = newCompilerOptions(prettyprint, lineThreshold, lineBreak);
options.setPreferLineBreakAtEndOfFile(preferLineBreakAtEof);
return parsePrint(js, options);
String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold,
boolean outputTypes) {
return new CodePrinter.Builder(parse(js, true))
.setCompilerOptions(newCompilerOptions(prettyprint, lineThreshold, lineBreak))
.setOutputTypes(outputTypes)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.build();
String parsePrint(String js, boolean prettyprint, boolean lineBreak,
int lineThreshold, boolean outputTypes,
boolean tagAsStrict) {
return new CodePrinter.Builder(parse(js, true))
.setCompilerOptions(newCompilerOptions(prettyprint, lineThreshold, lineBreak))
.setOutputTypes(outputTypes)
.setTypeRegistry(lastCompiler.getTypeRegistry())
.setTagAsStrict(tagAsStrict)
.build();
parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, false, true,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, false, false, false, 30));
parsePrint(js, false, false, true, 30));
parsePrint(js, true, false,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
parsePrint(js, true, false,
CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));
parsePrint(js, false, true, 10));
String result = parsePrint("var x", false, false, 0, false, true);
if (lastIndex <= sb.length()) {
if (nodeToReplace.getParent().isExprResult()) {
nodeToReplace = nodeToReplace.getParent();
new CodeReplacement(
original.getSourceOffset(), original.getLength(), generateCode(compiler, newNode)));
import static org.junit.Assert.assertTrue;
import com.google.javascript.rhino.Node;
import java.util.Iterator;
import java.util.Set;
Compiler compiler = createCompiler();
String testCode = "var loc = 'str';";
compileTestCode(compiler, testCode, "");
Node root = getScriptRoot(compiler);
RefasterJsScanner scanner = createScanner(compiler, template);
Match match = new Match(root.getFirstChild(), new NodeMetadata(compiler));
assertTrue(scanner.matches(match.getNode(), match.getMetadata()));
List<SuggestedFix> fixes = scanner.processMatch(match);
assertEquals(1, fixes.size());
Set<CodeReplacement> replacements = fixes.get(0).getReplacements().get("test");
assertEquals(1, replacements.size());
assertEquals(
new CodeReplacement(0, "var loc = 'str';".length(), "'bar';\n"),
replacements.iterator().next());
+ "function foo() {}";
Compiler compiler = createCompiler();
String preamble = "var loc = new Location();";
String testCode = "loc.href = 'str';";
compileTestCode(compiler, preamble + testCode, externs);
Node root = getScriptRoot(compiler);
RefasterJsScanner scanner = createScanner(compiler, template);
Match match = new Match(
root.getFirstChild().getNext().getFirstChild(), new NodeMetadata(compiler));
assertTrue(scanner.matches(match.getNode(), match.getMetadata()));
List<SuggestedFix> fixes = scanner.processMatch(match);
assertEquals(1, fixes.size());
Set<CodeReplacement> replacements = fixes.get(0).getReplacements().get("test");
assertEquals(1, replacements.size());
assertEquals(
new CodeReplacement(preamble.length(), testCode.length(), "foo();\n"),
replacements.iterator().next());
+ "FooType.prototype.bar = function() {};";
String template = externs
Compiler compiler = createCompiler();
String preamble = "var obj = new FooType();\n";
String testCode = preamble + "obj.bar();";
compileTestCode(compiler, testCode, externs);
Node root = getScriptRoot(compiler);
RefasterJsScanner scanner = createScanner(compiler, template);
Match match = new Match(root.getLastChild().getFirstChild(), new NodeMetadata(compiler));
assertTrue(scanner.matches(match.getNode(), match.getMetadata()));
List<SuggestedFix> fixes = scanner.processMatch(match);
assertEquals(1, fixes.size());
Set<CodeReplacement> replacements = fixes.get(0).getReplacements().get("test");
assertEquals(1, replacements.size());
assertEquals(
new CodeReplacement(preamble.length(), "obj.bar();".length(), "obj.baz();\n"),
replacements.iterator().next());
String template = externs
Compiler compiler = createCompiler();
String preamble = "var obj = new FooType();\n";
String postamble = "var someOtherCode = 3;\n";
String testCode = ""
+ preamble
+ "obj.bar();\n"
+ "obj.baz();\n"
+ postamble;
compileTestCode(compiler, testCode, externs);
Node root = getScriptRoot(compiler);
RefasterJsScanner scanner = createScanner(compiler, template);
Match match = new Match(root.getFirstChild().getNext(), new NodeMetadata(compiler));
assertTrue(scanner.matches(match.getNode(), match.getMetadata()));
List<SuggestedFix> fixes = scanner.processMatch(match);
assertEquals(1, fixes.size());
Set<CodeReplacement> replacements = fixes.get(0).getReplacements().get("test");
assertEquals(2, replacements.size());
Iterator<CodeReplacement> iterator = replacements.iterator();
assertEquals(
new CodeReplacement(preamble.length(), "obj.bar();".length(), ""),
iterator.next());
assertEquals(
new CodeReplacement(preamble.length() + "obj.bar();\n".length(), "obj.baz();".length(), ""),
iterator.next());
private Node getScriptRoot(Compiler compiler) {
Node root = compiler.getRoot();
return root.getLastChild().getFirstChild();
String after = "goog.foo()";
before.length(), after.length(), "goog2.get('service');\n");
EnvTypePair pair = isFwd ?
analyzeExprFwd(arg, typeEnv) : analyzeExprBwd(arg, typeEnv);
int templateMask = 0;
int otherScalarBits = other.getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
long v = 0;
return Double.valueOf(v);
long v = 0;
return Double.valueOf(v);
long v = 0;
return Double.valueOf(v);
long v = 0;
return Double.valueOf(v);
JSType objWithProp = pickReqObjType(receiver)
pickReqObjType(receiver).withLoose().withProperty(qname, requiredType));
pickReqObjType(obj).withLoose().withProperty(pname, type);
pickReqObjType(obj).withLoose().withProperty(pname, type);
default: {
Node parent = expr.getParent();
if (parent.isGetProp()) {
return JSType.TOP_STRUCT;
if (parent.isGetElem()) {
return JSType.TOP_DICT;
if (NodeUtil.isNamespaceDecl(getProp) && currentScope.isNamespace(getProp)
|| NodeUtil.isTypedefDecl(getProp)) {
EnumType et = currentScope.getEnum(declNode.getQualifiedName());
if (et != null) {
return et.toJSType();
Preconditions.checkState((lineCount < 0) || (line < lineCount));
usage = "Displays this message on stdout and exit")
usage = "Prints the compiler version to stdout and exit.")
private void printUsage(PrintStream ps) {
(new CmdLineParser(this)).printUsage(ps);
ps.flush();
private boolean errors = false;
private boolean runCompiler = false;
private PrintStream errorStream;
private void reportError(String message) {
errors = true;
errorStream.println(message);
errorStream.flush();
private void processFlagFile()
reportError("ERROR - Arguments in the file cannot contain "
errorStream = err;
processFlagFile();
reportError(e.getMessage());
reportError("ERROR - " + flags.flagFile + " read error.");
reportError("Please specify --common_js_entry_module.");
reportError("ERROR - invalid output_wrapper_file specified.");
reportError("ERROR - invalid output_wrapper specified. Missing '" +
if (errors) {
errorStream.println("Run with the --help option for the usage");
errorStream.flush();
flags.printUsage(out);
out.println(
"Closure Compiler (http://github.com/google/closure-compiler)\n" +
"Version: " + Compiler.getReleaseVersion() + "\n" +
"Built on: " + Compiler.getReleaseDate());
out.flush();
runCompiler = true;
errorStream = null;
return this.runCompiler;
public boolean hasErrors() {
return this.errors;
if (runner.hasErrors()) {
if (NodeUtil.isNamespaceDecl(parent)) {
Node namespaceName = parent.isAssign() ? parent.getFirstChild() : parent;
visitNamespacePropertyDeclaration(prop, namespaceName, prop.getString());
private JSType getTypeAtPropDeclNode(Node getProp, JSDocInfo jsdoc) {
Node parent = getProp.getParent();
if (parent.isAssign() && parent.getLastChild().isFunction()) {
currentScope.getScope(getFunInternalName(parent.getLastChild()))
if (isEnumDecl(n)) {
JSDocInfo jsdoc = getBestJSDocInfo(n);
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
String output = new String(outReader.toByteArray(), UTF_8);
assertTrue(output.indexOf(" --help ") >= 0);
assertTrue(output.indexOf(" --version ") >= 0);
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertFalse(runner.hasErrors());
CommandLineRunner runner =
createCommandLineRunner(new String[] {"function f() {}"});
assertFalse(runner.shouldRunCompiler());
assertTrue(runner.hasErrors());
if (!runner.shouldRunCompiler()) {
assertTrue(runner.hasErrors());
fail(new String(errReader.toByteArray()));
public void testStringKeyConstants() {
"var x = 5; /** @const */ var o = { /** @const {number} */ PROP: x};");
import java.util.Iterator;
Iterator<String> keys = sourceMapRoot.keys();
for (String key : Lists.newArrayList(keys)) {
throw new UnsupportedOperationException(
"SourceCodeEscapers is not in the standard release of Guava yet :(");
validateObjectLitStringKey(c);
validateChildCount(c, 0);
hotSwapScript(root, null);
recordAndUpdateRequire(t, n);
private void recordAndUpdateRequire(NodeTraversal t, Node call) {
private final boolean preserveJsDoc;
preserveJsDoc = false;
this.preserveJsDoc = options.preserveJsDoc;
if (preserveJsDoc) {
String jsDocString = n.getJSDocInfo().getOriginalCommentString();
if (jsDocString != null) {
add(jsDocString);
+ "Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT")
languageMode = options.getLanguageIn();
isIdeMode() || options.preserveJsDoc,
return isModuleFile;
public boolean preserveJsDoc;
preserveJsDoc = false;
checks.add(closureRewriteModule);
public class Es6RewriteGenerators extends NodeTraversal.AbstractPostOrderCallback
implements HotSwapCompilerPass {
Node condition;
Node postExpression;
condition = currentStatement.removeFirstChild();
postExpression = IR.empty();
condition = currentStatement.removeFirstChild();
if (condition.isEmpty()) {
condition = IR.trueNode();
postExpression = currentStatement.removeFirstChild();
Node firstEntry = IR.name(GENERATOR_DO_WHILE_INITIAL);
postExpression = IR.assign(firstEntry.cloneTree(), IR.falseNode());
condition = IR.or(firstEntry, currentStatement.removeFirstChild());
postExpression = postExpression.isEmpty() ? postExpression : IR.exprResult(postExpression);
if (!postExpression.isEmpty()) {
body.addChildToBack(postExpression);
Node conditionalBranch = IR.ifNode(condition, body);
originalGeneratorBody.addChildAfter(conditionalBranch, beginCase);
Preconditions.checkState(n.getParent() == null);
case Token.EXPR_RESULT:
if (n.getFirstChild().isYield()) {
exited = true;
if (lhs.isName() || lhs.isStringKey() || lhs.isRest()) {
Preconditions.checkState(lhs.isEmpty());
Preconditions.checkState(n.isName() || n.isRest() || n.isStringKey());
IR.paramList().srcref(classNode),
IR.block().srcref(classNode));
if (inheritedType.isSubtypeOf(resultType)) {
current.getPropDeclaredType(pname);
for (Node prop : n.children()) {
if (prop.getJSDocInfo() != null) {
declaredObjLitProps.put(prop,
getTypeDeclarationFromJsdoc(
prop.getJSDocInfo(), currentScope));
if (NodeUtil.hasConstAnnotation(prop)) {
warnings.add(JSError.make(prop, MISPLACED_CONST_ANNOTATION));
JSType propDeclType = getTypeDeclarationFromJsdoc(jsdoc, currentScope);
Preconditions.checkState(currentScope.isNamespace(recv));
String pname = getProp.getLastChild().getString();
JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(getProp);
JSType propDeclType = getTypeDeclarationFromJsdoc(jsdoc, currentScope);
boolean isConst = NodeUtil.hasConstAnnotation(getProp);
warnings.add(JSError.make(getProp, REDECLARED_PROPERTY,
if (isConst && !mayWarnAboutNoInit(getProp) && propDeclType == null) {
propDeclType = inferConstTypeFromRhs(getProp);
getProp.putBooleanProp(Node.ANALYZED_DURING_GTI, true);
JSType t = simpleInferExprType(getProp.getParent().getLastChild());
if (constExpr.isFromExterns()) {
Node rhs;
if (constExpr.isName()) {
Preconditions.checkState(constExpr.getParent().isVar());
rhs = constExpr.getFirstChild();
Preconditions.checkState(constExpr.isGetProp() &&
constExpr.getParent().isAssign());
rhs = constExpr.getParent().getLastChild();
JSType previousPropType = classType.getPropDeclaredType(pname);
fnScope.setDeclType(declFunType);
private void setDeclType(
DeclaredFunctionType declaredType) {
this.declaredType = declaredType;
private void sanityCheck() {
Set<String> names;
names = localFunDefs.keySet();
for (String s : localClassDefs.keySet()) {
Preconditions.checkState(names.contains(s));
names = locals.keySet();
for (String s : constVars) {
Preconditions.checkState(names.contains(s));
for (String s : localNamespaces.keySet()) {
Preconditions.checkState(names.contains(s));
names = new HashSet<>(formals);
for (String s : locals.keySet()) {
Preconditions.checkState(!names.contains(s),
"Name %s is defined twice.", s);
names.add(s);
for (String s : localFunDefs.keySet()) {
Preconditions.checkState(!names.contains(s),
"Name %s is defined twice.", s);
names.add(s);
for (String s : localTypedefs.keySet()) {
Preconditions.checkState(!names.contains(s),
"Name %s is defined twice.", s);
private JSType arrayType, regexpType; // used for array and regexp literals
Scope gs = symbolTable.getGlobalScope();
JSType arrayCtor = gs.getDeclaredTypeOf("Array");
arrayType = arrayCtor == null ?
JSType.UNKNOWN : arrayCtor.getFunType().getReturnType();
JSType regexpCtor = gs.getDeclaredTypeOf("RegExp");
regexpType = regexpCtor == null ?
JSType.UNKNOWN : regexpCtor.getFunType().getReturnType();
if (arrayType.isUnknown()) { // no externs
return !t.isUnknown() && t.isSubtypeOf(arrayType);
return new EnvTypePair(inEnv, regexpType);
return new EnvTypePair(env, arrayType);
return new EnvTypePair(outEnv, regexpType);
return new EnvTypePair(env, arrayType);
Preconditions.checkArgument(n.isQualifiedName());
if (isEmptyObjectLit(initializer)) {
&& isEmptyObjectLit(initializer.getLastChild());
static boolean isEmptyObjectLit(Node n) {
return n.isObjectLit() && n.getChildCount() == 0;
if (n.isName()) {
Node parent = getParent();
if (parent.isClass() && nameNode != parent.getFirstChild()) {
while (parent.isArrayPattern()) {
parent = parent.getParent();
if (parent.isDefaultValue() && nameNode == parent.getFirstChild()) {
return true;
private String getFunctionParameter(Node functionNode, int index) {
return functionNode.getChildAtIndex(1).getChildAtIndex(index).getString();
return n.isCall() ? n.getChildAtIndex(i + 1) : null;
private ImmutableList<Node> getParameters(Node operation) {
for (int i = 1; i < operation.getChildCount(); i++) {
builder.add(operation.getChildAtIndex(i));
String name = ttlAst.getFirstChild().getString();
String name = ttlAst.getFirstChild().getString();
String name = ttlAst.getFirstChild().getString();
ImmutableList<Node> params = getParameters(ttlAst);
ImmutableList<Node> params = getParameters(ttlAst);
ImmutableList<Node> params = getParameters(ttlAst);
String name = ttlAst.getFirstChild().getString();
ImmutableList<Node> params = getParameters(ttlAst);
ImmutableList<Node> params = getParameters(ttlAst);
Node mapFunctionBody = mapFunction.getChildAtIndex(2);
ImmutableList<Node> params = getParameters(ttlAst);
ImmutableList<Node> params = getParameters(ttlAst);
for (Node p : record.children()) {
if (p.isComputedProp()) {
String nameVar = p.getFirstChild().getString();
if (!nameResolver.nameVars.containsKey(nameVar)) {
reportWarning(ttlAst, UNKNOWN_NAMEVAR, nameVar);
builder.addProperty(nameResolver.nameVars.get(nameVar),
evalInternal(p.getChildAtIndex(1), nameResolver), null);
builder.addProperty(p.getString(),
evalInternal(p.getFirstChild(), nameResolver), null);
ImmutableList<Node> params = getParameters(ttlAst);
Node mapFnBody = mapFunction.getChildAtIndex(2);
ImmutableMap.Builder<String, JSType> newPropsBuilder =
new ImmutableMap.Builder<String, JSType>();
newPropsBuilder.put(newPropName, newPropValue);
return createRecordType(newPropsBuilder.build());
Preconditions.checkState(n.isName());
private static boolean canReturnNull(ControlFlowGraph<Node> graph) {
import com.google.common.annotations.VisibleForTesting;
private final NominalType nominalType;
if (isTopFunction()) {
outerVarPreconditions, typeParameters, true);
restFormals, retType, nominalType,
static JSType makeJSType(
ImmutableList<JSType> requiredFormals,
ImmutableList<JSType> optionalFormals,
JSType restFormals,
JSType retType) {
return JSType.fromFunctionType(FunctionType.normalized(
requiredFormals, optionalFormals, restFormals, retType,
null, null, null, false));
null, null, null, null, null, null, null, false);
null, null, null, null, null, null, null, true);
static final FunctionType QMARK_FUNCTION = FunctionType.normalized(
null, null, JSType.UNKNOWN, JSType.UNKNOWN, null, null, null, false);
Preconditions.checkState(this.nominalType == null);
&& nominalType.hasFreeTypeVars(boundTypeVars));
return Objects.equals(this.requiredFormals, f2.requiredFormals) &&
Objects.equals(this.optionalFormals, f2.optionalFormals) &&
Objects.equals(this.restFormals, f2.restFormals) &&
Objects.equals(this.returnType, f2.returnType) &&
Objects.equals(this.nominalType, f2.nominalType);
return Objects.hash(
requiredFormals, optionalFormals, restFormals, returnType, nominalType);
requiredFormals, optionalFormals,
restFormals, returnType, nominalType, outerVars, typeParameters, loose);
private JSType getFunTypeHelper(Node n, RawNominalType ownerType,
return getFunTypeBuilder(n, ownerType, registry, typeParameters)
Node n, RawNominalType ownerType, DeclaredTypeRegistry registry,
Node child = n.getFirstChild();
"then optional, then varargs", n);
if (!funNode.isFunction()) {
return FunctionTypeBuilder.qmarkFunctionBuilder();
Node params = funNode.getFirstChild().getNext();
for (Node param = params.getFirstChild();
param != null;
param = param.getNext()) {
String pname = param.getString();
JSType inlineParamType = ignoreJsdoc ? null : getNodeTypeDeclaration(
param.getJSDocInfo(), ownerType, registry, typeParameters);
if (convention.isOptionalParameter(param)) {
isRequired = false;
isRequired = false;
isRestFormals = true;
if (jsdocNode != null && jsdocNode.getType() == Token.EQUALS) {
isRequired = false;
jsdocNode = jsdocNode.getFirstChild();
isRequired = false;
isRestFormals = true;
jsdocNode = jsdocNode.getFirstChild();
private Map<K, V> map;
JSType type = rawType.getPropDeclaredType(pname);
JSType createConstructorObject(FunctionType ctorFn) {
Preconditions.checkState(typeMap.isEmpty());
return rawType.createConstructorObject(ctorFn);
for (String typeVar : rawType.getTypeParameters()) {
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
for (String typeVar : rawType.getTypeParameters()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, typeMap.keySet());
Preconditions.checkState(other.typeMap.containsKey(typeVar));
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
public JSType getPropDeclaredType(String pname) {
null, PersistentMap.of("_", Property.make(JSType.BOTTOM, JSType.BOTTOM)),
null, false, ObjectKind.UNRESTRICTED);
return ObjectType.makeObjectType(
for (String pname : this.props.keySet()) {
newProps = newProps.with(pname, this.props.get(pname).withRequired());
return ObjectType.makeObjectType(
return props.with(pname, nomProp.specialize(objProp));
return ObjectType.makeObjectType(
meetPropsHelper(true, resultNominalType, this.props, other.props),
return ObjectType.makeObjectType(
meetPropsHelper(true, null, this.props, other.props),
return ObjectType.makeObjectType(
if (t1.nominalType != t2.nominalType) {
if (t1.fn != t2.fn) {
throw new RuntimeException("Unification of functions not yet supported");
return makeObjectType(t1.nominalType, newProps, t1.fn,
for (String p : props.keySet()) {
newProps =
newProps.with(p, props.get(p).substituteGenerics(concreteTypes));
private static final PersistentMap EMPTY = NaivePersistentMap.create();
return EMPTY;
return PersistentMap.<K, V>create().with(key, value);
private static final PersistentSet EMPTY = NaivePersistentSet.create();
return EMPTY;
boolean isIdeMode, boolean parseJsDocDocumentation, LanguageMode languageMode,
this.parseJsDocDocumentation = parseJsDocDocumentation;
false,
boolean parseJsDocDocumentation,
isIdeMode, parseJsDocDocumentation, languageMode, acceptConstKeyword);
private static final int VAR_ARGS = Integer.MAX_VALUE - 1;
return n.isCall() ? n.getChildAtIndex(i + 1) : null;
int numParams = expr.getChildCount();
if (numParams < 1 + keyword.minParamCount) {
if (numParams > 1 + keyword.maxParamCount) {
new HashSet<String>(), true, true, LanguageMode.ECMASCRIPT6, false);
int numParams = expr.getChildCount() - 1;
for (int i = 1; i < numParams; i++) {
int numParams = expr.getChildCount() - 1;
for (int i = 0; i < numParams; i++) {
if (!validTypeTransformationExpression(expr.getChildAtIndex(i))) {
String name = expr.getFirstChild().getString();
String predicate = expr.getFirstChild().getString();
Node mapFnParam = mapFn.getChildAtIndex(1);
if (!mapFnParam.hasChildren()) {
warnMissingParam("map function", mapFnParam);
if (!mapFnParam.hasOneChild()) {
warnExtraParam("map function", mapFnParam);
Node mapFnBody = mapFn.getChildAtIndex(2);
int mapFnParamCount = mapFn.getChildAtIndex(1).getChildCount();
Node mapFnBody = mapFn.getChildAtIndex(2);
String name = expr.getFirstChild().getString();
String name = expr.getFirstChild().getString();
if ((rest || kind == PatternKind.INITIALIZER)
&& lvalue.type != ParseTreeType.IDENTIFIER_EXPRESSION) {
reportError("lvalues in initializer patterns must be identifiers");
private boolean preserveJsDoc = false;
preserveJsDoc = false;
options.preserveJsDoc = preserveJsDoc;
options.preserveJsDoc = preserveJsDoc;
public void testPreserveJsDoc() {
preserveJsDoc = true;
assertPrintSame("/** @type {foo} */var bar");
preserveJsDoc = false;
"$jscomp.inherits = function(x,y) {};"
optimizer.addOneTimePass(passConfig.rewriteGenerators);
"C.prototype.foo = /** @suppress {uselessCode} */ function() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value : 1, done : false};",
"      case 1:",
"        if(!($jscomp$generator$throw$arg!==undefined)) {",
"          $jscomp$generator$state=2;break",
"        }",
"        $jscomp$generator$state=-1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true};",
"    }",
"  }",
"  return {",
"    $$iterator: function(){ return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"};"
test("class D {} class C extends D { }", Joiner.on('\n').join(
"var C = function() {};",
"var C = function() {}",
"var C = function() {};",
"var C = function() {}",
"var C = function() {}",
"var C = function() {}",
"var C = function() {};",
"  var D = function() {}",
"var S = function() {};",
"var S = function() {};",
"var C = function() {};",
"var C = function() {};",
"var C = function() {};",
"var Sub = function() {};",
"  $jscomp$compprop0[foo] = /** @suppress {uselessCode} */ function(){",
"     var $jscomp$generator$state = 0;",
"     function $jscomp$generator$impl($jscomp$generator$next$arg,",
"         $jscomp$generator$throw$arg) {",
"       while (1) switch ($jscomp$generator$state) {",
"         case 0:",
"           $jscomp$generator$state = -1;",
"         default:",
"           return {value: undefined, done: true}",
"       }",
"     }",
"     return { $$iterator: function(){",
"       return this",
"     },",
"     next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"     throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"   };",
"  },",
"",
"C.prototype[foo] = /** @suppress {uselessCode} */ function() {",
"  var $jscomp$generator$state=0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while(1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function(){",
"      return this;",
"    },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"};"
"",
"C[foo] = /** @suppress {uselessCode} */ function() {",
"  var $jscomp$generator$state=0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while(1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: 2, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function(){",
"      return this;",
"    },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"};"
public void testSimpleGenerator() {
test("function *f() {}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"}"
));
test("function *f() {yield 1;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"}"
));
test("/** @param {*} a */ function *f(a, b) {}", Joiner.on('\n').join(
"/** @param {*} a @suppress {uselessCode} */",
"function f(a, b) {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  };",
"}"
));
test("function *f(a, b) {var i = 0, j = 2;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f(a, b) {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        j = 2;",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { var i = 0; yield i; i = 1; yield i; i = i + 1; yield i;}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        $jscomp$generator$state = 1;",
"        return {value: i, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        i = 1;",
"        $jscomp$generator$state = 3;",
"        return {value: i, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        i = i + 1;",
"        $jscomp$generator$state = 5;",
"        return {value: i, done: false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("{ function *f() {yield 1;} }", Joiner.on('\n').join(
"{",
"  var f = /** @suppress {uselessCode} */ function() {",
"    var $jscomp$generator$state = 0;",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        $jscomp$generator$throw$arg) {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = 1;",
"          return {value: 1, done: false};",
"        case 1:",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 2; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        case 2:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {value: undefined, done: true}",
"      }",
"    }",
"    return {",
"      $$iterator: function() { return this; },",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    }",
"  }",
"}"
));
public void testReturnGenerator() {
test("function f() { return function *g() {yield 1;} }", Joiner.on('\n').join(
"function f() {",
"  return /** @suppress {uselessCode} */ function g() {",
"    var $jscomp$generator$state = 0;",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        $jscomp$generator$throw$arg) {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = 1;",
"          return {value: 1, done: false};",
"        case 1:",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 2; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        case 2:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {value: undefined, done: true}",
"      }",
"    }",
"    return {",
"      $$iterator: function() { return this; },",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    };",
"  }",
"}"
));
public void testNestedGenerator() {
test("function *f() { function *g() {yield 2;} yield 1; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  /** @suppress {uselessCode} */",
"  function g() {",
"    var $jscomp$generator$state = 0;",
"    function $jscomp$generator$impl($jscomp$generator$next$arg,",
"        $jscomp$generator$throw$arg) {",
"      while (1) switch ($jscomp$generator$state) {",
"        case 0:",
"          $jscomp$generator$state = 1;",
"           return {value: 2, done: false};",
"        case 1:",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 2; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        case 2:",
"          $jscomp$generator$state = -1;",
"        default:",
"          return {value: undefined, done: true}",
"      }",
"    }",
"    return {",
"      $$iterator: function() { return this; },",
"      next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"      throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"    }",
"  }",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"         return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testForLoopsGenerator() {
test("function *f() {var i = 0; for (var j = 0; j < 10; j++) { i += j; } yield i;}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        for (var j = 0; j < 10; j++) { i += j; }",
"        $jscomp$generator$state = 1;",
"        return {value: i, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"      case 2:",
"        j++",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testWhileLoopsGenerator() {
test("function *f() {var i = 0; while (i < 10) { i++; i++; i++; } yield i;}",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        while (i < 10) { i ++; i++; i++; }",
"        $jscomp$generator$state = 1;",
"        return {value: i, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { var j = 0; while (j < 10) { yield j; j++; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        j++",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"      }",
"    }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorCannotConvertYet() {
test(Joiner.on('\n').join(
"function *f() {",
"  var i = 0; for (var j = 0; j < 10; j++) { i += j; throw 5; } yield i;",
"}"
), Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  var i;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        i = 0;",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        i += j;",
"        $jscomp$generator$state = -1;",
"        throw 5;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = 4;",
"        return {value: i, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() {switch (i) {default: case 1: yield 1;}}",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
test("function *f() { l: if (true) { var x = 5; break l; x++; yield x; }; }",
null, Es6ToEs3Converter.CANNOT_CONVERT_YET);
public void testThrowGenerator() {
test("function *f() {throw 1;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        throw 1;",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testLabelsGenerator() {
test("function *f() { l: if (true) { break l; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        l: if (true) { break l; }",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { l: for (;;) { yield i; continue l; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"      case 1:",
"        if (!true) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: i, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testIfGenerator() {
test("function *f() { var j = 0; if (j < 1) { yield j; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"        if (!(j < 1)) { $jscomp$generator$state = 1; break; }",
"        $jscomp$generator$state = 2;",
"        return {value: j, done: false};",
"      case 2:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 3; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 3:",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f(i) { if (i < 1) { yield i; } else { yield 1; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f(i) {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        if (!(i < 1)) { $jscomp$generator$state = 1; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: i, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 1:",
"        $jscomp$generator$state = 5;",
"        return {value: 1, done: false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorReturn() {
test("function *f() { return 1; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        return {value: 1, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorBreakContinue() {
test("function *f() { var j = 0; while (j < 10) { yield j; break; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 2;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { var j = 0; while (j < 10) { yield j; continue; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 2; break; }",
"        $jscomp$generator$state = 3;",
"        return {value: j, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; break; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = 3;",
"        break;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() { for (var j = 0; j < 10; j++) { yield j; continue; } }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var j;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        j = 0;",
"      case 1:",
"        if (!(j < 10)) { $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 2:",
"        j++;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testDoWhileLoopsGenerator() {
test("function *f() { do { yield j; } while (j < 10); }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$first$do;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$first$do = true;",
"      case 1:",
"        if (!($jscomp$generator$first$do || j < 10)) {",
"          $jscomp$generator$state = 3; break; }",
"        $jscomp$generator$state = 4;",
"        return {value: j, done: false};",
"      case 4:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 5; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 5:",
"      case 2:",
"        $jscomp$generator$first$do = false;",
"        $jscomp$generator$state = 1;",
"        break",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldNoValue() {
test("function *f() { yield; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: undefined, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testReturnNoValue() {
test("function *f() { return; }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"        return {value: undefined, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldExpression() {
test("function *f() { return (yield 1); }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$next$arg0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: 1, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$next$arg0 = $jscomp$generator$next$arg;",
"        $jscomp$generator$state = -1;",
"        return {value: $jscomp$generator$next$arg0, done: true};",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testFunctionInGenerator() {
test("function *f() { function g() {} }",
Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function g() {}",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldAll() {
test("function *f() {yield * n;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$yield$entry;",
"  var $jscomp$generator$yield$all;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$yield$all = $jscomp.makeIterator(n);",
"      case 1:",
"        if (!!($jscomp$generator$yield$entry =",
"            $jscomp$generator$yield$all.next($jscomp$generator$next$arg)).done) {",
"          $jscomp$generator$state = 2;",
"          break;",
"        }",
"        $jscomp$generator$state = 3;",
"        return {value: $jscomp$generator$yield$entry.value, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
test("function *f() {var i = yield * n;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  var $jscomp$generator$yield$entry;",
"  var $jscomp$generator$yield$all;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$yield$all = $jscomp.makeIterator(n);",
"      case 1:",
"        if (!!($jscomp$generator$yield$entry =",
"            $jscomp$generator$yield$all.next($jscomp$generator$next$arg)).done) {",
"          $jscomp$generator$state = 2;",
"          break;",
"        }",
"        $jscomp$generator$state = 3;",
"        return {value: $jscomp$generator$yield$entry.value, done: false};",
"      case 3:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 4; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 4:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        i = $jscomp$generator$yield$entry.value;",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldArguments() {
test("function *f() {yield arguments[0];}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$arguments = arguments;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: $jscomp$generator$arguments[0], done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldThis() {
test("function *f() {yield this;}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$this = this;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$state = 1;",
"        return {value: $jscomp$generator$this, done: false};",
"      case 1:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 2; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testYieldSwitch() {
test(Joiner.on('\n').join(
"function *f() {",
"  while (1) {",
"    switch (i) {",
"      case 1:",
"        yield 2;",
"        break;",
"      case 2:",
"        yield 3;",
"        continue;",
"      case 3:",
"        yield 4;",
"      default:",
"        yield 5;",
"    }",
"  }",
"}"
), Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var $jscomp$generator$switch$val1;",
"  var $jscomp$generator$switch$entered0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"      case 1:",
"        if (!1) {",
"          $jscomp$generator$state = 2;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = false;",
"        $jscomp$generator$switch$val1 = i;",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 1)) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 5;",
"        return {value: 2, done: false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"        $jscomp$generator$state = 3;",
"        break;",
"      case 4:",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 2)) {",
"          $jscomp$generator$state = 7;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 8;",
"        return {value: 3, done: false};",
"      case 8:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 9; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 9:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 7:",
"        if (!($jscomp$generator$switch$entered0",
"            || $jscomp$generator$switch$val1 === 3)) {",
"          $jscomp$generator$state = 10;",
"          break;",
"        }",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 11;",
"        return{value: 4, done: false};",
"      case 11:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 12; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 12:",
"      case 10:",
"        $jscomp$generator$switch$entered0 = true;",
"        $jscomp$generator$state = 13;",
"        return {value: 5, done: false};",
"      case 13:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 14; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 14:",
"      case 3:",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorNoTranslate() {
test("function *f() { if (1) { try {} catch (e) {} throw 1; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        if (!1) {",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"        try {} catch (e) {}",
"        $jscomp$generator$state = -1;",
"        throw 1;",
"      case 1:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorForIn() {
test("function *f() { for (var i in j) { yield 1; } }", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var i;",
"  var $jscomp$generator$forin$iter0;",
"  var $jscomp$generator$forin$var0;",
"  var $jscomp$generator$forin$array0;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        $jscomp$generator$forin$array0 = [];",
"        $jscomp$generator$forin$iter0 = j;",
"        for (i in $jscomp$generator$forin$iter0) {",
"          $jscomp$generator$forin$array0.push(i);",
"        }",
"        $jscomp$generator$forin$var0 = 0;",
"      case 1:",
"        if (!($jscomp$generator$forin$var0",
"            < $jscomp$generator$forin$array0.length)) {",
"          $jscomp$generator$state = 3;",
"          break;",
"        }",
"        i = $jscomp$generator$forin$array0[$jscomp$generator$forin$var0];",
"        if (!(!(i in $jscomp$generator$forin$iter0))) {",
"          $jscomp$generator$state = 4;",
"          break;",
"        }",
"        $jscomp$generator$state = 2;",
"        break;",
"      case 4:",
"        $jscomp$generator$state = 5;",
"        return{value:1, done:false};",
"      case 5:",
"        if (!($jscomp$generator$throw$arg !== undefined)) {",
"          $jscomp$generator$state = 6; break;",
"        }",
"        $jscomp$generator$state = -1;",
"        throw $jscomp$generator$throw$arg;",
"      case 6:",
"      case 2:",
"        $jscomp$generator$forin$var0++;",
"        $jscomp$generator$state = 1;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorTryCatch() {
test("function *f() {try {yield 1;} catch (e) {}}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var e;",
"  var $jscomp$generator$global$error;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        try {",
"          $jscomp$generator$state = 3;",
"          return {value: 1, done: false};",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 3:",
"        try {",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 4; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 4:",
"        try {",
"          $jscomp$generator$state = 2;",
"          break;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 1:",
"        e = $jscomp$generator$global$error;",
"      case 2:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
public void testGeneratorFinally() {
test("function *f() {try {yield 1;} catch (e) {} finally {b();}}", Joiner.on('\n').join(
"/** @suppress {uselessCode} */",
"function f() {",
"  var $jscomp$generator$state = 0;",
"  var e;",
"  var $jscomp$generator$finally0;",
"  var $jscomp$generator$global$error;",
"  function $jscomp$generator$impl($jscomp$generator$next$arg,",
"      $jscomp$generator$throw$arg) {",
"    while (1) switch ($jscomp$generator$state) {",
"      case 0:",
"        try {",
"          $jscomp$generator$state = 4;",
"          return {value: 1, done: false};",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 4:",
"        try {",
"          if (!($jscomp$generator$throw$arg !== undefined)) {",
"            $jscomp$generator$state = 5; break;",
"          }",
"          $jscomp$generator$state = -1;",
"          throw $jscomp$generator$throw$arg;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 5:",
"        try {",
"          $jscomp$generator$finally0 = 3;",
"          $jscomp$generator$state = 2;",
"          break;",
"        } catch ($jscomp$generator$e) {",
"          $jscomp$generator$global$error = $jscomp$generator$e;",
"          $jscomp$generator$state = 1;",
"          break;",
"        }",
"      case 1:",
"        e = $jscomp$generator$global$error;",
"        $jscomp$generator$finally0 = 3;",
"      case 2:",
"        b();",
"        $jscomp$generator$state = $jscomp$generator$finally0;",
"        break;",
"      case 3:",
"        $jscomp$generator$state = -1;",
"      default:",
"        return {value: undefined, done: true}",
"    }",
"  }",
"  return {",
"    $$iterator: function() { return this; },",
"    next: function(arg){ return $jscomp$generator$impl(arg, undefined); },",
"    throw: function(arg){ return $jscomp$generator$impl(undefined, arg); },",
"  }",
"}"
));
typeCheck(
"}",
GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE);
ParserRunner.createConfig(true, true, mode, false, null),
true, true, LanguageMode.ECMASCRIPT3, false, null)
true, true, LanguageMode.ECMASCRIPT3, false, null).suppressionNames);
true, true, LanguageMode.ECMASCRIPT3, false);
parseDocumentation, parseDocumentation,
LanguageMode.ECMASCRIPT3, false);
parse("function f({x: [y, z]}) {}");
"'}' expected");
ParserRunner.createConfig(isIdeMode, isIdeMode, mode, false, null),
ParserRunner.createConfig(isIdeMode, isIdeMode, mode, false, null),
ImmutableMap.Builder<String, JSType> newPropsBuilder =
new ImmutableMap.Builder<String, JSType>();
newPropsBuilder.put(newPropName, newPropValue);
return createRecordType(newPropsBuilder.build());
if (inheritedType.isSubtypeOf(resultType)) {
Preconditions.checkState(nominalType == null || receiverType == null);
Preconditions.checkState(!isLoose || receiverType == null);
if (nominalType != null
&& !nominalType.unifyWith(other.nominalType, typeParameters, typeMultimap)) {
if (receiverType != null
&& !receiverType.unifyWith(other.receiverType, typeParameters, typeMultimap)) {
for (String typeVar : rawType.getTypeParameters()) {
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
for (String typeVar : rawType.getTypeParameters()) {
Preconditions.checkState(typeMap.containsKey(typeVar),
"Type variable %s not in the domain: %s",
typeVar, typeMap.keySet());
Preconditions.checkState(other.typeMap.containsKey(typeVar));
if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
return false;
if (t1.nominalType != t2.nominalType) {
if (t1.fn != t2.fn) {
throw new RuntimeException("Unification of functions not yet supported");
return makeObjectType(t1.nominalType, newProps, t1.fn,
appendTypeNode(sb, typeNode.getFirstChild());
Node paramList = typeNode.getFirstChild();
if (paramList.isEmpty()) {
sb.append(")");
for (int i = 0; i < paramList.getChildCount() - 1; i++) {
appendTypeNode(sb, paramList.getChildAtIndex(i));
sb.append(",");
appendTypeNode(sb, paramList.getLastChild());
sb.append("Array.<");
appendTypeNode(sb, typeNode.getFirstChild().getFirstChild());
sb.append(">");
builder.recordParameter("foo", new JSTypeExpression(IR.string("number"), ""));
builder.recordParameter("bar", new JSTypeExpression(IR.string("string"), ""));
builder.recordReturnType(new JSTypeExpression(IR.string("number|string"), ""));
builder.recordThisType(new JSTypeExpression(IR.string("...number"), ""));
assertEquals("/**@this {...number} */", JSDocInfoPrinter.print(info));
builder.recordThrowType(new JSTypeExpression(IR.string("*"), ""));
builder.recordTypedef(new JSTypeExpression(IR.string("?"), ""));
builder.recordEnumParameterType(
new JSTypeExpression(IR.string("{foo: number, bar: string}"), ""));
"/**@enum {{foo: number, bar: string}} */", JSDocInfoPrinter.print(info));
builder.recordType(
new JSTypeExpression(IR.string("!Array.<number|string>"), ""));
visit(t, child, newNode);
NodeTraversal.traverse(compiler, root, new RewriteScopeCallback());
input.getAstRoot(compiler).addChildToFront(
IR.var(IR.name(name).srcref(node)).srcref(node));
private static final int VAR_ARGS = Integer.MAX_VALUE;
for (Map.Entry<String, Typedef> entry : localTypedefs.entrySet()) {
String name = entry.getKey();
Typedef td = entry.getValue();
typeParser.resolveTypedef(name, this);
for (Map.Entry<String, EnumType> entry : localEnums.entrySet()) {
String name = entry.getKey();
EnumType e = entry.getValue();
typeParser.resolveEnum(name, this);
locals.put(name, e.getObjLitType());
if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
&& n.getParent().getParent().isExprResult())) {
public JSType getObjLitType() {
return enumObjType;
public JSType toJSType() {
enumObjType = computeObjType();
if (registry.getTypedef(typeName) != null) {
return getTypedefType(typeName, registry);
if (registry.getEnum(typeName) != null) {
return getEnumPropType(typeName, registry);
private JSType getTypedefType(String name, DeclaredTypeRegistry registry) {
resolveTypedef(name, registry);
return registry.getTypedef(name).getType();
public void resolveTypedef(String name, DeclaredTypeRegistry registry) {
Typedef td = registry.getTypedef(name);
private JSType getEnumPropType(String name, DeclaredTypeRegistry registry) {
resolveEnum(name, registry);
return registry.getEnum(name).getPropType();
public void resolveEnum(String name, DeclaredTypeRegistry registry) {
EnumType e = registry.getEnum(name);
if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {
String name = n.getFirstChild().getFirstChild().getString();
Var v = t.getScope().getVar(name);
if (v == null || v.isGlobal()) {
exportMap.put(name, name);
test("export var a; export var b;", "var a; var b; module.exports = {a: a, b: b};");
Node name = varStatement.getFirstChild();
enclosingCase.getLastChild().addChildToBack(
IR.exprResult(IR.assign(name.detachFromParent(), name.removeFirstChild())));
hoistRoot.getParent().addChildAfter(IR.var(name.cloneTree()), hoistRoot);
if (dc == null) {
dc = new DeferredCheck(expr, expectedRetType,
currentScope, currentScope.getScope(calleeName));
dc.updateReturn(expectedRetType);
dc.updateArgTypes(argTypes);
ExtractionInfo templateInfo = extractMultilineTextualBlock(token);
List<String> templateString =
Splitter.on(" as")
.trimResults()
.splitToList(templateInfo.string);
if (templateString.size() >= 2) {
if (templateString.get(1).isEmpty()) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.expression.missing",
stream.getLineno(), stream.getCharno());
if (templateString.size() >= 3) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.found.multiple.as",
stream.getLineno(), stream.getCharno());
.split(templateString.get(0)));
if (isTypeTransformation && names.size() > 1) {
parser.addTypeWarning(
"msg.jsdoc.typetransformation.with.multiple.names",
stream.getLineno(), stream.getCharno());
token = templateInfo.token;
public void testParserWithTypeTransformation() {
parse("@template T as\n type('string')*/");
public void testParserWithTypeTransformationNewline() {
public void testParserWithAsKeywordTwice() {
parse("@template S as type('number') as type('string')*/",
"Bad type annotation. "
+ "Type transformation annotation must contain a single as");
return scanPostDigit(beginToken);
IR.getprop(subClassName.detachFromParent(), IR.string(staticMember)),
IR.getprop(superClassName.detachFromParent(), IR.string(staticMember))));
case Token.THIS:
visitThis(n, parent);
break;
private void visitThis(Node node, Node parent) {
Node enclosingMemberDef = NodeUtil.getEnclosingClassMember(node);
if (enclosingMemberDef == null) {
return;
Node enclosingClass = NodeUtil.getEnclosingClass(node);
if (enclosingMemberDef.isStaticMember()) {
parent.replaceChild(node,
IR.name(NodeUtil.getClassName(enclosingClass)).srcref(node));
compiler.reportCodeChange();
Node enclosingMember = NodeUtil.getEnclosingClassMember(enclosing);
methodName = IR.string(enclosingMember.getString()).srcref(enclosing);
public void testStaticMethodsWithThis() {
test(Joiner.on('\n').join(
"class C {",
"  static foo() { alert(this); }",
"}"
), Joiner.on('\n').join(
"/** @constructor @struct */",
"var C = function() {};",
"C.foo = function() { alert(C); };"
));
objectLiteral.addChildToBack(newProperty);
ParseTree value = parseExpression();
parseWarning(js, "this language feature is only supported in es6 mode: " +
"computed property");
for (Node arg = callNode.getFirstChild(); arg != null;
pair = analyzeExprFwd(
typeofRand, inEnv, JSType.UNKNOWN, comparedType.negate());
rhsType = rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
lhsType = lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
rhsType = rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
lhsType = lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
"Cannot create type with bits <<<%X>>>, " +
private static final JSType TOP_MINUS_NULL = new JSType(
TRUE_MASK | FALSE_MASK | NUMBER_MASK | STRING_MASK | UNDEFINED_MASK |
NON_SCALAR_MASK,
null, ImmutableSet.of(ObjectType.TOP_OBJECT), null, null);
private static final JSType TOP_MINUS_UNDEF = new JSType(
NON_SCALAR_MASK,
return UNKNOWN.removeType(this);
if ((isTop() || isUnknown()) && other.equals(NULL)) {
return TOP_MINUS_NULL;
if ((isTop() || isUnknown()) && other.equals(UNDEFINED)) {
return TOP_MINUS_UNDEF;
if (other.equals(NULL) || other.equals(UNDEFINED)) {
return new JSType(mask & ~other.mask, location, objs, typeVar, enums);
if (objs == null) {
(other.mask & ~NON_SCALAR_MASK) == 0 && other.objs.size() == 1);
&& pattern.getString().length() < 100
String longRegexp = "";
for (int i = 0; i < 200; i++) {
longRegexp += "x";
foldSame("x = RegExp(\"" + longRegexp + "\")");
return new JSType(TOP_SCALAR_MASK & ~mask);
return UNKNOWN;
"    x < 'asdf';\n" +
"  if (!(typeof x == 'number')) {\n" +
"    x - 5;\n" +
NewTypeInference.INVALID_OPERAND_TYPE);
"  if (typeof x !== 'number') {\n" +
"    x - 5;\n" +
NewTypeInference.INVALID_OPERAND_TYPE);
"  if (typeof x == 'number') {} else { x - 5; }\n" +
NewTypeInference.INVALID_OPERAND_TYPE);
"function f(/** (number|string) */ x) {\n" +
"  if (typeof x !== 'string') {\n" +
lhs, rhs, expr.getType(), inEnv, specializedType);
rhs, lhs, expr.getType(), inEnv, specializedType);
if (isTop() || isUnknown() || objs != null || typeVar != null) {
return new JSType(TOP_SCALAR_MASK & ~mask);
debugLog.append(str);
debugLog.append('\n');
logger.fine(str);
callNode.getFirstChild().getQualifiedName())) {
Node base = callNode.getLastChild();
while (base.isCast()) {
base = base.getFirstChild();
if (callNode.getLastChild().isQualifiedName()) {
baseClassNode = callNode.getLastChild();
reportBadBaseMethodUse(t, n, baseContainer, "Unknown class " + enclosingQname);
static final DiagnosticType DUPLICATE_PROPERTY_JSDOC = DiagnosticType.warning(
"JSC_DUPLICATE_PROPERTY_JSDOC",
"Found two JsDoc comments for property {0} of type {1}.\n");
for (NominalType superInterf: rawNominalType.getInterfaces()) {
for (String pname: nonInheritedPropNames) {
anonFunNames.put(fn, "%anon_fun" + freshId);
if (currentScope.isDefinedLocally(fnName)) {
warnings.add(JSError.make(
fn, VariableReferenceCheck.REDECLARED_VARIABLE, fnName));
warnings.add(JSError.make(getProp, DUPLICATE_PROPERTY_JSDOC,
warnings.add(JSError.make(getProp, DUPLICATE_PROPERTY_JSDOC,
warnings.add(JSError.make(propCreationNode, DUPLICATE_PROPERTY_JSDOC,
ArrayList<String> formals = Lists.newArrayList();
for (Node param = NodeUtil.getFunctionParameters(fn).getFirstChild();
param != null; param = param.getNext()) {
formals.add(param.getString());
return new Scope(fn, parentScope, formals, builder.buildDeclaration());
private final String name; // null for top scope
this.name =
parent == null ? null : NodeUtil.getFunctionName(root);
return !isDefinedLocally(name) && isVisibleInScope(name);
private static boolean debugging = false;
for (Object obj: objs) {
varNames.addAll(currentScope.getFormals());
if (currentScope.hasThis()) {
varNames.add("this");
for (Node key: expr.children()) {
QualifiedName pname = new QualifiedName(NodeUtil.getObjectLitKeyName(key));
JSType reqPtype = requiredType.mayHaveProp(pname) ?
requiredType.getProp(pname) : JSType.UNKNOWN;
JSType specPtype = specializedType.mayHaveProp(pname) ?
specializedType.getProp(pname) : JSType.UNKNOWN;
analyzeExprFwd(key.getLastChild(), env, reqPtype, specPtype);
currentScope.isOuterVar(varName)) {
JSType.TOP_OBJECT.withPropertyRequired(pname.getLeftmostName()));
for (String typeParam: typeParameters) {
for (String typeParam: typeParameters) {
if (mayWarnAboutNonObject(receiver, pname, recvType, specializedType)) {
for (Node key = expr.getLastChild();
key != null;
key = expr.getChildBefore(key)) {
new QualifiedName(NodeUtil.getObjectLitKeyName(key));
JSType reqPtype = requiredType.mayHaveProp(pname) ?
requiredType.getProp(pname) : JSType.UNKNOWN;
EnvTypePair pair = analyzeExprBwd(key.getLastChild(), env, reqPtype);
optionalFormals.add(t);
for (String unused: rawType.getTypeParameters()) {
for (JSTypeExpression texp: (implementedIntfs ?
builder.addOptFormal(null);
builder.addOptFormal(null);
String pname = param.getQualifiedName();
for (String pname: props.keySet()) {
for (ObjectType obj: objs) {
for (String pname: this.props.keySet()) {
for (ObjectType obj: objs) {
new Property(type, isDeclared ? type : null, false));
for (ObjectType obj: objs) {
for (ObjectType obj: objs) {
for (ObjectType obj: objs) {
for (ObjectType obj1: objs1) {
for (ObjectType obj2: objs2) {
for (String pname: obj2.props.keySet()) {
for (ObjectType obj2: objs2) {
for (ObjectType obj1: objs1) {
for (ObjectType obj2: objs2) {
for (ObjectType obj1: objs1) {
for (String p: props.keySet()) {
null, ImmutableList.of(BOTTOM), null, NUMBER).getFunType(),
ImmutableList.of(NUMBER), ImmutableList.of(STRING),
FunctionType.makeJSType(
null, ImmutableList.of(STRING), null, NUMBER));
FunctionType.makeJSType(
null, ImmutableList.of(STRING), NUMBER, NUMBER));
FunctionType.makeJSType(
null, null, STRING, NUMBER));
Set<JSError> warnings = Sets.newHashSet();
if (!isInterfaceMethodDef(fn) &&
private static boolean isInterfaceMethodDef(Scope methodScope) {
private Map<String, JSType> calcTypeInstantiation(
HashMap<String, JSType> typeMap = Maps.newHashMap();
typeMap.put(typeParam, JSType.UNKNOWN);
typeMap.put(typeParam, Iterables.getOnlyElement(types));
typeMap.put(typeParam, JSType.UNKNOWN);
return typeMap;
static final FunctionType BOTTOM_FUNCTION = FunctionType.normalized(
null, null, JSType.TOP, JSType.BOTTOM, null, null, null, false);
public boolean isBottomFunction() {
return this.equals(BOTTOM_FUNCTION);
return f2;
Preconditions.checkState(loose == false);
typeMultimap.remove(typeParam, other);
if (typeName.equals("boolean")) {
return JSType.BOOLEAN;
return JSType.NULL;
return JSType.NUMBER;
return JSType.STRING;
return JSType.UNDEFINED;
return JSType.fromTypeVar(typeName);
JSType namedType = registry.lookupTypeByName(typeName);
if (namedType == null) {
unknownTypeNames.put(n, typeName);
throw new UnknownTypeException("Unhandled type: " + typeName);
if (namedType.isTypeVariable()) {
return namedType;
return JSType.join(JSType.NULL, getNominalTypeHelper(
namedType, n, ownerType, registry, outerTypeParameters));
if (jsdocNode.getType() == Token.FUNCTION) {
import static com.google.javascript.jscomp.newtypes.FunctionType.BOTTOM_FUNCTION;
assertEquals(BOTTOM_FUNCTION,
FunctionType.meet(BOTTOM_FUNCTION, numToNum));
assertEquals(numToNum, FunctionType.join(BOTTOM_FUNCTION, numToNum));
if (source != null) {
return SimpleFormat.format("%s(%d, %d)", source.name, line + 1, column + 1);
return SimpleFormat.format("(%d, %d)", line + 1, column + 1);
Set<NominalType> interfaces = Sets.newHashSet(
typeParser.getImplementedInterfaces(
fnDoc, ownerType, parentScope, typeParameters));
for (NominalType interf : interfaces) {
if (interf.isClass()) {
warnings.add(JSError.make(
fn, TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, functionName));
interfaces.remove(interf);
ImmutableSet.copyOf(interfaces));
typeParser.getImplementedInterfaces(
fnDoc, ownerType, parentScope, typeParameters);
Set<NominalType> interfaces = Sets.newHashSet(
typeParser.getExtendedInterfaces(
fnDoc, ownerType, parentScope, typeParameters));
for (NominalType interf : interfaces) {
if (interf.isClass()) {
warnings.add(JSError.make(
fn, TypeCheck.CONFLICTING_EXTENDED_TYPE,
"interface", functionName));
interfaces.remove(interf);
ImmutableSet.copyOf(interfaces));
Preconditions.checkState(objs.size() == 1);
return Iterables.getOnlyElement(objs).getFunType();
public JSType getNodeTypeDeclaration(
JSDocInfo jsdoc, RawNominalType ownerType, DeclaredTypeRegistry registry) {
return namedType;
NominalType uninstantiated = namedType.getNominalTypeIfUnique();
ImmutableList<String> typeParameters =
uninstantiated.getRawNominalType().getTypeParameters();
builder.addRestFormals(
arg.getFirstChild(), ownerType, registry,
typeParameters));
ImmutableSet.Builder<NominalType> builder = ImmutableSet.builder();
for (JSTypeExpression texp: jsdoc.getImplementedInterfaces()) {
Node expRoot = texp.getRootNode();
if (hasKnownType(expRoot, ownerType, registry, typeParameters)) {
builder.add(
getNominalType(expRoot, ownerType, registry, typeParameters));
return builder.build();
for (JSTypeExpression texp: jsdoc.getExtendedInterfaces()) {
builder.add(
getNominalType(expRoot, ownerType, registry, typeParameters));
Preconditions.checkState(typeMap.containsKey(typeVar));
associatedNode, config, errorReporter);
this.sourceFile = associatedNode == null
? null : associatedNode.getStaticSourceFile();
this.associatedNode != null ?
this.associatedNode.getStaticSourceFile() :
null);
import com.google.common.collect.ImmutableSet;
ErrorReporter errorReporter) {
public static Node transformTree(ProgramTree node,
config, errorReporter);
Node irNode = irFactory.transform(node);
if (node.sourceComments != null) {
for (Comment comment : node.sourceComments) {
irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);
newBlock.setLineno(irNode.getLineno());
newBlock.setCharno(irNode.getCharno());
maybeSetLengthFrom(newBlock, node);
private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
private Comment getJsDocNode(ParseTree tree) {
Preconditions.checkNotNull(tree);
return null;
private Comment getJsDocNode(
Preconditions.checkNotNull(token);
return null;
private JSDocInfo handleJsDoc(ParseTree node, Node irNode) {
Comment comment = getJsDocNode(node);
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
validateTypeAnnotations(info, node);
com.google.javascript.jscomp.parsing.parser.Token token, Node irNode) {
Comment comment = getJsDocNode(token);
if (comment != null) {
JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);
parsedComments.add(comment);
if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {
JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();
if (info != null) {
return info;
return null;
private Node transform(ParseTree node) {
Node irNode = justTransform(node);
JSDocInfo jsDocInfo = handleJsDoc(node, irNode);
if (jsDocInfo != null) {
irNode = maybeInjectCastNode(node, jsDocInfo, irNode);
irNode.setJSDocInfo(jsDocInfo);
setSourceInfo(irNode, node);
return irNode;
private Node transformNodeWithInlineJsDoc(ParseTree node) {
Comment comment = getJsDocNode(node);
if (comment != null) {
JSDocInfo info = parseInlineTypeDoc(comment, irNode);
if (info != null) {
irNode.setJSDocInfo(info);
double value = Double.valueOf(token.toString());
JSDocInfo jsDocInfo = handleJsDoc(token, irNode);
return node.location.start.line + 1;
return node.location.start.column;
return token.location.start.line + 1;
return token.location.start.column;
if (node.location == null || node.location.start == null) {
return;
int lineno = lineno(node);
irNode.setLineno(lineno);
int charno = charno(node);
irNode.setCharno(charno);
maybeSetLengthFrom(irNode, node);
if (irNode.getLineno() == -1) {
int lineno = lineno(token);
irNode.setLineno(lineno);
int charno = charno(token);
irNode.setCharno(charno);
maybeSetLengthFrom(irNode, token);
private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {
irNode,
private JSDocInfo parseInlineTypeDoc(Comment node, Node irNode) {
irNode,
private void maybeSetLengthFrom(Node node, ParseTree source) {
node.setLength(source.location.end.offset - source.location.start.offset);
private void maybeSetLengthFrom(Node node,
com.google.javascript.jscomp.parsing.parser.Token source) {
node.setLength(source.location.end.offset - source.location.start.offset);
ret = newStringNode(Token.STRING, token.asLiteral().toString());
newName = processName(name);
Node lp = newNode(Token.PARAM_LIST);
for (ParseTree param : functionNode.formalParameterList.parameters) {
Node paramNode = transformNodeWithInlineJsDoc(param);
Preconditions.checkState(paramNode.isName());
lp.addChildToBack(paramNode);
node.addChildToBack(lp);
Node node = newNode(Token.LABEL);
node.addChildToBack(transformLabelName(labelTree.name));
for (ParseTree arg : exprNode.arguments.arguments) {
node.addChildToBack(transform(arg));
double value = Double.valueOf(literalNode.literalToken.asLiteral().value);
Node key;
Node value;
switch (el.type) {
case PROPERTY_NAME_ASSIGNMENT: {
PropertyNameAssignmentTree prop = el.asPropertyNameAssignment();
key = transformAsString(prop.name);
key.setType(Token.STRING_KEY);
value = transform(prop.value);
break;
case GET_ACCESSOR: {
GetAccessorTree prop = el.asGetAccessor();
key = transformAsString(prop.propertyName);
key.setType(Token.GETTER_DEF);
Node body = transform(prop.body);
value = IR.function(IR.name(""), IR.paramList(), body);
break;
case SET_ACCESSOR: {
SetAccessorTree prop = el.asSetAccessor();
key = transformAsString(prop.propertyName);
key.setType(Token.SETTER_DEF);
Node body = transform(prop.body);
value = IR.function(IR.name(""), IR.paramList(
safeProcessName(prop.parameter)), body);
break;
default:
throw new IllegalStateException("Unexpected node type: " + el.type);
key.addChildToFront(value);
flags = rawRegex.substring(rawRegex.lastIndexOf('/'));
setSourceInfo(literalStringNode, token);
private String normalizeString(String value) {
StringBuilder result = new StringBuilder();
int start = 1; // skip the leading quote
int cur = value.indexOf('\\');
if (cur == -1) {
return value;
while (cur != -1) {
if (cur - start > 0) {
result.append(value.substring(start, cur));
cur += 1; // skip the escape char.
char c = value.charAt(cur);
switch (c) {
case '\'':
case '"':
case '\\':
result.append(c);
break;
case 'b':
result.append('\b');
break;
case 'f':
result.append('\f');
break;
case 'n':
result.append('\n');
break;
case 'r':
result.append('\r');
break;
case 't':
result.append('\t');
break;
case 'v':
result.append('\u000B');
break;
case '\n':
break;
case '0':
result.append('\0');
break;
case 'x':
result.append((char)(
hexdigit(value.charAt(cur + 1)) * 16
+ hexdigit(value.charAt(cur + 2))));
cur += 2;
break;
case 'u':
result.append((char)(
hexdigit(value.charAt(cur + 1)) * 16 * 16 * 16
+ hexdigit(value.charAt(cur + 2)) * 16 * 16
+ hexdigit(value.charAt(cur + 3)) * 16
+ hexdigit(value.charAt(cur + 4))));
cur += 4;
break;
default:
result.append(c);
break;
start = cur + 1;
cur = value.indexOf('\\', start);
result.append(value.substring(start, value.length() -1));
return result.toString();
int hexdigit(char c) {
switch (c) {
case '0': return 0;
case '1': return 1;
case '2': return 2;
case '3': return 3;
case '4': return 4;
case '5': return 5;
case '6': return 6;
case '7': return 7;
case '8': return 8;
case '9': return 9;
case 'a': case 'A': return 10;
case 'b': case 'B': return 11;
case 'c': case 'C': return 12;
case 'd': case 'D': return 13;
case 'e': case 'E': return 14;
case 'f': case 'F': return 15;
throw new IllegalStateException("unexpected: " + c);
block.setLineno(lineno(caseNode));
block.setCharno(charno(caseNode));
maybeSetLengthFrom(block, caseNode);
block.setLineno(lineno(caseNode));
block.setCharno(charno(caseNode));
maybeSetLengthFrom(block, caseNode);
if (lineSet == false) {
setSourceInfo(block, cc);
lineSet = true;
block.addChildToBack(transform(cc));
return processVariableDeclarationList(stmt.declarations);
node.addChildToBack(transform(child));
Node node;
Comment comment = getJsDocNode(decl.lvalue);
if (comment != null && !comment.value.contains("@")) {
node = transformNodeWithInlineJsDoc(decl.lvalue);
node = transform(decl.lvalue);
abstract T processArrayLiteral(ArrayLiteralExpressionTree arrayLiteralExpressionTree);
abstract T processAstRoot(ProgramTree programTree);
abstract T processBlock(BlockTree blockTree);
abstract T processCatchClause(CatchTree catchTree);
abstract T processConditionalExpression(ConditionalExpressionTree conditionalExpressionTree);
abstract T processContinueStatement(ContinueStatementTree continueStatementTree);
abstract T processDoLoop(DoWhileStatementTree doWhileStatementTree);
abstract T processElementGet(MemberLookupExpressionTree memberLookupExpressionTree);
abstract T processEmptyStatement(EmptyStatementTree emptyStatementTree);
abstract T processExpressionStatement(ExpressionStatementTree expressionStatementTree);
abstract T processForInLoop(ForInStatementTree forInStatementTree);
abstract T processForLoop(ForStatementTree forStatementTree);
abstract T processFunctionCall(CallExpressionTree callExpressionTree);
abstract T processFunction(FunctionDeclarationTree functionDeclarationTree);
abstract T processIfStatement(IfStatementTree ifStatementTree);
abstract T processBinaryExpression(BinaryOperatorTree binaryOperatorTree);
abstract T processLabeledStatement(LabelledStatementTree labelledStatementTree);
abstract T processName(IdentifierExpressionTree identifierExpressionTree);
abstract T processNewExpression(NewExpressionTree newExpressionTree);
abstract T processNumberLiteral(LiteralExpressionTree literalNode);
abstract T processObjectLiteral(ObjectLiteralExpressionTree objectLiteralExpressionTree);
abstract T processParenthesizedExpression(ParenExpressionTree parenExpressionTree);
abstract T processPropertyGet(MemberExpressionTree memberExpressionTree);
abstract T processRegExpLiteral(LiteralExpressionTree literalNode);
abstract T processReturnStatement(ReturnStatementTree returnStatementTree);
abstract T processStringLiteral(LiteralExpressionTree literalNode);
abstract T processSwitchCase(CaseClauseTree caseClauseTree);
abstract T processSwitchStatement(SwitchStatementTree switchStatementTree);
abstract T processThrowStatement(ThrowStatementTree throwStatementTree);
abstract T processTryStatement(TryStatementTree tryStatementTree);
abstract T processUnaryExpression(UnaryExpressionTree unaryExpressionTree);
abstract T processVariableStatement(VariableStatementTree variableStatementTree);
abstract T processVariableDeclarationList(VariableDeclarationListTree decl);
abstract T processWhileLoop(WhileStatementTree whileStatementTree);
abstract T processWithStatement(WithStatementTree withStatementTree);
abstract T processDebuggerStatement(DebuggerStatementTree asDebuggerStatement);
abstract T processThisExpression(ThisExpressionTree asThisExpression);
abstract T processSwitchDefault(DefaultClauseTree asDefaultClause);
abstract T processBooleanLiteral(LiteralExpressionTree literalNode);
abstract T processNullLiteral(LiteralExpressionTree literalNode);
break;
case GET_ACCESSOR:
break;
case PROPERTY_NAME_ASSIGNMENT:
break;
break;
eat(TokenType.OPEN_PAREN);
eat(TokenType.CLOSE_PAREN);
eat(TokenType.OPEN_PAREN);
eat(TokenType.CLOSE_PAREN);
return new FormalParameterListTree(null, result.build());
elements.add(NullTree.Instance);
private NullTree(SourceRange location) {
public void disable_testJSDocAttachment1() {
public void disable_testJSDocAttachment2() {
public void disable_testJSDocAttachment3() {
public void disable_testJSDocAttachment4() {
public void disable_testJSDocAttachment5() {
public void disable_testJSDocAttachment6() throws Exception {
public void disable_testJSDocAttachment7() {
public void disable_testJSDocAttachment8() {
public void disable_testJSDocAttachment9() {
public void disable_testJSDocAttachment10() {
public void disable_testJSDocAttachment11() {
public void disable_testJSDocAttachment12() {
public void disable_testJSDocAttachment13() {
public void disable_testJSDocAttachment14() {
public void disable_testJSDocAttachment15() {
public void disable_testJSDocAttachment16() {
public void disable_testJSDocAttachment17() {
public void disable_testJSDocAttachment18() {
public void disable_testJSDocAttachment19() {
public void disable_testJSDocAttachment20() {
public void disable_testInlineJSDocAttachment1() {
public void disable_testInlineJSDocAttachment2() {
public void disable_testInlineJSDocAttachment3() {
public void disable_testInlineJSDocAttachment4() {
public void disable_testInlineJSDocAttachment5() {
public void disable_testInlineJSDocAttachment6() {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {
public void disable_testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {
public void disable_testSuspiciousBlockCommentWarning1() {
public void disable_testSuspiciousBlockCommentWarning2() {
public void disable_testSuspiciousBlockCommentWarning3() {
public void disable_testSuspiciousBlockCommentWarning4() {
public void disable_testSuspiciousBlockCommentWarning5() {
public void disable_testSuspiciousBlockCommentWarning6() {
public void disable_testSuspiciousBlockCommentWarning7() {
public void disable_testSuspiciousBlockCommentWarning8() {
public void disable_testFileOverviewJSDoc1() {
public void disable_testFileOverviewJSDoc2() {
public void disable_testParseBlockDescription() {
if (root.isFunction()) {
return NodeUtil.getFunctionBody(root);
return root;
rhs.isVar() && rhsPair.type.isUnknown()) {
Node rhs = vdecl.getFirstChild();
TypeEnv env = inEnv;
if (rhs != null) {
env = analyzeExprFwd(rhs, inEnv).env;
envPutType(env, name, JSType.STRING), JSType.STRING);
Node rhs = vdecl.getFirstChild();
TypeEnv env = outEnv;
if (rhs != null) {
env = analyzeExprBwd(rhs, outEnv).env;
envPutType(env, name, JSType.UNKNOWN), JSType.UNKNOWN);
public boolean isTrue() {
return TRUE_MASK == type;
public boolean isFalse() {
return FALSE_MASK == type;
if (currentScope.isUndeclaredFormal(varName) &&
if (!ctorType.isSubtypeOf(JSType.topFunction()) ||
!ctorFunType.isConstructor()) {
if ((specializedType.isTruthy() || specializedType.isFalsy()) ?
JSType.BOTTOM.equals(JSType.meet(recvType, JSType.TOP_OBJECT)) :
!recvType.isSubtypeOf(JSType.TOP_OBJECT)) {
class LValueResult {
case Token.NEW: {
case Token.NEW: {
if (isUnknown()) {
name.setJSDocInfo(createConstantJsDoc());
decl.getFirstChild().setJSDocInfo(createConstantJsDoc());
private JSDocInfo createConstantJsDoc() {
JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
builder.recordConstancy();
return builder.build(null);
private Set<String> modulesWithExports = Sets.newHashSet();
visitModuleExports(n);
script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
.copyInformationFromForTree(script));
emitOptionalModuleExportsOverride(script, moduleName);
NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
moduleName));
private void emitOptionalModuleExportsOverride(Node script,
String moduleName) {
if (!modulesWithExports.contains(moduleName)) {
Node moduleExportsProp = IR.getprop(IR.name(moduleName),
IR.string("module$exports"));
script.addChildToBack(IR.ifNode(
moduleExportsProp,
IR.block(IR.exprResult(IR.assign(IR.name(moduleName),
moduleExportsProp.cloneTree())))).copyInformationFromForTree(
script));
private void visitModuleExports(Node prop) {
String moduleName = guessCJSModuleName(prop.getSourceFileName());
Node module = prop.getChildAtIndex(0);
module.putProp(Node.ORIGINALNAME_PROP, "module");
module.setString(moduleName);
Node exports = prop.getChildAtIndex(1);
exports.putProp(Node.ORIGINALNAME_PROP, "exports");
exports.setString("module$exports");
modulesWithExports.add(moduleName);
private static final String EXPORTS = "exports";
n.setString(suffix);
n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);
Scope.Var var = t.getScope().getVar(name);
if (var != null && var.isGlobal()) {
n.setString(name + "$$" + suffix);
n.putProp(Node.ORIGINALNAME_PROP, name);
IR.exprResult(IR.assign(IR.name("exports"), onlyExport))
.copyInformationFromForTree(onlyExport));
test("define({test: 1})", "exports = {test: 1}");
"var module$foo$bar={},module$foo$bar={foo:1};");
"var module$foo$bar={},module$foo$bar={foo:1};");
Node expectedRoot = parse(compiled, options, normalizeResults);
Node expectedRoot = parse(compiled, options, normalizeResults);
Node expectedRoot = parse(compiled, options, normalizeResults);
"var module$test = {};" +
"var module$test = {};" +
"module$test.module$exports = function() {};" +
"if(module$test.module$exports)" +
"module$test=module$test.module$exports");
test("define({foo: 'bar'})", "exports={foo: 'bar'}");
tracker.outputTracerReport(outStream == null ?
System.out : outStream);
+ "If the number given is less than 1, the driver will run until "
+ "first error (either in Fuzzer or Compiler) is found. "
+ "Default: 1")
private int numberOfRuns = 1;
File file = new File(configFileName);
try {
return new JSONObject(Files.toString(
file, StandardCharsets.UTF_8));
e.printStackTrace();
return null;
return numberOfRuns < 1;
if (result.success && result.warnings.length == 0) {
getLogger().info("Compilation Succeeded!");
getLogger().info(debugInfo);
getLogger().warning("Compilation Failed!");
getLogger().info(debugInfo);
getLogger().log(Level.SEVERE, "Compiler error!\n", e);
getLogger().warning(debugInfo);
lines1[1].trim().startsWith("throw") &&
lines2[1].trim().startsWith("throw")) {
name = scopeManager.getRandomSymbol(true).name;
new Symbol("JSON", Type.FUNCTION),
if (symbol != null && localSymbols().remove(symbol)) {
numSym--;
if (excludeLocal && localSymbols().indexOf(sym) != -1) {
sb.append(Fuzzer.getPrettyCode(script));
logger.info(sb.toString());
sb.append(Fuzzer.getPrettyCode(script));
sb.append(Fuzzer.getPrettyCode(script));
import java.util.Stack;
Stack<String> currentLabels = scopeManager.localScope().labels;
Stack<String> currentLabels = scopeManager.localScope().labels;
Stack<String> currentLabels = scopeManager.localScope().labels;
currentLabels.push(labelName);
currentLabels.pop();
scopeManager.addScope();
scopeManager.addScope();
import java.util.Stack;
Stack<String> labels = new Stack<String>();
import java.util.Stack;
private Stack<Scope> scopeStack = new Stack<Scope>();
public void addScope() {
ArrayList<Scope> scopes = new ArrayList<Scope>(getNumScopes());
Scope s = scopeStack.get(i);
scopes.add(s);
Scope s = scopeStack.get(i);
scopes.add(s);
Random random = new Random(System.currentTimeMillis());
Random random = new Random();
Random random = new Random();
Random random = new Random();
Random random = new Random();
scope.labels.push("testLabel");
scope.labels.push("testLabel");
import java.util.Map;
public DiscreteDistribution(Random random, Map<T, Double> pmf) {
items = new ArrayList<T>(pmf.size());
weights = new ArrayList<Double>(pmf.size());
for (T item : pmf.keySet()) {
double p = pmf.get(item);
Preconditions.checkArgument(p >= 0);
Preconditions.checkArgument(!Double.isInfinite(p));
Preconditions.checkArgument(!Double.isNaN(p));
weights.add(p);
sum += p;
items.add(item);
for (int i = 0; i < pmf.size(); i++) {
import java.util.ArrayList;
public Compiler compile(String code) {
compiler.compile(Arrays.asList(SourceFile.fromCode("[externs]", "")),
return compiler;
public Compiler compile(Node script) {
compiler.compileModules(
new ArrayList<SourceFile>(), Arrays.asList(jsModule), getOptions());
return compiler;
public static void main(String[] args) {
Compiler compiler = driver.compile(script);
Result result = compiler.getResult();
System.out.println("Success!\n");
import com.google.common.collect.Maps;
import java.util.Map;
symbolTable.addScope();
Map<Expression, Double> pmf = Maps.newHashMap();
pmf.put(expr, expr.weight);
new DiscreteDistribution<Expression>(random, pmf);
Map<Statement, Double> pmf = Maps.newHashMap();
pmf.put(stmt, stmt.weight);
new DiscreteDistribution<Statement>(random, pmf);
import java.util.HashMap;
private int size = 0;
storage.push(new ArrayList<String>());
HashMap<List<String>, Double> pmf = new HashMap<List<String>, Double>();
List<String> scope = storage.get(i);
pmf.put(scope, Double.valueOf(scope.size()));
List<String> scope = storage.get(i);
pmf.put(scope, Double.valueOf(scope.size()));
new DiscreteDistribution<List<String>>(random, pmf);
Fuzzer fuzzer = spy(new Fuzzer(new Random()));
if (!strictExternCheck || !t.getInput().isExtern()) {
if (last.getType() == type &&
NodeUtil.isAssociative(type)) {
addExpr(first, p, context);
cc.addOp(opstr, true);
addExpr(last, p, rhsContext);
"var a,b,c;a||b||c;a*b*c;a|b|c");
assertPrint("var a={};for (var i = a || a || (\"size\" in a);;);",
" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);" +
" return ((a=b.id) && (a=parseInt(a.substr(1))) && 0<a);" +
"if (x < 1 || x > 1 || 1 < x || 1 > x) { alert(x) }",
"   (1 > x || 1 < x || 1 < x || 1 > x) && alert(x) ");
test("var AA;(function () {AA=1})()",
"(function () {1})()");
test("/** @const */var aa;(function () {aa=1})()", "(function () {1})()");
test("/** @const */var aa;(function () {aa=1})(); var z=aa",
"(function () {1})(); var z=1");
!staleVars.contains(v) &&
referenceInfo.isWellDefined() &&
referenceInfo.isAssignedOnceInLifetime() &&
(isInlineableDeclaredConstant(v, referenceInfo) ||
referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
boolean isOnlyAssignmentSameScopeAsDeclaration() {
Reference ref = getOneAndOnlyAssignment();
Preconditions.checkNotNull(ref);
for (BasicBlock block = ref.getBasicBlock();
block != null; block = block.getParent()) {
if (block.isFunction) {
if (ref.getSymbol().getScope() != ref.scope) {
return false;
return true;
public void testExternalIssue1053() {
testSame(
"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}");
!staleVars.contains(v) && referenceInfo.isWellDefined() &&
referenceInfo.isAssignedOnceInLifetime()) {
flags.setMutatesThis();
Node objectNode = getCallThisObject(callSite);
&& !isCallOrApply(callSite)) {
&& !isCallOrApply(callSite)) {
private static Node getCallThisObject(Node callSite) {
Node callTarget = callSite.getFirstChild();
if (!NodeUtil.isGet(callTarget)) {
return null;
String propString = callTarget.getLastChild().getString();
if (propString.equals("call") || propString.equals("apply")) {
return callTarget.getNext();
return callTarget.getFirstChild();
Node callTarget = callSite.getFirstChild();
if (NodeUtil.isGet(callTarget)) {
String propString = callTarget.getLastChild().getString();
if (propString.equals("call") || propString.equals("apply")) {
return true;
return false;
public void setAllFlags() {
public void clearAllFlags() {
public void setMutatesGlobalState() {
public void setThrows() {
public void setMutatesThis() {
public void setMutatesArguments() {
public void setReturnsTainted() {
unrollBinaryOperator(n, Token.COMMA, ",", context, Context.OTHER, 0, 0);
addExpr(n, isArrayOrFunctionArgument ? 1 : 0, Context.OTHER);
for (AliasUsage aliasUsage : traversal.getAliasUsages()) {
aliasUsage.applyAlias();
private interface AliasUsage {
public void applyAlias();
private class AliasedNode implements AliasUsage {
private final Node aliasReference;
private final Node aliasDefinition;
AliasedNode(Node aliasReference, Node aliasDefinition) {
this.aliasReference = aliasReference;
this.aliasDefinition = aliasDefinition;
private class AliasedTypeNode implements AliasUsage {
private final Node typeReference;
private final Node aliasDefinition;
private final String aliasName;
AliasedTypeNode(Node typeReference, Node aliasDefinition,
String aliasName) {
this.typeReference = typeReference;
this.aliasDefinition = aliasDefinition;
this.aliasName = aliasName;
String typeName = typeReference.getString();
typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
Node aliasedNode = aliasVar.getInitialValue();
aliasUsages.add(new AliasedNode(n, aliasedNode));
Node aliasedNode = aliasVar.getInitialValue();
aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));
System.err.println(param);
void remove();
public void remove() {
public void remove() {
public void remove() {
t.getCompiler().reportCodeChange();
compiler.reportCodeChange();
compiler.reportChangeToEnclosingScope(decl.getNode());
compiler.reportCodeChange();
compiler.reportCodeChange();
if (comp.hasScopeChanged(jsRoot)) {
cb.visit(comp, jsRoot);
traverse(comp, jsRoot,
new AbstractPreOrderCallback() {
public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {
if (n.isFunction() && comp.hasScopeChanged(n)) {
cb.visit(comp, n);
return true;
if (!scopes.isEmpty()) {
compiler.setScope(scopes.peek().getRootNode());
Node main, boolean verifyUnchangedNodes) {
NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);
compiler.reportCodeChange();
boolean changed = false;
declaration.remove();
changed = true;
if (changed) {
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
compiler.reportCodeChange();
NodeUtil.verifyScopeChanges(mtoc, mainRoot, false);
private void addDeadCodeElimination() {
passes.add(new PassFactory("removeUnreachableCode", false) {
return new UnreachableCodeElimination(compiler, true);
private void addInlineVariables() {
passes.add(new PassFactory("inlineVariables", false) {
return new InlineVariables(compiler, InlineVariables.Mode.ALL, true);
protected boolean analyzeChangedFunsOnly = true;
abstract void reportChangeToScope(Node n);
abstract Node getEnclosingScope(Node n);
if (phaseOptimizer != null) {
return phaseOptimizer.hasScopeChanged(n);
return true;
void reportChangeToScope(Node n) {
phaseOptimizer.reportChangeToScope(n);
Node getEnclosingScope(Node n) {
while (n != jsRoot && n.getParent() != null) {
n = n.getParent();
if (n.isFunction()) {
return n;
return n;
compiler.reportChangeToScope(fn);
compiler.reportChangeToScope(var);
compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));
compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));
compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));
compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));
NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);
setSanityCheckState();
currentScope = n.isFunction() ? n : compiler.getEnclosingScope(n);
void reportChangeToScope(Node n) {
n.setChangeTime(timestamp);
public MultiPassTest() {}
if (NodeUtil.hasFinally(n)) {
Node finallyBlock = n.getLastChild();
tryMinimizeExits(finallyBlock, exitType, labelName);
fold("function f(){try{return;}catch(e){return;}finally{return}}",
"function f(){try{}catch(e){}finally{}}");
fold("function f(){try{return;}finally{return;}}",
"function f(){try{}finally{}}");
fold("function f(){try{g:if(a()){} return;}finally{return}}",
"function f(){try{g:if(a()){}}finally{}}");
while (n != jsRoot) {
if (n.isFunction()) { return n; }
jsRoot = root;
void maybeSanityCheck(Node externs, Node root) {
currentScope = n;
currentScope = root;
import com.google.javascript.jscomp.NodeTraversal.AbstractPreOrderCallback;
import java.util.HashMap;
private Map<Node, Node> findCorrespondingNodes(Node n1, Node n2) {
Preconditions.checkState(n1.isEquivalentTo(n2));
Map<Node, Node> correspondingNodes = new HashMap<Node, Node>();
correspondingNodes.put(n1, n2);
correspondingNodesHelper(correspondingNodes, n1, n2);
return correspondingNodes;
private void correspondingNodesHelper(Map<Node, Node> map, Node n1, Node n2) {
if (n1.isFunction()) {
map.put(n1, n2);
for (Node child1 = n1.getFirstChild(), child2 = n2.getFirstChild();
child1 != null;
child1 = child1.getNext(), child2 = child2.getNext()) {
correspondingNodesHelper(map, child1, child2);
final Map<Node, Node> nodeMap =
findCorrespondingNodes(mainRoot, mainRootClone);
if (mainRoot.getChangeTime() != 0) {
assertFalse(mainRoot.isEquivalentToShallow(nodeMap.get(mainRoot)));
NodeTraversal.traverse(compiler, mainRoot,
new AbstractPreOrderCallback() {
public final boolean shouldTraverse(
NodeTraversal t, Node n, Node p) {
if (n.isFunction() &&
n.getChangeTime() != 0 && nodeMap.containsKey(n)) {
assertFalse(n.isEquivalentToShallow(nodeMap.get(n)));
return true;
public void testSanityCheck() {
Loop loop = optimizer.addFixedPointLoop();
addLoopedPass(loop, "x", 1);
addOneTimePass("z");
optimizer.setSanityCheck(
createPassFactory("sanity", createPass("sanity", 0), false));
assertPasses("x", "sanity", "x", "sanity", "z", "sanity");
private final CodeChangeHandler recentChange = new CodeChangeHandler();
compiler.addChangeHandler(recentChange);
tracer = newTracer();
endPass(externs, root);
private void endPass(Node externs, Node root) {
private Tracer newTracer() {
String comment = name +
(recentChange.hasCodeChanged() ? " on recently changed AST" : "");
if (tracker != null) {
tracker.recordPassStart(name, factory.isOneTimePass());
return new Tracer("JSCompiler", comment);
+ "/* @param {Function} childCtor Child class.\n"
+ "/** @param {function()} f \n@param {number} */\n"
"foo((/** @type {function(string)} */" +
"function(baz) { var f = baz; }))\n");
private final int hashcode;
public Iterable<JSType> getAlternates() {
&& alternates.size() != that.alternates.size()) {
for (JSType alternate : that.alternates) {
for (JSType alternate : alternates) {
Iterable<JSType> getAlternates() {
Node normalizeCheckExternsRootClone = root.getFirstChild();
Node normalizeCheckMainRootClone = root.getLastChild();
return new ClosurePassAndRenameVars(compiler);
return renameVars = new RenameVars(compiler, prefix,
boolean normalizedExpectedJs = false;
super.enableNormalize(false);
super.disableNormalize();
Set<String> currentPropertyNames =
interfaceType.getImplicitPrototype().getOwnPropertyNames();
token == JsDocToken.PIPE) {
return this.wrapsSameRawType(thatType)
&& (thisParameter.isSubtype(thatParameter)
|| thatParameter.isSubtype(thisParameter));
return this.getReferencedTypeInternal().isSubtype(thatType);
return thisType.toMaybeUnionType().meet(thatType);
return thatType.toMaybeUnionType().meet(thisType);
if (t.isUnknownType() || !t.isSubtype(type)) {
Asserts.assertTypeEquals(type, getType(name));
public void testAssertWithIsDef() {
assertTypeEquals(NULL_TYPE,
registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE),
public boolean canAssignTo(JSType that) {
return referencedType.canAssignTo(that);
public boolean canAssignTo(JSType that) {
boolean canAssign = true;
for (JSType t : alternates) {
if (t.isUnknownType()) {
return true;
canAssign &= t.canAssignTo(that);
return canAssign;
public boolean canAssignTo(JSType that) {
return true;
createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),
createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),
createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),
+ " * @param {*} opt_value\n"
+ " * @param {*} var_args\n"
+ " * @param {*} var_args\n"
+ " * @param {*} opt_value\n"
+ " * @param {*} opt_value\n"
+ " * @param {*} opt_str\n"
+ " * @param {*} opt_pattern\n"
+ " * @param {*} opt_flags\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {*} opt_message\n"
+ " * @param {*} opt_file\n"
+ " * @param {*} opt_line\n"
+ " * @param {string} opt_location\n"
"/** @constructor \n * @param {*} arg \n @return {string} */" +
+ "expected: function (new:String, *): string");
+ "expected: function (new:String, *): string");
+ "expected: function (new:String, *): string");
+ "expected: function (new:String, *): string");
"/** Object. \n * @param {*} x \n * @constructor */ " +
"/** Object. \n * @param {*} x \n * @constructor */ " +
testSame("/** @constructor \n @param {*} var_args \n @return {!Array} */"
+ "function Array(var_args) {}\n",
"/** @constructor */ function Foo() {}\n"
+ "/** @constructor */ function Bar() {}\n"
+ "var a = [];\n"
+ "a[0] = new Foo;\n"
+ "a[1] = new Bar;\n"
+ "var b = a[0];\n"
+ "var c = [new Foo, new Bar];\n", null);
"/** @constructor \n * @param {*} x */ function Object(x) {}" +
UNKNOWN_TYPE, createUnionType(VOID_TYPE, NUMBER_TYPE)),
assertEquals("function (new:Boolean, *): boolean",
assertEquals("function (new:Number, *): number",
assertEquals("function (new:String, *): string",
if (isConstructor || isInterface) {
implementedInterfaces = Lists.newArrayList();
for (JSTypeExpression t : info.getImplementedInterfaces()) {
JSType maybeInterType = t.evaluate(scope, typeRegistry);
if (maybeInterType != null &&
maybeInterType.setValidator(new ImplementedTypeValidator())) {
implementedInterfaces.add((ObjectType) maybeInterType);
reportWarning(CONSTRUCTOR_REQUIRED, "@implements", fnName);
if (functionType.hasImplementedInterfaces()) {
compiler.report(t.makeError(n,
CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));
for (ObjectType type : implementedInterfaces) {
registry.registerTypeImplementingInterface(this, type);
this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);
((context == Context.IN_FOR_INIT_CLAUSE) &&
(n.isIn()))){
add(n, clearContextForNoInOperator(context));
private  Context clearContextForNoInOperator(Context context) {
return (context == Context.IN_FOR_INIT_CLAUSE
? Context.OTHER : context);
Node defNode = reachingDef.getDef(name, cfgNode);
if (defNode != null &&
!reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {
candidates.add(new Candidate(name, defNode, n, cfgNode));
private final Node defCfgNode;
Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {
this.defCfgNode = defCfgNode;
if (defCfgNode.isFunction()) {
getDefinition(defCfgNode, null);
if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {
Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);
if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&
defCfgNode.getNext() != useCfgNode) {
cfg.getDirectedGraphNode(defCfgNode),
private static class Definition {
Node getDef(String name, Node useNode) {
Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
if (def == null) {
return null;
return def.node;
boolean dependsOnOuterScopeVars(String name, Node useNode) {
Preconditions.checkArgument(getCfg().hasNode(useNode));
GraphNode<Node, Branch> n = getCfg().getNode(useNode);
FlowState<MustDef> state = n.getAnnotation();
Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
inline("var x = 1; L: x = 2; print(x)", "var x = 1; print(2)");
inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; print(2)");
inline("var x = 1; L: M: N: x = 2; print(x)", "var x = 1; print(2)");
"function f(a) {return a + 'xy'}");
assertSame(def, defUse.getDef("param1", use));
assertNotSame(def, defUse.getDef("param1", use));
assertNotSame(def, defUse.getDef("param1", use));
assertNotSame(def, defUse.getDef("param1", use));
assertSame(def, defUse.getDef("x", use));
assertNotSame(def, defUse.getDef("x", use));
if (type == Token.NAME && !varName.equals(nextNode.getString())) {
boolean blocked = false;
if (nextParent == null) {
blocked = true;
boolean assignsName = (nextParent.isAssign()
&& nextNode == nextParent.getFirstChild());
boolean isVarDeclaration = (nextParent.isVar());
if (!assignsName && !isVarDeclaration) {
blocked = true;
if (blocked) {
lookAhead = null;
return;
case Token.NE: {
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
ensureTyped(t, n, BOOLEAN_TYPE);
break;
return this.isSubtype(that) || that.isSubtype(this);
"condition always evaluates to the same value\n" +
"condition always evaluates to the same value\n" +
"condition always evaluates to the same value\n" +
"condition always evaluates to the same value\n" +
scope = traverse(constructor, scope);
for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
scope = traverse(arg, scope);
assertEquals(type, getType(name));
allowKeywordAsObjectPropertyName = false;
allowKeywordAsObjectPropertyName
= (languageVersion >= Context.VERSION_1_8);
public boolean isAllowKeywordAsObjectPropertyName() {
return allowKeywordAsObjectPropertyName;
public void setAllowKeywordAsObjectPropertyName(boolean flag) {
this.allowKeywordAsObjectPropertyName = flag;
env.setAllowKeywordAsObjectPropertyName(true);
private boolean allowKeywordAsObjectPropertyName;
!(compilerEnv.isAllowKeywordAsObjectPropertyName()
if ((peekToken() != Token.COLON
&& ("get".equals(propertyName)
|| "set".equals(propertyName))))
boolean allowKeywordsAsObjectLiteralsKeys = false;
allowKeywordsAsObjectLiteralsKeys = false;
allowKeywordsAsObjectLiteralsKeys = true;
allowKeywordsAsObjectLiteralsKeys = true;
allowKeywordsAsObjectLiteralsKeys = true;
CompilerEnvirons environment = new CompilerEnvirons();
environment.setReservedKeywordAsIdentifier(
allowKeywordsAsObjectLiteralsKeys);
CompilerEnvirons environment = new CompilerEnvirons();
compilerEnv.setAllowKeywordAsObjectPropertyName(acceptEs5);
registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis;
"function ((Object|null)=, (Object|null)=): ?",
"var google = {\n"+
"actual parameter 1 of f does not match formal parameter\n"+
"actual parameter 1 of f does not match formal parameter\n"+
validator.expectCanAssignToPropertyOf(
t, assign, getJSType(rvalue),
type.getPropertyType(property), object, property);
return;
setPrototype(
new PrototypeObjectType(
registry,
this.getReferenceName() + ".prototype",
registry.getNativeObjectType(OBJECT_TYPE),
isNativeObjectType()),
null);
baseType.isFunctionPrototypeType() ||
!(baseType instanceof PrototypeObjectType)) {
setPrototype((PrototypeObjectType) baseType, propertyNode);
boolean setPrototype(PrototypeObjectType prototype, Node propertyNode) {
PrototypeObjectType oldPrototype = prototypeSlot == null
? null : (PrototypeObjectType) prototypeSlot.getType();
((PrototypeObjectType) prototypeSlot.getType()).clearCachedValues();
registry.createConstructorType(null, null, null, null);
for (int i = prevCutPosition; i < code.length() - 1; i++) {
code.setCharAt(i, code.charAt(i+1));
code.setLength(code.length() - 1);
reportLineCut(lineIndex, prevCutPosition, false);
"\"123456789012345678901234567890\";\"1234567890\";\n");
"Infinity"
if (a.equals("NaN") || a.equals("Infinity")) {
private ProcessProperties() {
symbolStack.push(new NameContext(globalNode));
symbolStack.peek().scope = t.getScope();
if (isPrototypePropertyAssign(n)) {
symbolStack.push(new NameContext(getNameInfoForName(
n.getFirstChild().getLastChild().getString(), PROPERTY)));
String name = parent.isName() ?
parent.getString() /* VAR */ :
n.getFirstChild().getString() /* named function */;
symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));
symbolStack.push(new NameContext(anonymousNode));
if (propName.equals("prototype")) {
processPrototypeParent(t, parent);
addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
addSymbolUse(propName, t.getModule(), PROPERTY);
!(parent.isAssign() &&
parent.getFirstChild().isGetProp() &&
parent.getFirstChild().getLastChild().getString().equals(
"prototype"))) {
if (!processGlobalFunctionDeclaration(t, n, parent,
parent.getParent())) {
context.name.readClosureVariables = true;
if (isPrototypePropertyAssign(n) ||
isGlobalFunctionDeclaration(t, n) ||
n.isFunction()) {
return t.inGlobalScope() &&
(NodeUtil.isFunctionDeclaration(n) ||
n.isFunction() &&
n.getParent().isName());
private boolean isPrototypePropertyAssign(Node assign) {
Node n = assign.getFirstChild();
if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
&& n.isGetProp()
&& assign.getParent().isExprResult()) {
boolean isChainedProperty =
n.getFirstChild().isGetProp();
if (isChainedProperty) {
Node child = n.getFirstChild().getFirstChild().getNext();
if (child.isString() &&
child.getString().equals("prototype")) {
return true;
return false;
Node nameNode, Node parent, Node gramps) {
new GlobalFunction(nameNode, parent, gramps, t.getModule()));
private void processPrototypeParent(NodeTraversal t, Node n) {
Property prop = new AssignmentProperty(grandParent, t.getModule());
key, key.getFirstChild(), map, n, t.getModule());
class GlobalFunction implements Symbol {
GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {
AssignmentProperty(Node node, JSModule module) {
JSModule module) {
Scope scope;
NameContext(NameInfo name) {
if(deepestCommonModuleRef == null) {
logger.fine("Moved method: " +
proto.getQualifiedName() + "." + nameInfo.name +
" from module " + prop.getModule() + " to module " +
deepestCommonModuleRef);
public JSType getLeastSupertype(JSType that) {
if (!that.isRecordType()) {
return super.getLeastSupertype(that);
RecordType thatRecord = that.toMaybeRecordType();
RecordTypeBuilder builder = new RecordTypeBuilder(registry);
for (String property : properties.keySet()) {
if (thatRecord.hasProperty(property) &&
thatRecord.getPropertyType(property).isEquivalentTo(
getPropertyType(property))) {
builder.addProperty(property, getPropertyType(property),
getPropertyNode(property));
return builder.build();
RecordType thatRecord = (RecordType) that;
JSType subRecordType = builder.build();
JSType leastSupertype = recordType.getLeastSupertype(subRecordType);
builder = new RecordTypeBuilder(registry);
builder.addProperty("b", STRING_TYPE, null);
assertTypeEquals(leastSupertype, builder.build());
JSType subRecordType = builder.build();
JSType leastSupertype = recordType.getLeastSupertype(subRecordType);
assertTypeEquals(leastSupertype, OBJECT_TYPE);
int firstDot = symbol.indexOf(".");
Preconditions.checkState(firstDot != -1);
Var owner = functionScope.getVar(symbol.substring(0, firstDot));
Scope ownerScope = owner == null ? functionScope : owner.getScope();
ownerScope.declare(symbol, node, bottomType, null);
public void testGlobalQualifiedNamesInLocalScopes() {
SymbolTable table = createSymbolTable(
"/** @const */ var x = {}; function f() { x.number = 3; }");
Symbol xNumber = getLocalVar(table, "x.number");
assertNotNull(xNumber);
assertTrue(table.getScope(xNumber).isGlobalScope());
assertEquals("?", xNumber.getType().toString());
static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error(
static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error(
DiagnosticType.error(
"The template type must be an object type");
DiagnosticType.error(
JSType iArgumentType = null;
iArgumentType = getJSType(iArgument).restrictByNotNullOrUndefined();
if (!(iArgumentType instanceof ObjectType)) {
TEMPLATE_TYPE_NOT_OBJECT_TYPE));
jArgumentFnType, (ObjectType) iArgumentType));
FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);
TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);
TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);
FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);
childType + " has no properties", getNativeType(OBJECT_TYPE))) {
if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
return false;
if (that.isRecordType()) {
return that.getGreatestSubtype(this);
if (that instanceof RecordType) {
return RecordType.isSubtype(this, (RecordType) that);
public class RecordType extends PrototypeObjectType {
if (!(other instanceof RecordType)) {
RecordType otherRecord = (RecordType) other;
RecordType thatRecord = (RecordType) that;
public JSType getGreatestSubtype(JSType that) {
JSType greatestSubtype = super.getGreatestSubtype(that);
if (greatestSubtype.isNoObjectType() && !that.isNoObjectType()) {
altPropType.isEquivalentTo(propType))) {
public boolean isRecordType() {
return true;
return RecordType.isSubtype(this, (RecordType) that);
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("{");
int i = 0;
for (String property : properties.keySet()) {
if (i > 0) {
sb.append(", ");
sb.append(property);
sb.append(": ");
sb.append(properties.get(property).toString());
++i;
sb.append("}");
return sb.toString();
"undefined has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +
"null has no properties\n" +
"undefined has no properties\n" +
"undefined has no properties\n" +
int endCharno = stream.getCharno();
jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,
true);
int endCharno = stream.getCharno();
jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,
matchingLC);
public boolean hasBrackets = false;
public StringPosition annotation = null;
public StringPosition name = null;
public StringPosition description = null;
public TypePosition type = null;
return documentation == null ? null : documentation.markers;
marker.annotation = new JSDocInfo.StringPosition();
marker.annotation.setItem(annotation);
marker.annotation.setPositionInformation(lineno, charno, lineno,
charno + annotation.length());
currentMarker.description = new JSDocInfo.StringPosition();
currentMarker.description.setItem(text);
currentMarker.description.setPositionInformation(startLineno, startCharno,
endLineno, endCharno);
int endCharno, boolean hasLC) {
currentMarker.type = new JSDocInfo.TypePosition();
currentMarker.type.setItem(typeNode);
currentMarker.type.hasBrackets = hasLC;
currentMarker.type.setPositionInformation(lineno, startCharno,
lineno, endCharno);
currentMarker.name = new JSDocInfo.StringPosition();
currentMarker.name.setItem(name);
currentMarker.name.setPositionInformation(lineno, charno,
lineno, charno + name.length());
assertEquals(lineno, marker.annotation.getStartLine());
assertEquals(charno, marker.annotation.getPositionOnStartLine());
assertEquals(8, returnDoc.type.getPositionOnStartLine());
assertEquals(12, returnDoc.type.getPositionOnEndLine());
"name", 18);
"name", 18),
"SomeType", 7, true);
"anothername", 23),
"AnotherType", 9, true);
assertNull(assertAnnotationMarker(jsdoc, "author", 0, 0).name);
"FooBar", 9, true);
"FooBar", 9, false);
assertTrue(marker.description != null);
assertEquals(description, marker.description.getItem());
assertEquals(marker.annotation.getStartLine(),
marker.description.getStartLine());
assertEquals(startCharno, marker.description.getPositionOnStartLine());
assertEquals(endLineno, marker.description.getEndLine());
assertEquals(endCharno, marker.description.getPositionOnEndLine());
private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker,
String typeName, int startCharno,
boolean hasBrackets) {
assertTrue(marker.type != null);
assertTrue(marker.type.getItem().getType() == Token.STRING);
String foundName = marker.type.getItem().getString();
assertEquals(hasBrackets, marker.type.hasBrackets);
assertEquals(startCharno, marker.type.getPositionOnStartLine());
int endCharno = startCharno + foundName.length();
if (hasBrackets) {
endCharno += 1;
assertEquals(endCharno, marker.type.getPositionOnEndLine());
assertEquals(marker.annotation.getStartLine(), marker.type.getStartLine());
assertEquals(marker.annotation.getStartLine(), marker.type.getEndLine());
String name, int startCharno) {
assertTrue(marker.name != null);
assertEquals(name, marker.name.getItem());
assertEquals(startCharno, marker.name.getPositionOnStartLine());
marker.name.getPositionOnEndLine());
assertEquals(marker.annotation.getStartLine(), marker.name.getStartLine());
assertEquals(marker.annotation.getStartLine(), marker.name.getEndLine());
if (marker.annotation != null) {
if (annotationName.equals(marker.annotation.getItem())) {
assertEquals(startLineno, marker.annotation.getStartLine());
marker.annotation.getPositionOnStartLine());
assertEquals(startLineno, marker.annotation.getEndLine());
marker.annotation.getPositionOnEndLine());
if (!poType.hasCachedValues()) {
poType.setImplicitPrototype(newImplicitProto);
return true;
node.getQualifiedName(), getNativeType(UNKNOWN_TYPE), narrowed);
"goog.isDefAndNotNull = function(x) {};";
"goog.asserts = {};" +
"/** @return {*} */ goog.asserts.assert = function(x) { return x; };" +
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
if (type instanceof FunctionPrototypeType) {
addRelatedInstance(
((FunctionPrototypeType) type).getOwnerFunction(), related);
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionPrototypeType protoType = (FunctionPrototypeType) instanceType;
return factory.getConcreteFunction(protoType.getOwnerFunction());
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
FunctionPrototypeType prototype = (FunctionPrototypeType) type;
return ((FunctionPrototypeType) type).getOwnerFunction()
.getInstanceType();
constructor = ((FunctionPrototypeType) objType).getOwnerFunction();
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
if (jsType instanceof FunctionPrototypeType) {
thisType = ((FunctionPrototypeType) jsType)
.getOwnerFunction().getInstanceType();
FunctionType baseConstructor = functionType.
getPrototype().getImplicitPrototype().getConstructor();
package com.google.javascript.rhino.jstype;
import com.google.common.collect.ImmutableSet;
import com.google.javascript.rhino.jstype.ObjectType;
public class FunctionPrototypeType extends PrototypeObjectType {
private static final long serialVersionUID = 1L;
private final FunctionType ownerFunction;
FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,
ObjectType implicitPrototype, boolean isNative) {
super(registry, null /* has no class name */, implicitPrototype,
isNative);
this.ownerFunction = ownerFunction;
FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,
ObjectType implicitPrototype) {
this(registry, ownerFunction, implicitPrototype, false);
public String getReferenceName() {
if (ownerFunction == null) {
return "{...}.prototype";
return ownerFunction.getReferenceName() + ".prototype";
public boolean hasReferenceName() {
return ownerFunction != null && ownerFunction.hasReferenceName();
public boolean isFunctionPrototypeType() {
return true;
public FunctionType getOwnerFunction() {
return ownerFunction;
public Iterable<ObjectType> getCtorImplementedInterfaces() {
return getOwnerFunction().getImplementedInterfaces();
public Iterable<ObjectType> getCtorExtendedInterfaces() {
if (getOwnerFunction() != null) {
return getOwnerFunction().getExtendedInterfaces();
return ImmutableSet.of();
private FunctionPrototypeType prototype;
public FunctionPrototypeType getPrototype() {
setPrototype(new FunctionPrototypeType(registry, this, null));
if (prototype == null) {
setPrototype(
new FunctionPrototypeType(
registry, this, baseType, isNativeObjectType()));
prototype.setImplicitPrototype(baseType);
public boolean setPrototype(FunctionPrototypeType prototype) {
return setPrototype(
new FunctionPrototypeType(
registry, this, objType, isNativeObjectType()));
prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);
return getConstructor().isNative() && "Object".equals(getReferenceName());
return getConstructor().isNative() && "Array".equals(getReferenceName());
return getConstructor().isNative() && "String".equals(getReferenceName());
return getConstructor().isNative() && "Boolean".equals(getReferenceName());
return getConstructor().isNative() && "Number".equals(getReferenceName());
return getConstructor().isNative() && "Date".equals(getReferenceName());
return getConstructor().isNative() && "RegExp".equals(getReferenceName());
ObjectType TOP_LEVEL_PROTOTYPE =
new FunctionPrototypeType(this, null, null, true);
OBJECT_FUNCTION_TYPE.defineDeclaredProperty(
"prototype", TOP_LEVEL_PROTOTYPE, null);
ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();
registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);
if (isNative()) {
boolean isNative() {
return nativeType;
return className != null;
public boolean isFunctionPrototypeType() {
return referencedType.isFunctionPrototypeType();
for (int i = 0; i < 4; ++i) {
String desired = "{a=[[Foo.prototype]]}";
String expected = "{}";
String desired = "{a=[[Foo.prototype]]}";
String expected = "{}";
testSets(false, js, js, "{}");
testSets(false, js, js, "{}");
assertFalse(x.getImplicitPrototype().hasOwnProperty("bar"));
assertFalse(x.getImplicitPrototype().hasOwnProperty("alert"));
assertEquals("function (this:Window, ?): undefined",
assertTrue(x.isPropertyTypeDeclared("alert"));
assertEquals("function (this:Window, ?): undefined",
assertFalse(proto1.hasOwnProperty("m1"));
assertFalse(proto1.hasOwnProperty("m2"));
assertTrue(proto2.hasOwnProperty("m1"));
assertTrue(proto2.hasOwnProperty("m2"));
assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());
public void testFunctionCyclycity() throws Exception {
FunctionPrototypeType instanceType =
new FunctionPrototypeType(
registry, U2U_CONSTRUCTOR_TYPE,
U2U_CONSTRUCTOR_TYPE.getInstanceType());
U2U_CONSTRUCTOR_TYPE.setPrototype(instanceType);
U2U_CONSTRUCTOR_TYPE.detectImplicitPrototypeCycle();
instanceType.detectImplicitPrototypeCycle();
public void testInvalidSetPrototypeBasedOn() {
try {
fun.setPrototypeBasedOn(unresolvedNamedType);
fail();
e.printStackTrace();
return ((FunctionType) lValueType).getInstanceType();
return ((FunctionType) type).getInstanceType();
JSType scopeType = scope.getJSType();
if (!(scopeType instanceof FunctionType)) {
JSType returnType = ((FunctionType) scopeType).getReturnType();
FunctionType funcType = (FunctionType) func.getJSType();
return (FunctionType) declaration.getJSType();
FunctionType type = (FunctionType) functionNode.getJSType();
import com.google.javascript.rhino.jstype.EnumElementType;
addInvalidatingType(((EnumElementType) type).getPrimitiveType());
((EnumElementType) type).getPrimitiveType());
if (type instanceof EnumElementType) {
field, ((EnumElementType) type).getPrimitiveType());
if (objType instanceof FunctionType) {
constructor = (FunctionType) objType;
cType, ((EnumElementType) jsType).getPrimitiveType(), prop);
FunctionType functionType = (FunctionType) function.getJSType();
FunctionType ownerFnType = ownerType instanceof FunctionType ?
(FunctionType) ownerType : null;
import com.google.javascript.rhino.jstype.FunctionType;
((FunctionType) objType).getInstanceType().setJSDocInfo(
if (type.isFunctionType() && type.isConstructor()) {
name, (FunctionType) type, n, parent, parent.getParent(), rValue);
if (constructor instanceof FunctionType && constructor.isConstructor()) {
classType = (FunctionType) constructor;
FunctionType fntype = ((FunctionType) valueType);
FunctionType fntype = ((FunctionType) valueType);
if (jstype != null && jstype.isFunctionType()) {
FunctionType functionType = (FunctionType) jstype;
FunctionType funType = (FunctionType) n.getJSType();
if (!funType.isConstructor()) {
FunctionType funType = (FunctionType) n.getJSType();
FunctionType funType = (FunctionType) function.getJSType();
import com.google.javascript.rhino.jstype.FunctionType;
if (nodeType != null && nodeType instanceof FunctionType) {
thisType = ((FunctionType) nodeType).getTypeOfThis();
if (rightType instanceof FunctionType) {
targetType = (FunctionType) rightType;
if (target instanceof FunctionType) {
FunctionType funcTarget = (FunctionType) target;
if (funcTarget.hasInstanceType()) {
return funcTarget.getInstanceType();
FunctionType funcTarget = (FunctionType) target;
FunctionType funcTarget = (FunctionType) target;
FunctionType funcTarget = (FunctionType) target;
if (lhs.getJSType() == null
|| !(lhs.getJSType() instanceof FunctionType)) {
ConcreteType retType = createType(((FunctionType)
lhs.getJSType().restrictByNotNullOrUndefined())
.getReturnType());
((FunctionType) recvType).getParameters() != null) {
((FunctionType) recvType).getParameters().iterator();
if (arg.getJSType() instanceof FunctionType) {
((FunctionType) arg.getJSType()).getTypeOfThis(),
arg, thisType, (FunctionType) paramType));
FunctionType callType = null;
if (propType instanceof FunctionType) {
callType = (FunctionType) propType;
if (getConcreteFunction((FunctionType) jsType) != null) {
return getConcreteFunction((FunctionType) jsType);
functionFromJSType.put((FunctionType) decl.getJSType(), funType);
import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;
final TypeCheck outerThis = this;
final FunctionType functionType = (FunctionType) n.getJSType();
if (objectJsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) objectJsType;
JSType jsType = object2.getJSType();
if (jsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) jsType;
FunctionType type = getFunctionType(constructor);
if (type != null && type.isConstructor()) {
visitParameterList(t, n, type);
ensureTyped(t, n, type.getInstanceType());
FunctionType functionType = (FunctionType) n.getJSType();
if (childType instanceof FunctionType) {
FunctionType functionType = (FunctionType) childType;
if (jsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) jsType;
private FunctionType getFunctionType(Node n) {
JSType type = getJSType(n).restrictByNotNullOrUndefined();
if (type.isUnknownType()) {
return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);
return (FunctionType) type;
return null;
type instanceof FunctionType ||
if (functionType instanceof FunctionType) {
FunctionType fnType = (FunctionType) functionType;
JSType iParameterType = iParameter.getJSType();
if (iParameterType instanceof FunctionType) {
FunctionType iParameterFnType = (FunctionType) iParameterType;
iArgumentType instanceof FunctionType &&
if (jParameterType instanceof FunctionType) {
FunctionType jParameterFnType = (FunctionType) jParameterType;
jArgumentType instanceof FunctionType) {
FunctionType jArgumentFnType = (FunctionType) jArgumentType;
FunctionType ct = (FunctionType) constructorType;
if (ct.isConstructor()) {
if (found instanceof FunctionType &&
required instanceof FunctionType) {
FunctionType fnTypeA = ((FunctionType) found);
FunctionType fnTypeB = ((FunctionType) required);
if (type instanceof FunctionType) {
FunctionType funType = (FunctionType) fnNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
if (var != null && var.getType() instanceof FunctionType) {
FunctionType aliasedType  = (FunctionType) var.getType();
functionType = (FunctionType) type;
if (propType instanceof FunctionType) {
return (FunctionType) propType;
if (propType instanceof FunctionType) {
return (FunctionType) propType;
if (type instanceof FunctionType &&
FunctionType fnType = (FunctionType) type;
&& type instanceof FunctionType
.setPrototypeBasedOn(((FunctionType) type).getInstanceType());
(FunctionType) rValue.getJSType(), info, lValue)) {
return o instanceof FunctionType ? ((FunctionType) o) : null;
ObjectType ownerType = getObjectSlot(ownerName);
if (ownerType instanceof FunctionType) {
JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();
defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),
true);
FunctionType functionType = (FunctionType) functionNode.getJSType();
public boolean isEnumElementType() {
return true;
public boolean isFunctionType() {
return true;
FunctionType other = null;
if (that instanceof FunctionType) {
other = (FunctionType) that;
if (!(otherType instanceof FunctionType)) {
return false;
FunctionType that = (FunctionType) otherType;
if (!that.isFunctionType()) {
if (((FunctionType) that).isInterface()) {
FunctionType other = (FunctionType) that;
subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
public boolean isFunctionType() {
return false;
public boolean isEnumElementType() {
return false;
if (thisType instanceof EnumElementType) {
JSType inf = ((EnumElementType) thisType).meet(thatType);
JSType inf = ((EnumElementType) thatType).meet(thisType);
if ((value instanceof FunctionType) &&
(value.isConstructor() || value.isInterface())) {
FunctionType functionType = (FunctionType) value;
public boolean isFunctionType() {
return false;
public boolean isEnumElementType() {
return referencedType.isEnumElementType();
name.fullName(),
parent.fullName(),
name.fullName()));
UNDEFINED_NAME_WARNING, name.fullName()));
flattenReferencesToCollapsibleDescendantNames(n, n.getName());
collapseDeclarationOfNameAndDescendants(n, n.getName());
UNSAFE_NAMESPACE_WARNING, nameObj.fullName()));
NAMESPACE_REDEFINED_WARNING, nameObj.fullName()));
String propAlias = appendPropForAlias(alias, p.getName());
name.fullName());
String originalName = n.fullName();
String originalName = n.fullName();
p, appendPropForAlias(alias, p.getName()));
appendPropForAlias(alias, p.getName()), p, p.getDeclaration());
refName.fullName());
alias, ref.node.getAncestor(2), n.fullName());
UNSAFE_THIS, name.fullName()));
String qName = objlitName.fullName() + '.' + propName;
String propAlias = appendPropForAlias(alias, p.getName());
private final String name;
this.name = name;
return name;
return fullName() + " (" + type + "): globalSets=" + globalSets +
String fullName() {
return parent == null ? name : parent.fullName() + '.' + name;
String fullName = name.fullName();
LocationMapping(String prefix, String replacement) {
if (that != null) {
if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
return true;
return this.isImplicitPrototype(thatObj);
return false;
void setNext(PropListItem next);
private PropListItem next;
public void setNext(PropListItem next) {
this.next = next;
item.setNext(result);
return item;
public abstract class ObjectType extends JSType {
if (properties.get(propertyName) != null) {
return true;
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
if (implicitPrototype.hasProperty(propertyName)) {
return true;
for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
if (interfaceType.hasProperty(propertyName)) {
return true;
return false;
Property p = properties.get(property);
if (p == null) {
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.isPropertyTypeDeclared(property);
return !p.inferred;
Property p = properties.get(property);
if (p == null) {
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.isPropertyTypeInferred(property);
return p.inferred;
public JSType getPropertyType(String propertyName) {
Property p = properties.get(propertyName);
if (p != null) {
return p.type;
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
return implicitPrototype.getPropertyType(propertyName);
return getNativeType(JSTypeNative.UNKNOWN_TYPE);
Property newProp = new Property(type, inferred, inExterns, propertyNode);
private static final class Property implements Serializable {
private Property(JSType type, boolean inferred, boolean inExterns,
Node propertyNode) {
subIface.setExtendedInterfaces(Lists.<ObjectType>newArrayList(iface));
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import com.google.common.collect.Multimap;
import com.google.common.collect.HashMultimap;
if (objectType != null) {
JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);
if (info != null && info.isConstant()
&& objectType.hasReferenceName()) {
initializedConstantProperties.put(objectType.getReferenceName(),
propertyName);
JSDocInfo prototypeInfo
= prototype.getOwnPropertyJSDocInfo(propertyName);
if (prototypeInfo != null && prototypeInfo.isConstant()
token = eatTokensUntilEOL();
do {
return options.getLanguageIn() == LanguageMode.ECMASCRIPT5;
import com.google.javascript.jscomp.Scope.Var;
import java.util.Iterator;
for (Iterator<Var> i = scope.getVars(); i.hasNext();) {
usedNames.add(i.next().getName());
String getNameNewName() {
return names.generateNextName();
if (n.canCollapse() && canCollapseChildNames) {
updateObjLitOrFunctionDeclaration(n, alias);
private void updateObjLitOrFunctionDeclaration(Name n, String alias) {
updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);
updateObjLitOrFunctionDeclarationAtVarNode(n);
updateFunctionDeclarationAtFunctionNode(n);
Name n, String alias) {
if (isObjLit) {
declareVarsForObjLitValues(
n, alias, rvalue,
varNode, varParent.getChildBefore(varNode), varParent);
addStubsForUndeclaredProperties(n, alias, varParent, varNode);
if (!varNode.hasChildren()) {
varParent.removeChild(varNode);
compiler.reportCodeChange();
private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {
private void updateFunctionDeclarationAtFunctionNode(Name n) {
private final List<WarningsGuard> guards;
private static final Comparator<WarningsGuard> guardComparator =
return a.getPriority() - b.getPriority();
this.guards = Lists.newArrayList();
addGuards(Lists.reverse(((ComposeWarningsGuard) guard).guards));
int index = Collections.binarySearch(this.guards, guard, guardComparator);
if (index < 0) {
index = -index - 1;
this.guards.add(index, guard);
return Collections.unmodifiableList(guards);
static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(
"JSC_DIVIDE_BY_0_ERROR",
"Divide by 0");
error(DIVIDE_BY_0_ERROR, right);
error(DIVIDE_BY_0_ERROR, right);
fold("x = 1 / 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
fold("x = 1 % 0", "", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);
JSType valueType = getDeclaredPropType(
t, info, keyNode, value);
private JSType getDeclaredTypeInAnnotation(
NodeTraversal t, Node node, JSDocInfo info) {
return getDeclaredTypeInAnnotation(t.getSourceName(), node, info);
JSType type = null;
if (value != null && value.getType() == Token.FUNCTION &&
shouldUseFunctionLiteralType(
(FunctionType) value.getJSType(), info, name)) {
type = value.getJSType();
if (info == null) {
CompilerInput input = compiler.getInput(sourceName);
Preconditions.checkNotNull(input, sourceName);
type = input.isExtern() ?
getNativeType(UNKNOWN_TYPE) : null;
if (value != null && value.getType() == Token.OBJECTLIT) {
type = value.getJSType();
type = createEnumTypeFromNodes(
value, name.getString(), info, name);
type = createFunctionTypeFromNodes(
value, name.getString(), info, name);
type = getDeclaredTypeInAnnotation(sourceName, name, info);
private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info,
return getDeclaredTypeInAnnotation(t, lValue, info);
return getDeclaredTypeInAnnotation(t, lValue, info);
JSType valueType = getDeclaredPropType(t, info, n, rhsValue);
JSType jsType = getDeclaredPropType(t, info, member, value);
"/** @type {Function} */ var abstractFn = function() {};" +
itself is nullable. */
createNullableType(U2U_CONSTRUCTOR_TYPE).
restrictByNotNullOrUndefined().toString());
"/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
"/**\n * @param {number} x \n * @constructor */ goog.FooAlias = goog.Foo;" +
"/**\n * @param {number} x \n * @constructor */ goog.Foo = function(x) {};" +
"/**\n * @param {number} x \n * @constructor */ var Foo = function(x) {};" +
"/** @type {Function} */ var abstractFn = function() {};" +
itself is nullable. */
createNullableType(U2U_CONSTRUCTOR_TYPE).
restrictByNotNullOrUndefined().toString());
boolean local = (var != null) && var.isLocal();
"var d = function a(b, c) {" +
"var walk = function a(b, c) {" +
"  a(b, c);" +
String param = params.getParameter(0);
this.compilationLevel.setOptionsForCompilationLevel(options);
JSType aType = slotA.getType();
JSType bType = slotB.getType();
if (aType.isNoType() || bType.isNoType()) {
return false;
return aType.differsFrom(bType);
public void testDiffer() {
assertScopesSame(childABC, childBC);
if (this.isSubtype(that)) {
private ObjectType implicitPrototype;
if (nativeType) {
this.implicitPrototype = implicitPrototype;
this.implicitPrototype =
registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
this.implicitPrototype = implicitPrototype;
return implicitPrototype;
void setImplicitPrototype(ObjectType implicitPrototype) {
this.implicitPrototype = implicitPrototype;
if (implicitPrototype != null && !implicitPrototype.isNativeObjectType()) {
implicitPrototype = (ObjectType) implicitPrototype.resolve(t, scope);
int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.');
addGuards(((ComposeWarningsGuard) guard).guards);
protected void initOptionsFromFlags(CompilerOptions options) {
final protected A getCompiler() {
return compiler;
final protected void setRunOptions(B options)
throws IOException, FlagUsageException {
options.setCodingConvention(config.codingConvention);
options.setSummaryDetailLevel(config.summaryDetailLevel);
inputCharset = getInputCharset();
if (inputCharset == Charsets.UTF_8) {
options.outputCharset = Charsets.US_ASCII;
options.outputCharset = inputCharset;
public interface CodingConvention {
usage = "Input charset for all files.")
initOptionsFromFlags(options);
builder.setOutputCharset(options.outputCharset);
public Charset outputCharset;
if (n == null || NodeUtil.isLiteralValue(n) ||
return NodeUtil.isLiteralValue(value)
throw new IllegalStateException("Unexpected initialiation parent");
static boolean isLiteralValue(Node n) {
if (!isLiteralValue(child)) {
return !isFunctionExpression(n);
return !(isLiteralValue(current) ||
current.getType() == Token.FUNCTION);
parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur)));
if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
if (NodeUtil.isLiteralValue(left)
if (NodeUtil.isLiteralValue(right) &&
if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {
if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
boolean rightLiteral = NodeUtil.isLiteralValue(right);
&& NodeUtil.isLiteralValue(right.getFirstChild())));
if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
if (!NodeUtil.isLiteralValue(argumentNode) &&
if (!NodeUtil.isLiteralValue(cond)) {
if (NodeUtil.isLiteralValue(cond)) {
!NodeUtil.isLiteralValue(value);
assign.assignNode.getLastChild())) {
assertTrue(NodeUtil.isLiteralValue(n));
assertTrue(NodeUtil.isLiteralValue(n));
assertFalse(NodeUtil.isLiteralValue(n));
assertMutableState(false, "(function() { })");
assertMutableState(false, "(function() { i++ })");
assertMutableState(false, "(function(a, b) {  })");
private Map<String, Node> aliases = Maps.newHashMap();
aliases.put(n.getString(), n.getFirstChild());
t.getScope().undeclare(t.getScope().getVar(n.getString()));
if (type == Token.NAME && NodeUtil.isAssignmentOp(parent)) {
Node aliasedNode = aliases.get(n.getString());
if (t.getScope().getVar(n.getString()) == null &&
aliasedNode != null) {
Node aliasedNode = aliases.get(baseName);
if (aliasedNode != null) {
import com.google.common.collect.Maps;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map;
out.append(escapeString(sourceFile));
out.append(originalPosition.getLineNumber() + "");
out.append(originalPosition.getCharacterIndex() + "");
out.append(escapeString(originalName));
private static class LineMapping {
int lineNumber;
int length;
List<LineCharMapping> characterMappings = Lists.newArrayList();
Map<Integer, LineCharMapping> charToMap = Maps.newHashMap();
void appendCharMapTo(Appendable out) throws IOException {
out.append("[");
for (int j = 0; j <= length; ++j) {
if (j > 0) {
out.append(",");
LineCharMapping current = charToMap.get(j);
if (current == null) {
out.append("-1");
out.append(String.valueOf(current.basisMapping.id));
out.append("]");
private static class LineCharMapping {
int startCharacter;
int endCharacter;
Mapping basisMapping;
Object sourceFile = node.getProp(Node.SOURCEFILE_PROP);
mapping.sourceFile = sourceFile.toString();
Object originalName = node.getProp(Node.ORIGINALNAME_PROP);
mapping.originalName = originalName.toString();
private static class LineMappingInformation {
Map<Integer, LineMapping> mappings;
int maxLine;
public LineMappingInformation(Map<Integer, LineMapping> mappings,
int maxLine) {
this.maxLine = maxLine;
this.mappings = mappings;
private LineMappingInformation determineLineMappings() {
Map<Integer, LineMapping> lineMappings = Maps.newHashMap();
int prefixLine = prefixPosition.getLineNumber();
int startPositionLine =
prefixLine + mapping.startPosition.getLineNumber();
int endPositionLine = prefixLine + mapping.endPosition.getLineNumber();
for (int i = startPositionLine; i <= endPositionLine; ++i) {
LineMapping lineMapping = lineMappings.get(i);
if (lineMapping == null) {
lineMapping = new LineMapping();
lineMapping.lineNumber = i;
lineMappings.put(i, lineMapping);
int startCharacter = mapping.startPosition.getCharacterIndex();
if (mapping.startPosition.getLineNumber() == 0) {
startCharacter += prefixPosition.getCharacterIndex();
int endCharacter = mapping.endPosition.getCharacterIndex();
if (mapping.endPosition.getLineNumber() == 0) {
endCharacter += prefixPosition.getCharacterIndex();
lineMapping.length = Math.max(lineMapping.length, endCharacter);
if (i > startPositionLine) {
startCharacter = 0;
if (i < endPositionLine) {
endCharacter = Integer.MAX_VALUE;
LineCharMapping lcm = new LineCharMapping();
lcm.startCharacter = startCharacter;
lcm.endCharacter = endCharacter;
lcm.basisMapping = mapping;
lineMapping.characterMappings.add(lcm);
return new LineMappingInformation(lineMappings, maxLine);
private void buildCharacterMappings(Collection<LineMapping> lineMappings) {
for (LineMapping lineMapping : lineMappings) {
for (int i = 0; i <= lineMapping.length; ++i) {
int minLength = Integer.MAX_VALUE;
LineCharMapping current = null;
Collections.sort(lineMapping.characterMappings,
new Comparator<LineCharMapping>() {
public int compare(LineCharMapping first, LineCharMapping second) {
Mapping firstBasis = first.basisMapping;
Mapping secondBasis = second.basisMapping;
String firstName = firstBasis.originalName;
String secondName = secondBasis.originalName;
firstName = firstName == null ? "" : firstName;
secondName = secondName == null ? "" : secondName;
return firstName.compareTo(secondName);
for (LineCharMapping lcm : lineMapping.characterMappings) {
if (i < lcm.startCharacter || i > lcm.endCharacter) {
continue;
int lcmLength = lcm.endCharacter - lcm.startCharacter;
if (lcmLength == minLength && lcm.basisMapping.originalName != null) {
current = lcm;
continue;
if (lcmLength < minLength) {
minLength = lcmLength;
current = lcm;
lineMapping.charToMap.put(i, current);
Mapping getMappingFor(Position position) {
LineMappingInformation info = determineLineMappings();
Map<Integer, LineMapping> lineMappings = info.mappings;
buildCharacterMappings(lineMappings.values());
LineMapping lineMapping = lineMappings.get(position.getLineNumber());
if (lineMapping == null) {
return null;
LineCharMapping lcm =
lineMapping.charToMap.get(position.getCharacterIndex());
if (lcm == null) {
return null;
return lcm.basisMapping;
LineMappingInformation info = determineLineMappings();
Map<Integer, LineMapping> lineMappings = info.mappings;
int maxLine = info.maxLine;
buildCharacterMappings(lineMappings.values());
out.append((maxLine + 1) + "");
for (int i = 0; i <= maxLine; ++i) {
LineMapping lineMapping = lineMappings.get(i);
if (lineMapping == null) {
out.append("[]");
lineMapping.appendCharMapTo(out);
out.append("\n");
for (int i = 0; i < mappings.size(); ++i) {
Mapping mapping = mappings.get(i);
switch (assertedNode.getType()) {
case Token.NAME:
JSType type = getJSType(assertedNode);
JSType narrowed = type.restrictByNotNullOrUndefined();
if (type != narrowed) {
scope = scope.createChildFlowScope();
redeclare(scope, assertedNode.getString(), narrowed);
break;
case Token.AND:
case Token.OR:
BooleanOutcomePair conditionOutcomes =
traverseWithinShortCircuitingBinOp(assertedNode, scope);
scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(
assertedNode, conditionOutcomes.getOutcomeFlowScope(
assertedNode.getType(), true), true);
break;
redeclare(scope, assertedNode.getString(), narrowed);
"[0]\n" +
"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9," +
"10,10,10,10,11,11,12,12,12,12,12,12,13,13,13,13,13,6]\n" +
"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9," +
"9,10,10,10,10,11,11,11,11,12,12,12,12,12,12,13,13,13," +
"13,13,6]\n" +
"[2,2,2,2]\n" +
Map<String, Token> tokens = Maps.newHashMap();
Map<String, Token> originalTokens = findTokens(js);
Map<String, Token> resultTokens = findTokens(result.generatedSource);
SourceMap.Mapping mapping =
result.sourceMap.getMappingFor(token.position);
assertEquals(mapping.originalPosition.getLineNumber(),
assertNotNull(mapping.originalName);
if (mapping.originalName != null) {
private FunctionInformationMap() {
initFields();
private Entry() {
initFields();
private int id_ = 0;
private java.lang.String sourceName_ = "";
private int lineNumber_ = 0;
private java.lang.String moduleName_ = "";
private int size_ = 0;
private java.lang.String name_ = "";
private java.lang.String compiledSource_ = "";
private com.google.javascript.jscomp.FunctionInformationMap.Entry result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap.Entry internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
com.google.javascript.jscomp.FunctionInformationMap.Entry returnMe = result;
result = null;
return returnMe;
return result.hasId();
return result.getId();
result.hasId = true;
result.id_ = value;
result.hasId = false;
result.id_ = 0;
return result.hasSourceName();
return result.getSourceName();
result.hasSourceName = true;
result.sourceName_ = value;
result.hasSourceName = false;
result.sourceName_ = getDefaultInstance().getSourceName();
return result.hasLineNumber();
return result.getLineNumber();
result.hasLineNumber = true;
result.lineNumber_ = value;
result.hasLineNumber = false;
result.lineNumber_ = 0;
return result.hasModuleName();
return result.getModuleName();
result.hasModuleName = true;
result.moduleName_ = value;
result.hasModuleName = false;
result.moduleName_ = getDefaultInstance().getModuleName();
return result.hasSize();
return result.getSize();
result.hasSize = true;
result.size_ = value;
result.hasSize = false;
result.size_ = 0;
return result.hasName();
return result.getName();
result.hasName = true;
result.name_ = value;
result.hasName = false;
result.name_ = getDefaultInstance().getName();
return result.hasCompiledSource();
return result.getCompiledSource();
result.hasCompiledSource = true;
result.compiledSource_ = value;
result.hasCompiledSource = false;
result.compiledSource_ = getDefaultInstance().getCompiledSource();
private Module() {
initFields();
private java.lang.String name_ = "";
private java.lang.String compiledSource_ = "";
private com.google.javascript.jscomp.FunctionInformationMap.Module result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap.Module internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap.Module();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
com.google.javascript.jscomp.FunctionInformationMap.Module returnMe = result;
result = null;
return returnMe;
return result.hasName();
return result.getName();
result.hasName = true;
result.name_ = value;
result.hasName = false;
result.name_ = getDefaultInstance().getName();
return result.hasCompiledSource();
return result.getCompiledSource();
result.hasCompiledSource = true;
result.compiledSource_ = value;
result.hasCompiledSource = false;
result.compiledSource_ = getDefaultInstance().getCompiledSource();
private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =
java.util.Collections.emptyList();
private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =
java.util.Collections.emptyList();
private com.google.javascript.jscomp.FunctionInformationMap result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.FunctionInformationMap();
return builder;
protected com.google.javascript.jscomp.FunctionInformationMap internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.FunctionInformationMap();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
if (result.entry_ != java.util.Collections.EMPTY_LIST) {
result.entry_ =
java.util.Collections.unmodifiableList(result.entry_);
if (result.module_ != java.util.Collections.EMPTY_LIST) {
result.module_ =
java.util.Collections.unmodifiableList(result.module_);
com.google.javascript.jscomp.FunctionInformationMap returnMe = result;
result = null;
return returnMe;
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.addAll(other.entry_);
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.addAll(other.module_);
return java.util.Collections.unmodifiableList(result.entry_);
return result.getEntryCount();
return result.getEntry(index);
result.entry_.set(index, value);
result.entry_.set(index, builderForValue.build());
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.add(value);
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
result.entry_.add(builderForValue.build());
if (result.entry_.isEmpty()) {
result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();
super.addAll(values, result.entry_);
result.entry_ = java.util.Collections.emptyList();
return java.util.Collections.unmodifiableList(result.module_);
return result.getModuleCount();
return result.getModule(index);
result.module_.set(index, value);
result.module_.set(index, builderForValue.build());
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.add(value);
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
result.module_.add(builderForValue.build());
if (result.module_.isEmpty()) {
result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();
super.addAll(values, result.module_);
result.module_ = java.util.Collections.emptyList();
private Instrumentation() {
initFields();
private java.lang.String reportDefined_ = "";
private java.lang.String reportCall_ = "";
private java.lang.String reportExit_ = "";
private java.util.List<java.lang.String> declarationToRemove_ =
java.util.Collections.emptyList();
private java.util.List<java.lang.String> init_ =
java.util.Collections.emptyList();
private java.lang.String appNameSetter_ = "";
private com.google.javascript.jscomp.Instrumentation result;
private Builder() {}
Builder builder = new Builder();
builder.result = new com.google.javascript.jscomp.Instrumentation();
return builder;
protected com.google.javascript.jscomp.Instrumentation internalGetResult() {
return result;
if (result == null) {
throw new IllegalStateException(
"Cannot call clear() after build().");
result = new com.google.javascript.jscomp.Instrumentation();
return create().mergeFrom(result);
public boolean isInitialized() {
return result.isInitialized();
if (result != null && !isInitialized()) {
return buildPartial();
if (!isInitialized()) {
return buildPartial();
if (result == null) {
throw new IllegalStateException(
"build() has already been called on this Builder.");
if (result.declarationToRemove_ != java.util.Collections.EMPTY_LIST) {
result.declarationToRemove_ =
java.util.Collections.unmodifiableList(result.declarationToRemove_);
if (result.init_ != java.util.Collections.EMPTY_LIST) {
result.init_ =
java.util.Collections.unmodifiableList(result.init_);
com.google.javascript.jscomp.Instrumentation returnMe = result;
result = null;
return returnMe;
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
result.declarationToRemove_.addAll(other.declarationToRemove_);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
result.init_.addAll(other.init_);
return result.hasReportDefined();
return result.getReportDefined();
result.hasReportDefined = true;
result.reportDefined_ = value;
result.hasReportDefined = false;
result.reportDefined_ = getDefaultInstance().getReportDefined();
return result.hasReportCall();
return result.getReportCall();
result.hasReportCall = true;
result.reportCall_ = value;
result.hasReportCall = false;
result.reportCall_ = getDefaultInstance().getReportCall();
return result.hasReportExit();
return result.getReportExit();
result.hasReportExit = true;
result.reportExit_ = value;
result.hasReportExit = false;
result.reportExit_ = getDefaultInstance().getReportExit();
return java.util.Collections.unmodifiableList(result.declarationToRemove_);
return result.getDeclarationToRemoveCount();
return result.getDeclarationToRemove(index);
result.declarationToRemove_.set(index, value);
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
result.declarationToRemove_.add(value);
if (result.declarationToRemove_.isEmpty()) {
result.declarationToRemove_ = new java.util.ArrayList<java.lang.String>();
super.addAll(values, result.declarationToRemove_);
result.declarationToRemove_ = java.util.Collections.emptyList();
return java.util.Collections.unmodifiableList(result.init_);
return result.getInitCount();
return result.getInit(index);
result.init_.set(index, value);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
result.init_.add(value);
if (result.init_.isEmpty()) {
result.init_ = new java.util.ArrayList<java.lang.String>();
super.addAll(values, result.init_);
result.init_ = java.util.Collections.emptyList();
return result.hasAppNameSetter();
return result.getAppNameSetter();
result.hasAppNameSetter = true;
result.appNameSetter_ = value;
result.hasAppNameSetter = false;
result.appNameSetter_ = getDefaultInstance().getAppNameSetter();
static final String ALIAS_NULL = "$$ALIAS_NULL";
static final String ALIAS_TRUE = "$$ALIAS_TRUE";
static final String ALIAS_FALSE = "$$ALIAS_FALSE";
static final String ALIAS_THROW = "$$ALIAS_THROW";
String code = toSource(root);
"function JSCompiler_stubMethod(id) {" +
"    return JSCompiler_stubMap[id].apply(this, arguments);" +
"function JSCompiler_unstubMethod(id, body) {" +
"  return JSCompiler_stubMap[id] = body;" +
checkForFunctionsWithUnknownTypes(exportedFunction);
JSDocInfo functionJSDocInfo = function.getJSType().getJSDocInfo();
FunctionType functionType = (FunctionType) function.getJSType();
if (!Character.isUpperCase(name.charAt(0))) {
|| compiler.getCodingConvention().isConstant(n.getString())) {
private final boolean assertOnChange;
PrepareAst(AbstractCompiler compiler, boolean forbidChanges) {
this.assertOnChange = forbidChanges;
if (assertOnChange) {
if (assertOnChange) {
if (externs != null) {
NodeTraversal.traverse(
compiler, externs, new PrepareAnnotations(compiler));
if (root != null) {
NodeTraversal.traverse(
compiler, root, new PrepareAnnotations(compiler));
case Token.STRING:
if (convention.isConstant(nString)) {
Strings.truncateAtMaxLength(source, 100, true),
Strings.truncateAtMaxLength(source2, 100, true)));
if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {
if (NodeUtil.isAssignmentOp(parent)) {
report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
if (n.getType() == Token.RETURN) {
report(t, n, GOOG_SCOPE_USES_RETURN);
if (n.getType() == Token.THIS) {
report(t, n, GOOG_SCOPE_REFERENCES_THIS);
t.getCompiler().report(
t.makeError(call, WRONG_ARGUMENT_COUNT,
" and no more than " + maxArgs + " argument(s)" : ""));
import com.google.common.collect.ImmutableSet;
return this.isSubtype(that) && that.isSubtype(this);
ImmutableSet.Builder<JSType> resolvedTypes = ImmutableSet.builder();
Preconditions.checkState(newAlternates.hashCode() == this.hashcode);
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.javascript.rhino.jstype.UnionType;
import java.util.Set;
if (!alternate.isUnknownType()) {
Iterator<JSType> it = alternates.iterator();
while (it.hasNext()) {
JSType current = it.next();
if (!current.isUnknownType()) {
if (alternate.isSubtype(current)) {
return this;
it.remove();
Set<JSType> alternateSet = ImmutableSet.copyOf(alternates);
int size = alternateSet.size();
result = new UnionType(registry, alternateSet);
"var $$ALIAS_TRUE=true;"));
"var $$ALIAS_FALSE=false;"));
"var $$ALIAS_NULL=null;"));
"var $$ALIAS_TRUE=true;var $$ALIAS_NULL=null;var $$ALIAS_FALSE=false;");
repitions, "var $$ALIAS_TRUE=true;", AliasKeywords.ALIAS_TRUE);
testSame("var $$ALIAS_TRUE='foo';");
super.enableLineNumberCheck(true);
"var a$b = 0; var a$b = 1; var c = a$b;");
test("function CreateClass(a) {}" +
"function CreateClass(a) {}" +
"function CreateClass(a) {}" +
"function CreateClass(a) {}" +
options.checkTypes = true;
if (condition != null && NodeUtil.isLiteralValue(condition) ) {
return NodeUtil.getBooleanValue(condition) ==
(Branch.ON_TRUE == branch);
if (condition != null && NodeUtil.isImmutableValue(condition)) {
return NodeUtil.getBooleanValue(condition) ==
(branch == Branch.ON_TRUE);
addExpr(first.getNext(), p);
addExpr(last, p);
boolean liftedExterns = false;
if (n.getJSDocInfo() != null && n.getJSDocInfo().isExterns()) {
externsRoot.addChildToBack(n);
input.setIsExtern(true);
input.getModule().remove(input);
externs.add(input);
liftedExterns = true;
if (liftedExterns) {
import com.google.common.collect.ImmutableSet;
private static final PassFactory peepholeOptimizations =
ImmutableSet<AbstractPeepholeOptimization> optimizations =
ImmutableSet.<AbstractPeepholeOptimization>of(
new PeepholeSubstituteAlternateSyntax());
final PeepholeOptimizationsPass peepholePass =
new PeepholeOptimizationsPass(compiler, optimizations);
return peepholePass;
private String tempNamePrefix = "JSCompiler_temp_";
return tempNamePrefix + safeNameIdSupplier.get();
String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get();
this.knownConstants.add(sName);
return sName;
class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback
private final StringBuilder sb;
private final List<String> paths;
abstract void generateExterns();
protected void appendInferredPaths(String path) {
for (int i = 0; i < pieces.size(); ++i) {
String cPath = Joiner.on(".").join(Iterables.limit(pieces, i + 1));
if (i == pieces.size() - 1 || !paths.contains(cPath)) {
if (i == 0) {
sb.append("var ");
sb.append(cPath);
if (i < pieces.size() - 1) {
sb.append(";\n");
paths.add(cPath);
protected Node getFunctionValue(Node value) {
Node definition = definitionParent.getLastChild();
protected void appendFunctionValue(Node definition) {
sb.append(" = ");
sb.append("function(");
Node parameters = definition.getFirstChild().getNext();
int i = 0;
for (Node current = parameters.getFirstChild();
current != null;
current = current.getNext()) {
if (i > 0) {
sb.append(", ");
sb.append(current.getString());
++i;
sb.append(") {}");
private final String symbolName;
private final Node value;
this.symbolName = symbolName;
this.value = value;
void generateExterns() {
appendInferredPaths(symbolName);
Node functionValue = getFunctionValue(value);
if (functionValue != null) {
appendFunctionValue(functionValue);
sb.append(";\n");
private final String symbolName;
private final Node value;
this.symbolName = symbolName;
this.value = value;
void generateExterns() {
String exportedPath = getExportedPath();
appendInferredPaths(exportedPath);
Node functionValue = getFunctionValue(value);
if (functionValue != null) {
appendFunctionValue(functionValue);
sb.append(";\n");
this.sb = new StringBuilder();
this.paths = Lists.newArrayList();
return sb.toString();
if (parent.getType() == Token.ASSIGN) {
import com.google.common.base.Predicates;
if (type == Token.BLOCK) {
tryFoldBlock(t, n, parent);
return;
if (!NodeUtil.isLiteralValue(left)) {
int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :
Token.TRUE;
if (type == Token.IF || type == Token.HOOK) {
tryFoldHookIf(t, n, parent);
return;
if (type == Token.DO) {
tryFoldDo(t, n, parent);
return;
if (type == Token.WHILE) {
tryFoldWhile(t, n, parent);
return;
if (type == Token.FOR) {
Node condition = NodeUtil.getConditionExpression(n);
if (condition != null) {
this.tryFoldForCondition(condition, n);
tryFoldFor(t, n, parent);
return;
if (type == Token.COMMA) {
tryFoldComma(t, n, left, right, parent);
return;
private void tryFoldComma(
NodeTraversal t, Node n, Node left, Node right, Node parent) {
if (!NodeUtil.mayHaveSideEffects(left)) {
n.removeChild(right);
parent.replaceChild(n, right);
t.getCompiler().reportCodeChange();
if (parent.getType() == Token.EXPR_RESULT) {
n.detachChildren();
parent.replaceChild(n, left);
Node newStatement = new Node(Token.EXPR_RESULT, right);
newStatement.copyInformationFrom(n);
parent.getParent().addChildAfter(newStatement, parent);
t.getCompiler().reportCodeChange();
void tryFoldBlock(NodeTraversal t, Node n, Node parent) {
for (Node c = n.getFirstChild(); c != null; ) {
Node next = c.getNext();  // save c.next, since 'c' may be removed
if (!NodeUtil.mayHaveSideEffects(c)) {
n.removeChild(c);  // lazy kids
t.getCompiler().reportCodeChange();
c = next;
if (n.isSyntheticBlock() || parent == null) {
return;
if (NodeUtil.tryMergeBlock(n)) {
t.getCompiler().reportCodeChange();
boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {
int type = n.getType();
Node cond = n.getFirstChild();
Node thenBody = cond.getNext();
Node elseBody = thenBody.getNext();
boolean changes = false;
if (type == Token.IF) {
if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {
n.removeChild(elseBody);
elseBody = null;
t.getCompiler().reportCodeChange();
changes = true;
if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {
n.removeChild(elseBody);
n.replaceChild(thenBody, elseBody);
Node notCond = new Node(Token.NOT);
n.replaceChild(cond, notCond);
notCond.addChildToFront(cond);
cond = notCond;
thenBody = cond.getNext();
elseBody = null;
t.getCompiler().reportCodeChange();
changes = true;
if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {
if (NodeUtil.mayHaveSideEffects(cond)) {
n.removeChild(cond);
parent.replaceChild(n, NodeUtil.newExpr(cond));
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
return true; // The if has been removed. There is nothing to do.
Preconditions.checkState(type == Token.HOOK);
if (NodeUtil.isExpressionNode(parent)) {
if (!NodeUtil.mayHaveSideEffects(thenBody)) {
Node ifNode = new Node(Token.IF);
if (cond.getType() == Token.NOT) {
Node expr = cond.getFirstChild();
cond.removeChild(expr);
ifNode.addChildToBack(expr);
Node not = new Node(Token.NOT).copyInformationFrom(cond);
n.removeChild(cond);
not.addChildToBack(cond);
ifNode.addChildToBack(not);
n.removeChild(elseBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))
.copyInformationFrom(elseBody));
parent.getParent().replaceChild(parent, ifNode);
t.getCompiler().reportCodeChange();
return true;
Node ifNode = new Node(Token.IF);
n.removeChild(cond);
ifNode.addChildToBack(cond);
n.removeChild(thenBody);
ifNode.addChildToBack(
new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))
.copyInformationFrom(thenBody));
parent.getParent().replaceChild(parent, ifNode);
t.getCompiler().reportCodeChange();
return true;
if (!NodeUtil.isLiteralValue(cond)) {
return changes;  // We can't remove branches otherwise!
boolean condTrue = NodeUtil.getBooleanValue(cond);
if (n.getChildCount() == 2) {
Preconditions.checkState(type == Token.IF);
if (condTrue) {
Node thenStmt = n.getFirstChild().getNext();
n.removeChild(thenStmt);
parent.replaceChild(n, thenStmt);
t.getCompiler().reportCodeChange();
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
Node firstBranch = n.getFirstChild().getNext();
Node secondBranch = firstBranch.getNext();
Node branch = condTrue ? firstBranch : secondBranch;
Node notBranch = condTrue ? secondBranch : firstBranch;
NodeUtil.redeclareVarsInsideBranch(notBranch);
n.removeChild(branch);
parent.replaceChild(n, branch);
t.getCompiler().reportCodeChange();
return true;
if (NodeUtil.isLiteralValue(left)) {
boolean lval = NodeUtil.getBooleanValue(left);
boolean rval = NodeUtil.getBooleanValue(right);
void tryFoldWhile(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.WHILE);
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
void tryFoldFor(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.FOR);
if (n.getChildCount() != 4) return;
if (n.getFirstChild().getType() != Token.EMPTY) return;
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
NodeUtil.redeclareVarsInsideBranch(n);
NodeUtil.removeChild(parent, n);
t.getCompiler().reportCodeChange();
void tryFoldDo(NodeTraversal t, Node n, Node parent) {
Preconditions.checkArgument(n.getType() == Token.DO);
Node cond = NodeUtil.getConditionExpression(n);
if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
return;
if (hasBreakOrContinue(n)) {
return;
Preconditions.checkState(
NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));
Node block = n.removeFirstChild();
parent.replaceChild(n, block);
t.getCompiler().reportCodeChange();
boolean hasBreakOrContinue(Node n) {
return NodeUtil.has(
n,
Predicates.<Node>or(
new NodeUtil.MatchNodeType(Token.BREAK),
new NodeUtil.MatchNodeType(Token.CONTINUE)),
new NodeUtil.MatchNotFunction());
private void tryFoldForCondition(Node n, Node parent) {
if (NodeUtil.isLiteralValue(n)) {
boolean result = NodeUtil.getBooleanValue(n);
if (result) {
parent.replaceChild(n, new Node(Token.EMPTY));
compiler.reportCodeChange();
return "JSCompiler_inline_result_" + safeNameIdSupplier.get();
if (containsSeparator(name)) {
String newName = getOrginalName(name);
if (TokenStream.isJSIdentifier(newName) &&
!newName.equals(ARGUMENTS)) {
referencedNames.remove(name);
referencedNames.add(newName);
List<Node> references = nameMap.get(name);
Preconditions.checkState(references != null);
for (Node n : references) {
Preconditions.checkState(n.getType() == Token.NAME);
n.setString(newName);
compiler.reportCodeChange();
import com.google.common.collect.HashMultimap;
HashMultimap.create();
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
if (NodeUtil.isLiteralValue(cond) && !NodeUtil.getBooleanValue(cond)) {
static boolean getBooleanValue(Node n) {
return n.getString().length() > 0;
return n.getDouble() != 0;
return false;
return false;
return true;
return true;
throw new IllegalArgumentException("Non-literal value: " + n);
if (NodeUtil.isLiteralValue(n)) {
boolean result = NodeUtil.getBooleanValue(n);
sb.append(" * @param {" + n.getJSType() + "} ");
(currentInfo.hasFileOverview() || currentInfo.isExterns());
import com.google.common.collect.ImmutableList;
import java.util.List;
List<String> parsePrintParseTestCases = ImmutableList.of(
"3;",
"var a = b;",
"var x, y, z;",
"try { foo() } catch(e) { bar() }",
"try { foo() } catch(e) { bar() } finally { stuff() }",
"try { foo() } finally { stuff() }",
"throw 'me'",
"function foo(a) { return a + 4; }",
"function foo() { return; }",
"var a = function(a, b) { foo(); return a + b; }",
"b = [3, 4, 'paul', \"Buchhe it\",,5];",
"v = (5, 6, 7, 8)",
"d = 34.0; x = 0; y = .3; z = -22",
"d = -x; t = !x + ~y;",
"'hi'; /* just a test */ stuff(a,b) \n foo(); // and another \n bar();",
"a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;",
"a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5",
"a = (2 + 3) * 4;",
"a = 1 + (2 + 3) + 4;",
"x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());",
"a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o",
"a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);",
"if (a > b) a = b; if (b < 3) a = 3; else c = 4;",
"if (a == b) { a++; } if (a == 0) { a++; } else { a --; }",
"for (var i in a) b += i;",
"for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}",
"for (x = 0; x < 10; x++) a /= 2;",
"for (;;) a++;",
"while(true) { blah(); }while(true) blah();",
"do stuff(); while(a>b);",
"[0, null, , true, false, this];",
"s.replace(/absc/, 'X').replace(/ab/gi, 'Y');",
"new Foo; new Bar(a, b,c);",
"with(foo()) { x = z; y = t; } with(bar()) a = z;",
"delete foo['bar']; delete foo;",
"var x = { 'a':'paul', 1:'3', 2:(3,4) };",
"switch(a) { case 2: case 3: { stuff(); break; }" +
"case 4: morestuff(); break; default: done();}",
"x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;",
"a.v = b.v; x['foo'] = y['zoo'];",
"'test' in x; 3 in x; a in x;",
"'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'",
"x.__proto__;");
for (String testCase : parsePrintParseTestCases) {
Node parse1 = parse(testCase);
Node parse2 = parse(new CodePrinter.Builder(parse1).build());
assertTrue(testCase, parse1.checkTreeEqualsSilent(parse2));
helperMoveExpression("foo()", "foo", "var temp_0 = foo(); temp_0;");
"var temp_0 = foo(); x = temp_0;");
"var temp_0 = foo(); var x = temp_0;");
"var temp_0 = foo(); if (temp_0);");
"var temp_0 = foo(); switch(temp_0){}");
"var temp_0 = foo(); switch(1 + temp_0){}");
"function (){ var temp_0 = foo(); return temp_0;}");
"var temp_0 = foo(); x = temp_0 && 1");
"var temp_0 = foo(); x = temp_0 || 1");
"var temp_0 = foo(); x = temp_0 ? 0 : 1");
"var temp_0; if (temp_0 = 0) temp_0 = foo(); x = temp_0;");
"var temp_0; if (temp_0 = 1); else temp_0 = foo(); x = temp_0;");
"var temp_0; if (1) temp_0 = foo(); else temp_0 = 0;var x = temp_0;");
"var temp_0; if (temp_0 = goo()) temp_0 = foo(); x = temp_0;");
"var temp_0; if (temp_0 = goo()) temp_0 = foo();" +
"var x = 1 + temp_0;");
"var temp_0;" +
"if (temp_0 = goo()) temp_0 = foo();" +
"if(temp_0);");
"var temp_0;" +
"if (temp_0 = goo()) temp_0 = foo();" +
"switch(temp_0){}");
"var temp_const_0 = 1 + goo();" +
"switch(temp_const_0 + foo()){}");
"var temp_0; if (temp_0 = goo()) temp_0 = foo();" +
"return temp_0;" +
"var temp_const_1 = goo;" +
"var temp_const_0 = goo(2);" +
"var temp_2;" +
"if (1) temp_2 = foo(); else temp_2 = 0;" +
"if (temp_const_1(1, temp_const_0, temp_2));");
"var x = 0; var temp_const_0 = x;" +
"x = temp_const_0 + (foo() + 1);");
"var x = 0; var temp_const_0 = x;" +
"y = (x = temp_const_0 + foo()) + x");
"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;" +
"temp_const_0.a = temp_const_1 + (foo() + 1);");
"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;" +
"y = (temp_const_0.a = temp_const_1 + foo()) + x.a");
"var XX = {}; var temp_const_0 = XX.a;" +
"XX.a = temp_const_0 + (foo() + 1);");
"var XX = {}; var temp_const_0 = XX.a;" +
"y = (XX.a = temp_const_0 + foo()) + XX.a");
"var temp_const_0 = goo();" +
"var temp_const_1 = temp_const_0.a;" +
"temp_const_0.a = temp_const_1 + (foo() + 1);");
"var temp_const_0 = goo();" +
"var temp_const_1 = temp_const_0.a;" +
"y = (temp_const_0.a = temp_const_1 + foo()) + goo().a");
"var temp_const_0 = goo().a;" +
"var temp_const_1 = temp_const_0.b;" +
"temp_const_0.b = temp_const_1 + (foo() + 1);");
"var temp_const_0 = goo().a;" +
"var temp_const_1 = temp_const_0.b;" +
"y = (temp_const_0.b = temp_const_1 + foo()) + goo().a");
decomposer.setTempNamePrefix("temp_");
decomposer.setTempNamePrefix("temp_");
private static final JSSourceFile[] EXTERNS = {
JSSourceFile.fromCode("externs", "")
"var foobar = function(d, e, f) {};\n");
"var a;\na.b;\na.b.cprop = function(d, e, f) {};\n");
"var a;\n" +
"a.b = function(p1) {};\n" +
"a.b.c = function(d, e, f) {};\n" +
"a.b.prototype;\n" +
"a.b.prototype.c = function(g, h, i) {};\n");
"var hello;\n" +
"hello.b;\n" +
"hello.b.c = function(d, e, f) {};\n" +
"hello.b.prototype;\n" +
"hello.b.prototype.c = function(g, h, i) {};\n");
"var prefix = function(p1) {};\n" +
"prefix.c = function(d, e, f) {};\n");
"var foobar;\n");
"var foobar;\n");
public void testExportNonexistantProperty() throws Exception {
"var a;\n" +
"a.b;\n" +
"a.b.none;\n");
System.err.println(compile(js));
assertEquals(expected, compile(js));
private String compile(String js) {
Result result = compiler.compile(EXTERNS, inputs, options);
return result.externExport;
import com.google.common.collect.ImmutableSet;
ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations =
ImmutableSet.<AbstractPeepholeOptimization>of(
new PeepholeSubstituteAlternateSyntax());
new PeepholeOptimizationsPass(compiler, peepholeOptimizations);
fold("if(x && true) z()", "x&&z()");
fold("if(x && false) z()", "");
fold("if(x==y && false) z()", "");
fold("do { foo() } while(!true);", "foo()");
fold("if(foo())do {foo()} while(false) else bar()", "foo()?foo():bar()");
fold("!!true", "0");
fold("!(!x&&!y)", "!x&&!y");
oneRepetitiontest.fold("x ? x() : void 0", "x&&x();");
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"if (JSCompiler_inline_result_0) throw 'test'; }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"return JSCompiler_inline_result_0; }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"switch(JSCompiler_inline_result_0) { default:break; } }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0?0:1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0&&1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"1 + JSCompiler_inline_result_0 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0&&1 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"1 + JSCompiler_inline_result_0 }",
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"var b = 1 + JSCompiler_inline_result_0 }",
"function x() { a:{{var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=true;}" +
"JSCompiler_inline_result_0?0:1 }}",
"function x() { var JSCompiler_temp_const_0=goo();" +
"var JSCompiler_temp_1;" +
"  {JSCompiler_temp_1=true;} " +
"  JSCompiler_temp_1=1;" +
"JSCompiler_temp_const_0 + JSCompiler_temp_1" +
"var JSCompiler_temp_const_0=z;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"var JSCompiler_temp_const_0=z;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"var JSCompiler_temp_const_1=z;" +
"var JSCompiler_temp_const_0=bar();" +
"var JSCompiler_inline_result_2;" +
"JSCompiler_inline_result_2 = true;" +
"JSCompiler_temp_const_1[JSCompiler_temp_const_0] = " +
"JSCompiler_inline_result_2;" +
"var JSCompiler_temp_const_0=z.y.x;" +
"var JSCompiler_inline_result_1;" +
"JSCompiler_inline_result_1 = true;" +
"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;" +
"function x() { {var JSCompiler_inline_result_0; " +
"JSCompiler_inline_result_0=_g;}" +
"1 + JSCompiler_inline_result_0() }",
"  {var JSCompiler_inline_result_0; JSCompiler_inline_result_0=_g;}" +
"  var CONSTANT_RESULT = JSCompiler_inline_result_0;" +
ImmutableList.of("foo?(bar=0):(baz=0)"));
"{var JSCompiler_inline_result_0;a();}" +
"c=z=JSCompiler_inline_result_0");
"{var JSCompiler_inline_result_0;a();}" +
"c=JSCompiler_inline_result_0=z");
"{var JSCompiler_inline_result_0;a();}" +
"if(z=JSCompiler_inline_result_0);");
"var JSCompiler_temp_const_0=z;" +
"{var JSCompiler_inline_result_1;a()}" +
"if(JSCompiler_temp_const_0.y=JSCompiler_inline_result_1);");
"var JSCompiler_temp_const_0 = x;" +
"{var JSCompiler_inline_result_1; a=1; JSCompiler_inline_result_1=1}" +
"x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;");
"var JSCompiler_inline_result_0;" +
"JSCompiler_inline_result_0 = ret$$inline_2;\n" +
"descriptions_=JSCompiler_inline_result_0;" +
"var a;function foo(){var a$$inline_1; a = 1}");
testSameInFunction(
"var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}");
testSameInFunction(
"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };");
testSameInFunction(
"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;");
testSameInFunction(
"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2");
invert = true;
testSameWithInversion(
"function foo(){var arguments$$1;}");
"function f(a, a$$1) {}");
"function f(a, a$$2) {}");
testSame("function () {" +
"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}");
"  var a$$1;" +
"  var a$$1;" +
"    var a;a$$1++" +
assertTrue(NodeUtil.getBooleanValue(getNode("true")));
assertTrue(NodeUtil.getBooleanValue(getNode("10")));
assertTrue(NodeUtil.getBooleanValue(getNode("'0'")));
assertTrue(NodeUtil.getBooleanValue(getNode("/a/")));
assertTrue(NodeUtil.getBooleanValue(getNode("{}")));
assertTrue(NodeUtil.getBooleanValue(getNode("[]")));
assertFalse(NodeUtil.getBooleanValue(getNode("false")));
assertFalse(NodeUtil.getBooleanValue(getNode("null")));
assertFalse(NodeUtil.getBooleanValue(getNode("0")));
assertFalse(NodeUtil.getBooleanValue(getNode("''")));
assertFalse(NodeUtil.getBooleanValue(getNode("undefined")));
assertFalse(NodeUtil.getBooleanValue(getNode("void 0")));
result = node.getFirstChild().toString(false, false, false);
result += " " + node.getLastChild().toString(false, false, false);
StringBuilder sb = new StringBuilder();
result.sourceMap.appendTo(sb, "testMap");
assertEquals(expectedMap, sb.toString());
JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName, js) };
&& Objects.equal(jsType, node2.getJSType())) {
!thisParamType.equals(otherParamType)) {
public boolean equals(Object object) {
if (!returnType.equals(that.returnType) ||
public boolean equals(Object that) {
ObjectType thatObj = ObjectType.cast((JSType) that);
return this.equals(that) ? TRUE : FALSE;
return that.equals(getNativeType(JSTypeNative.OBJECT_TYPE)) ||
that.equals(getNativeType(JSTypeNative.OBJECT_PROTOTYPE)) ||
return equals(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));
if (objType.equals(prototype)) {
if (equals(that)) {
Objects.equal(typeOfThis, other.typeOfThis)) {
if (functionInstance.equals(that)) {
public boolean equals(Object otherType) {
return this.typeOfThis.equals(that.typeOfThis) &&
this.call.equals(that.call);
return this.call.equals(otherType.call);
if (this.equals(that)) {
public boolean equals(Object that) {
ObjectType thatObj = ObjectType.cast((JSType) that);
return jsType.equals(this);
return thisType.equals(thatType) ? thisType :
return !this.equals(that);
if (thisType.equals(thatType)) {
public boolean equals(Object that) {
ObjectType objType = ObjectType.cast((JSType) that);
if (objType != null) {
return objType.isNominalType() &&
reference.equals(objType.getReferenceName());
public boolean equals(Object that) {
if (current.equals(prototype)) {
public boolean equals(Object that) {
return referencedType.equals(that);
public boolean equals(Object other) {
return otherRecord.properties.equals(properties);
thatRecord.getPropertyType(property).equals(
!thatRecord.getPropertyType(property).equals(
if (altPropType != null && !alt.equals(this) &&
altPropType.equals(propType))) {
if (!propA.equals(propB)) {
import java.util.Set;
Set<JSType> alternates;
UnionType(JSTypeRegistry registry, Set<JSType> alternates) {
public boolean equals(Object object) {
return alternates.equals(that.alternates);
Set<JSType> newAlternates = resolvedTypes.build();
Assert.assertEquals("JSType#resolve should not affect object equality",
assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));
assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));
assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));
assertEquals(getNativeType(NUMBER_OBJECT_TYPE),
assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));
assertEquals(getNativeType(STRING_TYPE),
assertEquals(getNativeType(NUMBER_TYPE), resolve(info.getType()));
assertEquals(getNativeType(BOOLEAN_TYPE),
assertEquals(getNativeType(BOOLEAN_TYPE),
assertEquals(getNativeType(BOOLEAN_TYPE),
assertEquals(NUMBER_TYPE, params.getFirstChild().getJSType());
assertEquals(registry.createOptionalType(BOOLEAN_TYPE),
assertEquals(registry.createOptionalType(STRING_TYPE),
assertEquals(typeRegistry.getNativeType(JSTypeNative.BOOLEAN_TYPE),
assertEquals(type, typeRegistry.getType(name));
assertEquals(type, typeRegistry.getType(name));
assertEquals(type, typeRegistry.getType(name));
assertEquals(type, typeRegistry.getType(name));
assertEquals(type, typeRegistry.getType(name));
assertEquals(UNKNOWN_TYPE,
assertEquals(NO_TYPE,
assertEquals(NO_TYPE,
assertEquals(ALL_TYPE,
assertEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE),
assertEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE),
assertEquals(createUnionType(ARRAY_TYPE, functionType),
assertEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE));
assertEquals(createUnionType(DATE_TYPE, ARRAY_TYPE),
assertEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE),
assertEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("length"));
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());
assertEquals(ALL_TYPE,
assertEquals(OBJECT_TYPE,
assertEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE),
assertEquals(OBJECT_TYPE,
assertEquals(OBJECT_TYPE,
assertEquals(OBJECT_TYPE,
assertEquals(OBJECT_TYPE,
assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());
assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());
assertEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo());
assertEquals(ALL_TYPE,
assertEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE),
assertEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE),
assertEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType),
assertEquals(OBJECT_TYPE,
assertEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE),
assertEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE),
assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());
assertEquals(ALL_TYPE,
assertEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE),
assertEquals(NUMBER_TYPE,
assertEquals(createUnionType(NUMBER_TYPE, functionType),
assertEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE),
assertEquals(createUnionType(NUMBER_TYPE, DATE_TYPE),
assertEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE),
assertEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE));
assertEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE));
assertEquals(createNullableType(STRING_OBJECT_TYPE),
assertEquals(createNullableType(NUMBER_TYPE),
assertEquals(createNullableType(functionType),
assertEquals(createNullableType(OBJECT_TYPE),
assertEquals(createNullableType(DATE_TYPE),
assertEquals(createNullableType(REGEXP_TYPE),
assertEquals(ALL_TYPE,
assertEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE),
assertEquals(createUnionType(DATE_TYPE, NUMBER_TYPE),
assertEquals(createUnionType(DATE_TYPE, functionType),
assertEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE));
assertEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE));
assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),
assertEquals(ALL_TYPE,
assertEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE),
assertEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE),
assertEquals(createUnionType(REGEXP_TYPE, functionType),
assertEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE));
assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),
assertEquals(REGEXP_TYPE,
assertEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType("source"));
assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("global"));
assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("ignoreCase"));
assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("multiline"));
assertEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType("lastIndex"));
assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());
assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());
assertEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("length"));
assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());
assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());
assertEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType("length"));
assertEquals(expectedReturnType, ((FunctionType) function).getReturnType());
assertEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor());
assertEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype());
assertEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType());
assertEquals(leastSupertype, recordType);
assertEquals(leastSupertype, builder.build());
assertEquals(leastSupertype, OBJECT_TYPE);
assertEquals(leastSupertype, OBJECT_TYPE);
assertEquals(subtype, builder.build());
assertEquals(subtype, builder.build());
assertEquals(subtype, builder.build());
assertEquals(subtype, NO_TYPE);
assertEquals(NO_OBJECT_TYPE,
assertEquals(U2U_CONSTRUCTOR_TYPE,
assertEquals(U2U_CONSTRUCTOR_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(U2U_CONSTRUCTOR_TYPE,
assertEquals(U2U_CONSTRUCTOR_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(googBar,
assertEquals(googBar,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals("apply should have the same return type as its function",
assertEquals("apply's first arg is the @this type",
assertEquals("apply's second arg is an Array",
assertEquals("call should have the same return type as its function",
assertEquals("call's first arg is the @this type",
i == j, typeA.equals(typeB));
typeA.getTypeOfThis().equals(typeB.getTypeOfThis()),
assertEquals(typeA, typeA.getLeastSupertype(typeB));
assertEquals(typeA, typeA.getGreatestSubtype(typeB));
assertEquals(String.format("sup(%s, %s)", typeA, typeB),
assertEquals(String.format("inf(%s, %s)", typeA, typeB),
i == j, typeA.equals(typeB));
assertEquals(typeA, typeA.getLeastSupertype(typeB));
assertEquals(typeA, typeA.getGreatestSubtype(typeB));
assertEquals(String.format("sup(%s, %s)", typeA, typeB),
assertEquals(String.format("inf(%s, %s)", typeA, typeB),
assertEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo());
assertEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo());
assertEquals(UNKNOWN_TYPE, stringEnum.getPropertyType("length"));
assertEquals(NUMBER_TYPE, stringEnum.findPropertyType("length"));
assertEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo());
assertEquals(NUMBER_TYPE, stringEnum.getPropertyType("length"));
assertEquals(NUMBER_TYPE, stringEnum.findPropertyType("length"));
assertEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor());
assertTrue(googBar.equals(googBar));
assertFalse(googBar.equals(googSubBar));
assertEquals(instance.getImplicitPrototype(), prototype);
assertEquals(NUMBER_TYPE, instance.getPropertyType("declared"));
assertEquals(
assertEquals(
assertEquals(NUMBER_TYPE, instance.getPropertyType("prop"));
assertEquals(STRING_TYPE, prototype.getPropertyType("prop"));
assertEquals(DATE_TYPE, namedGoogBar.getPropertyType("date"));
assertEquals(ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(BOOLEAN_OBJECT_TYPE.getImplicitPrototype().
assertEquals(DATE_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(NUMBER_OBJECT_TYPE.getImplicitPrototype().
assertEquals(URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(REFERENCE_ERROR_TYPE.getImplicitPrototype().
assertEquals(STRING_OBJECT_TYPE.getImplicitPrototype().
assertEquals(REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(),
assertEquals(SYNTAX_ERROR_TYPE.getImplicitPrototype().
assertEquals(TYPE_ERROR_TYPE.getImplicitPrototype().
assertEquals(ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor());
assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,
assertEquals(DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor());
assertEquals(ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor());
assertEquals(EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor());
assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,
assertEquals(OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor());
assertEquals(RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor());
assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,
assertEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor());
assertEquals(STRING_OBJECT_FUNCTION_TYPE,
assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,
assertEquals(TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor());
assertEquals(URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor());
aOnB.equals(bOnA));
assertFalse(googBar.equals(googBar.getInstanceType()));
assertFalse(googBar.getInstanceType().equals(googBar));
aOnB.equals(bOnA));
assertEquals("getLeastSupertype not reflexive",
assertEquals("getGreatestSubtype not reflexive",
assertEquals(expected,
assertEquals(expected,
assertEquals(expected,
assertEquals(expected,
assertEquals(UNKNOWN_TYPE, expected);
assertEquals(expected,
assertEquals(expected,
assertEquals(CHECKED_UNKNOWN_TYPE, expected);
assertTrue(a.equals(b));
assertTrue(namedGoogBar.equals(googBar.getInstanceType()));
assertTrue(googBar.getInstanceType().equals(namedGoogBar));
assertEquals(a, realA);
assertEquals(b, realB);
assertEquals(a, realA);
assertEquals(b, realB);
assertEquals(a, b);
assertEquals(a, b);
assertFalse(a.equals(UNKNOWN_TYPE));
assertFalse(b.equals(UNKNOWN_TYPE));
assertEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE));
assertEquals(CHECKED_UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a));
assertEquals(CHECKED_UNKNOWN_TYPE,
assertEquals(ARRAY_TYPE,
assertEquals(ARRAY_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE));
assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(functionType));
assertEquals(STRING_OBJECT_TYPE,
assertEquals(STRING_OBJECT_TYPE,
assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(DATE_TYPE));
assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE));
assertEquals(EVAL_ERROR_TYPE,
assertEquals(EVAL_ERROR_TYPE,
assertEquals(NO_TYPE,
assertEquals(UNKNOWN_TYPE,
assertTrue(typeI + " should equal itself", typeI.equals(typeI));
typeI.equals(typeJ));
assertEquals(
assertEquals(
assertEquals(BOOLEAN_TYPE,
assertEquals(BOOLEAN_TYPE,
assertEquals(NO_TYPE,
assertEquals(NULL_TYPE,
assertEquals(NUMBER_TYPE,
assertEquals(NUMBER_TYPE,
assertEquals(STRING_TYPE,
assertEquals(STRING_TYPE,
assertEquals(STRING_OBJECT_TYPE,
assertEquals(NO_TYPE,
assertEquals(NO_TYPE,
assertEquals(VOID_TYPE,
assertEquals(NO_OBJECT_TYPE,
assertEquals(NO_TYPE,
assertEquals(NO_TYPE,
assertEquals(NO_TYPE,
assertEquals(ALL_TYPE,
assertEquals(ALL_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(UNKNOWN_TYPE,
assertEquals(STRING_TYPE,
assertEquals(nullableStringValue,
assertEquals(STRING_OBJECT_TYPE,
assertEquals(NULL_TYPE,
assertEquals(type,
assertEquals(NO_TYPE,
assertEquals(derived1,
assertEquals(NO_OBJECT_TYPE,
assertEquals(derived1,
assertEquals(derived2,
assertEquals(bar,
assertEquals(t1Eq, p12.typeA);
assertEquals(t1Eq, p21.typeB);
assertEquals(t2Eq, p12.typeB);
assertEquals(t2Eq, p21.typeA);
assertEquals(t1Eq, p12.typeA);
assertEquals(t1Eq, p21.typeB);
assertEquals(t2Eq, p12.typeB);
assertEquals(t2Eq, p21.typeA);
assertEquals(OBJECT_TYPE, anonymous.getImplicitPrototype());
assertEquals(DATE_TYPE.getImplicitPrototype(),
assertEquals(ERROR_TYPE.getImplicitPrototype(),
assertEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType("X"));
assertEquals(NUMBER_TYPE, sup.getPropertyType("X"));
assertEquals(NUMBER_TYPE, sub.getPropertyType("X"));
abstract SymbolTable acquireSymbolTable();
options.inlineAnonymousFunctionExpressions = true;
options.decomposeExpressions = true;
options.inlineAnonymousFunctionExpressions = true;
options.decomposeExpressions = true;
private SymbolTable symbolTable = null;
SymbolTable acquireSymbolTable() {
if (symbolTable == null) {
symbolTable = new SymbolTable(this);
symbolTable.acquire();
return symbolTable;
options.inlineAnonymousFunctionExpressions,
enableBlockInlining,
options.decomposeExpressions);
tryFoldRegularExpressionConstructor(t, n, parent);
tryFoldLiteralConstructor(
t, n, parent, className, Token.ARRAYLIT);
tryFoldLiteralConstructor(
t, n, parent, className, Token.OBJECTLIT);
void tryFoldRegularExpressionConstructor(
return;
return;
return;
void tryFoldLiteralConstructor(
return;
private final boolean inlineFunctionExpressions;
boolean inlineFunctionExpressions,
boolean blockFunctionInliningEnabled,
boolean enableExpressionDecomposition) {
this.inlineFunctionExpressions =
inlineFunctionExpressions;
this.injector = new FunctionInjector(
compiler, safeNameIdSupplier, enableExpressionDecomposition);
return inlineLocalFunctions || inlineFunctionExpressions
|| parent == null || NodeUtil.isControlStructure(parent)
|| NodeUtil.isStatementBlock(parent);
if (inlineFunctionExpressions) {
findFunctionExpressions(t, n);
Node reparsedRoot = sanityCheckCodeGeneration(root);
if (reparsedRoot != null) {
Node clonedExterns = externs.cloneTree();
sanityCheckSymbolTable(
new Node(Token.BLOCK,
clonedExterns,
new Node(Token.BLOCK, reparsedRoot)),
root.getParent());
private void sanityCheckSymbolTable(Node reparsedRoot, Node originalRoot) {
SymbolTable table = compiler.acquireSymbolTable();
table.verify(reparsedRoot, originalRoot);
table.release();
package com.google.javascript.jscomp;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
class SymbolTable implements ScopeCreator, CodeChangeHandler {
static final DiagnosticType MISSING_VARIABLE =
DiagnosticType.error(
"JSC_MISSING_VARIABLE",
"Missing variable name: {0}");
static final DiagnosticType MOVED_VARIABLE =
DiagnosticType.error(
"JSC_MOVED_VARIABLE",
"Moved variable name: {0}");
static final DiagnosticType VARIABLE_COUNT_MISMATCH =
DiagnosticType.error(
"JSC_VARIABLE_COUNT_MISMATCH",
"Variable count does not match." +
"\nCached : {0}\nActual : {1}");
static final DiagnosticType SCOPE_MISMATCH =
DiagnosticType.error(
"JSC_SCOPE_MISMATCH",
"Scope roots used with the symbol table do not match." +
"\nExpected : {0}\nActual : {1}");
private final AbstractCompiler compiler;
private final ScopeCreator scopeCreator;
private boolean locked = false;
private MemoizedData cache = null;
SymbolTable(AbstractCompiler compiler) {
this.compiler = compiler;
compiler.addChangeHandler(this);
scopeCreator = new SyntacticScopeCreator(compiler);
synchronized void acquire() {
Preconditions.checkState(!locked, "SymbolTable already acquired");
locked = true;
synchronized void release() {
Preconditions.checkState(locked, "SymbolTable already released");
locked = false;
public Scope createScope(Node n, Scope parent) {
Preconditions.checkArgument(
(n.getType() == Token.BLOCK && n.getParent() == null) ||
n.getType() == Token.FUNCTION,
"May only create scopes for the global node and functions");
ensureCacheInitialized();
if (!cache.scopes.containsKey(n)) {
cache.scopes.put(n, scopeCreator.createScope(n, parent));
return cache.scopes.get(n);
private void ensureCacheInitialized() {
Preconditions.checkState(locked, "Unacquired symbol table");
if (cache == null) {
cache = new MemoizedData();
public void reportChange() {
if (!locked) {
cache = null;
private static class MemoizedData {
private Map<Node, Scope> scopes = Maps.newHashMap();
void verify(Node expectedRoot, Node actualRoot) {
VerifyingCallback callback = new VerifyingCallback(
expectedRoot, actualRoot);
callback.verify();
private class VerifyingCallback implements ScopedCallback {
private final List<Scope> expectedScopes = Lists.newArrayList();
private final List<Scope> actualScopes = Lists.newArrayList();
private boolean collectingExpected = true;
private final Node actualRoot;
private final Node expectedRoot;
private VerifyingCallback(Node expectedRoot, Node actualRoot) {
this.actualRoot = actualRoot;
this.expectedRoot = expectedRoot;
public boolean shouldTraverse(
NodeTraversal nodeTraversal, Node n, Node parent) {
return true;
public void visit(NodeTraversal t, Node n, Node parent) {}
public void enterScope(NodeTraversal t) {}
public void exitScope(NodeTraversal t) {
if (collectingExpected) {
expectedScopes.add(t.getScope());
actualScopes.add(t.getScope());
private void verify() {
if (cache == null) {
return;
if (!cache.scopes.isEmpty()) {
verifyScopes();
private void verifyScopes() {
collectingExpected = true;
NodeTraversal.traverse(compiler, expectedRoot, this);
collectingExpected = false;
(new NodeTraversal(compiler, this, SymbolTable.this))
.traverse(actualRoot);
Preconditions.checkState(expectedScopes.size() == actualScopes.size());
for (int i = 0; i < expectedScopes.size(); i++) {
Scope expectedScope = expectedScopes.get(i);
Scope actualScope = actualScopes.get(i);
if (!checkNodesMatch(expectedScope.getRootNode(),
actualScope.getRootNode())) {
compiler.report(
JSError.make(
SCOPE_MISMATCH,
expectedScope.getRootNode().toStringTree(),
actualScope.getRootNode().toStringTree()));
continue;
if (expectedScope.getVarCount() != actualScope.getVarCount()) {
compiler.report(
JSError.make(
VARIABLE_COUNT_MISMATCH,
Integer.toString(expectedScope.getVarCount()),
Integer.toString(actualScope.getVarCount())));
Iterator<Var> it = expectedScope.getVars();
while (it.hasNext()) {
Var var = it.next();
Scope.Var actualVar = actualScope.getVar(var.getName());
if (actualVar == null ||
expectedScope.getVar(var.getName()) != var) {
compiler.report(
JSError.make(MISSING_VARIABLE, var.getName()));
!checkNodesMatch(
var.getNameNode(),
actualVar.getNameNode()) ||
!isNodeAttached(actualVar.getNameNode())) {
compiler.report(
JSError.make(MOVED_VARIABLE, var.getName()));
private boolean checkNodesMatch(Node nodeA, Node nodeB) {
Node currentA = nodeA;
Node currentB = nodeB;
while (currentA != null && currentB != null) {
if (currentA.getType() != currentB.getType() ||
!currentA.isEquivalentTo(currentB)) {
return false;
currentA = currentA.getParent();
currentB = currentB.getParent();
return currentA == null && currentB == null;
private boolean isNodeAttached(Node node) {
for (Node current = node;
current != null; current = current.getParent()) {
if (current.getType() == Token.SCRIPT) {
return true;
return false;
SymbolTable table = compiler.acquireSymbolTable();
table.verify(
new Node(Token.BLOCK, externsRoot.cloneTree(), expectedRoot),
mainRoot.getParent());
table.release();
fold("x = new RegExp",                    "x = new RegExp");
fold("x = new RegExp(\"\")",              "x = new RegExp(\"\")");
fold("x = new RegExp(\"\", \"i\")",       "x = new RegExp(\"\",\"i\")");
"x = new RegExp(\"foobar\",\"bogus\")",
"x = new RegExp(\"foobar\",\"g\")");
"x = new RegExp(\"foobar\",\"ig\")");
fold("x = new RegExp(\"\\u2028\")", "x = new RegExp(\"\\u2028\")");
foldSame("x = new RegExp(\"" + longRegexp + "\")");
fold("x = new Array(7)", "x = new Array(7)");
allowFunctionExpressionInlining,
allowBlockInlining,
allowExpressionDecomposition);
public void testSymbolTable() throws Exception {
otherPass = new CompilerPass() {
SymbolTable st = getLastCompiler().acquireSymbolTable();
st.createScope(root.getParent(), null);
Node script = root.getFirstChild();
script.removeChild(script.getFirstChild());
st.release();
test("var x;", null, SymbolTable.VARIABLE_COUNT_MISMATCH);
public void testSymbolTableWrongRoot() throws Exception {
otherPass = new CompilerPass() {
SymbolTable st = getLastCompiler().acquireSymbolTable();
st.createScope(root, null);
st.release();
try {
testSame("var x;");
assertEquals(
"May only create scopes for the global node and functions",
e.getMessage());
package com.google.javascript.jscomp;
import static com.google.javascript.jscomp.SymbolTable.MISSING_VARIABLE;
import static com.google.javascript.jscomp.SymbolTable.MOVED_VARIABLE;
import static com.google.javascript.jscomp.SymbolTable.VARIABLE_COUNT_MISMATCH;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
public class SymbolTableTest extends CompilerTestCase {
DiagnosticType targetError = null;
return new BuggyVariableChanger(compiler);
super.enableLineNumberCheck(false);
setExpectedSymbolTableError(null);
targetError = null;
public void testOk() throws Exception {
test("var x = 3;", "");
public void testCountMismatch() throws Exception {
setExpectedSymbolTableError(VARIABLE_COUNT_MISMATCH);
test("var x = 3, y = 5;", "");
public void testMovedVariable() throws Exception {
setExpectedSymbolTableError(MOVED_VARIABLE);
test("var x = 3, y = 5;", "var x, y = 5;");
public void testMissingVariable() throws Exception {
setExpectedSymbolTableError(MISSING_VARIABLE);
test("var x = 3, y = 5;", "var z = 3, y = 5;");
protected void setExpectedSymbolTableError(DiagnosticType type) {
super.setExpectedSymbolTableError(type);
targetError = type;
private class BuggyVariableChanger
extends NodeTraversal.AbstractPostOrderCallback
implements CompilerPass {
private final AbstractCompiler compiler;
BuggyVariableChanger(AbstractCompiler compiler) {
this.compiler = compiler;
public void process(Node externs, Node root) {
SymbolTable table = compiler.acquireSymbolTable();
(new NodeTraversal(compiler, this, table)).traverseRoots(externs, root);
table.release();
public void visit(NodeTraversal t, Node node, Node parent) {
Scope scope = t.getScope();
if (node.getType() == Token.VAR) {
compiler.reportCodeChange();
if (targetError == null) {
parent.removeChild(node);
for (Node child = node.getFirstChild();
child != null; child = child.getNext()) {
scope.undeclare(scope.getVar(child.getString()));
parent.removeChild(node);
scope.undeclare(scope.getVar(node.getFirstChild().getString()));
node.getFirstChild().setString("z");
Node oldName = node.getFirstChild();
oldName.detachFromParent();
node.addChildToFront(Node.newString(Token.NAME, "x"));
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.graph.GraphNode;
t.getControlFlowGraph()).compute(
options.flowSensitiveInlineVariables = true;
options.flowSensitiveInlineVariables = true;
if (factoryList.get(i).getName().equals(passName)) {
factoryList.add(i, factory);
return;
"No factory named '" + passName + "' in the factory list");
import com.google.common.io.CharStreams;
import com.google.common.annotations.VisibleForTesting;
return parseFile(filePath, Files.toString(new File(filePath), Charsets.UTF_8));
doParse(filePath, new StringReader(fileContents));
if (line.indexOf("addDependency") == -1) {
return true;
depMatcher.reset(line);
if (depMatcher.matches()) {
String addDependencyParams = depMatcher.group(1);
depArgsMatch.reset(addDependencyParams);
if (!depArgsMatch.matches()) {
throw new ParseException("Invalid arguments to goog.addDependency(). Found: "
+ addDependencyParams, true);
String path = parseJsString(depArgsMatch.group(1));
DependencyInfo depInfo = new SimpleDependencyInfo(path, filePath,
parseJsStringArray(depArgsMatch.group(2)),
parseJsStringArray(depArgsMatch.group(3)));
if (logger.isLoggable(Level.FINE)) {
logger.fine("Found dep: " + depInfo);
depInfos.add(depInfo);
return true;
if (!parseLine(revisedLine)) {
private boolean shortcutMode = false;
public void setShortcutMode(boolean mode) {
this.shortcutMode = mode;
import com.google.javascript.jscomp.graph.Annotation;
import com.google.javascript.jscomp.graph.DiGraph;
import com.google.javascript.jscomp.graph.GraphNode;
if (graph.getNode(source).getAnnotation() == REACHABLE) {
List<String> EMPTY = Collections.emptyList();
import java.util.Map;
options.checkGlobalThisLevel = CheckLevel.OFF;
options.checkGlobalThisLevel = CheckLevel.OFF;
initOptions(options);
this.externs = makeCompilerInput(externs, true);
this.modules = null;
this.moduleGraph = null;
this.inputs = makeCompilerInput(inputs, false);
initBasedOnOptions();
initInputsByNameMap();
this.modules = modules;
try {
this.moduleGraph = new JSModuleGraph(modules);
report(JSError.make(MODULE_DEPENDENCY_ERROR,
e.getModule().getName(), e.getDependentModule().getName()));
return;
this.inputs = getAllInputsFromModules();
private void fillEmptyModules(List<JSModule> modules) {
static final DiagnosticType DUPLICATE_INPUT_IN_MODULES =
DiagnosticType.error("JSC_DUPLICATE_INPUT_IN_MODULES_ERROR",
"Two modules cannot contain the same input, but module {0} and {1} "
+ "both include \"{2}\"");
inputs = getAllInputsFromModules();
private List<CompilerInput> getAllInputsFromModules() {
JSModule firstModule = inputMap.get(inputName);
if (firstModule == null) {
inputs.add(input);
inputMap.put(inputName, module);
report(JSError.make(DUPLICATE_INPUT_IN_MODULES,
firstModule.getName(), module.getName(), inputName));
if (hasErrors()) {
return ImmutableList.of();
List<CompilerInput> annotatedExterns = Lists.newArrayList();
Iterator<CompilerInput> inputIterator = inputs.iterator();
while (inputIterator.hasNext()) {
CompilerInput input = inputIterator.next();
inputIterator.remove();
checkGlobalThisLevel = CheckLevel.WARNING;
import java.util.Map;
if (options.checkSuspiciousCode) {
sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));
sharedCallbacks.add(new CheckSideEffects(CheckLevel.WARNING));
if (options.checkGlobalThisLevel.isOn()) {
new CheckGlobalThis(compiler, options.checkGlobalThisLevel));
public class JSModule implements DependencyInfo {
if (module != provided.firstModule /* covers null case */ &&
!compiler.getModuleGraph().dependsOn(module,
if (moduleGraph != null) {
if (minimumModule == null) {
minimumModule = newModule;
minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(
minimumModule, newModule);
JSModuleGraph graph = compiler.getModuleGraph();
if (graph == null) {
.setModuleName(module == null ? "" : module.getName())
Scope functionScope) {
ImmutableSet.<Var>of());
Scope functionScope, Collection<Var> unflowableVars) {
getUnflowableVars(scope));
public void testExternsLifting1() {
test(new String[] {"/** @externs */ function f() {}"},
import com.google.javascript.rhino.jstype.FunctionType;
compiler.getCodingConvention(), registry);
TypeInference dfa =
new TypeInference(compiler, cfg, rai, assumedScope);
state.anonymousFunctionNameMap, functionInformationMap,
anonymousFunctionNameMap, functionNames);
VariableMap anonymousFunctionNameMap, FunctionNames functionNames) {
namedAnonFunctionMap, functionInformationMap, sourceMap,
private CompilerInput[] externs;
private JSModule[] modules;
private CompilerInput[] inputs;
private CompilerInput[] makeCompilerInput(
JSSourceFile[] files, boolean isExtern) {
CompilerInput [] inputs = new CompilerInput[files.length];
for (int i = 0; i < files.length; ++i) {
inputs[i] = new CompilerInput(files[i], isExtern);
private void checkFirstModule(JSModule[] modules) {
if (modules.length == 0) {
modules[0].getName()));
private void fillEmptyModules(JSModule[] modules) {
for (int i = 1; i < modules.length; i ++) {
JSModule module = modules[i];
private CompilerInput[] getAllInputsFromModules() {
List<CompilerInput> inputs = new ArrayList<CompilerInput>();
Map<String, JSModule> inputMap = new HashMap<String, JSModule>();
return new CompilerInput[0];
return inputs.toArray(new CompilerInput[inputs.size()]);
init(externs, modules, options);
int numInputs = inputs.length;
Node scriptNode = inputs[i].getAstRoot(Compiler.this);
if (inputs.length == 0) {
return inputs[0].getAstRoot(this);
List<CompilerInput> inputs = module.getInputs();
if (inputs.size() > 0) {
return inputs.get(0).getAstRoot(this);
private CompilerInput[] externs;
private CompilerInput[] inputs;
private JSModule[] modules;
private final boolean isExtern;
moduleDepths = new HashMap<JSModule, Integer>(modulesInDepOrder.length);
modulesByDepth = new ArrayList<List<JSModule>>();
private void markAllParametersEscaped() {
case ANNOTATION:
case EOC:
case EOF:
String multilineText = builder.toString();
if (option != WhitespaceOption.PRESERVE) {
multilineText = multilineText.trim();
int endLineno = stream.getLineno();
int endCharno = stream.getCharno();
if (multilineText.length() > 0) {
jsdocBuilder.markText(multilineText, startLineno, startCharno,
endLineno, endCharno);
return new ExtractionInfo(multilineText, token);
"function FUNC(x, y) {         y; y=0; y; x; x=0; x}");
private Predicate<N> nodePredicate;
private Predicate<DiGraphEdge<N, E>> edgePredicate;
private boolean result;
Predicate<DiGraphEdge<N, E>> edgePredicate) {
graph.pushNodeAnnotations();
graph.pushEdgeAnnotations();
discoverBackEdges(a);
result = checkAllPathsWithoutBackEdges(a, b);
graph.popNodeAnnotations();
graph.popEdgeAnnotations();
if (nodePredicate.apply(a.getValue())) {
throw new IllegalArgumentException("Node cannot be refined.");
if (value.equals("number")) {
return getNativeType(NUMBER_TYPE);
return getNativeType(BOOLEAN_TYPE);
return getNativeType(STRING_TYPE);
return getNativeType(VOID_TYPE);
return getNativeType(U2U_CONSTRUCTOR_TYPE);
return topType;
return type == null ? null :
type.visit(new RestrictByOneTypeOfResultVisitor(
value, resultEqualsValue));
return p.type == null ? null : p.type.visit(visitor);
return p.type == null ? null : p.type.visit(visitor);
if (callee.getType() == GETPROP) {
if (paramType != null) {
Node left = callee.getFirstChild();
Node right = callee.getLastChild();
if (left.getType() == NAME && "goog".equals(left.getString()) &&
right.getType() == STRING) {
Function<TypeRestriction, JSType> restricter =
restricters.get(right.getString());
if (restricter != null) {
return restrictParameter(param, paramType, blindScope, restricter,
outcome);
getJSType(value));
if (var != null &&
!(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
type = var.getType();
if (type == null) {
type = getNativeType(UNKNOWN_TYPE);
"var FooAlias = Foo;" +
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
static class ContextualRenameInverter extends AbstractPostOrderCallback
implements CompilerPass {
private Map<Var, String> nameMap = Maps.newHashMap();
private static String getOrginalNameInternal(String name, int index) {
return name.substring(0, index);
private static String getNameSuffix(String name, int index) {
return name.substring(
index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),
name.length());
public void visit(NodeTraversal t, Node node, Node parent) {
if (node.getType() == Token.NAME) {
String oldName = node.getString();
if (oldName.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) {
Scope scope = t.getScope();
Var var = t.getScope().getVar(oldName);
if (var == null || var.isGlobal()) {
return;
if (nameMap.containsKey(var)) {
node.setString(nameMap.get(var));
int index = indexOfSeparator(oldName);
String newName = getOrginalNameInternal(oldName, index);
String suffix = getNameSuffix(oldName, index);
boolean recurseScopes = false;
if (!suffix.matches("\\d+")) {
recurseScopes = true;
if (var.scope.isDeclared(newName, recurseScopes) ||
!TokenStream.isJSIdentifier(newName)) {
newName = oldName;
var.scope.declare(newName, var.nameNode, null, null);
Node parentNode = var.getParentNode();
if (parentNode.getType() == Token.FUNCTION &&
parentNode == var.scope.getRootNode()) {
var.getNameNode().setString(newName);
node.setString(newName);
compiler.reportCodeChange();
nameMap.put(var, newName);
if (global) {
reserveName(name);
if (!declarations.containsKey(name)) {
int id = incrementNameCount(name);
String newName = null;
if (id != 0) {
newName = getUniqueName(name, id);
declarations.put(name, newName);
removeDuplicateDeclarations(root);
public void testMakeLocalNamesUniqueWithContext0() {
public void testMakeLocalNamesUniqueWithContext() {
public void testMakeLocalNamesUniqueWithContext2() {
public void testRemoveDuplicateVarDeclarations() {
import com.google.javascript.rhino.jstype.JSType.TypePair;
if (result != null) {
UnionType numStr = (UnionType) createUnionType(
numStr.getGreatestSubtype(ERROR_TYPE));
import com.google.common.base.StringUtil;
if (!StringUtil.isEmpty(unaliasableGlobals) &&
!StringUtil.isEmpty(aliasableGlobals)) {
if (!StringUtil.isEmpty(unaliasableGlobals)) {
if (!StringUtil.isEmpty(aliasableGlobals)) {
context.getScriptNode().addChildAfter(expression,
context.getContextNode());
root = ParserRunner.parse(sourceName, sourceStr, compiler.isIdeMode(),
compiler.getTypeRegistry(),
import com.google.common.base.StringUtil;
builder.append(StringUtil.repeat(" ", spaces));
import com.google.common.base.StringUtil;
String language = StringUtil.makeSafe(matcher.group(1));
String country = StringUtil.makeSafe(matcher.group(2));
String variant = StringUtil.makeSafe(matcher.group(3));
import com.google.common.base.StringUtil;
StringUtil.truncateAtMaxLength(source, 100, true)));
StringUtil.truncateAtMaxLength(source, 100, true),
StringUtil.truncateAtMaxLength(source2, 100, true)));
if (n.getParent().getType() == Token.BLOCK
|| n.getParent().getType() == Token.SCRIPT) {
Node paramNode = NodeUtil.getFnParameters(fnNode).getFirstChild();
for (Node n : funType.getParameters()) {
if (paramNode == null) {
break;
sb.append(" * @param {" + n.getJSType() + "} ");
sb.append(paramNode.getString());
sb.append("\n");
paramNode = paramNode.getNext();
if (fnNode.getBooleanProp(Node.IS_DISPATCHER)) {
import com.google.common.base.StringUtil;
(StringUtil.isEmpty(sourceName) ? "(unknown source)" : sourceName),
class Config {
boolean parseJsDocDocumentation) {
this.parseJsDocDocumentation = parseJsDocDocumentation;
boolean isIdeMode,
JSTypeRegistry typeRegistry,
initAnnotationNames();
if (isIdeMode) {
Config config = new Config(
typeRegistry, annotationNames, isIdeMode);
"input", string, true, registry,
"input", string,  true, registry,
this.unflowableVarNames.add(unflowableVar.getName());
if (var != null) {
escapedLocalVars.get(scope));
private final PriorityQueue<WarningsGuard> guards;
this.guards = new PriorityQueue<WarningsGuard>(
5,
new Comparator<WarningsGuard>() {
public int compare(WarningsGuard a, WarningsGuard b) {
return a.getPriority() - b.getPriority();
this.guards.add(guard);
import com.google.common.base.Join;
out.println("\nLoop " + i + ":\n" + Join.join("\n", loop));
import com.google.common.base.Join;
computeRelatedTypes(p.type);
return !getRelated(prop.type).intersects(typesInSet);
typesRelatedToSet.or(getRelated(prop.type));
getRelatedTypesOnNonUnion(alt, relatedTypes);
getRelatedTypesOnNonUnion(type, relatedTypes);
private void getRelatedTypesOnNonUnion(
if (relatedBitsets.containsKey(type)) {
relatedTypes.or(relatedBitsets.get(type));
throw new RuntimeException("Related types should have been computed for"
+ "type: " + type + " but have not been.");
JSType type;
if (type == null) {
type = newType;
type = type.getLeastSupertype(newType);
typesSet.set(getIntForType(newType));
return Join.join(" && ", types);
import com.google.common.base.Join;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;
import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;
pseudoName = Join.join("_", allMergedNames);
import com.google.common.base.Join;
return "(" + Join.join(",", names) + ")";
import com.google.common.base.Join;
out.append(Join.join(", ", refersTo));
out.append(Join.join(", ", referencedBy));
import com.google.common.base.Join;
import javax.annotation.Nullable;
n.setString(Join.join("-", parts));
String propName = lvalueNode.getLastChild().getString();
JSType propType = ownerType.getPropertyType(propName);
if (propType instanceof FunctionType) {
functionType =
new FunctionTypeBuilder(
name, compiler, errorRoot, sourceName, scope)
.setSourceNode(fnRoot)
.inferFromOverriddenFunction(
(FunctionType) propType, parametersNode)
.inferThisType(info, owner)
.buildAndRegister();
Iterable<ObjectType> getCtorImplementedInterfaces() {
Iterable<ObjectType> getCtorImplementedInterfaces() {
Iterable<ObjectType> getCtorImplementedInterfaces() {
Iterable<ObjectType> getCtorImplementedInterfaces() {
import com.google.common.base.Join;
"Errors: \n" + Join.join("\n", compiler.getErrors()) +
"Warnings: \n" + Join.join("\n", compiler.getWarnings()),
import com.google.common.base.Join;
Join.join("\n", compiler.getErrors()), root != null);
"Unexpected error(s): " + Join.join("\n", compiler.getErrors()),
Join.join("\n", stErrors),
"Unexpected warning(s): " + Join.join("\n", aggregateWarnings),
assertEquals(Join.join("", expected), compiler.toSource(mainRoot));
Join.join("\n", compiler.getErrors()), root != null);
import com.google.common.base.Join;
return Join.join("\n", parts);
return Join.join(";", parts);
Join.join("",
import com.google.common.base.Join;
Join.join("\n", compiler.getErrors()), root != null);
import com.google.common.base.Join;
Join.join(", ", compiler.getErrors()), 0, compiler.getErrorCount());
"unexpected warning(s) : " + Join.join(", ", compiler.getWarnings()),
fail("unexpected error(s):\n" + Join.join("\n", errors));
fail("unexpected warnings(s):\n" + Join.join("\n", warnings));
Join.join(", ", compiler.getErrors()), 0, compiler.getErrorCount());
import com.google.common.base.Join;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.Node;
Join.join(", ", compiler.getErrors()), 0, compiler.getErrorCount());
List<NamedPass> mixedupPasses = Lists.newArrayList();
Random random = new Random();
while (myPasses.size() > 0) {
mixedupPasses.add(
myPasses.remove(random.nextInt(myPasses.size())));
myPasses.addAll(mixedupPasses);
(!objectType.isInstanceType() || var.isExtern())) {
(isExtern || !ownerType.isInstanceType())) {
CodeGenerator(CodeConsumer consumer, Charset outputCharset) {
this(consumer, null);
sourceMap, outputCharset);
Charset outputCharset) {
: new CodeGenerator(cp, outputCharset);
if (root == null) {
NodeTraversal.traverse(compiler, root, renamer);
super(consumer, outputCharset);
assertTrue(conv.isVarArgsParameter(args.getLastChild()));
assertTrue(conv.isVarArgsParameter(optArgs.getLastChild()));
assertTrue(conv.isOptionalParameter(args.getFirstChild()));
assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));
Node mainRootClone = mainRoot.cloneTree();
normalize.process(externsRoot, mainRootClone);
assertFalse(ALL_TYPE.matchesObjectContext());
protected JSType caseTopType(JSType topType) {
return topType;
import java.io.FileReader;
import java.text.ParseException;
private FunctionNames functionNames_;
private VariableMap variableMap_;
private VariableMap propertyMap_;
private VariableMap anonFunctionNameMap_;
public static final DiagnosticType READ_ERROR = DiagnosticType.error(
"JSC_READ_ERROR", "Cannot read: {0}");
private static final DiagnosticType INPUT_MAP_PROP_PARSE =
DiagnosticType.error("JSC_INPUT_MAP_PROP_PARSE",
"Input property map parse error: {0}");
private static final DiagnosticType INPUT_VAR_PROP_PARSE =
DiagnosticType.error("JSC_INPUT_MAP_VAR_PARSE",
"Input variable map parse error: {0}");
nameAnonymousFunctions(options_.anonymousFunctionNaming);
if (options_.instrumentationTemplate != null ||
options_.recordFunctionInformation) {
computeFunctionNames();
private void aliasStrings(Set<String> aliasableStrings,
boolean aliasAllStrings,
String aliasStringsBlacklist,
boolean outputStringUsage) {
logger_.info("Aliasing strings");
startPass("aliasStrings");
AliasStrings aliasStrings = new AliasStrings(
this,
getModuleGraph(),
aliasAllStrings ? null : aliasableStrings,
aliasStringsBlacklist,
outputStringUsage);
process(aliasStrings);
endPass();
private void aliasKeywords() {
logger_.info("Aliasing true/false/null");
startPass("aliasKeywords");
AliasKeywords aliasKeywords = new AliasKeywords(this);
process(aliasKeywords);
endPass();
variableMap_, propertyMap_, anonFunctionNameMap_,
functionInformationMap_, sourceMap_, externExports_,
getPassConfig().getCssNames());
if (options_.flowSensitiveInlineVariables) {
flowSensitiveInlineVariables();
if (options_.collapseAnonymousFunctions) {
collapseAnonymousFunctions();
if (options_.moveFunctionDeclarations) {
moveFunctionDeclarations();
if (options_.anonymousFunctionNaming ==
AnonymousFunctionNamingPolicy.MAPPED) {
nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);
if (options_.extractPrototypeMemberDeclarations &&
(options_.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&
options_.propertyRenaming !=
PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {
extractPrototypeMemberDeclarations();
if (options_.coalesceVariableNames) {
coalesceVariableNames();
VariableMap prevPropertyMap = null;
if (options_.inputPropertyMapSerialized != null) {
try {
prevPropertyMap =
VariableMap.fromBytes(options_.inputPropertyMapSerialized);
report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));
if (options_.ambiguateProperties && (options_.propertyRenaming
== PropertyRenamingPolicy.ALL_UNQUOTED)) {
ambiguateProperties(options_.anonymousFunctionNaming
.getReservedCharacters());
switch (options_.propertyRenaming) {
case HEURISTIC:
renamePrototypes(false,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
case AGGRESSIVE_HEURISTIC:
renamePrototypes(true,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
case ALL_UNQUOTED:
renameProperties(options_.generatePseudoNames,
options_.anonymousFunctionNaming,
prevPropertyMap);
break;
if (options_.convertToDottedProperties) {
convertToDottedProperties();
if (options_.rewriteFunctionExpressions) {
rewriteFunctionExpressions();
if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {
aliasStrings(options_.aliasableStrings,
options_.aliasAllStrings,
options_.aliasStringsBlacklist,
options_.outputJsStringUsage);
if (options_.aliasExternals) {
aliasExternals();
if (options_.aliasKeywords) {
aliasKeywords();
if (options_.collapseVariableDeclarations) {
collapseVariableDeclarations();
denormalize();
if (options_.instrumentationTemplate != null) {
instrumentFunctions();
if (options_.variableRenaming != VariableRenamingPolicy.ALL) {
invertContextualRenaming();
if (options_.variableRenaming != VariableRenamingPolicy.OFF) {
VariableMap prevVariableMap = null;
if (options_.inputVariableMapSerialized != null) {
try {
prevVariableMap =
VariableMap.fromBytes(options_.inputVariableMapSerialized);
report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));
renameVars(options_.renamePrefix,
options_.variableRenaming == VariableRenamingPolicy.LOCAL,
options_.anonymousFunctionNaming,
options_.generatePseudoNames,
prevVariableMap);
if (options_.processObjectPropertyString) {
objectPropertyStringPostprocess();
if (options_.labelRenaming) {
renameLabels();
if (options_.anonymousFunctionNaming ==
AnonymousFunctionNamingPolicy.UNMAPPED) {
nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);
if (options_.checkSymbols) {
sanityCheckVars();
void sanityCheckVars() {
logger_.info("Checking for undefined vars");
startPass("sanityCheckVars");
VarCheck v = new VarCheck(this, true);
process(v);
endPass();
void computeFunctionNames() {
logger_.info("Computing fully-qualified function names and ids");
startPass("computeFunctionNames");
functionNames_ = new FunctionNames(this);
process(functionNames_);
endPass();
void flowSensitiveInlineVariables() {
logger_.info("Flow Sensitive Inline Variables");
startPass("flowSensitiveInlineVariables");
process(new FlowSensitiveInlineVariables(this));
endPass();
void coalesceVariableNames() {
logger_.info("Coalesce Variable Names");
startPass("coalesceVariableNames");
process(new CoalesceVariableNames(this));
endPass();
void collapseVariableDeclarations() {
logger_.info("Collapsing variable declarations");
startPass("collapseVariableDeclarations");
process(new CollapseVariableDeclarations(this));
setUnnormalized();
endPass();
void extractPrototypeMemberDeclarations() {
logger_.info("Extracting Common Prototype Member Declarations");
startPass("extractPrototypeMemberDeclarations");
process(new ExtractPrototypeMemberDeclarations(this));
endPass();
void rewriteFunctionExpressions() {
logger_.info("Rewrite function expressions");
startPass("rewriteFunctionExpressions");
process(new FunctionRewriter(this));
endPass();
void collapseAnonymousFunctions() {
logger_.info("Collapsing anonymous functions");
startPass("collapseAnonymousFunctions");
process(new CollapseAnonymousFunctions(this));
endPass();
void moveFunctionDeclarations() {
logger_.info("Move function declarations");
startPass("moveFunctionDeclarations");
process(new MoveFunctionDeclarations(this));
endPass();
void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {
logger_.info("Naming anonymous functions");
startPass("nameAnonymousFunctions");
if (policy == AnonymousFunctionNamingPolicy.UNMAPPED) {
process(new NameAnonymousFunctions(this));
NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(this);
process(naf);
anonFunctionNameMap_ = naf.getFunctionMap();
endPass();
void aliasExternals() {
logger_.info("Creating alias functions for externals");
startPass("aliasExternals");
AliasExternals ae = new AliasExternals(this,
getModuleGraph(),
options_.unaliasableGlobals,
options_.aliasableGlobals);
process(ae);
endPass();
void objectPropertyStringPostprocess() {
logger_.info("goog.testing.ObjectPropertyString postprocess");
startPass("ObjectPropertyStringPostprocess");
process(new ObjectPropertyStringPostprocess(this));
endPass();
void ambiguateProperties(char[] reservedCharacters) {
logger_.info("Ambiguating properties");
startPass("ambiguateProperties");
process(new AmbiguateProperties(this, reservedCharacters));
endPass();
private void denormalize() {
logger_.info("Denormalizing");
startPass("denormalize");
process(new Denormalize(this));
setUnnormalized();
endPass();
void renameVars(String renamePrefix, boolean renameLocalVarsOnly,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
boolean generatePseudoNames,
VariableMap prevVariableMap) {
logger_.info("Renaming vars");
startPass("renameVars");
boolean preserveAnonymousFunctionNames =
anonFunctionNamePolicy != AnonymousFunctionNamingPolicy.OFF;
RenameVars rn = new RenameVars(
this, renamePrefix,
renameLocalVarsOnly, preserveAnonymousFunctionNames,
generatePseudoNames,
prevVariableMap,
anonFunctionNamePolicy.getReservedCharacters(),
getPassConfig().getExportedNames());
process(rn);
variableMap_ = rn.getVariableMap();
endPass();
void renameProperties(boolean generatePseudoNames,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
VariableMap prevPropertyMap) {
logger_.info("Renaming properties");
startPass("renameProperties");
RenameProperties rp = new RenameProperties(
this, generatePseudoNames, prevPropertyMap,
anonFunctionNamePolicy.getReservedCharacters());
process(rp);
propertyMap_ = rp.getPropertyMap();
endPass();
void invertContextualRenaming() {
logger_.info("Denormalizing local names");
startPass("invertNames");
process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));
endPass();
void renamePrototypes(boolean aggressive,
AnonymousFunctionNamingPolicy anonFunctionNamePolicy,
VariableMap prevPropertyMap) {
logger_.info("Renaming prototypes");
startPass("renamePrototypes");
RenamePrototypes rp = new RenamePrototypes(this, aggressive,
anonFunctionNamePolicy.getReservedCharacters(),
prevPropertyMap);
process(rp);
propertyMap_ = rp.getPropertyMap();
endPass();
void renameLabels() {
logger_.info("Renaming labels");
startPass("renameLabels");
RenameLabels rn = new RenameLabels(this);
process(rn);
endPass();
void convertToDottedProperties() {
logger_.info("Converting quoted property accesses to dot syntax");
startPass("convertToDottedProperties");
process(new ConvertToDottedProperties(this));
endPass();
void instrumentFunctions() {
logger_.info("Instrumenting functions");
startPass("instrumentFunctions");
try {
FileReader templateFile =
new FileReader(options_.instrumentationTemplate);
process(new InstrumentFunctions(this,
functionNames_,
options_.instrumentationTemplate,
options_.appNameStr,
templateFile));
report(JSError.make(READ_ERROR, options_.instrumentationTemplate));
endPass();
new RecordFunctionInformation(this, functionNames_);
return variableMap_;
return propertyMap_;
private FunctionNames functionNames;
state.functionNames = functionNames_;
functionNames_ = state.functionNames;
setExportedNames(pass.getExportedVariableNames());
Map<String, Integer> cssNames = null;
cssNames = Maps.newHashMap();
(new ReplaceCssNames(compiler, cssNames)).process(
setCssNames(cssNames);
compiler, getCrossModuleIdGenerator(),
private final DiagnosticType error;
compiler.report(JSError.make(error));
JSError.make(Compiler.READ_ERROR, sourceFile.getName()));
compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import java.util.Collections;
private Set<String> exportedNames = null;
private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =
new CrossModuleMethodMotion.IdGenerator();
private Map<String, Integer> cssNames = null;
Map<String, Integer> getCssNames() {
return cssNames == null ? null : Maps.newHashMap(cssNames);
Set<String> getExportedNames() {
return exportedNames == null ? null :
Collections.unmodifiableSet(exportedNames);
CrossModuleMethodMotion.IdGenerator getCrossModuleIdGenerator() {
return crossModuleIdGenerator;
void setCssNames(Map<String, Integer> newVal) {
cssNames = newVal == null ? null : Maps.newHashMap(newVal);
void setExportedNames(Set<String> newVal) {
exportedNames = newVal == null ? null : Sets.newHashSet(newVal);
State getIntermediateState() {
return new State(getCssNames(), getExportedNames(),
crossModuleIdGenerator);
void setIntermediateState(State state) {
setCssNames(state.cssNames);
setExportedNames(state.exportedNames);
crossModuleIdGenerator = state.crossModuleIdGenerator;
return delegate.getCssNames();
return delegate.getExportedNames();
delegate.setCssNames(newVal);
delegate.setExportedNames(newVal);
private final Map<String, Integer> cssNames;
private final Set<String> exportedNames;
private final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;
private State(Map<String, Integer> cssNames, Set<String> exportedNames,
CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator) {
Preconditions.checkState(variable != null);
assigns.add(new Assignment(variable, argTypes.get(i)));
allInstantiatedTypes.add(thisType);
ConcreteType thisType = inferConcreteType(scope, firstArgument);
ConcreteType ret;
private class MyScopeCreator implements ScopeCreator {
private final AbstractCompiler compiler;
private final TypedScopeCreator delegate;
MyScopeCreator(AbstractCompiler compiler) {
this.compiler = compiler;
this.delegate = new TypedScopeCreator(compiler);
public Scope createScope(Node root, Scope parent) {
Scope typedScope = delegate.createScope(root, parent);
TypeInference typeInference = new TypeInference(
compiler, computeCfg(root),
compiler.getReverseAbstractInterpreter(), typedScope);
typeInference.analyze();
return typedScope;
private ControlFlowGraph<Node> computeCfg(Node n) {
ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);
cfa.process(null, n);
return cfa.getCfg();
compiler, callback, new MyScopeCreator(compiler));
DiagnosticGroups.setWarningLevels(
options, AbstractCompilerRunner.FLAG_jscomp_error.get(),
CheckLevel.ERROR);
DiagnosticGroups.setWarningLevels(
options, AbstractCompilerRunner.FLAG_jscomp_warning.get(),
CheckLevel.WARNING);
DiagnosticGroups.setWarningLevels(
options, AbstractCompilerRunner.FLAG_jscomp_off.get(),
CheckLevel.OFF);
import com.google.common.collect.Multimaps;
Multimap<String, JSModule> fileRefs = Multimaps.newLinkedHashMultimap();
if (NodeUtil.isVar(var.getParentNode())) {
reachingDef.put(var, new Definition(var.scope.getRootNode()));
static final DiagnosticType AMBIGUOUS_FUNCTION_DECL =
DiagnosticType.warning("AMBIGUIOUS_FUNCTION_DECL",
"Conditional named functions have inconsistent behavior. Instead of" +
" 'function f(){}' use 'var f = function(){}'.");
if (NodeUtil.isFunctionDeclaration(parent)) {
if (!isHoistedFunction(parent)) {
t.report(n, AMBIGUOUS_FUNCTION_DECL);
boolean isHoistedFunction(Node fn) {
Preconditions.checkArgument(NodeUtil.isFunctionDeclaration(fn));
return fn.getParent().getType() == Token.SCRIPT
|| fn.getParent().getParent().getType() == Token.FUNCTION;
testSame("x = 3; var y; var y;");
Node externs = all.getFirstChild();
(new Normalize(compiler, false)).process(externs, n);
(new MakeDeclaredNamesUnique.UndoConstantRenaming(compiler)).process(
externs, n);
(MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(
externs, n);
public void testAmbiguousFunctionDeclarations() {
testSame("if (1) { function f(){}; }", VarCheck.AMBIGUOUS_FUNCTION_DECL);
testSame("{ function f(){}; }", VarCheck.AMBIGUOUS_FUNCTION_DECL);
testSame("a:function f(){};", VarCheck.AMBIGUOUS_FUNCTION_DECL);
testSame("function f(){}");
testSame("(function(){ function f(){} })");
new File(dirName).mkdirs();
if (aliasRefs.isWellDefined() && aliasRefs.isNeverReassigned()) {
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
if (parent.getFirstChild().getType() == Token.NAME) {
Node functionExpression = parent.getFirstChild();
decomposeSubExpressions(
functionExpression.getNext(), child, state);
if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {
state.sideEffects = true;
Node replacement = rewriteCallExpression(parent, state);
parent = replacement;
if (isSubexpressionMovable(expressionRoot, subExpression)) {
return DecompositionType.MOVABLE;
return DecompositionType.DECOMPOSABLE;
private boolean isSubexpressionMovable(
boolean callExpressionHasSideEffects = NodeUtil.mayHaveSideEffects(
subExpression);
return true;
return false;
if (parentType == Token.ASSIGN
&& parent.getFirstChild().getType() == Token.NAME) {
n, callExpressionHasSideEffects)) {
return false;
private boolean canBeSideEffected(Node n) {
return NodeUtil.has(
n, new SideEffected(this.knownConstants),
Predicates.<Node>alwaysTrue());
private static class SideEffected implements Predicate<Node> {
final Set<String> additionalConsts;
SideEffected(Set<String> additionalConsts) {
this.additionalConsts = additionalConsts;
public boolean apply(Node n) {
switch (n.getType()) {
case Token.CALL:
case Token.NEW:
case Token.NAME:
return !NodeUtil.isConstantName(n)
&& !additionalConsts.contains(n.getString());
default:
return false;
return canBeSideEffected(n);
private static boolean canBeSideEffected(Node n) {
switch (n.getType()) {
case Token.CALL:
if (!n.isNoSideEffectsCall()) {
return true;
break;
case Token.NEW:
return true;
case Token.NAME:
if (!NodeUtil.isConstantName(n)) {
return true;
break;
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (canBeSideEffected(c)) {
return true;
return false;
private final Set<Var> declaredConstants = Sets.newHashSet();
Predicates.<Var>or(
identifyConstants, Predicates.<Var>alwaysTrue()));
if (declaredConstants.contains(var)) {
return true;
if (!var.isConst()) {
return false;
if (var.getInitialValue() == null) {
return false;
if (!NodeUtil.isImmutableValue(var.getInitialValue())) {
return false;
declaredConstants.add(var);
return true;
referenceInfo.isNeverReassigned()) {
Reference declaration = referenceInfo.references.get(0);
Node value = declaration.getNameNode().getFirstChild();
if (declaration.getParent().getType() == Token.VAR &&
value != null && value.getType() == Token.NAME) {
inlineDeclaredConstant(v, referenceInfo.references);
inlineNonConstants(t.getScope(), v, referenceInfo);
private void inlineNonConstants(Scope scope,
if (referenceInfo.references.size() >= 2 &&
inlineWellDefinedVariable(v, referenceInfo.references);
Reference declaration = referenceInfo.references.get(0);
Reference reference = referenceInfo.references.get(1);
if (canInline(declaration, reference)) {
blacklistVarReferencesInTree(
declaration.getNameNode().getFirstChild(), scope);
inline(v, declaration, reference);
referenceInfo.isNeverReassigned()) {
inlineWellDefinedVariable(
candidate.alias, candidate.refInfo.references);
private void inline(Var v, Reference declaration, Reference reference) {
Node name = declaration.getNameNode();
Preconditions.checkState(name.getFirstChild() != null);
Node value = name.removeFirstChild();
inlineValue(v, reference, value);
private void inlineWellDefinedVariable(Var v,
inlineValue(v, refSet.get(i),
decl.getNameNode().getFirstChild().cloneTree());
private void inlineDeclaredConstant(Var v, List<Reference> refSet) {
inlineValue(v, r, v.getInitialValue().cloneTree());
ref.getParent().replaceChild(ref.getNameNode(), value);
List<Reference> refs) {
return var.getInitialValue().getType() != Token.STRING ||
isStringWorthInlining(var, refs);
private boolean canInline(Reference declaration, Reference reference) {
if (!isValidDeclaration(declaration) || !isValidReference(reference)) {
if (declaration.getBasicBlock() != reference.getBasicBlock()) {
if (declaration.getNameNode().getFirstChild().getType() == Token.GETPROP
&& reference.getParent().getType() == Token.CALL) {
return canMoveAggressively(declaration) ||
canMoveModerately(declaration, reference);
private boolean canMoveAggressively(Reference declaration) {
Node value = declaration.getNameNode().getFirstChild();
private boolean canMoveModerately(Reference declaration,
Iterator<Node> it = new NodeIterators.LocalVarMotion(
declaration.getNameNode(),
declaration.getParent(),
declaration.getGrandparent());
return declaration.isDeclaration() &&
declaration.getNameNode().getFirstChild() != null;
if (!isValidDeclaration(refSet.get(0))) {
for (int i = 1; i < refSet.size(); i++) {
Node value = refSet.get(0).getNameNode().getFirstChild();
LocalVarMotion(Node ... ancestors) {
Preconditions.checkArgument(ancestors.length >= 2);
Preconditions.checkArgument(ancestors[0].getType() == Token.NAME);
Preconditions.checkArgument(ancestors[1].getType() == Token.VAR);
this.iterator = new FunctionlessLocalScope(ancestors);
Node nameNode = ancestors[0];
Node valueNode = nameNode.getFirstChild();
private static final boolean ALLOW_ASSIGNMENT_SPLITTING = false;
if (ALLOW_ASSIGNMENT_SPLITTING) {
splitAssignments(n);
private void splitAssignments(Node n) {
for (Node next, c = n.getFirstChild(); c != null; c = next) {
next = c.getNext();
if (NodeUtil.isExpressionNode(c)) {
Node expression = c;
while (isCompoundAssignment(expression.getFirstChild())) {
Node assign = expression.getFirstChild();
Node rhs = assign.getLastChild();
Node nameNode = rhs.getFirstChild();
if (NodeUtil.mayEffectMutableState(nameNode)) {
break;
assign.removeChild(rhs);
assign.addChildToBack(nameNode.cloneTree());
Node newChild = NodeUtil.newExpr(rhs);
n.addChildBefore(newChild, expression);
expression = newChild;  // next iteration.
compiler.reportCodeChange();
private static boolean isCompoundAssignment(Node n) {
return (NodeUtil.isAssignmentOp(n)
&& NodeUtil.isAssignmentOp(n.getLastChild()));
Reference decl = references.get(0);
if (!decl.isInitializingDeclaration()) {
BasicBlock declBlock = decl.getBasicBlock();
if (!declBlock.provablyExecutesBefore(
boolean isNeverReassigned() {
for (int i = 1; i < size; i++) {
if (references.get(i).isLvalue()) {
return false;
return true;
scope.declare(varName, nameNode,
public void testExposeExpression12() {
helperExposeExpression(
"if (goo.a(1, foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1.a;" +
"if (temp_const_0.call(temp_const_1, 1, foo()));");
public void testExposeExpression13() {
helperExposeExpression(
"if (goo['a'](foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1['a'];" +
"if (temp_const_0.call(temp_const_1, foo()));");
public void testExposeExpression14() {
helperExposeExpression(
"z:if (goo.a(1, foo()));",
"foo",
"var temp_const_1 = goo;" +
"var temp_const_0 = temp_const_1.a;" +
"z:if (temp_const_0.call(temp_const_1, 1, foo()));");
testSame("var AA; AA=1");
testSame("/** @const */var aa; aa=1;");
public void testDoNotExitConditional() {
testSame("var x = {};\nvar y = x.a;\nx.a = 1;\nvar z = y;");
Iterator<Node> moveIt = new LocalVarMotion(
currentAncestors.toArray(new Node[currentAncestors.size()]));
public void disable_testSplitAssign() {
testSame("a = 0");
test("a = b = 0",
"b = 0; a = b");
test("a = b = c = foo()",
"c = foo(); b = c; a = b");
test("a.a = a.b = 0",
"a.b = 0; a.a = a.b");
test("a[0] = a[1] = 0",
"a[1] = 0; a[0] = a[1]");
testSame("a[x++] = a[x++] = 0");
testSame("a[getNext()] = a[getNext()] = 0");
testSame("for(;a=b=0;c=d=0);");
test("a *= b -= c += foo()",
"c += foo(); b -= c; a *= b");
checkSynthesizedExtern("function(x){}", "");
checkSynthesizedExtern("function(){x}", "var x");
checkSynthesizedExtern("function(){function() {x}}", "var x");
public boolean allowsUndeclaredVariables() {
return true;
NodeUtil.isRValue(name);
public boolean allowsUndeclaredVariables();
options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,
CheckLevel.OFF);
options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,
CheckLevel.OFF);
VarCheck v = new VarCheck(this, false);
this, renamePrefix, renameLocalVarsOnly, prevVariableMap,
public boolean allowBrokenClosureRequires;
allowBrokenClosureRequires = false;
public boolean allowsUndeclaredVariables() {
return true;
if (options.checkSymbols) {
checks.add(checkVars);
final ProcessClosurePrimitives pass =
options.brokenClosureRequiresLevel != null ?
new ProcessClosurePrimitives(
compiler,
options.brokenClosureRequiresLevel,
options.rewriteNewDateGoogNow) :
new ProcessClosurePrimitives(
compiler,
options.allowBrokenClosureRequires,
options.rewriteNewDateGoogNow);
Node name1 = thenAssign.getFirstChild();
if (name2.hasChildren() && name1.getString().equals(name2.getString())) {
&& NodeUtil.isRValue(callNode)
public boolean allowsUndeclaredVariables() {
return false;
return NodeUtil.isLiteralValue(
declaration.getNameNode().getFirstChild());
traverseBranch(fnName, n);
static boolean isLValue(Node n) {
return getRValue(n) != null;
static Node getRValue(Node n) {
Node current = n;
Node ancestor;
while ((ancestor = current.getParent()) != null) {
switch (ancestor.getType()) {
case Token.EXPR_RESULT:
case Token.GETPROP:
break;
case Token.ASSIGN:
if (ancestor.getFirstChild() == current) {
return ancestor.getLastChild();
break;
case Token.SCRIPT:
case Token.FUNCTION:
case Token.LP:
case Token.BLOCK:
return null;
case Token.VAR:
if (n.hasChildren()) {
return n.getFirstChild();
return null;
default:
return null;
current = ancestor;
return null;
static boolean isRValue(Node n) {
Node current = n;
Node parent;
while ((parent = current.getParent()) != null) {
switch (parent.getType()) {
case Token.EXPR_RESULT:
case Token.GETPROP:
break;
case Token.ASSIGN:
if (parent.getFirstChild() != current) {
return true;
break;
case Token.SCRIPT:
case Token.FUNCTION:
case Token.LP:
case Token.BLOCK:
case Token.VAR:
return false;
default:
return true;
current = parent;
return false;
ProcessClosurePrimitives(AbstractCompiler compiler,
boolean allowBrokenRequires,
boolean rewriteNewDateGoogNow) {
this(compiler,
allowBrokenRequires ? CheckLevel.WARNING : CheckLevel.ERROR,
rewriteNewDateGoogNow);
if (n.getType() == Token.FUNCTION) {
String fnName = n.getFirstChild().getString();
Scope s = t.getScope();
if (!fnName.isEmpty() && s.getVar(fnName).scope == s) {
addReference(t, s.getVar(fnName),
Reference.newBleedingFunction(t, parent, n));
RenameVars(AbstractCompiler compiler, String prefix,
boolean localRenamingOnly, VariableMap prevUsedRenameMap,
private final String[] checkWarningsOnlyForPath;
Preconditions.checkArgument(checkWarningsOnlyForPath != null);
this.checkWarningsOnlyForPath = new String[] { checkWarningsOnlyForPath };
Preconditions.checkArgument(checkWarningsOnlyForPath != null);
this.checkWarningsOnlyForPath = checkWarningsOnlyForPath;
final String filePath = error.sourceName;
if (error.level != CheckLevel.ERROR && filePath != null) {
boolean checkMe = false;
for (String checkedPath : checkWarningsOnlyForPath) {
checkMe |= filePath.contains(checkedPath);
if (!checkMe) {
JSType delegateType = typeRegistry.getType(
codingConvention.getDelegateSuperclassName());
private final boolean nonStrictModuleChecks;
this(compiler, true);
VarCheck(AbstractCompiler compiler, boolean nonStrictModuleChecks) {
this.nonStrictModuleChecks = nonStrictModuleChecks;
Node nameNode = Node.newString(Token.NAME, varName);
getSynthesizedExternsRoot().addChildToBack(
new Node(Token.VAR, nameNode));
scope.declare(varName, nameNode,
null, getSynthesizedExternsInput());
if (nonStrictModuleChecks && scope.isGlobal()) {
return new ProcessClosurePrimitives(compiler, false, true);
return new RenameVars(compiler, prefix, true, null, null, null);
localRenamingOnly, previouslyUsedMap, null, null);
new ProcessClosurePrimitives(compiler, true, true);
false, previouslyUsedMap, null,
checkSourceMap("function(foo, bar) { foo = foo + bar + 2; return foo; }",
"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9," +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,8,\"\"]\n" +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,9,\"foo\"]\n" +
"[\"testcode\",1,14,\"bar\"]\n" +
"[\"testcode\",1,19]\n" +
"[\"testcode\",1,21,\"foo\"]\n" +
"[\"testcode\",1,27,\"foo\"]\n" +
"[\"testcode\",1,33,\"bar\"]\n" +
"[\"testcode\",1,39]\n" +
"[\"testcode\",1,42]\n" +
"[\"testcode\",1,49,\"foo\"]\n");
checkSourceMap("function(foo, bar) {\r\n\n\n\nfoo = foo + bar + foo;" +
"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9," +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,8,\"\"]\n" +
"[\"testcode\",1,8]\n" +
"[\"testcode\",1,9,\"foo\"]\n" +
"[\"testcode\",1,14,\"bar\"]\n" +
"[\"testcode\",1,19]\n" +
private boolean nonStrictModuleChecks = true;
nonStrictModuleChecks = true;
return new VarCheck(compiler, nonStrictModuleChecks);
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
nonStrictModuleChecks = false;
(new VarCheck(compiler)).process(externs, root);
(new VariableTestCheck(compiler)).process(externs, root);
