this.typeArguments = typeArguments.clone();return performStateCheck(1);TimeZone.setDefault(zone);
dateTimeParser.setTimeZone(zone);
date3 = dateTimeParser.parse("March 30, 2003 05:30:45.000");
date4 = dateTimeParser.parse("March 30, 2003 01:10:00.000");
date5 = dateTimeParser.parse("March 30, 2003 01:40:00.000");
date6 = dateTimeParser.parse("March 30, 2003 02:10:00.000");
date7 = dateTimeParser.parse("March 30, 2003 02:40:00.000");
date8 = dateTimeParser.parse("October 26, 2003 05:30:45.000");
dateTimeParser.setTimeZone(defaultZone);
TimeZone.setDefault(defaultZone);
TimeZone.setDefault(zone);
cal3 = Calendar.getInstance();
cal3.setTime(date3);
cal4 = Calendar.getInstance();
cal4.setTime(date4);
cal5 = Calendar.getInstance();
cal5.setTime(date5);
cal6 = Calendar.getInstance();
cal6.setTime(date6);
cal7 = Calendar.getInstance();
cal7.setTime(date7);
cal8 = Calendar.getInstance();
cal8.setTime(date8);
TimeZone.setDefault(defaultZone);
TimeZone.setDefault(zone);
dateTimeParser.setTimeZone(zone);
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round(date4, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round((Object) cal4, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round(date5, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round((Object) cal5, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round(date6, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round((Object) cal6, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round(date7, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.round((Object) cal7, Calendar.DATE));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 01:00:00.000"),
DateUtils.round(date4, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 01:00:00.000"),
DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.round(date5, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.round(date6, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.round(date7, Calendar.HOUR_OF_DAY));
assertEquals("round MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY));
TimeZone.setDefault(defaultZone);
dateTimeParser.setTimeZone(defaultZone);
TimeZone.setDefault(defaultZone);
dateTimeParser.setTimeZone(defaultZone);
TimeZone.setDefault(zone);
dateTimeParser.setTimeZone(zone);
assertEquals("truncate MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.truncate(date3, Calendar.DATE));
assertEquals("truncate MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 00:00:00.000"),
DateUtils.truncate((Object) cal3, Calendar.DATE));
assertEquals("truncate MET date across DST change-over",
dateTimeParser.parse("October 26, 2003 00:00:00.000"),
DateUtils.truncate(date8, Calendar.DATE));
assertEquals("truncate MET date across DST change-over",
dateTimeParser.parse("October 26, 2003 00:00:00.000"),
DateUtils.truncate((Object) cal8, Calendar.DATE));
TimeZone.setDefault(defaultZone);
dateTimeParser.setTimeZone(defaultZone);
final TimeZone MST_MDT = TimeZone.getTimeZone("MST7MDT");
TimeZone.setDefault(MST_MDT);
final DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS z");
format.setTimeZone(MST_MDT);
final Date oct31_01MDT = new Date(1099206000000L);
final Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour
final Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes
final Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds
final Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds
assertEquals("Check 00:00:00.000", "2004-10-31 00:00:00.000 MDT", format.format(oct31MDT));
assertEquals("Check 01:00:00.000", "2004-10-31 01:00:00.000 MDT", format.format(oct31_01MDT));
assertEquals("Check 01:02:00.000", "2004-10-31 01:02:00.000 MDT", format.format(oct31_01_02MDT));
assertEquals("Check 01:02:03.000", "2004-10-31 01:02:03.000 MDT", format.format(oct31_01_02_03MDT));
assertEquals("Check 01:02:03.004", "2004-10-31 01:02:03.004 MDT", format.format(oct31_01_02_03_04MDT));
final Calendar gval = Calendar.getInstance();
gval.setTime(new Date(oct31_01MDT.getTime()));
gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value
assertEquals("Demonstrate Problem", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);
assertEquals("Truncate Calendar.MILLISECOND",
oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));
assertEquals("Truncate Calendar.SECOND",
oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));
assertEquals("Truncate Calendar.MINUTE",
oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));
assertEquals("Truncate Calendar.HOUR_OF_DAY",
oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));
assertEquals("Truncate Calendar.HOUR",
oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));
assertEquals("Truncate Calendar.DATE",
oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));
assertEquals("Round Calendar.MILLISECOND",
oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));
assertEquals("Round Calendar.SECOND",
oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));
assertEquals("Round Calendar.MINUTE",
oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));
assertEquals("Round Calendar.HOUR_OF_DAY",
oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));
assertEquals("Round Calendar.HOUR",
oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));
assertEquals("Round Calendar.DATE",
oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));
TimeZone.setDefault(defaultZone);
TimeZone.setDefault(zone);
dateTimeParser.setTimeZone(zone);
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling(date4, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling((Object) cal4, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling(date5, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling((Object) cal5, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling(date6, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling((Object) cal6, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling(date7, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 31, 2003 00:00:00.000"),
DateUtils.ceiling((Object) cal7, Calendar.DATE));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.ceiling(date4, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.ceiling((Object) cal4, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.ceiling(date5, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 03:00:00.000"),
DateUtils.ceiling((Object) cal5, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.ceiling(date6, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.ceiling((Object) cal6, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.ceiling(date7, Calendar.HOUR_OF_DAY));
assertEquals("ceiling MET date across DST change-over",
dateTimeParser.parse("March 30, 2003 04:00:00.000"),
DateUtils.ceiling((Object) cal7, Calendar.HOUR_OF_DAY));
TimeZone.setDefault(defaultZone);
dateTimeParser.setTimeZone(defaultZone);System.out.println("Can't test IS_JAVA value: "+javaVersion);public void testIsJavaVersionAtLeat() throws Exception {final List<Object> list = new ArrayList<>();public static final String ISO_8859_1 = "ISO-8859-1";
public static final String US_ASCII = "US-ASCII";
public static final String UTF_16 = "UTF-16";
public static final String UTF_16BE = "UTF-16BE";
public static final String UTF_16LE = "UTF-16LE";
public static final String UTF_8 = "UTF-8";super.appendDetail(buffer, fieldName, array);
import static org.junit.Assert.assertEquals;classes.add(cls);final boolean outputStatics, boolean excludeNulls, final Class<? super T> reflectUpToClass) {
return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics, excludeNulls)
if(!excludeNullValues || fieldValue != null){
import static org.junit.Assert.*;
class TestFixture{
public TestFixture(Integer a, String b){public void testToPrimitive_int() {
final Integer[] b = null;
assertEquals(null, ArrayUtils.toPrimitive(b));
assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0]));
assertTrue(Arrays.equals(
new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), 
Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)}))
);
try {
ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null});
fail();
public void testToPrimitive_int_int() {
final Long[] l = null;
assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE));
assertSame(ArrayUtils.EMPTY_INT_ARRAY, 
ArrayUtils.toPrimitive(new Integer[0], 1));
assertTrue(Arrays.equals(
new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), 
Integer.valueOf(Integer.MAX_VALUE), Integer.valueOf(9999999)},1)));
assertTrue(Arrays.equals(
new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), 
null, Integer.valueOf(9999999)}, Integer.MAX_VALUE))
);
public void testToPrimitive_long() {
final Long[] b = null;
assertEquals(null, ArrayUtils.toPrimitive(b));
assertSame(ArrayUtils.EMPTY_LONG_ARRAY, 
ArrayUtils.toPrimitive(new Long[0]));
assertTrue(Arrays.equals(
new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), 
Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)}))
);
try {
ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null});
fail();
public void testToPrimitive_long_long() {
final Long[] l = null;
assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE));
assertSame(ArrayUtils.EMPTY_LONG_ARRAY, 
ArrayUtils.toPrimitive(new Long[0], 1));
assertTrue(Arrays.equals(
new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), 
Long.valueOf(Long.MAX_VALUE), Long.valueOf(9999999)},1)));
assertTrue(Arrays.equals(
new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), 
null, Long.valueOf(9999999)}, Long.MAX_VALUE))
);
public void testToPrimitive_float() {
final Float[] b = null;
assertEquals(null, ArrayUtils.toPrimitive(b));
assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, 
ArrayUtils.toPrimitive(new Float[0]));
assertTrue(Arrays.equals(
new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), 
Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)}))
);
try {
ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null});
fail();
public void testToPrimitive_float_float() {
final Float[] l = null;
assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE));
assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, 
ArrayUtils.toPrimitive(new Float[0], 1));
assertTrue(Arrays.equals(
new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), 
Float.valueOf(Float.MAX_VALUE), Float.valueOf(9999999)},1)));
assertTrue(Arrays.equals(
new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), 
null, Float.valueOf(9999999)}, Float.MAX_VALUE))
);
public void testToPrimitive_double() {
final Double[] b = null;
assertEquals(null, ArrayUtils.toPrimitive(b));
assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, 
ArrayUtils.toPrimitive(new Double[0]));
assertTrue(Arrays.equals(
new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), 
Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)}))
);
try {
ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null});
fail();
public void testToPrimitive_double_double() {
final Double[] l = null;
assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE));
assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, 
ArrayUtils.toPrimitive(new Double[0], 1));
assertTrue(Arrays.equals(
new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), 
Double.valueOf(Double.MAX_VALUE), Double.valueOf(9999999)},1)));
assertTrue(Arrays.equals(
new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},
ArrayUtils.toPrimitive(new Double[] {Double.valueOf(Double.MIN_VALUE), 
null, Double.valueOf(9999999)}, Double.MAX_VALUE))
);if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
for (int i = start; i < sz; i++) {
if (cs.charAt(i) == searchChar) {
return i;
if (searchChar <= Character.MAX_CODE_POINT) {
int ind = 0;
char[] chars = Character.toChars(searchChar);
for (int i = start; i < sz - 1; i++) {
char high = cs.charAt(i);
char low = cs.charAt(i + 1);
if (high == chars[0] && low == chars[1]) {
return ind;
i++;
ind++;
if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
for (int i = start; i >= 0; --i) {
if (cs.charAt(i) == searchChar) {
return i;
if (searchChar <= Character.MAX_CODE_POINT) {
char[] chars = Character.toChars(searchChar);
if (start == sz - 1) {
return NOT_FOUND;
int maxInd = -1;
int ind = 0;
for (int i = 0; i < cs.length() - 1; i++) {
char high = cs.charAt(i);
char low = cs.charAt(i + 1);
if (chars[0] == high && chars[1] == low) {
maxInd = ind;
i++;
i++; //skip over one
ind++;
if (maxInd >= start) {
return maxInd;
final int CODE_POINT = 0x2070E;
StringBuilder builder = new StringBuilder();
builder.appendCodePoint(CODE_POINT);
assertEquals(0, StringUtils.indexOf(builder, CODE_POINT, 0));
builder.appendCodePoint(CODE_POINT);
assertEquals(1, StringUtils.indexOf(builder, CODE_POINT, 1));
char[] tmp = {(char) 55361};
builder = new StringBuilder();
builder.append(tmp);
assertEquals(-1, StringUtils.indexOf(builder, CODE_POINT, 0));
final int CODE_POINT = 0x2070E;
StringBuilder builder = new StringBuilder();
builder.appendCodePoint(CODE_POINT);
assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT, 0));
builder.appendCodePoint(CODE_POINT);
assertEquals(1, StringUtils.lastIndexOf(builder, CODE_POINT, 0));
assertEquals(1, StringUtils.lastIndexOf(builder, CODE_POINT, 1));
builder.append("aaaaa");
assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT, 4));
char[] tmp = {(char) 55361};
builder = new StringBuilder();
builder.append(tmp);
assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT, 0));
builder.appendCodePoint(CODE_POINT);
assertEquals(1, StringUtils.lastIndexOf(builder, CODE_POINT, 0 ));
assertEquals(1, StringUtils.lastIndexOf(builder, CODE_POINT, 1 ));if(searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT){
for (int i = start; i < sz; i++) {
if (cs.charAt(i) == searchChar) {
return i;
if(searchChar <= Character.MAX_CODE_POINT){
char[] chars = Character.toChars(searchChar);
for(int i = start; i < sz; i++){
if(cs.charAt(i) == chars[0]){
if(i+1 == sz){
break;
if(cs.charAt(i+1) == chars[1]){
return i;
if(searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT){
for (int i = start; i >= 0; --i) {
if (cs.charAt(i) == searchChar) {
return i;
if(searchChar <= Character.MAX_CODE_POINT){
char[] chars = Character.toChars(searchChar);
for(int i = start; i >= 0; --i){
if(cs.charAt(i) == chars[0]){
if(i + 1 == cs.length()){
break;
if(cs.charAt(i+1) == chars[1]){
return i;
public void testLastIndexOfSupplementaryCharacters(){
final int CODE_POINT = 0x2070E;
StringBuilder builder = new StringBuilder();
builder.appendCodePoint(CODE_POINT);
assertEquals(0, CharSequenceUtils.lastIndexOf(builder, CODE_POINT, 0));
char[] tmp = {(char) 55361};
builder = new StringBuilder();
builder.append(tmp);
assertEquals(-1, CharSequenceUtils.lastIndexOf(builder, CODE_POINT, 0));
public void testIndexOfSupplementaryCharacters(){
final int CODE_POINT = 0x2070E;
StringBuilder builder = new StringBuilder();
builder.appendCodePoint(CODE_POINT);
assertEquals(0, CharSequenceUtils.indexOf(builder, CODE_POINT, 0));
assertEquals(0, CharSequenceUtils.lastIndexOf(builder, CODE_POINT, 0));
assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT, 0));
assertEquals(0, StringUtils.indexOf(builder, CODE_POINT, 0));
assertEquals(0, StringUtils.indexOf(builder,  CODE_POINT));
assertEquals(0, StringUtils.lastIndexOf(builder, CODE_POINT));
assertTrue (StringUtils.contains(builder, CODE_POINT));
char[] tmp = {(char) 55361};
builder = new StringBuilder();
builder.append(tmp);
assertEquals(-1, CharSequenceUtils.indexOf(builder, CODE_POINT, 0));
assertEquals(-1, CharSequenceUtils.lastIndexOf(builder, CODE_POINT, 0));
assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT, 0));
assertEquals(-1, StringUtils.indexOf(builder, CODE_POINT, 0));
assertEquals(-1, StringUtils.indexOf(builder,  CODE_POINT));
assertEquals(-1, StringUtils.lastIndexOf(builder, CODE_POINT));
assertFalse (StringUtils.contains(builder, CODE_POINT));assertFalse(CharUtils.isAscii(CHAR_COPY));end = Integer.MAX_VALUE;
final char[] buffer = new char[count];
char ch;
ch = (char) (random.nextInt(gap) + start);
ch = chars[random.nextInt(gap) + start];
if (letters && Character.isLetter(ch)
|| numbers && Character.isDigit(ch)
|| !letters && !numbers) {
if(ch >= 56320 && ch <= 57343) {
if(count == 0) {
count++;
buffer[count] = ch;
count--;
buffer[count] = (char) (55296 + random.nextInt(128));
if(count == 0) {
count++;
buffer[count] = (char) (56320 + random.nextInt(128));
count--;
buffer[count] = ch;
count++;
buffer[count] = ch;
return new String(buffer);spaceToWrapAt = matcher.start();
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;if (b.compareTo(BigDecimal.valueOf(d)) == 0) {public void testParseOffset() throws ParseException {final String javaVersion = System.getProperty("java.specification.name");public static <T> void greaterObj(final Comparable<T> value, final T min) {
greaterObj(value, min, DEFAULT_GREATER_EX_MESSAGE, value, min);
public static <T> void greaterObj(final Comparable<T> value, final T min, final String message, final Object... values) {
public static <T> void greaterOrEqualObj(final Comparable<T> value, final T min) {
greaterOrEqualObj(value, min, DEFAULT_GREATER_OR_EQUAL_EX_MESSAGE, value, min);
public static <T> void greaterOrEqualObj(final Comparable<T> value, final T min, final String message, final Object... values) {
public static <T> void smallerObj(final Comparable<T> value, final T max) {
smallerObj(value, max, DEFAULT_SMALLER_EX_MESSAGE, value, max);
public static <T> void smallerObj(final Comparable<T> value, final T max, final String message, final Object... values) {
public static <T> void smallerOrEqualObj(final Comparable<T> value, final T max) {
smallerOrEqualObj(value, max, DEFAULT_SMALLER_OR_EQUAL_EX_MESSAGE, value, max);
public static <T> void smallerOrEqualObj(final Comparable<T> value, final T max, final String message, final Object... values) {
public static <T> void differentObj(final Comparable<T> value, final T reference) {
differentObj(value, reference, DEFAULT_DIFFERENT_EX_MESSAGE, value);
public static <T> void differentObj(final Comparable<T> value, final T reference, final String message, final Object... values) {
if (value.compareTo(reference) == 0) {
Validate.greaterObj("c", "b");
Validate.greaterObj("b", "b");
Validate.greaterObj("a", "b");
Validate.greaterObj("c", "b", "MSG");
Validate.greaterObj("b", "b", "MSG");
Validate.greaterObj("a", "b", "MSG");
Validate.greaterOrEqualObj("c", "b");
Validate.greaterOrEqualObj("b", "b");
Validate.greaterOrEqualObj("a", "b");
Validate.greaterOrEqualObj("c", "b", "MSG");
Validate.greaterOrEqualObj("b", "b", "MSG");
Validate.greaterOrEqualObj("a", "b", "MSG");
Validate.smallerObj("a", "b");
Validate.smallerObj("b", "b");
Validate.smallerObj("c", "b");
Validate.smallerObj("a", "b", "MSG");
Validate.smallerObj("b", "b", "MSG");
Validate.smallerObj("c", "b", "MSG");
Validate.smallerOrEqualObj("a", "b");
Validate.smallerOrEqualObj("b", "b");
Validate.smallerOrEqualObj("c", "b");
Validate.smallerOrEqualObj("a", "b", "MSG");
Validate.smallerOrEqualObj("b", "b", "MSG");
Validate.smallerOrEqualObj("c", "b", "MSG");
Validate.differentObj("b", "a");
Validate.differentObj("a", "a");
Validate.differentObj("b", "a", "MSG");
Validate.differentObj("a", "a", "MSG");public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName) 
throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
messagePrefix = "No such method: ";
method = getMatchingMethod(object.getClass(),
if (method != null) {
isOriginallyAccessible = method.isAccessible();
if (!isOriginallyAccessible) {
method.setAccessible(true);
messagePrefix = "No such accessible method: ";
method = getMatchingAccessibleMethod(object.getClass(),
return invokeMethod(object, false, methodName, args, parameterTypes);
Validate.notNull(cls, "Null class not allowed.");
Validate.notEmpty(methodName, "Null or blank methodName not allowed.");
Method[] methodArray = cls.getDeclaredMethods();
List<Class<?>> superclassList = ClassUtils.getAllSuperclasses(cls);
for (Class<?> klass: superclassList) {
methodArray = ArrayUtils.addAll(methodArray, klass.getDeclaredMethods());
Method inexactMatch = null;
for (Method method: methodArray) {
if (methodName.equals(method.getName()) && 
ArrayUtils.isEquals(parameterTypes, method.getParameterTypes())) {
return method;
ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {
if (inexactMatch == null) {
inexactMatch = method;
< distance(parameterTypes, inexactMatch.getParameterTypes())) {
inexactMatch = method;
return inexactMatch;if (lhs instanceof long[]) {
append((long[]) lhs, (long[]) rhs);
append((int[]) lhs, (int[]) rhs);
append((short[]) lhs, (short[]) rhs);
append((char[]) lhs, (char[]) rhs);
append((byte[]) lhs, (byte[]) rhs);
append((double[]) lhs, (double[]) rhs);
append((float[]) lhs, (float[]) rhs);
append((boolean[]) lhs, (boolean[]) rhs);
append((Object[]) lhs, (Object[]) rhs, comparator);
public void testContains_LANG_1261() {
class LANG1261ParentObject {
public boolean equals(Object o) {
return true;
class LANG1261ChildObject extends LANG1261ParentObject {
Object[] array = new LANG1261ChildObject[] { new LANG1261ChildObject() };
assertTrue(ArrayUtils.contains(array, new LANG1261ParentObject()));int numDecimals = 0; // Check required precision (LANG-693)
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
try {
if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {this.testEmpty(StrTokenizer.getCSVInstance());
this.testEmpty(StrTokenizer.getCSVInstance(""));final double jaro = score(first,second);
final int cl = commonPrefixLength(first, second);
final double matchScore = Math.round((jaro + (DEFAULT_SCALING_FACTOR * cl * (1.0 - jaro))) *100.0)/100.0;
return  matchScore;
private static double score(final CharSequence first, final CharSequence second) {
String shorter;
String longer;
longer = first.toString().toLowerCase();
shorter = second.toString().toLowerCase();
longer = second.toString().toLowerCase();
shorter = first.toString().toLowerCase();
final int halflength = shorter.length() / 2 + 1;
final String m1 = getSetOfMatchingCharacterWithin(shorter, longer, halflength);
final String m2 = getSetOfMatchingCharacterWithin(longer, shorter, halflength);
if (m1.length() == 0 || m2.length() == 0) {
return 0.0;
if (m1.length() != m2.length()) {
return 0.0;
final int transpositions = transpositions(m1, m2);
final double dist =
(m1.length() / ((double)shorter.length()) +
m2.length() / ((double)longer.length()) +
(m1.length() - transpositions) / ((double)m1.length())) / 3.0;
return dist;
private static String getSetOfMatchingCharacterWithin(final CharSequence first, final CharSequence second, final int limit) {
final StringBuilder common = new StringBuilder();
final StringBuilder copy = new StringBuilder(second);
for (int i = 0; i < first.length(); i++) {
final char ch = first.charAt(i);
boolean found = false;
for (int j = Math.max(0, i - limit); !found && j < Math.min(i + limit, second.length()); j++) {
if (copy.charAt(j) == ch) {
found = true;
common.append(ch);
copy.setCharAt(j,'*');
return common.toString();
private static int transpositions(final CharSequence first, final CharSequence second) {
int transpositions = 0;
for (int i = 0; i < first.length(); i++) {
if (first.charAt(i) != second.charAt(i)) {
transpositions++;
return transpositions / 2;
private static int commonPrefixLength(final CharSequence first, final CharSequence second) {
final int result = getCommonPrefix(first.toString(), second.toString()).length();
return result > 4 ? 4 : result;
assertEquals(0.91d, StringUtils.getJaroWinklerDistance("ABC Corporation", "ABC Corp"), 0.0d);
assertEquals(0.93d, StringUtils.getJaroWinklerDistance("D N H Enterprises Inc", "D & H Enterprises, Inc."), 0.0d);
assertEquals(0.94d, StringUtils.getJaroWinklerDistance("My Gym Children's Fitness Center", "My Gym. Childrens Fitness"), 0.0d);
assertEquals(0.9d, StringUtils.getJaroWinklerDistance("PENNSYLVANIA", "PENNCISYLVNIA"), 0.0d);assertFalse(StringUtils.endsWithAny("abcXYZ", null));public void testBetweenWithCompare(){
final Comparator<Integer> c = new Comparator<Integer>(){
final Comparator<String> lengthComp = new Comparator<String>(){
Range<Integer> rb = Range.between(-10,20);
assertFalse("should not contain null",rb.contains(null));
assertTrue("should contain 10",rb.contains(10));
assertTrue("should contain -10",rb.contains(-10));
assertFalse("should not contain 21",rb.contains(21));
assertFalse("should not contain -11",rb.contains(-11));
rb = Range.between(-10,20,c);
assertFalse("should not contain null",rb.contains(null));
assertTrue("should contain 10",rb.contains(10));
assertTrue("should contain -10",rb.contains(-10));
assertTrue("should contain 21",rb.contains(21));
assertTrue("should contain -11",rb.contains(-11));
assertFalse("should not contain null",rbstr.contains(null));
assertTrue("should contain house",rbstr.contains("house"));
assertTrue("should contain i",rbstr.contains("i"));
assertFalse("should not contain hose",rbstr.contains("hose"));
assertFalse("should not contain ice",rbstr.contains("ice"));
assertFalse("should not contain null",rbstr.contains(null));
assertTrue("should contain house",rbstr.contains("house"));
assertTrue("should contain i",rbstr.contains("i"));
assertFalse("should not contain houses",rbstr.contains("houses"));
assertFalse("should not contain ''",rbstr.contains(""));package org.apache.commons.lang3;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
public class ThreadUtils {
public static Thread findThreadById(final long threadId, final ThreadGroup threadGroup) {
if (threadGroup == null) {
throw new IllegalArgumentException("The thread group must not be null");
final Thread thread = findThreadById(threadId);
if(thread != null && threadGroup.equals(thread.getThreadGroup())) {
return thread;
return null;
public static Thread findThreadById(final long threadId, final String threadGroupName) {
if (threadGroupName == null) {
throw new IllegalArgumentException("The thread group name must not be null");
final Thread thread = findThreadById(threadId);
if(thread != null && thread.getThreadGroup() != null && thread.getThreadGroup().getName().equals(threadGroupName)) {
return thread;
return null;
public static Collection<Thread> findThreadsByName(final String threadName, final ThreadGroup threadGroup) {
return findThreads(threadGroup, false, new NamePredicate(threadName));
public static Collection<Thread> findThreadsByName(final String threadName, final String threadGroupName) {
if (threadName == null) {
throw new IllegalArgumentException("The thread name must not be null");
if (threadGroupName == null) {
throw new IllegalArgumentException("The thread group name must not be null");
final Collection<ThreadGroup> threadGroups = findThreadGroups(new NamePredicate(threadGroupName));
if(threadGroups.isEmpty()) {
return Collections.emptyList();
final Collection<Thread> result = new ArrayList<Thread>();
final NamePredicate threadNamePredicate = new NamePredicate(threadName);
for(final ThreadGroup group : threadGroups) {
result.addAll(findThreads(group, false, threadNamePredicate));
return Collections.unmodifiableCollection(result);
public static Collection<ThreadGroup> findThreadGroupsByName(final String threadGroupName) {
return findThreadGroups(new NamePredicate(threadGroupName));
public static Collection<ThreadGroup> getAllThreadGroups() {
return findThreadGroups(ALWAYS_TRUE_PREDICATE);
public static ThreadGroup getSystemThreadGroup() {
ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();
while(threadGroup.getParent() != null) {
threadGroup = threadGroup.getParent();
return threadGroup;
public static Collection<Thread> getAllThreads() {
return findThreads(ALWAYS_TRUE_PREDICATE);
public static Collection<Thread> findThreadsByName(final String threadName) {
return findThreads(new NamePredicate(threadName));
public static Thread findThreadById(final long threadId) {
final Collection<Thread> result = findThreads(new ThreadIdPredicate(threadId));
return result.isEmpty() ? null : result.iterator().next();
public ThreadUtils() {
super();
public interface ThreadPredicate /*extends java.util.function.Predicate<Thread>*/{
boolean test(Thread thread);
public interface ThreadGroupPredicate /*extends java.util.function.Predicate<ThreadGroup>*/{
boolean test(ThreadGroup threadGroup);
public static final AlwaysTruePredicate ALWAYS_TRUE_PREDICATE = new AlwaysTruePredicate();
private final static class AlwaysTruePredicate implements ThreadPredicate, ThreadGroupPredicate{
private AlwaysTruePredicate() {
public boolean test(final ThreadGroup threadGroup) {
return true;
public boolean test(final Thread thread) {
return true;
public static class NamePredicate implements ThreadPredicate, ThreadGroupPredicate {
private final String name;
public NamePredicate(final String name) {
super();
if (name == null) {
throw new IllegalArgumentException("The name must not be null");
this.name = name;
public boolean test(final ThreadGroup threadGroup) {
return threadGroup != null && threadGroup.getName().equals(name);
public boolean test(final Thread thread) {
return thread != null && thread.getName().equals(name);
public static class ThreadIdPredicate implements ThreadPredicate {
private final long threadId;
public ThreadIdPredicate(final long threadId) {
super();
if (threadId <= 0) {
throw new IllegalArgumentException("The thread id must be greater than zero");
this.threadId = threadId;
public boolean test(final Thread thread) {
return thread != null && thread.getId() == threadId;
public static Collection<Thread> findThreads(final ThreadPredicate predicate){
return findThreads(getSystemThreadGroup(), true, predicate);
public static Collection<ThreadGroup> findThreadGroups(final ThreadGroupPredicate predicate){
return findThreadGroups(getSystemThreadGroup(), true, predicate);
public static Collection<Thread> findThreads(final ThreadGroup group, final boolean recurse, final ThreadPredicate predicate) {
if (group == null) {
throw new IllegalArgumentException("The group must not be null");
if (predicate == null) {
throw new IllegalArgumentException("The predicate must not be null");
int count = group.activeCount();
Thread[] threads;
do {
threads = new Thread[count + (count / 2) + 1]; //slightly grow the array size
count = group.enumerate(threads, recurse);
final List<Thread> result = new ArrayList<Thread>(count);
for (int i = 0; i < count; ++i) {
if (predicate.test(threads[i])) {
result.add(threads[i]);
return Collections.unmodifiableCollection(result);
public static Collection<ThreadGroup> findThreadGroups(final ThreadGroup group, final boolean recurse, final ThreadGroupPredicate predicate){
if (group == null) {
throw new IllegalArgumentException("The group must not be null");
if (predicate == null) {
throw new IllegalArgumentException("The predicate must not be null");
int count = group.activeGroupCount();
ThreadGroup[] threadGroups;
do {
threadGroups = new ThreadGroup[count + (count / 2) + 1]; //slightly grow the array size
count = group.enumerate(threadGroups, recurse);
final List<ThreadGroup> result = new ArrayList<ThreadGroup>(count);
for(int i = 0; i < count; ++i) {
if(predicate.test(threadGroups[i])) {
result.add(threadGroups[i]);
return Collections.unmodifiableCollection(result);
package org.apache.commons.lang3.math;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
public class NumberUtils {
public static final Long LONG_ZERO = Long.valueOf(0L);
public static final Long LONG_ONE = Long.valueOf(1L);
public static final Long LONG_MINUS_ONE = Long.valueOf(-1L);
public static final Integer INTEGER_ZERO = Integer.valueOf(0);
public static final Integer INTEGER_ONE = Integer.valueOf(1);
public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);
public static final Short SHORT_ZERO = Short.valueOf((short) 0);
public static final Short SHORT_ONE = Short.valueOf((short) 1);
public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);
public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);
public static final Byte BYTE_ONE = Byte.valueOf((byte) 1);
public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);
public static final Double DOUBLE_ZERO = Double.valueOf(0.0d);
public static final Double DOUBLE_ONE = Double.valueOf(1.0d);
public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);
public static final Float FLOAT_ZERO = Float.valueOf(0.0f);
public static final Float FLOAT_ONE = Float.valueOf(1.0f);
public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);
public NumberUtils() {
super();
public static int toInt(final String str) {
return toInt(str, 0);
public static int toInt(final String str, final int defaultValue) {
if(str == null) {
return defaultValue;
try {
return Integer.parseInt(str);
return defaultValue;
public static long toLong(final String str) {
return toLong(str, 0L);
public static long toLong(final String str, final long defaultValue) {
if (str == null) {
return defaultValue;
try {
return Long.parseLong(str);
return defaultValue;
public static float toFloat(final String str) {
return toFloat(str, 0.0f);
public static float toFloat(final String str, final float defaultValue) {
if (str == null) {
return defaultValue;
try {
return Float.parseFloat(str);
return defaultValue;
public static double toDouble(final String str) {
return toDouble(str, 0.0d);
public static double toDouble(final String str, final double defaultValue) {
if (str == null) {
return defaultValue;
try {
return Double.parseDouble(str);
return defaultValue;
public static byte toByte(final String str) {
return toByte(str, (byte) 0);
public static byte toByte(final String str, final byte defaultValue) {
if(str == null) {
return defaultValue;
try {
return Byte.parseByte(str);
return defaultValue;
public static short toShort(final String str) {
return toShort(str, (short) 0);
public static short toShort(final String str, final short defaultValue) {
if(str == null) {
return defaultValue;
try {
return Short.parseShort(str);
return defaultValue;
public static Number createNumber(final String str) throws NumberFormatException {
if (str == null) {
return null;
if (StringUtils.isBlank(str)) {
throw new NumberFormatException("A blank string is not a valid number");
final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"};
int pfxLen = 0;
for(final String pfx : hex_prefixes) {
if (str.startsWith(pfx)) {
pfxLen += pfx.length();
break;
if (pfxLen > 0) { // we have a hex number
char firstSigDigit = 0; // strip leading zeroes
for(int i = pfxLen; i < str.length(); i++) {
firstSigDigit = str.charAt(i);
if (firstSigDigit == '0') { // count leading zeroes
pfxLen++;
break;
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
return createBigInteger(str);
if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int
return createLong(str);
return createInteger(str);
final char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
final int decPos = str.indexOf('.');
final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
int numDecimals = 0; // Check required precision (LANG-693)
if (decPos > -1) { // there is a decimal point
if (expPos > -1) { // there is an exponent
if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + " is not a valid number.");
dec = str.substring(decPos + 1, expPos);
dec = str.substring(decPos + 1);
mant = getMantissa(str, decPos);
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
if (expPos > -1) {
if (expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + " is not a valid number.");
mant = getMantissa(str, expPos);
mant = getMantissa(str);
dec = null;
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
exp = null;
final String numeric = str.substring(0, str.length() - 1);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
return createBigInteger(numeric);
throw new NumberFormatException(str + " is not a valid number.");
case 'f' :
case 'F' :
try {
final Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
case 'd' :
case 'D' :
try {
final Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
try {
return createBigDecimal(numeric);
default :
throw new NumberFormatException(str + " is not a valid number.");
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
exp = null;
if (dec == null && exp == null) { // no decimal point and no exponent
try {
return createInteger(str);
try {
return createLong(str);
return createBigInteger(str);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
try {
if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
return createBigDecimal(str);
private static String getMantissa(final String str) {
return getMantissa(str, str.length());
private static String getMantissa(final String str, final int stopPos) {
final char firstChar = str.charAt(0);
final boolean hasSign = (firstChar == '-' || firstChar == '+');
return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);
private static boolean isAllZeros(final String str) {
if (str == null) {
return true;
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
return str.length() > 0;
public static Float createFloat(final String str) {
if (str == null) {
return null;
return Float.valueOf(str);
public static Double createDouble(final String str) {
if (str == null) {
return null;
return Double.valueOf(str);
public static Integer createInteger(final String str) {
if (str == null) {
return null;
return Integer.decode(str);
public static Long createLong(final String str) {
if (str == null) {
return null;
return Long.decode(str);
public static BigInteger createBigInteger(final String str) {
if (str == null) {
return null;
int pos = 0; // offset within string
int radix = 10;
boolean negate = false; // need to negate later?
if (str.startsWith("-")) {
negate = true;
pos = 1;
if (str.startsWith("0x", pos) || str.startsWith("0X", pos)) { // hex
radix = 16;
pos += 2;
radix = 16;
pos ++;
radix = 8;
pos ++;
final BigInteger value = new BigInteger(str.substring(pos), radix);
return negate ? value.negate() : value;
public static BigDecimal createBigDecimal(final String str) {
if (str == null) {
return null;
if (StringUtils.isBlank(str)) {
throw new NumberFormatException("A blank string is not a valid number");
if (str.trim().startsWith("--")) {
throw new NumberFormatException(str + " is not a valid number.");
return new BigDecimal(str);
public static long min(final long... array) {
validateArray(array);
long min = array[0];
for (int i = 1; i < array.length; i++) {
if (array[i] < min) {
min = array[i];
return min;
public static int min(final int... array) {
validateArray(array);
int min = array[0];
for (int j = 1; j < array.length; j++) {
if (array[j] < min) {
min = array[j];
return min;
public static short min(final short... array) {
validateArray(array);
short min = array[0];
for (int i = 1; i < array.length; i++) {
if (array[i] < min) {
min = array[i];
return min;
public static byte min(final byte... array) {
validateArray(array);
byte min = array[0];
for (int i = 1; i < array.length; i++) {
if (array[i] < min) {
min = array[i];
return min;
public static double min(final double... array) {
validateArray(array);
double min = array[0];
for (int i = 1; i < array.length; i++) {
if (Double.isNaN(array[i])) {
return Double.NaN;
if (array[i] < min) {
min = array[i];
return min;
public static float min(final float... array) {
validateArray(array);
float min = array[0];
for (int i = 1; i < array.length; i++) {
if (Float.isNaN(array[i])) {
return Float.NaN;
if (array[i] < min) {
min = array[i];
return min;
public static long max(final long... array) {
validateArray(array);
long max = array[0];
for (int j = 1; j < array.length; j++) {
if (array[j] > max) {
max = array[j];
return max;
public static int max(final int... array) {
validateArray(array);
int max = array[0];
for (int j = 1; j < array.length; j++) {
if (array[j] > max) {
max = array[j];
return max;
public static short max(final short... array) {
validateArray(array);
short max = array[0];
for (int i = 1; i < array.length; i++) {
if (array[i] > max) {
max = array[i];
return max;
public static byte max(final byte... array) {
validateArray(array);
byte max = array[0];
for (int i = 1; i < array.length; i++) {
if (array[i] > max) {
max = array[i];
return max;
public static double max(final double... array) {
validateArray(array);
double max = array[0];
for (int j = 1; j < array.length; j++) {
if (Double.isNaN(array[j])) {
return Double.NaN;
if (array[j] > max) {
max = array[j];
return max;
public static float max(final float... array) {
validateArray(array);
float max = array[0];
for (int j = 1; j < array.length; j++) {
if (Float.isNaN(array[j])) {
return Float.NaN;
if (array[j] > max) {
max = array[j];
return max;
private static void validateArray(final Object array) {
if (array == null) {
throw new IllegalArgumentException("The Array must not be null");
Validate.isTrue(Array.getLength(array) != 0, "Array cannot be empty.");        
public static long min(long a, final long b, final long c) {
if (b < a) {
a = b;
if (c < a) {
a = c;
return a;
public static int min(int a, final int b, final int c) {
if (b < a) {
a = b;
if (c < a) {
a = c;
return a;
public static short min(short a, final short b, final short c) {
if (b < a) {
a = b;
if (c < a) {
a = c;
return a;
public static byte min(byte a, final byte b, final byte c) {
if (b < a) {
a = b;
if (c < a) {
a = c;
return a;
public static double min(final double a, final double b, final double c) {
return Math.min(Math.min(a, b), c);
public static float min(final float a, final float b, final float c) {
return Math.min(Math.min(a, b), c);
public static long max(long a, final long b, final long c) {
if (b > a) {
a = b;
if (c > a) {
a = c;
return a;
public static int max(int a, final int b, final int c) {
if (b > a) {
a = b;
if (c > a) {
a = c;
return a;
public static short max(short a, final short b, final short c) {
if (b > a) {
a = b;
if (c > a) {
a = c;
return a;
public static byte max(byte a, final byte b, final byte c) {
if (b > a) {
a = b;
if (c > a) {
a = c;
return a;
public static double max(final double a, final double b, final double c) {
return Math.max(Math.max(a, b), c);
public static float max(final float a, final float b, final float c) {
return Math.max(Math.max(a, b), c);
public static boolean isDigits(final String str) {
return StringUtils.isNumeric(str);
public static boolean isNumber(final String str) {
if (StringUtils.isEmpty(str)) {
return false;
final char[] chars = str.toCharArray();
int sz = chars.length;
boolean hasExp = false;
boolean hasDecPoint = false;
boolean allowSigns = false;
boolean foundDigit = false;
final int start = (chars[0] == '-') ? 1 : 0;
if (sz > start + 1 && chars[start] == '0') { // leading 0
if (
(chars[start + 1] == 'x') || 
(chars[start + 1] == 'X') 
) { // leading 0x/0X
int i = start + 2;
if (i == sz) {
return false; // str == "0x"
for (; i < chars.length; i++) {
if ((chars[i] < '0' || chars[i] > '9')
&& (chars[i] < 'a' || chars[i] > 'f')
&& (chars[i] < 'A' || chars[i] > 'F')) {
return false;
return true;
int i = start + 1;
for (; i < chars.length; i++) {
if (chars[i] < '0' || chars[i] > '7') {
return false;
return true;               
sz--; // don't want to loop to the last char, check it afterwords
int i = start;
while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
if (chars[i] >= '0' && chars[i] <= '9') {
foundDigit = true;
allowSigns = false;
if (hasDecPoint || hasExp) {
return false;
hasDecPoint = true;
if (hasExp) {
return false;
if (!foundDigit) {
return false;
hasExp = true;
allowSigns = true;
if (!allowSigns) {
return false;
allowSigns = false;
foundDigit = false; // we need a digit after the E
return false;
i++;
if (i < chars.length) {
if (chars[i] >= '0' && chars[i] <= '9') {
return true;
if (chars[i] == 'e' || chars[i] == 'E') {
return false;
if (chars[i] == '.') {
if (hasDecPoint || hasExp) {
return false;
return foundDigit;
if (!allowSigns
&& (chars[i] == 'd'
|| chars[i] == 'D'
|| chars[i] == 'f'
|| chars[i] == 'F')) {
return foundDigit;
if (chars[i] == 'l'
|| chars[i] == 'L') {
return foundDigit && !hasExp && !hasDecPoint;
return false;
return !allowSigns && foundDigit;
public static boolean isParsable(final String str) {
if( StringUtils.endsWith( str, "." ) ) {
return false;
if( StringUtils.startsWith( str, "-" ) ) {
return isDigits( StringUtils.replaceOnce( str.substring(1), ".", StringUtils.EMPTY ) );
return isDigits( StringUtils.replaceOnce( str, ".", StringUtils.EMPTY ) );
public static int compare(int x, int y) {
if (x == y) {
return 0;
return x < y ? -1 : 1;
public static int compare(long x, long y) {
if (x == y) {
return 0;
return x < y ? -1 : 1;
public static int compare(short x, short y) {
if (x == y) {
return 0;
return x < y ? -1 : 1;
public static int compare(byte x, byte y) {
return x - y;
private boolean preserveEscapes = false;
if (preserveEscapes) {
pos++;
continue;
public boolean isPreserveEscapes() {
return preserveEscapes;
public void setPreserveEscapes(final boolean preserveEscapes) {
this.preserveEscapes = preserveEscapes;
public void testSubstitutePreserveEscape() {
final String org = "${not-escaped} $${escaped}";
final Map<String, String> map = new HashMap<String, String>();
map.put("not-escaped", "value");
StrSubstitutor sub = new StrSubstitutor(map, "${", "}", '$');
assertFalse(sub.isPreserveEscapes());
assertEquals("value ${escaped}", sub.replace(org));
sub.setPreserveEscapes(true);
assertTrue(sub.isPreserveEscapes());
assertEquals("value $${escaped}", sub.replace(org));package org.apache.commons.lang3;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.lang3.mutable.MutableInt;
public class ArrayUtils {
public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];
public static final String[] EMPTY_STRING_ARRAY = new String[0];
public static final long[] EMPTY_LONG_ARRAY = new long[0];
public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];
public static final int[] EMPTY_INT_ARRAY = new int[0];
public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];
public static final short[] EMPTY_SHORT_ARRAY = new short[0];
public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];
public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];
public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];
public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];
public static final float[] EMPTY_FLOAT_ARRAY = new float[0];
public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];
public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];
public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];
public static final char[] EMPTY_CHAR_ARRAY = new char[0];
public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];
public static final int INDEX_NOT_FOUND = -1;
public ArrayUtils() {
super();
public static String toString(final Object array) {
return toString(array, "{}");
public static String toString(final Object array, final String stringIfNull) {
if (array == null) {
return stringIfNull;
return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();
public static int hashCode(final Object array) {
return new HashCodeBuilder().append(array).toHashCode();
public static boolean isEquals(final Object array1, final Object array2) {
return new EqualsBuilder().append(array1, array2).isEquals();
public static Map<Object, Object> toMap(final Object[] array) {
if (array == null) {
return null;
final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));
for (int i = 0; i < array.length; i++) {
final Object object = array[i];
if (object instanceof Map.Entry<?, ?>) {
final Map.Entry<?,?> entry = (Map.Entry<?,?>) object;
map.put(entry.getKey(), entry.getValue());
final Object[] entry = (Object[]) object;
if (entry.length < 2) {
throw new IllegalArgumentException("Array element " + i + ", '"
+ object
+ "', has a length less than 2");
map.put(entry[0], entry[1]);
throw new IllegalArgumentException("Array element " + i + ", '"
+ object
+ "', is neither of type Map.Entry nor an Array");
return map;
public static &lt;T&gt; T[] createAnArray(int size) {
return new T[size]; // compiler error here
public static &lt;T&gt; T[] createAnArray(int size) {
return (T[])new Object[size]; // ClassCastException at runtime
String[] array = ArrayUtils.toArray("1", "2");
String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();
public static <T> T[] toArray(final T... items) {
return items;
public static <T> T[] clone(final T[] array) {
if (array == null) {
return null;
return array.clone();
public static long[] clone(final long[] array) {
if (array == null) {
return null;
return array.clone();
public static int[] clone(final int[] array) {
if (array == null) {
return null;
return array.clone();
public static short[] clone(final short[] array) {
if (array == null) {
return null;
return array.clone();
public static char[] clone(final char[] array) {
if (array == null) {
return null;
return array.clone();
public static byte[] clone(final byte[] array) {
if (array == null) {
return null;
return array.clone();
public static double[] clone(final double[] array) {
if (array == null) {
return null;
return array.clone();
public static float[] clone(final float[] array) {
if (array == null) {
return null;
return array.clone();
public static boolean[] clone(final boolean[] array) {
if (array == null) {
return null;
return array.clone();
public static <T> T[] nullToEmpty(final T[] array, final Class<T[]> type) {
if(type == null) {
throw new IllegalArgumentException("The type must not be null");
if(array == null) {
return type.cast(Array.newInstance(type.getComponentType(), 0));
return array;
public static Object[] nullToEmpty(final Object[] array) {
if (isEmpty(array)) {
return EMPTY_OBJECT_ARRAY;
return array;
public static Class<?>[] nullToEmpty(final Class<?>[] array) {
if (isEmpty(array)) {
return EMPTY_CLASS_ARRAY;
return array;
public static String[] nullToEmpty(final String[] array) {
if (isEmpty(array)) {
return EMPTY_STRING_ARRAY;
return array;
public static long[] nullToEmpty(final long[] array) {
if (isEmpty(array)) {
return EMPTY_LONG_ARRAY;
return array;
public static int[] nullToEmpty(final int[] array) {
if (isEmpty(array)) {
return EMPTY_INT_ARRAY;
return array;
public static short[] nullToEmpty(final short[] array) {
if (isEmpty(array)) {
return EMPTY_SHORT_ARRAY;
return array;
public static char[] nullToEmpty(final char[] array) {
if (isEmpty(array)) {
return EMPTY_CHAR_ARRAY;
return array;
public static byte[] nullToEmpty(final byte[] array) {
if (isEmpty(array)) {
return EMPTY_BYTE_ARRAY;
return array;
public static double[] nullToEmpty(final double[] array) {
if (isEmpty(array)) {
return EMPTY_DOUBLE_ARRAY;
return array;
public static float[] nullToEmpty(final float[] array) {
if (isEmpty(array)) {
return EMPTY_FLOAT_ARRAY;
return array;
public static boolean[] nullToEmpty(final boolean[] array) {
if (isEmpty(array)) {
return EMPTY_BOOLEAN_ARRAY;
return array;
public static Long[] nullToEmpty(final Long[] array) {
if (isEmpty(array)) {
return EMPTY_LONG_OBJECT_ARRAY;
return array;
public static Integer[] nullToEmpty(final Integer[] array) {
if (isEmpty(array)) {
return EMPTY_INTEGER_OBJECT_ARRAY;
return array;
public static Short[] nullToEmpty(final Short[] array) {
if (isEmpty(array)) {
return EMPTY_SHORT_OBJECT_ARRAY;
return array;
public static Character[] nullToEmpty(final Character[] array) {
if (isEmpty(array)) {
return EMPTY_CHARACTER_OBJECT_ARRAY;
return array;
public static Byte[] nullToEmpty(final Byte[] array) {
if (isEmpty(array)) {
return EMPTY_BYTE_OBJECT_ARRAY;
return array;
public static Double[] nullToEmpty(final Double[] array) {
if (isEmpty(array)) {
return EMPTY_DOUBLE_OBJECT_ARRAY;
return array;
public static Float[] nullToEmpty(final Float[] array) {
if (isEmpty(array)) {
return EMPTY_FLOAT_OBJECT_ARRAY;
return array;
public static Boolean[] nullToEmpty(final Boolean[] array) {
if (isEmpty(array)) {
return EMPTY_BOOLEAN_OBJECT_ARRAY;
return array;
public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
final Class<?> type = array.getClass().getComponentType();
if (newSize <= 0) {
final T[] emptyArray = (T[]) Array.newInstance(type, 0);
return emptyArray;
final
T[] subarray = (T[]) Array.newInstance(type, newSize);
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_LONG_ARRAY;
final long[] subarray = new long[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_INT_ARRAY;
final int[] subarray = new int[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_SHORT_ARRAY;
final short[] subarray = new short[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_CHAR_ARRAY;
final char[] subarray = new char[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_BYTE_ARRAY;
final byte[] subarray = new byte[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_DOUBLE_ARRAY;
final double[] subarray = new double[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_FLOAT_ARRAY;
final float[] subarray = new float[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {
if (array == null) {
return null;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive > array.length) {
endIndexExclusive = array.length;
final int newSize = endIndexExclusive - startIndexInclusive;
if (newSize <= 0) {
return EMPTY_BOOLEAN_ARRAY;
final boolean[] subarray = new boolean[newSize];
System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
return subarray;
public static boolean isSameLength(final Object[] array1, final Object[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final long[] array1, final long[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final int[] array1, final int[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final short[] array1, final short[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final char[] array1, final char[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final byte[] array1, final byte[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final double[] array1, final double[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final float[] array1, final float[] array2) {
return getLength(array1) == getLength(array2);
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {
return getLength(array1) == getLength(array2);
public static int getLength(final Object array) {
if (array == null) {
return 0;
return Array.getLength(array);
public static boolean isSameType(final Object array1, final Object array2) {
if (array1 == null || array2 == null) {
throw new IllegalArgumentException("The Array must not be null");
return array1.getClass().getName().equals(array2.getClass().getName());
public static void reverse(final Object[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final long[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final int[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final short[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final char[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final byte[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final double[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final float[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final boolean[] array) {
if (array == null) {
return;
reverse(array, 0, array.length);
public static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
boolean tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
byte tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
char tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
double tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
float tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
int tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
long tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
Object tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive) {
if (array == null) {
return;
int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;
int j = Math.min(array.length, endIndexExclusive) - 1;
short tmp;
while (j > i) {
tmp = array[j];
array[j] = array[i];
array[i] = tmp;
j--;
i++;
public static void swap(final Object[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final long[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final int[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final short[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final char[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final byte[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final double[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final float[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final boolean[] array, int offset1, int offset2) {
if (array == null || array.length == 0) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final boolean[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
boolean aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final byte[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
byte aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final char[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
char aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final double[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
double aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final float[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
float aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final int[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
int aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final long[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
long aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final Object[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
Object aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void swap(final short[] array,  int offset1, int offset2, int len) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
if (offset1 == offset2) {
return;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
short aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
public static void shift(final Object[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final long[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final int[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final short[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final char[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final byte[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final double[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final float[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final boolean[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static int indexOf(final Object[] array, final Object objectToFind) {
return indexOf(array, objectToFind, 0);
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
if (objectToFind == null) {
for (int i = startIndex; i < array.length; i++) {
if (array[i] == null) {
return i;
for (int i = startIndex; i < array.length; i++) {
if (objectToFind.equals(array[i])) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final Object[] array, final Object objectToFind) {
return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
if (objectToFind == null) {
for (int i = startIndex; i >= 0; i--) {
if (array[i] == null) {
return i;
for (int i = startIndex; i >= 0; i--) {
if (objectToFind.equals(array[i])) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final Object[] array, final Object objectToFind) {
return indexOf(array, objectToFind) != INDEX_NOT_FOUND;
public static int indexOf(final long[] array, final long valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final long[] array, final long valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final long[] array, final long valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final long[] array, final long valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final int[] array, final int valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final int[] array, final int valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final int[] array, final int valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final int[] array, final int valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final short[] array, final short valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final short[] array, final short valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final short[] array, final short valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final short[] array, final short valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final char[] array, final char valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final char[] array, final char valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final char[] array, final char valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final char[] array, final char valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final byte[] array, final byte valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final byte[] array, final byte valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {
if (array == null) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final byte[] array, final byte valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final double[] array, final double valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {
return indexOf(array, valueToFind, 0, tolerance);
public static int indexOf(final double[] array, final double valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
final double min = valueToFind - tolerance;
final double max = valueToFind + tolerance;
for (int i = startIndex; i < array.length; i++) {
if (array[i] >= min && array[i] <= max) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final double[] array, final double valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
final double min = valueToFind - tolerance;
final double max = valueToFind + tolerance;
for (int i = startIndex; i >= 0; i--) {
if (array[i] >= min && array[i] <= max) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final double[] array, final double valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {
return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;
public static int indexOf(final float[] array, final float valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final float[] array, final float valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final float[] array, final float valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final float[] array, final float valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static int indexOf(final boolean[] array, final boolean valueToFind) {
return indexOf(array, valueToFind, 0);
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
startIndex = 0;
for (int i = startIndex; i < array.length; i++) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {
return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {
if (ArrayUtils.isEmpty(array)) {
return INDEX_NOT_FOUND;
if (startIndex < 0) {
return INDEX_NOT_FOUND;
startIndex = array.length - 1;
for (int i = startIndex; i >= 0; i--) {
if (valueToFind == array[i]) {
return i;
return INDEX_NOT_FOUND;
public static boolean contains(final boolean[] array, final boolean valueToFind) {
return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
public static char[] toPrimitive(final Character[] array) {
if (array == null) {
return null;
return EMPTY_CHAR_ARRAY;
final char[] result = new char[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].charValue();
return result;
public static char[] toPrimitive(final Character[] array, final char valueForNull) {
if (array == null) {
return null;
return EMPTY_CHAR_ARRAY;
final char[] result = new char[array.length];
for (int i = 0; i < array.length; i++) {
final Character b = array[i];
result[i] = (b == null ? valueForNull : b.charValue());
return result;
public static Character[] toObject(final char[] array) {
if (array == null) {
return null;
return EMPTY_CHARACTER_OBJECT_ARRAY;
final Character[] result = new Character[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Character.valueOf(array[i]);
return result;
public static long[] toPrimitive(final Long[] array) {
if (array == null) {
return null;
return EMPTY_LONG_ARRAY;
final long[] result = new long[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].longValue();
return result;
public static long[] toPrimitive(final Long[] array, final long valueForNull) {
if (array == null) {
return null;
return EMPTY_LONG_ARRAY;
final long[] result = new long[array.length];
for (int i = 0; i < array.length; i++) {
final Long b = array[i];
result[i] = (b == null ? valueForNull : b.longValue());
return result;
public static Long[] toObject(final long[] array) {
if (array == null) {
return null;
return EMPTY_LONG_OBJECT_ARRAY;
final Long[] result = new Long[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Long.valueOf(array[i]);
return result;
public static int[] toPrimitive(final Integer[] array) {
if (array == null) {
return null;
return EMPTY_INT_ARRAY;
final int[] result = new int[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].intValue();
return result;
public static int[] toPrimitive(final Integer[] array, final int valueForNull) {
if (array == null) {
return null;
return EMPTY_INT_ARRAY;
final int[] result = new int[array.length];
for (int i = 0; i < array.length; i++) {
final Integer b = array[i];
result[i] = (b == null ? valueForNull : b.intValue());
return result;
public static Integer[] toObject(final int[] array) {
if (array == null) {
return null;
return EMPTY_INTEGER_OBJECT_ARRAY;
final Integer[] result = new Integer[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Integer.valueOf(array[i]);
return result;
public static short[] toPrimitive(final Short[] array) {
if (array == null) {
return null;
return EMPTY_SHORT_ARRAY;
final short[] result = new short[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].shortValue();
return result;
public static short[] toPrimitive(final Short[] array, final short valueForNull) {
if (array == null) {
return null;
return EMPTY_SHORT_ARRAY;
final short[] result = new short[array.length];
for (int i = 0; i < array.length; i++) {
final Short b = array[i];
result[i] = (b == null ? valueForNull : b.shortValue());
return result;
public static Short[] toObject(final short[] array) {
if (array == null) {
return null;
return EMPTY_SHORT_OBJECT_ARRAY;
final Short[] result = new Short[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Short.valueOf(array[i]);
return result;
public static byte[] toPrimitive(final Byte[] array) {
if (array == null) {
return null;
return EMPTY_BYTE_ARRAY;
final byte[] result = new byte[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].byteValue();
return result;
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {
if (array == null) {
return null;
return EMPTY_BYTE_ARRAY;
final byte[] result = new byte[array.length];
for (int i = 0; i < array.length; i++) {
final Byte b = array[i];
result[i] = (b == null ? valueForNull : b.byteValue());
return result;
public static Byte[] toObject(final byte[] array) {
if (array == null) {
return null;
return EMPTY_BYTE_OBJECT_ARRAY;
final Byte[] result = new Byte[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Byte.valueOf(array[i]);
return result;
public static double[] toPrimitive(final Double[] array) {
if (array == null) {
return null;
return EMPTY_DOUBLE_ARRAY;
final double[] result = new double[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].doubleValue();
return result;
public static double[] toPrimitive(final Double[] array, final double valueForNull) {
if (array == null) {
return null;
return EMPTY_DOUBLE_ARRAY;
final double[] result = new double[array.length];
for (int i = 0; i < array.length; i++) {
final Double b = array[i];
result[i] = (b == null ? valueForNull : b.doubleValue());
return result;
public static Double[] toObject(final double[] array) {
if (array == null) {
return null;
return EMPTY_DOUBLE_OBJECT_ARRAY;
final Double[] result = new Double[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Double.valueOf(array[i]);
return result;
public static float[] toPrimitive(final Float[] array) {
if (array == null) {
return null;
return EMPTY_FLOAT_ARRAY;
final float[] result = new float[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].floatValue();
return result;
public static float[] toPrimitive(final Float[] array, final float valueForNull) {
if (array == null) {
return null;
return EMPTY_FLOAT_ARRAY;
final float[] result = new float[array.length];
for (int i = 0; i < array.length; i++) {
final Float b = array[i];
result[i] = (b == null ? valueForNull : b.floatValue());
return result;
public static Float[] toObject(final float[] array) {
if (array == null) {
return null;
return EMPTY_FLOAT_OBJECT_ARRAY;
final Float[] result = new Float[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = Float.valueOf(array[i]);
return result;
public static boolean[] toPrimitive(final Boolean[] array) {
if (array == null) {
return null;
return EMPTY_BOOLEAN_ARRAY;
final boolean[] result = new boolean[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = array[i].booleanValue();
return result;
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {
if (array == null) {
return null;
return EMPTY_BOOLEAN_ARRAY;
final boolean[] result = new boolean[array.length];
for (int i = 0; i < array.length; i++) {
final Boolean b = array[i];
result[i] = (b == null ? valueForNull : b.booleanValue());
return result;
public static Boolean[] toObject(final boolean[] array) {
if (array == null) {
return null;
return EMPTY_BOOLEAN_OBJECT_ARRAY;
final Boolean[] result = new Boolean[array.length];
for (int i = 0; i < array.length; i++) {
result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);
return result;
public static boolean isEmpty(final Object[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final long[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final int[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final short[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final char[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final byte[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final double[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final float[] array) {
return getLength(array) == 0;
public static boolean isEmpty(final boolean[] array) {
return getLength(array) == 0;
public static <T> boolean isNotEmpty(final T[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final long[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final int[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final short[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final char[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final byte[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final double[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final float[] array) {
return !isEmpty(array);
public static boolean isNotEmpty(final boolean[] array) {
return !isEmpty(array);
public static <T> T[] addAll(final T[] array1, final T... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final Class<?> type1 = array1.getClass().getComponentType();
final
T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
try {
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
final Class<?> type2 = array2.getClass().getComponentType();
if (!type1.isAssignableFrom(type2)){
throw new IllegalArgumentException("Cannot store "+type2.getName()+" in an array of "
+type1.getName(), ase);
throw ase; // No, so rethrow original
return joinedArray;
public static boolean[] addAll(final boolean[] array1, final boolean... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final boolean[] joinedArray = new boolean[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static char[] addAll(final char[] array1, final char... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final char[] joinedArray = new char[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static byte[] addAll(final byte[] array1, final byte... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final byte[] joinedArray = new byte[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static short[] addAll(final short[] array1, final short... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final short[] joinedArray = new short[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static int[] addAll(final int[] array1, final int... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final int[] joinedArray = new int[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static long[] addAll(final long[] array1, final long... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final long[] joinedArray = new long[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static float[] addAll(final float[] array1, final float... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final float[] joinedArray = new float[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static double[] addAll(final double[] array1, final double... array2) {
if (array1 == null) {
return clone(array2);
return clone(array1);
final double[] joinedArray = new double[array1.length + array2.length];
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
return joinedArray;
public static <T> T[] add(final T[] array, final T element) {
Class<?> type;
if (array != null){
type = array.getClass().getComponentType();
type = element.getClass();
throw new IllegalArgumentException("Arguments cannot both be null");
final
T[] newArray = (T[]) copyArrayGrow1(array, type);
newArray[newArray.length - 1] = element;
return newArray;
public static boolean[] add(final boolean[] array, final boolean element) {
final boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static byte[] add(final byte[] array, final byte element) {
final byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static char[] add(final char[] array, final char element) {
final char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static double[] add(final double[] array, final double element) {
final double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static float[] add(final float[] array, final float element) {
final float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static int[] add(final int[] array, final int element) {
final int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static long[] add(final long[] array, final long element) {
final long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
public static short[] add(final short[] array, final short element) {
final short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);
newArray[newArray.length - 1] = element;
return newArray;
private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {
if (array != null) {
final int arrayLength = Array.getLength(array);
final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);
System.arraycopy(array, 0, newArray, 0, arrayLength);
return newArray;
return Array.newInstance(newArrayComponentType, 1);
public static <T> T[] add(final T[] array, final int index, final T element) {
Class<?> clss = null;
if (array != null) {
clss = array.getClass().getComponentType();
clss = element.getClass();
throw new IllegalArgumentException("Array and element cannot both be null");
final T[] newArray = (T[]) add(array, index, element, clss);
return newArray;
public static boolean[] add(final boolean[] array, final int index, final boolean element) {
return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);
public static char[] add(final char[] array, final int index, final char element) {
return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);
public static byte[] add(final byte[] array, final int index, final byte element) {
return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);
public static short[] add(final short[] array, final int index, final short element) {
return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);
public static int[] add(final int[] array, final int index, final int element) {
return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);
public static long[] add(final long[] array, final int index, final long element) {
return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);
public static float[] add(final float[] array, final int index, final float element) {
return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);
public static double[] add(final double[] array, final int index, final double element) {
return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {
if (array == null) {
if (index != 0) {
throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");
final Object joinedArray = Array.newInstance(clss, 1);
Array.set(joinedArray, 0, element);
return joinedArray;
final int length = Array.getLength(array);
if (index > length || index < 0) {
throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);
final Object result = Array.newInstance(clss, length + 1);
System.arraycopy(array, 0, result, 0, index);
Array.set(result, index, element);
if (index < length) {
System.arraycopy(array, index, result, index + 1, length - index);
return result;
public static <T> T[] remove(final T[] array, final int index) {
return (T[]) remove((Object) array, index);
public static <T> T[] removeElement(final T[] array, final Object element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static boolean[] remove(final boolean[] array, final int index) {
return (boolean[]) remove((Object) array, index);
public static boolean[] removeElement(final boolean[] array, final boolean element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static byte[] remove(final byte[] array, final int index) {
return (byte[]) remove((Object) array, index);
public static byte[] removeElement(final byte[] array, final byte element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static char[] remove(final char[] array, final int index) {
return (char[]) remove((Object) array, index);
public static char[] removeElement(final char[] array, final char element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static double[] remove(final double[] array, final int index) {
return (double[]) remove((Object) array, index);
public static double[] removeElement(final double[] array, final double element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static float[] remove(final float[] array, final int index) {
return (float[]) remove((Object) array, index);
public static float[] removeElement(final float[] array, final float element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static int[] remove(final int[] array, final int index) {
return (int[]) remove((Object) array, index);
public static int[] removeElement(final int[] array, final int element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static long[] remove(final long[] array, final int index) {
return (long[]) remove((Object) array, index);
public static long[] removeElement(final long[] array, final long element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
public static short[] remove(final short[] array, final int index) {
return (short[]) remove((Object) array, index);
public static short[] removeElement(final short[] array, final short element) {
final int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
return remove(array, index);
private static Object remove(final Object array, final int index) {
final int length = getLength(array);
if (index < 0 || index >= length) {
throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);
final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);
System.arraycopy(array, 0, result, 0, index);
if (index < length - 1) {
System.arraycopy(array, index + 1, result, index, length - index - 1);
return result;
public static <T> T[] removeAll(final T[] array, final int... indices) {
return (T[]) removeAll((Object) array, clone(indices));
public static <T> T[] removeElements(final T[] array, final T... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);
for (final T v : values) {
final MutableInt count = occurrences.get(v);
if (count == null) {
occurrences.put(v, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {
final T v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v, found);
if (found < 0) {
break;
toRemove.set(found++);
final
T[] result = (T[]) removeAll(array, toRemove);
return result;
public static byte[] removeAll(final byte[] array, final int... indices) {
return (byte[]) removeAll((Object) array, clone(indices));
public static byte[] removeElements(final byte[] array, final byte... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final Map<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);
for (final byte v : values) {
final Byte boxed = Byte.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {
final Byte v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.byteValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (byte[]) removeAll(array, toRemove);
public static short[] removeAll(final short[] array, final int... indices) {
return (short[]) removeAll((Object) array, clone(indices));
public static short[] removeElements(final short[] array, final short... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);
for (final short v : values) {
final Short boxed = Short.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {
final Short v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.shortValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (short[]) removeAll(array, toRemove);
public static int[] removeAll(final int[] array, final int... indices) {
return (int[]) removeAll((Object) array, clone(indices));
public static int[] removeElements(final int[] array, final int... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);
for (final int v : values) {
final Integer boxed = Integer.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {
final Integer v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.intValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (int[]) removeAll(array, toRemove);
public static char[] removeAll(final char[] array, final int... indices) {
return (char[]) removeAll((Object) array, clone(indices));
public static char[] removeElements(final char[] array, final char... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);
for (final char v : values) {
final Character boxed = Character.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {
final Character v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.charValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (char[]) removeAll(array, toRemove);
public static long[] removeAll(final long[] array, final int... indices) {
return (long[]) removeAll((Object) array, clone(indices));
public static long[] removeElements(final long[] array, final long... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);
for (final long v : values) {
final Long boxed = Long.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {
final Long v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.longValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (long[]) removeAll(array, toRemove);
public static float[] removeAll(final float[] array, final int... indices) {
return (float[]) removeAll((Object) array, clone(indices));
public static float[] removeElements(final float[] array, final float... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);
for (final float v : values) {
final Float boxed = Float.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {
final Float v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.floatValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (float[]) removeAll(array, toRemove);
public static double[] removeAll(final double[] array, final int... indices) {
return (double[]) removeAll((Object) array, clone(indices));
public static double[] removeElements(final double[] array, final double... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);
for (final double v : values) {
final Double boxed = Double.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {
final Double v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.doubleValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (double[]) removeAll(array, toRemove);
public static boolean[] removeAll(final boolean[] array, final int... indices) {
return (boolean[]) removeAll((Object) array, clone(indices));
public static boolean[] removeElements(final boolean[] array, final boolean... values) {
if (isEmpty(array) || isEmpty(values)) {
return clone(array);
final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); // only two possible values here
for (final boolean v : values) {
final Boolean boxed = Boolean.valueOf(v);
final MutableInt count = occurrences.get(boxed);
if (count == null) {
occurrences.put(boxed, new MutableInt(1));
count.increment();
final BitSet toRemove = new BitSet();
for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {
final Boolean v = e.getKey();
int found = 0;
for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {
found = indexOf(array, v.booleanValue(), found);
if (found < 0) {
break;
toRemove.set(found++);
return (boolean[]) removeAll(array, toRemove);
static Object removeAll(final Object array, final int... indices) {
final int length = getLength(array);
int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed
if (isNotEmpty(indices)) {
Arrays.sort(indices);
int i = indices.length;
int prevIndex = length;
while (--i >= 0) {
final int index = indices[i];
if (index < 0 || index >= length) {
throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);
if (index >= prevIndex) {
continue;
diff++;
prevIndex = index;
final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);
if (diff < length) {
int end = length; // index just after last copy
int dest = length - diff; // number of entries so far not copied
for (int i = indices.length - 1; i >= 0; i--) {
final int index = indices[i];
if (end - index > 1) { // same as (cp > 0)
final int cp = end - index - 1;
dest -= cp;
System.arraycopy(array, index + 1, result, dest, cp);
end = index;
if (end > 0) {
System.arraycopy(array, 0, result, 0, end);
return result;
static Object removeAll(final Object array, final BitSet indices) {
final int srcLength = ArrayUtils.getLength(array);
final int removals = indices.cardinality(); // true bits are items to remove
final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);
int srcIndex=0;
int destIndex=0;
int count;
int set;
while((set = indices.nextSetBit(srcIndex)) != -1){
count = set - srcIndex;
if (count > 0) {
System.arraycopy(array, srcIndex, result, destIndex, count);
destIndex += count;
srcIndex = indices.nextClearBit(set);
count = srcLength - srcIndex;
if (count > 0) {
System.arraycopy(array, srcIndex, result, destIndex, count);            
return result;
public static <T extends Comparable<? super T>> boolean isSorted(final T[] array) {
return isSorted(array, new Comparator<T>() {
public int compare(T o1, T o2) {
return o1.compareTo(o2);
public static <T> boolean isSorted(final T[] array, final Comparator<T> comparator) {
if (comparator == null) {
throw new IllegalArgumentException("Comparator should not be null.");
if(array == null || array.length < 2) {
return true;
T previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final T current = array[i];
if (comparator.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(int[] array) {
if(array == null || array.length < 2) {
return true;
int previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final int current = array[i];
if(NumberUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(long[] array) {
if(array == null || array.length < 2) {
return true;
long previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final long current = array[i];
if(NumberUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(short[] array) {
if(array == null || array.length < 2) {
return true;
short previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final short current = array[i];
if(NumberUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(final double[] array) {
if(array == null || array.length < 2) {
return true;
double previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final double current = array[i];
if(Double.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(final float[] array) {
if(array == null || array.length < 2) {
return true;
float previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final float current = array[i];
if(Float.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(byte[] array) {
if(array == null || array.length < 2) {
return true;
byte previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final byte current = array[i];
if(NumberUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(char[] array) {
if(array == null || array.length < 2) {
return true;
char previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final char current = array[i];
if(CharUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean isSorted(boolean[] array) {
if(array == null || array.length < 2) {
return true;
boolean previous = array[0];
final int n = array.length;
for(int i = 1; i < n; i++) {
final boolean current = array[i];
if(BooleanUtils.compare(previous, current) > 0) {
return false;
previous = current;
return true;
public static boolean[] removeAllOccurences(final boolean[] array, final boolean element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));        
public static char[] removeAllOccurences(final char[] array, final char element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));        
public static byte[] removeAllOccurences(final byte[] array, final byte element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static short[] removeAllOccurences(final short[] array, final short element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static int[] removeAllOccurences(final int[] array, final int element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static long[] removeAllOccurences(final long[] array, final long element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static float[] removeAllOccurences(final float[] array, final float element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static double[] removeAllOccurences(final double[] array, final double element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));
public static <T> T[] removeAllOccurences(final T[] array, final T element) {
int index = indexOf(array, element);
if (index == INDEX_NOT_FOUND) {
return clone(array);
int[] indices = new int[array.length - index];
indices[0] = index;
int count = 1;
while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
indices[count++] = index;
return removeAll(array, Arrays.copyOf(indices, count));if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0) {
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
boolean aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
byte aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
char aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
double aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
float aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
int aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
long aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
Object aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
if (array == null || array.length == 0 || offset1 >= array.length || offset2 >= array.length) {
return;
if (offset1 < 0) {
offset1 = 0;
if (offset2 < 0) {
offset2 = 0;
if (offset1 == offset2) {
len = Math.min(Math.min(len, array.length - offset1), array.length - offset2);
for (int i = 0; i < len; i++, offset1++, offset2++) {
short aux = array[offset1];
array[offset1] = array[offset2];
array[offset2] = aux;
for (final Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperMap.entrySet()) {
final Class<?> primitiveClass = entry.getKey();
final Class<?> wrapperClass = entry.getValue();
public static String joinWith(final String separator, final Object... objects) {
if (objects == null) {
throw new IllegalArgumentException("Object varargs must not be null");
final String sanitizedSeparator = defaultString(separator, StringUtils.EMPTY);
final StringBuilder result = new StringBuilder();
final Iterator<Object> iterator = Arrays.asList(objects).iterator();
while (iterator.hasNext()) {
final String value = ObjectUtils.toString(iterator.next());
result.append(value);
if (iterator.hasNext()) {
result.append(sanitizedSeparator);
return result.toString();
package org.apache.commons.lang3;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
public class ThreadUtils {
public static Thread findThreadById(final long threadId, final ThreadGroup threadGroup) {
if (threadGroup == null) {
throw new IllegalArgumentException("The thread group must not be null");
final Thread thread = findThreadById(threadId);
if(thread != null && threadGroup.equals(thread.getThreadGroup())) {
return thread;
return null;
public static Thread findThreadById(final long threadId, final String threadGroupName) {
if (threadGroupName == null) {
throw new IllegalArgumentException("The thread group name must not be null");
final Thread thread = findThreadById(threadId);
if(thread != null && thread.getThreadGroup() != null && thread.getThreadGroup().getName().equals(threadGroupName)) {
return thread;
return null;
public static Collection<Thread> findThreadsByName(final String threadName, final ThreadGroup threadGroup) {
return findThreads(threadGroup, false, new NamePredicate(threadName));
public static Collection<Thread> findThreadsByName(final String threadName, final String threadGroupName) {
if (threadName == null) {
throw new IllegalArgumentException("The thread name must not be null");
if (threadGroupName == null) {
throw new IllegalArgumentException("The thread group name must not be null");
final Collection<ThreadGroup> threadGroups = findThreadGroups(new NamePredicate(threadGroupName));
if(threadGroups.isEmpty()) {
return Collections.emptyList();
final Collection<Thread> result = new ArrayList<Thread>();
final NamePredicate threadNamePredicate = new NamePredicate(threadName);
for(final ThreadGroup group : threadGroups) {
result.addAll(findThreads(group, false, threadNamePredicate));
return Collections.unmodifiableCollection(result);
public static Collection<ThreadGroup> findThreadGroupsByName(final String threadGroupName) {
return findThreadGroups(new NamePredicate(threadGroupName));
public static Collection<ThreadGroup> getAllThreadGroups() {
return findThreadGroups(ALWAYS_TRUE_PREDICATE);
public static ThreadGroup getSystemThreadGroup() {
ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();
while(threadGroup.getParent() != null) {
threadGroup = threadGroup.getParent();
return threadGroup;
public static Collection<Thread> getAllThreads() {
return findThreads(ALWAYS_TRUE_PREDICATE);
public static Collection<Thread> findThreadsByName(final String threadName) {
return findThreads(new NamePredicate(threadName));
public static Thread findThreadById(final long threadId) {
final Collection<Thread> result = findThreads(new ThreadIdPredicate(threadId));
if(result.isEmpty()) {
return null;
return result.iterator().next();
public ThreadUtils() {
super();
public interface ThreadPredicate /*extends java.util.function.Predicate<Thread>*/{
boolean test(Thread thread);
public interface ThreadGroupPredicate /*extends java.util.function.Predicate<ThreadGroup>*/{
boolean test(ThreadGroup threadGroup);
public static final AlwaysTruePredicate ALWAYS_TRUE_PREDICATE = new AlwaysTruePredicate();
private final static class AlwaysTruePredicate implements ThreadPredicate, ThreadGroupPredicate{
private AlwaysTruePredicate() {
public boolean test(final ThreadGroup threadGroup) {
return true;
public boolean test(final Thread thread) {
return true;
public static class NamePredicate implements ThreadPredicate, ThreadGroupPredicate {
private final String name;
public NamePredicate(final String name) {
super();
if (name == null) {
throw new IllegalArgumentException("The name must not be null");
this.name = name;
public boolean test(final ThreadGroup threadGroup) {
return threadGroup != null && threadGroup.getName().equals(name);
public boolean test(final Thread thread) {
return thread != null && thread.getName().equals(name);
public static class ThreadIdPredicate implements ThreadPredicate {
private final long threadId;
public ThreadIdPredicate(final long threadId) {
super();
if (threadId <= 0) {
throw new IllegalArgumentException("The thread id must be greater than zero");
this.threadId = threadId;
public boolean test(final Thread thread) {
return thread != null && thread.getId() == threadId;
public static Collection<Thread> findThreads(final ThreadPredicate predicate){
return findThreads(getSystemThreadGroup(), true, predicate);
public static Collection<ThreadGroup> findThreadGroups(final ThreadGroupPredicate predicate){
return findThreadGroups(getSystemThreadGroup(), true, predicate);
public static Collection<Thread> findThreads(final ThreadGroup group, final boolean recurse, final ThreadPredicate predicate) {
if (group == null) {
throw new IllegalArgumentException("The group must not be null");
if (predicate == null) {
throw new IllegalArgumentException("The predicate must not be null");
int count = group.activeCount();
Thread[] threads;
do {
threads = new Thread[count + (count / 2) + 1]; //slightly grow the array size
count = group.enumerate(threads, recurse);
final List<Thread> result = new ArrayList<Thread>(count);
for (int i = 0; i < count; ++i) {
if (predicate.test(threads[i])) {
result.add(threads[i]);
return Collections.unmodifiableCollection(result);
public static Collection<ThreadGroup> findThreadGroups(final ThreadGroup group, final boolean recurse, final ThreadGroupPredicate predicate){
if (group == null) {
throw new IllegalArgumentException("The group must not be null");
if (predicate == null) {
throw new IllegalArgumentException("The predicate must not be null");
int count = group.activeGroupCount();
ThreadGroup[] threadGroups;
do {
threadGroups = new ThreadGroup[count + (count / 2) + 1]; //slightly grow the array size
count = group.enumerate(threadGroups, recurse);
final List<ThreadGroup> result = new ArrayList<ThreadGroup>(count);
for(int i = 0; i < count; ++i) {
if(predicate.test(threadGroups[i])) {
result.add(threadGroups[i]);
return Collections.unmodifiableCollection(result);
&& (!Modifier.isStatic(f.getModifiers()))
&& (!f.isAnnotationPresent(EqualsExclude.class))) {
package org.apache.commons.lang3.builder;
public @interface EqualsExclude {
&& (!Modifier.isStatic(field.getModifiers()))
&& (!field.isAnnotationPresent(HashCodeExclude.class))) {
package org.apache.commons.lang3.builder;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
public @interface HashCodeExclude {
return list.toArray(new String[list.size()]);
private static Object checkNotNull(final Object obj) {
if (obj == null) {
throw new IllegalArgumentException("The Object passed in should not be null.");
return obj;
super(checkNotNull(object));
super(checkNotNull(object), style);
super(checkNotNull(object), style, buffer);
super(checkNotNull(object), style, buffer);
if(field.isAnnotationPresent(ToStringExclude.class)) {
return false;
package org.apache.commons.lang3.builder;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
public @interface ToStringExclude {
this.typeArguments = typeArguments.clone();
if (other == null) {
return false;
return obj instanceof StrBuilder && equals((StrBuilder) obj);
array = new char[] {1, 2, 3};
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
array = new char[] {1, 2, 3};
assertEquals(3, array[0]);
assertEquals(2, array[1]);
assertEquals(1, array[2]);
array = new float[] {1, 2, 3};
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
array = new float[] {1, 2, 3};
assertEquals(3, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(1, array[2], 0);
array = new double[] {1, 2, 3};
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
array = new double[] {1, 2, 3};
assertEquals(3, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(1, array[2], 0);
array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 3, 0);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0]);
assertEquals(2, array[1]);
assertEquals(1, array[2]);
array = new long[] {1, 2, 3};
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
array = new long[] {1, 2, 3};
assertEquals(3, array[0]);
assertEquals(2, array[1]);
assertEquals(1, array[2]);
array = new String[] {"1", "2", "3", "4"};
ArrayUtils.swap(array, -1, 2, 3);
assertEquals("3", array[0]);
assertEquals("4", array[1]);
assertEquals("1", array[2]);
assertEquals("2", array[3]);
array = new String[] {"1", "2", "3", "4", "5"};
ArrayUtils.swap(array, -3, 2, 3);
assertEquals("3", array[0]);
assertEquals("4", array[1]);
assertEquals("5", array[2]);
assertEquals("2", array[3]);
assertEquals("1", array[4]);
array = new short[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 2);
assertEquals(4, array[0]);
assertEquals(5, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
assertEquals(3, array[4]);
import org.apache.commons.lang3.test.DefaultLocale;
assertFalse(StringUtils.containsAny(null, 'a', 'b'));
assertFalse(StringUtils.containsAny("", 'a', 'b'));
assertTrue(StringUtils.containsAny("zzabyycdxx", 'z', 'a'));
assertTrue(StringUtils.containsAny("zzabyycdxx", 'b', 'y'));
assertTrue(StringUtils.containsAny("zzabyycdxx", 'z', 'y'));
assertFalse(StringUtils.containsAny("ab", 'z'));
assertTrue(StringUtils.containsAny("zzabyycdxx", "zy"));
assertTrue(StringUtils.containsAny("hello, goodbye", new String[]{"hello", "goodbye"}));
assertTrue(StringUtils.containsAny("hello, goodbye", new String[]{"hello", "Goodbye"}));
assertFalse(StringUtils.containsAny("hello, goodbye", new String[]{"Hello", "Goodbye"}));
assertFalse(StringUtils.containsAny("hello, goodbye", new String[]{"Hello", null}));
assertFalse(StringUtils.containsAny("hello, null", new String[] { "Hello", null }));
new DefaultLocale<RuntimeException>(Locale.ENGLISH) {
public void test() {
for (final Locale locale : locales) {
Locale.setDefault(locale);
for (int j = 0; j < tdata.length; j++) {
assertTrue(Locale.getDefault() + ": " + j + " " + tdata[j][0] + " " + tdata[j][1], StringUtils
.containsIgnoreCase(tdata[j][0], tdata[j][1]));
for (int j = 0; j < fdata.length; j++) {
assertFalse(Locale.getDefault() + ": " + j + " " + fdata[j][0] + " " + fdata[j][1], StringUtils
.containsIgnoreCase(fdata[j][0], fdata[j][1]));
assertEquals(-1, StringUtils.indexOfAny(null, 'a','b'));
assertEquals(-1, StringUtils.indexOfAny("", 'a','b'));
assertEquals(0, StringUtils.indexOfAny("zzabyycdxx", 'z','a'));
assertEquals(3, StringUtils.indexOfAny("zzabyycdxx", 'b','y'));
assertEquals(-1, StringUtils.indexOfAny("ab", 'z'));
assertEquals(-1, StringUtils.indexOfAnyBut(null));
assertEquals(-1, StringUtils.indexOfAnyBut(null, 'a','b'));
assertEquals(-1, StringUtils.indexOfAnyBut(""));
assertEquals(-1, StringUtils.indexOfAnyBut("", 'a','b'));
assertEquals(-1, StringUtils.indexOfAnyBut("zzabyycdxx"));
assertEquals(3, StringUtils.indexOfAnyBut("zzabyycdxx", 'z','a'));
assertEquals(0, StringUtils.indexOfAnyBut("zzabyycdxx", 'b','y'));
assertEquals(-1, StringUtils.indexOfAnyBut("aba", 'a', 'b'));
assertEquals(0, StringUtils.indexOfAnyBut("aba", 'z'));
public void testJoinWith() {
assertEquals("", StringUtils.joinWith(",", new Object[0]));        // empty array
assertEquals("", StringUtils.joinWith(",", (Object[]) NULL_ARRAY_LIST));
assertEquals("null", StringUtils.joinWith(",", NULL_TO_STRING_LIST));   //toString method prints 'null'
assertEquals("a,b,c", StringUtils.joinWith(",", new Object[]{"a", "b", "c"}));
assertEquals(",a,", StringUtils.joinWith(",", new Object[]{null, "a", ""}));
assertEquals("ab", StringUtils.joinWith(null, "a", "b"));
public void testJoinWithThrowsException() {
StringUtils.joinWith(",", (Object[]) null);
package org.apache.commons.lang3;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import org.junit.Test;
public class ThreadUtilsTest {
public void testNullThreadName() throws InterruptedException {
ThreadUtils.findThreadsByName(null);
public void testNullThreadGroupName() throws InterruptedException {
ThreadUtils.findThreadGroupsByName(null);
public void testNullThreadThreadGroupName1() throws InterruptedException {
ThreadUtils.findThreadsByName(null, "tgname");
public void testNullThreadThreadGroupName2() throws InterruptedException {
ThreadUtils.findThreadsByName("tname", (String) null);
public void testNullThreadThreadGroupName3() throws InterruptedException {
ThreadUtils.findThreadsByName(null, (String) null);
public void testNullThreadThreadGroup1() throws InterruptedException {
ThreadUtils.findThreadsByName("tname", (ThreadGroup) null);
public void testNullThreadThreadGroup2() throws InterruptedException {
ThreadUtils.findThreadById(1L, (ThreadGroup) null);
public void testNullThreadThreadGroup3() throws InterruptedException {
ThreadUtils.findThreadsByName(null, (ThreadGroup) null);
public void testInvalidThreadId() throws InterruptedException {
ThreadUtils.findThreadById(-5L);
public void testThreadGroupsByIdFail() throws InterruptedException {
ThreadUtils.findThreadById(Thread.currentThread().getId(), (String) null);
public void testThreadgroupsNullParent() throws InterruptedException {
ThreadUtils.findThreadGroups(null, true, ThreadUtils.ALWAYS_TRUE_PREDICATE);
public void testThreadgroupsNullPredicate() throws InterruptedException {
ThreadUtils.findThreadGroups(null);
public void testThreadsNullPredicate() throws InterruptedException {
ThreadUtils.findThreads(null);
public void testNoThread() throws InterruptedException {
assertEquals(0, ThreadUtils.findThreadsByName("some_thread_which_does_not_exist_18762ZucTT").size());
public void testNoThreadGroup() throws InterruptedException {
assertEquals(0, ThreadUtils.findThreadGroupsByName("some_thread_group_which_does_not_exist_18762ZucTTII").size());
public void testSystemThreadGroupExists() throws InterruptedException {
final ThreadGroup systemThreadGroup = ThreadUtils.getSystemThreadGroup();
assertNotNull(systemThreadGroup);
assertNull(systemThreadGroup.getParent());
assertEquals("system", systemThreadGroup.getName());
public void testAtLeastOneThreadExists() throws InterruptedException {
assertTrue(ThreadUtils.getAllThreads().size() > 0);
public void testAtLeastOneThreadGroupsExists() throws InterruptedException {
assertTrue(ThreadUtils.getAllThreadGroups().size() > 0);
public void testThreadsSameName() throws InterruptedException {
final Thread t1 = new TestThread("thread1_XXOOLL__");
final Thread alsot1 = new TestThread("thread1_XXOOLL__");
try {
t1.start();
alsot1.start();
assertEquals(2, ThreadUtils.findThreadsByName("thread1_XXOOLL__").size());
t1.interrupt();
alsot1.interrupt();
t1.join();
alsot1.join();
public void testThreads() throws InterruptedException {
final Thread t1 = new TestThread("thread1_XXOOLL__");
final Thread t2 = new TestThread("thread2_XXOOLL__");
try {
t1.start();
t2.start();
assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOLL__").size());
t1.interrupt();
t2.interrupt();
t1.join();
t2.join();
public void testThreadsById() throws InterruptedException {
final Thread t1 = new TestThread("thread1_XXOOLL__");
final Thread t2 = new TestThread("thread2_XXOOLL__");
try {
t1.start();
t2.start();
assertSame(t1, ThreadUtils.findThreadById(t1.getId()));
assertSame(t2, ThreadUtils.findThreadById(t2.getId()));
t1.interrupt();
t2.interrupt();
t1.join();
t2.join();
public void testThreadsByIdWrongGroup() throws InterruptedException {
final Thread t1 = new TestThread("thread1_XXOOLL__");
final ThreadGroup tg = new ThreadGroup("tg__HHEE22");
try {
t1.start();
assertNull(ThreadUtils.findThreadById(t1.getId(), tg));
t1.interrupt();
t1.join();
tg.destroy();
public void testThreadGroups() throws InterruptedException {
final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");
final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");
final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");
try {
t1.start();
t2.start();
assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__").size());
assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__","thread_group_DDZZ99__").size());
assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOPP__","thread_group_DDZZ99__").size());
assertEquals(0, ThreadUtils.findThreadsByName("thread1_XXOOPP__","non_existent_thread_group_JJHHZZ__").size());
assertEquals(0, ThreadUtils.findThreadsByName("non_existent_thread_BBDDWW__","thread_group_DDZZ99__").size());
assertEquals(1, ThreadUtils.findThreadGroupsByName("thread_group_DDZZ99__").size());
assertEquals(0, ThreadUtils.findThreadGroupsByName("non_existent_thread_group_JJHHZZ__").size());
assertNotNull(ThreadUtils.findThreadById(t1.getId(),threadGroup));
t1.interrupt();
t2.interrupt();
t1.join();
t2.join();
threadGroup.destroy();
public void testThreadGroupsRef() throws InterruptedException {
final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");
final ThreadGroup deadThreadGroup = new ThreadGroup("dead_thread_group_MMQQSS__");
deadThreadGroup.destroy();
final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");
final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");
try {
t1.start();
t2.start();
assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__").size());
assertEquals(1, ThreadUtils.findThreadsByName("thread1_XXOOPP__",threadGroup).size());
assertEquals(1, ThreadUtils.findThreadsByName("thread2_XXOOPP__",threadGroup).size());
assertEquals(0, ThreadUtils.findThreadsByName("thread1_XXOOPP__",deadThreadGroup).size());
t1.interrupt();
t2.interrupt();
t1.join();
t2.join();
threadGroup.destroy();
assertEquals(0, ThreadUtils.findThreadsByName("thread2_XXOOPP__",threadGroup).size());
public void testThreadGroupsById() throws InterruptedException {
final ThreadGroup threadGroup = new ThreadGroup("thread_group_DDZZ99__");
final Thread t1 = new TestThread(threadGroup, "thread1_XXOOPP__");
final Thread t2 = new TestThread(threadGroup, "thread2_XXOOPP__");
final long nonExistingId = t1.getId()+t2.getId();
try {
t1.start();
t2.start();
assertSame(t1, ThreadUtils.findThreadById(t1.getId(),"thread_group_DDZZ99__"));
assertSame(t2, ThreadUtils.findThreadById(t2.getId(),"thread_group_DDZZ99__"));
assertNull(ThreadUtils.findThreadById(nonExistingId,"non_existent_thread_group_JJHHZZ__"));
assertNull(ThreadUtils.findThreadById(nonExistingId,"thread_group_DDZZ99__"));
t1.interrupt();
t2.interrupt();
t1.join();
t2.join();
threadGroup.destroy();
public void testConstructor() throws InterruptedException {
assertNotNull(new ThreadUtils());
final Constructor<?>[] cons = ThreadUtils.class.getDeclaredConstructors();
assertEquals(1, cons.length);
assertTrue(Modifier.isPublic(cons[0].getModifiers()));
assertTrue(Modifier.isPublic(ThreadUtils.class.getModifiers()));
assertFalse(Modifier.isFinal(ThreadUtils.class.getModifiers()));
public void testComplexThreadGroups() throws Exception {
final ThreadGroup threadGroup1 = new ThreadGroup("thread_group_1__");
final ThreadGroup threadGroup2 = new ThreadGroup("thread_group_2__");
final ThreadGroup threadGroup3 = new ThreadGroup(threadGroup2, "thread_group_3__");
final ThreadGroup threadGroup4 = new ThreadGroup(threadGroup2, "thread_group_4__");
final ThreadGroup threadGroup5 = new ThreadGroup(threadGroup1, "thread_group_5__");
final ThreadGroup threadGroup6 = new ThreadGroup(threadGroup4, "thread_group_6__");
final ThreadGroup threadGroup7 = new ThreadGroup(threadGroup4, "thread_group_7__");
final ThreadGroup threadGroup7Doubled = new ThreadGroup(threadGroup4, "thread_group_7__");
final List<ThreadGroup> threadGroups = Arrays.asList(threadGroup1,threadGroup2,threadGroup3,threadGroup4,threadGroup5,threadGroup6, threadGroup7, threadGroup7Doubled);
final Thread t1 = new TestThread("thread1_X__");
final Thread t2 = new TestThread(threadGroup1, "thread2_X__");
final Thread t3 = new TestThread(threadGroup2, "thread3_X__");
final Thread t4 = new TestThread(threadGroup3, "thread4_X__");
final Thread t5 = new TestThread(threadGroup4, "thread5_X__");
final Thread t6 = new TestThread(threadGroup5, "thread6_X__");
final Thread t7 = new TestThread(threadGroup6, "thread7_X__");
final Thread t8 = new TestThread(threadGroup4, "thread8_X__");
final Thread t9 = new TestThread(threadGroup6, "thread9_X__");
final Thread t10 = new TestThread(threadGroup3, "thread10_X__");
final Thread t11 = new TestThread(threadGroup7, "thread11_X__");
final Thread t11Doubled = new TestThread(threadGroup7Doubled, "thread11_X__");
final List<Thread> threads = Arrays.asList(t1,t2,t3,t4,t5,t6,t7,t8,t9,t10, t11, t11Doubled);
try {
for (final Thread thread : threads) {
thread.start();
assertTrue(ThreadUtils.getAllThreadGroups().size() >= 7);
assertTrue(ThreadUtils.getAllThreads().size() >= 11);
assertTrue(ThreadUtils.findThreads(ThreadUtils.ALWAYS_TRUE_PREDICATE).size() >= 11);
assertEquals(1, ThreadUtils.findThreadsByName(t4.getName(), threadGroup3.getName()).size());
assertEquals(0, ThreadUtils.findThreadsByName(t4.getName(), threadGroup2.getName()).size());
assertEquals(2, ThreadUtils.findThreadsByName(t11.getName(), threadGroup7.getName()).size());
for (final Thread thread : threads) {
thread.interrupt();
thread.join();
for (final ThreadGroup threadGroup : threadGroups) {
if (!threadGroup.isDestroyed()) {
threadGroup.destroy();
private static class TestThread extends Thread {
private final CountDownLatch latch = new CountDownLatch(1);
public TestThread(final String name) {
super(name);
public TestThread(final ThreadGroup group, final String name) {
super(group, name);
public synchronized void start() {
super.start();
try {
latch.await();
Thread.currentThread().interrupt();
public void run() {
latch.countDown();
try {
synchronized(this){
this.wait();
Thread.currentThread().interrupt();
static class TestObjectEqualsExclude {
private int a;
private int b;
public TestObjectEqualsExclude(int a, int b) {
this.a = a;
this.b = b;
public int getA() {
return a;
public int getB() {
return b;
public void testToEqualsExclude() {
TestObjectEqualsExclude one = new TestObjectEqualsExclude(1, 2);
TestObjectEqualsExclude two = new TestObjectEqualsExclude(1, 3);
assertFalse(EqualsBuilder.reflectionEquals(one, two));
one = new TestObjectEqualsExclude(1, 2);
two = new TestObjectEqualsExclude(2, 2);
assertTrue(EqualsBuilder.reflectionEquals(one, two));
static class TestObjectHashCodeExclude {
private int a;
private int b;
public TestObjectHashCodeExclude(int a, int b) {
this.a = a;
this.b = b;
public int getA() {
return a;
public int getB() {
return b;
static class TestObjectHashCodeExclude2 {
private int a;
private int b;
public TestObjectHashCodeExclude2(int a, int b) {
this.a = a;
this.b = b;
public int getA() {
return a;
public int getB() {
return b;
public void testToHashCodeExclude() {
TestObjectHashCodeExclude one = new TestObjectHashCodeExclude(1, 2);
TestObjectHashCodeExclude2 two = new TestObjectHashCodeExclude2(1, 2);
assertEquals(17 * 37 + 2, HashCodeBuilder.reflectionHashCode(one));
assertEquals(17, HashCodeBuilder.reflectionHashCode(two));
package org.apache.commons.lang3.builder;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertThat;
import org.junit.Test;
public class ReflectionToStringBuilderExcludeWithAnnotationTest {
class TestFixture {
private final String excludedField = EXCLUDED_FIELD_VALUE;
private final String includedField = INCLUDED_FIELD_VALUE;
private static final String INCLUDED_FIELD_NAME = "includedField";
private static final String INCLUDED_FIELD_VALUE = "Hello World!";
private static final String EXCLUDED_FIELD_NAME = "excludedField";
private static final String EXCLUDED_FIELD_VALUE = "excluded field value";
public void test_toStringExclude() {
final String toString = ReflectionToStringBuilder.toString(new TestFixture());
assertThat(toString, not(containsString(EXCLUDED_FIELD_NAME)));
assertThat(toString, not(containsString(EXCLUDED_FIELD_VALUE)));
assertThat(toString, containsString(INCLUDED_FIELD_NAME));
assertThat(toString, containsString(INCLUDED_FIELD_VALUE));
package org.apache.commons.lang3.builder;
import org.junit.Test;
public class ReflectionToStringBuilderTest {
public void testConstructorWithNullObject() {
new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, new StringBuffer());
package org.apache.commons.lang3.test;
import java.util.Locale;
public abstract class DefaultLocale<E extends Throwable> {
public DefaultLocale(Locale targetLocale) throws E {
synchronized (getClass()) {
Locale defaultLocale = Locale.getDefault();
try {
Locale.setDefault(targetLocale);
test();
Locale.setDefault(defaultLocale);
abstract public void test() throws E;
package org.apache.commons.lang3.test;
import java.util.TimeZone;
public abstract class DefaultTimeZone<E extends Throwable> {
public DefaultTimeZone(TimeZone targetZone) throws E {
synchronized (getClass()) {
TimeZone defaultZone = TimeZone.getDefault();
try {
TimeZone.setDefault(targetZone);
test();
TimeZone.setDefault(defaultZone);
abstract public void test() throws E;
package org.apache.commons.lang3.test;
import java.util.Locale;
import java.util.TimeZone;
public abstract class DefaultTimeZoneAndLocale<E extends Throwable> {
public DefaultTimeZoneAndLocale(TimeZone targetZone, final Locale targetLocale) throws E {
new DefaultTimeZone<E>(targetZone) {
public void test() throws E {
new DefaultLocale<E>(targetLocale) {
public void test() throws E {
DefaultTimeZoneAndLocale.this.test();
abstract public void test() throws E;
public void test_LANG_1131_EqualsWithNullStrBuilder() throws Exception {
final StrBuilder sb = new StrBuilder();
final StrBuilder other = null;
assertFalse(sb.equals(other));
import org.apache.commons.lang3.test.DefaultLocale;
import org.apache.commons.lang3.test.DefaultTimeZone;
new DefaultLocale<RuntimeException>(Locale.ENGLISH) {
public void test() {
TimeZone timeZone = TimeZone.getTimeZone("GMT-3");
Calendar june = createJuneTestDate(timeZone);
assertFormats("Sun, 08 Jun 2003 10:11:12 -0300", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),
timeZone, june);
timeZone = TimeZone.getTimeZone("UTC");
june = createJuneTestDate(timeZone);
assertFormats("Sun, 08 Jun 2003 10:11:12 +0000", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),
timeZone, june);
new DefaultTimeZone<ParseException>(TimeZone.getTimeZone("UTC")) {
public void test() throws ParseException {
final Date d = new Date();
final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);
final Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() });
assertEquals("Date not equal to itself ISO formatted and parsed", d.getTime(), d2.getTime() + d.getTime() % 1000);
import org.apache.commons.lang3.test.DefaultLocale;
new DefaultLocale<ParseException>(Locale.ENGLISH){
public void test() throws ParseException {
DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDateStrictly("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
new DefaultLocale<ParseException>(Locale.ENGLISH){
public void test() throws ParseException {
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
new DefaultLocale<ParseException>(Locale.GERMAN){
public void test() throws ParseException {
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDateStrictly("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
new DefaultLocale<ParseException>(Locale.GERMAN){
public void test() throws ParseException {
DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
new DefaultLocale<ParseException>(Locale.ENGLISH){
public void test() throws ParseException {
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", Locale.GERMAN, "EEE, dd MMM yyyy HH:mm:ss zzz");
import org.apache.commons.lang3.test.DefaultLocale;
import org.apache.commons.lang3.test.DefaultTimeZoneAndLocale;
new DefaultTimeZoneAndLocale<RuntimeException>(TimeZone.getTimeZone("America/New_York"), Locale.US) {
public void test() {
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getTimeZone("Atlantic/Reykjavik"));
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());
final FastDateFormat format4 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());
final FastDateFormat format5 = FastDateFormat.getInstance("MM-DD-yyyy", TimeZone.getDefault());
final FastDateFormat format6 = FastDateFormat.getInstance("MM-DD-yyyy");
assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);
assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());
assertEquals(TimeZone.getDefault(), format2.getTimeZone());
assertSame(format3, format4);
assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);
assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5);
new DefaultLocale<RuntimeException>(Locale.US) {
public void test() throws RuntimeException {
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);
assertSame(format1, format3);
assertEquals(Locale.GERMANY, format1.getLocale());
new DefaultLocale<RuntimeException>(Locale.US) {
public void test() throws RuntimeException {
final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);
Locale.setDefault(Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);
assertSame(Locale.GERMANY, format1.getLocale());
assertSame(Locale.US, format2.getLocale());
assertSame(Locale.GERMANY, format3.getLocale());
assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);
assertTrue(format2 != format3);
new DefaultLocale<RuntimeException>(Locale.US) {
public void test() throws RuntimeException {
final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);
Locale.setDefault(Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);
assertSame(Locale.GERMANY, format1.getLocale());
assertSame(Locale.US, format2.getLocale());
assertSame(Locale.GERMANY, format3.getLocale());
assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);
assertTrue(format2 != format3);
new DefaultTimeZoneAndLocale<RuntimeException>(TimeZone.getTimeZone("America/New_York"), Locale.US) {
public void test() {
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getTimeZone("Atlantic/Reykjavik"), Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getDefault(), Locale.GERMANY);
assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);
assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());
assertEquals(TimeZone.getDefault(), format2.getTimeZone());
assertEquals(TimeZone.getDefault(), format3.getTimeZone());
assertEquals(Locale.GERMANY, format1.getLocale());
assertEquals(Locale.GERMANY, format2.getLocale());
assertEquals(Locale.GERMANY, format3.getLocale());
import org.apache.commons.lang3.test.DefaultTimeZoneAndLocale;
DatePrinter getInstance(final String format) {
new DefaultTimeZoneAndLocale<RuntimeException>(NEW_YORK, Locale.US) {
public void test() {
final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);
final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 0, 0);
final Date date1 = cal1.getTime();
final Date date2 = cal2.getTime();
final long millis1 = date1.getTime();
final long millis2 = date2.getTime();
DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss");
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
assertEquals(sdf.format(date1), fdf.format(date1));
assertEquals("2003-01-10T15:33:20", fdf.format(date1));
assertEquals("2003-01-10T15:33:20", fdf.format(cal1));
assertEquals("2003-01-10T15:33:20", fdf.format(millis1));
assertEquals("2003-07-10T09:00:00", fdf.format(date2));
assertEquals("2003-07-10T09:00:00", fdf.format(cal2));
assertEquals("2003-07-10T09:00:00", fdf.format(millis2));
fdf = getInstance("Z");
assertEquals("-0500", fdf.format(date1));
assertEquals("-0500", fdf.format(cal1));
assertEquals("-0500", fdf.format(millis1));
assertEquals("-0400", fdf.format(date2));
assertEquals("-0400", fdf.format(cal2));
assertEquals("-0400", fdf.format(millis2));
fdf = getInstance("ZZ");
assertEquals("-05:00", fdf.format(date1));
assertEquals("-05:00", fdf.format(cal1));
assertEquals("-05:00", fdf.format(millis1));
assertEquals("-04:00", fdf.format(date2));
assertEquals("-04:00", fdf.format(cal2));
assertEquals("-04:00", fdf.format(millis2));
final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" +
" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z";
fdf = getInstance(pattern);
sdf = new SimpleDateFormat(pattern);
assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1));
assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2));assertEquals(t1.getName(), ThreadUtils.findThreadById(t1.getId()).getName());
assertEquals(t1.getName(), ThreadUtils.findThreadById(t1.getId(),"thread_group_DDZZ99__").getName());
assertEquals(t2.getName(), ThreadUtils.findThreadById(t2.getId(),"thread_group_DDZZ99__").getName());if (obj instanceof StrBuilder) {
return equals((StrBuilder) obj);
return false;this.typeArguments = typeArguments;for (final Class<?> primitiveClass : primitiveWrapperMap.keySet()) {
final Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);
&& !Modifier.isStatic(f.getModifiers())) {
&& !Modifier.isStatic(field.getModifiers())) {
return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);
import org.apache.commons.lang3.test.SwitchDefaults;
import org.apache.commons.lang3.test.SystemDefaults;
import org.junit.Rule;
public SwitchDefaults defaults = new SwitchDefaults();
for (final Locale testLocale : locales) {
Locale.setDefault(testLocale);
for (int j = 0; j < tdata.length; j++) {
assertTrue(Locale.getDefault() + ": " + j + " " + tdata[j][0] + " " + tdata[j][1], StringUtils
.containsIgnoreCase(tdata[j][0], tdata[j][1]));
for (int j = 0; j < fdata.length; j++) {
assertFalse(Locale.getDefault() + ": " + j + " " + fdata[j][0] + " " + fdata[j][1], StringUtils
.containsIgnoreCase(fdata[j][0], fdata[j][1]));
package org.apache.commons.lang3.test;
import java.util.Locale;
import java.util.TimeZone;
import org.apache.commons.lang3.LocaleUtils;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;
public class SwitchDefaults implements TestRule {
public Statement apply(Statement stmt, Description description) {
SystemDefaults defaults = description.getAnnotation(SystemDefaults.class);
if(defaults == null) {
return stmt;
return applyTimeZone(defaults, applyLocale(defaults, stmt));
private Statement applyTimeZone(SystemDefaults defaults, final Statement stmt) {
if(defaults.timezone().isEmpty()) {
return stmt;
final TimeZone newTimeZone = TimeZone.getTimeZone(defaults.timezone());
return new Statement() {
public void evaluate() throws Throwable {
TimeZone save = TimeZone.getDefault();
try {
TimeZone.setDefault(newTimeZone);
stmt.evaluate();
TimeZone.setDefault(save);
private Statement applyLocale(SystemDefaults defaults, final Statement stmt) {
if(defaults.locale().isEmpty()) {
return stmt;
final Locale newLocale = LocaleUtils.toLocale(defaults.locale());
return new Statement() {
public void evaluate() throws Throwable {
Locale save = Locale.getDefault();
try {
Locale.setDefault(newLocale);
stmt.evaluate();
Locale.setDefault(save);
package org.apache.commons.lang3.test;
public @interface SystemDefaults {
String locale() default "";
String timezone() default "";
import org.apache.commons.lang3.test.SwitchDefaults;
import org.apache.commons.lang3.test.SystemDefaults;
import org.junit.Rule;
public SwitchDefaults defaults = new SwitchDefaults();
TimeZone timeZone = TimeZone.getTimeZone("GMT-3");
Calendar june = createJuneTestDate(timeZone);
assertFormats("Sun, 08 Jun 2003 10:11:12 -0300", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),
timeZone, june);
timeZone = TimeZone.getTimeZone("UTC");
june = createJuneTestDate(timeZone);
assertFormats("Sun, 08 Jun 2003 10:11:12 +0000", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),
timeZone, june);
final Date d = new Date();
final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);
final Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() });
assertEquals("Date not equal to itself ISO formatted and parsed", d.getTime(), d2.getTime() + d.getTime() % 1000);
import org.apache.commons.lang3.test.SwitchDefaults;
import org.apache.commons.lang3.test.SystemDefaults;
import org.junit.Rule;
public SwitchDefaults defaults = new SwitchDefaults();
DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDateStrictly("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDateStrictly("Mi, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", "EEE, dd MMM yyyy HH:mm:ss zzz");
DateUtils.parseDate("Mi, 09 Apr 2008 23:55:38 GMT", Locale.GERMAN, "EEE, dd MMM yyyy HH:mm:ss zzz");
import static org.junit.Assert.assertNotSame;
import org.apache.commons.lang3.test.SwitchDefaults;
import org.apache.commons.lang3.test.SystemDefaults;
import org.junit.Rule;
public SwitchDefaults defaults = new SwitchDefaults();
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getTimeZone("Atlantic/Reykjavik"));
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());
final FastDateFormat format4 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());
final FastDateFormat format5 = FastDateFormat.getInstance("MM-DD-yyyy", TimeZone.getDefault());
final FastDateFormat format6 = FastDateFormat.getInstance("MM-DD-yyyy");
assertNotSame(format1, format2);
assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());
assertEquals(TimeZone.getDefault(), format2.getTimeZone());
assertSame(format3, format4);
assertNotSame(format3, format5);
assertNotSame(format4, format6);
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
assertNotSame(format1, format2);
assertSame(format1, format3);
assertEquals(Locale.GERMANY, format1.getLocale());
final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);
Locale.setDefault(Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);
assertSame(Locale.GERMANY, format1.getLocale());
assertEquals(Locale.US, format2.getLocale());
assertSame(Locale.GERMANY, format3.getLocale());
assertNotSame(format1, format2);
assertNotSame(format2, format3);
final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);
Locale.setDefault(Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);
assertSame(Locale.GERMANY, format1.getLocale());
assertEquals(Locale.US, format2.getLocale());
assertSame(Locale.GERMANY, format3.getLocale());
assertNotSame(format1, format2);
assertNotSame(format2, format3);
final FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getTimeZone("Atlantic/Reykjavik"), Locale.GERMANY);
final FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);
final FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy",
TimeZone.getDefault(), Locale.GERMANY);
assertNotSame(format1, format2);
assertEquals(TimeZone.getTimeZone("Atlantic/Reykjavik"), format1.getTimeZone());
assertEquals(TimeZone.getDefault(), format2.getTimeZone());
assertEquals(TimeZone.getDefault(), format3.getTimeZone());
assertEquals(Locale.GERMANY, format1.getLocale());
assertEquals(Locale.GERMANY, format2.getLocale());
assertEquals(Locale.GERMANY, format3.getLocale());
import org.apache.commons.lang3.test.SwitchDefaults;
import org.apache.commons.lang3.test.SystemDefaults;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Rule;
DatePrinter getInstance(final String format) {
public SwitchDefaults defaults = new SwitchDefaults();
final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);
final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 0, 0);
final Date date1 = cal1.getTime();
final Date date2 = cal2.getTime();
final long millis1 = date1.getTime();
final long millis2 = date2.getTime();
DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss");
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
assertEquals(sdf.format(date1), fdf.format(date1));
assertEquals("2003-01-10T15:33:20", fdf.format(date1));
assertEquals("2003-01-10T15:33:20", fdf.format(cal1));
assertEquals("2003-01-10T15:33:20", fdf.format(millis1));
assertEquals("2003-07-10T09:00:00", fdf.format(date2));
assertEquals("2003-07-10T09:00:00", fdf.format(cal2));
assertEquals("2003-07-10T09:00:00", fdf.format(millis2));
fdf = getInstance("Z");
assertEquals("-0500", fdf.format(date1));
assertEquals("-0500", fdf.format(cal1));
assertEquals("-0500", fdf.format(millis1));
assertEquals("-0400", fdf.format(date2));
assertEquals("-0400", fdf.format(cal2));
assertEquals("-0400", fdf.format(millis2));
fdf = getInstance("ZZ");
assertEquals("-05:00", fdf.format(date1));
assertEquals("-05:00", fdf.format(cal1));
assertEquals("-05:00", fdf.format(millis1));
assertEquals("-04:00", fdf.format(date2));
assertEquals("-04:00", fdf.format(cal2));
assertEquals("-04:00", fdf.format(millis2));
final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" +
" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z";
fdf = getInstance(pattern);
sdf = new SimpleDateFormat(pattern);
assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1));
assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2));public static void swap(final Object[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final long[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final int[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final short[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final char[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final byte[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final double[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final float[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final boolean[] array, int offset1, int offset2) {
if (array == null) {
return;
swap(array, offset1, offset2, 1);
public static void swap(final boolean[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
boolean aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final byte[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
byte aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final char[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
char aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final double[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
double aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final float[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
float aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final int[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
int aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final long[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
long aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final Object[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
Object aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void swap(final short[] array,  int offset1, int offset2, int len) {
if (array == null) {
return;
for (int i = 0; i < len; i++) {
short aux = array[offset1 + i];
array[offset1 + i] = array[offset2 + i];
array[offset2 + i] = aux;
public static void shift(final Object[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final long[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final int[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final short[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final char[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final byte[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final double[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final float[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final boolean[] array, int offset) {
if (array == null) {
return;
shift(array, 0, array.length, offset);
public static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
public static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset) {
if (array == null) {
return;
if (startIndexInclusive >= array.length - 1 || endIndexExclusive <= 0) {
return;
if (startIndexInclusive < 0) {
startIndexInclusive = 0;
if (endIndexExclusive >= array.length) {
endIndexExclusive = array.length;
int n = endIndexExclusive - startIndexInclusive;
if (n <= 1) {
return;
offset %= n;
if (offset < 0) {
offset += n;
while (n > 1 && offset > 0) {
int n_offset = n - offset;
if (offset > n_offset) {
swap(array, startIndexInclusive, startIndexInclusive + n - n_offset,  n_offset);
n = offset;
offset -= n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset,  offset);
startIndexInclusive += offset;
n = n_offset;
swap(array, startIndexInclusive, startIndexInclusive + n_offset, offset);
break;
if (repeat <= 0) {
return EMPTY;
public static String rotate(String str, int shift) {
if (str == null) {
return null;
final int strLen = str.length();
if (shift == 0 || strLen == 0 || shift % strLen == 0) {
return str;
final StringBuilder builder = new StringBuilder(strLen);
final int offset = - (shift % strLen);
builder.append(substring(str, offset));
builder.append(substring(str, 0, offset));
return builder.toString();
return true;
public void testSwapChar() {
char[] array = new char[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2);
assertArrayEquals(new char[] {3, 2, 1}, array);
array = new char[] {1, 2, 3};
ArrayUtils.swap(array, 0, 0);
assertArrayEquals(new char[] {1, 2, 3}, array);
array = new char[] {1, 2, 3};
ArrayUtils.swap(array, 1, 0);
assertArrayEquals(new char[] {2, 1, 3}, array);
public void testSwapCharRange() {
char[] array = new char[] {1, 2, 3, 4};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testSwapCharOutOfRange() {
char[] array = new char[] {1, 2, 3};
ArrayUtils.swap(array, 0, 3);
public void testSwapCharOutOfRangeLen() {
char[] array = new char[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
public void testSwapFloat() {
float[] array = new float[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2);
assertEquals(3, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(1, array[2], 0);
public void testSwapFloatRange() {
float[] array = new float[] {1, 2, 3, 4};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0], 0);
assertEquals(4, array[1], 0);
assertEquals(1, array[2], 0);
assertEquals(2, array[3], 0);
public void testSwapFloatOutOfRange() {
float[] array = new float[] {1, 2, 3};
ArrayUtils.swap(array, 0, 3);
public void testSwapFloatOutOfRangeLen() {
float[] array = new float[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
public void testSwapDouble() {
double[] array = new double[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2);
assertEquals(3, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(1, array[2], 0);
public void testSwapDoubleRange() {
double[] array = new double[] {1, 2, 3, 4};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0], 0);
assertEquals(4, array[1], 0);
assertEquals(1, array[2], 0);
assertEquals(2, array[3], 0);
public void testSwapDoubleOutOfRange() {
double[] array = new double[] {1, 2, 3};
ArrayUtils.swap(array, 0, 3);
public void testSwapDoubleOutOfRangeLen() {
double[] array = new double[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
public void testSwapInt() {
int[] array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2);
assertEquals(3, array[0]);
assertEquals(2, array[1]);
assertEquals(1, array[2]);
public void testSwapIntRange() {
int[] array = new int[] {1, 2, 3, 4};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testSwapIntExchangedOffsets() {
int[] array;
array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 0, 1, 2);
assertArrayEquals(new int[] {2, 3, 1}, array);
array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 1, 0, 2);
assertArrayEquals(new int[] {2, 3, 1}, array);
public void testSwapIntOutOfRange() {
int[] array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 0, 3);
public void testSwapIntOutOfRangeLen() {
int[] array = new int[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
public void testSwapLong() {
long[] array = new long[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2);
assertEquals(3, array[0]);
assertEquals(2, array[1]);
assertEquals(1, array[2]);
public void testSwapLongRange() {
long[] array = new long[] {1, 2, 3, 4};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testSwapLongOutOfRange() {
long[] array = new long[] {1, 2, 3};
ArrayUtils.swap(array, 0, 3);
public void testSwapLongOutOfRangeLen() {
long[] array = new long[] {1, 2, 3};
ArrayUtils.swap(array, 0, 2, 2);
public void testSwapObject() {
String[] array = new String[] {"1", "2", "3"};
ArrayUtils.swap(array, 0, 2);
assertEquals("3", array[0]);
assertEquals("2", array[1]);
assertEquals("1", array[2]);
public void testSwapObjectRange() {
String[] array = new String[] {"1", "2", "3", "4"};
ArrayUtils.swap(array, 0, 2, 2);
assertEquals("3", array[0]);
assertEquals("4", array[1]);
assertEquals("1", array[2]);
assertEquals("2", array[3]);
public void testSwapObjectOutOfRange() {
String[] array = new String[] {"1", "2", "3"};
ArrayUtils.swap(array, 0, 3);
public void testSwapObjectOutOfRangeLen() {
String[] array = new String[] {"1", "2", "3"};
ArrayUtils.swap(array, 0, 2, 2);
public void testShiftDouble() {
double[] array = new double[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0], 0);
assertEquals(1, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(3, array[3], 0);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0], 0);
assertEquals(1, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(3, array[3], 0);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0], 0);
assertEquals(4, array[1], 0);
assertEquals(1, array[2], 0);
assertEquals(2, array[3], 0);
public void testShiftRangeDouble() {
double[] array = new double[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0], 0);
assertEquals(3, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(4, array[3], 0);
assertEquals(5, array[4], 0);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(4, array[2], 0);
assertEquals(3, array[3], 0);
assertEquals(5, array[4], 0);
public void testShiftRangeNoElemDouble() {
double[] array = new double[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
public void testShiftAllDouble() {
double[] array = new double[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
public void testShiftFloat() {
float[] array = new float[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0], 0);
assertEquals(1, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(3, array[3], 0);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0], 0);
assertEquals(1, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(3, array[3], 0);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0], 0);
assertEquals(4, array[1], 0);
assertEquals(1, array[2], 0);
assertEquals(2, array[3], 0);
public void testShiftRangeFloat() {
float[] array = new float[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0], 0);
assertEquals(3, array[1], 0);
assertEquals(2, array[2], 0);
assertEquals(4, array[3], 0);
assertEquals(5, array[4], 0);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(4, array[2], 0);
assertEquals(3, array[3], 0);
assertEquals(5, array[4], 0);
public void testShiftRangeNoElemFloat() {
float[] array = new float[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
public void testShiftAllFloat() {
float[] array = new float[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0], 0);
assertEquals(2, array[1], 0);
assertEquals(3, array[2], 0);
assertEquals(4, array[3], 0);
public void testShiftShort() {
short[] array = new short[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testShiftRangeShort() {
short[] array = new short[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0]);
assertEquals(3, array[1]);
assertEquals(2, array[2]);
assertEquals(4, array[3]);
assertEquals(5, array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(4, array[2]);
assertEquals(3, array[3]);
assertEquals(5, array[4]);
public void testShiftRangeNoElemShort() {
short[] array = new short[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftAllShort() {
short[] array = new short[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftByte() {
byte[] array = new byte[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testShiftRangeByte() {
byte[] array = new byte[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0]);
assertEquals(3, array[1]);
assertEquals(2, array[2]);
assertEquals(4, array[3]);
assertEquals(5, array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(4, array[2]);
assertEquals(3, array[3]);
assertEquals(5, array[4]);
public void testShiftRangeNoElemByte() {
byte[] array = new byte[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftAllByte() {
byte[] array = new byte[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftChar() {
char[] array = new char[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testShiftRangeChar() {
char[] array = new char[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0]);
assertEquals(3, array[1]);
assertEquals(2, array[2]);
assertEquals(4, array[3]);
assertEquals(5, array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(4, array[2]);
assertEquals(3, array[3]);
assertEquals(5, array[4]);
public void testShiftRangeNoElemChar() {
char[] array = new char[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftAllChar() {
char[] array = new char[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftLong() {
long[] array = new long[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testShiftRangeLong() {
long[] array = new long[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0]);
assertEquals(3, array[1]);
assertEquals(2, array[2]);
assertEquals(4, array[3]);
assertEquals(5, array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(4, array[2]);
assertEquals(3, array[3]);
assertEquals(5, array[4]);
public void testShiftRangeNoElemLong() {
long[] array = new long[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftAllLong() {
long[] array = new long[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftInt() {
int[] array = new int[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, 5);
assertEquals(4, array[0]);
assertEquals(1, array[1]);
assertEquals(2, array[2]);
assertEquals(3, array[3]);
ArrayUtils.shift(array, -3);
assertEquals(3, array[0]);
assertEquals(4, array[1]);
assertEquals(1, array[2]);
assertEquals(2, array[3]);
public void testShiftRangeInt() {
int[] array = new int[] {1, 2, 3, 4, 5};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals(1, array[0]);
assertEquals(3, array[1]);
assertEquals(2, array[2]);
assertEquals(4, array[3]);
assertEquals(5, array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(4, array[2]);
assertEquals(3, array[3]);
assertEquals(5, array[4]);
public void testShiftRangeNoElemInt() {
int[] array = new int[] {1, 2, 3, 4};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftAllInt() {
int[] array = new int[] {1, 2, 3, 4};
ArrayUtils.shift(array, 4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
ArrayUtils.shift(array, -4);
assertEquals(1, array[0]);
assertEquals(2, array[1]);
assertEquals(3, array[2]);
assertEquals(4, array[3]);
public void testShiftObject() {
String[] array = new String[] {"1", "2", "3", "4"};
ArrayUtils.shift(array, 1);
assertEquals("4", array[0]);
assertEquals("1", array[1]);
assertEquals("2", array[2]);
assertEquals("3", array[3]);
ArrayUtils.shift(array, -1);
assertEquals("1", array[0]);
assertEquals("2", array[1]);
assertEquals("3", array[2]);
assertEquals("4", array[3]);
ArrayUtils.shift(array, 5);
assertEquals("4", array[0]);
assertEquals("1", array[1]);
assertEquals("2", array[2]);
assertEquals("3", array[3]);
ArrayUtils.shift(array, -3);
assertEquals("3", array[0]);
assertEquals("4", array[1]);
assertEquals("1", array[2]);
assertEquals("2", array[3]);
public void testShiftRangeObject() {
String[] array = new String[] {"1", "2", "3", "4", "5"};
ArrayUtils.shift(array, 1, 3, 1);
assertEquals("1", array[0]);
assertEquals("3", array[1]);
assertEquals("2", array[2]);
assertEquals("4", array[3]);
assertEquals("5", array[4]);
ArrayUtils.shift(array, 1, 4, 2);
assertEquals("1", array[0]);
assertEquals("2", array[1]);
assertEquals("4", array[2]);
assertEquals("3", array[3]);
assertEquals("5", array[4]);
public void testShiftRangeNoElemObject() {
String[] array = new String[] {"1", "2", "3", "4"};
ArrayUtils.shift(array, 1, 1, 1);
assertEquals("1", array[0]);
assertEquals("2", array[1]);
assertEquals("3", array[2]);
assertEquals("4", array[3]);
public void testShiftAllObject() {
String[] array = new String[] {"1", "2", "3", "4"};
ArrayUtils.shift(array, 4);
assertEquals("1", array[0]);
assertEquals("2", array[1]);
assertEquals("3", array[2]);
assertEquals("4", array[3]);
ArrayUtils.shift(array, -4);
assertEquals("1", array[0]);
assertEquals("2", array[1]);
assertEquals("3", array[2]);
assertEquals("4", array[3]);
assertEquals("", StringUtils.repeat("a", -2));
public void testRepeat_CharInt() {
assertEquals("zzz", StringUtils.repeat('z', 3));
assertEquals("", StringUtils.repeat('z', 0));
assertEquals("", StringUtils.repeat('z', -2));
public void testRotate_StringInt() {
assertEquals(null, StringUtils.rotate(null, 1));
assertEquals("", StringUtils.rotate("", 1));
assertEquals("abcdefg", StringUtils.rotate("abcdefg", 0));
assertEquals("fgabcde", StringUtils.rotate("abcdefg", 2));
assertEquals("cdefgab", StringUtils.rotate("abcdefg", -2));
assertEquals("abcdefg", StringUtils.rotate("abcdefg", 7));
assertEquals("abcdefg", StringUtils.rotate("abcdefg", -7));
assertEquals("fgabcde", StringUtils.rotate("abcdefg", 9));
assertEquals("cdefgab", StringUtils.rotate("abcdefg", -9));
assertEquals("efgabcd", StringUtils.rotate("abcdefg", 17));
assertEquals("defgabc", StringUtils.rotate("abcdefg", -17));if (value == y) {
if (previous != null && previous.getValue() == value) {private static class TimeZoneStrategy extends Strategy {
private final String validTimeZoneChars;
if (zone[ID].startsWith("GMT")) {
continue;
final StringBuilder sb= new StringBuilder();
sb.append("(GMT[+-]\\d{1,2}:\\d{2}").append('|');
sb.append("[+-]\\d{4}").append('|');
for(final String id : tzNames.keySet()) {
escapeRegex(sb, id, false).append('|');
sb.setCharAt(sb.length()-1, ')');
validTimeZoneChars= sb.toString();
regex.append(validTimeZoneChars);
else if(value.startsWith("GMT")) {
tz= TimeZone.getTimeZone(value);
import org.junit.Ignore;
for(final Locale locale : Locale.getAvailableLocales()) {
final FastDateParser fdp= new FastDateParser("yyyy/MM/dd z", TimeZone.getDefault(), locale);
for(final TimeZone tz :  new TimeZone[]{NEW_YORK, REYKJAVIK, GMT}) {
final Calendar cal= Calendar.getInstance(tz, locale);
cal.clear();
cal.set(Calendar.YEAR, 2000);
cal.set(Calendar.MONTH, 1);
cal.set(Calendar.DAY_OF_MONTH, 10);
final Date expected= cal.getTime();
final Date actual = fdp.parse("2000/02/10 "+tz.getDisplayName(locale));
Assert.assertEquals("tz:"+tz.getID()+" locale:"+locale.getDisplayName(), expected, actual);private final HashMap<String, CharSequence> lookupMap;
lookupMap = new HashMap<String, CharSequence>();
this.lookupMap.put(seq[0].toString(), seq[1]);
int max = longest;
if (index + longest > input.length()) {
max = input.length() - index;
if (!prefixSet.contains(input.charAt(index))) {
return 0;
for (int i = max; i >= shortest; i--) {
final CharSequence subSeq = input.subSequence(index, index + i);
final CharSequence result = lookupMap.get(subSeq.toString());
if (result != null) {
out.write(result.toString());
return i;final Method[] annotatedMethods = new Method[]{
MethodUtilsTest.class.getMethod("testGetMethodsWithAnnotation"),
MethodUtilsTest.class.getMethod("testGetMethodsListWithAnnotation")
assertArrayEquals(annotatedMethods, MethodUtils.getMethodsWithAnnotation(MethodUtilsTest.class, Annotated.class));
final List<Method> annotatedMethods = Arrays.asList(
);
final List<Method> methodUtilsTestAnnotatedFields = MethodUtils.getMethodsListWithAnnotation(MethodUtilsTest.class, Annotated.class);
assertEquals(annotatedMethods.size(), methodUtilsTestAnnotatedFields.size());
assertTrue(methodUtilsTestAnnotatedFields.contains(annotatedMethods.get(0)));
assertTrue(methodUtilsTestAnnotatedFields.contains(annotatedMethods.get(1)));public void testLang100() throws Exception {
final String encoding = "UTF-8";
final byte[] bytes = orig.getBytes(encoding);
final String copy = new String(bytes, encoding);
public void testZeroLengthNextBytes() throws Exception {
public void testNextBytes() throws Exception {
public void testNextIntMinimalRange() throws Exception {
public void testNextInt() throws Exception {
public void testNextDoubleMinimalRange() throws Exception {
public void testNextFloatMinimalRange() throws Exception {
public void testNextDouble() throws Exception {
public void testNextFloat() throws Exception {
public void testNextLongMinimalRange() throws Exception {
public void testNextLong() throws Exception {
public void testExtremeRangeInt() throws Exception {
public void testExtremeRangeLong() throws Exception {
public void testExtremeRangeFloat() throws Exception {
public void testExtremeRangeDouble() throws Exception {
public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {
final String original = new String(data, "UTF8");
String encoding = SystemUtils.FILE_ENCODING;
byte[] expectedBytes = expectedString.getBytes(encoding);
assertEquals(expectedString, StringUtils.toString(expectedBytes, encoding));
encoding = "UTF-16";
expectedBytes = expectedString.getBytes(encoding);
public void testEscapeSurrogatePairsLang858() throws Exception {
public void testToEncodedString() throws UnsupportedEncodingException {
byte[] expectedBytes = expectedString.getBytes(encoding);
expectedBytes = expectedString.getBytes(encoding);
public void testReflectionArrayCycle() throws Exception {
public void testReflectionArrayCycleLevel2() throws Exception {
public void testSimpleReflectionObjectCycle() throws Exception {
public void testSelfInstanceVarReflectionObjectCycle() throws Exception {
public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {
public void testReflectionObjectCycle() throws Exception {
public void testReflectionArrayAndObjectCycle() throws Exception {
public void testSetExternalExecutor() throws Exception {
public void testGetRuntimeException() throws Exception {
public void testGetCheckedException() throws Exception {
public void testGetInterruptedException() throws Exception {
public void testLang954() throws Exception {while (inputLineLength - offset > wrapLength) {public static String toFullyQualifiedName(final Class context, final String resourceName) {
public static String toFullyQualifiedPath(final Class context, final String resourceName) {hash = hash * 31 + ObjectUtils.hashCode(object);assertTrue(StringUtils.isAnyEmpty(null));
assertFalse(StringUtils.isNoneEmpty(null));
assertTrue(StringUtils.isAnyBlank(null));
assertFalse(StringUtils.isNoneBlank(null));public void testisEmpty(){
public void testisNotEmpty(){
public void testisAnyEmpty(){
public void testisNoneEmpty(){
public void testisBlank(){
public void testisNotBlank(){
public void testisAnyBlank(){
public void testisNoneBlank(){return ObjectUtils.toString(first);
return ObjectUtils.toString(first);
public StrBuilder appendWithSeparators(final Object[] array, String separator) {
separator = ObjectUtils.toString(separator);
append(separator);
public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) {
separator = ObjectUtils.toString(separator);
append(separator);
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {
separator = ObjectUtils.toString(separator);
append(separator);package org.apache.commons.lang3.reflect;
import java.lang.reflect.Type;
public interface Typed<T> {
Type getType();if(input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1)) ) {
final int start = index + 1;
int end = index + 2;
while ( end < input.length() && Character.isDigit(input.charAt(end)) ) {
end++;
if ( Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {
end--; // rollback
break;
if (end - start >= 3) {
break;
out.write( Integer.parseInt(input.subSequence(start, end).toString(), 8) );
return 1 + end - start;
public void testOutOfRange() {
final OctalUnescaper oue = new OctalUnescaper();
String input = "\\999";
try {
String result = oue.translate(input);
fail("NumberFormatException was expected for input: " + input);assertEquals("Failed to unescape octal characters via the between method", "\378 and", result);
assertEquals("Failed to unescape octal characters via the between method", "\378", result);reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
testClass = testClass.getSuperclass();for(int i=0; i<sz; i++) {
if(inLiteral && ch != '\'') {
switch(ch) {
case '\'' : 
if(inLiteral) {
buffer = null;
inLiteral = false;
buffer = new StringBuilder();
list.add(new Token(buffer));
inLiteral = true;
break;
case 'y'  : value = y; break;
case 'M'  : value = M; break;
case 'd'  : value = d; break;
case 'H'  : value = H; break;
case 'm'  : value = m; break;
case 's'  : value = s; break;
case 'S'  : value = S; break;
default   : 
if(buffer == null) {
buffer = new StringBuilder();
list.add(new Token(buffer));
buffer.append(ch);
if(value != null) {
if(previous != null && previous.getValue() == value) {
list.add(token); 
buffer = null; 
return list.toArray( new Token[list.size()] );if (reverseAbbreviationMap.containsKey(className)) {
className = reverseAbbreviationMap.get(className);fail("createFloat(blank) failed: " + value);
fail("createDouble(blank) failed: " + value);
fail("createInteger(blank) failed: " + value);
fail("createLong(blank) failed: " + value);
fail("createBigInteger(blank) failed: " + value);
fail("createBigDecimal(blank) failed: " + value);public T build();String localeName = locale.toString();
if (localeName.equals("ja_JP_JP") || localeName.startsWith("th_TH")) {
if (year < 1868 && locale.toString().equals("ja_JP_JP")) {
if (eraBC && format.equals(SHORT_FORMAT) && locale.toString().equals("ja_JP_JP")) {private static final String SHORT_FORMAT = "G/y/M/d/a/E/Z";
private static final String LONG_FORMAT = "GGGG/yyyy/MMMM/dddd/aaaa/EEEE/ZZZZ";
private static final String SHORT_FORMAT_NOERA = "y/M/d/a/E/Z";
private static final String LONG_FORMAT_NOERA = "yyyy/MMMM/dddd/aaaa/EEEE/ZZZZ";
return getInstance(FormatCache.getPatternForStyle(dateStyle, null, locale), TimeZone.getDefault(), Locale.getDefault());
map.put(parser, i++);            
assertEquals(i++, (int)map.get(parser));
Calendar cal = Calendar.getInstance(GMT); // fails for non-GMT
cal.clear();
cal.set(2003, 1, 10);
Date in = cal.getTime();
SimpleDateFormat sdf = new SimpleDateFormat(LONG_FORMAT, locale);
String fmt = sdf.format(in);
Date out = sdf.parse(fmt);
assertEquals(locale.toString(), in, out);return b*17 + t ;validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out empty
validateNullToStringStyleRegistry(); // Ensure registry starts out emptyObject[] original = new Object[] {true, false};
assertTrue(new CompareToBuilder().append(o1, o1).build() == 0);
assertTrue(new CompareToBuilder().append(o1, o2).build() == 0);
assertTrue(new CompareToBuilder().append(o1, o2).build() < 0);
assertTrue(new CompareToBuilder().append(o2, o1).build() > 0);
assertTrue(new CompareToBuilder().append(o1, null).build() > 0);
assertTrue(new CompareToBuilder().append((Object) null, (Object) null).build() == 0);
assertTrue(new CompareToBuilder().append(null, o1).build() < 0);
assertEquals("Wrong daemon flag", flag, t.isDaemon());
assertEquals("Wrong result of equals", expected, init.equals(obj));
assertEquals("Not symmetric", expected, obj.equals(init));
assertFalse(triple.getRight());
assertTrue(triple.getRight());
Triple<Object, String, Long> triple2 = Triple.of(null, "bar", 200L);for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
Type toTypeArg = entry.getValue();
Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {return Long.valueOf(str);package org.apache.commons.collections.comparators;
import org.apache.commons.collections.AbstractTestObject;
package org.apache.commons.collections.comparators;
package org.apache.commons.collections;
public abstract class AbstractTestObject extends BulkTest {
return Boolean.getBoolean("org.apache.commons.collections:with-clover");
package org.apache.commons.collections;
public class BulkTest extends TestCase implements Cloneable {
package org.apache.commons.collections.comparators;
package org.apache.commons.collections.comparators;
package org.apache.commons.collections.comparators;
package org.apache.commons.collections.comparators;package org.apache.commons.collections.comparators;
package org.apache.commons.collections.comparators;
package org.apache.commons.collections;
import org.apache.commons.collections.comparators.BooleanComparator;
import org.apache.commons.collections.comparators.ComparableComparator;
import org.apache.commons.collections.comparators.ComparatorChain;
import org.apache.commons.collections.comparators.NullComparator;
import org.apache.commons.collections.comparators.ReverseComparator;
import org.apache.commons.collections.comparators.TransformingComparator;
public static Comparator<Boolean> booleanComparator(boolean trueFirst) {
return BooleanComparator.booleanComparator(trueFirst);
public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, Transformer<? super E, ? extends E> transformer) {
if (comparator == null) {
comparator = NATURAL_COMPARATOR;
return new TransformingComparator<E>(transformer, comparator);
package org.apache.commons.collections.comparators;
package org.apache.commons.collections.comparators;
import org.apache.commons.collections.ComparatorUtils;
package org.apache.commons.collections.comparators;
import org.apache.commons.collections.ComparatorUtils;if (last == CharUtils.LF) {
if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
return ret.substring(0, lastIdx - 1);
if (sz > start + 1) {
if (chars[start] == '0' && chars[start + 1] == 'x') {
int i = start + 2;
if (i == sz) {
return false; // str == "0x"
for (; i < chars.length; i++) {
if ((chars[i] < '0' || chars[i] > '9')
&& (chars[i] < 'a' || chars[i] > 'f')
&& (chars[i] < 'A' || chars[i] > 'F')) {
return false;
return true;
if (method.getName().equals(methodName)) {
if (ClassUtils.isAssignable(parameterTypes, method
.getParameterTypes(), true)) {
Method accessibleMethod = getAccessibleMethod(method);
if (accessibleMethod != null) {
if (bestMatch == null
|| MemberUtils.compareParameterTypes(
accessibleMethod.getParameterTypes(),
bestMatch.getParameterTypes(),
parameterTypes) < 0) {
bestMatch = accessibleMethod;
if (quoteLen > 0) {
if (isQuote(chars, pos, len, quoteStart, quoteLen)) {
quoting = true;
pos += quoteLen;
continue;
if(input.charAt(index) == '\\') {
if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {
int i=2;
while( (index + i < input.length()) && input.charAt(index + i) == 'u') {
i++;
if( (index + i < input.length()) && (input.charAt(index + i) == '+') ) {
i++;
if( (index + i + 4 <= input.length()) ) {
CharSequence unicode = input.subSequence(index + i, index + i + 4);
try {
int value = Integer.parseInt(unicode.toString(), 16);
out.write((char) value);
throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);
return i + 4;
throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + 
input.subSequence(index, input.length()) +
"' due to end of CharSequence");import org.apache.commons.lang3.text.translate.UnicodeEscaper;
StringEscapeUtils.ESCAPE_XML.with( UnicodeEscaper.between(0x7f, Integer.MAX_VALUE) );
assertEquals("Supplementary character must be represented using a single escape", "\u233B4",if (str == null) {
if (trueString == null) {
if (falseString == null) {
return true;
return false;
try {
BooleanUtils.toBooleanObject((String) null, "Y", "N", "U");
fail();public F getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {public Object toString(String format) {assertSame(Locale.GERMANY, format1.getLocale());
assertEquals(sdf.format(date2), fdf.format(date2));            list8 = list10;synchronized (HashCodeBuilder.class) {
synchronized (HashCodeBuilder.class) {private static int hashMember(String name, Object value)
throws IllegalAccessException, InvocationTargetException {public final static int SEMI_MONTH = 1001;
public final static int RANGE_WEEK_SUNDAY = 1;
public final static int RANGE_WEEK_MONDAY = 2;
public final static int RANGE_WEEK_RELATIVE = 3;
public final static int RANGE_WEEK_CENTER = 4;
public final static int RANGE_MONTH_SUNDAY = 5;
public final static int RANGE_MONTH_MONDAY = 6;
public final static int MODIFY_TRUNCATE = 0;
public final static int MODIFY_ROUND = 1;
public final static int MODIFY_CEILING= 2;(ch0 == 't' || ch0 == 'T'))
(ch0 == 'f' || ch0 == 'F'))
(ch1 == 'n' || ch1 == 'N') ) 
(ch1 == 'o' || ch1 == 'O') ) 
(ch2 == 's' || ch2 == 'S') ) 
(ch2 == 'f' || ch2 == 'F') ) 
(ch3 == 'e' || ch3 == 'E') ) 
(ch4 == 'e' || ch4 == 'E') ) 
|| (numbers && Character.isDigit(ch))
|| (!letters && !numbers)) 
private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,
boolean preserveAllTokens)
private static String replaceEach(String text, String[] searchList, String[] replacementList,
boolean repeat, int timeToLive)
searchList.length == 0 || replacementList == null || replacementList.length == 0)
searchList[i].length() == 0 || replacementList[i] == null)
searchList[i].length() == 0 || replacementList[i] == null)
public static void matchesPattern(CharSequence input, String pattern)
if (Pattern.matches(pattern, input) == false)
public static void matchesPattern(CharSequence input, String pattern, String message, Object... values)
if (Pattern.matches(pattern, input) == false)
public static <T> void inclusiveBetween(T start, T end, Comparable<T> value)
if (value.compareTo(start) < 0 || value.compareTo(end) > 0)
public static <T> void inclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values)
if (value.compareTo(start) < 0 || value.compareTo(end) > 0)
public static <T> void exclusiveBetween(T start, T end, Comparable<T> value)
if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0)
public static <T> void exclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values)
if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0)
public static void isInstanceOf(Class<?> type, Object o)
if (type.isInstance(o) == false)
public static void isInstanceOf(Class<?> type, Object o, String message, Object... values)
if (type.isInstance(o) == false)
public static void isAssignableFrom(Class<?> superType, Class<?> type)
if (superType.isAssignableFrom(type) == false)
public static void isAssignableFrom(Class<?> superType, Class<?> type, String message, Object... values)
if (superType.isAssignableFrom(type) == false)
public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, 
Class<?> reflectUpToClass) 
public class EventListenerSupport<L> implements Serializable
public static <T> EventListenerSupport<T> create(Class<T> listenerInterface)
public EventListenerSupport(Class<L> listenerInterface)
public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader)
public L fire()
public void addListener(L listener)
int getListenerCount()
public void removeListener(L listener)
protected class ProxyInvocationHandler implements InvocationHandler
public Object invoke(Object proxy, Method method, Object[] args) 
throws Throwable
for (L listener : listeners)
public class EventUtils
public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener)
try
catch (NoSuchMethodException e)
catch (IllegalAccessException e)
catch (InvocationTargetException e)
public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource, Class<L> listenerType, String... eventTypes)
private static class EventBindingInvocationHandler implements InvocationHandler
public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes)
public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable
if ( eventTypes.isEmpty() || eventTypes.contains(method.getName()))
if (hasMatchingParametersMethod(method))
else
private boolean hasMatchingParametersMethod(final Method method)
|| (value != null && value.equals(information))) 
else {
catch (Exception e) {
else {
else {
public static String replace(Object source, Properties valueProperties)
while (propNames.hasMoreElements())
List<String> tokens, int quoteStart, int quoteLen) 
if(start instanceof GregorianCalendar) {
if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&
(start.get(Calendar.DAY_OF_MONTH) == 29 ) )
days += 1;public static &lt;T&gt; T[] createAnArray(int size)
public static &lt;T&gt; T[] createAnArray(int size)
return (T[])Object[size]; // ClassCastException at runtime
public static <T> T[] toArray(final T... items)return getJavaVersion(nom);return foundDigit && !hasExp;assertEquals(0, StringUtils.indexOfAnyBut("ab", new char[] {'z'}));Constructor<T>[] ctors = cls.getConstructors();
for (Constructor<T> ctor : ctors) {
result = ctor;return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);try {
final Method clone = o.getClass().getMethod("clone", (Class[])null);
final T result = (T)clone.invoke(o, (Object[])null);
return result;
throw new CloneFailedException("Cloneable type has no clone method", e);
throw new CloneFailedException("Cannot clone Cloneable type", e);
throw new CloneFailedException("Exception cloning Cloneable type", e.getCause());UnicodeEscaper nee = UnicodeEscaper.below('F');
String result = nee.translate(input);
UnicodeEscaper nee = UnicodeEscaper.between('F', 'L');
String result = nee.translate(input);
UnicodeEscaper nee = UnicodeEscaper.above('F');
String result = nee.translate(input);public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = 
getSystemProperty("java.util.prefs.PreferencesFactory");
public static final String USER_COUNTRY = 
getSystemProperty("user.country") == null ?
getSystemProperty("user.region") : getSystemProperty("user.country");
public static final boolean IS_OS_AIX = getOSMatches("AIX");
public static final boolean IS_OS_HP_UX = getOSMatches("HP-UX");
public static final boolean IS_OS_IRIX = getOSMatches("Irix");
public static final boolean IS_OS_LINUX = getOSMatches("Linux") || getOSMatches("LINUX");
public static final boolean IS_OS_MAC = getOSMatches("Mac");
public static final boolean IS_OS_MAC_OSX = getOSMatches("Mac OS X");
public static final boolean IS_OS_OS2 = getOSMatches("OS/2");
public static final boolean IS_OS_SOLARIS = getOSMatches("Solaris");
public static final boolean IS_OS_SUN_OS = getOSMatches("SunOS");
public static final boolean IS_OS_UNIX =
IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX ||
IS_OS_MAC_OSX || IS_OS_SOLARIS || IS_OS_SUN_OS;
public static final boolean IS_OS_WINDOWS = getOSMatches(OS_NAME_WINDOWS_PREFIX);
public static final boolean IS_OS_WINDOWS_NT = getOSMatches(OS_NAME_WINDOWS_PREFIX + " NT");
public static final boolean IS_OS_WINDOWS_VISTA = getOSMatches(OS_NAME_WINDOWS_PREFIX, "6.0"); 
public static final boolean IS_OS_WINDOWS_7 = getOSMatches(OS_NAME_WINDOWS_PREFIX, "6.1"); 
public SystemUtils() {
super();
if (JAVA_VERSION_TRIMMED == null) {
return 0f;
String str = JAVA_VERSION_TRIMMED.substring(0, 3);
if (JAVA_VERSION_TRIMMED.length() >= 5) {
str = str + JAVA_VERSION_TRIMMED.substring(4, 5);
try {
return Float.parseFloat(str);
return 0;
if (JAVA_VERSION_TRIMMED == null) {
return 0;
String str = JAVA_VERSION_TRIMMED.substring(0, 1);
str = str + JAVA_VERSION_TRIMMED.substring(2, 3);
if (JAVA_VERSION_TRIMMED.length() >= 5) {
str = str + JAVA_VERSION_TRIMMED.substring(4, 5);
str = str + "0";
try {
return Integer.parseInt(str);
return 0;
private static boolean getJavaVersionMatches(String versionPrefix) {
if (JAVA_VERSION_TRIMMED == null) {
return false;
return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);
private static boolean getOSMatches(String osNamePrefix) {
if (OS_NAME == null) {
return false;
return OS_NAME.startsWith(osNamePrefix);
private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {
if (OS_NAME == null || OS_VERSION == null) {
return false;
return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);
System.err.println(
"Caught a SecurityException reading the system property '" + property 
+ "'; the SystemUtils property value will default to null."
);
public static boolean isJavaAwtHeadless() {
return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;
public static File getJavaHome() {
return new File(System.getProperty(JAVA_HOME_KEY));
public static File getJavaIoTmpDir() {
return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));
public static File getUserDir() {
return new File(System.getProperty(USER_DIR_KEY));
public static File getUserHome() {
return new File(System.getProperty(USER_HOME_KEY));
private String JAVA_VERSION;
private String JAVA_VERSION_TRIMMED;
private String OS_NAME;
private String OS_VERSION;
private float getJavaVersionAsFloat() {
if (JAVA_VERSION_TRIMMED == null) {
return 0f;
String str = JAVA_VERSION_TRIMMED.substring(0, 3);
if (JAVA_VERSION_TRIMMED.length() >= 5) {
str = str + JAVA_VERSION_TRIMMED.substring(4, 5);
try {
return Float.parseFloat(str);
return 0;
private int getJavaVersionAsInt() {
if (JAVA_VERSION == null) {
return 0;
String str = JAVA_VERSION_TRIMMED.substring(0, 1);
str = str + JAVA_VERSION_TRIMMED.substring(2, 3);
if (JAVA_VERSION_TRIMMED.length() >= 5) {
str = str + JAVA_VERSION_TRIMMED.substring(4, 5);
str = str + "0";
try {
return Integer.parseInt(str);
return 0;
private String getJavaVersionTrimmed() {
if (JAVA_VERSION != null) {
for (int i = 0; i < JAVA_VERSION.length(); i++) {
char ch = JAVA_VERSION.charAt(i);
if (ch >= '0' && ch <= '9') {
return JAVA_VERSION.substring(i);
return null;
private boolean getJavaVersionMatches(String versionPrefix) {
if (JAVA_VERSION_TRIMMED == null) {
return false;
return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);
private boolean getOSMatches(String osNamePrefix) {
if (OS_NAME == null) {
return false;
return OS_NAME.startsWith(osNamePrefix);
private boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {
if (OS_NAME == null || OS_VERSION == null) {
return false;
return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);
JAVA_VERSION = null;
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(0f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.1f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.2";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.2f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.3.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.3f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.3.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.4.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.4f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.4.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.41f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.5.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.5f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "1.6.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.6f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "JavaVM-1.3.1";  //HP-UX
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = "XXX-1.3.x";  //error
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(0.0f, getJavaVersionAsFloat(), 0.000001f);
JAVA_VERSION = null;
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(0, getJavaVersionAsInt());
JAVA_VERSION = "1.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(110, getJavaVersionAsInt());
JAVA_VERSION = "1.2";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(120, getJavaVersionAsInt());
JAVA_VERSION = "1.3.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(130, getJavaVersionAsInt());
JAVA_VERSION = "1.3.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(131, getJavaVersionAsInt());
JAVA_VERSION = "1.4.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(140, getJavaVersionAsInt());
JAVA_VERSION = "1.4.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(141, getJavaVersionAsInt());
JAVA_VERSION = "1.5.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(150, getJavaVersionAsInt());
JAVA_VERSION = "1.6.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(160, getJavaVersionAsInt());
JAVA_VERSION = "JavaVM-1.3.1";  //HP-UX
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(131, getJavaVersionAsInt());
JAVA_VERSION = "XXX-1.3.x";  //error
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(0, getJavaVersionAsInt());
JAVA_VERSION = null;
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(true, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.2";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(true, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.3.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(true, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.3.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(true, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.4.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(true, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.4.1";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(true, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.5.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(true, getJavaVersionMatches("1.5"));
JAVA_VERSION = "1.6.0";
JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();
assertEquals(false, getJavaVersionMatches("1.1"));
assertEquals(false, getJavaVersionMatches("1.2"));
assertEquals(false, getJavaVersionMatches("1.3"));
assertEquals(false, getJavaVersionMatches("1.4"));
assertEquals(false, getJavaVersionMatches("1.5"));
public void testOSMatches() {
OS_NAME = null;
assertEquals(false, getOSMatches("Windows"));
OS_NAME = "Windows 95";
assertEquals(true, getOSMatches("Windows"));
OS_NAME = "Windows NT";
assertEquals(true, getOSMatches("Windows"));
OS_NAME = "OS/2";
assertEquals(false, getOSMatches("Windows"));
public void testOSMatches2() {
OS_NAME = null;
OS_VERSION = null;
assertEquals(false, getOSMatches("Windows 9", "4.1"));
OS_NAME = "Windows 95";
OS_VERSION = "4.0";
assertEquals(false, getOSMatches("Windows 9", "4.1"));
OS_NAME = "Windows 95";
OS_VERSION = "4.1";
assertEquals(true, getOSMatches("Windows 9", "4.1"));
OS_NAME = "Windows 98";
OS_VERSION = "4.1";
assertEquals(true, getOSMatches("Windows 9", "4.1"));
OS_NAME = "Windows NT";
OS_VERSION = "4.0";
assertEquals(false, getOSMatches("Windows 9", "4.1"));
OS_NAME = "OS/2";
OS_VERSION = "4.0";
assertEquals(false, getOSMatches("Windows 9", "4.1"));public static boolean containsAny(CharSequence cs, char[] searchChars) {
if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
return false;
int csLength = cs.length();
int searchLength = searchChars.length;
int csLastIndex = csLength - 1;
int searchLastIndex = searchLength - 1;
for (int i = 0; i < csLength; i++) {
char ch = cs.charAt(i);
for (int j = 0; j < searchLength; j++) {
if (searchChars[j] == ch) {
if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
if (searchChars[j + 1] == cs.charAt(i + 1)) {
return true;
return true;
return false;public ContextedExceptionTest(String name) {
super(name);
.addValue("test Nbr", new Integer(5))
.addValue("test Poorly written obj", new ObjectWithFaultyToString());
assertTrue(message.indexOf("test Poorly written obj")>=0);
assertTrue(message.indexOf("Crap")>=0);
assertTrue(contextedException.getValue("crap") == null);
assertTrue(contextedException.getValue("test Poorly written obj") instanceof ObjectWithFaultyToString);
assertTrue(contextedException.getLabelSet().size() == 5);
contextedException.addValue("test Poorly written obj", "replacement");
public void testGetMessage() {
testAddValue();
public ContextedRuntimeExceptionTest(String name) {
super(name);
.addValue("test Nbr", new Integer(5))
.addValue("test Poorly written obj", new ObjectWithFaultyToString());
assertTrue(message.indexOf("test Poorly written obj")>=0);
assertTrue(message.indexOf("Crap")>=0);
assertTrue(contextedRuntimeException.getValue("crap") == null);
assertTrue(contextedRuntimeException.getValue("test Poorly written obj") instanceof ObjectWithFaultyToString);
assertTrue(contextedRuntimeException.getLabelSet().size() == 5);
contextedRuntimeException.addValue("test Poorly written obj", "replacement");
public void testGetMessage() {
testAddValue();public static CharSequence reverse(CharSequence str) {
if (str == null) {
return null;
return new StringBuilder(str).reverse();
public static CharSequence defaultIfEmpty(CharSequence str, CharSequence defaultStr) {Iterator aIt = a.iterator();
Iterator adIt = ad.iterator();
Iterator notaIt = nota.iterator();
Character c = (Character) notaIt.next();
Iterator emptySetIt = emptySet.iterator();
Iterator notFirstIt = notFirst.iterator();
Iterator notLastIt = notLast.iterator();if (searchStr.length() == 0 && startPos >= str.length()) {
return str.length();try {valueStr = value.toString();}
catch (Throwable t) {
valueStr = "Excepted on toString(): " + 
ExceptionUtils.getStackTrace(t);String dateStr = "February 942, 1996";
String[] parsers = new String[] {"MMMMM DDD, yyyy"};private StrLookup variableResolver;
this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);
public StrSubstitutor(StrLookup variableResolver) {
public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {
StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {
StrLookup resolver = getVariableResolver();
public StrLookup getVariableResolver() {
public void setVariableResolver(StrLookup variableResolver) {assertEquals("removeEndIgnoreCase(\"www.domain.com\", \".com\")", StringUtils.removeEndIgnoreCase("www.domain.com", ".COM"), "www.domain");Map<String, Object> map = new HashMap<String, Object>();private static final StrLookup<?> NONE_LOOKUP;
private static final StrLookup<Object> SYSTEM_PROPERTIES_LOOKUP;
NONE_LOOKUP = new MapStrLookup(null);
StrLookup lookup = null;
lookup = new MapStrLookup(System.getProperties());
public static StrLookup<Object> systemPropertiesLookup() {
public static <V> StrLookup mapLookup(Map<String, V> map) {
static class MapStrLookup<V> extends StrLookup {Class normalizerFormClass = ClassUtils.getClass("java.text.Normalizer$Form", false);
Class normalizerClass = ClassUtils.getClass("java.text.Normalizer", false);List list = new ArrayList();
List result = ClassUtils.convertClassNamesToClasses(list);
list.add(new Object());
fail();
List list = new ArrayList();
List result = ClassUtils.convertClassesToClassNames(list);
list.add(new Object());
fail();numberArray1 = null;
newArray = ArrayUtils.addAll(stringArray1, null);
newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, null);private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE = "The validated character sequence is invalid: %d";
assertEquals("MSG6", ex.getMessage());
assertEquals("MSG7", ex.getMessage());
assertEquals("MSG7.4", ex.getMessage());
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
assertEquals("The validated string is empty", ex.getMessage());
assertEquals("The validated string is empty", ex.getMessage());
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
assertEquals("The validated string is blank", e.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("The validated string is blank", e.getMessage());
assertEquals("The validated string is blank", e.getMessage());
assertEquals("The validated string is blank", e.getMessage());
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
assertEquals("Broken: -1", ex.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("Broken: 2", ex.getMessage());
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
assertEquals("Broken: -1", ex.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("Broken: 2", ex.getMessage());
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
fail("Expecting IllegalArgumentException");
assertEquals("Broken: -1", ex.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("Broken: 2", ex.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("The validated string index is invalid: -1", ex.getMessage());
fail("Expecting IllegalArgumentException");
assertEquals("The validated string index is invalid: 2", ex.getMessage());package org.apache.commons.lang.concurrent;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
public class CallableBackgroundInitializer<T> extends BackgroundInitializer<T> {
private final Callable<T> callable;
public CallableBackgroundInitializer(Callable<T> call) {
checkCallable(call);
callable = call;
public CallableBackgroundInitializer(Callable<T> call, ExecutorService exec) {
super(exec);
checkCallable(call);
callable = call;
protected T initialize() throws Exception {
return callable.call();
private void checkCallable(Callable<T> call) {
if (call == null) {
throw new IllegalArgumentException("Callable must not be null!");private Range byteRange;
private Range byteRange2;
private Range byteRange3;private final Comparator comparator;
public static <T extends Comparable> Range is(T element) {
return new Range(element, element, ComparableComparator.INSTANCE);
public static <T extends Comparable> Range between(T element1, T element2) {
return new Range( element1, element2, ComparableComparator.INSTANCE);
public static <T> Range is(T element, Comparator c) {
return new Range(element, element, c);
public static <T> Range between(T element1, T element2, Comparator c) {
return new Range(element1, element2, c);
private Range(T element1, T element2, Comparator c) {
public Comparator getComparator() {
Range range = (Range) obj;for (T val : values) {
if (val != null && val != ObjectUtils.NULL) {
return val;
public void testFirstNonNull() {
assertEquals(null, ObjectUtils.firstNonNull(null, null));
assertEquals("", ObjectUtils.firstNonNull(null, ""));
assertEquals("123", ObjectUtils.firstNonNull(null, null, "123", "456"));
assertEquals("123", ObjectUtils.firstNonNull("123", null, "456", null));
assertEquals(null, ObjectUtils.firstNonNull());
assertSame(Boolean.TRUE, ObjectUtils.firstNonNull(Boolean.TRUE));
assertNull(ObjectUtils.firstNonNull());
assertNull(ObjectUtils.firstNonNull(null, null));
assertSame("123", ObjectUtils.firstNonNull(null, ObjectUtils.NULL, "123", "456"));
assertSame("456", ObjectUtils.firstNonNull(ObjectUtils.NULL, "456", "123", null));
assertNull(ObjectUtils.firstNonNull(null, null, ObjectUtils.NULL));public boolean lessThan(T element) {
return false;
return this.comparator.compare(getMinimum(), element) < 1;
public boolean greaterThan(T element) {
return false;
return this.comparator.compare(getMaximum(), element) > -1;assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=[]" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());
assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());
List excludeList = new ArrayList();
List excludeList = new ArrayList();
List excludeList = new ArrayList();
String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList());
String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection) null);
assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());
assertEquals("<size=0>", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals("[]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals("<size=0>", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals("{}", new ToStringBuilder(base).append("a", new HashMap(), true).toString());
assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());
List base = new ArrayList();
assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());Constructor[] cons = BooleanUtils.class.getDeclaredConstructors();
Constructor[] cons = CharSetUtils.class.getDeclaredConstructors();
Constructor[] cons = CharUtils.class.getDeclaredConstructors();
Constructor[] cons = ObjectUtils.class.getDeclaredConstructors();
Constructor[] cons = RandomStringUtils.class.getDeclaredConstructors();
Constructor[] cons = StringEscapeUtils.class.getDeclaredConstructors();
Constructor[] cons = SystemUtils.class.getDeclaredConstructors();
Constructor[] cons = WordUtils.class.getDeclaredConstructors();public static Constructor getAccessibleConstructor(Class<?> cls,
public static Constructor getAccessibleConstructor(Class<?> cls,
public static Constructor getAccessibleConstructor(Constructor ctor) {
public static Constructor getMatchingAccessibleConstructor(Class<?> cls,private final Map registry = new HashMap();
Map registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory());
private void checkBuiltInFormat(String pattern, Map registry, Object[] args, Locale[] locales) {
private void checkBuiltInFormat(String pattern, Map registry, Object[] args, Locale locale) {assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());
assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());
assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());
assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());Map map = new HashMap();
Map map = null;
private Map values;
values = new HashMap();
Map map = new HashMap();
Map map = new HashMap();
Map map = new HashMap();
Map map = new HashMap();
Map map = new HashMap();
Map map = new HashMap();
MutableObject obj = new MutableObject(replaceTemplate);  // toString returns template
List list = tok.getTokenList();
protected List tokenize(char[] chars, int offset, int count) {
protected List tokenize(char[] chars, int offset, int count) {
List list = super.tokenize(chars, offset, count);private Class parentClass = PublicChild.class.getSuperclass();
private Map classCache;
classCache = new HashMap();
Class[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };
Class[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };
private void expectMatchingAccessibleMethodParameterTypes(Class cls,
String methodName, Class[] requestTypes, Class[] actualTypes) {
private String toString(Class[] c) {
private Class[] singletonArray(Class c) {
Class[] result = (Class[]) classCache.get(c);Constructor[] cons = NumberUtils.class.getDeclaredConstructors();HashSet testLocales = new HashSet();
for (Iterator l = testLocales.iterator(); l.hasNext();) {
Locale locale = (Locale) l.next();
sb.appendAll((Collection) null);
sb.appendAll((Iterator) null);
sb.appendWithSeparators((Collection) null, ",");
sb.appendWithSeparators((Iterator) null, ",");
Constructor[] cons = DateFormatUtils.class.getDeclaredConstructors();Constructor[] cons = ArrayUtils.class.getDeclaredConstructors();
Map map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}});
map = ArrayUtils.toMap(new Object[] {new Map.Entry() {
Collection coll = new ArrayList();
Validate.notEmpty((Collection) null);
Collection coll = new ArrayList();
Validate.notEmpty((Collection) null, "MSG");
Map map = new HashMap();
Validate.notEmpty((Map) null);
Map map = new HashMap();
Validate.notEmpty((Map) null, "MSG");
List coll = new ArrayList();
Validate.noNullElements((Collection) null);
List coll = new ArrayList();
Validate.noNullElements((Collection) null, "MSG");
List coll = new ArrayList();
coll = new ArrayList();
Constructor[] cons = Validate.class.getDeclaredConstructors();parser.applyPattern(parsePatterns[i]);Constructor[] cons = ExceptionUtils.class.getDeclaredConstructors();
List throwables = ExceptionUtils.getThrowableList(null);
List throwables = ExceptionUtils.getThrowableList(withoutCause);
List throwables = ExceptionUtils.getThrowableList(nested);
List throwables = ExceptionUtils.getThrowableList(withCause);
List throwables = ExceptionUtils.getThrowableList(jdkNoCause);
List throwables = ExceptionUtils.getThrowableList(selfCause);
List throwables = ExceptionUtils.getThrowableList(cyclicCause);Constructor[] cons = ClassUtils.class.getDeclaredConstructors();
assertEquals("", ClassUtils.getShortClassName((Class) null));
assertEquals("", ClassUtils.getPackageName((Class)null));
List list = ClassUtils.getAllSuperclasses(CY.class);
List list = ClassUtils.getAllInterfaces(CY.class);
Class[] array2 = new Class[] {Object.class, Object.class};
Class[] array1 = new Class[] {Object.class};
Class[] array1s = new Class[] {String.class};
Class[] array0 = new Class[] {};
assertFalse(ClassUtils.isAssignable((Class) null, null));
assertFalse(ClassUtils.isAssignable((Class) null, null, true));
final Class[] primitives = new Class[] {
Class[] wrappers= ClassUtils.primitivesToWrappers(primitives);
Class primitive = primitives[i];
Class expectedWrapper = ClassUtils.primitiveToWrapper(primitive);
final Class[] noPrimitives = new Class[] {
final Class[] primitives = {
Class wrapperCls = ClassUtils.primitiveToWrapper(primitives[i]);
final Class[] classes = {
Class[] primitives = ClassUtils.wrappersToPrimitives(classes);
Class expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]);
Class[] empty = new Class[0];
private void assertGetClassReturnsClass( Class c ) throws Exception {
private void assertGetClassThrowsException( String className, Class exceptionType ) throws Exception {
Set set = Collections.unmodifiableSet(new HashSet());
Set set = Collections.unmodifiableSet(new HashSet());
Class[] results = ClassUtils.toClass(array);
Constructor[] cons = StringUtils.class.getDeclaredConstructors();
assertEquals(null, StringUtils.join((Iterator) null, ','));
assertEquals(null, StringUtils.join((Iterator) null, null));
assertEquals(null, StringUtils.join((Collection) null, ','));
assertEquals(null, StringUtils.join((Collection) null, null));Constructor ctor = getMatchingAccessibleConstructor(cls, parameterTypes);
Constructor ctor = getAccessibleConstructor(cls, parameterTypes);
Constructor ctor = cls.getConstructor(parameterTypes);
Constructor result = null;
Constructor[] ctors = cls.getConstructors();
Constructor ctor = getAccessibleConstructor(ctors[i]);Class[] parameterTypes = new Class[arguments];
Object[] args, Class[] parameterTypes)
Class[] parameterTypes = new Class[arguments];
Object[] args, Class[] parameterTypes)
public static Object invokeExactStaticMethod(Class cls, String methodName,
Object[] args, Class[] parameterTypes)
public static Object invokeStaticMethod(Class cls, String methodName,
public static Object invokeStaticMethod(Class cls, String methodName,
Class[] parameterTypes = new Class[arguments];
public static Object invokeStaticMethod(Class cls, String methodName,
Object[] args, Class[] parameterTypes)
public static Object invokeExactStaticMethod(Class cls, String methodName,
public static Object invokeExactStaticMethod(Class cls, String methodName,
Class[] parameterTypes = new Class[arguments];
public static Method getAccessibleMethod(Class cls, String methodName,
Class parameterType) {
new Class[] { parameterType });
public static Method getAccessibleMethod(Class cls, String methodName,
Class[] parameterTypes) {
Class cls = method.getDeclaringClass();
Class[] parameterTypes = method.getParameterTypes();
private static Method getAccessibleMethodFromSuperclass(Class cls,
String methodName, Class[] parameterTypes) {
Class parentClass = cls.getSuperclass();
private static Method getAccessibleMethodFromInterfaceNest(Class cls,
String methodName, Class[] parameterTypes) {
Class[] interfaces = cls.getInterfaces();
public static Method getMatchingAccessibleMethod(Class cls,
String methodName, Class[] parameterTypes) {ToStringBuilder.setDefaultStyle(STYLE);for (Iterator it = collection.iterator(); it.hasNext();) {
for (Iterator it = collection.iterator(); it.hasNext(); i++) {
for (Iterator it = collection.iterator(); it.hasNext(); ) {
for (Iterator it = collection.iterator(); it.hasNext(); i++) {
if (num instanceof Comparable == false) {
if (num1 instanceof Comparable == false) {buffer.append(SystemUtils.LINE_SEPARATOR);                 
buffer.append(SystemUtils.LINE_SEPARATOR);
buffer.append("\t---------------------------------");
String contextMessage = contextedException.getFormattedExceptionMessage("");
assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);
assertTrue(message.contains(contextMessage));
String contextMessage = contextedRuntimeException.getFormattedExceptionMessage("");
assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);
assertTrue(message.contains(contextMessage));import org.apache.commons.lang.UnhandledException;
throw new UnhandledException(ioe);
import org.apache.commons.lang.UnhandledException;
throw new UnhandledException("Unable to parse unicode value: " + unicode, nfe);
assertGetClassThrowsIllegalArgument( null );
private void assertGetClassThrowsIllegalArgument( String className ) throws Exception {
assertGetClassThrowsException( className, IllegalArgumentException.class );throw new NullArgumentException("className");
import org.apache.commons.lang.NullArgumentException;
throw new NullArgumentException("target");return between(0, codepoint);
return between(codepoint, Integer.MAX_VALUE);import org.apache.commons.lang.math.NumberUtils;String pBaseStr = p.getClass().getName();private char a='a';
private char b='b';
private transient char transientB='t';
objectsLevel2[0] = (Object) objects;
private SelfInstanceVarReflectionTestFixture typeIsSelf;
this.typeIsSelf = this;
private SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;
this.typeIsSelf = this;
objects[0] = (Object) simple;import org.apache.commons.lang.IDKey;
package org.apache.commons.lang;public abstract class AbstractNestableTestCase extends TestCase
public AbstractNestableTestCase(String name)
suite.addTest(NestableDelegateTestCase.suite());
suite.addTest(NestableErrorTestCase.suite());
suite.addTest(NestableExceptionTestCase.suite());
suite.addTest(NestableRuntimeExceptionTestCase.suite());
suite.addTest(ExceptionUtilsTestCase.suite());
public class ExceptionUtilsTestCase extends junit.framework.TestCase {
public ExceptionUtilsTestCase(String name) {
return new TestSuite(ExceptionUtilsTestCase.class);
assertEquals("ExceptionUtilsTestCase.ExceptionWithCause: Wrapper", ExceptionUtils.getMessage(th));
public class NestableDelegateTestCase extends junit.framework.TestCase {
public NestableDelegateTestCase(String name)
return new TestSuite(NestableDelegateTestCase.class);
public class NestableErrorTestCase extends AbstractNestableTestCase {
public NestableErrorTestCase(String name)
return new TestSuite(NestableErrorTestCase.class);
public class NestableExceptionTestCase extends AbstractNestableTestCase {
public NestableExceptionTestCase(String name)
return new TestSuite(NestableExceptionTestCase.class);
public class NestableRuntimeExceptionTestCase extends AbstractNestableTestCase {
public NestableRuntimeExceptionTestCase(String name)
return new TestSuite(NestableRuntimeExceptionTestCase.class);char c = str.charAt(i);
if (c > 0x7F) {assertEquals("truncate ampm-1 failed",
assertEquals("truncate ampm-2 failed",
dateTimeParser.parse("February 4, 2002 00:00:00.000"),
assertEquals("truncate ampm-3 failed",
assertEquals("truncate ampm-4 failed",
dateTimeParser.parse("February 4, 2002 12:00:00.000"),
assertEquals("truncate ampm-1 failed",
assertEquals("truncate ampm-2 failed",
dateTimeParser.parse("February 4, 2002 00:00:00.000"),
assertEquals("truncate ampm-3 failed",
assertEquals("truncate ampm-4 failed",
dateTimeParser.parse("February 4, 2002 12:00:00.000"),
assertEquals("truncate ampm-1 failed",
assertEquals("truncate ampm-2 failed",
dateTimeParser.parse("February 4, 2002 00:00:00.000"),
assertEquals("truncate ampm-3 failed",
assertEquals("truncate ampm-4 failed",
dateTimeParser.parse("February 4, 2002 12:00:00.000"),return Integer.toHexString(ch).toUpperCase();int mid = (low + high) >> 1;MessageFormat mf = null;
if (locale == null) {
mf = new MessageFormat(pattern);
mf = new MessageFormat(pattern, locale);if (upper != str.length()) result.append(StringUtils.defaultString(appendToEnd));assertEquals("String", results[0].getSimpleName());
assertEquals("Integer", results[1].getSimpleName());
assertEquals("Double", results[2].getSimpleName());stopTime = -1;
startTime = System.currentTimeMillis();
stopTime = System.currentTimeMillis();
startTime = -1;
stopTime = -1;
stopTime = System.currentTimeMillis();
stopTime = -1;
stopTime = System.currentTimeMillis();
startTime += (System.currentTimeMillis() - stopTime);
stopTime = -1;if (field == Calendar.SECOND) {
done = true;
if (field == Calendar.MINUTE) {
done = true;assertEquals(languages.length, list.size());
assertEquals(countries.length, list.size());register(value);
try {
if (value instanceof Collection) {
if (detail) {
appendDetail(buffer, fieldName, (Collection) value);
appendSummarySize(buffer, fieldName, ((Collection) value).size());
if (detail) {
appendDetail(buffer, fieldName, (Map) value);
appendSummarySize(buffer, fieldName, ((Map) value).size());
if (detail) {
appendDetail(buffer, fieldName, (long[]) value);
appendSummary(buffer, fieldName, (long[]) value);
if (detail) {
appendDetail(buffer, fieldName, (int[]) value);
appendSummary(buffer, fieldName, (int[]) value);
if (detail) {
appendDetail(buffer, fieldName, (short[]) value);
appendSummary(buffer, fieldName, (short[]) value);
if (detail) {
appendDetail(buffer, fieldName, (byte[]) value);
appendSummary(buffer, fieldName, (byte[]) value);
if (detail) {
appendDetail(buffer, fieldName, (char[]) value);
appendSummary(buffer, fieldName, (char[]) value);
if (detail) {
appendDetail(buffer, fieldName, (double[]) value);
appendSummary(buffer, fieldName, (double[]) value);
if (detail) {
appendDetail(buffer, fieldName, (float[]) value);
appendSummary(buffer, fieldName, (float[]) value);
if (detail) {
appendDetail(buffer, fieldName, (boolean[]) value);
appendSummary(buffer, fieldName, (boolean[]) value);
if (detail) {
appendDetail(buffer, fieldName, (Object[]) value);
appendSummary(buffer, fieldName, (Object[]) value);
appendDetail(buffer, fieldName, value);
appendSummary(buffer, fieldName, value);
unregister(value);
register(object);
register(object);java.util.ArrayList list = new java.util.ArrayList(array.length);
return (Token[]) list.toArray( new Token[0] );long millis = endMillis - startMillis;
if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
return formatDuration(millis, format, padWithZeros);
int leapDays = 0;
if (days < 0) {
days += start.getActualMaximum(Calendar.DAY_OF_MONTH);
months -= 1;
start.add(Calendar.MONTH, 1);
while (months < 0) {
months += 12;
years -= 1;
if (start instanceof GregorianCalendar) {
if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) &&
( end.get(Calendar.MONTH) > 1) )  
leapDays += 1;
if (end instanceof GregorianCalendar) {
if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) &&
( end.get(Calendar.MONTH) < 1) )  
leapDays -= 1;
start.add(Calendar.YEAR, 1);
if (!Token.containsTokenWithValue(tokens, y) && years != 0) {
if (Token.containsTokenWithValue(tokens, M)) {
months += 12 * years;
years = 0;
while ( (start.get(Calendar.YEAR) != end.get(Calendar.YEAR))) {
days += start.getActualMaximum(Calendar.DAY_OF_YEAR);
start.set(Calendar.YEAR, end.get(Calendar.YEAR));
if (!Token.containsTokenWithValue(tokens, M) && months != 0) {   
while(start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {
String date = start.getTime().toString();
days += leapDays;
start.set(Calendar.MONTH, end.get(Calendar.MONTH));
bruteForce(2006, 0, 1);
bruteForce(2006, 0, 2);
private void bruteForce(int year, int month, int day) {
for (int i=0; i < 1500; i++) {
assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, "d" );
c.add(Calendar.DAY_OF_MONTH, 1);&& isDigits(numeric.substring(1))
&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
&& isDigits(numeric.substring(1))
&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {if (!Token.containsTokenWithValue(tokens, y)) {
while(start.get(Calendar.YEAR) != end.get(Calendar.YEAR)) {
days += start.getActualMaximum(Calendar.DAY_OF_YEAR);
start.add(Calendar.YEAR, 1);
if (!Token.containsTokenWithValue(tokens, M) && months != 0) {
start.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);
end.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);
days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
months = 0;
start = null;
end = null;
assertEquals(expected, result);while (days < 0) {
end.add(Calendar.MONTH, -1);
days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
end.add(Calendar.MONTH, 1);
days += 365 * years;
if (!Token.containsTokenWithValue(tokens, M)) {
String result = DurationFormatUtils.formatPeriod(cal1.getTime().getTime(), cal2.getTime().getTime(), format);for (int i = 0; i < thisBuf.length; i++) {
for (int i = startIndex; i < thisBuf.length; i++) {for (int i = startIndex; i < thisBuf.length - strLen; i++) {days += 31; // such overshooting is taken care of later on
milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
end.add( field, -1 * difference );
int endValue = end.get(field);
int startValue = start.get(field);
if (endValue < startValue) {
int newdiff = startValue - endValue;
end.add( field, newdiff );
return newdiff;
return 0;String str = "a b .c";package org.apache.commons.lang;
package org.apache.commons.lang;public static Object[] toObject(char[] array) {
if ( array == null ) {
for( int i = 0; i < array.length; i++ ){
result[i] = new Character( array[i] );assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, null));
assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, null));|| (!letters && !numbers)) {
buffer[count] = ch;int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
while (months < 0) {
months += 12;
years -= 1;
int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
while (days < 0) {
days += 31; // such overshooting is taken care of later on
months -= 1;
int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
while (minutes < 0) {
minutes += 60;
hours -= 1;
int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
while (seconds < 0) {
seconds += 60;
minutes -= 1;
int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
while (milliseconds < 0) {
milliseconds += 1000;
seconds -= 1;try {
Method mth = other.getClass().getMethod("getName", null);
String name = (String) mth.invoke(other, null);
return iName.equals(name);
return false;
try {
Method mth = other.getClass().getMethod("getName", null);
String name = (String) mth.invoke(other, null);
return iName.equals(name);
return false;
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.BLUE);
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.GREEN);
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.RED);
void testEqualsTrueWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.BLUE);
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.GREEN);
this.testEqualsTrueWithDifferentClassLoaders(ColorEnum.RED);
void testEqualsTrueWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,Throwable cause = getCause(throwable);
if (cause != null) {
throwable = cause;
while ((throwable = getCause(throwable)) != null) {
cause = throwable;
return cause;
int count = 0;
while (throwable != null) {
count++;
throwable = ExceptionUtils.getCause(throwable);
return count;
while (throwable != null) {
return (Throwable[]) list.toArray(new Throwable[list.size()]);
public void testGetThrowables_Throwable() {
assertEquals(1, ExceptionUtils.getThrowables(withoutCause).length);
assertSame(withoutCause, ExceptionUtils.getThrowables(withoutCause)[0]);
assertEquals(2, ExceptionUtils.getThrowables(nested).length);
assertSame(nested, ExceptionUtils.getThrowables(nested)[0]);
assertSame(withoutCause, ExceptionUtils.getThrowables(nested)[1]);
assertEquals(3, ExceptionUtils.getThrowables(withCause).length);
assertSame(withCause, ExceptionUtils.getThrowables(withCause)[0]);
assertSame(nested, ExceptionUtils.getThrowables(withCause)[1]);
assertSame(withoutCause, ExceptionUtils.getThrowables(withCause)[2]);for (int i=0; i < buf.length; i++) {public static Class getClass( ClassLoader classLoader, String className, boolean initialize )
throws ClassNotFoundException {
if( abbreviationMap.containsKey( className ) ) {
clazz = Class.forName( "[" + abbreviationMap.get( className ), initialize, classLoader ).getComponentType();
else {
clazz = Class.forName( toProperClassName( className ), initialize, classLoader );
public static Class getClass( ClassLoader classLoader, String className ) throws ClassNotFoundException {
return getClass( classLoader, className, true );
public static Class getClass( String className ) throws ClassNotFoundException {
return getClass( Thread.currentThread().getContextClassLoader() == null ? ClassUtils.class.getClassLoader() :
Thread.currentThread().getContextClassLoader(), className, true );
public static Class getClass( String className, boolean initialize ) throws ClassNotFoundException {
return getClass( Thread.currentThread().getContextClassLoader() == null ? ClassUtils.class.getClassLoader() :
Thread.currentThread().getContextClassLoader(), className, initialize );
private static String toProperClassName( String className ) {
className = StringUtils.deleteWhitespace( className );
if( className == null ) {
throw new NullArgumentException( "className" );
else if( className.endsWith( "[]" ) ) {
final StringBuffer classNameBuffer = new StringBuffer();
while( className.endsWith( "[]" ) ) {
className = className.substring( 0, className.length() - 2 );
classNameBuffer.append( "[" );
final String abbreviation = ( String ) abbreviationMap.get( className );
if( abbreviation != null ) {
classNameBuffer.append( abbreviation );
else {
classNameBuffer.append( "L" ).append( className ).append( ";" );public class ClassUtils
public static final String PACKAGE_SEPARATOR = String.valueOf( PACKAGE_SEPARATOR_CHAR );
public static final String INNER_CLASS_SEPARATOR = String.valueOf( INNER_CLASS_SEPARATOR_CHAR );
private static Map primitiveWrapperMap = new HashMap();
static
primitiveWrapperMap.put( Boolean.TYPE, Boolean.class );
primitiveWrapperMap.put( Byte.TYPE, Byte.class );
primitiveWrapperMap.put( Character.TYPE, Character.class );
primitiveWrapperMap.put( Short.TYPE, Short.class );
primitiveWrapperMap.put( Integer.TYPE, Integer.class );
primitiveWrapperMap.put( Long.TYPE, Long.class );
primitiveWrapperMap.put( Double.TYPE, Double.class );
primitiveWrapperMap.put( Float.TYPE, Float.class );
primitiveWrapperMap.put( Void.TYPE, Void.TYPE );
static
public ClassUtils()
super();
public static String getShortClassName( Object object, String valueIfNull )
if( object == null )
return getShortClassName( object.getClass().getName() );
public static String getShortClassName( Class cls )
if( cls == null )
return getShortClassName( cls.getName() );
public static String getShortClassName( String className )
if( className == null )
if( className.length() == 0 )
for( int i = 0; i < chars.length; i++ )
if( chars[i] == PACKAGE_SEPARATOR_CHAR )
else if( chars[i] == INNER_CLASS_SEPARATOR_CHAR )
return new String( chars, lastDot, chars.length - lastDot );
public static String getPackageName( Object object, String valueIfNull )
if( object == null )
return getPackageName( object.getClass().getName() );
public static String getPackageName( Class cls )
if( cls == null )
return getPackageName( cls.getName() );
public static String getPackageName( String className )
if( className == null )
int i = className.lastIndexOf( PACKAGE_SEPARATOR_CHAR );
if( i == -1 )
return className.substring( 0, i );
public static List getAllSuperclasses( Class cls )
if( cls == null )
while( superclass != null )
classes.add( superclass );
public static List getAllInterfaces( Class cls )
if( cls == null )
while( cls != null )
for( int i = 0; i < interfaces.length; i++ )
if( list.contains( interfaces[i] ) == false )
list.add( interfaces[i] );
List superInterfaces = getAllInterfaces( interfaces[i] );
for( Iterator it = superInterfaces.iterator(); it.hasNext(); )
Class intface = ( Class ) it.next();
if( list.contains( intface ) == false )
list.add( intface );
public static List convertClassNamesToClasses( List classNames )
if( classNames == null )
List classes = new ArrayList( classNames.size() );
for( Iterator it = classNames.iterator(); it.hasNext(); )
String className = ( String ) it.next();
try
classes.add( Class.forName( className ) );
catch( Exception ex )
classes.add( null );
public static List convertClassesToClassNames( List classes )
if( classes == null )
List classNames = new ArrayList( classes.size() );
for( Iterator it = classes.iterator(); it.hasNext(); )
Class cls = ( Class ) it.next();
if( cls == null )
classNames.add( null );
else
classNames.add( cls.getName() );
public static boolean isAssignable( Class[] classArray, Class[] toClassArray )
if( ArrayUtils.isSameLength( classArray, toClassArray ) == false )
if( classArray == null )
if( toClassArray == null )
for( int i = 0; i < classArray.length; i++ )
if( isAssignable( classArray[i], toClassArray[i] ) == false )
public static boolean isAssignable( Class cls, Class toClass )
if( toClass == null )
if( cls == null )
return !( toClass.isPrimitive() );
if( cls.equals( toClass ) )
if( cls.isPrimitive() )
if( toClass.isPrimitive() == false )
if( Integer.TYPE.equals( cls ) )
return Long.TYPE.equals( toClass )
|| Float.TYPE.equals( toClass )
|| Double.TYPE.equals( toClass );
if( Long.TYPE.equals( cls ) )
return Float.TYPE.equals( toClass )
|| Double.TYPE.equals( toClass );
if( Boolean.TYPE.equals( cls ) )
if( Double.TYPE.equals( cls ) )
if( Float.TYPE.equals( cls ) )
return Double.TYPE.equals( toClass );
if( Character.TYPE.equals( cls ) )
return Integer.TYPE.equals( toClass )
|| Long.TYPE.equals( toClass )
|| Float.TYPE.equals( toClass )
|| Double.TYPE.equals( toClass );
if( Short.TYPE.equals( cls ) )
return Integer.TYPE.equals( toClass )
|| Long.TYPE.equals( toClass )
|| Float.TYPE.equals( toClass )
|| Double.TYPE.equals( toClass );
if( Byte.TYPE.equals( cls ) )
return Short.TYPE.equals( toClass )
|| Integer.TYPE.equals( toClass )
|| Long.TYPE.equals( toClass )
|| Float.TYPE.equals( toClass )
|| Double.TYPE.equals( toClass );
return toClass.isAssignableFrom( cls );
public static Class primitiveToWrapper( Class cls )
if( cls != null && cls.isPrimitive() )
convertedClass = ( Class ) primitiveWrapperMap.get( cls );
public static Class[] primitivesToWrappers( Class[] classes )
if( classes == null )
if( classes.length == 0 )
for( int i = 0; i < classes.length; i++ )
public static boolean isInnerClass( Class cls )
if( cls == null )
return cls.getName().indexOf( INNER_CLASS_SEPARATOR_CHAR ) >= 0;
throws ClassNotFoundException
if( abbreviationMap.containsKey( className ) )
else
public static Class getClass( ClassLoader classLoader, String className ) throws ClassNotFoundException
public static Class getClass( String className ) throws ClassNotFoundException
public static Class getClass( String className, boolean initialize ) throws ClassNotFoundException
private static String toProperClassName( String className )
if( className == null )
else if( className.endsWith( "[]" ) )
while( className.endsWith( "[]" ) )
if( abbreviation != null )
elseduration = StringUtils.replaceOnce(duration, "1 seconds", "1 second");
duration = StringUtils.replaceOnce(duration, "1 minutes", "1 minute");
duration = StringUtils.replaceOnce(duration, "1 hours", "1 hour");
duration = StringUtils.replaceOnce(duration, "1 days", "1 day");
return duration;
public void testFormatDurationWords(){
text = DurationFormatUtils.formatDurationWords(50*1000, true, false);
text = DurationFormatUtils.formatDurationWords(65*1000, true, false);
text = DurationFormatUtils.formatDurationWords(120*1000, true, false);
text = DurationFormatUtils.formatDurationWords(121*1000, true, false);
text = DurationFormatUtils.formatDurationWords(72*60*1000, true, false);
text = DurationFormatUtils.formatDurationWords(24*60*60*1000, true, false);
text = DurationFormatUtils.formatDurationWords(50*1000, true, true);
text = DurationFormatUtils.formatDurationWords(65*1000, true, true);
text = DurationFormatUtils.formatDurationWords(120*1000, true, true);
text = DurationFormatUtils.formatDurationWords(121*1000, true, true);
text = DurationFormatUtils.formatDurationWords(72*60*1000, true, true);
text = DurationFormatUtils.formatDurationWords(24*60*60*1000, true, true);
text = DurationFormatUtils.formatDurationWords(50*1000, false, true);
text = DurationFormatUtils.formatDurationWords(65*1000, false, true);
text = DurationFormatUtils.formatDurationWords(120*1000, false, true);
text = DurationFormatUtils.formatDurationWords(121*1000, false, true);
text = DurationFormatUtils.formatDurationWords(72*60*1000, false, true);
text = DurationFormatUtils.formatDurationWords(24*60*60*1000, false, true);
text = DurationFormatUtils.formatDurationWords(50*1000, false, false);
text = DurationFormatUtils.formatDurationWords(65*1000, false, false);
text = DurationFormatUtils.formatDurationWords(120*1000, false, false);
text = DurationFormatUtils.formatDurationWords(121*1000, false, false);
text = DurationFormatUtils.formatDurationWords(72*60*1000, false, false);
text = DurationFormatUtils.formatDurationWords(48*60*60*1000 + 72*60*1000 , false, false);
public void testFormatDurationHMS(){
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "y") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "M") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "d") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "H") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "m") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "s") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "S") );
assertEquals( "0000", DurationFormatUtils.formatDuration(duration, "SSSS") );
assertEquals( "0000", DurationFormatUtils.formatDuration(duration, "yyyy") );
assertEquals( "0000", DurationFormatUtils.formatDuration(duration, "yyMM") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "y") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "M") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "d") );
assertEquals( "0", DurationFormatUtils.formatDuration(duration, "H") );
assertEquals( "1", DurationFormatUtils.formatDuration(duration, "m") );
assertEquals( "60", DurationFormatUtils.formatDuration(duration, "s") );
assertEquals( "60000", DurationFormatUtils.formatDuration(duration, "S") );
assertEquals( "01:00", DurationFormatUtils.formatDuration(duration, "mm:ss") );
assertEquals( "0 0 " + days, DurationFormatUtils.formatDuration(duration, "y M d") );
public void testFormatPeriodISO(){
text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);
text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "y") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "M") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "d") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "H") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "m") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "s") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time1970, "S") );
assertEquals( "0000", DurationFormatUtils.formatPeriod(time1970, time1970, "SSSS") );
assertEquals( "0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyyy") );
assertEquals( "0000", DurationFormatUtils.formatPeriod(time1970, time1970, "yyMM") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time, "y") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time, "M") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time, "d") );
assertEquals( "0", DurationFormatUtils.formatPeriod(time1970, time, "H") );
assertEquals( "1", DurationFormatUtils.formatPeriod(time1970, time, "m") );
assertEquals( "60", DurationFormatUtils.formatPeriod(time1970, time, "s") );
assertEquals( "60000", DurationFormatUtils.formatPeriod(time1970, time, "S") );
assertEquals( "01:00", DurationFormatUtils.formatPeriod(time1970, time, "mm:ss") );
assertEquals( "36", DurationFormatUtils.formatPeriod(time1970, time, "yM") );
assertEquals( "3 years 6 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'") );
assertEquals( "03/06", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM") );
assertEquals( "310", DurationFormatUtils.formatPeriod(time1970, time, "yM") );
assertEquals( "3 years 10 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'") );
assertEquals( "03/10", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM") );
assertEquals( "40", DurationFormatUtils.formatPeriod(time1970, time, "yM") );
assertEquals( "4 years 0 months", DurationFormatUtils.formatPeriod(time1970, time, "y' years 'M' months'") );
assertEquals( "04/00", DurationFormatUtils.formatPeriod(time1970, time, "yy/MM") );
assertEquals( "48", DurationFormatUtils.formatPeriod(time1970, time, "M") );
assertEquals( "48", DurationFormatUtils.formatPeriod(time1970, time, "MM") );
assertEquals( "048", DurationFormatUtils.formatPeriod(time1970, time, "MMM") );
assertArrayEquals( 
new DurationFormatUtils.Token[] { 
new DurationFormatUtils.Token( DurationFormatUtils.y, 1),
new DurationFormatUtils.Token( DurationFormatUtils.M, 1),
new DurationFormatUtils.Token( DurationFormatUtils.d, 1),
new DurationFormatUtils.Token( DurationFormatUtils.H, 1),
new DurationFormatUtils.Token( DurationFormatUtils.m, 1),
new DurationFormatUtils.Token( DurationFormatUtils.s, 1),
new DurationFormatUtils.Token( DurationFormatUtils.S, 1)
);
assertArrayEquals( 
new DurationFormatUtils.Token[] { 
new DurationFormatUtils.Token( DurationFormatUtils.H, 1),
new DurationFormatUtils.Token( new StringBuffer(":"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.m, 2),
new DurationFormatUtils.Token( new StringBuffer(":"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.s, 2),
new DurationFormatUtils.Token( new StringBuffer("."), 1),
new DurationFormatUtils.Token( DurationFormatUtils.S, 3)
);
assertArrayEquals( 
new DurationFormatUtils.Token[] { 
new DurationFormatUtils.Token( new StringBuffer("P"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.y, 4),
new DurationFormatUtils.Token( new StringBuffer("Y"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.M, 1),
new DurationFormatUtils.Token( new StringBuffer("M"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.d, 1),
new DurationFormatUtils.Token( new StringBuffer("DT"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.H, 1),
new DurationFormatUtils.Token( new StringBuffer("H"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.m, 1),
new DurationFormatUtils.Token( new StringBuffer("M"), 1),
new DurationFormatUtils.Token( DurationFormatUtils.s, 1),
new DurationFormatUtils.Token( new StringBuffer("."), 1),
new DurationFormatUtils.Token( DurationFormatUtils.S, 1),
new DurationFormatUtils.Token( new StringBuffer("S"), 1)
DurationFormatUtils.lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)
);
DurationFormatUtils.Token token = new DurationFormatUtils.Token( DurationFormatUtils.y, 4 );
assertFalse( "Token equal to non-Token class. ", token.equals(new Object()) );
assertFalse( "Token equal to Token with wrong value class. ", token.equals(
new DurationFormatUtils.Token( new Object() )
) );
assertFalse( "Token equal to Token with different count. ", token.equals(
new DurationFormatUtils.Token( DurationFormatUtils.y, 1 )
) );
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token( new Integer(1), 4 );
assertTrue( "Token with Number value not equal to itself. ", numToken.equals( numToken ) );
assertEquals( "Arrays are unequal length. ", obj1.length, obj2.length );
for(int i=0; i<obj1.length; i++) {
assertTrue( "Index " + i + " not equal, " + obj1[i] + " vs " + obj2, obj1[i].equals(obj2[i]));private static final String[] PADDING = new String[Character.MAX_VALUE];package org.apache.commons.lang;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.textui.TestRunner;
public class IntHashMapTest extends TestCase
public static void main(String[] args) {
TestRunner.run(suite());
public static Test suite() {
TestSuite suite = new TestSuite(IntHashMapTest.class);
suite.setName("IntHashMapTest Tests");
return suite;
public void testConstructor() {
try {
IntHashMap map = new IntHashMap(-1, 0.0f);
fail();
assertEquals("Illegal Capacity: -1", e.getMessage());
try {
IntHashMap map = new IntHashMap(1, 0.0f);
fail();
assertEquals("Illegal Load: 0.0", e.getMessage());
IntHashMap map = new IntHashMap(0, 1.0f);
try {
IntHashMap map1 = new IntHashMap(-1);
fail();
assertEquals("Illegal Capacity: -1", e.getMessage());
IntHashMap map1 = new IntHashMap(0);
public void testClear() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
map.clear();
assertEquals(0, map.size());
public void testContainsKey() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
assertTrue(map.containsKey(1));
assertTrue(map.containsKey(2));
assertFalse(map.containsKey(3));
public void testContains() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
assertTrue(map.containsValue("hello"));
assertTrue(map.containsValue("world"));
assertFalse(map.containsValue("goodbye"));
try {
map.containsValue(null);
fail();
public void testContainsValue() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
assertTrue(map.containsValue("hello"));
assertTrue(map.containsValue("world"));
assertFalse(map.containsValue("goodbye"));
try {
map.containsValue(null);
fail();
public void testIsEmpty() {
IntHashMap map = new IntHashMap();
assertTrue(map.isEmpty());
assertNull(map.put(1, "hello"));
assertEquals(1, map.size());
assertFalse(map.isEmpty());
public void testPut() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
assertEquals("hello", map.put(1, "hellooooo"));
public void testRemove() {
IntHashMap map = new IntHashMap();
assertNull(map.put(1, "hello"));
assertNull(map.put(2, "world"));
assertEquals(2, map.size());
assertEquals("hello", map.remove(1));
assertEquals(1, map.size());
assertNull(map.remove(3));cloned.chars = cloned.chars;return nextToken();
return previousToken();
char cbuf[] = new char[len];
StringBuffer token = new StringBuffer();
List tokens = new ArrayList();
String tok = null;
while (start < len) {
start = readNextToken(start, cbuf, token);
tok = token.toString();
addToken(tokens, tok);
token.setLength(0);
if (start == len && delim.isMatch(chars, start - 1, 0, len) == 1) {
private int readNextToken(int start, char cbuf[], StringBuffer token) {
token.setLength(0);
int len = chars.length;
int ignoreLen = 0;
int delimLen = 0;
int quoteLen = 0;
while (start < len &&
(ignoreLen = ignored.isMatch(chars, start, 0, len)) >= 1 &&
(delimLen = delim.isMatch(chars, start, 0, len)) < 1 &&
(quoteLen = quote.isMatch(chars, start, 0, len)) < 1) {
start += ignoreLen;
return start;
if ((delimLen = delim.isMatch(chars, start, 0, len)) >= 1) {
start += delimLen;
start = readQuoted(start + quoteLen, cbuf, token);
start = readUnquoted(start, token);
return start;
private int readQuoted(int start, char cbuf[], StringBuffer token) {
int cbufcnt = 0;
boolean done = false;
boolean quoting = true;
int len = chars.length;
int delimLen = 0;
int quoteLen = 0;
while (pos < len && !done) {
if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {
if (pos + 1 < len && chars[pos + 1] == chars[pos]) {
cbuf[cbufcnt++] = chars[pos];
pos += 2;
quoting = false;
pos += quoteLen;
cbuf[cbufcnt++] = chars[pos];
pos++;
else {
if ((delimLen = delim.isMatch(chars, pos, 0, len)) >= 1) {
done = true;
if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {
cbuf[cbufcnt++] = chars[pos];
pos++;
token.append(cbuf, 0, cbufcnt);
return pos + delimLen;
private int readUnquoted(int start, StringBuffer token) {
char[] chars = this.chars;
int len = chars.length;
int pos = start;
int delimLen = 0;
while (pos < len && (delimLen = delim.isMatch(chars, pos, 0, len)) < 1) {
pos++;
while (trimmer.isMatch(chars, start, 0, len) > 0) {
start++;
int length = Math.min(pos, len) - start;
while (trimmer.isMatch(chars, start + length - 1, 0, len) > 0) {
length--;
for (int i=0;i<length;i++) {
if (ignored.isMatch(chars, start + i, 0, len) == 0) {
token.append(chars[start + i]);
return pos + delimLen;
cloned.chars = (char[]) cloned.chars;
String input = "a;b;c;\"d;\"\"e\";f; ; ;";
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
assertTrue(tokens.length == expected.length);
String input = "a \"b\" c";
StrTokenizer tok = new StrTokenizer(input, ' ', '"');
assertEquals(null, tokenizer.next());return this;
return this;
return this;
return this;
sb.append((String) null);
assertEquals("foo", sb.toString());
sb.append((String) null, 0, 1);
assertEquals("foo", sb.toString());
sb.append((StringBuffer) null);
assertEquals("foo", sb.toString());
sb.append((StringBuffer) null, 0, 1);
assertEquals("foo", sb.toString());
sb.append((StrBuilder) null);
assertEquals("foo", sb.toString());
sb.append((StrBuilder) null, 0, 1);
assertEquals("foo", sb.toString());
sb.append((char[]) null);
assertEquals("", sb.toString());
sb.append((char[]) null, 0, 1);
assertEquals("foo", sb.toString());System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);
size -= len;
public StrBuilder deleteCharAt(int index) {
if (index < 0 || index >= size) {
throw new StringIndexOutOfBoundsException(index);
System.arraycopy(buffer, index + 1, buffer, index, size - index - 1);
size--;
public StrBuilder delete(char ch) {
int start = i;
while (++i < size) {
if (buffer[i] != ch) {
break;
System.arraycopy(buffer, i, buffer, start, size - i);
size -= (i - start);
public StrBuilder delete(String str) {
delete(index, index + len);
public StrBuilder replace(int startIndex, int endIndex, String str) {
endIndex = validateRange(startIndex, endIndex);
int insertLen = str.length();
int removeLen = endIndex - startIndex;
if (insertLen > removeLen) {
if (insertLen != removeLen) {
str.getChars(0, insertLen, buffer, startIndex);
return this;
public StrBuilder replace(int startIndex, int endIndex, StrBuilder builder) {
int insertLen = builder.length();
int removeLen = endIndex - startIndex;
if (insertLen > removeLen) {
ensureCapacity(size - removeLen + insertLen);
if (insertLen != removeLen) {
System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);
size += (insertLen - removeLen);
builder.getChars(0, insertLen, buffer, startIndex);
public StrBuilder replace(char search, char replace) {
public StrBuilder replace(String searchStr, String replaceStr) {
replaceStr = (replaceStr == null ? "" : replaceStr);
replace(index, index + searchLen, replaceStr);
index = indexOf(searchStr, index);
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import org.apache.commons.lang.ArrayUtils;
private static Object FOO = new Object() {
public String toString() {
return "foo";
public void testDeleteChar() {
StrBuilder sb = new StrBuilder("abc");
sb.delete('X');
assertEquals("abc",sb.toString()); 
sb.delete('a');
assertEquals("bc",sb.toString()); 
sb.delete('c');
assertEquals("b",sb.toString()); 
sb.delete('b');
assertEquals("",sb.toString()); 
public void testDeleteIntInt() {
StrBuilder sb = new StrBuilder("abc");
sb.delete(0, 1);
assertEquals("bc",sb.toString()); 
sb.delete(1, 2);
assertEquals("b",sb.toString());
sb.delete(0, 1);
assertEquals("",sb.toString()); 
sb.delete(0, 1);
assertEquals("",sb.toString()); 
public void testDeleteString() {
StrBuilder sb = new StrBuilder("abc");
sb.delete(null);
assertEquals("abc",sb.toString()); 
sb.delete("");
assertEquals("abc",sb.toString()); 
sb.delete("X");
assertEquals("abc",sb.toString()); 
sb.delete("a");
assertEquals("bc",sb.toString()); 
sb.delete("c");
assertEquals("b",sb.toString()); 
sb.delete("b");
assertEquals("",sb.toString()); 
public void testDeleteCharAt() {
StrBuilder sb = new StrBuilder("abc");
sb.deleteCharAt(0);
assertEquals("bc",sb.toString()); 
public void testDeleteCharAtExceptions() {
StrBuilder sb = new StrBuilder("abc");
try {
sb.deleteCharAt(1000);
fail("Expected StringIndexOutOfBoundsException");
public void testReplaceCharChar() {
StrBuilder sb = new StrBuilder("abc");
sb.replace('a', 'd');
assertEquals("dbc", sb.toString());
sb.replace('a', 'd');
assertEquals("dbc", sb.toString());
sb = new StrBuilder("aabbcc");
sb.replace('a', 'd');
assertEquals("ddbbcc", sb.toString());
sb.replace('a', 'd');
assertEquals("ddbbcc", sb.toString());
sb.replace('d', 'd');
assertEquals("ddbbcc", sb.toString());
public void testReplaceStringString() {
StrBuilder sb = new StrBuilder("abc");
sb.replace("a", "d");
assertEquals("dbc", sb.toString());
sb.replace("a", "d");
assertEquals("dbc", sb.toString());
sb = new StrBuilder("aabbcc");
sb.replace("a", "d");
assertEquals("ddbbcc", sb.toString());
sb.replace("a", "d");
assertEquals("ddbbcc", sb.toString());
public void testReplaceIntIntStrBuilder() {
StrBuilder sb = new StrBuilder("abc");
sb.replace(0, 1, new StrBuilder ("d"));
assertEquals("dbc", sb.toString());
sb.replace(0, 1, new StrBuilder ("aaa"));
assertEquals("aaabc", sb.toString());
sb = new StrBuilder("aabbcc");
sb.replace(0, 2, new StrBuilder("d"));
assertEquals("dbbcc", sb.toString());
public void testStartsWith() {
this.testStartsWith(new StrBuilder());
this.testStartsWith(new StrBuilder(""));
this.testStartsWith(new StrBuilder(null));
void testStartsWith(StrBuilder sb ) {
assertFalse(sb.startsWith("a"));
assertFalse(sb.startsWith(null));
assertTrue(sb.startsWith(""));
sb.append("abc");
assertTrue(sb.startsWith("a"));
assertTrue(sb.startsWith("ab"));
assertTrue(sb.startsWith("abc"));
assertFalse(sb.startsWith("cba"));
public void testEndsWith() {
this.testEndsWith(new StrBuilder());
this.testEndsWith(new StrBuilder(""));
this.testEndsWith(new StrBuilder(null));
void testEndsWith(StrBuilder sb) {
assertFalse(sb.endsWith("a"));
assertFalse(sb.endsWith("c"));
assertTrue(sb.endsWith(""));
assertFalse(sb.endsWith(null));
sb.append("abc");
assertTrue(sb.endsWith("c"));
assertTrue(sb.endsWith("bc"));
assertTrue(sb.endsWith("abc"));
assertFalse(sb.endsWith("cba"));
assertFalse(sb.endsWith("abcd"));
assertFalse(sb.endsWith(" abc"));
assertFalse(sb.endsWith("abc "));
public void testAppendWithNullText() {
StrBuilder sb = new StrBuilder();
sb.setNullText("NULL");
sb.appendNull();
assertEquals("NULL", sb.toString());
sb.append((Object) null);
assertEquals("NULLNULL", sb.toString());
sb.append(FOO);
assertEquals("NULLNULLfoo", sb.toString());
sb.append((String) null);
assertEquals("NULLNULLfooNULL", sb.toString());
sb.append("");
assertEquals("NULLNULLfooNULL", sb.toString());
sb.append("bar");
assertEquals("NULLNULLfooNULLbar", sb.toString());
sb.append((StringBuffer) null);
assertEquals("NULLNULLfooNULLbarNULL", sb.toString());
sb.append(new StringBuffer("baz"));
assertEquals("NULLNULLfooNULLbarNULLbaz", sb.toString());
public void testAppend_Object() {
StrBuilder sb = new StrBuilder();
sb.appendNull();
assertEquals("", sb.toString());
sb.append((Object) null);
sb.append(FOO);
assertEquals("foo", sb.toString());
sb.append((StringBuffer) null);
assertEquals("foo", sb.toString());
sb.append(new StringBuffer("baz"));
assertEquals("foobaz", sb.toString());
sb.append(new StrBuilder("yes"));
assertEquals("foobazyes", sb.toString());
public void testAppend_String() {
StrBuilder sb = new StrBuilder();
sb.append("foo");
assertEquals("foo", sb.toString());
sb.append((String) null);
assertEquals("foo", sb.toString());
sb.append("");
assertEquals("foo", sb.toString());
sb.append("bar");
assertEquals("foobar", sb.toString());
public void testAppend_String_int_int() {
StrBuilder sb = new StrBuilder();
sb.append("foo", 0, 3);
assertEquals("foo", sb.toString());
sb.append((String) null, 0, 1);
assertEquals("foo", sb.toString());
try {
sb.append("bar", -1, 1);
fail("append(char[], -1,) expected IndexOutOfBoundsException");
try {
sb.append("bar", 3, 1);
fail("append(char[], 3,) expected IndexOutOfBoundsException");
try {
sb.append("bar", 1, -1);
fail("append(char[],, -1) expected IndexOutOfBoundsException");
try {
sb.append("bar", 1, 3);
fail("append(char[], 1, 3) expected IndexOutOfBoundsException");
try {
sb.append("bar", -1, 3);
fail("append(char[], -1, 3) expected IndexOutOfBoundsException");
try {
sb.append("bar", 4, 0);
fail("append(char[], 4, 0) expected IndexOutOfBoundsException");
sb.append("bar", 3, 0);
assertEquals("foo", sb.toString());
sb.append("abcbardef", 3, 3);
assertEquals("foobar", sb.toString());
public void testAppend_StringBuffer() {
StrBuilder sb = new StrBuilder();
sb.append(new StringBuffer("foo"));
assertEquals("foo", sb.toString());
sb.append((StringBuffer) null);
assertEquals("foo", sb.toString());
sb.append(new StringBuffer(""));
assertEquals("foo", sb.toString());
sb.append(new StringBuffer("bar"));
assertEquals("foobar", sb.toString());
public void testAppend_StringBuffer_int_int() {
StrBuilder sb = new StrBuilder();
sb.append(new StringBuffer("foo"), 0, 3);
assertEquals("foo", sb.toString());
sb.append((StringBuffer) null, 0, 1);
assertEquals("foo", sb.toString());
try {
sb.append(new StringBuffer("bar"), -1, 1);
fail("append(char[], -1,) expected IndexOutOfBoundsException");
try {
sb.append(new StringBuffer("bar"), 3, 1);
fail("append(char[], 3,) expected IndexOutOfBoundsException");
try {
sb.append(new StringBuffer("bar"), 1, -1);
fail("append(char[],, -1) expected IndexOutOfBoundsException");
try {
sb.append(new StringBuffer("bar"), 1, 3);
fail("append(char[], 1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new StringBuffer("bar"), -1, 3);
fail("append(char[], -1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new StringBuffer("bar"), 4, 0);
fail("append(char[], 4, 0) expected IndexOutOfBoundsException");
sb.append(new StringBuffer("bar"), 3, 0);
assertEquals("foo", sb.toString());
sb.append(new StringBuffer("abcbardef"), 3, 3);
assertEquals("foobar", sb.toString());
public void testAppend_StrBuilder() {
StrBuilder sb = new StrBuilder();
sb.append(new StrBuilder("foo"));
assertEquals("foo", sb.toString());
sb.append((StrBuilder) null);
assertEquals("foo", sb.toString());
sb.append(new StrBuilder(""));
assertEquals("foo", sb.toString());
sb.append(new StrBuilder("bar"));
assertEquals("foobar", sb.toString());
public void testAppend_StrBuilder_int_int() {
StrBuilder sb = new StrBuilder();
sb.append(new StrBuilder("foo"), 0, 3);
assertEquals("foo", sb.toString());
sb.append((StrBuilder) null, 0, 1);
assertEquals("foo", sb.toString());
try {
sb.append(new StrBuilder("bar"), -1, 1);
fail("append(char[], -1,) expected IndexOutOfBoundsException");
try {
sb.append(new StrBuilder("bar"), 3, 1);
fail("append(char[], 3,) expected IndexOutOfBoundsException");
try {
sb.append(new StrBuilder("bar"), 1, -1);
fail("append(char[],, -1) expected IndexOutOfBoundsException");
try {
sb.append(new StrBuilder("bar"), 1, 3);
fail("append(char[], 1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new StrBuilder("bar"), -1, 3);
fail("append(char[], -1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new StrBuilder("bar"), 4, 0);
fail("append(char[], 4, 0) expected IndexOutOfBoundsException");
sb.append(new StrBuilder("bar"), 3, 0);
assertEquals("foo", sb.toString());
sb.append(new StrBuilder("abcbardef"), 3, 3);
assertEquals("foobar", sb.toString());
public void testAppend_CharArray() {
StrBuilder sb = new StrBuilder();
sb.append((char[]) null);
assertEquals("", sb.toString());
sb.append(new char[0]);
assertEquals("", sb.toString());
sb.append(new char[]{'f', 'o', 'o'});
assertEquals("foo", sb.toString());
public void testAppend_CharArray_int_int() {
StrBuilder sb = new StrBuilder();
sb.append(new char[]{'f', 'o', 'o'}, 0, 3);
assertEquals("foo", sb.toString());
sb.append((char[]) null, 0, 1);
assertEquals("foo", sb.toString());
try {
sb.append(new char[]{'b', 'a', 'r'}, -1, 1);
fail("append(char[], -1,) expected IndexOutOfBoundsException");
try {
sb.append(new char[]{'b', 'a', 'r'}, 3, 1);
fail("append(char[], 3,) expected IndexOutOfBoundsException");
try {
sb.append(new char[]{'b', 'a', 'r'}, 1, -1);
fail("append(char[],, -1) expected IndexOutOfBoundsException");
try {
sb.append(new char[]{'b', 'a', 'r'}, 1, 3);
fail("append(char[], 1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new char[]{'b', 'a', 'r'}, -1, 3);
fail("append(char[], -1, 3) expected IndexOutOfBoundsException");
try {
sb.append(new char[]{'b', 'a', 'r'}, 4, 0);
fail("append(char[], 4, 0) expected IndexOutOfBoundsException");
sb.append(new char[]{'b', 'a', 'r'}, 3, 0);
assertEquals("foo", sb.toString());
sb.append(new char[]{'a', 'b', 'c', 'b', 'a', 'r', 'd', 'e', 'f'}, 3, 3);
assertEquals("foobar", sb.toString());
public void testAppend_Primitive() {
StrBuilder sb = new StrBuilder();
sb.append(true);
assertEquals("true", sb.toString());
sb.append(false);
assertEquals("truefalse", sb.toString());
sb.append('!');
assertEquals("truefalse!", sb.toString());
public void testAppend_PrimitiveNumber() {
StrBuilder sb = new StrBuilder();
sb.append(0);
assertEquals("0", sb.toString());
sb.append(1L);
assertEquals("01", sb.toString());
sb.append(2.3f);
assertEquals("012.3", sb.toString());
sb.append(4.5d);
assertEquals("012.34.5", sb.toString());
public void testAppendPadding() {
StrBuilder sb = new StrBuilder();
sb.append("foo");
assertEquals("foo", sb.toString());
sb.appendPadding(-1, '-');
assertEquals("foo", sb.toString());
sb.appendPadding(0, '-');
assertEquals("foo", sb.toString());
sb.appendPadding(1, '-');
assertEquals("foo-", sb.toString());
sb.appendPadding(16, '-');
assertEquals(20, sb.length());
assertEquals("foo-----------------", sb.toString());
public void testAppendFixedWidthPadLeft() {
StrBuilder sb = new StrBuilder();
sb.appendFixedWidthPadLeft("foo", -1, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 0, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 1, '-');
assertEquals("o", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 2, '-');
assertEquals("oo", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 3, '-');
assertEquals("foo", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 4, '-');
assertEquals("-foo", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft("foo", 10, '-');
assertEquals(10, sb.length());
assertEquals("-------foo", sb.toString());
sb.clear();
sb.setNullText("null");
sb.appendFixedWidthPadLeft(null, 5, '-');
assertEquals("-null", sb.toString());
public void testAppendFixedWidthPadLeft_int() {
StrBuilder sb = new StrBuilder();
sb.appendFixedWidthPadLeft(123, -1, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 0, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 1, '-');
assertEquals("3", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 2, '-');
assertEquals("23", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 3, '-');
assertEquals("123", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 4, '-');
assertEquals("-123", sb.toString());
sb.clear();
sb.appendFixedWidthPadLeft(123, 10, '-');
assertEquals(10, sb.length());
assertEquals("-------123", sb.toString());
public void testAppendFixedWidthPadRight() {
StrBuilder sb = new StrBuilder();
sb.appendFixedWidthPadRight("foo", -1, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 0, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 1, '-');
assertEquals("f", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 2, '-');
assertEquals("fo", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 3, '-');
assertEquals("foo", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 4, '-');
assertEquals("foo-", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight("foo", 10, '-');
assertEquals(10, sb.length());
assertEquals("foo-------", sb.toString());
sb.clear();
sb.setNullText("null");
sb.appendFixedWidthPadRight(null, 5, '-');
assertEquals("null-", sb.toString());
public void testAppendFixedWidthPadRight_int() {
StrBuilder sb = new StrBuilder();
sb.appendFixedWidthPadRight(123, -1, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 0, '-');
assertEquals("", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 1, '-');
assertEquals("1", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 2, '-');
assertEquals("12", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 3, '-');
assertEquals("123", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 4, '-');
assertEquals("123-", sb.toString());
sb.clear();
sb.appendFixedWidthPadRight(123, 10, '-');
assertEquals(10, sb.length());
assertEquals("123-------", sb.toString());
public void testAppendWithSeparators_Array() {
StrBuilder sb = new StrBuilder();
sb.appendWithSeparators((Object[]) null, ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(new Object[0], ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, ",");
assertEquals("foo,bar,baz", sb.toString());
sb.clear();
sb.appendWithSeparators(new Object[]{"foo", "bar", "baz"}, null);
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ",");
assertEquals("foo,,baz", sb.toString());
public void testAppendWithSeparators_Collection() {
StrBuilder sb = new StrBuilder();
sb.appendWithSeparators((Collection) null, ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(Collections.EMPTY_LIST, ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}), ",");
assertEquals("foo,bar,baz", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}), null);
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}), ",");
assertEquals("foo,,baz", sb.toString());
public void testAppendWithSeparators_Iterator() {
StrBuilder sb = new StrBuilder();
sb.appendWithSeparators((Iterator) null, ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), ",");
assertEquals("", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), ",");
assertEquals("foo,bar,baz", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", "bar", "baz"}).iterator(), null);
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}).iterator(), ",");
assertEquals("foo,,baz", sb.toString());
public void testAppendWithSeparatorsWithNullText() {
StrBuilder sb = new StrBuilder();
sb.setNullText("null");
sb.appendWithSeparators(new Object[]{"foo", null, "baz"}, ",");
assertEquals("foo,null,baz", sb.toString());
sb.clear();
sb.appendWithSeparators(Arrays.asList(new Object[]{"foo", null, "baz"}), ",");
assertEquals("foo,null,baz", sb.toString());
public void testInsert() {
StrBuilder sb = new StrBuilder();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, FOO);
fail("insert(-1, Object) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, FOO);
fail("insert(7, Object) expected StringIndexOutOfBoundsException");
sb.insert(0, (Object) null);
assertEquals("barbaz", sb.toString());
sb.insert(0, FOO);
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, "foo");
fail("insert(-1, String) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, "foo");
fail("insert(7, String) expected StringIndexOutOfBoundsException");
sb.insert(0, (String) null);
assertEquals("barbaz", sb.toString());
sb.insert(0, "foo");
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, new char[]{'f', 'o', 'o'});
fail("insert(-1, char[]) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, new char[]{'f', 'o', 'o'});
fail("insert(7, char[]) expected StringIndexOutOfBoundsException");
sb.insert(0, (char[]) null);
assertEquals("barbaz", sb.toString());
sb.insert(0, new char[0]);
assertEquals("barbaz", sb.toString());
sb.insert(0, new char[]{'f', 'o', 'o'});
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);
fail("insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);
fail("insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException");
sb.insert(0, (char[]) null, 0, 0);
assertEquals("barbaz", sb.toString());
sb.insert(0, new char[0], 0, 0);
assertEquals("barbaz", sb.toString());
try {
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3);
fail("insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException");
try {
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3);
fail("insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException");
try {
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1);
fail("insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException");
try {
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10);
fail("insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException");
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0);
assertEquals("barbaz", sb.toString());
sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);
assertEquals("foobarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, true);
fail("insert(-1, boolean) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, true);
fail("insert(7, boolean) expected StringIndexOutOfBoundsException");
sb.insert(0, true);
assertEquals("truebarbaz", sb.toString());
sb.insert(0, false);
assertEquals("falsetruebarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, '!');
fail("insert(-1, char) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, '!');
fail("insert(7, char) expected StringIndexOutOfBoundsException");
sb.insert(0, '!');
assertEquals("!barbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, 0);
fail("insert(-1, int) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, 0);
fail("insert(7, int) expected StringIndexOutOfBoundsException");
sb.insert(0, '0');
assertEquals("0barbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, 1L);
fail("insert(-1, long) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, 1L);
fail("insert(7, long) expected StringIndexOutOfBoundsException");
sb.insert(0, 1L);
assertEquals("1barbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, 2.3F);
fail("insert(-1, float) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, 2.3F);
fail("insert(7, float) expected StringIndexOutOfBoundsException");
sb.insert(0, 2.3F);
assertEquals("2.3barbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, 4.5D);
fail("insert(-1, double) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, 4.5D);
fail("insert(7, double) expected StringIndexOutOfBoundsException");
sb.insert(0, 4.5D);
assertEquals("4.5barbaz", sb.toString());
public void testInsertWithNullText() {
StrBuilder sb = new StrBuilder();
sb.setNullText("null");
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, FOO);
fail("insert(-1, Object) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, FOO);
fail("insert(7, Object) expected StringIndexOutOfBoundsException");
sb.insert(0, (Object) null);
assertEquals("nullbarbaz", sb.toString());
sb.insert(0, FOO);
assertEquals("foonullbarbaz", sb.toString());
sb.clear();
sb.append("barbaz");
assertEquals("barbaz", sb.toString());
try {
sb.insert(-1, "foo");
fail("insert(-1, String) expected StringIndexOutOfBoundsException");
try {
sb.insert(7, "foo");
fail("insert(7, String) expected StringIndexOutOfBoundsException");
sb.insert(0, (String) null);
assertEquals("nullbarbaz", sb.toString());
sb.insert(0, "foo");
assertEquals("foonullbarbaz", sb.toString());
public void testToCharArray ( ) {
StrBuilder sb = new StrBuilder();        
assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray());
char[] a = sb.toCharArray();
assertNotNull ("toCharArray() result is null", a);
assertEquals ("toCharArray() result is too large", 0, a.length);
sb.append("junit");
a = sb.toCharArray();
assertEquals ("toCharArray() result incorrect length",5, a.length);
assertTrue ("toCharArray() result does not match",Arrays.equals("junit".toCharArray(), a));
public void testToCharArrayIntInt() {
StrBuilder sb = new StrBuilder();
assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0));
sb.append("junit");
char[] a = sb.toCharArray(0, 20); //too large test
assertEquals ("toCharArray(int,int) result incorrect length",5, a.length);
assertTrue ("toCharArray(int,int) result does not match",Arrays.equals("junit".toCharArray(), a));
a = sb.toCharArray(0, 4);
assertEquals ("toCharArray(int,int) result incorrect length",4, a.length);
assertTrue ("toCharArray(int,int) result does not match",Arrays.equals("juni".toCharArray(), a));
a = sb.toCharArray(0, 4);
assertEquals ("toCharArray(int,int) result incorrect length",4, a.length);
assertTrue ("toCharArray(int,int) result does not match",Arrays.equals("juni".toCharArray(), a));
a = sb.toCharArray(0,1);
assertNotNull ("toCharArray(int,int) result is null", a);
sb.toCharArray(-1, 5);
fail ("no string index out of bound on -1");
catch (IndexOutOfBoundsException e) {}
sb.toCharArray(6, 5);
fail ("no string index out of bound on -1");
catch (IndexOutOfBoundsException e) {}
public void testGetChars ( ) {
StrBuilder sb = new StrBuilder();
char[] input = new char[10];
char[] a = sb.getChars(input);
assertSame (input, a);
assertTrue(Arrays.equals(new char[10], a));
sb.append("junit");
a = sb.getChars(input);
assertSame(input, a);
assertTrue(Arrays.equals(new char[] {'j','u','n','i','t',0,0,0,0,0},a));
a = sb.getChars(null);
assertNotSame(input,a);
assertEquals(5,a.length);
assertTrue(Arrays.equals("junit".toCharArray(),a));
input = new char[5];
a = sb.getChars(input);
assertSame(input, a);
input = new char[4];
a = sb.getChars(input);
assertNotSame(input, a);
public void testGetCharsIntIntCharArrayInt( ) {
StrBuilder sb = new StrBuilder();
sb.append("junit");
char[] a = new char[5];
sb.getChars(0,5,a,0);
assertTrue(Arrays.equals(new char[] {'j','u','n','i','t'},a));
a = new char[5];
sb.getChars(0,2,a,3);
assertTrue(Arrays.equals(new char[] {0,0,0,'j','u'},a));
try {
sb.getChars(-1,0,a,0);
fail("no exception");
catch (IndexOutOfBoundsException e) {
try {
sb.getChars(0,-1,a,0);
fail("no exception");
catch (IndexOutOfBoundsException e) {
try {
sb.getChars(0,20,a,0);
fail("no exception");
catch (IndexOutOfBoundsException e) {
sb.getChars(4,2,a,0);
fail("no exception");
catch (IndexOutOfBoundsException e) {
public void testAppendStringBuffer() {
StrBuilder sb = new StrBuilder();
sb = sb.append(new StringBuffer());
assertNotNull(sb);
sb = sb.append(new StringBuffer("junit"));
assertEquals ("junit", sb.toString());
public void testAppendStrBuilder() {
sb = sb.append((StrBuilder)null);
assertNotNull(sb);
sb = sb.append(new StrBuilder());
assertNotNull(sb);
assertEquals("", sb.toString());
public void testStringBuffer() {
assertEquals (new StringBuffer().toString(), sb.toStringBuffer().toString());
sb.append("junit");
assertEquals(new StringBuffer("junit").toString(), sb.toStringBuffer().toString());
public void testReverse() {
StrBuilder sb = new StrBuilder();
String actual = sb.reverse().toString();
assertEquals ("", actual);
sb.append(true);
actual = sb.reverse().toString();
assertEquals("eurt", actual);
actual = sb.reverse().toString();
assertEquals("true", actual);
public void testIndexOfChar() {
public void testLastIndexOfChar() {
StrBuilder sb = new StrBuilder("abab");
assertEquals (2, sb.lastIndexOf('a'));
assertEquals ("abab".lastIndexOf('a'), sb.lastIndexOf('a'));
assertEquals(3, sb.lastIndexOf('b'));
assertEquals ("abab".lastIndexOf('b'), sb.lastIndexOf('b'));
assertEquals (-1, sb.lastIndexOf('z'));
public void testIndexOfCharInt() {
public void testLastIndexOfCharInt() {
public void testIndexOfString() {
public void testLastIndexOfString() {
StrBuilder sb = new StrBuilder("abab");
assertEquals(2, sb.lastIndexOf("a"));
assertEquals("abab".lastIndexOf("a"), sb.lastIndexOf("a"));
assertEquals(2, sb.lastIndexOf("ab"));
assertEquals("abab".lastIndexOf("ab"), sb.lastIndexOf("ab"));
assertEquals(3, sb.lastIndexOf("b"));
assertEquals("abab".lastIndexOf("b"), sb.lastIndexOf("b"));
assertEquals(1, sb.lastIndexOf("ba"));
assertEquals("abab".lastIndexOf("ba"), sb.lastIndexOf("ba"));
assertEquals(-1, sb.lastIndexOf("z"));
assertEquals(-1, sb.lastIndexOf((String) null));
public void testIndexOfStringInt() {
public void testLastIndexOfStringInt() {
public void testContainsChar() {
StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz");
assertTrue (sb.contains('a'));
assertTrue (sb.contains('o'));
assertTrue (sb.contains('z'));
assertFalse (sb.contains('1'));
public void testContainsString() {
StrBuilder sb = new StrBuilder("abcdefghijklmnopqrstuvwxyz");
assertTrue (sb.contains("a"));
assertTrue (sb.contains("pq"));
assertTrue (sb.contains("z"));
assertFalse (sb.contains("zyx"));
public void testMidString() {
StrBuilder sb = new StrBuilder("hello goodbye hello");
assertEquals ("goodbye", sb.midString(6, 7));
assertEquals ("hello", sb.midString(0, 5));
assertEquals ("hello", sb.midString(-5, 5));
assertEquals ("", sb.midString(0, -1));
assertEquals ("", sb.midString(20, 2));
public void testRightString() {
StrBuilder sb = new StrBuilder("left right");
assertEquals ("right", sb.rightString(5));
assertEquals ("", sb.rightString(0));
assertEquals ("", sb.rightString(-5));
assertEquals ("left right", sb.rightString(15));
public void testLeftString() {
StrBuilder sb = new StrBuilder("left right");
assertEquals ("left", sb.leftString(4));
assertEquals ("", sb.leftString(0));
assertEquals ("", sb.leftString(-5));
assertEquals ("left right", sb.leftString(15));
public void testSubstringInt() {
StrBuilder sb = new StrBuilder ("hello goodbye");
assertEquals ("goodbye", sb.substring(6));
assertEquals ("hello goodbye".substring(6), sb.substring(6));
assertEquals ("hello goodbye", sb.substring(0));
assertEquals ("hello goodbye".substring(0), sb.substring(0));
try {
sb.substring(-1);
fail ();
try {
sb.substring(15);
fail ();
public void testSubstringIntInt() {
StrBuilder sb = new StrBuilder ("hello goodbye");
assertEquals ("hello", sb.substring(0, 5));
assertEquals ("hello goodbye".substring(0, 6), sb.substring(0, 6));
assertEquals ("goodbye", sb.substring(6, 13));
assertEquals ("hello goodbye".substring(6,13), sb.substring(6, 13));
assertEquals ("goodbye", sb.substring(6, 20));
try {
sb.substring(-1, 5);
fail();
try {
sb.substring(15, 20);
fail();if (startIndex >= size) {
int strLen = (str == null ? 0 : str.length());
if (startIndex < 0) {
int strLen = (str == null ? 0 : str.length());
assertEquals (0, sb.indexOf("a"));
assertEquals ("abab".indexOf("a"), sb.indexOf("a"));
assertEquals (0, sb.indexOf("ab"));
assertEquals ("abab".indexOf("ab"), sb.indexOf("ab"));
assertEquals ("abab".indexOf("b"), sb.indexOf("b"));
assertEquals ("abab".indexOf("ba"), sb.indexOf("ba"));
assertEquals (-1, sb.indexOf("z"));
assertEquals (2, sb.lastIndexOf("a"));
assertEquals ("abab".lastIndexOf("a"), sb.lastIndexOf("a"));
assertEquals (2, sb.lastIndexOf("ab"));
assertEquals ("abab".lastIndexOf("ab"), sb.lastIndexOf("ab"));
assertEquals ("abab".lastIndexOf("b"), sb.lastIndexOf("b"));
assertEquals ("abab".lastIndexOf("ba"), sb.lastIndexOf("ba"));
assertEquals (-1, sb.lastIndexOf("z"));
assertEquals (2, sb.indexOf("a", 1));
assertEquals (2, sb.indexOf("ab", 1));
assertEquals ("abab".indexOf("ab", 1), sb.indexOf("ab", 1));
assertEquals ("abab".indexOf("b", 2), sb.indexOf("b", 2));
assertEquals ("abab".indexOf("ba", 2), sb.indexOf("ba", 2));
assertEquals (-1, sb.indexOf("z", 2));
assertEquals (2, sb.indexOf("za", 0));
assertEquals (-1, sb.indexOf("za", 3));
assertEquals (0, sb.lastIndexOf("a", 1));
assertEquals ("abab".lastIndexOf("a", 1), sb.lastIndexOf("a", 1));
assertEquals (0, sb.lastIndexOf("ab", 1));
assertEquals ("abab".lastIndexOf("ab", 1), sb.lastIndexOf("ab", 1));
assertEquals ("abab".lastIndexOf("b", 2), sb.lastIndexOf("b", 2));
assertEquals ("abab".lastIndexOf("ba", 2), sb.lastIndexOf("ba", 2));
assertEquals (-1, sb.lastIndexOf("z", 2));
assertEquals (2, sb.lastIndexOf("za", sb.length()));
assertEquals (-1, sb.lastIndexOf("za", 1));sb.setLength(2);if (ch == '\r' || ch == '\n') {
if (last == '\n') {
if (str.charAt(lastIdx - 1) == '\r') {
if (last == '\n') {
if (ret.charAt(lastIdx - 1) == '\r') {
if (last == '\n') {
if (str.charAt(lastIdx - 1) == '\r') {
if (length == size) {return (boolean[]) add( array, index, new Boolean(element), Boolean.TYPE );int removeLen = endIndex = startIndex;
return new String(buf, size - length, size);return lastIndexOf(ch, 0);
char[] thisBuf = buf;
if (thisBuf[i] == ch) {
return lastIndexOf(str, size);
char[] thisBuf = buf;
for (int i = startIndex - strLen; i >= 0; i--) {
if (str.charAt(j) != thisBuf[i + j]) {String.class, ClassUtils.classpublic static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = getSystemProperty("java.util.prefs.PreferencesFactory");
public static String toString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {
return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );
public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
static String format(Token[] tokens, int years, int months, int days, int hours, 
int minutes, int seconds, int milliseconds, boolean padWithZeros) 
if(value instanceof StringBuffer) {
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));
String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);
buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));
public static synchronized FastDateFormat getDateTimeInstance(
int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);List list = new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));
list.add(methodName);
CAUSE_METHOD_NAMES = (String[]) list.toArray(new String[list.size()]);
return (String[]) list.toArray(new String[list.size()]);if (arrayStart == null) {
arrayStart = "";CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);
TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);
(ignoreLen = ignored.isMatch(chars, len, start)) >= 1 &&
token.append(chars, start, Math.min(pos, len) - start);
static final class CharSetMatcher implements Matcher {
CharSetMatcher(char chars[]) {if (JAVA_VERSION == null) {
String str = JAVA_VERSION.substring(0, 3);
if (JAVA_VERSION.length() >= 5) {
str = str + JAVA_VERSION.substring(4, 5);
if (JAVA_VERSION == null) {
String str = JAVA_VERSION.substring(0, 1);
str = str + JAVA_VERSION.substring(2, 3);
if (JAVA_VERSION.length() >= 5) {
str = str + JAVA_VERSION.substring(4, 5);
if (JAVA_VERSION == null) {
return JAVA_VERSION.startsWith(versionPrefix);
if (JAVA_VERSION == null) {
String str = JAVA_VERSION.substring(0, 3);
if (JAVA_VERSION.length() >= 5) {
str = str + JAVA_VERSION.substring(4, 5);
String str = JAVA_VERSION.substring(0, 1);
str = str + JAVA_VERSION.substring(2, 3);
if (JAVA_VERSION.length() >= 5) {
str = str + JAVA_VERSION.substring(4, 5);
if (JAVA_VERSION == null) {
return JAVA_VERSION.startsWith(versionPrefix);if (entityName.charAt(0) == '#') {
char charAt1 = entityName.charAt(1);
if (charAt1 == 'x' || charAt1=='X') {
entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();
entityValue = Integer.parseInt(entityName.substring(1));public static String formatISO(long millis) {
return format(millis, "H:mm:ss.SSS");
public static String format(long millis) {
return format(millis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );
public static String format(long startMillis, long endMillis) {
return format(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );
public static String format(long millis, String format) {
return format(millis, format, true, TimeZone.getDefault());
public static String format(long millis, String format, boolean padWithZeros, TimeZone timezone) {
if(millis >= 28 * DateUtils.MILLIS_PER_DAY) {
Calendar c = Calendar.getInstance(timezone);
c.set(1970, 0, 1, 0, 0, 0);
c.set(Calendar.MILLISECOND, 0);
return format(c.getTime().getTime(), millis, format, padWithZeros, timezone);
int years        = 0;
int months       = 0;
if(Token.containsTokenWithValue(tokens, y) ) {
years = (int) (millis / DateUtils.MILLIS_PER_YEAR);
millis = millis - (years * DateUtils.MILLIS_PER_YEAR);
if(Token.containsTokenWithValue(tokens, M) ) {
months = (int) (millis / DateUtils.MILLIS_PER_MONTH);
millis = millis - (months * DateUtils.MILLIS_PER_MONTH);
if(months == 12) {
years++;
months = 0;
if(Token.containsTokenWithValue(tokens, d) ) {
days = (int) (millis / DateUtils.MILLIS_PER_DAY);
millis = millis - (days * DateUtils.MILLIS_PER_DAY);
if(Token.containsTokenWithValue(tokens, H) ) {
hours = (int) (millis / DateUtils.MILLIS_PER_HOUR);
millis = millis - (hours * DateUtils.MILLIS_PER_HOUR);
if(Token.containsTokenWithValue(tokens, m) ) {
minutes = (int) (millis / DateUtils.MILLIS_PER_MINUTE);
millis = millis - (minutes * DateUtils.MILLIS_PER_MINUTE);
if(Token.containsTokenWithValue(tokens, s) ) {
seconds = (int) (millis / DateUtils.MILLIS_PER_SECOND);
millis = millis - (seconds * DateUtils.MILLIS_PER_SECOND);
if(Token.containsTokenWithValue(tokens, S) ) {
milliseconds = (int) millis;
return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
static String formatDuration(Token[] tokens, int years, int months, int days, int hours, 
int minutes, int seconds, int milliseconds, boolean padWithZeros) 
StringBuffer buffer = new StringBuffer();
int sz = tokens.length;
for(int i=0; i<sz; i++) {
Token token = tokens[i];
Object value = token.getValue();
int count = token.getCount();
if(value instanceof StringBuffer) {
buffer.append(value.toString());
if(value == y) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+years, count, "0") : ""+years ); 
if(value == M) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+months, count, "0") : ""+months ); 
if(value == d) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+days, count, "0") : ""+days ); 
if(value == H) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+hours, count, "0") : ""+hours ); 
if(value == m) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+minutes, count, "0") : ""+minutes ); 
if(value == s) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+seconds, count, "0") : ""+seconds ); 
if(value == S) {
buffer.append( padWithZeros ? StringUtils.leftPad(""+milliseconds, count, "0") : ""+milliseconds ); 
return buffer.toString();
public static String format(long startMillis, long endMillis, String format) {
return format(startMillis, endMillis, format, true, TimeZone.getDefault());
public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {
if(millis < 28 * DateUtils.MILLIS_PER_DAY) {
return format(millis, format, padWithZeros, timezone);
while(months < 0) {
while(days < 0) {
days += 31;  // such overshooting is taken care of later on
while(hours < 0) {
while(minutes < 0) {
while(seconds < 0) {
while(milliseconds < 0) {
milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );
seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );
minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );
hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );
days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );
months -= reduceAndCorrect( start, end, Calendar.MONTH, months );
years -= reduceAndCorrect( start, end, Calendar.YEAR, years );
if(!Token.containsTokenWithValue(tokens, y) ) {
if(Token.containsTokenWithValue(tokens, M) ) {
if(!Token.containsTokenWithValue(tokens, M) ) {
if(!Token.containsTokenWithValue(tokens, d) ) {
if(!Token.containsTokenWithValue(tokens, H) ) {
if(!Token.containsTokenWithValue(tokens, m) ) {
if(!Token.containsTokenWithValue(tokens, s) ) {
return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
if(endValue < startValue) {
public static String formatWords(
long millis,
boolean suppressLeadingZeroElements,
boolean suppressTrailingZeroElements) {
String duration = format(millis, "d' days 'H' hours 'm' minutes 's' seconds'");
if(suppressLeadingZeroElements) {
duration = " " + duration;
String tmp = StringUtils.replaceOnce(duration, " 0 days", "");
if(tmp.length() != duration.length()) {
duration = tmp;
tmp = StringUtils.replaceOnce(duration, " 0 hours", "");
if(tmp.length() != duration.length()) {
duration = tmp;
tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");
duration = tmp;
if(tmp.length() != duration.length()) {
duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");
if(duration.length() != 0) {
duration = duration.substring(1);
if(suppressTrailingZeroElements) {
String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");
if(tmp.length() != duration.length()) {
duration = tmp;
tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");
if(tmp.length() != duration.length()) {
duration = tmp;
tmp = StringUtils.replaceOnce(duration, " 0 hours", "");
if(tmp.length() != duration.length()) {
duration = StringUtils.replaceOnce(tmp, " 0 days", "");
duration = StringUtils.replaceOnce(duration, "1 seconds", "1 second");
duration = StringUtils.replaceOnce(duration, "1 minutes", "1 minute");
duration = StringUtils.replaceOnce(duration, "1 hours", "1 hour");
duration = StringUtils.replaceOnce(duration, "1 days", "1 day");
return duration;
class Token {
static boolean containsTokenWithValue(Token[] tokens, Object value) {
int sz = tokens.length;
for(int i=0; i<sz; i++) {
if(tokens[i].getValue() == value) {
return true;
return false;
private Object value;
private int count;
public Token(Object value) {
this.value = value;
this.count = 1;
Token(Object value, int count) {
this.value = value;
this.count = count;
public void increment() { 
count++;
public int getCount() {
return count;
public Object getValue() {
return value;
public boolean equals(Object obj2) {
if(obj2 instanceof Token) {
Token tok2 = (Token) obj2;
if(this.value.getClass() != tok2.value.getClass()) {
return false;
if(this.count != tok2.count) {
if(this.value instanceof StringBuffer) {
return this.value.toString().equals(tok2.value.toString());
if(this.value instanceof Number) {
return this.value.equals(tok2.value);
return this.value == tok2.value;
return false;
public String toString() {
return StringUtils.repeat(this.value.toString(), this.count);
return DurationFormatUtils.formatISO(getTime());
return DurationFormatUtils.formatISO(getSplitTime());
public void testFormatWords(){
text = DurationFormatUtils.formatWords(50*1000, true, false);
text = DurationFormatUtils.formatWords(65*1000, true, false);
text = DurationFormatUtils.formatWords(120*1000, true, false);
text = DurationFormatUtils.formatWords(121*1000, true, false);
text = DurationFormatUtils.formatWords(72*60*1000, true, false);
text = DurationFormatUtils.formatWords(24*60*60*1000, true, false);
text = DurationFormatUtils.formatWords(50*1000, true, true);
text = DurationFormatUtils.formatWords(65*1000, true, true);
text = DurationFormatUtils.formatWords(120*1000, true, true);
text = DurationFormatUtils.formatWords(121*1000, true, true);
text = DurationFormatUtils.formatWords(72*60*1000, true, true);
text = DurationFormatUtils.formatWords(24*60*60*1000, true, true);
text = DurationFormatUtils.formatWords(50*1000, false, true);
text = DurationFormatUtils.formatWords(65*1000, false, true);
text = DurationFormatUtils.formatWords(120*1000, false, true);
text = DurationFormatUtils.formatWords(121*1000, false, true);
text = DurationFormatUtils.formatWords(72*60*1000, false, true);
text = DurationFormatUtils.formatWords(24*60*60*1000, false, true);
text = DurationFormatUtils.formatWords(50*1000, false, false);
text = DurationFormatUtils.formatWords(65*1000, false, false);
text = DurationFormatUtils.formatWords(120*1000, false, false);
text = DurationFormatUtils.formatWords(121*1000, false, false);
text = DurationFormatUtils.formatWords(72*60*1000, false, false);
text = DurationFormatUtils.formatWords(48*60*60*1000 + 72*60*1000 , false, false);
public void testFormatISOStyle(){
assertEquals("0:00:00.000", DurationFormatUtils.formatISO(time));
assertEquals("0:00:00.001", DurationFormatUtils.formatISO(time));
assertEquals("0:00:00.015", DurationFormatUtils.formatISO(time));
assertEquals("0:00:00.165", DurationFormatUtils.formatISO(time));
assertEquals("0:00:01.675", DurationFormatUtils.formatISO(time));
assertEquals("0:00:13.465", DurationFormatUtils.formatISO(time));
assertEquals("0:01:12.789", DurationFormatUtils.formatISO(time));
assertEquals("0:32:12.789", DurationFormatUtils.formatISO(time));
assertEquals("1:02:12.789", DurationFormatUtils.formatISO(time));
public void testISODurationFormat(){
text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);
assertEquals("P32Y1M22DT9H11M12.1S", text);
text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);
assertEquals("P1Y1M2DT10H30M0.0S", text);
public void testFormat() {
long time = 0;
assertEquals( "0", DurationFormatUtils.format(time, "y") );
assertEquals( "0", DurationFormatUtils.format(time, "M") );
assertEquals( "0", DurationFormatUtils.format(time, "d") );
assertEquals( "0", DurationFormatUtils.format(time, "H") );
assertEquals( "0", DurationFormatUtils.format(time, "m") );
assertEquals( "0", DurationFormatUtils.format(time, "s") );
assertEquals( "0", DurationFormatUtils.format(time, "S") );
assertEquals( "0000", DurationFormatUtils.format(time, "SSSS") );
assertEquals( "0000", DurationFormatUtils.format(time, "yyyy") );
assertEquals( "0000", DurationFormatUtils.format(time, "yyMM") );
time = 60 * 1000;
assertEquals( "0", DurationFormatUtils.format(time, "y") );
assertEquals( "0", DurationFormatUtils.format(time, "M") );
assertEquals( "0", DurationFormatUtils.format(time, "d") );
assertEquals( "0", DurationFormatUtils.format(time, "H") );
assertEquals( "1", DurationFormatUtils.format(time, "m") );
assertEquals( "60", DurationFormatUtils.format(time, "s") );
assertEquals( "60000", DurationFormatUtils.format(time, "S") );
assertEquals( "01:00", DurationFormatUtils.format(time, "mm:ss") );
assertEquals( "36", DurationFormatUtils.format(time, "yM") );
assertEquals( "3 years 6 months", DurationFormatUtils.format(time, "y' years 'M' months'") );
assertEquals( "03/06", DurationFormatUtils.format(time, "yy/MM") );
assertEquals( "310", DurationFormatUtils.format(time, "yM") );
assertEquals( "3 years 10 months", DurationFormatUtils.format(time, "y' years 'M' months'") );
assertEquals( "03/10", DurationFormatUtils.format(time, "yy/MM") );
assertEquals( "40", DurationFormatUtils.format(time, "yM") );
assertEquals( "4 years 0 months", DurationFormatUtils.format(time, "y' years 'M' months'") );
assertEquals( "04/00", DurationFormatUtils.format(time, "yy/MM") );
assertEquals( "48", DurationFormatUtils.format(time, "M") );
assertEquals( "48", DurationFormatUtils.format(time, "MM") );
assertEquals( "048", DurationFormatUtils.format(time, "MMM") );
new Token[] { 
new Token( DurationFormatUtils.y, 1),
new Token( DurationFormatUtils.M, 1),
new Token( DurationFormatUtils.d, 1),
new Token( DurationFormatUtils.H, 1),
new Token( DurationFormatUtils.m, 1),
new Token( DurationFormatUtils.s, 1),
new Token( DurationFormatUtils.S, 1)
new Token[] { 
new Token( DurationFormatUtils.H, 1),
new Token( new StringBuffer(":"), 1),
new Token( DurationFormatUtils.m, 2),
new Token( new StringBuffer(":"), 1),
new Token( DurationFormatUtils.s, 2),
new Token( new StringBuffer("."), 1),
new Token( DurationFormatUtils.S, 3)
new Token[] { 
new Token( new StringBuffer("P"), 1),
new Token( DurationFormatUtils.y, 4),
new Token( new StringBuffer("Y"), 1),
new Token( DurationFormatUtils.M, 1),
new Token( new StringBuffer("M"), 1),
new Token( DurationFormatUtils.d, 1),
new Token( new StringBuffer("DT"), 1),
new Token( DurationFormatUtils.H, 1),
new Token( new StringBuffer("H"), 1),
new Token( DurationFormatUtils.m, 1),
new Token( new StringBuffer("M"), 1),
new Token( DurationFormatUtils.s, 1),
new Token( new StringBuffer("."), 1),
new Token( DurationFormatUtils.S, 1),
new Token( new StringBuffer("S"), 1)
private void assertArrayEquals(Token[] obj1, Token[] obj2) {assertEquals("null must not be null.", t.getMessage());Object newArray = copyArrayGrow1(array, element != null ? element.getClass() : Object.class);
Array.set(newArray, lastIndex(newArray), element);
return (Object[]) newArray;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;
newArray[lastIndex(newArray)] = element;rule = UnpaddedNumberField.INSTANCE_YEAR;double numeratorValue = 0;
numeratorValue = (double) whole * denominator - numerator;
numeratorValue = (double) whole * denominator + numerator;
if (Math.abs(numeratorValue) > Integer.MAX_VALUE) {
int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
return new Fraction(numerator / gcd, denominator / gcd);
return getFraction(
Integer.parseInt(str.substring(0, pos)) + whole * denom,
denom
);
return getFraction(
Integer.parseInt(str.substring(0, pos)),
Integer.parseInt(str.substring(pos + 1))
);
throw new ArithmeticException("Unable to invert a fraction with a zero numerator");
return getFraction(denominator, numerator);
return getFraction(-numerator, denominator);
return getFraction(-numerator, denominator);
double denominatorValue = Math.pow(denominator, power);
double numeratorValue = Math.pow(numerator, power);
if (numeratorValue > Integer.MAX_VALUE || denominatorValue > Integer.MAX_VALUE) {
throw new ArithmeticException("Integer overflow");
if (power < 0) {
return getFraction((int) Math.pow(denominator, -power), 
(int) Math.pow(numerator, -power));
return getFraction((int) Math.pow(numerator, power), 
(int) Math.pow(denominator, power));
private static int greatestCommonDivisor(int number1, int number2) {
int remainder = number1 % number2;
while (remainder != 0) {
number1 = number2;
number2 = remainder;
remainder = number1 % number2;
return number2;
if (fraction == null) {
throw new IllegalArgumentException("The fraction must not be null");
if (numerator == 0) {
return fraction;
if (fraction.numerator == 0) {
return this;
int gcd = greatestCommonDivisor(Math.abs(fraction.denominator), Math.abs(denominator));
int thisResidue = denominator/gcd;
int thatResidue = fraction.denominator/gcd;
double denominatorValue = Math.abs((double) gcd * thisResidue * thatResidue);
double numeratorValue = (double) numerator * thatResidue + fraction.numerator * thisResidue;
if (Math.abs(numeratorValue) > Integer.MAX_VALUE || 
Math.abs(denominatorValue) > Integer.MAX_VALUE) {
throw new ArithmeticException("Integer overflow");
return Fraction.getReducedFraction((int) numeratorValue, (int) denominatorValue);
return add(fraction.negate());
double numeratorValue = (double) numerator * fraction.numerator;
double denominatorValue = (double) denominator * fraction.denominator;
if (Math.abs(numeratorValue) > Integer.MAX_VALUE || 
Math.abs(denominatorValue) > Integer.MAX_VALUE) {
throw new ArithmeticException("Integer overflow");
return getReducedFraction((int) numeratorValue, (int) denominatorValue);
if (numerator == 0) {
return ZERO;
double numeratorValue = (double) numerator * fraction.denominator;
double denominatorValue = (double) denominator * fraction.numerator;
if (Math.abs(numeratorValue) > Integer.MAX_VALUE || 
Math.abs(denominatorValue) > Integer.MAX_VALUE) {
throw new ArithmeticException("Integer overflow");
return getReducedFraction((int) numeratorValue, (int) denominatorValue);
return (numerator == other.numerator &&
denominator == other.denominator);
hashCode = 17;
hashCode = 37 * hashCode + numerator;
hashCode = 37 * hashCode + denominator;
.append(numerator)
.append(denominator).toString();
.append(denominator).toString();
.append(numerator).append('/')
.append(denominator).toString();
private static final int SKIP = 53;
fail("expecting ArithmeticException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
fail("expecting NumberFomatException");
f = Fraction.getFraction(Integer.MAX_VALUE);val.add(fields[i][0], -offset);StringBuffer buffer = new StringBuffer(str.length());
buffer.append(replaceChars.charAt(index));
buffer.append(ch);
return buffer.toString();
assertEquals("q651.506bera", StringUtils.replaceChars("d216.102oren", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789",
"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234"));public static class ClassNameCompartor implements Comparator {
public static final Comparator CLASS_NAME_COMPARATOR = new ClassNameCompartor();
public static class PackageNameCompartor implements Comparator {
public static final Comparator PACKAGE_NAME_COMPARATOR = new PackageNameCompartor();int i = 0;
for (Iterator it = collection.iterator(); it.hasNext(); i++) {if (locale == null) {suite.setName("CalendarUtilsTest Tests");assertEquals("b" + NON_WHITESPACE + "c", res[1]);throw new IllegalArgumentException("The array must not conatin any null elements");
fail("Exception in method ONE prevented invokation: " + t.toString());
fail("Exception in method TWO prevented invokation: " + t.toString());
fail("Exception in method THREE prevented invokation: " + t.toString());return random(count, start, end, letters, numbers, null);
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {
return random(count,start,end,letters,numbers,set,RANDOM);
public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set, Random random) {
if( count == 0 ) {
if( (start == 0) && (end == 0) ) {
if(!letters && !numbers) {
while(count-- != 0) {
if(set == null) {
ch = (char)(random.nextInt(gap) + start);
ch = set[random.nextInt(gap) + start];
if( (letters && numbers && Character.isLetterOrDigit(ch)) ||
(letters && Character.isLetter(ch)) ||
(numbers && Character.isDigit(ch)) ||
(!letters && !numbers)
) 
buffer.append( ch );
public static String random(int count, String set) {
return random(count, set.toCharArray());
public static String random(int count, char[] set) {
return random(count, 0, set.length, false, false, set);
Exception e = null;
r1 = RandomStringUtils.random(-1);
e = e2;
assertNotNull("random(<0) throws exception", e);if("-".equals(str)) {
for(int i=0; i<sz; i++) {
if(ch == '-') {
if(end) {
if(ch == '^') {
if (str == null) {
return null;
if (str == null) {
return null;
if (str == null) {
if (str == null) {
if (str == null) {
return null;
if (str == null) {
return null;
public void testSqueeze() {
assertEquals(null, CharSetUtils.squeeze(null, (String) null));
assertEquals(null, CharSetUtils.squeeze(null, new String[] { "el" }));
assertEquals("hello", CharSetUtils.squeeze("hello", ""));
assertEquals("", CharSetUtils.squeeze("", new String[] { "el" }));
try {
CharSetUtils.squeeze("hello", (String[]) null);
fail("Expecting NullPointerException");
try {
CharSetUtils.squeeze("hello", new String[] { "", null });
fail("Expecting NullPointerException");
public void testCount() {
assertEquals(0, CharSetUtils.count(null, (String) null));
assertEquals(0, CharSetUtils.count(null, new String[] { "el" }));
assertEquals(0, CharSetUtils.count("", new String[] { "el" }));
assertEquals(0, CharSetUtils.count("hello", ""));
try {
CharSetUtils.count("hello", (String[]) null);
fail("Expecting NullPointerException");
try {
CharSetUtils.count("hello", new String[] { "", null });
fail("Expecting NullPointerException");
public void testKeep() {
assertEquals(null, CharSetUtils.keep(null, (String) null));
assertEquals(null, CharSetUtils.keep(null, new String[] { "el" }));
assertEquals("", CharSetUtils.keep("hello", new String[] { "" }));
assertEquals("", CharSetUtils.keep("hello", ""));
try {
CharSetUtils.keep("hello", (String[]) null);
fail("Expecting NullPointerException");
try {
CharSetUtils.keep("hello", new String[] { "", null});
fail("Expecting NullPointerException");
public void testDelete() {
assertEquals(null, CharSetUtils.delete(null,(String) null));
assertEquals(null, CharSetUtils.delete(null, new String[] { "el" }));
try {
CharSetUtils.delete("hello", (String[]) null);
fail("Expecting NullPointerException");
try {
CharSetUtils.delete("hello",  new String[] { "-", null });
fail("Expecting NullPointerException");if ("\r".equals(str) || "\n".equals(str)) {
else {
int inputLength;
if (repeat == 1 || (inputLength = str.length()) == 0) {
if (pads <= 0) {
return str; // returns original String when possible
if (pads <= 0) {
return str; // returns original String when possible": expected '" + StringUtils.escape(expected) +
"' actual '" + StringUtils.escape(actual) + "'",if (str == null) {
if (str.length() == 0) {
throw new NumberFormatException("\"\" is not a valid number.");
if (str == null) {
if (str == null) {
if (str == null) {
if (str == null) {
if (str == null) {
if (str == null) {
Float f = NumberUtils.createFloat("");
fail("createFloat(empty) failed");
Double d = NumberUtils.createDouble("");
fail("createDouble(empty) failed");
Integer i = NumberUtils.createInteger("");
fail("createInteger(empty) failed");
Long l = NumberUtils.createLong("");
fail("createLong(empty) failed");
BigInteger i = NumberUtils.createBigInteger("");
fail("createBigInteger(empty) failed");
BigDecimal d = NumberUtils.createBigDecimal("");
fail("createBigDecimal(empty) failed");if (method != null) {comparison = superHashCode;public CompareToBuilder appendSuper(int superHashCode) {public static final boolean IS_JAVA_1_1 = getJavaVersionMatches("1.1");
public static final boolean IS_JAVA_1_2 = getJavaVersionMatches("1.2");
public static final boolean IS_JAVA_1_3 = getJavaVersionMatches("1.3");
public static final boolean IS_JAVA_1_4 = getJavaVersionMatches("1.4");
public static final boolean IS_JAVA_1_5 = getJavaVersionMatches("1.5");
public static final boolean IS_OS_AIX = getOSMatches("AIX");
public static final boolean IS_OS_HP_UX = getOSMatches("HP-UX");
public static final boolean IS_OS_IRIX = getOSMatches("Irix");
public static final boolean IS_OS_LINUX = getOSMatches("Linux") || getOSMatches("LINUX");
public static final boolean IS_OS_MAC = getOSMatches("Mac");
public static final boolean IS_OS_MAC_OSX = getOSMatches("Mac OS X");
public static final boolean IS_OS_OS2 = getOSMatches("OS/2");
public static final boolean IS_OS_SOLARIS = getOSMatches("Solaris");
public static final boolean IS_OS_SUN_OS = getOSMatches("SunOS");
public static final boolean IS_OS_WINDOWS = getOSMatches("Windows");
public static final boolean IS_OS_WINDOWS_2000 = getOSMatches("Windows", "5.0");
public static final boolean IS_OS_WINDOWS_95 = getOSMatches("Windows 9", "4.0");
public static final boolean IS_OS_WINDOWS_98 = getOSMatches("Windows 9", "4.1");
public static final boolean IS_OS_WINDOWS_ME = getOSMatches("Windows", "4.9");
public static final boolean IS_OS_WINDOWS_NT = getOSMatches("Windows NT");
public static final boolean IS_OS_WINDOWS_XP = getOSMatches("Windows", "5.1");
public static final float JAVA_VERSION_FLOAT = getJavaVersionAsFloat();
public static final int JAVA_VERSION_INT = getJavaVersionAsInt();
public SystemUtils() {import java.util.StringTokenizer;
StringBuffer buffer = new StringBuffer();
char[] chars = str.toCharArray();
int start = 0;
for (int i = 0; i < chars.length; i++) {
if (chars[i] == separatorChar) {
list.add(str.substring(start, i));
start = i + 1;
list.add(str.substring(start));
StringTokenizer tok = null;
tok = new StringTokenizer(str);
tok = new StringTokenizer(str, separatorChars);
int listSize = tok.countTokens();
if (max > 0 && listSize > max) {
listSize = max;
String[] list = new String[listSize];
int i = 0;
int lastTokenBegin = 0;
int lastTokenEnd = 0;
while (tok.hasMoreTokens()) {
if (max > 0 && i == listSize - 1) {
String endToken = tok.nextToken();
lastTokenBegin = str.indexOf(endToken, lastTokenEnd);
list[i] = str.substring(lastTokenBegin);
break;
list[i] = tok.nextToken();
lastTokenBegin = str.indexOf(list[i], lastTokenEnd);
lastTokenEnd = lastTokenBegin + list[i].length();
i++;
return list;
int inputLength = str.length();
char[] input = str.toCharArray();
char[] output = new char[repeat * inputLength];
char ch = input[0];
output[i] = ch;
break;
char ch0 = input[0];
char ch1 = input[1];
output[i] = ch0;
output[i + 1] = ch1;
break;
for (int i = repeat - 1; i >= 0; i--) {
System.arraycopy(input, 0, output, i * inputLength, inputLength);
break;            
return new String(output);
char[] strChars = str.toCharArray();
char ch = strChars[i];
char[] strChars = str.toCharArray();
char ch = strChars[i];if (padStr == null || padStr.length() == 0) {
if (padStr.length() == 1 && size - str.length() <= PAD_LIMIT) {
return rightPad(str, size, padStr.charAt(0));
size = (size - str.length()) / padStr.length();
if (size > 0) {
str += repeat(padStr, size);
return str;
return leftPad(str, size, ' ');
if (padStr == null || padStr.length() == 0) {
if (padStr.length() == 1 && size - str.length() <= PAD_LIMIT) {
size = (size - str.length()) / padStr.length();
if (size > 0) {
str = repeat(padStr, size) + str;
return str;public static String toString(Object array) {
public static String toString(Object array, String stringIfNull) {
public static int hashCode(Object array) {
public static boolean isEquals(Object array1, Object array2) {
public static Map toMap(Object[] array) {
throw new IllegalArgumentException("The array must not be null");            
Map map = new HashMap((int) (array.length * 1.5));
public static Object[] clone(Object[] array) {
public static long[] clone(long[] array) {
public static short[] clone(short[] array) {
public static char[] clone(char[] array) {
public static byte[] clone(byte[] array) {
public static double[] clone(double[] array) {
public static float[] clone(float[] array) {
public static boolean[] clone(boolean[] array) {
public static boolean isSameLength(Object[] array1, Object[] array2) {
public static boolean isSameLength(long[] array1, long[] array2) {
public static boolean isSameLength(int[] array1, int[] array2) {
public static boolean isSameLength(short[] array1, short[] array2) {
public static boolean isSameLength(char[] array1, char[] array2) {
public static boolean isSameLength(byte[] array1, byte[] array2) {
public static boolean isSameLength(double[] array1, double[] array2) {
public static boolean isSameLength(float[] array1, float[] array2) {
public static boolean isSameLength(boolean[] array1, boolean[] array2) {
public static boolean isSameType(Object array1, Object array2) {
throw new IllegalArgumentException("The array must not be null");
public static void reverse(Object[] array) {
public static void reverse(long[] array) {
public static void reverse(int[] array) {
public static void reverse(short[] array) {
public static void reverse(char[] array) {
public static void reverse(byte[] array) {
public static void reverse(double[] array) {
public static void reverse(float[] array) {
public static void reverse(boolean[] array) {
public static int indexOf(Object[] array, Object objectToFind) {
public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
public static int lastIndexOf(Object[] array, Object objectToFind) {
public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
public static boolean contains(Object[] array, Object objectToFind) {if(obj == null) {assertEquals("Expected: null, Actual: null", t.getMessage());
"Expected: java.lang.String, Actual: java.lang.Integer",return (int)Math.random() * n;
return (long)Math.random() * Long.MAX_VALUE;/p>out.write("\\u" + Integer.toHexString(ch));
out.write("\\u0" + Integer.toHexString(ch));
out.write("\\u00" + Integer.toHexString(ch));
out.write("\\u00" + Integer.toHexString(ch));
out.write("\\u000" + Integer.toHexString(ch));
unicode.setLength(4);
unicode.append(ch);
continue;
int sz = str.length();
StringBuffer buffer = new StringBuffer(2 * sz);
for (int i = 0; i < sz; i++) {
char ch = str.charAt(i);
if (ch > 0xfff) {
buffer.append("\\u" + Integer.toHexString(ch));
buffer.append("\\u0" + Integer.toHexString(ch));
buffer.append("\\u00" + Integer.toHexString(ch));
switch (ch) {
case '\b' :
buffer.append('\\');
buffer.append('b');
break;
case '\n' :
buffer.append('\\');
buffer.append('n');
break;
case '\t' :
buffer.append('\\');
buffer.append('t');
break;
case '\f' :
buffer.append('\\');
buffer.append('f');
break;
case '\r' :
buffer.append('\\');
buffer.append('r');
break;
default :
if (ch > 0xf) {
buffer.append("\\u00" + Integer.toHexString(ch));
buffer.append("\\u000" + Integer.toHexString(ch));
break;
switch (ch) {
case '\'' :
buffer.append('\\');
buffer.append('\'');
break;
case '"' :
buffer.append('\\');
buffer.append('"');
break;
case '\\' :
buffer.append('\\');
buffer.append('\\');
break;
default :
buffer.append(ch);
break;
return buffer.toString();
int sz = str.length();
StringBuffer buffer = new StringBuffer(sz);
StringBuffer unicode = new StringBuffer(4);
boolean hadSlash = false;
boolean inUnicode = false;
for (int i = 0; i < sz; i++) {
char ch = str.charAt(i);
if(inUnicode) {
if(unicode.length() == 4) {
try {
int value = Integer.parseInt(unicode.toString(), 16);
buffer.append( (char)value );
unicode.setLength(0);
unicode.setLength(4);
inUnicode = false;
hadSlash = false;
throw new NestableRuntimeException("Unable to parse unicode value: "+unicode, nfe);
unicode.append(ch);
continue;
if(hadSlash) {
hadSlash = false;
switch(ch) {
case '\\': buffer.append('\\'); break;
case '\'': buffer.append('\''); break;
case '\"': buffer.append('"'); break;
case 'r':  buffer.append('\r'); break;
case 'f':  buffer.append('\f'); break;
case 't':  buffer.append('\t'); break;
case 'n':  buffer.append('\n'); break;
case 'b':  buffer.append('\b'); break;
case 'u':  {
inUnicode=true;
break;
default :
buffer.append(ch);
break;
continue;
if(ch == '\\') {
hadSlash = true;
continue;
buffer.append(ch);
if(hadSlash) {
buffer.append('\\');
return buffer.toString();
assertEscapeJava("\\u00fd", "\u00fd");
assertEscapeJava("non-breaking space", "This space is non-breaking:" + "\\u00a0",
assertEscapeJava("\\uabcd\\u1234\\u012c",
assertEquals("unescape(String) failed",
unescaped, StringUtils.unescape(original));
"\\u00fd", StringUtils.escape("\u00fd") );import java.lang.reflect.InvocationTargetException;
if (style == null) {
style = getDefaultStyle();
if (clazz.isArray()) {
reflectionAppendArray(object, clazz, builder);
Field[] fields = clazz.getDeclaredFields();
Field.setAccessible(fields, true);
for (int i = 0; i < fields.length; i++) {
Field f = fields[i];
if ((f.getName().indexOf('$') == -1)
&& (useTransients || !Modifier.isTransient(f.getModifiers()))
&& (!Modifier.isStatic(f.getModifiers()))) {
try {
builder.append(f.getName(), f.get(object));
throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
private static void reflectionAppendArray(Object object, Class clazz, ToStringBuilder builder) {
try {
builder.getClass().getDeclaredMethod("append", new Class[] { clazz.getComponentType().isArray() ? Object.class : clazz }).invoke(
builder,
new Object[] { object });
throw new InternalError("Unexpected SecurityException: " + e.getMessage());
throw new InternalError("Unexpected NoSuchMethodException: " + e.getMessage());
throw new InternalError("Unexpected IllegalArgumentException: " + e.getMessage());
throw new InternalError("Unexpected IllegalAccessException: " + e.getMessage());
throw new InternalError("Unexpected InvocationTargetException: " + e.getMessage());
if (value instanceof Collection) {
public void testReflection() {
assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));package org.apache.commons.lang.time;private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap());
private static final Map cEnumClasses = new HashMap();
final Map map = new HashMap(50);
throw new IllegalArgumentException("The Enum name must not be empty");String methodName = method.getName();
Class[] parameterTypes = method.getParameterTypes();
int paramSize = parameterTypes.length;if (useTransients || !Modifier.isTransient(f.getModifiers())) {
if (!Modifier.isStatic(f.getModifiers())) {
try {
builder.append(f.get(lhs), f.get(rhs));
if (useTransients || !Modifier.isTransient(f.getModifiers())) {
if (!Modifier.isStatic(f.getModifiers())) {
try {
builder.append(f.get(lhs), f.get(rhs));
if (useTransients || !Modifier.isTransient(f.getModifiers())) {
if (!Modifier.isStatic(f.getModifiers())) {
try {
builder.append(f.get(object));
if (useTransients || !Modifier.isTransient(f.getModifiers())) {
if (!Modifier.isStatic(f.getModifiers())) {
try {
builder.append(f.getName(), f.get(object));public static String replace(String text, String repl, String with,
int max) {
if (text == null) {
return null;
package org.apache.commons.lang;
public class StringUtilsTest extends TestCase
public void testCaseFunctions()
public void testJoin()
public void testSplit()
public void testReplaceFunctions()
public void testOverlayString()
public void testRepeat()
public void testCenter()
public void testChompFunctions()
public void testPadFunctions()Entry entry = (Entry) cEnumClasses.get(getClass().getName());
cEnumClasses.put(getClass().getName(), entry);
return Enum.getEnum(getClass(), getName());
if (enumClass == null) {
throw new IllegalArgumentException("The Enum Class must not be null");
Entry entry = (Entry) cEnumClasses.get(enumClass.getName());
if (enumClass == null) {
throw new IllegalArgumentException("The Enum Class must not be null");
if (Enum.class.isAssignableFrom(enumClass) == false) {
throw new IllegalArgumentException("The Class must be a subclass of Enum");
Entry entry = (Entry) cEnumClasses.get(enumClass.getName());
if (enumClass == null) {
throw new IllegalArgumentException("The Enum Class must not be null");
if (Enum.class.isAssignableFrom(enumClass) == false) {
throw new IllegalArgumentException("The Class must be a subclass of Enum");
Entry entry = (Entry) cEnumClasses.get(enumClass.getName());
String shortName = getClass().getName();
String shortName = getClass().getName();return (cls.getDeclaringClass() != null);return reflectionToString(object, null, false);
return reflectionToString(object, style, false);
public static String reflectionToString(Object object, ToStringStyle style, 
boolean outputTransients) {
Field[] fields = object.getClass().getDeclaredFields();
ToStringBuilder builder = new ToStringBuilder(object, style);
throw new InternalError("Unexpected IllegalAccessException");
return builder.toString();
public void testReflection() {
assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));StringBuffer buf = new StringBuffer((int) 1.2 * str.length() * (listSize - i) / listSize);
while (tok.hasMoreTokens()) {
buf.append(tok.nextToken());
if (tok.hasMoreTokens()) {
buf.append(separator);
list[i] = buf.toString();return Modifier.isStatic(member.getModifiers());return min;return Collections.EMPTY_MAP;"getSourceException"range = new CharRange('_');